HTMLDocument2 *pDoc, IMimeMessage *pMsg, IHashTable **ppHash)
{
    HRESULT                 hr;
    IMimeEditTagCollection  *rgpCollect[4];
    IMimeEditTagCollection  *pCollect;
    ULONG                   uCollect,
                            cCollect=0,
                            cItems=0,
                            cCount,
                            cFetched;
    IHashTable              *pHash;
    IMimeEditTag            *pTag;
    BSTR                    bstrSrc;
    LPSTR                   pszUrlA;

    // keep trucking if we fail, to catch as many as we can
    *ppHash = NULL;

    // image collection
    if (CreateOEImageCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // background images
    if (CreateBGImageCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // background sounds
    if (CreateBGSoundCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // active-movie controls (for MSPHONE)
    if (CreateActiveMovieCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // count the number of items we need to package and 
    // prepare a hash-table for duplicate entries
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        Assert (rgpCollect[uCollect]);

        if ((rgpCollect[uCollect])->Count(&cCount)==S_OK)
            cItems+=cCount;
    }

    // create the hashtable
    hr = MimeOleCreateHashTable(cItems, TRUE, &pHash);
    if (FAILED(hr))
        goto error;

    // looks for external references in each
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        pCollect = rgpCollect[uCollect];
        if (pCollect)
        {
            pCollect->Reset();
            
            while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
            {
                Assert (pTag);

                if (pTag->GetSrc(&bstrSrc)==S_OK)
                {
                    pszUrlA = PszToANSI(CP_ACP, bstrSrc);
                    if (pszUrlA)
                    {
                        if (HrFindUrlInMsg(pMsg, pszUrlA, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
                        {
                            // this URL was not in the message and it external
                            // let's track it as a restricted URL in our hash
                            pHash->Insert(pszUrlA, NULL, NOFLAGS);
                        }
                        MemFree(pszUrlA);
                    }
                    SysFreeString(bstrSrc);
                }
                pTag->Release();
            }
            pCollect->Release();
        }
    }
        
    // return our new hash
    *ppHash = pHash;
    pHash = NULL;

error:
    ReleaseObj(pHash);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeutil.cpp ===
// --------------------------------------------------------------------------------
// Mimeutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"
#include "dllmain.h"
#include "mimeutil.h"
#include "demand.h"

HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg)
{
    DWORD   dwFlags=0;

    if (pMsg)
        pMsg->GetFlags(&dwFlags);

    return (dwFlags&IMF_HTML || dwFlags & IMF_PLAIN)? S_OK : S_FALSE;
}

HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody)
{
    ULONG   uBody;

    if (cBody==0 || rghBody==NULL)
        return S_FALSE;

    for (uBody=0; uBody<cBody; uBody++)
        {
        if (HrIsBodyEncoded(pMsg, rghBody[uBody])==S_OK)
            return S_OK;
        }

    return S_FALSE;
}


/*
 * looks for non-7bit or non-8bit encoding
 */
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    LPSTR   lpsz;
    HRESULT hr=S_FALSE;

    if (!FAILED(MimeOleGetBodyPropA(pMsg, hBody, PIDTOSTR(PID_HDR_CNTXFER), NOFLAGS, &lpsz)))
        {
        if (lstrcmpi(lpsz, STR_ENC_7BIT)!=0 && lstrcmpi(lpsz, STR_ENC_8BIT)!=0)
            hr=S_OK;

        SafeMimeOleFree(lpsz);
        }
    return hr;
}

// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer, DWORD cchSize)
{
    INETCSETINFO    rCsetInfo;
    CODEPAGEINFO    rCodePage;
    HRESULT         hr;
    LPSTR           psz;

    if (hCharset == NULL)
        return E_INVALIDARG;

    hr = MimeOleGetCharsetInfo(hCharset, &rCsetInfo);
    if (FAILED(hr))
        goto error;

    hr = MimeOleGetCodePageInfo(rCsetInfo.cpiInternet, &rCodePage);
    if (FAILED(hr))
        goto error;

    psz = rCodePage.szWebCset;

    if (FIsEmpty(psz))      // if no webset, try the body cset
        psz = rCodePage.szBodyCset;

    if (FIsEmpty(psz))
        {
        hr = E_FAIL;
        goto error;
        }

    StrCpyN(lpszBuffer, psz, cchSize);

error:
    return hr;
}



HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HBODY   hBodyParent;

    if (!FAILED(pMsg->GetBody(IBL_PARENT, hBody, &hBodyParent)) &&
            (pMsg->IsContentType(hBodyParent, STR_CNT_MULTIPART, STR_SUB_RELATED)==S_OK))
        return S_OK;
    else
        return S_FALSE;
}


HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    Assert (pMsg && hBody);

    pv.vt = VT_I4;
    pv.lVal = TRUE;
    return pMsg->SetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv);
}

HRESULT HrIsReferencedUrl(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT rVariant;

    rVariant.vt = VT_I4;

    if (!FAILED(pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_RENDERED), NOFLAGS, &rVariant)) && rVariant.ulVal)
        return S_OK;

    return S_FALSE;
}


HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    pv.vt = VT_I4;



    if (pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv)==S_OK &&
        pv.vt == VT_I4 && pv.lVal == TRUE)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT hr=S_OK;

    if (pMsg && hBody)
        {
        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsReferencedUrl(pMsg, hBody)==S_OK)
                    {
                    hr = HrMarkGhosted(pMsg, hBody);
                    if (FAILED(hr))
                        goto error;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }
        }
error:
    return hr;
}


HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT     hr=S_OK;
    ULONG       cKids=0,
                uKid;
    LPHBODY     rghKids=0;

    pMsg->CountBodies(hBody, FALSE, &cKids);
    if (cKids)
        {
        if (!MemAlloc((LPVOID *)&rghKids, sizeof(HBODY) * cKids))
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }

        cKids = 0;

        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsGhosted(pMsg, hBody)==S_OK)
                    {
                    rghKids[cKids++] = hBody;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }

        for (uKid = 0; uKid < cKids; uKid++)
            {
            hr=pMsg->DeleteBody(rghKids[uKid], 0);
            if (FAILED(hr))
                goto error;
            }

        }

error:
    SafeMemFree(rghKids);
    return hr;
}

UINT uCodePageFromCharset(HCHARSET hCharset)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = GetACP();

    if (hCharset &&
        (MimeOleGetCharsetInfo(hCharset, &CsetInfo)==S_OK))
        uiCodePage = CsetInfo.cpiInternet ;

    return uiCodePage;
}

UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg)
{
    HCHARSET hCharset=0;

    if (pMsg)
        pMsg->GetCharset(&hCharset);
    return uCodePageFromCharset(hCharset);
}



HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstmOut)
{
    IMimeBody   *pBody;
    HRESULT     hr;

    hr = MimeOleCreateBody(&pBody);
    if (!FAILED(hr))
        {
        hr = pBody->InitNew();
        if (!FAILED(hr))
            {
            hr = pBody->SetData(IET_UNICODE, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, pstmW);
            if (!FAILED(hr))
                {
                hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
                if (!FAILED(hr))
                    hr =  pBody->GetData(IET_INETCSET, ppstmOut);
                }
            }
        pBody->Release();
        }
    return hr;
}


HRESULT HrCopyHeader(LPMIMEMESSAGE pMsgDest, HBODY hBodyDest, LPMIMEMESSAGE pMsgSrc, HBODY hBodySrc, LPCSTR pszName)
{
    LPSTR   lpszProp;
    HRESULT hr;

    hr = MimeOleGetBodyPropA(pMsgSrc, hBodySrc, pszName, NOFLAGS, &lpszProp);
    if (!FAILED(hr))
        {
        hr = MimeOleSetBodyPropA(pMsgDest, hBodyDest, pszName, NOFLAGS, lpszProp);
        SafeMimeOleFree(lpszProp);
        }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeapi.cpp ===
#include <pch.hxx>
#include "dllmain.h"
#include "demand.h"
#include "resource.h"
#include "saferun.h"
#include "viewsrc.h"
#include "triutil.h"
#include "mhtml.h"

MIMEOLEAPI MimeEditViewSource(HWND hwndParent, IMimeMessage *pMsg)
{
    TraceCall("MimeEditViewSource");

    return ViewSource(hwndParent, pMsg);
}

MIMEOLEAPI MimeEditVerifyTrust(HWND hwnd, LPCSTR pszFileName, LPCSTR pszPathName)
{
    LPWSTR  pszFileNameW = NULL,
            pszPathNameW = NULL; 
    HRESULT hr = S_OK;

    TraceCall ("MimeEditVerifyTrust");

    AssertSz(pszFileName, "Someone forgot to pass in name. Bummer.");
    AssertSz(pszPathName, "Someone forgot to pass in name. Bummer.");

    IF_NULLEXIT(pszFileNameW = PszToUnicode(CP_ACP, pszFileName));
    IF_NULLEXIT(pszPathNameW = PszToUnicode(CP_ACP, pszPathName));

    hr = VerifyTrust(hwnd, pszFileNameW, pszFileNameW);

exit:
    MemFree(pszFileNameW);
    MemFree(pszPathNameW);

    return TraceResult(hr);
}

MIMEOLEAPI MimeEditIsSafeToRun(HWND hwnd, LPCSTR pszFileName, BOOL fPrompt)
{
    HRESULT hr = S_OK;
    LPWSTR pwszFileName;

    TraceCall ("MimeEditIsSafeToRun");

    Assert(pszFileName);

    IF_NULLEXIT(pwszFileName = PszToUnicode(CP_ACP, pszFileName));
    IF_FAILEXIT(hr = IsSafeToRun(hwnd, pwszFileName, fPrompt));

exit:    
    MemFree(pwszFileName);

    return hr;
}


MIMEOLEAPI MimeEditGetBackgroundImageUrl(IUnknown *pDocUnk, BSTR *pbstr)
{
    IHTMLDocument2  *pDoc;
    HRESULT         hr;

    TraceCall ("MimeEditGetBackgroundImageUrl");

    if (pDocUnk == NULL || pbstr == NULL)
        return E_INVALIDARG;

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (!FAILED(hr))
    {
        hr = GetBackgroundImage(pDoc, pbstr);
        pDoc->Release();
    }
    return hr;
}

MIMEOLEAPI MimeEditCreateMimeDocument(IUnknown *pDocUnk, IMimeMessage *pMsgSrc, DWORD dwFlags, IMimeMessage **ppMsg)
{
    HRESULT         hr;
    IMimeMessage    *pMsg=0;
    IHTMLDocument2  *pDoc=0;
    
    TraceCall ("MimeEditCreateMimeDocument");

    if (pDocUnk == NULL || ppMsg == NULL)
        return TraceResult(E_INVALIDARG);

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (FAILED(hr))
        goto error;

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
        goto error;

    hr = SaveAsMHTML(pDoc, dwFlags, pMsgSrc, pMsg, NULL);
    if (FAILED(hr))
        goto error;

    *ppMsg = pMsg;
    pMsg = NULL;

error:
    ReleaseObj(pMsg);
    ReleaseObj(pDoc);
    return hr;
}


MIMEOLEAPI MimeEditDocumentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv)
{
    TraceCall ("MimeEditDocumentFromStream");

    if (pstm==NULL || ppv==NULL)
        return TraceResult(E_FAIL);
        
    return HrCreateSyncTridentFromStream(pstm, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\oleutil.cpp ===
/*
 *    o l e u t i l . c p p
 *    
 *    Purpose:
 *        OLE utilities
 *
 *  History
 *      Feb '97: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include "pch.hxx"
#include "msoert.h"
#include "oleutil.h"
#include "demand.h"

ASSERTDATA



HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm)
{
    LPDATAOBJECT            pDataObj=0;
    HRESULT                 hr;
    FORMATETC               fetc={cf, 0, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM               stgmed;

    ZeroMemory(&stgmed, sizeof(STGMEDIUM));

    if (!pUnk || !ppstm)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObj);
    if(FAILED(hr))
        goto error;

    hr=pDataObj->GetData(&fetc, &stgmed);
    if(FAILED(hr))
        goto error;

    Assert(stgmed.pstm);
    *ppstm = stgmed.pstm;
    (*ppstm)->AddRef();

    // addref the pUnk as it will be release in releasestgmed
    if(stgmed.pUnkForRelease)
        stgmed.pUnkForRelease->AddRef();
    ReleaseStgMedium(&stgmed);

error:
    ReleaseObj(pDataObj);
    return hr;
}


HRESULT CmdSelectAllCopy(LPOLECOMMANDTARGET pCmdTarget)
{
    HRESULT hr;

    if (!pCmdTarget)
        return E_FAIL;

    hr=pCmdTarget->Exec(NULL, OLECMDID_SELECTALL, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    if (FAILED(hr))
        goto error;

    hr=pCmdTarget->Exec(NULL, OLECMDID_COPY, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    if (FAILED(hr))
        goto error;
error:
    return hr;
}

HRESULT HrInitNew(LPUNKNOWN pUnk)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->InitNew();

error:
    ReleaseObj(ppsi);
    return hr;
}

HRESULT HrIPersistStreamInitLoad(LPUNKNOWN pUnk, LPSTREAM pstm)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        goto error;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->Load(pstm);

error:
    ReleaseObj(ppsi);
    return hr;
}



HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;
    WCHAR           szFileW[MAX_PATH];

    Assert(lstrlen(lpszFile) <= MAX_PATH);

    if (lpszFile == NULL || *lpszFile == NULL)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    if(!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszFile, -1, szFileW, MAX_PATH))
        {
        hr=E_FAIL;
        goto error;
        }

    hr=ppf->Save(szFileW, FALSE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}


HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;
    WCHAR           szFileW[MAX_PATH];

    Assert(lstrlen(lpszFile) <= MAX_PATH);

    if (lpszFile == NULL || *lpszFile == NULL)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    if(!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszFile, -1, szFileW, MAX_PATH))
        {
        hr=E_FAIL;
        goto error;
        }

    hr=ppf->Load(szFileW, STGM_READ|STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}



HRESULT GetDispProp(IDispatch * pDisp, DISPID dispid, LCID lcid, VARIANT *pvar, EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    Assert(pDisp);
    Assert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    return (pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr));
}

HRESULT SetDispProp(IDispatch *pDisp, DISPID dispid, LCID lcid, VARIANTARG *pvarg, EXCEPINFO *pexcepinfo, DWORD dwFlags)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT;     // Dispid of prop arg.
    DISPPARAMS  dp;                                 // Params for Invoke
    UINT        uiErr;                              // Invoke error param.

    Assert(pDisp);
    Assert(pvarg);

    dp.rgvarg = pvarg;
    dp.cArgs = 1;

    if (dwFlags & DISPATCH_METHOD)
    {
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = NULL;
    }
    else
    {
        dp.cNamedArgs = 1;
        dp.rgdispidNamedArgs = &dispidPut;
    }

    return pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            (UINT)dwFlags,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);
}

HRESULT HrLoadSync(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    LPSTREAM    pstm=0;
    HRESULT     hr;

    hr = OpenFileStream(lpszFile, OPEN_EXISTING	, GENERIC_READ, &pstm);
    if (SUCCEEDED(hr))
        {
        hr = HrIPersistStreamInitLoad(pUnk, pstm);
        pstm->Release();
        }
   return hr;    
}


HRESULT HrCoTaskStringDupeToW(LPCSTR lpsz, LPOLESTR *ppszW)
{
    HRESULT hr = NOERROR;
    ULONG   cch, cchRet;
    LPCSTR  lpszPath;

    if (lpsz == NULL || ppszW == NULL)
        return E_INVALIDARG;

    *ppszW = 0;

    cch = lstrlen(lpsz)+1;

    // allocate a wide-string with enough character to hold string
    *ppszW=(LPOLESTR)CoTaskMemAlloc(cch * sizeof(OLECHAR));
    if(!*ppszW)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    cchRet=MultiByteToWideChar(CP_ACP, 0, lpsz, cch, *ppszW, cch);
    if(!cchRet)
        {
        hr=E_FAIL;
        goto error;
        }

error:
    if(FAILED(hr))
        CoTaskMemFree(*ppszW);
    return hr;
}

#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN Debug Code
//

void DebugPrintInterface(REFIID riid, char *szPrefix)
{
    LPOLESTR    pszW=0;
    char        szGuid[MAX_PATH];
    char        szTmp[MAX_PATH];
    char        szOut[MAX_PATH];
    LONG        cb=MAX_PATH;
    HKEY        hk=0;

    TraceCall("DebugPrintInterface");
    
    AssertSz(szPrefix, "Hey! Atleast pass an empty string!");

    StringFromIID(riid, &pszW);

    WideCharToMultiByte(CP_ACP, 0, pszW, -1, szGuid, MAX_PATH, NULL, NULL);
        
    StrCpyN(szTmp, "SOFTWARE\\Classes\\Interface\\", ARRAYSIZE(szTmp));
    StrCatBuff(szTmp, szGuid, ARRAYSIZE(szTmp));
    
    if((RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, KEY_QUERY_VALUE, &hk)==ERROR_SUCCESS) &&
        RegQueryValue(hk, NULL, szTmp, &cb)==ERROR_SUCCESS)
        wnsprintf(szOut, ARRAYSIZE(szOut), "%s: {%s}", szPrefix, szTmp);
    else    
        wnsprintf(szOut, ARRAYSIZE(szOut), "%s: [notfound] %s", szPrefix, szGuid);

    TraceInfo(szOut);

    if(hk)
        RegCloseKey(hk);
    if(pszW)
        CoTaskMemFree(pszW);
}

void DebugPrintCmdIdBlock(ULONG cCmds, OLECMD *rgCmds)
{
    char    sz[255],
            szT[255];

    TraceCall("DebugPrintCmdIdBlock");
    wnsprintf(sz, ARRAYSIZE(sz), "CmdId:: {%d,{", cCmds);
    for (ULONG ul=0;ul<cCmds; ul++)
        {
        switch (rgCmds[ul].cmdID)
            {
            case OLECMDID_COPY:
                StrCatBuff(sz, "copy", ARRAYSIZE(sz));
                break;

            case OLECMDID_CUT:
                StrCatBuff(sz, "cut", ARRAYSIZE(sz));
                break;
            
            case OLECMDID_PASTE:
                StrCatBuff(sz, "paste", ARRAYSIZE(sz));
                break;

            default:
                wnsprintf(szT, ARRAYSIZE(szT), "%d", rgCmds[ul].cmdID);
                StrCatBuff(sz, szT, ARRAYSIZE(sz));
            }
            if(ul+1!=cCmds)
                StrCatBuff(sz, ", ", ARRAYSIZE(sz));
        }

    StrCatBuff(sz, "}}", ARRAYSIZE(sz));
//    TraceInfo(sz);    // Turning down the noise
}


//
//  END Debug Code
//
/////////////////////////////////////////////////////////////////////////////
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeutil.h ===
// --------------------------------------------------------------------------------
// Mimeutil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIMEUTIL_H
#define __MIMEUTIL_H

#define SafeMimeOleFree SafeMemFree

// --------------------------------------------------------------------------------
// Random Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrComputeLineCount(LPMIMEMESSAGE pMsg, LPDWORD pdw);
HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody);
HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg);
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrCopyHeader(LPMIMEMESSAGE pMsgDest, HBODY hBodyDest, LPMIMEMESSAGE pMsgSrc, HBODY hBodySrc, LPCSTR pszName);

// --------------------------------------------------------------------------------
// MHTML Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt);

// --------------------------------------------------------------------------------
// Random functions that probably shouldn't even be in this file
// --------------------------------------------------------------------------------
HRESULT HrEscapeQuotedString (LPTSTR pszIn, LPTSTR *ppszOut);
// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer, DWORD cchSize);

// --------------------------------------------------------------------------------
// international support
// --------------------------------------------------------------------------------
UINT uCodePageFromCharset(HCHARSET hCharset);
UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg);
HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstm);

// --------------------------------------------------------------------------------
// functions for ghosting props
// --------------------------------------------------------------------------------
HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody);

#endif // __MIMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\oleutil.h ===
/*
 *    o l e u t i l . h
 *    
 *    Purpose: OLE utilities
 *
 *    Owner: brettm 
 *
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _OLEUTIL_H
#define _OLEUTIL_H

#include <docobj.h>

/* 
 * Persist Functions
 */
HRESULT HrInitNew(LPUNKNOWN pUnk);
HRESULT HrIPersistStreamLoad(LPUNKNOWN pUnk, LPSTREAM pstm);
HRESULT HrIPersistStreamInitLoad(LPUNKNOWN pUnk, LPSTREAM pstm);
HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR lpszFile);
HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR lpszFile);
HRESULT HrLoadSync(LPUNKNOWN pUnk, LPSTR lpszFile);

/*
 * Data Object functions
 */
HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm);
HRESULT CmdSelectAllCopy(LPOLECOMMANDTARGET pCmdTarget);

/*
 * IDispatch Helpers
 */
HRESULT GetDispProp(IDispatch * pDisp, DISPID dispid, LCID lcid, VARIANT *pvar, EXCEPINFO * pexcepinfo);
HRESULT SetDispProp(IDispatch *pDisp, DISPID dispid, LCID lcid, VARIANTARG *pvarg, EXCEPINFO *pexcepinfo, DWORD dwFlags);

/* 
 * OLE Allocator Helpers
 */
HRESULT HrCoTaskStringDupeToW(LPCSTR lpsz, LPOLESTR *ppszW);

#define SafeCoTaskMemFree(_pv)	\
	{							\
    if (_pv)					\
        {						\
        CoTaskMemFree(_pv);		\
        _pv=NULL;				\
        }                       \
    }

/* 
 * Debug Helpers
 */
#ifdef DEBUG
void DebugPrintInterface(REFIID riid, char *szPrefix);
void DebugPrintCmdIdBlock(ULONG cCmds, OLECMD *rgCmds);
#else
#define DebugPrintInterface       1 ? (void)0 : (void)
#define DebugPrintCmdIdBlock         1 ? (void)0 : (void)
#endif

#define RECT_WIDTH(_prc) (_prc->right - _prc->left)
#define RECT_HEIGHT(_prc) (_prc->bottom - _prc->top)

#endif //_OLEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\plainstm.h ===
/*
 *    p l a i n c n v . h
 *    
 *    Purpose:
 *        Plain Stream -> html converter
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _PLAINCONV_H
#define _PLAINCONV_H

#define CCHMAX_BUFFER       8192

class CPlainConverter
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    CPlainConverter();
    ~CPlainConverter();

    HRESULT HrConvert(LPSTREAM pstmPlain, WCHAR chQuoteW, LPSTREAM *ppstmHtml);

private:
    ULONG                   m_cRef;
    LPSTREAM                m_pstmPlain,
                            m_pstmOut;
    ULONG                   m_cchOut,
                            m_cchBuffer,
                            m_cchPos,
                            m_nSpcs;
    BOOL                    m_fCRLF;
    WCHAR                   m_rgchOutBufferW[CCHMAX_BUFFER];
    WCHAR                   m_rgchBufferW[CCHMAX_BUFFER],
                            m_chQuoteW;

    HRESULT HrParseStream();
    HRESULT HrWrite(LPCWSTR pszW, ULONG cch);
    HRESULT HrOutputSpaces(ULONG cSpaces);
    inline HRESULT HrOutputQuoteChar();

};

typedef CPlainConverter *LPPLAINCONVERTER;

HRESULT HrConvertPlainStreamW(LPSTREAM pstm, WCHAR chQuote, LPSTREAM *ppstmHtml);
HRESULT HrConvertHTMLToFormat(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf);

HRESULT EscapeStringToHTML(LPWSTR pwszIn, LPWSTR *ppwszOut);

#endif //_PLAINCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\plainstm.cpp ===
/*
 *    p l a i n s t m . c p p
 *
 *    Purpose:
 *        IStream implementation that wraps a plain stream as html and does URL detection
 *
 *  History
 *      September '96: brettm - created
 *
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "strconst.h"
#include "plainstm.h"
#include "triutil.h"
#include "oleutil.h"
#include "demand.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  t y p e d e f s
 */

/*
 *  c o n s t a n t s
 */
#define MAX_URL_SIZE            8+1

#define WCHAR_BYTES(_lpsz)     (sizeof(_lpsz) - sizeof(WCHAR))
#define WCHAR_CCH(_lpsz)       (WCHAR_BYTES(_lpsz)/sizeof(WCHAR))

static const WCHAR  c_szHtmlNonBreakingSpaceW[]  =L"&nbsp;",
                    c_szHtmlBreakW[]             =L"<BR>\r\n",
                    c_szSpaceW[]                 =L" ",
                    c_szEscGreaterThanW[]        =L"&gt;",
                    c_szEscLessThanW[]           =L"&lt;",
                    c_szEscQuoteW[]              =L"&quot;",
                    c_szEscAmpersandW[]          =L"&amp;";
                    
#define chSpace         ' '
#define chCR            '\r'
#define chLF            '\n'
#define chQuoteChar     '\"' 
#define chLessThan      '<'
#define chGreaterThan   '>'
#define chAmpersand     '&'

#define IsSpecialChar(_ch)  ( _ch == chLessThan || _ch == chSpace || _ch == chCR || _ch == chLF || _ch == chQuoteChar || _ch == chLessThan || _ch == chGreaterThan || _ch == chAmpersand )

/*
 *  g l o b a l s
 */
enum
{
    escInvalid=-1,
    escGreaterThan=0,
    escLessThan,
    escAmpersand,
    escQuote
};

/*
 *  f u n c t i o n   p r o t y p e s
 */


/*
 *  f u n c t i o n s
 */

HRESULT HrConvertPlainStreamW(LPSTREAM pstm, WCHAR chQuoteW, LPSTREAM *ppstmHtml)
{
    LPPLAINCONVERTER    pPlainConv=0;
    HRESULT             hr;

    if (!(pPlainConv=new CPlainConverter()))
        return E_OUTOFMEMORY;

    hr=pPlainConv->HrConvert(pstm, chQuoteW, ppstmHtml);
    if (FAILED(hr))
        goto error;

    HrRewindStream(*ppstmHtml);

error:
    ReleaseObj(pPlainConv);
    return hr;
}



CPlainConverter::CPlainConverter()
{
    m_cRef=1;
    m_pstmPlain=NULL;
    m_pstmOut=NULL;
    m_cchPos = 0;
    m_cchBuffer = 0;
    m_cchOut = 0;
    m_fCRLF = 0;
}

CPlainConverter::~CPlainConverter()
{
    SafeRelease(m_pstmPlain);
    SafeRelease(m_pstmOut);
}

HRESULT CPlainConverter::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    if (!*lplpObj)
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CPlainConverter::AddRef()
{
    return ++m_cRef;
}

ULONG CPlainConverter::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CPlainConverter::HrWrite(LPCWSTR pszW, ULONG cch)
{
    ULONG   cb;
    HRESULT hr=S_OK;

    AssertSz(cch <= sizeof(m_rgchOutBufferW)/sizeof(WCHAR), "Hey! why are you writing too much out at once");

    if (m_cchOut + cch > sizeof(m_rgchOutBufferW)/sizeof(WCHAR))
        {
        // fill buffer then flush it
        cb = sizeof(m_rgchOutBufferW) - (m_cchOut*sizeof(WCHAR));
        CopyMemory((LPVOID)&m_rgchOutBufferW[m_cchOut], (LPVOID)pszW, cb);
        hr = m_pstmOut->Write(m_rgchOutBufferW, sizeof(m_rgchOutBufferW), NULL);
        
        // we just filled the buffer with an extra cb off the string, so copy the rest into 
        pszW = (LPCWSTR)((LPBYTE)pszW + cb);
        cch -= cb / sizeof(WCHAR);
        CopyMemory((LPVOID)m_rgchOutBufferW, (LPVOID)pszW, cch*sizeof(WCHAR));
        m_cchOut=cch;
        }
    else
        {
        CopyMemory((LPVOID)&m_rgchOutBufferW[m_cchOut], (LPVOID)pszW, cch*sizeof(WCHAR));
        m_cchOut+=cch;
        }
    return hr;
}

HRESULT CPlainConverter::HrConvert(LPSTREAM pstm, WCHAR chQuoteW, LPSTREAM *ppstmHtml)
{
    HRESULT         hr;

    if (ppstmHtml==NULL)
        return E_INVALIDARG;

    // caller wants a stream created? or use his own??
    if (*ppstmHtml==NULL)
        {
        if (FAILED(MimeOleCreateVirtualStream(&m_pstmOut)))
            return E_OUTOFMEMORY;
        }
    else
        {
        m_pstmOut=*ppstmHtml;
        }

    m_pstmPlain=pstm;
    if (pstm)
        pstm->AddRef();

    if (m_pstmPlain)
        {
        hr=HrRewindStream(m_pstmPlain);
        if (FAILED(hr))
            goto error;
        }

    m_nSpcs=0;
    m_chQuoteW=chQuoteW;

    if (m_pstmPlain)
        {
        // if quoting, quote the first line.
        HrOutputQuoteChar();
        hr = HrParseStream();
        }

    if (m_cchOut)
        hr = m_pstmOut->Write(m_rgchOutBufferW, m_cchOut*sizeof(WCHAR), NULL);

    *ppstmHtml=m_pstmOut;

error:
    m_pstmOut = NULL;
    return hr;
}


HRESULT CPlainConverter::HrParseStream()
{
    LPSTREAM    pstmOut=m_pstmOut;
    ULONG       cchLast;

    Assert(pstmOut);


    ULONG   cb;

    Assert(m_pstmPlain);

    m_pstmPlain->Read(m_rgchBufferW, sizeof(m_rgchBufferW), &cb);
    m_cchBuffer = cb / sizeof(WCHAR);
    m_cchPos=0;

    // Raid 63406 - OE doesn't skip byte order marks when inlining unicode text
    if (cb >= 4 && *m_rgchBufferW == 0xfeff)
        m_cchPos++;

    while (cb)
        {
        if (m_nSpcs && m_rgchBufferW[m_cchPos] != chSpace)
            {
            // this character is not a space, and we have spaces queued up, output
            // spaces before the character
            HrOutputSpaces(m_nSpcs);
            m_nSpcs = 0;
            }

        switch (m_rgchBufferW[m_cchPos])
            {
            case chSpace:                   // queue spaces
                m_nSpcs++;                
                break;

            case chCR:                      // swallow carriage returns as they are always in CRLF pairs.
                break;

            case chLF:
                // if we're quoting, insert a quote after the CRLF.
                HrWrite(c_szHtmlBreakW, WCHAR_BYTES(c_szHtmlBreakW)/sizeof(WCHAR));
                HrOutputQuoteChar();
                m_fCRLF = 1;
                break;

            case chQuoteChar:
                HrWrite(c_szEscQuoteW, WCHAR_BYTES(c_szEscQuoteW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;
    
            case chLessThan:
                HrWrite(c_szEscLessThanW, WCHAR_BYTES(c_szEscLessThanW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            case chGreaterThan:
                HrWrite(c_szEscGreaterThanW, WCHAR_BYTES(c_szEscGreaterThanW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            case chAmpersand:
                HrWrite(c_szEscAmpersandW, WCHAR_BYTES(c_szEscAmpersandW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            default:
                // set the last pointer and pull these up...
                cchLast = m_cchPos;
                m_cchPos++;
                while (m_cchPos < m_cchBuffer &&
                        !IsSpecialChar(m_rgchBufferW[m_cchPos]))
                    {
                    m_cchPos++;
                    }                
                HrWrite(&m_rgchBufferW[cchLast], m_cchPos - cchLast);
                m_cchPos--;     //rewind as we INC below
                m_fCRLF = 0;
                break;
            }
        
        m_cchPos++;
        Assert(m_cchPos <= m_cchBuffer);
        if (m_cchPos == m_cchBuffer)
            {
            // hit end of buffer, re-read next block
            m_pstmPlain->Read(m_rgchBufferW, sizeof(m_rgchBufferW), &cb);
            m_cchPos=0;
            m_cchBuffer = cb / sizeof(WCHAR);
            }
        }


    return S_OK;
}



HRESULT CPlainConverter::HrOutputQuoteChar()
{
    if (m_chQuoteW)
        {
        // don't bother escaping all quote chars as we only use ">|:"
        AssertSz(m_chQuoteW != '<' && m_chQuoteW != '&' && m_chQuoteW != '"', "need to add support to escape these, if we use them as quote chars!!");
        if (m_chQuoteW== chGreaterThan)
            HrWrite(c_szEscGreaterThanW, WCHAR_BYTES(c_szEscGreaterThanW)/sizeof(WCHAR));
        else
            HrWrite(&m_chQuoteW, 1);
        HrWrite(L" ", 1);
        }
    return S_OK;
}

HRESULT CPlainConverter::HrOutputSpaces(ULONG cSpaces)
{
    if (cSpaces == 1 && m_fCRLF)    // if we get "\n foo" make sure it's an nbsp;
        return HrWrite(c_szHtmlNonBreakingSpaceW, WCHAR_CCH(c_szHtmlNonBreakingSpaceW));


    while (--cSpaces)
        HrWrite(c_szHtmlNonBreakingSpaceW, WCHAR_CCH(c_szHtmlNonBreakingSpaceW));

    return HrWrite(c_szSpaceW, 1);
}



/*
 * Warning This Function Trashes the Input Buffer aka: strtok
 *
 */
HRESULT EscapeStringToHTML(LPWSTR pwszIn, LPWSTR *ppwszOut)
{   
    int         cchPos,
                esc=escInvalid,
                cb = 0;
    LPWSTR      pwszText = pwszIn,
                pwszWrite = NULL,
                pwszEnd = NULL;
    HRESULT     hr = S_OK;

    if (!pwszIn)
        return S_OK;

    // count space required
    while (*pwszText)
    {
        switch (*pwszText)
        {
            case chGreaterThan:
                cb += WCHAR_BYTES(c_szEscGreaterThanW);
                break;
    
            case chLessThan:
                cb += WCHAR_BYTES(c_szEscLessThanW);
                break;
    
            case chAmpersand:
                cb += WCHAR_BYTES(c_szEscAmpersandW);
                break;
    
            case chQuoteChar:
                cb += WCHAR_BYTES(c_szEscQuoteW);
                break;
        
            default:
                cb += sizeof(*pwszText);
        }
        
        pwszText++;
    }

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwszWrite, cb+sizeof(WCHAR)));

    pwszText = pwszIn;
    *ppwszOut = pwszWrite;
    pwszEnd = pwszWrite + (cb/sizeof(WCHAR));

    // count space required
    while (*pwszText)
    {
        switch (*pwszText)
        {
            case chGreaterThan:
                StrCpyNW(pwszWrite, c_szEscGreaterThanW, (DWORD)(pwszEnd-pwszWrite));
                pwszWrite += WCHAR_CCH(c_szEscGreaterThanW);
                break;

            case chLessThan:
                StrCpyNW(pwszWrite, c_szEscLessThanW, (DWORD)(pwszEnd-pwszWrite));
                pwszWrite += WCHAR_CCH(c_szEscLessThanW);
                break;

            case chQuoteChar:
                StrCpyNW(pwszWrite, c_szEscQuoteW, (DWORD)(pwszEnd-pwszWrite));
                pwszWrite += WCHAR_CCH(c_szEscQuoteW);
                break;

            case chAmpersand:
                StrCpyNW(pwszWrite, c_szEscAmpersandW, (DWORD)(pwszEnd-pwszWrite));
                pwszWrite += WCHAR_CCH(c_szEscAmpersandW);
                break;
    
            default:
                *pwszWrite++ = *pwszText;
        }

        pwszText++;
    }
    *pwszWrite = 0;
    pwszWrite = NULL;

exit:
    MemFree(pwszWrite);
    return S_OK;
}


HRESULT HrConvertHTMLToFormat(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf)
{
    HRESULT     hr;
    LPUNKNOWN   pUnkTrident=0;
    LPSTREAM    pstmPlain=0;

    if (!ppstm)
        return E_INVALIDARG;

    hr = HrCreateSyncTridentFromStream(pstmHtml, IID_IUnknown, (LPVOID *)&pUnkTrident);
    if (FAILED(hr))
        goto error;

    hr = HrGetDataStream(pUnkTrident, cf, &pstmPlain);
    if (FAILED(hr))
        goto error;

    *ppstm = pstmPlain;
    pstmPlain->AddRef();

error:
    ReleaseObj(pUnkTrident);
    ReleaseObj(pstmPlain);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\saferun.h ===
#ifndef _SAFERUN_H
#define _SAFERUN_H

/*
 * IsSafeToRun
 *
 * return codes:
 *   S_OPENFILE : file should be opened
 *   S_SAVEFILE : file should be saved
 *
 * errors:
 *   E_FAIL, E_INVALIDARG, hrUserCancel
 *
 */

HRESULT IsSafeToRun(HWND hwnd, LPCWSTR lpszFileName, BOOL fPrompt);

HRESULT VerifyTrust(HWND hwnd, LPCWSTR pszFileName, LPCWSTR pszPathName);

#endif //_SAFERUN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\saveatt.h ===
#ifndef _SAVEATT_H
#define _SAVEATT_H

interface IMimeMessage;

HRESULT HrSaveAttachments(HWND hwnd, IMimeMessage *pMsg, LPWSTR rgchPath, ULONG cchPath, BOOL fShowUnsafe);

#endif // _SAVEATT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\saferun.cpp ===
/*
 *    s a f e r u n . c p p
 *    
 *    Purpose:
 *		Athena's version of shdocvw's saferun dialog
 *    
 *    Owner:
 *      brettm.
 *
 *    History:
 *      Created: March 1997
 *    
 *    Copyright (C) Microsoft Corp. 1996.
 */


#include "pch.hxx"
#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "util.h"
#include "attrun.h"
#include "saferun.h"
#include "strconst.h"
#include <wintrust.h>
#include "demand.h"
#include "shlwapip.h"


/*
 *      c o n s t a n t s
 */

#define FTA_OpenIsSafe    0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#define FTA_NoEdit        0x00000008 //  4. no editing of file type


/*
 *      t y p e d e f s
 */
typedef struct SAFEOPENPARAM_tag
{
    LPCWSTR     lpszFileName;
    LPCWSTR     lpszFileClass;
    LPCWSTR     lpszExt;
    HRESULT     hr;
}   SAFEOPENPARAM, *LPSAFEOPENPARAM;


/*
 *      p r o t o t y p e s
 */
LRESULT SetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, LPCWSTR pcszValue, DWORD dwType, const BYTE *pcbyte, DWORD dwcb);
LRESULT GetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, PCWSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteBuf, PDWORD pdwcbBufLen);
BOOL RememberFileIsSafeToOpen(LPCWSTR szFileClass);
BOOL FIsExtBad(LPCWSTR lpszExt);
HRESULT SafeOpenDialog(HWND hwnd, LPSAFEOPENPARAM pSafeOpen);
INT_PTR CALLBACK SafeOpenDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*
 * return codes:
 *   S_OPENFILE : file should be opened
 *   S_SAVEFILE : file should be saved
 *
 * errors:
 *   E_FAIL, E_INVALIDARG, hrUserCancel
 *
 */
HRESULT IsSafeToRun(HWND hwnd, LPCWSTR lpszFileName, BOOL fPrompt)
{
    BOOL            fSafe;
    DWORD           dwValueType, 
                    dwEditFlags;
    ULONG           cb;
    WCHAR          *szExt,
                    szFileClass[MAX_PATH];
    SAFEOPENPARAM  rSafeOpen={0}; 

    if (lpszFileName == NULL || *lpszFileName == NULL)
        return E_INVALIDARG;

    *szFileClass = 0;

    szExt = PathFindExtensionW(lpszFileName);
    if (*szExt)
        {
	    cb = sizeof(szFileClass);
        RegQueryValueWrapW(HKEY_CLASSES_ROOT, szExt, szFileClass, (LONG*)&cb);
        }

    cb = sizeof(dwEditFlags);

    // $34489. Make HTML files ALWAYS unsafe
    if (PathIsHTMLFileW(lpszFileName))
        fSafe = FALSE;
    else
        fSafe = ((GetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags", &dwValueType, (PBYTE)&dwEditFlags, &cb) == ERROR_SUCCESS) && 
                (dwValueType == REG_BINARY || dwValueType == REG_DWORD) && 
                (dwEditFlags & FTA_OpenIsSafe)) && !FIsExtBad(szExt);

    rSafeOpen.lpszFileName = lpszFileName;
    rSafeOpen.lpszFileClass = szFileClass;
    rSafeOpen.lpszExt = szExt;

    return fSafe ? MIMEEDIT_S_OPENFILE : (fPrompt ? SafeOpenDialog(hwnd, &rSafeOpen) : MIMEEDIT_E_USERCANCEL);
}


HRESULT SafeOpenDialog(HWND hwnd, LPSAFEOPENPARAM pSafeOpen)
{
    pSafeOpen->hr = E_FAIL;  // incase we fail
    DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSafeOpen), hwnd, SafeOpenDlgProc, (LPARAM)pSafeOpen);
    return pSafeOpen->hr;
}

#define MAXDISPLAYNAMELEN 64

INT_PTR CALLBACK SafeOpenDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPSAFEOPENPARAM     pSafeOpen;

    switch(msg)
        {
        case WM_INITDIALOG:
            {
	        Assert (lParam);
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
	
            pSafeOpen = (LPSAFEOPENPARAM)lParam;
	        // if an UNSAFE extension type, don't allow user to set edit flags
            if (FIsExtBad(pSafeOpen->lpszExt))
		        EnableWindow(GetDlgItem(hwnd, IDC_SAFEOPEN_ALWAYS), FALSE);

	        CheckDlgButton(hwnd, IDC_SAFEOPEN_ALWAYS, TRUE);
	        CheckDlgButton(hwnd, IDC_SAFEOPEN_AUTOSAVE, TRUE);

	        WCHAR szBuf[32];
            WCHAR szBuf2[MAX_PATH+32]; // ok with MAX_PATH
	        WCHAR szBuf3[MAX_PATH+32]; // ok with MAX_PATH
            int length = 0;

            StrCpyNW(szBuf3, pSafeOpen->lpszFileName, ARRAYSIZE(szBuf3));
            PathStripPathW(szBuf3);
            length = lstrlenW(szBuf3);
            if (length > MAXDISPLAYNAMELEN)
            {
                WCHAR *szExt;
                szExt = PathFindExtensionW(pSafeOpen->lpszFileName);
                if (*szExt)
                {
                    int cExt = lstrlenW(szExt);
                    if (cExt < MAXDISPLAYNAMELEN-3)
                    {
                        PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN-cExt, 0);
                        StrCatBuffW(szBuf2, szExt, ARRAYSIZE(szBuf2));
                    }
                    else
                        PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN, 0);
                }
                else
                {
                    PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN, 0);
                }
                StrCpyNW(szBuf3, szBuf2, ARRAYSIZE(szBuf3));
            }

	        GetDlgItemTextWrapW(hwnd, IDC_SAFEOPEN_EXPL, szBuf, ARRAYSIZE(szBuf));
            wnsprintfW(szBuf2, ARRAYSIZE(szBuf2), szBuf, szBuf3);

	        SetDlgItemTextWrapW(hwnd, IDC_SAFEOPEN_EXPL, szBuf2);
	        CenterDialog(hwnd);
            }
            return TRUE;

        case WM_COMMAND:
	        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
                {
	            case IDOK:
                    pSafeOpen = (LPSAFEOPENPARAM)GetWindowLongPtr(hwnd, DWLP_USER);

	                if (!IsDlgButtonChecked(hwnd, IDC_SAFEOPEN_ALWAYS))
		                RememberFileIsSafeToOpen(pSafeOpen->lpszFileClass);

	                pSafeOpen->hr = IsDlgButtonChecked(hwnd, IDC_SAFEOPEN_AUTOSAVE) ? MIMEEDIT_S_SAVEFILE : MIMEEDIT_S_OPENFILE;
	                EndDialog(hwnd, IDOK);
                    break;
                                        
                case IDCANCEL:
                    pSafeOpen = (LPSAFEOPENPARAM)GetWindowLongPtr(hwnd, DWLP_USER);

                    pSafeOpen->hr = MIMEEDIT_E_USERCANCEL;
                    EndDialog(hwnd, IDCANCEL);
	                break;
	            }
            break;

        }
    return FALSE;
}



LRESULT GetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, PCWSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
    LONG lResult;
    HKEY hkeySubKey;

    if (GetSystemMetrics(SM_CLEANBOOT))
	    return ERROR_GEN_FAILURE;

    lResult = RegOpenKeyExWrapW(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE, &hkeySubKey);
    if (lResult == ERROR_SUCCESS)
        {
	    LONG lResultClose;

	    lResult = RegQueryValueExWrapW(hkeySubKey, pcszValue, NULL, pdwValueType,
				      pbyteBuf, pdwcbBufLen);

	    lResultClose = RegCloseKey(hkeySubKey);

	    if (lResult == ERROR_SUCCESS)
	        lResult = lResultClose;
        }

    return(lResult);
}

LRESULT SetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, LPCWSTR pcszValue, DWORD dwType, const BYTE *pcbyte, DWORD dwcb)
{
    LONG lResult;
    HKEY hkeySubKey;

    lResult = RegCreateKeyExWrapW(hkeyParent, pcszSubKey, 0, NULL, 0, KEY_SET_VALUE,
                                NULL, &hkeySubKey, NULL);

    if (lResult == ERROR_SUCCESS)
        {
        LONG lResultClose;

        lResult = RegSetValueExWrapW(hkeySubKey, pcszValue, 0, dwType, pcbyte, dwcb);

        lResultClose = RegCloseKey(hkeySubKey);

        if (lResult == ERROR_SUCCESS)
            lResult = lResultClose;
        }
    return(lResult);
}


BOOL RememberFileIsSafeToOpen(LPCWSTR szFileClass)
{
    DWORD dwValueType, dwEditFlags;
    ULONG cb = sizeof(dwEditFlags);

    if (szFileClass==NULL || *szFileClass == NULL)
        return FALSE;

    if (GetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags",
			   &dwValueType, (PBYTE)&dwEditFlags, &cb) == ERROR_SUCCESS &&
	    (dwValueType == REG_BINARY || dwValueType == REG_DWORD))
        {
	    dwEditFlags &= ~FTA_NoEdit;
	    dwEditFlags |= FTA_OpenIsSafe;
        } 
    else 
        {
	    dwEditFlags = FTA_OpenIsSafe;
        }

    return (SetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags",
			     REG_BINARY, (BYTE*)&dwEditFlags,
			     sizeof(dwEditFlags)) == ERROR_SUCCESS);
}

// Keep in sync with c_arszUnsafeExts in shell\shdocvw\download.cpp
// @todo [NeilBren, TonyC] Move this to the registry and have IE and OE share it
static const LPWSTR szBadExt[] = 
{   L".exe", L".com", L".bat", L".lnk", L".url",
    L".cmd", L".inf", L".reg", L".isp", L".bas", L".pcd",
    L".mst", L".pif", L".scr", L".hlp", L".chm", L".hta", L".asp", 
    L".js",  L".jse", L".vbs", L".vbe", L".ws",  L".wsh", L".msi",
    L".ade", L".adp", L".crt", L".ins", L".mdb",
    L".mde", L".msc", L".msp", L".sct", L".shb",
    L".vb",  L".wsc", L".wsf", L".cpl", L".shs",
    L".vsd", L".vst", L".vss", L".vsw", L".its", L".tmp",
    L".mdw", L".mdt", L".ops", L".mda", L".mdz", L".prf",
    L".scf", L".ksh", L".csh", L".app", L".fxp", L".prg",
    L".htm", L".html",L".vsmacros"
};      

    

BOOL FIsExtBad(LPCWSTR lpszExt)
{
    if (lpszExt == NULL || *lpszExt == NULL)
        return TRUE;

    for (int i=0; i<ARRAYSIZE(szBadExt); i++)
        if (StrCmpIW(lpszExt, szBadExt[i]) == 0)
            return TRUE;

    return FALSE;
}

// Returns:
//
//  IDOK     -- If it's trusted
//  IDNO     -- If it's not known (warning dialog requried)
//  IDCANCEL -- We need to stop download it
//
HRESULT VerifyTrust(HWND hwnd, LPCWSTR pszFileName, LPCWSTR pszPathName)
{
    UINT    uRet = IDNO; // assume unknown
    HANDLE  hFile;
    HRESULT hr=E_FAIL;
    WCHAR   *szExt;

    if (pszFileName==NULL || *pszFileName==NULL || pszPathName==NULL || *pszPathName==NULL)
        return S_OK;        // REVIEW$: ?? should I fail if these are NULL ??

    szExt = PathFindExtensionW(pszFileName);

    if (StrCmpIW(szExt, c_szExeExt) != 0) // don't check for non-exe's
        return S_OK;

    hFile = CreateFileWrapW(pszPathName, GENERIC_READ, FILE_SHARE_READ,
		    NULL, OPEN_EXISTING,
		    FILE_ATTRIBUTE_NORMAL, 0);
            
    if (hFile == INVALID_HANDLE_VALUE)
        return E_HANDLE;

	GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
	GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;
	WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;
	WIN_TRUST_SUBJECT_FILE Subject;

	Subject.hFile = hFile;
	Subject.lpPath = pszFileName;

	ActionData.SubjectType = &SubjectPeImage;
	ActionData.Subject = &Subject;
	ActionData.hClientToken = NULL;

	hr = WinVerifyTrust(hwnd, &PublishedSoftware, &ActionData);
	CloseHandle(hFile);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\saveatt.cpp ===
#include <pch.hxx>
#include "resource.h"
#include "dllmain.h"
#include "saveatt.h"
#include "mimeolep.h"
#include "demand.h"
#include "msoert.h"
#include "util.h"
#include "shlwapi.h"
#include "shlwapip.h"


class CSaveAttachDlg
{
public:
    CSaveAttachDlg();
    ~CSaveAttachDlg();

    ULONG AddRef();
    ULONG Release();

    HRESULT Show(HWND hwndOwner, IMimeMessage *pMsg, LPWSTR rgchPath, ULONG cchPath, BOOL fShowUnsafe);
    static INT_PTR CALLBACK ExtDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    HWND            m_hwnd,
                    m_hwndList,
                    m_hwndEdit;
    WCHAR           m_rgchPath[MAX_PATH];
    BOOL            m_fShowUnsafe;

    INT_PTR DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnInitDialog(HWND hwnd);
    HRESULT OnDestroy();
    HRESULT OnWMNotfiy(WPARAM wParam, LPARAM lParam);
    HRESULT OnSave();
    HRESULT SaveAttachment(LPWSTR lpszDir, LPATTACHDATA pAttach);

};


CSaveAttachDlg::CSaveAttachDlg()
{
    m_cRef = 1;
    *m_rgchPath = 0;
    m_hwnd = NULL;
    m_hwndList = NULL;
    m_hwndEdit = NULL;
    m_fShowUnsafe = FALSE;
}

CSaveAttachDlg::~CSaveAttachDlg()
{
}

ULONG CSaveAttachDlg::AddRef()
{
    return ++m_cRef;
}

ULONG CSaveAttachDlg::Release()
{
    m_cRef--;
    if (m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



HRESULT CSaveAttachDlg::Show(HWND hwndOwner, IMimeMessage *pMsg, LPWSTR lpszPath, ULONG cchPath, BOOL fShowUnsafe)
{
    HRESULT     hr;

    // no need to addref as it's a modal-dialog
    m_pMsg = pMsg;
    m_fShowUnsafe = fShowUnsafe;

    if (!PathFileExistsW(lpszPath) || !PathIsDirectoryW(lpszPath))
        HrGetLastOpenFileDirectoryW(ARRAYSIZE(m_rgchPath), m_rgchPath);
    else
    {
        Assert (cchPath <= MAX_PATH);
        StrCpyNW(m_rgchPath, lpszPath, ARRAYSIZE(m_rgchPath));
    }

    // save attachment DialogBox reutrn hresult
    hr =(HRESULT) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSaveAttachments), hwndOwner, ExtDlgProc, (LPARAM)this);

    if (lpszPath)
        StrCpyNW(lpszPath, m_rgchPath, cchPath);

    return hr;
}


HRESULT CSaveAttachDlg::OnSave()
{
    HWND            hwndEdit;
    LV_ITEMW        lvi;
    int             cItems,
                    i;
    LPATTACHDATA    pAttach;
    WCHAR           wszDir[MAX_PATH+1],
                    wszErr[MAX_PATH + CCHMAX_STRINGRES],
                    wszFmt[CCHMAX_STRINGRES];
    HCURSOR         hcur;
    HRESULT         hr = S_OK;
    BOOL            fFailures=FALSE;

    wszDir[MAX_PATH] = 0;

    hwndEdit = GetDlgItem(m_hwnd, idcPathEdit);
    AssertSz(hwndEdit, "Should have gotten an hwndEdit");

    GetWindowTextWrapW(hwndEdit, wszDir, MAX_PATH);

    if (!PathIsDirectoryW(wszDir))
    {
        LoadStringWrapW(g_hLocRes, idsErrFolderInvalid, wszFmt, ARRAYSIZE(wszFmt));
        wnsprintfW(wszErr, ARRAYSIZE(wszErr), wszFmt, wszDir);
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAttachments), wszErr, NULL, MB_OK|MB_ICONEXCLAMATION);
        return E_FAIL;
    }
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    cItems = ListView_GetItemCount(m_hwndList);

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE|LVIF_PARAM;
    lvi.stateMask = LVIS_SELECTED;
    for (i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
        if (lvi.state & LVIS_SELECTED)
        {
            pAttach = (LPATTACHDATA)lvi.lParam;
            hr = SaveAttachment(wszDir, pAttach);
            if (hr == MIMEEDIT_E_USERCANCEL)
                break;
            if (FAILED(hr))
                fFailures=TRUE;     // flag error, but keep trying
        }
    }
    
    if (hcur)
        SetCursor(hcur);

    if (fFailures)
        AthMessageBoxW(m_hwnd,  MAKEINTRESOURCEW(idsSaveAttachments), MAKEINTRESOURCEW(idsErrOneOrMoreAttachSaveFailed), NULL, MB_OK|MB_ICONEXCLAMATION);

    StrCpyNW(m_rgchPath, wszDir, MAX_PATH);
    return hr;
}


HRESULT CSaveAttachDlg::SaveAttachment(LPWSTR lpszDir, LPATTACHDATA pAttach)
{
    HRESULT     hr = S_OK;
    WCHAR       wszRes[CCHMAX_STRINGRES],
                wsz[MAX_PATH + CCHMAX_STRINGRES],
                wszPath[MAX_PATH];
    int         id;

    *wszRes = 0;

    Assert (pAttach);

    StrCpyNW(wszPath, lpszDir, ARRAYSIZE(wszPath));
    PathAppendW(wszPath, pAttach->szFileName);
    
    if (PathFileExistsW(wszPath))
    {
        LoadStringWrapW(g_hLocRes, idsFileExistWarning, wszRes, ARRAYSIZE(wszRes));
        wnsprintfW(wsz, ARRAYSIZE(wsz), wszRes, wszPath);
        
        // the file exists, warn the dude
        id = AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAttachments), wsz,  NULL, MB_YESNOCANCEL|MB_DEFBUTTON2|MB_ICONEXCLAMATION);
        if (id == IDCANCEL)
            return MIMEEDIT_E_USERCANCEL;
        else
            if (id == IDNO)
                return S_OK;
    }
    
    return HrSaveAttachToFile(m_pMsg, pAttach->hAttach, wszPath);
}


HRESULT CSaveAttachDlg::OnInitDialog(HWND hwnd)
{
    ULONG           uAttach,
                    cAttach;
    HBODY           *rghAttach;
    LPATTACHDATA    pAttach;
    LV_ITEMW        lvi;
    LV_COLUMNW      lvc;
    HIMAGELIST      hImageList;
    RECT            rc;

    m_hwnd = hwnd;
    CenterDialog(hwnd);
    
    // Set up edit box with passed in Directory
    m_hwndEdit = GetDlgItem(hwnd, idcPathEdit);
    if (!m_hwndEdit)
        return E_FAIL;

    if (m_rgchPath)
        SendMessageWrapW(m_hwndEdit, WM_SETTEXT, 0, (LPARAM)m_rgchPath);
    else
    {
        WCHAR szDir[MAX_PATH];
        HrGetLastOpenFileDirectoryW(ARRAYSIZE(szDir), szDir);
        SendMessageWrapW(m_hwndEdit, WM_SETTEXT, 0, LPARAM(szDir));
    }
    
    m_hwndList = GetDlgItem(hwnd, idcAttachList);
    AssertSz(m_hwndList, "Should have gotten an hwndList");
    
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.cx = 0;
    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    
    Assert (m_pMsg);
    if (m_pMsg->GetAttachments(&cAttach, &rghAttach)==S_OK)
    {
        hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), FALSE, cAttach, 0);
        ListView_SetImageList(m_hwndList, hImageList, LVSIL_SMALL);
        
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            if (HrAttachDataFromBodyPart(m_pMsg, rghAttach[uAttach], &pAttach)==S_OK)
            {
                if (!m_fShowUnsafe && pAttach && !pAttach->fSafe)
                    continue;

                lvi.pszText = pAttach->szDisplay;
                lvi.iImage = ImageList_AddIcon(hImageList, pAttach->hIcon);
                lvi.lParam = (LPARAM)pAttach;
                if (SendMessage(m_hwndList, LVM_INSERTITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)) == -1)
                {
                    // try and keep crusing
                    HrFreeAttachData(pAttach);
                    pAttach=NULL;
                }
            }
        }
        SafeMemFree(rghAttach);
    }
    
    GetClientRect(m_hwndList, &rc);
    ListView_SetColumnWidth(m_hwndList, 0, rc.right);
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);
    ListView_SelectAll(m_hwndList);
    SetFocus(m_hwndList);
    return S_OK;
}

HRESULT CSaveAttachDlg::OnDestroy()
{
    ULONG       cItems;
    LV_ITEMW    lvi;

    // walk the listview and free up the LPATTACHDATA hanging off each element

    if (m_hwndList && 
        (cItems = ListView_GetItemCount(m_hwndList)))
    {
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_PARAM;
        for (lvi.iItem=0; lvi.iItem < (int)cItems; lvi.iItem++)
        {
            if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
                HrFreeAttachData((LPATTACHDATA)lvi.lParam);
        }
    }
    return S_OK;
}

HRESULT CSaveAttachDlg::OnWMNotfiy(WPARAM wParam, LPARAM lParam)
{
    NM_LISTVIEW    *pnmlv;
    LPNMHDR         pnmh = NULL;
    UINT            uiCode;
    
    if (idcAttachList == wParam)
    {
        pnmh = LPNMHDR(lParam);
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            pnmlv = (NM_LISTVIEW *)pnmh;
            
            // Only do next section if changing selected states
            if ((!!(pnmlv->uOldState & LVIS_SELECTED) != (!!(pnmlv->uNewState & LVIS_SELECTED))))
            {
                // enable button is >0 items selected
                EnableWindow(GetDlgItem(m_hwnd, IDOK), ListView_GetSelectedCount(m_hwndList));
            }
        }
    }
    else if (idcPathEdit == wParam)
    {
        pnmh = LPNMHDR(lParam);
        if (NM_SETFOCUS == pnmh->code)
            SendMessage(m_hwndEdit, EM_SETSEL, 0, -1);
    }
    
    return S_FALSE;
}



INT_PTR CALLBACK CSaveAttachDlg::ExtDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSaveAttachDlg *pDlg = (CSaveAttachDlg *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pDlg = (CSaveAttachDlg *)lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
    }

    return pDlg?pDlg->DlgProc(hwndDlg, uMsg, wParam, lParam):FALSE;
}


INT_PTR CSaveAttachDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            if (SUCCEEDED(OnInitDialog(hwndDlg)))
                SHAutoComplete(m_hwndEdit, 0);
            return FALSE;
        }
        
        case WM_DESTROY:
            OnDestroy();
            break;
        
        case WM_NOTIFY:
            OnWMNotfiy(wParam, lParam);
            return 0;
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case idcSelectAllAttBtn:
                    ListView_SelectAll(m_hwndList);
                    SetFocus(m_hwndList);
                    return TRUE;
            
                case idcBrowseBtn:
                {
                    WCHAR   wszDir[MAX_PATH];
                    HWND    hwndEdit = GetDlgItem(hwndDlg, idcPathEdit); 
                    
                    GetWindowTextWrapW(hwndEdit, wszDir, ARRAYSIZE(wszDir));
                    if (BrowseForFolderW(g_hLocRes, hwndDlg, wszDir, MAX_PATH, idsPickAtachDir, FALSE))
                        SetWindowTextWrapW(hwndEdit, wszDir);
                    return TRUE;
                }
            
                case IDOK:
                    if (SUCCEEDED(OnSave()))
                        EndDialog(hwndDlg, S_OK);
                    return TRUE;
            
                case IDCANCEL:
                    EndDialog(hwndDlg, MIMEEDIT_E_USERCANCEL);
                    return TRUE;
            }
            break;             
        }
    }
    
    return FALSE;
}


HRESULT HrSaveAttachments(HWND hwnd, IMimeMessage *pMsg, LPWSTR lpszPath, ULONG cchPath, BOOL fShowUnsafe)
{
    CSaveAttachDlg *pDlg;
    HRESULT         hr;

    if (pMsg==NULL)
        return E_INVALIDARG;

    pDlg = new CSaveAttachDlg();
    if (!pDlg)
        return E_OUTOFMEMORY;

    hr = pDlg->Show(hwnd, pMsg, lpszPath, cchPath, fShowUnsafe);

    pDlg->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\secmgr.cpp ===
/*
 *    s e c m g r . c p p
 *    
 *    Purpose:
 *        Implement security manager callback
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <docobj.h>
#include "dllmain.h"
#include "secmgr.h"
#include "urlmon.h"


#define DEF_SECURITYZONE	URLZONE_UNTRUSTED
/* 
 * Security Manger implementation
 *
 */
CSecManager::CSecManager(IOleCommandTarget *pCmdTarget)
{
    m_cRef=1;
    m_pCmdTarget = pCmdTarget;  // loose reference as it's always around
}

CSecManager::~CSecManager()
{
}

HRESULT CSecManager::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IInternetSecurityManager))
        *lplpObj = (IInternetSecurityManager*) this;
    else
        return E_NOINTERFACE;
        
    AddRef();
    return NOERROR;
}

ULONG CSecManager::AddRef()
{
    return ++m_cRef;
}

ULONG CSecManager::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CSecManager::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CSecManager::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CSecManager::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    DWORD   dwZone;

    if (pdwZone == NULL)
        return E_INVALIDARG;

    // run our resources in the trusted zone
    if (pwszUrl && !StrCmpNIW(pwszUrl, L"res:", 4))
        dwZone = URLZONE_TRUSTED;
    // run message content in the selected zone
    else
        dwZone = DwGetZone();

    if (dwZone > URLZONE_PREDEFINED_MAX)
        dwZone = DEF_SECURITYZONE;

    *pdwZone = dwZone;
    return S_OK;
}

HRESULT CSecManager::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

DWORD CSecManager::DwGetZone()
{
    VARIANTARG  va;
    DWORD       dwZone = DEF_SECURITYZONE;

    if (m_pCmdTarget &&
        m_pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SECURITY_ZONE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK &&
        va.vt == VT_I4)
        dwZone = va.lVal;
    
    return dwZone;
}

HRESULT CreateSecurityManger(IOleCommandTarget *pCmdTarget, LPSECMANAGER *ppSecMgr)
{
	CSecManager	*pSecMgr;

	TraceCall ("CreateSecurityManger");

	pSecMgr = new CSecManager(pCmdTarget);
	if (!pSecMgr)
		return TraceResult(E_OUTOFMEMORY);

	*ppSecMgr = pSecMgr;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\secmgr.h ===
#ifndef _SECMGR_H
#define _SECMGR_H

interface IInternetSecurityManager;

class CSecManager :
    public IInternetSecurityManager
{
public:
    CSecManager(IOleCommandTarget *pCmdTarget);
    virtual ~CSecManager();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IInternetSecurityManager
    virtual HRESULT STDMETHODCALLTYPE SetSecuritySite(IInternetSecurityMgrSite *pSite);
    virtual HRESULT STDMETHODCALLTYPE GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    virtual HRESULT STDMETHODCALLTYPE MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

private:
    ULONG               m_cRef;
    IOleCommandTarget   *m_pCmdTarget;

    DWORD DwGetZone();

};

typedef CSecManager *LPSECMANAGER;

HRESULT CreateSecurityManger(IOleCommandTarget *pCmdTarget, LPSECMANAGER *ppSecMgr);

#endif //_SECMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\spell.cpp ===
/*
 *  spell.c
 *
 *  Implementation of spelling
 *
 *  Owner:  v-brakol
 *          bradk@directeq.com
 */
#include "pch.hxx"
#include "richedit.h"
#include "resource.h"
#include "util.h"
#include <mshtml.h>
#include <mshtmcid.h>
#include "mshtmhst.h"
#include "mshtmdid.h"
#include <docobj.h>
#include "spell.h"
#include "strconst.h"
#include "bodyutil.h"
#include <error.h>
#include "htmlstr.h"
#include "dllmain.h"
#include "msi.h"
#include "lid.h"
#include "demand.h"

typedef struct
{
    LPTSTR pszString;
    DWORD cchSize;
} STRING_AND_SIZE;

#define GetAddr(var, cast, name)    {if ((var = (cast)GetProcAddress(m_hinstDll, name)) == NULL) \
                                        goto error;}

#define TESTHR(hr) (FAILED(hr) || hr == HR_S_ABORT || hr == HR_S_SPELLCANCEL)
#define SPELLER_GUID            "{CC29EB3F-7BC2-11D1-A921-00A0C91E2AA2}"
#define DICTIONARY_GUID         "{CC29EB3D-7BC2-11D1-A921-00A0C91E2AA2}"
#define CSAPI3T1_GUID           "{CC29EB41-7BC2-11D1-A921-00A0C91E2AA2}"
#ifdef DEBUG
#define SPELLER_DEBUG_GUID      "{CC29EB3F-7BC2-11D1-A921-10A0C91E2AA2}"
#define DICTIONARY_DEBUG_GUID   "{CC29EB3D-7BC2-11D1-A921-10A0C91E2AA2}"
#define CSAPI3T1_DEBUG_GUID     "{CC29EB41-7BC2-11D1-A921-10A0C91E2AA2}"
#endif  // DEBUG

#define MAX_SPELLWORDS   10

typedef BOOL (LPFNENUMLANG)(DWORD_PTR, LPTSTR);
typedef BOOL (LPFNENUMUSERDICT)(DWORD_PTR, LPTSTR);

typedef struct _FILLLANG
    {
    HWND    hwndCombo;
    BOOL    fUnknownFound;
    BOOL    fDefaultFound;
    BOOL    fCurrentFound;
    UINT    lidDefault;
    UINT    lidCurrent;
    } FILLLANG, * LPFILLLANG;

BOOL    TestLangID(LPCTSTR szLangId);
BOOL    GetLangID(IOleCommandTarget* pParentCmdTarget, LPTSTR szLangID, DWORD cchLangId);
WORD    WGetLangID(IOleCommandTarget* pParentCmdTarget);
DWORD   GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer);
VOID    EnumLanguages(DWORD_PTR, LPFNENUMLANG);
BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang);
void    RemoveTrailingSpace(LPTSTR lpszWord);
void    DumpRange(IHTMLTxtRange *pRange);
BOOL    FBadSpellChecker(LPSTR rgchBufDigit);
void    EnableRepeatedWindows(CSpell* pSpell, HWND hwndDlg);
BOOL    GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail);
VOID    EnumUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn);
BOOL    GetDefaultUserDictionary(TCHAR *rgchUserDict, int cchBuff);
WORD    GetWCharType(WCHAR wc);
HRESULT OpenDirectory(TCHAR *szDir);

BOOL TestLangID(LPCTSTR pszLangId)
{
    // check for new speller
    {
        TCHAR   rgchEngine[MAX_PATH];
        int     cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
        TCHAR   rgchLex[MAX_PATH];
        int     cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

        if (GetNewSpellerEngine((USHORT) StrToInt(pszLangId), rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
            return TRUE;
    }

    // use the old code to check for an old speller
    {
        TCHAR       rgchBufKeyTest[cchMaxPathName];
        TCHAR       rgchBufTest[cchMaxPathName];
        TCHAR       szMdr[cchMaxPathName];

        wnsprintf(rgchBufKeyTest, ARRAYSIZE(rgchBufKeyTest), c_szRegSpellKeyDef, pszLangId);
        if (GetSpellingPaths(rgchBufKeyTest, rgchBufTest, szMdr, sizeof(rgchBufTest)/sizeof(TCHAR)))
            return TRUE;
    }

    return FALSE;
}

/*
 * GetSpellLangID
 *
 * Returns the LangID that should be used as the base for all registry
 * operations
 *
 */
BOOL GetLangID(IOleCommandTarget* pParentCmdTarget, LPTSTR pszLangId, DWORD cchLangId)
{
TCHAR   rgchBuf[cchMaxPathName];
TCHAR   rgchBufKey[cchMaxPathName];
BOOL    fRet;
VARIANT va;

    pszLangId[0] = 0;

    Assert(pParentCmdTarget);
    if (pParentCmdTarget && pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SPELL_LANGUAGE, 0, NULL, &va)== S_OK)
    {
        TCHAR       rgchLangId[cchMaxPathName];

        if (WideCharToMultiByte (CP_ACP, 0, va.bstrVal, -1,
                                rgchLangId, sizeof(rgchLangId), NULL, NULL))
        {
            StrCpyN(pszLangId, rgchLangId, cchLangId);
        }

        SysFreeString(va.bstrVal);
    }
    
    if (*pszLangId == 0)
    {
        wnsprintf(pszLangId, cchLangId, "%d", GetUserDefaultLangID());
        Assert(lstrlen(pszLangId) == 4);
    }

    wnsprintf(rgchBufKey, ARRAYSIZE(rgchBufKey), c_szRegSpellKeyDef, pszLangId);
    // copy c_szRegSpellProfile to buffer
    StrCpyN(rgchBuf, c_szRegSpellProfile, ARRAYSIZE(rgchBuf));
    // add key to buffer
    StrCatBuff(rgchBuf, rgchBufKey, ARRAYSIZE(rgchBuf));

    // and see if it's legit:
    if(!(fRet = TestLangID(pszLangId)))
        {
        // couldn't open it!
        // check for other languages that might be installed...
        STRING_AND_SIZE stringAndSize;

        stringAndSize.pszString = pszLangId;
        stringAndSize.cchSize = cchLangId;

        pszLangId[0] = 0;
        EnumLanguages((DWORD_PTR) &stringAndSize, FindLangCallback);
        if(*pszLangId == 0)
            wnsprintf(pszLangId, cchLangId, TEXT("%d"), GetUserDefaultLangID());
        }

    fRet = (pszLangId[0] != 0) && TestLangID(pszLangId);

    return fRet;
}

WORD    WGetLangID(IOleCommandTarget* pParentCmdTarget)
{
    TCHAR       rgchBufDigit[10];
    
    if (!GetLangID(pParentCmdTarget, rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR)))
        return GetUserDefaultLangID();

    return (WORD) StrToInt(rgchBufDigit);
}

BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang)
{
    // dwLangID is long pointer to szLang ID.  Copy it and return FALSE
    STRING_AND_SIZE * pStringAndSize = (STRING_AND_SIZE *) dwLangId;

    if (pStringAndSize && pStringAndSize->pszString)
    {
        StrCpyN(pStringAndSize->pszString, lpszLang, pStringAndSize->cchSize);
    }

    return FALSE;
}

BOOL EnumOldSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
DWORD   iKey = 0;
FILETIME    ft;
HKEY    hkey = NULL;
LONG    lRet;
TCHAR   szLangId[cchMaxPathName];
DWORD   cchLangId;
BOOL    fContinue;

    // scotts@directeq.com - changed KEY_QUERY_VALUE to KEY_ENUMERATE_SUB_KEYS - 26203
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSpellKeyDefRoot, 0, KEY_ENUMERATE_SUB_KEYS, &hkey) == ERROR_SUCCESS)
        {
        do
            {
            cchLangId = (cchMaxPathName - 1) * sizeof(TCHAR);

            lRet = RegEnumKeyEx(hkey,
                                iKey++,
                                szLangId,
                                &cchLangId,
                                NULL,
                                NULL,
                                NULL,
                                &ft);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;


            // do some quick sanity checking
            if (cchLangId != 4 ||
                !IsCharAlphaNumeric(szLangId[0]) ||
                IsCharAlpha(szLangId[0]))
                {
                fContinue = TRUE;
                }
            else
                fContinue = (!TestLangID(szLangId) || (*pfn)(dwCookie, szLangId));

            } while (fContinue);
        }

    if (hkey)
        RegCloseKey(hkey);

    return fContinue;
}

BOOL EnumNewSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
    BOOL        fContinue = TRUE;
    DWORD       i;
    UINT        installState;
    UINT        componentState;
    TCHAR       rgchQualifier[MAX_PATH];
    DWORD       cchQualifier;

#ifdef DEBUG
    for(i=0; fContinue; i++)
    {
        cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
        componentState = MsiEnumComponentQualifiers(DICTIONARY_DEBUG_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

        if (componentState != ERROR_SUCCESS)
            break;

        // find the language ID
        // the string is formatted as 1033\xxxxxx
        // or                         1042
        {
            TCHAR       szLangId[cchMaxPathName];
            TCHAR       *pSlash;

            StrCpyN(szLangId, rgchQualifier, ARRAYSIZE(szLangId));
            pSlash = StrChr(szLangId, '\\');
            if (pSlash)
                *pSlash = 0;

            fContinue = (*pfn)(dwCookie, szLangId);
        }
    }
#endif  // DEBUG

    for(i=0; fContinue; i++)
    {
        cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
        componentState = MsiEnumComponentQualifiers(DICTIONARY_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

        if (componentState != ERROR_SUCCESS)
            break;

        // find the language ID
        // the string is formatted as 1033\xxxxxx
        // or                         1042
        {
            TCHAR       szLangId[cchMaxPathName];
            TCHAR       *pSlash;

            StrCpyN(szLangId, rgchQualifier, ARRAYSIZE(szLangId));
            pSlash = StrChr(szLangId, '\\');
            if (pSlash)
                *pSlash = 0;

            fContinue = (*pfn)(dwCookie, szLangId);
        }
    }
    
    return fContinue;
}

VOID EnumLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
    EnumNewSpellerLanguages(dwCookie, pfn);
    EnumOldSpellerLanguages(dwCookie, pfn);
}

BOOL EnumOffice9UserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR       rgchBuf[cchMaxPathName];
    HKEY        hkey = NULL;
    FILETIME    ft;
    DWORD       iKey = 0;
    LONG        lRet;
    TCHAR       szValue[cchMaxPathName];
    DWORD       cchValue;
    TCHAR       szCustDict[cchMaxPathName];
    DWORD       cchCustDict;
    BOOL        fContinue = TRUE;
    BOOL        fFoundUserDict = FALSE;
    TCHAR       szOffice9Proof[cchMaxPathName]={0};
    
    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    StrCpyN(rgchBuf, c_szRegSpellProfile, ARRAYSIZE(rgchBuf));
    StrCatBuff(rgchBuf, c_szRegSpellKeyCustom, ARRAYSIZE(rgchBuf));

    if(RegOpenKeyEx(HKEY_CURRENT_USER, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
            cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

            fFoundUserDict = TRUE;

            // check to see if we have a path
            if (!(StrChr(szCustDict, ':') || StrChr(szCustDict, '\\')))
            {
                TCHAR   szTemp[cchMaxPathName];
                
                if (!strlen(szOffice9Proof))
                {
                    LPITEMIDLIST pidl;

                    if (S_OK == SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl))
                        SHGetPathFromIDList(pidl, szOffice9Proof);
                    else
                    {
                        // if the Shell call fails (as it can on Win9x sometimes) let's get the info
                        // from the registry
                        HKEY hKeyShellFolders;
                        ULONG cchAppData;
                        
                        if(RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegShellFoldersKey, 0, KEY_QUERY_VALUE, &hKeyShellFolders) == ERROR_SUCCESS)
                        {
                            cchAppData = ARRAYSIZE(szOffice9Proof);
                            RegQueryValueEx(hKeyShellFolders, c_szValueAppData, 0, NULL, (LPBYTE)szOffice9Proof, &cchAppData);
                            RegCloseKey(hKeyShellFolders);
                        }
                    }

                    // if this fails then we will try the current path
                }

                StrCpyN(szTemp, szOffice9Proof, ARRAYSIZE(szTemp));
                StrCatBuff(szTemp, "\\", ARRAYSIZE(szTemp));
                StrCatBuff(szTemp, c_szSpellOffice9ProofPath, ARRAYSIZE(szTemp));
                StrCatBuff(szTemp, szCustDict, ARRAYSIZE(szTemp));
                StrCpyN(szCustDict, szTemp, ARRAYSIZE(szCustDict));
            }
            
            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

    return fFoundUserDict;
}

BOOL EnumOfficeUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR       rgchBuf[cchMaxPathName];
    HKEY        hkey = NULL;
    FILETIME    ft;
    DWORD       iKey = 0;
    LONG        lRet;
    TCHAR       szValue[cchMaxPathName];
    DWORD       cchValue;
    TCHAR       szCustDict[cchMaxPathName];
    DWORD       cchCustDict;
    BOOL        fFoundUserDict = FALSE;
    BOOL        fContinue = TRUE;

    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    StrCpyN(rgchBuf, c_szRegSpellProfile, ARRAYSIZE(rgchBuf));
    StrCatBuff(rgchBuf, c_szRegSpellKeyCustom, ARRAYSIZE(rgchBuf));

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
            cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

            fFoundUserDict = TRUE;

            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

    return fFoundUserDict;
}

VOID EnumUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    // check for Office9 user dictionaries. If we find any
    // we bail.
    if (EnumOffice9UserDictionaries(dwCookie, pfn))
        return;

    EnumOfficeUserDictionaries(dwCookie, pfn);
}

/*
 *  GetSpellingPaths
 *
 *  Purpose:
 *      Function to get Spelling DLL names.
 *
 *  Arguments:
 *      szKey           c_szRegSpellKeyDef (with correct language)
 *      szDefault       c_szRegSpellEmpty
 *      szReturnBuffer  dll filename
 *      szMdr           dictionary filename
 *      cchReturnBufer
 *
 *  Returns:
 *      DWORD
 */
DWORD GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer)
{
    DWORD           dwRet = 0;
    TCHAR           rgchBuf[cchMaxPathName];
    DWORD           dwType, cbData;
    HKEY            hkey = NULL;
    LPTSTR          szValue;

    szReturnBuffer[0] = 0;
    StrCpyN(rgchBuf, c_szRegSpellProfile, ARRAYSIZE(rgchBuf));
    StrCatBuff(rgchBuf, szKey, ARRAYSIZE(rgchBuf));

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey))
        goto err;

    cbData = cchReturnBufer * sizeof(TCHAR);
    szValue = (LPTSTR) (szMdr ? c_szRegSpellPath : c_szRegSpellPathDict);
    if (ERROR_SUCCESS != SHQueryValueEx(hkey, szValue, 0L, &dwType, (BYTE *) szReturnBuffer, &cbData))
        goto err;

    // Parse off the main dictionary filename
    if(szMdr)
    {
        szMdr[0] = 0;
        cbData = cchReturnBufer * sizeof(TCHAR);
        if (ERROR_SUCCESS != SHQueryValueEx(hkey, c_szRegSpellPathLex, 0L, &dwType, (BYTE *) szMdr, &cbData))
            goto err;
    }

    dwRet = cbData;

err:
    if(hkey)
        RegCloseKey(hkey);
    return dwRet;
}

/*
 *  SpellingDlgProc
 *
 *  Purpose:
 *      Dialog procedure for the Tools.Spelling dialog
 *
 *  Arguments:
 *      HWND        Dialog procedure arguments.
 *      UINT
 *      WPARAM
 *      LPARAM
 *
 *  Returns:
 *      BOOL        TRUE if the message has been processed.
 */
INT_PTR CALLBACK SpellingDlgProc(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam)
{
    CSpell*     pSpell;
    HWND        hwndEdited;
    HWND        hwndSuggest;

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, DWLP_USER, lparam);
        pSpell = (CSpell*)lparam;
        pSpell->m_hwndDlg = hwndDlg;

        hwndEdited = GetDlgItem(hwndDlg, EDT_Spell_ChangeTo);
        hwndSuggest = GetDlgItem(hwndDlg, LBX_Spell_Suggest);

        pSpell->m_fEditWasEmpty = TRUE;
        SetDlgItemText(hwndDlg, TXT_Spell_Error, pSpell->m_szErrType);
        SetDlgItemText(hwndDlg, EDT_Spell_WrongWord, pSpell->m_szWrongWord);
        SetWindowText(hwndEdited, pSpell->m_szEdited);

        EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Options), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (0 != pSpell->m_rgprflex[1]));
        pSpell->m_fRepeat = (pSpell->m_wsrb.sstat == sstatRepeatWord);
        EnableRepeatedWindows(pSpell, hwndDlg);

        if (!pSpell->m_fRepeat)
            pSpell->FillSuggestLbx();
        else
            ListBox_ResetContent(GetDlgItem(hwndDlg, LBX_Spell_Suggest));

        if (pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested && !pSpell->m_fRepeat)
        {
            EnableWindow(hwndSuggest, TRUE);
            ListBox_SetCurSel(hwndSuggest, 0);
            UpdateEditedFromSuggest(hwndDlg, hwndEdited, hwndSuggest);
            EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), TRUE);

            // Set initial default button to "Change"
            SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Change, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Change), BS_DEFPUSHBUTTON, TRUE);

            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), FALSE);
        }
        else
        {
            Edit_SetSel(hwndEdited, 0, 32767);  // select the whole thing
            EnableWindow(hwndSuggest, FALSE);
            EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), FALSE);

            // Set initial default button to "Ignore"
            SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Ignore, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Ignore), BS_DEFPUSHBUTTON, TRUE);

            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), !pSpell->m_fSuggestions && !pSpell->m_fRepeat);
        }

        AthFixDialogFonts(hwndDlg);
        SetFocus(hwndEdited);
        break;

    case WM_DESTROY:
        break;

    case WM_COMMAND:
        return SpellingOnCommand(hwndDlg, wMsg, wparam, lparam);

    }

    return FALSE;
}


void EnableRepeatedWindows(CSpell* pSpell, HWND hwndDlg)
{
    INT ids;

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (!pSpell->m_fRepeat && (0 != pSpell->m_rgprflex[1])));
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_IgnoreAll), !pSpell->m_fRepeat);
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_ChangeAll), !pSpell->m_fRepeat);
    if (pSpell->m_fRepeat)
    {
        SetWindowText(GetDlgItem(hwndDlg, EDT_Spell_ChangeTo), "");
        *pSpell->m_szEdited = 0;
    }

}


BOOL SpellingOnCommand(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam)
{
    CSpell*     pSpell;
    BOOL        fChange;
    BOOL        fAlwaysSuggest;
    BOOL        fUndoing = FALSE;
    HRESULT     hr = 0;

    pSpell = (CSpell*) GetWindowLongPtr(hwndDlg, DWLP_USER);
    Assert(pSpell);

    // Update our replacement word?  Only do this when a button is clicked
    // or a double-click from the suggest listbox, and the word has been modified.
    if ((GET_WM_COMMAND_CMD(wparam, lparam) == BN_CLICKED ||
         GET_WM_COMMAND_CMD(wparam, lparam) == LBN_DBLCLK) &&
        Edit_GetModify(GetDlgItem(hwndDlg, EDT_Spell_ChangeTo)))
    {
        HWND    hwndEditChangeTo;

        hwndEditChangeTo = GetDlgItem(pSpell->m_hwndDlg, EDT_Spell_ChangeTo);
        Edit_SetModify(hwndEditChangeTo, FALSE);
        pSpell->m_fSuggestions = FALSE;
        GetWindowText(hwndEditChangeTo, pSpell->m_szEdited, 512);
    }

    switch(GET_WM_COMMAND_ID(wparam, lparam))
    {
    case LBX_Spell_Suggest:
        if (GET_WM_COMMAND_CMD(wparam, lparam) == LBN_SELCHANGE)
        {
            UpdateEditedFromSuggest(hwndDlg, GetDlgItem(hwndDlg, EDT_Spell_ChangeTo),
                                    GetDlgItem(hwndDlg, LBX_Spell_Suggest));
            return TRUE;
        }
        else if (GET_WM_COMMAND_CMD(wparam, lparam) == LBN_DBLCLK)
        {
            goto ChangeIt;
        }
        else
        {
            return FALSE;
        }

    case EDT_Spell_ChangeTo:
        if (GET_WM_COMMAND_CMD(wparam, lparam) == EN_CHANGE)
        {
            INT     idClearDefault;
            INT     idSetDefault;
            BOOL    fEditModified;


            // We get EN_CHANGE notifications for both a SetWindowText() and user modifications.
            // Look at the dirty flag (only set on user mods) and the state of the suggestions
            // selection to see which button should get the default style.
            fEditModified = Edit_GetModify(GET_WM_COMMAND_HWND(wparam, lparam));
            if (fEditModified || pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested)
            {
                idClearDefault = PSB_Spell_Ignore;
                idSetDefault = PSB_Spell_Change;
            }
            else
            {
                idClearDefault = PSB_Spell_Change;
                idSetDefault = PSB_Spell_Ignore;
            }

            // Enable/disable Suggest button
            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), fEditModified);

            // Set default button
            Button_SetStyle(GetDlgItem(hwndDlg, idClearDefault), BS_PUSHBUTTON, TRUE);
            SendMessage(hwndDlg, DM_SETDEFID, idSetDefault, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, idSetDefault), BS_DEFPUSHBUTTON, TRUE);

            // "Change" button title
            if (GetWindowTextLength(GET_WM_COMMAND_HWND(wparam, lparam)) && pSpell->m_fEditWasEmpty)
            {
                pSpell->m_fEditWasEmpty = FALSE;
                LoadString(g_hLocRes, idsSpellChange, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_Change, pSpell->m_szTempBuffer);
                LoadString(g_hLocRes, idsSpellChangeAll, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_ChangeAll, pSpell->m_szTempBuffer);
            }
            else if (GetWindowTextLength(GET_WM_COMMAND_HWND(wparam, lparam)) == 0)
            {
                pSpell->m_fEditWasEmpty = TRUE;
                LoadString(g_hLocRes, idsSpellDelete, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_Change, pSpell->m_szTempBuffer);
                LoadString(g_hLocRes, idsSpellDeleteAll, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_ChangeAll, pSpell->m_szTempBuffer);
            }
        }
        return TRUE;

    case PSB_Spell_IgnoreAll:
    {
        PROOFLEX    lexIgnoreAll;

        lexIgnoreAll = pSpell->m_pfnSpellerBuiltInUdr(pSpell->m_pid, lxtIgnoreAlways);
        if (0 != lexIgnoreAll)
        {
            RemoveTrailingSpace(pSpell->m_szWrongWord);
            pSpell->AddToUdrA(pSpell->m_szWrongWord, lexIgnoreAll);
            pSpell->m_fCanUndo = FALSE;
        }
    }
        // scotts@directeq.com - remove the annoying dialog and just break out of here - 34229
        break;

    case PSB_Spell_Ignore:
        // Due to limitations with the spelling engine and our single undo level,
        // we can't allow undo's of Ignore if the error was a Repeated Word.
        if (pSpell->m_wsrb.sstat == sstatRepeatWord)
            pSpell->m_fCanUndo = FALSE;
        else
            pSpell->SpellSaveUndo(PSB_Spell_Ignore);

        // scotts@directeq.com - remove the annoying dialog and just break out of here - 34229
        break;

    case PSB_Spell_ChangeAll:
        if (pSpell->FVerifyThisText(pSpell->m_szEdited, FALSE))
        {
            pSpell->m_fCanUndo = FALSE;
            hr = pSpell->HrReplaceErrorText(TRUE, TRUE);
            break;
        }
        else
        {
            return TRUE;
        }

    case PSB_Spell_Change:
ChangeIt:
        if (pSpell->FVerifyThisText(pSpell->m_szEdited, FALSE))
        {
            pSpell->m_fUndoChange = TRUE;
            pSpell->SpellSaveUndo(PSB_Spell_Change);
            hr = pSpell->HrReplaceErrorText(FALSE, TRUE);
            break;
        }
        else
        {
            return TRUE;
        }

    case PSB_Spell_Add:
        Assert(pSpell->m_rgprflex[1]);
        pSpell->m_fCanUndo = FALSE;
        fChange = FALSE;
        RemoveTrailingSpace(pSpell->m_szWrongWord);
        // scotts@directeq.com - removed the FVerifyThisText that was here - no need
        // to FVerifyThisText if the user is asking us to Add this word - fixes 55587
        pSpell->AddToUdrA(pSpell->m_szWrongWord, pSpell->m_rgprflex[1]);
        if (fChange)
            hr = pSpell->HrReplaceErrorText(FALSE, TRUE);
        break;

    case PSB_Spell_UndoLast:
        pSpell->SpellDoUndo();
        fUndoing = TRUE;
        break;

    case PSB_Spell_Suggest:
        hr = pSpell->HrSpellSuggest();
        if (FAILED(hr))
            goto bail;
        goto loadcache;

    case IDCANCEL:
        pSpell->m_fShowDoneMsg = FALSE;
        EndDialog(hwndDlg, IDCANCEL);
        return TRUE;

    default:
        return FALSE;
    }

    // If no current error, then proceed with checking the rest
    if (SUCCEEDED(hr))
    {
        // Change "Cancel" button to "Close"
        LoadString(g_hLocRes, idsSpellClose, pSpell->m_szTempBuffer,
                   sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
        SetDlgItemText(hwndDlg, IDCANCEL, pSpell->m_szTempBuffer);

        pSpell->m_wsrb.sstat = sstatNoErrors;
        hr = pSpell->HrFindErrors();
        if(FAILED(hr))
            goto bail;

        if(pSpell->m_wsrb.sstat==sstatNoErrors)
        {
            EndDialog(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam));
            return TRUE;
        }

    }

bail:
    if(FAILED(hr))
    {
        EndDialog(hwndDlg, IDCANCEL);
        return TRUE;
    }

    SetDlgItemText(hwndDlg, EDT_Spell_WrongWord, pSpell->m_szWrongWord);
    SetDlgItemText(hwndDlg, TXT_Spell_Error, pSpell->m_szErrType);
    SetDlgItemText(hwndDlg, EDT_Spell_ChangeTo, pSpell->m_szEdited);

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_UndoLast), pSpell->m_fCanUndo);
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (0 != pSpell->m_rgprflex[1]));

    pSpell->m_fRepeat = (pSpell->m_wsrb.sstat == sstatRepeatWord);
    EnableRepeatedWindows(pSpell, hwndDlg);

loadcache:
    if (!pSpell->m_fRepeat)
        pSpell->FillSuggestLbx();
    else
        ListBox_ResetContent(GetDlgItem(hwndDlg, LBX_Spell_Suggest));

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), !pSpell->m_fSuggestions && !pSpell->m_fRepeat);
    if (pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested && !pSpell->m_fRepeat)
    {
        EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), TRUE);
        EnableWindow(GetDlgItem(hwndDlg, LBX_Spell_Suggest), TRUE);
        ListBox_SetCurSel(GetDlgItem(hwndDlg, LBX_Spell_Suggest), 0);
        UpdateEditedFromSuggest(hwndDlg, GetDlgItem(hwndDlg, EDT_Spell_ChangeTo),
                                GetDlgItem(hwndDlg, LBX_Spell_Suggest));
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, LBX_Spell_Suggest), FALSE);
    }

    SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwndDlg, EDT_Spell_ChangeTo), MAKELONG(TRUE,0));

    return TRUE;
}


void RemoveTrailingSpace(LPTSTR lpszWord)
{
    LPTSTR      lpsz;

    lpsz = StrChrI(lpszWord, ' ');
    if(lpsz)
        *lpsz = 0;
}

BOOL GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail)
{
    DWORD                           er;
    LPCSTR                          rgpszDictionaryTypes[] = {"Normal", "Consise", "Complete"}; 
    int                             cDictTypes = sizeof(rgpszDictionaryTypes) / sizeof(LPCSTR);
    int                             i;
    TCHAR                           rgchQual[MAX_PATH];
    bool                            fFound = FALSE;
    DWORD                           cch;
    INSTALLUILEVEL                  iuilOriginal;
    
    if (rgchEngine == NULL || rgchLex == NULL)
        return FALSE;

    *rgchEngine = 0;
    *rgchLex = 0;

    wnsprintf(rgchQual, ARRAYSIZE(rgchQual), "%d\\Normal", lgid);
    cch = cchEngine;

    if (bTestAvail)
    {
        // Explicitly Turn off internal installer UI
        // Eg: A feature is set to "run from CD," and CD is not present - fail silently
        // OE Bug 74697
        iuilOriginal = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
    }

#ifdef DEBUG
    er = MsiProvideQualifiedComponent(SPELLER_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
    if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
    {
        cch = cchEngine;
        er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
    }
#else
    er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
#endif

    if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND)) 
    {
        fFound = FALSE;
        goto errorExit;
    }

    // Hebrew has main lex in new speller
        for (i = 0; i < cDictTypes; i++)
        {
            int nDictionaryIndex = (int)min(i, ARRAYSIZE(rgpszDictionaryTypes)-1);
            wnsprintf(rgchQual, ARRAYSIZE(rgchQual), "%d\\%s",  lgid, rgpszDictionaryTypes[nDictionaryIndex]);
            cch = cchLex;

#ifdef DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
            if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
            {
                cch = cchLex;
                er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
            }
#else   // DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
#endif  // DEBUG

            if ((er == ERROR_SUCCESS) || (er == ERROR_FILE_NOT_FOUND))
            {
                fFound = TRUE;
                break;
            }
        }

errorExit:
    if (bTestAvail)
    {
        // Restore original UI Level
        MsiSetInternalUI(iuilOriginal, NULL);
    }
    return fFound;
}

BOOL FIsNewSpellerInstaller(IOleCommandTarget* pParentCmdTarget)
{
    LANGID langid;
    TCHAR   rgchEngine[MAX_PATH];
    int     cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
    TCHAR   rgchLex[MAX_PATH];
    int     cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

    // first try to load dictionaries for various languages
    langid = WGetLangID(pParentCmdTarget);
    if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
    {
        langid = GetSystemDefaultLangID();
        if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
        {
            langid = 1033;  // bloody cultural imperialists.
            if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
                return FALSE;
        }
    }

    return TRUE;
}

// scotts@directeq.com - copied from "old" spell code - 32675
/*
 *  FIsSpellingInstalled
 *
 *  Purpose:
 *      Is the spelling stuff installed
 *
 *  Arguments:
 *      none
 *
 *  Returns:
 *      BOOL            Returns TRUE if spelling is installed, else FALSE.
 */
BOOL FIsSpellingInstalled(IOleCommandTarget* pParentCmdTarget)
{
    TCHAR       rgchBufDigit[10];

    if (GetLangID(pParentCmdTarget, rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR)) && !FBadSpellChecker(rgchBufDigit))
        return true;

    if (FIsNewSpellerInstaller(pParentCmdTarget))
        return true;

    return false;
}

// Does a quick check to see if spelling is available; caches result.
BOOL FCheckSpellAvail(IOleCommandTarget* pParentCmdTarget)
{
// scotts@directeq.com - copied from "old" spell code - 32675
    static int fSpellAvailable = -1;

    if (fSpellAvailable < 0)
        fSpellAvailable = (FIsSpellingInstalled(pParentCmdTarget) ? 1 : 0);

    return (fSpellAvailable > 0);
}

HRESULT CSpell::HrSpellReset()
{
    m_fSpellContinue = FALSE;

    return NOERROR;
}

/*
 *  UlNoteCmdToolsSpelling
 *
 *  Purpose:
 *      An interface layer between the note and core spelling code
 *
 *  Arguments:
 *      HWND            Owning window handle, main window
 *      HWND            Subject line window, checked first, actually.
 *      BOOL            Suppress done message (used when spell-check on send)
 *
 *  Returns:
 *      ULONG           Returns 0 if spelling check was completed, else returns non-zero
 *                      if an error occurred or user cancelled the spell check.
 */
HRESULT CSpell::HrSpellChecking(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg)
{
    HRESULT hr = NOERROR;

    hr = HrSpellReset();
    if (FAILED(hr))
        goto End;

    hr = HrInitRanges(pRangeIgnore, hwndMain, fSuppressDoneMsg);
    if(FAILED(hr))
        goto End;

    hr = HrFindErrors();
    if(FAILED(hr))
        goto End;

    if(m_wsrb.sstat==sstatNoErrors && m_fShowDoneMsg)
        AthMessageBoxW(m_hwndNote, MAKEINTRESOURCEW(idsSpellCaption), MAKEINTRESOURCEW(idsSpellMsgDone), NULL, MB_OK | MB_ICONINFORMATION);

End:
    DeInitRanges();

    return hr;
}


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrBkgrndSpellTimer()
{
    HRESULT       hr=NOERROR;
    LONG          cSpellWords = 0;
    IHTMLTxtRange *pTxtRange=0;
    LONG          cb;
    VARIANT_BOOL  fSuccess;

    if (m_Stack.fEmpty())
        goto error;

    while (!(m_Stack.fEmpty()) && cSpellWords <= MAX_SPELLWORDS)
    {
        m_Stack.HrGetRange(&pTxtRange);
        if (pTxtRange)
        {
            while(cSpellWords <= MAX_SPELLWORDS)
            {
                pTxtRange->collapse(VARIANT_TRUE);
                if (SUCCEEDED(pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess)) && fSuccess==VARIANT_TRUE)
                {
                    HrBkgrndSpellCheck(pTxtRange);
                    cSpellWords++;
                }
                else
                {
                    m_Stack.pop();
                    SafeRelease(pTxtRange);
                    break;
                }

                cb=0;
                if (FAILED(pTxtRange->moveStart((BSTR)c_bstr_Word, 1, &cb)) || cb!=1)
                {
                    m_Stack.pop();
                    SafeRelease(pTxtRange);
                    break;
                }
            }

        }
    }

error:
    SafeRelease(pTxtRange);
    return hr;
}
#endif // BACKGROUNDSPELL

#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrBkgrndSpellCheck(IHTMLTxtRange *pTxtRange)
{
    HRESULT         hr = NOERROR;
    LPSTR           pszText = 0;
    VARIANT_BOOL    fSuccess;

    hr = pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;

    StripNBSPs(pszText);

    // ignore words with wildcards
    if (StrChr(pszText, '*'))
        goto error;

    RemoveTrailingSpace(pszText);
    hr = HrCheckWord(pszText);
    if(FAILED(hr))
        goto error;

    if(m_wsrb.sstat!=sstatNoErrors && m_wsrb.sstat!=sstatRepeatWord) //found an error.
    {
        // FIgnore should take pTxtRange as the parameter.
        if(FIgnore(pTxtRange))
        {
            m_wsrb.sstat = sstatNoErrors;
            goto error;
        }

        if (HrHasSquiggle(pTxtRange)==S_OK)
        {
            DebugTrace("Spell: Bad word %s\n", pszText);
            goto error;
        }

        //put red squiggle
        HrSetSquiggle(pTxtRange);

    }
    else //if the wrong word is corrected, delete <U> tag.
    {
        if (HrHasSquiggle(pTxtRange)==S_OK)
            HrDeleteSquiggle(pTxtRange);

    }

error:
    SafeMemFree(pszText);   
    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
//const static CHAR c_szSquiggleFmt[] = "<U style='color:red'>%s</U>";
const static CHAR c_szSquiggleFmt[] = "<SPAN class=badspelling STYLE='text-decoration:underline;color:red'>%s</SPAN>";
HRESULT CSpell::HrSetSquiggle(IHTMLTxtRange *pTxtRange)
{
    CHAR    szBuf[MAX_PATH]={0};
    BSTR    bstr=0;
    HRESULT hr=NOERROR;
    LPSTR   pszText=0;
    INT     nSpaces=0;
    int     i;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;
    
    hr = HrGetSpaces(pszText, &nSpaces);
    if(FAILED(hr))
        goto error;
    
    RemoveTrailingSpace(pszText);
    wnsprintf(szBuf, ARRAYSIZE(szBuf), c_szSquiggleFmt, pszText);
    for(i=0; i<(nSpaces-1); i++)
        StrCatBuff(szBuf, "&nbsp", ARRAYSIZE(szBuf));
    if (nSpaces>0)
        StrCatBuff(szBuf, " ", ARRAYSIZE(szBuf));

    HrLPSZToBSTR(szBuf, &bstr);
    hr = pTxtRange->pasteHTML(bstr);
    if(FAILED(hr))
        goto error;

error:
    SafeSysFreeString(bstr);
    SafeMemFree(pszText);
    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrDeleteSquiggle(IHTMLTxtRange *pTxtRange)
{
    CHAR    szBuf[MAX_PATH]={0};
    BSTR    bstr=0;
    HRESULT hr=NOERROR;
    LPSTR   pszText=0;
    INT     nSpaces=0;
    int     i;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;
    
    hr = HrGetSpaces(pszText, &nSpaces);
    if(FAILED(hr))
        goto error;

    StrCpyN(szBuf, pszText, ARRAYSIZE(szBuf));
    for(i=0; i<(nSpaces-1); i++)
        StrCatBuff(szBuf, "&nbsp", ARRAYSIZE(szBuf));
    if (nSpaces>0)
        StrCatBuff(szBuf, " ", ARRAYSIZE(szBuf));
    HrLPSZToBSTR(szBuf, &bstr);
    hr = pTxtRange->pasteHTML(bstr);
    if(FAILED(hr))
        goto error;

error:
    SafeSysFreeString(bstr);
    SafeMemFree(pszText);
    return hr;
}
#endif // BACKGROUNDSPELL

HRESULT CSpell::HrGetSpaces(LPSTR pszText, INT* pnSpaces)
{
    LPSTR p;
    *pnSpaces = 0;
    p = StrChrI(pszText, ' ');
    if(p)
    {
        *pnSpaces = (INT) (&pszText[lstrlen(pszText)] - p);
        Assert(*pnSpaces>=0);
    }
    return NOERROR;
}

HRESULT CSpell::HrInsertMenu(HMENU hmenu, IHTMLTxtRange *pTxtRange)
{
    LPSTR   pch=0;
    LPSTR   pszText=0;
    INT     index=0;
    HRESULT hr;
    VARIANT_BOOL    fSuccess;

    hr = pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (pszText==NULL || *pszText=='\0')
    {
        hr = E_FAIL;
        goto error;
    }
        
    StrCpyN(m_szEdited, pszText, ARRAYSIZE(m_szEdited));
    HrSpellSuggest();
    pch = m_szSuggest;
    if (*pch == '\0')
    {
        LoadString(g_hLocRes, idsSpellNoSuggestions, m_szTempBuffer,
                   sizeof(m_szTempBuffer)/sizeof(TCHAR));
        InsertMenu(hmenu, (UINT)0, MF_BYPOSITION|MF_STRING, idmSuggest0, m_szTempBuffer);
        EnableMenuItem(hmenu, idmSuggest0, MF_BYCOMMAND|MF_GRAYED);
        //ListBox_AddString(hwndLbx, m_szTempBuffer);
    }
    else
    {
        while(*pch != '\0' && index<5)
        {
            InsertMenu(hmenu, (UINT)index, MF_BYPOSITION|MF_STRING, idmSuggest0 + index, pch);
            index++;
            //ListBox_AddString(hwndLbx, pch);
            while(*pch != '\0')
                pch++;
            pch++;
        }
    }

error:
    SafeMemFree(pszText);
    return hr;
}


const static TCHAR c_szFmt[] = "%s%s";
HRESULT CSpell::HrReplaceBySuggest(IHTMLTxtRange *pTxtRange, INT index)
{
    CHAR    szBuf[MAX_PATH] = {0};
    BSTR    bstr=0;
    BSTR    bstrPut=0;
    LPSTR   pch=0;
    INT     i=0;
    HRESULT hr;

    pch = m_szSuggest;
    while(*pch != '\0' && i<5)
    {
        if (index == i)
        {
            StrCpyN(szBuf, pch, ARRAYSIZE(szBuf));

            if (SUCCEEDED(pTxtRange->get_text(&bstr)) && bstr)
            {
                LPSTR   pszText = 0;
                if (SUCCEEDED(HrBSTRToLPSZ(CP_ACP, bstr, &pszText)) && pszText)
                {
                    LPSTR   psz;
                    INT     nSpaces=0;
                    psz = StrChrI(pszText, ' ');
                    if(psz)
                    {
                        nSpaces = (INT) (&pszText[lstrlen(pszText)] - psz);
                        Assert(nSpaces>=0);
                        for(int i=0; i<(nSpaces-1); i++)
                            StrCatBuff(szBuf, "&nbsp;", ARRAYSIZE(szBuf));
                        if (nSpaces>0)
                            StrCatBuff(szBuf, " ", ARRAYSIZE(szBuf));
                    }
                    hr = HrLPSZToBSTR(szBuf, &bstrPut);

                    SafeMemFree(pszText);
                }
                SafeSysFreeString(bstr);
            }
            if (bstrPut)
            {
                pTxtRange->pasteHTML(bstrPut);
                SafeSysFreeString(bstrPut);
            }
            break;
        }
        i++;
        while(*pch != '\0')
            pch++;
        pch++;
    }

    return NOERROR;
}





HRESULT CSpell::HrFindErrors()
{
    HRESULT hr = NOERROR;

    if(m_State == SEL)
    {
        hr = HrCheckRange(m_pRangeSelExpand);
        // if hr==HR_S_ABORT, quit so as to pass control to dialog procedure which calls HrFindErrors.
        if(TESTHR(hr))
            goto error;

        if(AthMessageBoxW(m_hwndDlg ? m_hwndDlg : m_hwndNote,
                            MAKEINTRESOURCEW(idsSpellCaption),
                            MAKEINTRESOURCEW(idsSpellMsgContinue),
                            NULL, 
                            MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
        {
            m_fShowDoneMsg = FALSE;
            goto error;
        }

        CleanupState();
    }

    if(m_State == SELENDDOCEND)
    {
        DumpRange(m_pRangeSelEndDocEnd);
        m_fIgnoreScope = TRUE;
        hr = HrCheckRange(m_pRangeSelEndDocEnd);
        m_fIgnoreScope = FALSE;
        if(TESTHR(hr))
            goto error;

        CleanupState();

        hr = HrSpellReset();
        if (FAILED(hr))
            goto error;
    }

    if(m_State == DOCSTARTSELSTART)
    {
        hr = HrCheckRange(m_pRangeDocStartSelStart);
        if(TESTHR(hr))
            goto error;

        CleanupState();
    }

error:
    // save the hr so as to know if something went wrong when dialog procedure calls HrFindErrors.
    m_hr = hr;
    return hr;
}

VOID CSpell::CleanupState()
{
    m_State++;
    SafeRelease(m_pRangeChecking);
}

HRESULT CSpell::HrCheckRange(IHTMLTxtRange* pRange)
{
    HRESULT         hr = NOERROR;
    INT_PTR         nCode;
    LPSTR           pszText = 0;
    VARIANT_BOOL    fSuccess;

    if(m_pRangeChecking == NULL)
    {
        hr = pRange->duplicate(&m_pRangeChecking);
        if(FAILED(hr))
            goto error;

        hr = m_pRangeChecking->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }

    while(TRUE)
    {
        SafeMemFree(pszText);

        hr = HrGetNextWordRange(m_pRangeChecking);
        if(FAILED(hr))
            goto error;
        if (hr == HR_S_SPELLBREAK)
            break;
        if (hr == HR_S_SPELLCONTINUE)
            continue;

        // Do we really need it?
        if (!m_fIgnoreScope)
        {
            hr = pRange->inRange(m_pRangeChecking, &fSuccess);
            if(FAILED(hr))
                goto error;
            if(fSuccess != VARIANT_TRUE)
                break;
        }

        // check if we are on the original text of a reply/forward message.
        if(m_pRangeIgnore)
        {
            fSuccess = VARIANT_FALSE;

            m_pRangeIgnore->inRange(m_pRangeChecking, &fSuccess);

            // normally don't spellcheck words in m_pRangeIgnore.
            // but if it's selected, we check it.
            if(fSuccess==VARIANT_TRUE)
            {
                hr = m_pRangeSelExpand->inRange(m_pRangeChecking, &fSuccess);
                if(FAILED(hr))
                    goto error;
                if(fSuccess != VARIANT_TRUE)
                    continue;
            }
        }

tryWordAgain:
        hr = HrGetText(m_pRangeChecking, &pszText);
        if(FAILED(hr))
            goto error;
        if (hr == HR_S_SPELLBREAK)
            break;
        if (hr == HR_S_SPELLCONTINUE)
            continue;

        hr = HrCheckWord(pszText);
        if(FAILED(hr))
            goto error;

        if(m_wsrb.sstat!=sstatNoErrors) //found an error.
        {
            if(FIgnore(m_pRangeChecking))
            {
                m_wsrb.sstat = sstatNoErrors;
                continue;
            }

            // if it contains a period, remove it for processing
            if (StrChr(pszText, '.'))
            {
                BOOL    fResult;
                
                hr = HrStripTrailingPeriod(m_pRangeChecking, &fResult);
                if (FAILED(hr))
                    goto error;

                if (fResult)
                    goto tryWordAgain;
            }

            HrProcessSpellErrors();
            if(!m_hwndDlg) //spellchecking dialog is lauched only once.
            {
                nCode = DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSpelling), m_hwndNote,
                                      SpellingDlgProc, (LPARAM)this);

            }
            if(nCode == -1)
                hr = E_FAIL;
            else if(FAILED(m_hr))
                // something was wrong when dialog calls HrFindErrors.
                // it has higher priority than IDCANCEL.
                hr = m_hr;
            else if(nCode == IDCANCEL)
                hr = HR_S_SPELLCANCEL;
            else
                // we quit here to pass control to the dialog procedure which calls HrFindErrors.
                hr = HR_S_ABORT;
            goto error;
        }

    }

error:
    SafeMemFree(pszText);   

    return hr;
}

HRESULT CSpell::HrGetText(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, LPSTR *ppszText)
{
    HRESULT             hr = NOERROR;
    IHTMLTxtRange       *pTxtRange = NULL;
    BSTR                bstr = NULL;

    if (ppszText == NULL || pRangeStart == NULL || pRangeEnd == NULL)
        return E_INVALIDARG;

    *ppszText = NULL;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pBodyElem->createTextRange(&pTxtRange);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pTxtRange);
    if (FAILED(hr))
        goto error;

    hr = pTxtRange->get_text(&bstr);
    if (FAILED(hr))
        goto error;

    if(bstr==NULL || SysStringLen(bstr)==0)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // never spell check Japanese.
    if(((WORD)*bstr > (WORD)0x3000) && //DBCS
        (GetACP() == 932 || FIgnoreDBCS()))
    {
        hr = HR_S_SPELLCONTINUE;
        goto error;
    }
    
    hr = HrBSTRToLPSZ(CP_ACP, bstr, ppszText);
    if (FAILED(hr))
        goto error;
    if (*ppszText == NULL)
    {
        hr = E_FAIL;
        goto error;
    }
    
error:
    SafeRelease(pTxtRange);
    SafeSysFreeString(bstr);

    return hr;
}

HRESULT CSpell::HrGetText(IHTMLTxtRange* pRange, LPSTR *ppszText)
{
    BSTR        bstr=0;
    HRESULT     hr = NOERROR;
    UINT        uCodePage;

    if (ppszText==NULL || pRange==NULL)
        return E_INVALIDARG;

    *ppszText = 0;

    hr = pRange->get_text(&bstr);
    if(FAILED(hr))
        goto error;
    if(bstr==NULL || SysStringLen(bstr)==0)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // never spell check Japanese.
    if(((WORD)*bstr > (WORD)0x3000) && //DBCS
        (GetACP() == 932 || FIgnoreDBCS()))
    {
        hr = HR_S_SPELLCONTINUE;
        goto error;
    }

    uCodePage = GetCodePage();
    *ppszText = PszToANSI(uCodePage, bstr);
    if (*ppszText == NULL)
    {
        hr = E_FAIL;
        goto error;
    }

error:
    SafeSysFreeString(bstr);
    return hr;
}

HRESULT CSpell::HrStripTrailingPeriod(IHTMLTxtRange* pRange, BOOL* pfResult)
{
    HRESULT             hr = NOERROR;
    IMarkupPointer      *pRangeStart = NULL;
    IMarkupPointer      *pRangeEnd = NULL;
    IMarkupPointer      *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE markupContext;
    long                cch;
    OLECHAR             chText[64];
    BOOL                fResult;

    if (pRange==NULL || pfResult == NULL)
        return E_INVALIDARG;

    *pfResult = FALSE;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MovePointersToRange(pRange, pRangeStart, pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = pRangeStart->IsEqualTo(pRangeEnd, &fResult);
    if (FAILED(hr))
        goto error;

    if (fResult)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }
    
    // check for '.' and remove
    {
        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
        
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeTemp->IsRightOf(pRangeStart, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = HR_S_SPELLBREAK;
                goto error;
            }

            if (markupContext == CONTEXT_TYPE_Text && chText[0] != L'.')
                goto finished;

            cch = 1;
            hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text)
            {
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;

                *pfResult = TRUE;
            }
        }
    }

finished:
    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pRange);
    if (FAILED(hr))
        goto error;

error:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);
    
    return hr;
}

HRESULT CSpell::HrHasWhitespace(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, BOOL *pfResult)
{
    HRESULT             hr = NOERROR;
    LPSTR               pszText = NULL;
    LPSTR               psz;
    
    if (pRangeStart == NULL || pRangeEnd == NULL || pfResult == NULL)
        return E_INVALIDARG;

    *pfResult = FALSE;

    hr = HrGetText(pRangeStart, pRangeEnd, &pszText);
    if (FAILED(hr) || HR_S_SPELLCONTINUE == hr || HR_S_SPELLBREAK == hr)
        goto error;

    Assert(NULL != pszText);
    for(psz = pszText; *psz; psz = CharNext(psz))
    {
        if (IsSpace(psz))
        {
            *pfResult = TRUE;
            break;
        }
    }
        
error:
    SafeMemFree(pszText);

    return hr;
}

HRESULT CSpell::HrGetNextWordRange(IHTMLTxtRange* pRange)
{
    HRESULT             hr = NOERROR;
    IMarkupPointer      *pRangeStart = NULL;
    IMarkupPointer      *pRangeEnd = NULL;
    IMarkupPointer      *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE markupContext;
    long                cch;
    OLECHAR             chText[64];
    BOOL                fResult;
    BOOL                fFoundWhite;
    
    if (pRange==NULL)
        return E_INVALIDARG;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MovePointersToRange(pRange, pRangeStart, pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = pRangeStart->IsEqualTo(pRangeEnd, &fResult);
    if (FAILED(hr))
        goto error;

    if (!fResult)
    {
        do
        {
            hr = pRangeStart->MoveUnit(MOVEUNIT_NEXTWORDBEGIN);
            if (FAILED(hr))
                goto error;

            // make sure beyond the old end
            hr = pRangeStart->IsLeftOf(pRangeEnd, &fResult);
            if (FAILED(hr))
                goto error;
                
        } while(fResult);

        hr = pRangeEnd->MoveToPointer(pRangeStart);
        if (FAILED(hr))
            goto error;
    }
    
    hr = pRangeEnd->MoveUnit(MOVEUNIT_NEXTWORDEND);
    if (FAILED(hr))
        goto error;
    
processNextWord:
    // check to see if we have anything
    hr = pRangeEnd->IsRightOf(pRangeStart, &fResult);
    if (FAILED(hr))
        goto error;

    // if the end is not to the right of the start then we do not have a word
    if (!fResult)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // strip preceding puncts or white space
    // words can also be created with just puncts and whitespace
    {
        while(TRUE)
        {
            cch = 1;
            hr = pRangeStart->Right(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeStart->IsLeftOf(pRangeEnd, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = pRangeEnd->MoveUnit(MOVEUNIT_NEXTWORDEND);
                if (FAILED(hr))
                    goto error;

                continue;
            }

            if (markupContext == CONTEXT_TYPE_Text && 0 == ((C1_SPACE | C1_PUNCT) & GetWCharType(chText[0])))
                break;

            cch = 1;
            hr = pRangeStart->Right(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;
        }
    }

    // check for white space and remove
    {
        fFoundWhite = FALSE;

        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
            
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeTemp->IsRightOf(pRangeStart, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = HR_S_SPELLBREAK;
                goto error;
            }

            if (markupContext == CONTEXT_TYPE_Text)
            {
                if (0 == (C1_SPACE & GetWCharType(chText[0])))
                {
                    if (!fFoundWhite)
                        break;
                    
                    goto finished;
                }

                fFoundWhite = TRUE;
            }

            cch = 1;
            hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text)
            {
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;
            }
        }
    }

    // now look for a period
    {
        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
        
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            if (markupContext == CONTEXT_TYPE_Text && chText[0] != L'.')
                goto finished;

            cch = 1;
            hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text && chText[0] == L'.')
            {
                hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                if (FAILED(hr))
                    goto error;

                if (fResult)
                    goto finished;              
                    
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;

                // scan ahead for characters
                // need to check for i.e. -- abbreviations
                // it sure would be nice if Trident could do this!!
                {
                    while(TRUE)
                    {
                        cch = 1;
                        hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
                        if (FAILED(hr))
                            goto error;

                        if (markupContext == CONTEXT_TYPE_None)
                            goto finished;

                        if (markupContext == CONTEXT_TYPE_Text && 0 == (C1_SPACE & GetWCharType(chText[0])))
                            goto finished;

                        cch = 1;
                        hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
                        if (FAILED(hr))
                            goto error;

                        // we found more text
                        // need to check to see if we crossed white space to get here
                        if (markupContext == CONTEXT_TYPE_Text)
                        {
                            hr = pRangeTemp->MoveToPointer(pRangeEnd);
                            if (FAILED(hr))
                                goto error;

                            hr = pRangeTemp->MoveUnit(MOVEUNIT_NEXTWORDEND);
                            if (FAILED(hr))
                                goto finished;

                            hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                            if (FAILED(hr))
                                goto error;

                            if (fResult)
                                goto finished;
                                                            
                            pRangeEnd->MoveToPointer(pRangeTemp);
                            if (FAILED(hr))
                                goto error;
                                
                            goto processNextWord;
                        }
                    }
                }
                    
                goto finished;
            }

        }
    }

finished:
    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pRange);
    if (FAILED(hr))
        goto error;

error:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);
        
    return hr;
}

BOOL CSpell::FIgnore(IHTMLTxtRange *pRangeChecking)
{
    HRESULT                 hr;
    IHTMLAnchorElement      *pAE=0;
    IHTMLElement            *pElemParent=0;
    BOOL                    fRet = FALSE;
    BSTR                    bstr=0;
    IHTMLTxtRange           *pRange=0;
    VARIANT_BOOL            fSuccess;

    if(pRangeChecking == NULL)
        return fRet;

    if(FIgnoreURL())
    {
        hr = pRangeChecking->duplicate(&pRange);
        if(FAILED(hr))
            goto Cleanup;

        hr = pRange->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto Cleanup;

        hr = pRange->expand((BSTR)c_bstr_Character, &fSuccess);
        if(FAILED(hr))
            goto Cleanup;

        // check pRangeChecking if we are on URL
        hr = pRange->parentElement(&pElemParent);
        if(FAILED(hr))
            goto Cleanup;

        hr = pElemParent->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE);
        if(FAILED(hr))
            goto Cleanup;

        hr = pAE->get_href(&bstr);
        if(FAILED(hr))
            goto Cleanup;

        if(bstr != NULL)
        {
            fRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseObj(pElemParent);
    ReleaseObj(pAE);
    ReleaseObj(pRange);
    SafeSysFreeString(bstr);
    return fRet;
}

// scotts@directeq.com - can now specify dict index - 53193
HRESULT CSpell::AddToUdrW(WCHAR* pwsz, PROOFLEX lex)
{
    m_pfnSpellerAddUdr(m_pid, lex, pwsz);
    return NOERROR;
}

// scotts@directeq.com - can now specify dict index - 53193
HRESULT CSpell::AddToUdrA(CHAR* psz, PROOFLEX lex)
{
    WCHAR   wszBuf[cchEditBufferMax]={0};
    MultiByteToWideChar(CP_ACP, 0, psz, -1, wszBuf, ARRAYSIZE(wszBuf)-1);
    return AddToUdrW(wszBuf, lex);
}

HRESULT CSpell::HrProcessSpellErrors()
{
    int     idSpellErrorString;
    HRESULT hr = S_OK;

    WideCharToMultiByte(GetCodePage(), 0, m_wsib.pwsz, -1, m_szWrongWord, sizeof(m_szWrongWord)-1, NULL, NULL);

    // Select error word in edit control except for Abbreviation warnings
    if (m_wsrb.sstat != sstatWordConsideredAbbreviation && m_pRangeChecking)
    {
        hr = m_pRangeChecking->select();
        if(FAILED(hr))
            goto End;
    }

    // Process spelling error
    if (m_wsrb.sstat == sstatReturningChangeAlways ||
        m_wsrb.sstat == sstatReturningChangeOnce)
    {
        WideCharToMultiByte(GetCodePage(), 0, m_wsrb.pwsz, -1, m_szEdited, sizeof(m_szEdited)-1, NULL, NULL);

        // "Change always" was returned.  This means we have to do the replacement
        // automatically and then find the next spelling error.
        if (m_wsrb.sstat==sstatReturningChangeAlways)
        {
            FVerifyThisText(m_szEdited, TRUE);
            m_fCanUndo = FALSE; // can't undo automatic replacements
            hr = HrReplaceErrorText(TRUE, FALSE);
            if (FAILED(hr))
                goto End;
            m_wsrb.sstat = sstatNoErrors;
            HrFindErrors();
        }
    }
    else if (m_wsrb.sstat == sstatWordConsideredAbbreviation)
    {
        // An abbreviation was returned.  We need to add it to the IgnoreAlways cache and
        // find the next spelling error.
        AddToUdrW((WCHAR*)m_wsib.pwsz, m_rgprflex[1]);
        m_wsrb.sstat = sstatNoErrors;
        HrFindErrors();

    }
    else
        StrCpyN(m_szEdited, m_szWrongWord, ARRAYSIZE(m_szEdited));


    // Load the right error description string
    switch (m_wsrb.sstat)
    {
    case sstatUnknownInputWord:
    case sstatReturningChangeOnce:
    case sstatInitialNumeral:
        idSpellErrorString = idsSpellWordNotFound;
        break;
    case sstatRepeatWord:
        idSpellErrorString = idsSpellRepeatWord;
        break;
    case sstatErrorCapitalization:
        idSpellErrorString = idsSpellWordNeedsCap;
        break;
    }

    LoadString(g_hLocRes, idSpellErrorString, m_szErrType,
               sizeof(m_szErrType)/sizeof(TCHAR));

    // Handle suggestions
    m_fSuggestions = FALSE;
#ifdef __WBK__NEVER__
    if (m_wsrb.sstat == sstatReturningChangeOnce)
    {
        // Automatic suggestion of one word
        m_fSuggestions = TRUE;
        m_fNoneSuggested = FALSE;
    }
    else
#endif // __WBK__NEVER__
    {
        // Enumerate suggestion list if requested
        if (m_fAlwaysSuggest)
            hr = HrSpellSuggest();
    }

End:
    return hr;
}


HRESULT CSpell::HrReplaceErrorText(BOOL fChangeAll, BOOL fAddToUdr)
{
    HRESULT     hr=NOERROR;
    WCHAR       wszWrong[cchEditBufferMax]={0};
    WCHAR       wszEdited[cchEditBufferMax]={0};
    int         cwch;
    
    if (fAddToUdr)
    {
        RemoveTrailingSpace(m_szWrongWord);
        
        cwch = MultiByteToWideChar(GetCodePage(), 0, m_szWrongWord, -1, wszWrong, ARRAYSIZE(wszWrong)-1);
        Assert(cwch);
        
        cwch = MultiByteToWideChar(GetCodePage(), 0, m_szEdited, -1, wszEdited, ARRAYSIZE(wszEdited)-1);
        Assert(cwch);
        
        hr = m_pfnSpellerAddChangeUdr(m_pid, fChangeAll ? lxtChangeAlways : lxtChangeOnce, wszWrong, wszEdited);
        if (FAILED(hr))
            goto error;
    }

    hr = HrReplaceSel(m_szEdited);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT CSpell::HrCheckWord(LPCSTR pszWord) 
{
    DWORD               cwchWord;
    PTEC                ptec;
    SPELLERSUGGESTION   sugg;
    
    cwchWord = MultiByteToWideChar(GetCodePage(), 0, pszWord, -1, m_wszIn, ARRAYSIZE(m_wszIn)-1);
    ZeroMemory(&m_wsrb, sizeof(m_wsrb));
    ZeroMemory(&m_wsib, sizeof(m_wsib));
    m_wsib.pwsz     = m_wszIn;
    m_wsib.cch      = cwchWord;

    m_wsib.clex     = m_clex; 
    m_wsib.prglex   = m_rgprflex;
    m_wsib.ichStart = 0;
    m_wsib.cchUse   = cwchWord;
    m_wsrb.pwsz     = m_wszRet;
    m_wsrb.cchAlloc = ARRAYSIZE(m_wszRet);
    m_wsrb.cszAlloc = 1; // we've got space for 1 speller suggestion
    m_wsrb.prgsugg  = &sugg;  

    // scotts@directeq.com - "repeat word" bug fix - 2757, 13573, 56057
    // m_wsib.sstate should only be sstateIsContinued after the first call to this function
    // (e.g., when a new speller session is invoked using F7 or the menu item).
    // This allows the spell code to accurately track "repeat" words.
    if (m_fSpellContinue)
        m_wsib.sstate = sstateIsContinued;
    else
        m_fSpellContinue = TRUE;

    ptec = m_pfnSpellerCheck(m_pid, scmdVerifyBuffer, &m_wsib, &m_wsrb);

    // do we haveinvalid characters, if so return NOERR
    if (ProofMajorErr(ptec) != ptecNoErrors && ProofMinorErr(ptec) == ptecInvalidEntry)
    {
        // force it to be correct
        m_wsrb.sstat = sstatNoErrors;

        return NOERROR;
    }
    
    if (ptec != ptecNoErrors)
        
        return E_FAIL;

    return NOERROR;
}

HRESULT CSpell::HrSpellSuggest()
{
    int                 cchWord;
    WCHAR               wszBuff[cchMaxSuggestBuff]={0};
    WCHAR               wszWord[cchEditBufferMax]={0};
    SPELLERSUGGESTION   rgsugg[20];
    TCHAR              *pchNextSlot=0;
    ULONG               iszSuggestion;
    int                 cchSuggestion;
    SPELLERSUGGESTION  *pSuggestion;
    TCHAR              *pchLim=0;
    PTEC                ptec;
    SPELLERSTATUS       sstat;

    sstat = m_wsrb.sstat;
    cchWord = MultiByteToWideChar(GetCodePage(), 0, m_szEdited, -1, wszWord, ARRAYSIZE(wszWord)-1);
    m_wsib.cch      = cchWord;
    m_wsib.clex     = m_clex; 
    m_wsib.prglex   = m_rgprflex;
    m_wsib.ichStart = 0;
    m_wsib.cchUse   = cchWord;
    m_wsib.pwsz     = wszWord;

    m_wsrb.prgsugg  = rgsugg;
    m_wsrb.cszAlloc = ARRAYSIZE(rgsugg);
    m_wsrb.pwsz     = wszBuff;
    m_wsrb.cchAlloc = ARRAYSIZE(wszBuff);

    ptec = m_pfnSpellerCheck(m_pid, scmdSuggest, &m_wsib, &m_wsrb);
    m_fNoneSuggested = (m_wsrb.csz == 0);

    pchLim = &m_szSuggest[ARRAYSIZE(m_szSuggest)-1];
    pchNextSlot = m_szSuggest;;
    do
    {
        pSuggestion = m_wsrb.prgsugg;
        if (sstatMoreInfoThanBufferCouldHold == m_wsrb.sstat)
        {
            m_wsrb.csz = m_wsrb.cszAlloc;
        }
        for (iszSuggestion = 0; iszSuggestion < m_wsrb.csz; iszSuggestion++)
        {
            cchSuggestion = WideCharToMultiByte(GetCodePage(), 0, pSuggestion->pwsz, -1, 
                                                pchNextSlot, (int) (pchLim-pchNextSlot), NULL, NULL);

            // bradk@directeq.com - raid 29322
            // make sure words do not have trailing spaces
            // only the French speller returns words with trailing spaces
            RemoveTrailingSpace(pchNextSlot);
            cchSuggestion = lstrlen(pchNextSlot)+1;

            pSuggestion++;
            if (cchSuggestion > 0)
                pchNextSlot += cchSuggestion;
            Assert(pchNextSlot <= pchLim);
        }
        ptec = m_pfnSpellerCheck(m_pid, scmdSuggestMore, &m_wsib, &m_wsrb);
    } while (ptec == ptecNoErrors && m_wsrb.sstat!=sstatNoMoreSuggestions);
    *pchNextSlot = '\0';
    m_wsrb.sstat = sstat;
    m_fSuggestions = TRUE;

    return NOERROR;
}


VOID CSpell::FillSuggestLbx()
{
    HWND        hwndLbx;
    INT         isz;
    LPTSTR      sz;
    LPTSTR      pch;

    // Empty contents regardless
    hwndLbx = GetDlgItem(m_hwndDlg, LBX_Spell_Suggest);
    ListBox_ResetContent(hwndLbx);

    // We didn't even try to get any suggestions
    if (!m_fSuggestions)
        return;

    // We tried to get suggestions
    pch = m_szSuggest;
    if (*pch == '\0')
    {
        LoadString(g_hLocRes, idsSpellNoSuggestions, m_szTempBuffer,
                   sizeof(m_szTempBuffer)/sizeof(TCHAR));
        ListBox_AddString(hwndLbx, m_szTempBuffer);
    }
    else
    {
        while(*pch != '\0')
        {
            ListBox_AddString(hwndLbx, pch);
            while(*pch != '\0')
                pch++;
            pch++;
        }
    }

}

VOID UpdateEditedFromSuggest(HWND hwndDlg, HWND hwndEdited, HWND hwndSuggest)
{
    INT     nSel;
    INT     cch;
    LPSTR   szTemp;

    nSel = ListBox_GetCurSel(hwndSuggest);
    cch = ListBox_GetTextLen(hwndSuggest, nSel) + 1;
    if (MemAlloc((LPVOID *) &szTemp, cch))
    {
        ListBox_GetText(hwndSuggest, nSel, szTemp);
        SetWindowText(hwndEdited, szTemp);

        // Clear default button style from "Ignore" button and set default to "Change"
        Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Ignore), BS_PUSHBUTTON, TRUE);
        SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Change, 0L);
        Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Change), BS_DEFPUSHBUTTON, TRUE);

        Edit_SetSel(hwndEdited, 0, 32767);  // select the whole thing
        Edit_SetModify(hwndEdited, TRUE);
        MemFree(szTemp);
    }
}


BOOL CSpell::FVerifyThisText(LPSTR szThisText, BOOL /*fProcessOnly*/)
{
    BOOL    fReturn=FALSE;
    HRESULT hr;

    Assert(szThisText);

    hr = HrCheckWord(szThisText);
    if (FAILED(hr))
        goto error;

    switch (m_wsrb.sstat)
    {
    case sstatUnknownInputWord:
    case sstatInitialNumeral:
    case sstatErrorCapitalization:
        if (AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsSpellCaption), MAKEINTRESOURCEW(idsSpellMsgConfirm), NULL, MB_YESNO | MB_ICONEXCLAMATION ) == IDYES)
            fReturn = TRUE;
        else
            fReturn = FALSE;
        break;
    default:
        fReturn = TRUE;
        break;
    }

error:
    return fReturn;
}


VOID CSpell::SpellSaveUndo(INT idButton)
{
    HRESULT     hr = NOERROR;

    if(!m_pRangeChecking)
        return;

    SafeRelease(m_pRangeUndoSave);
    m_pRangeChecking->duplicate(&m_pRangeUndoSave);
    if(!m_pRangeUndoSave)
        goto error;

    m_fCanUndo = TRUE;

error:
    return;
}

VOID CSpell::SpellDoUndo()
{
    HRESULT hr = NOERROR;
    IOleCommandTarget* pCmdTarget = NULL;
    CHARRANGE chrg = {0};
    LONG    lMin = 0;

    m_fCanUndo = FALSE;

    if(!m_pRangeUndoSave)
        goto Cleanup;

    SafeRelease(m_pRangeChecking);
    m_pRangeUndoSave->duplicate(&m_pRangeChecking);
    if(!m_pRangeChecking)
        goto Cleanup;


    hr = m_pRangeChecking->collapse(VARIANT_TRUE);
    if(FAILED(hr))
        goto Cleanup;

    if (m_fUndoChange)
    {
        m_fUndoChange = FALSE;
        hr = m_pDoc->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
        if(FAILED(hr))  
            goto Cleanup;
    
        hr = pCmdTarget->Exec(&CMDSETID_Forms3,
                           IDM_UNDO,
                           MSOCMDEXECOPT_DONTPROMPTUSER,
                           NULL, NULL);
        if(FAILED(hr))  
            goto Cleanup;
    }

Cleanup:
    ReleaseObj(pCmdTarget);

}


CSpell::CSpell(IHTMLDocument2* pDoc, IOleCommandTarget* pParentCmdTarget, DWORD dwSpellOpt)
{
    HRESULT     hr;
    
    Assert(pDoc);
    m_pDoc = pDoc;
    m_pDoc->AddRef();

    Assert(pParentCmdTarget);
    m_pParentCmdTarget = pParentCmdTarget;
    m_pParentCmdTarget->AddRef();

    m_hwndDlg = NULL;
    m_cRef = 1;
    m_fSpellContinue = FALSE;
    m_fCanUndo = FALSE;
    m_fUndoChange = FALSE;
    m_State = SEL;
    m_pRangeDocStartSelStart = NULL;
    m_pRangeSel = NULL;
    m_pRangeSelExpand = NULL;
    m_pRangeSelEndDocEnd = NULL;
    m_pRangeChecking = NULL;
    m_pRangeUndoSave = NULL;
    m_hr = NOERROR;
    m_hinstDll = NULL;
    ZeroMemory(&m_wsib, sizeof(m_wsib));
    ZeroMemory(&m_wsrb, sizeof(m_wsrb));
    ZeroMemory(&m_pid, sizeof(m_pid));
    m_fIgnoreScope = FALSE;
    m_dwCookieNotify = 0;
    m_dwOpt = dwSpellOpt;

    m_langid = lidUnknown;

    m_clex = 0;
    ZeroMemory(&m_rgprflex, sizeof(m_rgprflex));

    m_pMarkup = NULL;
    m_pBodyElem = NULL;

    m_fCSAPI3T1 = FALSE;
}

CSpell::~CSpell()
{
    CloseSpeller();

    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);

    SafeRelease(m_pMarkup);

    SafeRelease(m_pBodyElem);
}


ULONG CSpell::AddRef()
{
    return ++m_cRef;
}


ULONG CSpell::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CSpell::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



/////////////////////////////////////////////////////////////////////////////
//
//  IDispatch
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSpell::GetIDsOfNames(
    REFIID      /*riid*/,
    OLECHAR **  /*rgszNames*/,
    UINT        /*cNames*/,
    LCID        /*lcid*/,
    DISPID *    /*rgDispId*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSpell::GetTypeInfo(
    UINT        /*iTInfo*/,
    LCID        /*lcid*/,
    ITypeInfo **ppTInfo)
{
    if (ppTInfo)
        *ppTInfo=NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CSpell::GetTypeInfoCount(UINT *pctinfo)
{
    if (pctinfo)
        {
        *pctinfo=0;
        return NOERROR;
        }
    else
        return E_POINTER;
}

#ifdef BACKGROUNDSPELL
STDMETHODIMP CSpell::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            wFlags,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       /*pVarResult*/,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    IHTMLWindow2        *pWindow=0;
    IHTMLEventObj       *pEvent=0;
    BSTR                bstr=0;
    HRESULT             hr=E_NOTIMPL;
    LONG                lKeyCode=0;
    LONG                cb;


    if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONKEYUP &&
        (wFlags & DISPATCH_METHOD))
    {
        // Order of events:
        // document gives us window gives us event object
        // the event object can tell us which button was clicked
        // event gives us source element gives us ID
        // a couple lstrcmps will tell us which one got hit
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_keyCode(&lKeyCode);
                if (lKeyCode == 32 || lKeyCode == 188/*','*/ || lKeyCode == 190/*'.'*/ || lKeyCode == 185/*':'*/ || lKeyCode == 186/*';'*/)
                {
                    IHTMLTxtRange *pTxtRange=0;
                    VARIANT_BOOL   fSuccess;
                    GetSelection(&pTxtRange);
                    if (pTxtRange)
                    {
                        pTxtRange->move((BSTR)c_bstr_Character, -2, &cb);
                        pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
                        //DumpRange(pRangeDup);
                        //pTxtRange->setEndPoint((BSTR)c_bstr_StartToStart, pRangeDup);
                        //DumpRange(pTxtRange);
                        //pRangeDup->Release();

                        m_Stack.push(pTxtRange);
                        pTxtRange->Release();
                    }
                }
                else if (lKeyCode == 8 /*backspace*/|| lKeyCode == 46/*del*/)
                {
                    IHTMLTxtRange *pTxtRange=0;
                    VARIANT_BOOL   fSuccess;
                    LONG           cb;
                    GetSelection(&pTxtRange);
                    if (pTxtRange)
                    {
                        pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
                        if (HrHasSquiggle(pTxtRange)==S_OK)
                        {
                            //DumpRange(pTxtRange);
                            m_Stack.push(pTxtRange);
                        }
                        pTxtRange->Release();
                    }
                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    } 
    else if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS && (wFlags & DISPATCH_METHOD))
    {
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_keyCode(&lKeyCode);
                if (lKeyCode == 18)// CTRL+R
                {
                    IHTMLTxtRange*          pRangeDoc = NULL;

                    if (m_pBodyElem)
                        m_pBodyElem->createTextRange(&pRangeDoc);

                    if (pRangeDoc)
                    {
                        pRangeDoc->move((BSTR)c_bstr_Character, -1, &cb);
                        m_Stack.push(pRangeDoc);
                        pRangeDoc->Release();
                    }


                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    }




    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrHasSquiggle(IHTMLTxtRange *pTxtRange)
{
    BSTR    bstr=0;
    HRESULT hr;
    LPWSTR  pwszSquiggleStart=0, pwszSquiggleEnd=0, pwszSquiggleAfter=0;

    hr = pTxtRange->get_htmlText(&bstr);
    if(FAILED(hr) || bstr==0 || *bstr==L'\0')
    {
        hr = S_FALSE;
        goto error;
    }

    hr = S_FALSE;
    pwszSquiggleStart = StrStrIW(bstr, L"<SPAN class=badspelling");
    if (pwszSquiggleStart)
    {
        pwszSquiggleEnd = StrStrIW(bstr, L"</SPAN>");
        if (pwszSquiggleEnd)
        {
            pwszSquiggleAfter = pwszSquiggleEnd + 7;
            if (*pwszSquiggleAfter == L' ' || *pwszSquiggleAfter == L'\0' || *pwszSquiggleAfter == L'&')
                hr = S_OK;
        }
    }

error:
    SafeSysFreeString(bstr);
    return hr;
}
#endif // BACKGROUNDSPELL


BOOL CSpell::OpenSpeller()
{
    SpellerParams   params;
    DWORD           dwSel;
    LANGID          langid;
    
    // LoadOldSpeller is called within LoadNewSpeller
    // We should be checking for V1 spellers after failing
    // for the desired V3 speller, then go on to check for
    // default speller and the speller for 1033.
    if (!LoadNewSpeller())
        goto error;

    if (!OpenUserDictionaries())
        goto error;

    dwSel = sobitStdOptions;
    m_fAlwaysSuggest = !!FAlwaysSuggest();
    if (FIgnoreNumber())
        dwSel |= sobitIgnoreMixedDigits;
    else
        dwSel &= ~sobitIgnoreMixedDigits;

    if (FIgnoreUpper())
        dwSel |= sobitIgnoreAllCaps;
    else
        dwSel &= ~sobitIgnoreAllCaps;

    if (m_pfnSpellerSetOptions(m_pid, soselBits, dwSel) != ptecNoErrors)
        goto error;

    return TRUE;

error:
    CloseSpeller();
    
    return FALSE;
}


BOOL FNewer(WORD *pwVerOld, WORD *pwVerNew)
{
    BOOL fOK = FALSE;
    
    Assert(pwVerOld);
    Assert(pwVerNew);

    if (pwVerNew[0] > pwVerOld[0])
        fOK = TRUE;
    else if (pwVerNew[0] == pwVerOld[0])
    {
        if (pwVerNew[1] > pwVerOld[1])
            fOK = TRUE;
        else if (pwVerNew[1] == pwVerOld[1])
        {
            if (pwVerNew[2] > pwVerOld[2])
                fOK = TRUE;
            else if (pwVerNew[2] == pwVerOld[2])
            {
                if (pwVerNew[3] >= pwVerOld[3])
                    fOK = TRUE;
            }
        }
    }

    return fOK;
}

BOOL GetDllVersion(LPTSTR pszDll, WORD *pwVer, int nCountOfVers)
{
    Assert(pszDll);
    Assert(pwVer);

    BOOL fOK = FALSE;
    DWORD dwVerInfoSize, dwVerHnd;
    LPSTR pszInfo, pszVersion, pszT;
    LPWORD pwTrans;
    UINT uLen;
    char szGet[MAX_PATH];
    int i;

    ZeroMemory(pwVer, nCountOfVers * sizeof(pwVer[0]));

    if (dwVerInfoSize = GetFileVersionInfoSize(pszDll, &dwVerHnd))
    {
        if (pszInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
        {
            if (GetFileVersionInfo(pszDll, dwVerHnd, dwVerInfoSize, pszInfo))
            {
                if (VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID*)&pwTrans, &uLen) &&
                    uLen >= (2 * sizeof(WORD)))
                {
                    // set up buffer for calls to VerQueryValue()
                    wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\FileVersion", pwTrans[0], pwTrans[1]);
                    
                    if (VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen)
                    {
                        i = 0;
                        while (*pszVersion)
                        {
                            if ((',' == *pszVersion) || ('.' == *pszVersion))
                                i++;
                            else
                            {
                                pwVer[i] *= 10;
                                pwVer[i] += (*pszVersion - '0');
                            }

                            pszVersion++;
                        }
                                
                        fOK = TRUE;
                    }
                }
            }

            GlobalFree((HGLOBAL)pszInfo);
        }
    }

    return fOK;
}

HINSTANCE LoadCSAPI3T1()
{
    static BOOL s_fInit = FALSE;
    HINSTANCE hinstLocal;

    EnterCriticalSection(&g_csCSAPI3T1);

    // Avoid doing this for every note!
    if (!s_fInit)
    {
        typedef enum
        {
            CSAPI_FIRST,
            CSAPI_DARWIN = CSAPI_FIRST,
            CSAPI_COMMON,
            CSAPI_OE,
            CSAPI_MAX,
        } CSAPISRC;

        BOOL fCheck;
        
        // cb is for BYTE counts, cch for CHARACTER counts
        DWORD cbDllPath;
        DWORD cchDllPath;

        int csapisrc;
        // Info about the dll currently being examined
        TCHAR szDllPath[MAX_PATH];
        WORD wVer[4] = {0};

        // Info about the dll we will ultimately load
        TCHAR szNewestDllPath[MAX_PATH];
        WORD wVerNewest[4] = {0};

        szDllPath[0] = TEXT('\0');
        szNewestDllPath[0] = TEXT('\0');

        // Avoid doing this for every note!
        s_fInit = TRUE;
    
        for (csapisrc = CSAPI_FIRST; csapisrc < CSAPI_MAX; csapisrc++)
        {
            // Assume we can't find the dll using the current method, so there's no need to look at its version
            fCheck = FALSE;
        
            switch (csapisrc)
            {
            // see if Darwin knows where it is
            case CSAPI_DARWIN:
                {    
                    UINT                            installState;

                    cchDllPath = ARRAYSIZE(szDllPath);
#ifdef DEBUG
                    installState = MsiLocateComponent(CSAPI3T1_DEBUG_GUID, szDllPath, &cchDllPath);
                    if (installState != INSTALLSTATE_LOCAL)
                    {
                        cchDllPath = ARRAYSIZE(szDllPath);
                        installState = MsiLocateComponent(CSAPI3T1_GUID, szDllPath, &cchDllPath);
                    }
#else   // DEBUG
                    installState = MsiLocateComponent(CSAPI3T1_GUID, szDllPath, &cchDllPath);
#endif  // DEBUG

                    // Only bother looking at the version if dll is installed
                    fCheck = (INSTALLSTATE_LOCAL == installState);
                }
                break;

            // Is it in Common Files\Microsoft Shared\Proof?
            case CSAPI_COMMON:
                {
                    DWORD           dwType;
                    HKEY            hkey = NULL;
                    LPTSTR          pszEnd;

                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedTools, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        cbDllPath = sizeof(szDllPath);
                        if (SHQueryValueEx(hkey, c_szRegSharedToolsPath, 0L, &dwType, szDllPath, &cbDllPath) == ERROR_SUCCESS)
                        {
                            pszEnd = PathAddBackslash(szDllPath);
                            StrCpyN(pszEnd, c_szSpellCSAPI3T1Path, ARRAYSIZE(szDllPath) - (DWORD)(pszEnd - szDllPath));
                            fCheck = TRUE;
                        }

                        RegCloseKey(hkey);
                    }
                }
                break;

            // Is it in the OE directory?
            case CSAPI_OE:
                {
                    DWORD           dwType;
                    HKEY            hkey = NULL;
                    LPTSTR          pszEnd;

                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        cbDllPath = sizeof(szDllPath);
                        if (SHQueryValueEx(hkey, c_szInstallRoot, 0L, &dwType, szDllPath, &cbDllPath) == ERROR_SUCCESS)
                        {
                            pszEnd = PathAddBackslash(szDllPath);
                            StrCpyN(pszEnd, c_szCSAPI3T1, ARRAYSIZE(szDllPath) - (DWORD)(pszEnd - szDllPath));
                            fCheck = TRUE;
                        }

                        RegCloseKey(hkey);
                    }
                }
                break;
        
            default:
                AssertSz(FALSE, "Unhandled case hit while looking for csapi3t1.dll!");
                break;
            }

            // Figure out the version of the dll if needed
            if (fCheck && GetDllVersion(szDllPath, wVer, ARRAYSIZE(wVer)))
            {
                // If it's newer, remember the new version and the file's location
                if (FNewer(wVerNewest, wVer))
                {
                    CopyMemory(wVerNewest, wVer, sizeof(wVer));
                    StrCpyN(szNewestDllPath, szDllPath, ARRAYSIZE(szNewestDllPath));
                }
            }

        }

        // Assuming we found something, try to load it
        if (szNewestDllPath[0])
            g_hinstCSAPI3T1 = LoadLibrary(szNewestDllPath);
    }
    
    hinstLocal = g_hinstCSAPI3T1;
    LeaveCriticalSection(&g_csCSAPI3T1);

    return hinstLocal;
}

BOOL CSpell::LoadOldSpeller()
{
    TCHAR           szLangId[MAX_PATH] = {0};
    TCHAR           rgchBufKeyTest[MAX_PATH] = {0};
    TCHAR           rgchBuf[MAX_PATH] = {0};
    WCHAR           rgchBufW[MAX_PATH] = {0};
    TCHAR           rgchLex[MAX_PATH] = {0};
    WCHAR           rgchLexW[MAX_PATH] = {0};
    WCHAR           rgchUserDictW[MAX_PATH]={0};
    PROOFLEXIN      plxin;
    PROOFLEXOUT     plxout;
    SpellerParams   params;
    LANGID          langid;

    m_hinstDll = LoadCSAPI3T1();
    if (!m_hinstDll)
    {
        m_pfnSpellerCloseLex  = 0;
        m_pfnSpellerTerminate = 0;
        return FALSE;
    }
    
    // We are using the global csapi3t1.dll, so don't free it!
    m_fCSAPI3T1 = TRUE;

    GetAddr(m_pfnSpellerSetDllName, PROOFSETDLLNAME,"SpellerSetDllName");
    GetAddr(m_pfnSpellerVersion,    PROOFVERSION,   "SpellerVersion");
    GetAddr(m_pfnSpellerInit,       PROOFINIT,      "SpellerInit");
    GetAddr(m_pfnSpellerTerminate,  PROOFTERMINATE, "SpellerTerminate");
    GetAddr(m_pfnSpellerSetOptions, PROOFSETOPTIONS,"SpellerSetOptions");
    GetAddr(m_pfnSpellerOpenLex,    PROOFOPENLEX,   "SpellerOpenLex");
    GetAddr(m_pfnSpellerCloseLex,   PROOFCLOSELEX,  "SpellerCloseLex");
    GetAddr(m_pfnSpellerCheck,      SPELLERCHECK,   "SpellerCheck");
    GetAddr(m_pfnSpellerAddUdr,     SPELLERADDUDR,  "SpellerAddUdr");
    GetAddr(m_pfnSpellerBuiltInUdr, SPELLERBUILTINUDR, "SpellerBuiltinUdr");
    GetAddr(m_pfnSpellerAddChangeUdr, SPELLERADDCHANGEUDR, "SpellerAddChangeUdr");

    langid = WGetLangID(m_pParentCmdTarget);
    wnsprintf(szLangId, ARRAYSIZE(szLangId), "%d", langid);
    wnsprintf(rgchBufKeyTest, ARRAYSIZE(rgchBufKeyTest), c_szRegSpellKeyDef, szLangId);
    GetSpellingPaths(rgchBufKeyTest, rgchBuf, rgchLex, sizeof(rgchBuf)/sizeof(TCHAR));

    if (!*rgchBuf)
        return FALSE;
        
    MultiByteToWideChar(GetCodePage(), 0, rgchBuf, -1, rgchBufW, ARRAYSIZE(rgchBufW)-1);
    m_pfnSpellerSetDllName(rgchBufW, GetCodePage());
    
    params.versionAPI = PROOFTHISAPIVERSION;
    if (m_pfnSpellerInit(&m_pid, &params) != ptecNoErrors)
        return FALSE;

    m_langid = langid;

    // Tell the speller the name of the dictionary.  This requires unicode conversion.
    MultiByteToWideChar(CP_ACP, 0, rgchLex, -1, rgchLexW, ARRAYSIZE(rgchLexW)-1);

    // open the main dict
    plxin.pwszLex       = rgchLexW;
    plxin.fCreate       = FALSE;
    plxin.lxt           = lxtMain;
    plxin.lidExpected   = langid;

    memset(&plxout, 0, sizeof(plxout));
    
    if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
        return FALSE;
        
    m_rgprflex[0] = plxout.lex;
    m_clex++;

    return TRUE;

// needed by the GetAddr macro -- bite me!!!!!!
error:
    return FALSE;
}


BOOL CSpell::LoadNewSpeller()
{
    SpellerParams   params;
    LANGID          langid;
    TCHAR           rgchEngine[MAX_PATH];
    int             cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
    TCHAR           rgchLex[MAX_PATH];
    int             cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

    langid = WGetLangID(m_pParentCmdTarget);
    if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
    {
        if (!LoadOldSpeller())
        {
            langid = GetSystemDefaultLangID();
            if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
            {
                langid = 1033;  // bloody cultural imperialists.
                if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
                {
                    return FALSE;
                }
            }
        }
        else
            return TRUE;
    }

    Assert(rgchEngine[0]);  // should be something in the engine name!
    m_hinstDll = LoadLibrary(rgchEngine);
    if (!m_hinstDll)
    {
        m_pfnSpellerCloseLex  = 0;
        m_pfnSpellerTerminate = 0;
        return FALSE;
    }

    // We are not using csapi3t1.dll, so we should free it
    m_fCSAPI3T1 = FALSE;

    GetAddr(m_pfnSpellerVersion,    PROOFVERSION,   "SpellerVersion");
    GetAddr(m_pfnSpellerInit,       PROOFINIT,      "SpellerInit");
    GetAddr(m_pfnSpellerTerminate,  PROOFTERMINATE, "SpellerTerminate");
    GetAddr(m_pfnSpellerSetOptions, PROOFSETOPTIONS,"SpellerSetOptions");
    GetAddr(m_pfnSpellerOpenLex,    PROOFOPENLEX,   "SpellerOpenLex");
    GetAddr(m_pfnSpellerCloseLex,   PROOFCLOSELEX,  "SpellerCloseLex");
    GetAddr(m_pfnSpellerCheck,      SPELLERCHECK,   "SpellerCheck");
    GetAddr(m_pfnSpellerAddUdr,     SPELLERADDUDR,  "SpellerAddUdr");
    GetAddr(m_pfnSpellerBuiltInUdr, SPELLERBUILTINUDR, "SpellerBuiltinUdr");
    GetAddr(m_pfnSpellerAddChangeUdr, SPELLERADDCHANGEUDR, "SpellerAddChangeUdr");

    params.versionAPI = PROOFTHISAPIVERSION;
    if (m_pfnSpellerInit(&m_pid, &params) != ptecNoErrors)
        return FALSE;
    if (m_pfnSpellerSetOptions(m_pid, soselBits, 
            sobitSuggestFromUserLex | sobitIgnoreAllCaps | sobitIgnoreSingleLetter) != ptecNoErrors)
        return FALSE;

    m_langid = langid;

    // Hebrew does not have a main lex
    if ((langid != lidHebrew) || !m_fCSAPI3T1)
    {
        PROOFLEXIN      plxin;
        PROOFLEXOUT     plxout;
        WCHAR           rgchLexW[MAX_PATH]={0};
        
        // Tell the speller the name of the dictionary.  This requires unicode conversion.
        MultiByteToWideChar(CP_ACP, 0, rgchLex, -1, rgchLexW, ARRAYSIZE(rgchLexW)-1);

        // open the main dict
        plxin.pwszLex       = rgchLexW;
        plxin.fCreate       = FALSE;
        plxin.lxt           = lxtMain;
        plxin.lidExpected   = langid; 

        memset(&plxout, 0, sizeof(plxout));
        
        if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
            return FALSE;
            
        m_rgprflex[0] = plxout.lex;
        m_clex++;
    }
    
    return TRUE;

// needed by the GetAddr macro -- bite me!!!!!!
error:
    return FALSE;
}

BOOL EnumUserDictCallback(DWORD_PTR dwCookie, LPTSTR lpszDict)
{
    CSpell *pSpell = (CSpell*)dwCookie;
    
    Assert(pSpell);
    return pSpell->OpenUserDictionary(lpszDict);
}

BOOL CSpell::OpenUserDictionary(LPTSTR lpszDict)
{
    PROOFLEXIN  plxin;
    PROOFLEXOUT plxout;
    WCHAR       rgchUserDictW[MAX_PATH]={0};

    // make sure our directory exists
    {
        TCHAR   rgchDictDir[MAX_PATH];

        StrCpyN(rgchDictDir, lpszDict, ARRAYSIZE(rgchDictDir));

        PathRemoveFileSpec(rgchDictDir);
        OpenDirectory(rgchDictDir);
    }

    MultiByteToWideChar(CP_ACP, 0, lpszDict, -1, rgchUserDictW, ARRAYSIZE(rgchUserDictW)-1);

    plxin.pwszLex       = rgchUserDictW;
    plxin.fCreate       = TRUE;
    plxin.lxt           = lxtUser;
    plxin.lidExpected   = m_langid; 

    memset(&plxout, 0, sizeof(plxout));
    
    if ( m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
        return TRUE;
        
    m_rgprflex[m_clex++] = plxout.lex;

    return TRUE;
}

BOOL CSpell::OpenUserDictionaries()
{
    // now open the user dicts
    EnumUserDictionaries((DWORD_PTR)this, EnumUserDictCallback);

    // if only one dict open then we need to create default user dict
    if (m_clex == 1)
    {
        PROOFLEXIN  plxin;
        PROOFLEXOUT plxout;
        TCHAR       rgchUserDict[MAX_PATH]={0};

        if (GetDefaultUserDictionary(rgchUserDict, ARRAYSIZE(rgchUserDict)))
        {
            WCHAR   rgchUserDictW[MAX_PATH];
            
            // make sure our directory exists
            {
                TCHAR   rgchDictDir[MAX_PATH];

                StrCpyN(rgchDictDir, rgchUserDict, ARRAYSIZE(rgchDictDir));

                PathRemoveFileSpec(rgchDictDir);
                OpenDirectory(rgchDictDir);
            }

            MultiByteToWideChar(CP_ACP, 0, rgchUserDict, -1, rgchUserDictW, ARRAYSIZE(rgchUserDictW)-1);

            plxin.pwszLex       = rgchUserDictW;
            plxin.fCreate       = TRUE;
            plxin.lxt           = lxtUser;
            plxin.lidExpected   = m_langid;

            memset(&plxout, 0, sizeof(plxout));

            if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
                return TRUE;
                
            m_rgprflex[m_clex++] = plxout.lex;
        }
    }
    
    return TRUE;
}


VOID CSpell::CloseSpeller()
{
    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);

    if (m_pfnSpellerCloseLex)
    {
        for(int i=0; i<cchMaxDicts; i++)
        {
            if (m_rgprflex[i])
            {
                m_pfnSpellerCloseLex(m_pid, m_rgprflex[i], TRUE);
                m_rgprflex[i] = NULL;
            }
        }
    }

    if (m_pfnSpellerTerminate)
        m_pfnSpellerTerminate(m_pid, TRUE);

    m_pid = 0;
    
    m_pfnSpellerVersion     = 0;
    m_pfnSpellerInit        = 0;
    m_pfnSpellerTerminate   = 0;
    m_pfnSpellerSetOptions  = 0;
    m_pfnSpellerOpenLex     = 0;
    m_pfnSpellerCloseLex    = 0;
    m_pfnSpellerCheck       = 0;
    m_pfnSpellerAddUdr      = 0; 
    m_pfnSpellerAddChangeUdr= 0; 
    m_pfnSpellerBuiltInUdr  = 0;

    // As long as we are not using the global CSAPI3T1.DLL, free it
    if (m_hinstDll && !m_fCSAPI3T1)
    {
        FreeLibrary(m_hinstDll);
        m_hinstDll = NULL;
    }
}


BOOL CSpell::GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex)
{
    DWORD                           er;
    LPCSTR                          rgpszDictionaryTypes[] = {"Normal", "Consise", "Complete"}; 
    int                             cDictTypes = sizeof(rgpszDictionaryTypes) / sizeof(LPCSTR);
    int                             i;
    TCHAR                           rgchQual[MAX_PATH];
    DWORD                           cch;

    if (rgchEngine == NULL || rgchLex == NULL)
        return FALSE;

    *rgchEngine = 0;
    *rgchLex = 0;
    
    wnsprintf(rgchQual, ARRAYSIZE(rgchQual), "%d\\Normal", lgid);
    cch = cchEngine;

#ifdef DEBUG
    er = MsiProvideQualifiedComponent(SPELLER_DEBUG_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
    if (er != ERROR_SUCCESS)
    {
        cch = cchEngine;
        er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
    }
#else
    er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
#endif

    if (er != ERROR_SUCCESS) 
        return FALSE;

    bool fFound = FALSE;

    // Hebrew does not have a lex
    if ((lgid != lidHebrew) || !m_fCSAPI3T1)
    {
        for (i = 0; i < cDictTypes; i++)
        {
            wnsprintf(rgchQual, ARRAYSIZE(rgchQual), "%d\\%s",  lgid, rgpszDictionaryTypes[i]);
            cch = cchLex;
            
#ifdef DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_DEBUG_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
            if (er != ERROR_SUCCESS)
            {
                cch = cchLex;
                er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
            }
#else   // DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
#endif  // DEBUG

            if (ERROR_SUCCESS == er)
            {
                fFound = TRUE;
                break;
            }
        }
    }
    return fFound;
}

BOOL GetDefaultUserDictionary(TCHAR *rgchUserDict, int cchBuff)
{
    DWORD           dwType;
    DWORD           cbUserDict;
    HKEY            hkey = NULL;
    BOOL            fFound = FALSE;
    LPTSTR          pszEnd;
    
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedTools, 0, KEY_QUERY_VALUE, &hkey))
    {
        cbUserDict = cchBuff * sizeof(rgchUserDict[0]);
        
        if (SHQueryValueEx(hkey, c_szRegSharedToolsPath, 0L, &dwType, rgchUserDict, &cbUserDict) == ERROR_SUCCESS)
        {
            pszEnd = PathAddBackslash(rgchUserDict);
            if (pszEnd)
            {
                StrCpyN(pszEnd, c_szRegDefCustomDict, cchBuff - (DWORD)(pszEnd - rgchUserDict));

                fFound = TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    // if we where able to create a path to the user dict store it in the regdb
    if (fFound)
    {
        TCHAR   rgchBuf[cchMaxPathName];

        StrCpyN(rgchBuf, c_szRegSpellProfile, ARRAYSIZE(rgchBuf));
        StrCatBuff(rgchBuf, c_szRegSpellKeyCustom, ARRAYSIZE(rgchBuf));

        if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, rgchBuf, REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hkey, NULL) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkey, c_szRegSpellPathDict, 0, REG_SZ, (BYTE *)rgchUserDict, (lstrlen(rgchUserDict) + 1) * sizeof(TCHAR));

            RegCloseKey(hkey);
        }
    }
    
    return fFound;
}

VOID CSpell::DeInitRanges()
{
    VARIANT_BOOL fSuccess;

    if(m_pRangeSel)
        m_pRangeSel->select();

    SafeRelease(m_pRangeDocStartSelStart);
    SafeRelease(m_pRangeSel);
    SafeRelease(m_pRangeSelExpand);
    SafeRelease(m_pRangeSelEndDocEnd);
    SafeRelease(m_pRangeChecking);
    SafeRelease(m_pRangeUndoSave);
    SafeRelease(m_pBodyElem);
    SafeRelease(m_pMarkup);
    m_hwndDlg = NULL;
}


HRESULT CSpell::HrInitRanges(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg)
{
    HRESULT                 hr = NOERROR;
    IDispatch*              pID=0;
    VARIANT_BOOL            fSuccess;
    IHTMLTxtRange*          pRangeDoc = NULL;
    IHTMLSelectionObject*   pSel = NULL;
    BSTR                    bstr = NULL;
    IMarkupPointer          *pRangeStart = NULL;
    IMarkupPointer          *pRangeEnd = NULL;
    IMarkupPointer          *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE     markupContext;
    long                    cch;
    OLECHAR                 chText[64];
    BOOL                    fResult;

    Assert(m_pDoc);

    m_hwndNote = hwndMain;
    m_fShowDoneMsg = !fSuppressDoneMsg;

    m_pRangeIgnore = pRangeIgnore;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    m_pBodyElem->createTextRange(&pRangeDoc);
    if(!pRangeDoc)
    {
        hr = E_FAIL;
        goto error;
    }

    m_pDoc->get_selection(&pSel);
    if(!pSel)
    {
        hr = E_FAIL;
        goto error;
    }

    pSel->createRange(&pID);
    if(!pID)
    {
        hr = E_FAIL;
        goto error;
    }

    pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)&m_pRangeSel);
    if(!m_pRangeSel)
    {
        // if the selection is on an image or something rather than text, it fails.
        // So we just start spellchecking from the beginning.
        pRangeDoc->duplicate(&m_pRangeSel);
        if(!m_pRangeSel)
        {
            hr = E_FAIL;
            goto error;
        }

        hr = m_pRangeSel->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }

    Assert(m_pRangeSel);
    m_pRangeSel->duplicate(&m_pRangeSelExpand);
    if(!m_pRangeSelExpand)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelExpand->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeSel->get_text(&bstr);
    if(FAILED(hr))
        goto error;

    if(!bstr || lstrlenW(bstr) == 0)
    {
        m_State = SELENDDOCEND;
        hr = m_pRangeSelExpand->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }
    else
        m_State = SEL;

    // make sure we backup over any abbreviations
    // it would be nice if Trident could do this!
    {
        hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->MovePointersToRange(m_pRangeSelExpand, pRangeStart, pRangeEnd);
        if (FAILED(hr))
            goto error;

        // first check to see if we have a character to the right or a '.'
        // if not it's not an abbreviation
        {
            hr = pRangeTemp->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;
            
            while(TRUE)
            {
                cch = 1;
                hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_None)
                    goto noAbbreviation;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    WORD    wType;

                    wType = GetWCharType(chText[0]);
                    if ((C1_SPACE & wType) || ((C1_PUNCT & wType) && chText[0] != L'.'))
                        goto noAbbreviation;
                }

                cch = 1;
                hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                    if (FAILED(hr))
                        goto error;

                    if (fResult)
                        goto noAbbreviation;                
                                                
                    break;
                }
            }
        }

        // now look for a period
        {
processNextWord:
            hr = pRangeEnd->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;

            hr = pRangeTemp->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;
            
            while(TRUE)
            {
                cch = 1;
                hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_None)
                    goto finishedAbbreviation;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    WORD    wType;

                    wType = GetWCharType(chText[0]);
                    if ((C1_SPACE & wType) || ((C1_PUNCT & wType) && chText[0] != L'.'))
                        goto finishedAbbreviation;
                }

                cch = 1;
                hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_Text && chText[0] == L'.')
                {
                    hr = pRangeTemp->MoveUnit(MOVEUNIT_PREVWORDBEGIN);
                    if (FAILED(hr))
                        goto finishedAbbreviation;

                    hr = HrHasWhitespace(pRangeTemp, pRangeEnd, &fResult);
                    if (FAILED(hr))
                        goto error;

                    if (fResult)
                        goto finishedAbbreviation;
                                                    
                    pRangeStart->MoveToPointer(pRangeTemp);
                    if (FAILED(hr))
                        goto error;
                        
                    goto processNextWord;
                }
            }
        }

finishedAbbreviation:
        hr = m_pMarkup->MovePointersToRange(m_pRangeSelExpand, pRangeTemp, pRangeEnd);
        if (FAILED(hr))
            goto error;

        // check to see if we had a selection
        // if not be sure to set new selection correctly
        hr = pRangeTemp->IsEqualTo(pRangeEnd, &fResult);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->MoveRangeToPointers(pRangeStart, fResult ? pRangeStart : pRangeEnd, m_pRangeSelExpand);
        if (FAILED(hr))
            goto error;
noAbbreviation:
        ;
    }

    m_pBodyElem->createTextRange(&m_pRangeSelEndDocEnd);
    if(!m_pRangeSelEndDocEnd)
    {
        hr = E_FAIL;
        goto error;
    }

    m_pRangeSelEndDocEnd->duplicate(&m_pRangeDocStartSelStart);
    if(!m_pRangeDocStartSelStart)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelEndDocEnd->setEndPoint((BSTR)c_bstr_StartToEnd, m_pRangeSelExpand);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeSelEndDocEnd->setEndPoint((BSTR)c_bstr_EndToEnd, pRangeDoc);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeDocStartSelStart->setEndPoint((BSTR)c_bstr_StartToStart, pRangeDoc);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeDocStartSelStart->setEndPoint((BSTR)c_bstr_EndToStart, m_pRangeSelExpand);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pRangeDoc);
    ReleaseObj(pID);
    ReleaseObj(pSel);
    SafeSysFreeString(bstr);
    
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);

    return hr;
}


HRESULT CSpell::HrReplaceSel(LPSTR szWord)
{
    HRESULT     hr = NOERROR;
    BSTR        bstrGet=0, bstrPut=0;
    INT         cch;
    TCHAR       szBuf[cchEditBufferMax]={0};
    UINT        uCodePage;
    LPSTR       psz;
    BOOL        fSquiggle=FALSE;
    LONG        cb = 0;

    if(!m_pRangeChecking || szWord==NULL)
        return E_INVALIDARG;


    if (*szWord == 0)
    {
        hr = m_pRangeChecking->moveStart((BSTR)c_bstr_Character, -1, &cb);
        //If we failed to movestart, we just delete the word.
        hr = m_pRangeChecking->put_text(L"");
        goto error;
    }

#ifdef BACKGROUNDSPELL
    if (HrHasSquiggle(m_pRangeChecking)==S_OK)
        fSquiggle = TRUE;
#endif // BACKGROUNDSPELL
    
    hr = m_pRangeChecking->get_text(&bstrGet);
    if(!bstrGet || lstrlenW(bstrGet)==0)
        goto error;

    uCodePage = GetCodePage();

    cch = SysStringLen(bstrGet);
    if (!WideCharToMultiByte(uCodePage, 0, bstrGet, -1, szBuf, sizeof(szBuf), NULL, NULL))
    {
        hr = E_FAIL;
        goto error;
    }

    psz = StrChr(szBuf, ' ');
    if(psz)
    {
        TCHAR szPut[cchEditBufferMax]={0};
        wnsprintf(szPut, ARRAYSIZE(szPut), c_szFmt, szWord, psz);
        hr = HrLPSZToBSTR(szPut, &bstrPut);
    }
    else
        hr = HrLPSZToBSTR(szWord, &bstrPut);

    if (FAILED(hr))
        goto error;

    if (!fSquiggle)
        hr = m_pRangeChecking->put_text(bstrPut);
    else
        hr = m_pRangeChecking->pasteHTML(bstrPut);

    if(FAILED(hr))
        goto error;

error:
    if (SUCCEEDED(hr))
        hr = HrUpdateSelection();

    SysFreeString(bstrGet);
    SysFreeString(bstrPut);
    return hr;
}


HRESULT CSpell::GetSelection(IHTMLTxtRange **ppRange)
{
    IHTMLSelectionObject*   pSel = NULL;
    IHTMLTxtRange           *pTxtRange=0;
    IDispatch               *pID=0;
    HRESULT                 hr=E_FAIL;

    if (ppRange == NULL)
        return TraceResult(E_INVALIDARG);

    *ppRange = NULL;

    if(m_pDoc)
        {
        m_pDoc->get_selection(&pSel);
        if (pSel)
            {
            pSel->createRange(&pID);
            if (pID)
                {
                hr = pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)ppRange);
                pID->Release();
                }
            pSel->Release();
            }
        }
    return hr;
}


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrRegisterKeyPressNotify(BOOL fRegister)
{
    IConnectionPointContainer * pCPContainer=0;
    IConnectionPoint *          pCP=0;
    HRESULT                     hr;

    Assert(m_pDoc)

    hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(DIID_HTMLDocumentEvents, &pCP);
    pCPContainer->Release();
    if (FAILED(hr))
        goto error;

    if (fRegister)
        {
        Assert(0==m_dwCookieNotify);
        hr = pCP->Advise(this, &m_dwCookieNotify);
        if (FAILED(hr))
            goto error;
        }
    else
        {
        if (m_dwCookieNotify)
            {
            hr = pCP->Unadvise(m_dwCookieNotify);
            if (FAILED(hr))
                goto error;
            }
        }
error:
    ReleaseObj(pCP);
    return hr;
}
#endif // BACKGROUNDSPELL


HRESULT CSpell::OnWMCommand(int id, IHTMLTxtRange *pTxtRange)
{
    switch (id)
    {
    case idmSuggest0:
    case idmSuggest1:
    case idmSuggest2:
    case idmSuggest3:
    case idmSuggest4:
        HrReplaceBySuggest(pTxtRange, id-idmSuggest0);
        break;
    case idmIgnore:
    case idmIgnoreAll:
    case idmAdd:
#ifdef BACKGROUNDSPELL
        HrDeleteSquiggle(pTxtRange);
#endif // BACKGROUNDSPELL
        break;
    default:
        return S_FALSE;
    }

    return S_OK;
}


HRESULT CSpell::HrUpdateSelection()
{
    HRESULT         hr;
    VARIANT_BOOL    fSuccess;

    SafeRelease(m_pRangeSel);
    m_pRangeSelEndDocEnd->duplicate(&m_pRangeSel);
    if (!m_pRangeSel)
    {
        hr = E_FAIL;
        goto error;
    }
    hr = m_pRangeSel->setEndPoint((BSTR)c_bstr_EndToStart, m_pRangeSelEndDocEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pRangeSel->setEndPoint((BSTR)c_bstr_StartToEnd, m_pRangeDocStartSelStart);
    if (FAILED(hr))
        goto error;

    SafeRelease(m_pRangeSelExpand);
    m_pRangeSel->duplicate(&m_pRangeSelExpand);
    if(!m_pRangeSelExpand)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelExpand->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}


BOOL CSpell::FIgnoreNumber()
{
    return (m_dwOpt & MESPELLOPT_IGNORENUMBER);
}

BOOL CSpell::FIgnoreUpper()
{
    return (m_dwOpt & MESPELLOPT_IGNOREUPPER);
}

BOOL CSpell::FIgnoreDBCS()
{
    return (m_dwOpt & MESPELLOPT_IGNOREDBCS);
}

BOOL CSpell::FIgnoreProtect()
{
    return (m_dwOpt & MESPELLOPT_IGNOREPROTECT);
}

BOOL CSpell::FAlwaysSuggest()
{
    return (m_dwOpt & MESPELLOPT_ALWAYSSUGGEST);
}

BOOL CSpell::FCheckOnSend()
{
    return (m_dwOpt & MESPELLOPT_CHECKONSEND);
}

BOOL CSpell::FIgnoreURL()
{
    return (m_dwOpt & MESPELLOPT_IGNOREURL);
}


UINT CSpell::GetCodePage()
{
    UINT        uCodePage;
    TCHAR       szBuf[cchEditBufferMax]={0};

    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szBuf, sizeof(szBuf)))
        uCodePage = StrToInt(szBuf);
    else
        uCodePage = CP_ACP;

    return uCodePage;
}


void DumpRange(IHTMLTxtRange *pRange)
{
#ifdef DEBUG
    BSTR        bstrGet=0;

    if (!pRange)
        return;
    pRange->get_text(&bstrGet);
    SysFreeString(bstrGet);
#endif
}



BOOL FBadSpellChecker(LPSTR rgchBufDigit)
{
    TCHAR       rgchBufKey[cchMaxPathName];
    TCHAR       rgchBuf[cchMaxPathName];
    TCHAR       szMdr[cchMaxPathName];
    LPSTR       pszSpell;

    wnsprintf(rgchBufKey, ARRAYSIZE(rgchBufKey), c_szRegSpellKeyDef, rgchBufDigit);

    if (!GetSpellingPaths(rgchBufKey, rgchBuf, szMdr, sizeof(rgchBuf)/sizeof(TCHAR)))
        return TRUE;

    pszSpell = PathFindFileNameA(rgchBuf);
    if (!pszSpell)
        return TRUE;

    if (lstrcmpi(pszSpell, "msspell.dll")==0 ||
        lstrcmpi(pszSpell, "mssp32.dll")==0)
        return TRUE;

    // scotts@directeq.com - check that the dict exists (also check the spell dll
    // for good measure) - 42208

    // spell dll must exist
    if (!PathFileExists(rgchBuf))
        return TRUE;

    // main dict must exist
    if (!PathFileExists(szMdr))
        return TRUE;

    return FALSE;
}


#ifdef BACKGROUNDSPELL
CSpellStack::CSpellStack()
{
    m_cRef = 1;
    m_sp = -1;
    ZeroMemory(&m_rgStack, sizeof(CCell)*MAX_SPELLSTACK);
}


CSpellStack::~CSpellStack()
{
    while (m_sp>=0)
    {
        SafeRelease(m_rgStack[m_sp].pTextRange);
        m_sp--;
    }
}


ULONG CSpellStack::AddRef()
{
    return ++m_cRef;
}


ULONG CSpellStack::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CSpellStack::HrGetRange(IHTMLTxtRange   **ppTxtRange)
{
    HRESULT hr;

    Assert(ppTxtRange);
    *ppTxtRange = 0;
    if (m_sp < 0)
        return E_FAIL;

    *ppTxtRange = m_rgStack[m_sp].pTextRange;
    if (*ppTxtRange)
        (*ppTxtRange)->AddRef();

    return NOERROR;
}


HRESULT CSpellStack::push(IHTMLTxtRange *pTxtRange)
{
    HRESULT hr;
    BSTR    bstr=0;

    Assert(m_sp >= -1 && m_sp <= (MAX_SPELLSTACK-2));

    if (pTxtRange == NULL)
        return E_INVALIDARG;

    hr = pTxtRange->get_text(&bstr);
    if (FAILED(hr) || bstr==NULL || *bstr==L'\0' || *bstr==L' ')
    {
        Assert(0);
        goto error;
    }

    m_sp++;
    m_rgStack[m_sp].pTextRange = pTxtRange;
    pTxtRange->AddRef();

error:
    SafeSysFreeString(bstr);
    return NOERROR;
}


HRESULT CSpellStack::pop()
{
    if (m_sp < 0)
        return NOERROR;

    Assert(m_sp>=0 && m_sp<=(MAX_SPELLSTACK-1));

    SafeRelease(m_rgStack[m_sp].pTextRange);
    m_sp--;

    return NOERROR;
}


BOOL CSpellStack::fEmpty()
{
    Assert(m_sp>=-1 && m_sp<=(MAX_SPELLSTACK-1));

    if (m_sp < 0)
        return TRUE;
    else
        return FALSE;
}
#endif // BACKGROUNDSPELL



WORD GetWCharType(WCHAR wc)
{
    BOOL    fResult;
    WORD    wResult;

    fResult = GetStringTypeExWrapW(CP_ACP, CT_CTYPE1, &wc, 1, &wResult);
    if (FALSE == fResult)
        return 0;
    else
        return wResult;
}

/*******************************************************************

  NAME:       OpenDirectory
  
    SYNOPSIS:   checks for existence of directory, if it doesn't exist
    it is created
    
********************************************************************/
HRESULT OpenDirectory(TCHAR *szDir)
{
    TCHAR *sz, ch;
    HRESULT hr;
    
    Assert(szDir != NULL);
    hr = S_OK;
    
    if (!CreateDirectory(szDir, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
    {
        Assert(szDir[1] == TEXT(':'));
        Assert(szDir[2] == TEXT('\\'));
        
        sz = &szDir[3];
        
        while (TRUE)
        {
            while (*sz != 0)
            {
                if (!IsDBCSLeadByte(*sz))
                {
                    if (*sz == TEXT('\\'))
                        break;
                }
                sz = CharNext(sz);
            }
            ch = *sz;
            *sz = 0;
            if (!CreateDirectory(szDir, NULL))
            {
                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    hr = E_FAIL;
                    *sz = ch;
                    break;
                }
            }
            *sz = ch;
            if (*sz == 0)
                break;
            sz++;
        }
    }
    
    return(hr);
}

HRESULT CSpell::_EnsureInited()
{
    HRESULT     hr=S_OK;

    if (m_pMarkup == NULL)
    {
        hr = m_pDoc->QueryInterface(IID_IMarkupServices, (LPVOID *)&m_pMarkup);
        if (FAILED(hr))
            goto error;
    }
    
    if (m_pBodyElem == NULL)
    {
        hr = HrGetBodyElement(m_pDoc, &m_pBodyElem);
        if (FAILED(hr))
            goto error;
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\spell.h ===
/*
 *  spell.h
 *
 *  Declarations for spelling
 *
 *  Owner:
 *  		v-brakol
 *			bradk@directeq.com
 */

/*
 *  Capone Specific Definitions for the spelling subsystem
 */
#ifndef _SPELL_H
#define _SPELL_H

#include "proofbse.h"
#include "spellapi.h"

#define cchMaxPathName      MAX_PATH
#define cchMaxSuggestBuff   (2048)
#ifdef BACKGROUNDSPELL
#define MAX_SPELLSTACK      (1024)
#endif // BACKGROUNDSPELL
#define sobitStdOptions     (sobitFindRepeatWord)
#define cchMaxDicts			64

class CBody;

// Size of current edit block.  Leave this a small value for the DEBUG
// version to help track down bugs with inter-buffer processing.
#ifdef DEBUG
#define cchEditBufferMax    512
#else
#define cchEditBufferMax    512
#endif

#define chCRSpell           0x0D
#define chLFSpell           0x0A
#define chHyphen            0x2D


// Scode sources
#define FACILITY_MAIL           (0x0100)
#define FACILITY_MAPI           (0x0200)
#define FACILITY_WIN            (0x0300)
#define FACILITY_MASK           (0x0700)

#define MAKE_MAIL_S_SCODE(_str) \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_MAIL, (_str))
#define MAKE_MAIL_E_SCODE(_str) \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str))
#define MAKE_MAIL_X_SCODE(_str) \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str) | CRITICAL_FLAG)

#define MAIL_E_SPELLGENERICSPELL    MAKE_MAIL_E_SCODE(idsErrSpellGenericSpell)
#define MAIL_E_SPELLGENERICLOAD     MAKE_MAIL_E_SCODE(idsErrSpellGenericLoad)
#define MAIL_E_SPELLMAINDICTLOAD    MAKE_MAIL_E_SCODE(idsErrSpellMainDictLoad)
#define MAIL_E_SPELLVERSION         MAKE_MAIL_E_SCODE(idsErrSpellVersion)
#define MAIL_E_SPELLUSERDICT        MAKE_MAIL_E_SCODE(idsErrSpellUserDict)
#define MAIL_E_SPELLUSERDICTLOAD    MAKE_MAIL_E_SCODE(idsErrSpellUserDictLoad)
#define MAIL_E_SPELLUSERDICTOPENRO  MAKE_MAIL_E_SCODE(idsErrSpellUserDictOpenRO)
#define MAIL_E_SPELLUSERDICTSAVE    MAKE_MAIL_E_SCODE(idsErrSpellUserDictSave)
#define MAIL_E_SPELLUSERDICTWORDLEN MAKE_MAIL_E_SCODE(idsErrSpellUserDictWordLen)
#define MAIL_E_SPELLCACHEWORDLEN    MAKE_MAIL_E_SCODE(idsErrSpellCacheWordLen)
#define MAIL_E_SPELLEDIT            MAKE_MAIL_E_SCODE(idsErrSpellEdit)

// the order is important
enum
{
    SEL,
    SELENDDOCEND,
    DOCSTARTSELSTART,
    STATEMAX
};

/*
 *  CSApi Function typedefs.  Note these are *not* Unicode enabled.  Thus need to use
 *  LPSTR and not LPTSTR.
 */

#ifdef BACKGROUNDSPELL
struct CCell
{
    IHTMLTxtRange   *pTextRange;
    ULONG           cb;
};

class CSpellStack
{
public:
    CSpellStack();
    ~CSpellStack();
    ULONG   AddRef();
    ULONG   Release();

    HRESULT HrGetRange(IHTMLTxtRange   **ppTxtRange);
    BOOL    fEmpty();
    HRESULT push(IHTMLTxtRange   *pTxtRange);
    HRESULT pop();

private:
    ULONG   m_cRef;
    int     m_sp; // stack pointer.
    CCell   m_rgStack[MAX_SPELLSTACK];
};
#endif // BACKGROUNDSPELL

class CSpell :
#ifdef BACKGROUNDSPELL
    public IDispatch
#else
	public IUnknown
#endif // BACKGROUNDSPELL
{
public:
    CSpell(IHTMLDocument2* pDoc, IOleCommandTarget* pParentCmdTarget, DWORD dwSpellOpt);
    ~CSpell();

    // IUnknown methods
    ULONG   STDMETHODCALLTYPE AddRef();
    ULONG   STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    // IDispatch methods
#ifdef BACKGROUNDSPELL
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
#endif // BACKGROUNDSPELL
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

	HRESULT HrSpellReset();
    HRESULT HrSpellChecking(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg);


    HRESULT OnWMCommand(int id, IHTMLTxtRange *pTxtRange);
#ifdef BACKGROUNDSPELL
    HRESULT HrHasSquiggle(IHTMLTxtRange *pTxtRange);
#endif // BACKGROUNDSPELL
    HRESULT HrInitRanges(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg);
    VOID    DeInitRanges();

    BOOL    OpenSpeller();
    VOID    CloseSpeller();

	BOOL	OpenUserDictionaries();
    BOOL	OpenUserDictionary(LPTSTR lpszDict);

    HRESULT HrFindErrors();
    HRESULT HrReplaceErrorText(BOOL fChangeAll, BOOL fAddToUdr);
    HRESULT HrSpellSuggest();
    VOID    FillSuggestLbx();
    BOOL    FVerifyThisText(LPSTR szThisText, BOOL fProcessOnly);
    VOID    SpellSaveUndo(INT idButton);
    VOID    SpellDoUndo();
#ifdef BACKGROUNDSPELL
    HRESULT HrBkgrndSpellTimer();
    HRESULT HrBkgrndSpellCheck(IHTMLTxtRange *pTxtRange);
    HRESULT HrSetSquiggle(IHTMLTxtRange *pTxtRange);
    HRESULT HrDeleteSquiggle(IHTMLTxtRange *pTxtRange);
#endif // BACKGROUNDSPELL
    HRESULT HrInsertMenu(HMENU hmenu, IHTMLTxtRange *pTxtRange);
    HRESULT HrReplaceBySuggest(IHTMLTxtRange *pTxtRange, INT index);
#ifdef BACKGROUNDSPELL
    HRESULT HrRegisterKeyPressNotify(BOOL fRegister);
#endif // BACKGROUNDSPELL
    HRESULT AddToUdrW(WCHAR* pwsz, PROOFLEX lex);	// scotts@directeq.com - can now specify dict index - 53193
    HRESULT AddToUdrA(CHAR* psz, PROOFLEX lex);		// scotts@directeq.com - can now specify dict index - 53193
    HRESULT HrCheckWord(LPCSTR pszWord);

    BOOL        m_fSpellSelection: 1,
                m_fUdrReadOnly:    1,
                m_fSuggestions:    1,
                m_fNoneSuggested:  1,
                m_fAlwaysSuggest:  1,
                m_fEditWasEmpty:   1,
                m_fRepeat:         1,
                m_fCanUndo:        1,
                m_fUndoChange:     1,
                m_fShowDoneMsg:    1,
                m_fIgnoreScope:    1,
                m_fSpellContinue:  1,	// scotts@directeq.com - "repeat word" bug fix - 2757, 13573, 56057
                m_junk:            3,
                m_fCSAPI3T1:       1;
                
    HWND        m_hwndDlg;                // the spelling dialog using thie SPELLFO structure
    
    TCHAR       m_szWrongWord[cchEditBufferMax];            // current misspelled word
    TCHAR       m_szEdited[cchEditBufferMax];               // current replacement word

	WCHAR		m_wszIn[cchEditBufferMax];
    WCHAR       m_wszRet[cchEditBufferMax];

    PROOFID             m_pid;
    WSIB                m_wsib;
    WSRB                m_wsrb;

	LANGID				m_langid;

    DWORD				m_clex;
    PROOFLEX            m_rgprflex[cchMaxDicts];

    PROOFVERSION        m_pfnSpellerVersion;
    PROOFINIT           m_pfnSpellerInit;
    PROOFTERMINATE      m_pfnSpellerTerminate;
    PROOFSETOPTIONS     m_pfnSpellerSetOptions;
    PROOFOPENLEX        m_pfnSpellerOpenLex;
    PROOFCLOSELEX       m_pfnSpellerCloseLex;
    SPELLERCHECK        m_pfnSpellerCheck;
    SPELLERADDUDR       m_pfnSpellerAddUdr;
    SPELLERBUILTINUDR   m_pfnSpellerBuiltInUdr;
    SPELLERADDCHANGEUDR m_pfnSpellerAddChangeUdr;
    PROOFSETDLLNAME     m_pfnSpellerSetDllName;

    CHARRANGE           m_chrgCurrent;            // current selection in edit control
    TCHAR               m_szErrType[256];         // string describing type of spelling error
    TCHAR               m_szTempBuffer[256];      // temporary buffer used for LoadString()
    TCHAR               m_szSuggest[cchMaxSuggestBuff];
    IHTMLTxtRange*      m_pRangeChecking;// text range currently checked
    IHTMLTxtRange*      m_pRangeIgnore;// ignore text

private:
    ULONG               m_cRef;
    INT                 m_State;
    IHTMLTxtRange*      m_pRangeDocStartSelStart;//from document start to selection start.
    IHTMLTxtRange*      m_pRangeSel; //from selection start to selection end
    IHTMLTxtRange*      m_pRangeSelExpand; //from selection start to selection end
    IHTMLTxtRange*      m_pRangeSelEndDocEnd;// from selection end to document end
    IHTMLTxtRange*      m_pRangeUndoSave;// from selection end to document end
#ifdef BACKGROUNDSPELL
    CSpellStack         m_Stack;
#endif // BACKGROUNDSPELL
    IHTMLDocument2*     m_pDoc;
    IOleCommandTarget*	m_pParentCmdTarget;

    HINSTANCE   		m_hinstDll;               // spell dll
    HWND       			m_hwndNote;               // body edit field
    LONG        		m_soCur;                  // current spelling options.
    HRESULT     		m_hr;
    DWORD       		m_dwOpt;
    DWORD       		m_dwCookieNotify;

	IMarkupServices*	m_pMarkup;
	IHTMLBodyElement*	m_pBodyElem;

    HRESULT HrGetSel();
    HRESULT HrReplaceSel(LPTSTR szWord);
    HRESULT HrProcessSpellErrors();
    VOID    CleanupState();
    HRESULT HrCheckRange(IHTMLTxtRange* pRange);
    BOOL    FIgnore(IHTMLTxtRange* pRangeChecking);
    BOOL    FIgnoreNumber();
    BOOL    FIgnoreUpper();
    BOOL    FIgnoreDBCS();
    BOOL    FIgnoreProtect();
    BOOL    FAlwaysSuggest();
    BOOL    FCheckOnSend();
    BOOL    FIgnoreURL();
    HRESULT HrGetNextWordRange(IHTMLTxtRange* pRange);
    HRESULT HrGetText(IHTMLTxtRange* pRange, LPSTR *ppszText);
    HRESULT	HrGetText(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, LPSTR *ppszText);
    HRESULT	HrStripTrailingPeriod(IHTMLTxtRange* pRange, BOOL* pfResult);
    HRESULT HrHasWhitespace(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, BOOL *pfResult);
    HRESULT HrUpdateSelection();
    HRESULT GetSelection(IHTMLTxtRange **ppRange);
    HRESULT HrGetSpaces(LPSTR pszText, INT* pnSpaces);
    BOOL    LoadOldSpeller();
    BOOL    LoadNewSpeller();
    BOOL    GetNewSpellerEngine(LANGID, TCHAR*, DWORD, TCHAR*, DWORD);
    UINT    GetCodePage();
    HRESULT _EnsureInited();
};


INT_PTR CALLBACK SpellingDlgProc(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam);
BOOL    SpellingOnCommand(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam);
VOID    UpdateEditedFromSuggest(HWND, HWND, HWND);

BOOL  FCheckSpellAvail(IOleCommandTarget* pParentCmdTarget);

#endif  // _SPELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\triutil.cpp ===
/*
 *    t r i u t i l . c p p
 *    
 *    Purpose:
 *        Trident utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "urlmon.h"
#include "wininet.h"
#include "winineti.h"
#include "mshtml.h"
#include "mshtmcid.h"
#include "mshtmhst.h"
#include "oleutil.h"
#include "triutil.h"
#include "htmlstr.h"
#include "demand.h"
#include "mhtml.h"
#include "mshtmdid.h"
#include "tags.h"

ASSERTDATA

class CDummySite :
        public IOleClientSite,
        public IDispatch
{
    private:
        LONG    m_cRef;
        
    public:
        // *** ctor/dtor methods ***
        CDummySite() : m_cRef(1) {}
        ~CDummySite() {}
        
        // *** IUnknown methods ***
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
        virtual ULONG STDMETHODCALLTYPE AddRef();
        virtual ULONG STDMETHODCALLTYPE Release();

        // IOleClientSite methods.
        virtual HRESULT STDMETHODCALLTYPE SaveObject() { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE ShowObject() { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout() { return E_NOTIMPL; }

        // *** IDispatch ***
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);
};

/*
 *  t y p e d e f s
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */

HRESULT ClearStyleSheetBackground(IHTMLDocument2 *pDoc);

STDMETHODIMP_(ULONG) CDummySite::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDummySite::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CDummySite::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOleClientSite))
    {
        *ppvObject = static_cast<IOleClientSite *>(this);
    }
    else if (riid == IID_IDispatch)
    {
        *ppvObject = static_cast<IDispatch *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CDummySite::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            /*wFlags*/,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       pVarResult,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    HRESULT             hr = S_OK;

    if (dispIdMember != DISPID_AMBIENT_DLCONTROL)
    {
        hr = E_NOTIMPL;
        goto exit;
    }

    if (NULL == pVarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    pVarResult->vt = VT_I4;
    pVarResult->lVal = DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD | DLCTL_FORCEOFFLINE;
    
exit:
    return hr;
}

HRESULT HrCreateSyncTridentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv)
{
    HRESULT             hr;
    IOleCommandTarget   *pCmdTarget = NULL;
    CDummySite          *pDummy = NULL;
    IOleClientSite      *pISite = NULL;
    IOleObject          *pIObj = NULL;

    // BUGBUG: this cocreate should also go thro' the same code path as the DocHost one
    // so that if this is the first trident in the process, we keep it's CF around

    hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                            IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
    if (FAILED(hr))
        goto exit;

    // Create a dummy site
    pDummy = new CDummySite;
    if (NULL == pDummy)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the client site interface
    hr = pDummy->QueryInterface(IID_IOleClientSite, (VOID **) &pISite);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the OLE object interface from trident
    hr = pCmdTarget->QueryInterface(IID_IOleObject, (VOID **) &pIObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the client site
    hr = pIObj->SetClientSite(pISite);
    if (FAILED(hr))
    {
        goto exit;
    }

    // force trident to load sync
    pCmdTarget->Exec(&CMDSETID_Forms3, IDM_PERSISTSTREAMSYNC, NULL, NULL, NULL);

    hr = HrIPersistStreamInitLoad(pCmdTarget, pstm);
    if (FAILED(hr))
        goto exit;

    // success let's return the desired interface
    hr = pCmdTarget->QueryInterface(riid, ppv);

exit:
    ReleaseObj(pIObj);
    ReleaseObj(pISite);
    ReleaseObj(pDummy);
    ReleaseObj(pCmdTarget);
    return hr;
}


HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr)
{
    IHTMLElement    *pObj;
    HRESULT         hr=E_FAIL;
    VARIANT         rVar;

    if (pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj)==S_OK)
        {
        Assert (pObj);

        rVar.vt = VT_BSTR;
        if (!FAILED(pObj->getAttribute(bstrMember, lFlags, &rVar))
            && rVar.vt == VT_BSTR 
            && rVar.bstrVal != NULL)
            {
            hr = S_OK;
            *pbstr = rVar.bstrVal;
            }
        pObj->Release(); 
        }
    return hr;
}



ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect)
{
    ULONG   ulCount=0;

    if (pCollect)
        pCollect->get_length((LONG *)&ulCount);

    return ulCount;
}



HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj)
{
    HRESULT     hr=E_FAIL;
    IDispatch   *pDisp=0;
    VARIANTARG  va1,
                va2;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
    va1.lVal = (LONG)uIndex;
    
    pCollect->item(va1, va2, &pDisp);
    if (pDisp)
        {
        hr = pDisp->QueryInterface(riid, ppvObj);
        pDisp->Release();
        }
    return hr;
}

HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect)
{
    VARIANT                 v;
    IDispatch               *pDisp=0;
    IHTMLElementCollection  *pCollect=0;
    HRESULT                 hr;
        
    Assert(ppCollect);
    Assert(bstrTagName);
    Assert(pDoc);

    *ppCollect = NULL;

    hr = pDoc->get_all(&pCollect);
    if (pCollect)
        {
        v.vt = VT_BSTR;
        v.bstrVal = bstrTagName;
        pCollect->tags(v, &pDisp);
        if (pDisp)
            {
            hr = pDisp->QueryInterface(IID_IHTMLElementCollection, (LPVOID *)ppCollect);
            pDisp->Release();
            }
        pCollect->Release();
        }
    else if (S_OK == hr)
        hr = E_FAIL;

    return hr;
}

HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue)
{
    IHTMLElement    *pObj;
    HRESULT         hr;
    VARIANT         rVar;

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj);
    if (!FAILED(hr))
        {
        Assert (pObj);
        rVar.vt = VT_BSTR;
        rVar.bstrVal = bstrValue;
        // if bstrVal is NULL then kill the member
        if (bstrValue)
            hr = pObj->setAttribute(bstrMember, rVar, FALSE);
        else
            hr = pObj->removeAttribute(bstrMember, 0, NULL);
        pObj->Release();
        }
    return hr;
}



HRESULT GetBodyStream(IUnknown *pUnkTrident, BOOL fHtml, LPSTREAM *ppstm)
{
    LPPERSISTSTREAMINIT pStreamInit;
    LPSTREAM            pstm;
    HRESULT             hr;

    Assert(ppstm);
    Assert(pUnkTrident);

    *ppstm=NULL;

    if (fHtml)
        {
        // get the HTML from Trident
        hr = pUnkTrident->QueryInterface(IID_IPersistStreamInit, (LPVOID*)&pStreamInit);
        if (!FAILED(hr))
            {
            hr = MimeOleCreateVirtualStream(&pstm);
            if (!FAILED(hr))
                {
                hr=pStreamInit->Save(pstm, FALSE);
                if (!FAILED(hr))
                    {
                    *ppstm=pstm;
                    pstm->AddRef();
                    }
                pstm->Release();
                }
            pStreamInit->Release();
            }
        }
    else
        {
        hr = HrGetDataStream(pUnkTrident, 
#ifndef WIN16
                        CF_UNICODETEXT, 
#else
                        CF_TEXT,
#endif
                        ppstm);

        }
    return hr;
}



HRESULT HrBindToUrl(LPCSTR pszUrl, LPSTREAM *ppstm)
{
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO  *pCacheInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
    DWORD                       cInfo = sizeof(buf);
    HRESULT                     hr;

    pCacheInfo->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

    // try to get from the cache
    if (RetrieveUrlCacheEntryFileA(pszUrl, pCacheInfo, &cInfo, 0))
        {
        UnlockUrlCacheEntryFile(pszUrl, 0);
        if (OpenFileStream(pCacheInfo->lpszLocalFileName, OPEN_EXISTING, GENERIC_READ, ppstm)==S_OK)
            return S_OK;
        }

    if (URLOpenBlockingStreamA(NULL, pszUrl, ppstm, 0, NULL)!=S_OK)
        return MIME_E_URL_NOTFOUND;

    return S_OK;
}


HRESULT HrGetStyleTag(IHTMLDocument2 *pDoc, BSTR *pbstr)
{
    IHTMLStyleSheet             *pStyle;
    VARIANTARG                  va1, va2;

    if (pDoc == NULL || pbstr == NULL)
        return E_INVALIDARG;

    *pbstr=NULL;

    if (HrGetStyleSheet(pDoc, &pStyle)==S_OK)
        {
        pStyle->get_cssText(pbstr);
        pStyle->Release();
        }

    return *pbstr ?  S_OK : E_FAIL;
}




HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, DWORD dwFlags, LPSTREAM *ppstm)
{
    HBODY   hBody=HBODY_ROOT;
    HRESULT hr = E_FAIL;
    LPSTR   lpszFree=0;
        
    if (pMsg && lpszUrl)
    {
         // if it's an MHTML: url then we have to fixup to get the cid:
         if (StrCmpNIA(lpszUrl, "mhtml:", 6)==0 &&
             !FAILED(MimeOleParseMhtmlUrl(lpszUrl, NULL, &lpszFree)))
             lpszUrl = lpszFree;

        if (!(dwFlags & FINDURL_SEARCH_RELATED_ONLY) || MimeOleGetRelatedSection(pMsg, FALSE, &hBody, NULL)==S_OK)
        {
            if (!FAILED(hr = pMsg->ResolveURL(hBody, NULL, lpszUrl, 0, &hBody)) && ppstm)
                hr = pMsg->BindToObject(hBody, IID_IStream, (LPVOID *)ppstm);
        }
    }

    SafeMemFree(lpszFree);
    return hr;
}


HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt)
{
    BYTE    pb[4096];
    LPWSTR  lpszW;
    TCHAR   rgch[MAX_PATH];

    if (!FAILED(pstm->Read(&pb, 4096, NULL)))
        {
        if (!FAILED(FindMimeFromData(NULL, NULL, pb, 4096, NULL, NULL, &lpszW, 0)))
            {
            WideCharToMultiByte(CP_ACP, 0, lpszW, -1, rgch, MAX_PATH, NULL, NULL);
            return MimeOleGetContentTypeExt(rgch, lplpszExt);
            }
        }
    return S_FALSE;
}






HRESULT UnWrapStyleSheetUrl(BSTR bstrStyleUrl, BSTR *pbstrUrl)
{
    LPWSTR      lpszLeftParaW=0, 
                lpszRightParaW=0;
    LPWSTR      pszUrlW;

    // remove 'url()' wrapping from url
    *pbstrUrl = NULL;
    
    if (!bstrStyleUrl)
        return E_FAIL;

    if (StrCmpIW(bstrStyleUrl, L"none")==0)     // 'none' means there isn't one!!!
        return E_FAIL;

    pszUrlW = PszDupW(bstrStyleUrl);
    if (!pszUrlW)
        return TraceResult(E_OUTOFMEMORY);

    if (*pszUrlW != 0)
    {
        DWORD cchSize = (lstrlenW(pszUrlW) + 1);
        lpszLeftParaW = StrChrW(pszUrlW, '(');
        if (lpszLeftParaW)
        {
            lpszRightParaW = StrChrW(lpszLeftParaW, ')');
            if(lpszRightParaW)
            {
                *lpszRightParaW = 0;
                // strcpy same block is ok, as it's a shift down.
                StrCpyNW(pszUrlW, ++lpszLeftParaW, cchSize);
            }
        }
    }
    *pbstrUrl = SysAllocString(pszUrlW);
    MemFree(pszUrlW);
    return *pbstrUrl ? S_OK : E_OUTOFMEMORY;
}

HRESULT WrapStyleSheetUrl(BSTR bstrUrl, BSTR *pbstrStyleUrl)
{
    // simply put 'url()' around the url

    DWORD cchSize = (SysStringLen(bstrUrl) + 6);
    *pbstrStyleUrl = SysAllocStringLen(NULL, cchSize);
    if (*pbstrStyleUrl == NULL)
        return E_OUTOFMEMORY;

    StrCpyNW(*pbstrStyleUrl, L"url(", cchSize);
    StrCatBuffW(*pbstrStyleUrl, bstrUrl, cchSize);
    StrCatBuffW(*pbstrStyleUrl, L")", cchSize);
    StrCpyW(*pbstrStyleUrl, L"url(");
    StrCatW(*pbstrStyleUrl, bstrUrl);
    StrCatW(*pbstrStyleUrl, L")");
    return S_OK;
}




/*
 * GetBackgroundImage
 *
 * Trident does not have a very clean OM for getting a background image. You get get the BACKGROUND property on  
 * the <body> tag and/or the background-url propetry in the body's sytle sheet, but neither of these OM methods will
 * combine with any <BASE> url's. So, if the Url is not absolute we have to hunt around for the <BASE> ourselves

    // ugh. This is really disgusting. Trident has no object model for getting a fixed up URL to the background image.
    // it doesn't comine with the base, so the URL is relative and useless to us. We have to do all this work manually.
    // We get a collection of <BASE> tags and find the sourceIndex of the <BODY> tag. We look for the <BASE> tag with the 
    // highest sourceIndex below the body's sourceIndex and comine this guy.
 */

HRESULT GetBackgroundImage(IHTMLDocument2 *pDoc, BSTR *pbstrUrl)
{
    HRESULT                 hr;
    IMimeEditTagCollection  *pCollect;
    IMimeEditTag            *pTag;
    ULONG                   cFetched;
    BSTR                    bstrSrc;

    if (pDoc == NULL || pbstrUrl == NULL)
        return E_INVALIDARG;

    *pbstrUrl = NULL;

    // use the background image collection to get the first background in the precedence order
    if (CreateBGImageCollection(pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();
        if (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            pTag->GetSrc(pbstrUrl);
            pTag->Release();
        }
        pCollect->Release();
    }
    return (*pbstrUrl == NULL ? E_FAIL : S_OK);
}



HRESULT SetBackgroundImage(IHTMLDocument2 *pDoc, BSTR bstrUrl)
{
    IMimeEditTagCollection  *pCollect;
    IMimeEditTag            *pTag;
    IHTMLBodyElement        *pBody;
    ULONG                   cFetched;
    BSTR                    bstrSrc;
    HRESULT                 hr = E_FAIL;

    if (pDoc == NULL)
        return E_INVALIDARG;

    // first we use the background image collection to get the 
    // first background in the precedence order if one is present then
    // we use whatever tag this is. If not then we use the body background as that
    // is our prefered client-interop method
    if (CreateBGImageCollection(pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();
        if (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            hr = pTag->SetSrc(bstrUrl);
            pTag->Release();
        }
        pCollect->Release();
    }
    
    if (hr == S_OK) // if we found one already
        return S_OK;


    hr = HrGetBodyElement(pDoc, &pBody);
    if (!FAILED(hr))
    {
        hr = pBody->put_background(bstrUrl);
        pBody->Release();
    }
    return hr;
}





HRESULT HrCopyStyleSheets(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest)
{
    IHTMLStyleSheet                 *pStyleSrc=0,
                                    *pStyleDest=0;
    LONG                            lRule=0,
                                    lRules=0;
                
    IHTMLStyleSheetRulesCollection  *pCollectRules=0;
    IHTMLStyleSheetRule             *pRule=0;
    IHTMLRuleStyle                  *pRuleStyle=0;
    BSTR                            bstrSelector=0,
                                    bstrRule=0;

    if (pDocSrc == NULL || pDocDest == NULL)
        return E_INVALIDARG;

    if (HrGetStyleSheet(pDocDest, &pStyleDest)==S_OK)
        {
        // remove all the rules on the destination style sheet
        while (!FAILED(pStyleDest->removeRule(0)));

        if (HrGetStyleSheet(pDocSrc, &pStyleSrc)==S_OK)
            {
            // walk rules collection on source adding to dest
            if (pStyleSrc->get_rules(&pCollectRules)==S_OK)
                 {
                lRules=0;
                pCollectRules->get_length(&lRules);

                for (lRule = 0; lRule < lRules; lRule++)
                    {
                    if (pCollectRules->item(lRule, &pRule)==S_OK)
                        {
                        if (pRule->get_selectorText(&bstrSelector)==S_OK)
                            {
                            if (pRule->get_style(&pRuleStyle)==S_OK)
                                {
                                if (pRuleStyle->get_cssText(&bstrRule)==S_OK)
                                    {
                                    LONG   l;
                                
                                    l=0;
                                    pStyleDest->addRule(bstrSelector, bstrRule, -1, &l);
                                    SysFreeString(bstrRule);
                                    }
                                pRuleStyle->Release();
                                }

                            SysFreeString(bstrSelector);
                            }
                        pRule->Release();
                        }
                    }
                pCollectRules->Release();
                }
            pStyleSrc->Release();
            }
        pStyleDest->Release();
        }   

    return S_OK;
}


HRESULT HrCopyBackground(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest)
{
    HRESULT                     hr;
    IHTMLBodyElement            *pBodySrc=0;
    IHTMLBodyElement            *pBodyDest=0;
    BSTR                        bstrUrl=0;
    VARIANT                     var;
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = HrGetBodyElement(pDocSrc, &pBodySrc);
    if(FAILED(hr))
        goto error;

    hr = HrGetBodyElement(pDocDest, &pBodyDest);
    if(FAILED(hr))
        goto error;

    GetBackgroundImage(pDocSrc, &bstrUrl);

    hr = pBodyDest->put_background(bstrUrl);
    if(FAILED(hr))
        goto error;

    hr=pBodySrc->get_bgColor(&var);
    if(FAILED(hr))
        goto error;

    hr=pBodyDest->put_bgColor(var);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pBodySrc);
    ReleaseObj(pBodyDest);
    SysFreeString(bstrUrl);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT HrRemoveStyleSheets(IHTMLDocument2 *pDoc)
{
    IHTMLStyleSheet         *pStyle=0;
    IHTMLBodyElement            *pBody=0;
                
    if(pDoc == NULL)
        return E_INVALIDARG;

    if (HrGetBodyElement(pDoc, &pBody)==S_OK)
    {
        HrSetMember(pBody, (BSTR)c_bstr_STYLE, NULL);
        HrSetMember(pBody, (BSTR)c_bstr_LEFTMARGIN, NULL);
        HrSetMember(pBody, (BSTR)c_bstr_TOPMARGIN, NULL);
        pBody->Release();
    }

    if(HrGetStyleSheet(pDoc, &pStyle)==S_OK)
    {
        while (!FAILED(pStyle->removeRule(0)));
        pStyle->Release();
    }   

    return S_OK;
}


HRESULT HrRemoveBackground(IHTMLDocument2 *pDoc)
{
    HRESULT                     hr;
    IHTMLBodyElement            *pBody=0;
    VARIANT                     var;
    
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = HrGetBodyElement(pDoc, &pBody);
    if(FAILED(hr))
        goto error;

    hr = pBody->put_background(NULL);
    if(FAILED(hr))
        goto error;

    hr = pBody->put_bgColor(var);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pBody);
    return hr;
}


HRESULT FindStyleRule(IHTMLDocument2 *pDoc, LPCWSTR pszSelectorW, IHTMLRuleStyle **ppRuleStyle)
{
    IHTMLBodyElement                *pBody;
    IHTMLElement                    *pElem;
    IHTMLStyle                      *pStyleAttrib=0;
    IHTMLStyleSheet                 *pStyleTag=0;
    IHTMLStyleSheetRulesCollection  *pCollectRules=0;
    IHTMLStyleSheetRule             *pRule=0;
    LONG                            lRule=0,
                                    lRules=0;
    BSTR                            bstrSelector=0;
    Assert (pDoc);

    *ppRuleStyle = NULL;

    if (HrGetStyleSheet(pDoc, &pStyleTag)==S_OK)
        {
        pStyleTag->get_rules(&pCollectRules);
        if (pCollectRules)
            {
            pCollectRules->get_length(&lRules);

            for (lRule = 0; lRule < lRules; lRule++)
                {
                pCollectRules->item(lRule, &pRule);
                if (pRule)
                    {
                    pRule->get_selectorText(&bstrSelector);
                    if (bstrSelector)
                        {
                        if (StrCmpIW(bstrSelector, pszSelectorW)==0)
                            pRule->get_style(ppRuleStyle);

                        SysFreeString(bstrSelector);
                        bstrSelector=0;
                        }
                    SafeRelease(pRule);
                    }
                }                
            pCollectRules->Release();
            }
        pStyleTag->Release();
        }

    return *ppRuleStyle ? S_OK : E_FAIL;
}

HRESULT ClearStyleSheetBackground(IHTMLDocument2 *pDoc)
{
    IHTMLBodyElement                *pBody;
    IHTMLElement                    *pElem;
    IHTMLStyle                      *pStyleAttrib=0;
    IHTMLRuleStyle                  *pRuleStyle=0;

    Assert (pDoc);

    if (HrGetBodyElement(pDoc, &pBody)==S_OK)
    {
        if (pBody->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
        {
            // NULL out the style sheet property.
            pElem->get_style(&pStyleAttrib);
            if (pStyleAttrib)
            {
                pStyleAttrib->put_backgroundImage(NULL);
                pStyleAttrib->Release();
            }
            pElem->Release();
        }
        pBody->Release();
    }

    if (FindStyleRule(pDoc, L"BODY", &pRuleStyle)==S_OK)
    {
        pRuleStyle->put_backgroundImage(NULL);
        pRuleStyle->Release();
    }
    return S_OK;

}

HRESULT GetBackgroundSound(IHTMLDocument2 *pDoc, int *pcRepeat, BSTR *pbstrUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLBGsound            *pBGSnd;
    VARIANT                 v;
    HRESULT                 hr = E_FAIL;

    TraceCall ("GetBackgroundSound");

    if (pDoc == NULL || pbstrUrl == NULL || pcRepeat == NULL)
        return TraceResult(E_INVALIDARG);
            
    *pbstrUrl = NULL;
    *pcRepeat=1;

    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect)))
        {
        // get the first BGSOUND in the document
        if (HrGetCollectionItem(pCollect, 0, IID_IHTMLBGsound, (LPVOID *)&pBGSnd)==S_OK)
            {
            pBGSnd->get_src(pbstrUrl);
            if (*pbstrUrl)
                {
                // valid bstr, make sure it's non null
                if (**pbstrUrl)
                    {
                    hr = S_OK;
                    if (pBGSnd->get_loop(&v)==S_OK)
                        {
                        if (v.vt == VT_I4)
                            *pcRepeat = v.lVal;
                        else
                            if (v.vt == VT_BSTR)
                                {
                                // returns a string with "INFINITE"
                                *pcRepeat = -1;
                                SysFreeString(v.bstrVal);
                                }
                            else
                                AssertSz(FALSE, "bad-type from BGSOUND");
                        }
                    }
                else
                    {
                    SysFreeString(*pbstrUrl);
                    *pbstrUrl = NULL;
                    }
                }
            pBGSnd->Release();
            }
        pCollect->Release();
        }

    return hr;
}

HRESULT SetBackgroundSound(IHTMLDocument2 *pDoc, int cRepeat, BSTR bstrUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLElement            *pElem;
    IHTMLElement2           *pElem2;
    IHTMLBodyElement        *pBody;
    IHTMLBGsound            *pBGSnd;
    VARIANT                 v;
    int                     count,
                            i;

    TraceCall ("GetBackgroundSound");

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);
            
    // remove an existing background sounds
    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect)))
    {
        count = (int)UlGetCollectionCount(pCollect);
        for (i=0; i<count; i++)
        {
            if (HrGetCollectionItem(pCollect, i, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                pElem->put_outerHTML(NULL);
                pElem->Release();
            }
        }
        pCollect->Release();
    }

    // if we're setting a new one, then insert after the body tag         
    if (bstrUrl && *bstrUrl)
    {
        pElem = NULL;       // trident' OM (returns S_OK with pElem==NULL)
        pDoc->createElement((BSTR)c_bstr_BGSOUND, &pElem);
        if (pElem)
        {
            if (pElem->QueryInterface(IID_IHTMLBGsound, (LPVOID *)&pBGSnd)==S_OK)
            {
                // set the source attribute
                pBGSnd->put_src(bstrUrl);
                
                // set the loop count
                v.vt = VT_I4;
                v.lVal = cRepeat;
                pBGSnd->put_loop(v);

                // insert the tag into the document
                if (HrGetBodyElement(pDoc, &pBody)==S_OK)
                {
                    if (!FAILED(pBody->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElem2)))
                    {
                        pElem2->insertAdjacentElement((BSTR)c_bstr_AfterBegin, pElem, NULL);
                        pElem2->Release();
                    }
                    pBody->Release();
                }
                
                pBGSnd->Release();
            }
            pElem->Release();
        }
    }
    return S_OK;
}



HRESULT FindNearestBaseUrl(IHTMLDocument2 *pDoc, IHTMLElement *pElemTag, BSTR *pbstrBaseUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLElement            *pElem;
    IHTMLBaseElement        *pBase;
    LONG                    lBasePos=0,
                            lBasePosSoFar=0,
                            lIndex=0;
    BSTR                    bstr=NULL,
                            bstrBase=NULL;
    int                     count;

    TraceCall ("FindNearestBaseUrl");

    if (pDoc == NULL || pbstrBaseUrl == NULL || pElemTag == NULL)
        return TraceResult(E_INVALIDARG);
            
    *pbstrBaseUrl = NULL;

    pElemTag->get_sourceIndex(&lIndex);

    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BASE, &pCollect)))
    {
        count = (int)UlGetCollectionCount(pCollect);
        for (int i=0; i<count; i++)
        {
            if (!FAILED(HrGetCollectionItem(pCollect, i, IID_IHTMLElement, (LPVOID *)&pElem)))
            {
                pElem->get_sourceIndex(&lBasePos);
                if (lBasePos < lIndex &&
                    lBasePos >= lBasePosSoFar)
                {
                    if (!FAILED(pElem->QueryInterface(IID_IHTMLBaseElement, (LPVOID *)&pBase)))
                    {
                        SysFreeString(bstr);
                        if (pBase->get_href(&bstr)==S_OK && bstr)
                        {
                            SysFreeString(bstrBase);
                            bstrBase = bstr;
                            lBasePosSoFar = lBasePos;
                        }
                        pBase->Release();
                    }
                }
                pElem->Release();
            }
        }
        pCollect->Release();
    }
    
    *pbstrBaseUrl = bstrBase;
    return bstrBase ?  S_OK : TraceResult(E_FAIL);
}


#define CCHMAX_SNIFF_BUFFER 4096

HRESULT SniffStreamForMimeType(LPSTREAM pstm, LPWSTR *ppszType)
{
    BYTE    pb[CCHMAX_SNIFF_BUFFER];
    HRESULT hr = E_FAIL;

    *ppszType = NULL;

    if (!FAILED(pstm->Read(&pb, CCHMAX_SNIFF_BUFFER, NULL)))
        hr = FindMimeFromData(NULL, NULL, pb, CCHMAX_SNIFF_BUFFER, NULL, NULL, ppszType, 0);

    return hr;
}

HRESULT CreateCacheFileFromStream(LPSTR pszUrl, LPSTREAM pstm)
{
    TCHAR		rgchFileName[MAX_PATH];
    HRESULT		hr;
    FILETIME	ft;
    
    rgchFileName[0] = 0;
    
    if (pstm == NULL || pszUrl == NULL)
        return TraceResult(E_INVALIDARG);
    
    if (!CreateUrlCacheEntryA(pszUrl, 0, NULL, rgchFileName, 0))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }
    
    
    hr = WriteStreamToFile(pstm, rgchFileName, CREATE_ALWAYS, GENERIC_WRITE);    
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }
    
    ft.dwLowDateTime = 0;
    ft.dwHighDateTime = 0;
    
    if (!CommitUrlCacheEntryA(	pszUrl, rgchFileName,
								ft, ft,
                                NORMAL_CACHE_ENTRY,
                                NULL, 0, NULL, 0))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }
    
error:
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\tags.h ===
/*
 *    t a g s . h
 *    
 *    Purpose:
 *        tag packer abstractions
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */



HRESULT CreateOEImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages);
HRESULT CreateBGImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages);
HRESULT CreateBGSoundCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags);
HRESULT CreateActiveMovieCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\tags.cpp ===
/*
 *    t a g s . c p p
 *    
 *    Purpose:
 *        tag packer abstractions
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "strconst.h"
#include "htmlstr.h"
#include "triutil.h"
#include "oleutil.h"
#include "mhtml.h"
#include "basemht.h"
#include "tags.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  p r o t o t y p e s
 */
HRESULT CreateOEImageTag(IHTMLElement *pElem, IMimeEditTag **ppTag);
HRESULT CreateBGImageTag(IHTMLDocument2 *pDoc, IUnknown *pUnk, DWORD dwType, IMimeEditTag **ppTag);
HRESULT CreateBGSoundTag(IHTMLElement *pElem, IMimeEditTag **ppTag);
HRESULT CreateActiveMovieTag(IUnknown *pUnk, IMimeEditTag **ppTag);

/*
 *  c o n s t a n t s
 */

enum
{
    BGIMAGE_BODYBACKGROUND = 0,
    BGIMAGE_BODYSTYLE,
    BGIMAGE_STYLESHEET,
    BGIMAGE_MAX
};

/*
 *  t y p e d e f s
 */

 
class COEImage :
    public CBaseTag
{
public:

    COEImage();
    virtual ~COEImage();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);
};

 
class COEImageCollection :
    public CBaseTagCollection
{
public:

    COEImageCollection();
    virtual ~COEImageCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CBGImage :
    public CBaseTag
{
public:

    CBGImage();
    virtual ~CBGImage();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLDocument2 *pDoc, IHTMLElement *pElem, DWORD dwType);

private:
    DWORD   m_dwType;
    IHTMLBodyElement        *m_pBody;           // set depending on type
    IHTMLStyle              *m_pStyle;          // set depending on type
    IHTMLRuleStyle          *m_pRuleStyle;      // set depending on type

protected:
    // override CBaseTagCollection
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstrSrc);
};

 
class CBGImageCollection :
    public CBaseTagCollection
{
public:

    CBGImageCollection();
    virtual ~CBGImageCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CBGSound:
    public CBaseTag
{
public:

    CBGSound();
    virtual ~CBGSound();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);
};

 
class CBGSoundCollection :
    public CBaseTagCollection
{
public:

    CBGSoundCollection();
    virtual ~CBGSoundCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CActiveMovie:
    public CBaseTag
{
public:

    CActiveMovie();
    virtual ~CActiveMovie();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);


private:
    IDispatch   *m_pDisp;
    DISPID      m_dispidSrc;

    HRESULT _GetSrc(BSTR *pbstr);
    HRESULT _EnsureDispID();

protected:
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstr);

};

 
class CActiveMovieCollection :
    public CBaseTagCollection
{
public:

    CActiveMovieCollection();
    virtual ~CActiveMovieCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


/* 
 *   F u n c t i o n s
 */


COEImage::COEImage()
{
}


COEImage::~COEImage()
{
}

HRESULT COEImage::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    HrGetMember(pElem, (BSTR)c_bstr_SRC, VARIANT_FALSE, &m_bstrSrc);
    return CBaseTag::Init(pElem);
}

HRESULT COEImage::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrDest);

    return S_OK;
}

HRESULT COEImage::OnPostSave()
{
    // OnPostSave the original SRC attribute
    HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrSrc);
    return S_OK;
}


HRESULT COEImage::CanPackage()
{
    IHTMLImgElement     *pImg;
    BSTR                bstr=NULL;
    HRESULT             hr=S_OK;

    // for an image, make sure that the ready-state has hit 'complete'. If not then the bits
    // have not been fully downloaded
    if (m_pElem && 
        m_pElem->QueryInterface(IID_IHTMLImgElement, (LPVOID *)&pImg)==S_OK)
    {
        pImg->get_readyState(&bstr);   // don't forget trident returns S_OK with bstr==NULL!
        if (bstr)
        {
            if (StrCmpIW(bstr, L"complete")!=0)
                hr = INET_E_DOWNLOAD_FAILURE;
            SysFreeString(bstr);
        }
        pImg->Release();
    }
    return hr;
}

HRESULT COEImage::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"image/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
COEImageCollection::COEImageCollection()
{
}


COEImageCollection::~COEImageCollection()
{
}

HRESULT COEImageCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLElement            *pElem;
    ULONG                   uImage;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_IMG, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    m_cTags = UlGetCollectionCount(pCollect);
    if (m_cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * m_cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * m_cTags);

        for (uImage=0; uImage<m_cTags; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                hr = CreateOEImageTag(pElem, &m_rgpTags[uImage]);
                if (FAILED(hr))
                {
                    pElem->Release();
                    goto error;
                }
                pElem->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateOEImageTag(IHTMLElement *pElem, IMimeEditTag **ppTag)
{
    COEImage    *pImage=0;
    HRESULT     hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create image
    pImage = new COEImage();
    if (!pImage)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init image with element
    hr = pImage->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pImage;
    pImage = NULL;

error:
    ReleaseObj(pImage);
    return hr;
}



HRESULT CreateOEImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages)
{
    COEImageCollection *pImages=0;
    HRESULT             hr;

    if (ppImages == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppImages = NULL;

    // create collection
    pImages = new COEImageCollection();
    if (!pImages)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pImages->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppImages = pImages;
    pImages = NULL;

error:
    ReleaseObj(pImages);
    return hr;
}
















CBGImage::CBGImage()
{
    m_dwType = BGIMAGE_BODYBACKGROUND;
    m_pBody = NULL;
    m_pStyle = NULL;
    m_pRuleStyle = NULL;
}


CBGImage::~CBGImage()
{
    SafeRelease(m_pBody);
    SafeRelease(m_pStyle);
    SafeRelease(m_pRuleStyle);
}

HRESULT CBGImage::Init(IHTMLDocument2 *pDoc, IHTMLElement *pElem, DWORD dwType)
{
    BSTR        bstr=NULL,
                bstrSrc=NULL,
                bstrBase=NULL;
    ULONG       cch=0;
    HRESULT     hr;

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    // tells us what the ITHMLElement actually is (BODY tag or STYLE)
    m_dwType = dwType;

    switch (dwType)
    {
        case BGIMAGE_BODYBACKGROUND:
            if (pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&m_pBody)==S_OK)
                m_pBody->get_background(&bstrSrc);
            break;
        
        case BGIMAGE_BODYSTYLE:
            pElem->get_style(&m_pStyle);
            if (m_pStyle)
            {
                m_pStyle->get_backgroundImage(&bstr);
                UnWrapStyleSheetUrl(bstr, &bstrSrc);
                SysFreeString(bstr);
            }
            break;

        case BGIMAGE_STYLESHEET:
            if (FindStyleRule(pDoc, L"BODY", &m_pRuleStyle)==S_OK)
            {
                m_pRuleStyle->get_backgroundImage(&bstr);
                UnWrapStyleSheetUrl(bstr, &bstrSrc);
                SysFreeString(bstr);
            }
            break;
        
        default:
            AssertSz(0, "BadType");
    }

    // trident's OM doesn't combine body backgound URLs with the nearest base tag
    // so we have to do this ourselves for background images
    if (bstrSrc &&
        FindNearestBaseUrl(pDoc, pElem, &bstrBase)==S_OK)
    {
        // see how many bytes are required
        UrlCombineW(bstrBase, bstrSrc, NULL, &cch, 0);
        if (cch)
        {
            // allocate the 'combined' string
            bstr = SysAllocStringLen(NULL, cch);
            if (bstr)
            {
                // do the actual combine into the new buffer
                if (!FAILED(UrlCombineW(bstrBase, bstrSrc, bstr, &cch, URL_UNESCAPE)))
                {
                    // use the new 'combined' url instead
                    SysFreeString(bstrSrc);
                    bstrSrc = bstr;
                }
                else
                    SysFreeString(bstr);
            }
        }
        SysFreeString(bstrBase);
    }
    
    // init failed if we get here and have no SRC url
    if (bstrSrc == NULL)
        return TraceResult(E_FAIL);

    m_bstrSrc = bstrSrc;
    bstrSrc = NULL;

    hr = CBaseTag::Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

error:
    SysFreeString(bstrSrc);
    return hr;
}

HRESULT CBGImage::SetSrc(BSTR bstrSrc)
{
    BSTR                    bstr=NULL;

    switch (m_dwType)
    {
        case BGIMAGE_BODYBACKGROUND:
            if (m_pBody)
                m_pBody->put_background(bstrSrc);
            break;
        
        case BGIMAGE_BODYSTYLE:
            if (m_pStyle && 
                WrapStyleSheetUrl(bstrSrc, &bstr)==S_OK)
            {
                m_pStyle->put_backgroundImage(bstr);
                SysFreeString(bstr);
            }
            break;

        case BGIMAGE_STYLESHEET:
            if (m_pRuleStyle && 
                WrapStyleSheetUrl(bstrSrc, &bstr)==S_OK)
            {
                m_pRuleStyle->put_backgroundImage(bstr);
                SysFreeString(bstr);
            }
            break;
        
        default:
            AssertSz(0, "BadType");
    }
    return S_OK;
}

HRESULT CBGImage::OnPreSave()
{
    if (m_bstrDest)
        SetSrc(m_bstrDest);
    return S_OK;
}

HRESULT CBGImage::OnPostSave()
{
    SetSrc(m_bstrSrc);
    return S_OK;
}


HRESULT CBGImage::CanPackage()
{
    return S_OK;
}

HRESULT CBGImage::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"image/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
CBGImageCollection::CBGImageCollection()
{
}


CBGImageCollection::~CBGImageCollection()
{
}

HRESULT CBGImageCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLBodyElement        *pBody=NULL;
    IHTMLElement            *pElem;
    IHTMLStyle              *pStyle=NULL;
    IHTMLRuleStyle          *pRuleStyle;
    BSTR                    bstr=NULL;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    /* *
       * there are 3 ways to get a background image:
       *  (in order of precedence that trident renders them)
       * 1. <BODY style="background:">
       * 2. <STYLE> background-image: </STYLE>
       * 3. <BODY background=>
       */

    // allocate an array of at most BGIMAGE_MAX CBGImage objects, we might not use them all
    if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * BGIMAGE_MAX))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }
        
    ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * BGIMAGE_MAX);

    hr = HrGetBodyElement(pDoc, &pBody);
    if (FAILED(hr))
    {
        // this can fail if we are on a page with no BODY tag, eg. a FRAMESET page
        // if there is no body, then we assume there are no BGIMAGES and bail with 0
        // elements in the collection
        hr = S_OK;
        goto error;
    }

    // try <BODY STYLE="background-image:">
    if (pBody->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
    {
        pElem->get_style(&pStyle);
        if (pStyle)
        {
            pStyle->get_backgroundImage(&bstr);
            if (bstr) 
            {
                if (*bstr && StrCmpIW(bstr, L"none")!=0)  // might be "" or "none" - both empty in trident language
                {
                    hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_BODYSTYLE, &m_rgpTags[m_cTags]);
                    if (!FAILED(hr))
                        m_cTags++;
                }
                SysFreeString(bstr);
                bstr = NULL;
            }
            pStyle->Release();
        }
        pElem->Release();
    }

    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // try the <STYLE> tag
    if (FindStyleRule(pDoc, L"BODY", &pRuleStyle)==S_OK)
    {
        pRuleStyle->get_backgroundImage(&bstr);
        if (bstr) 
        {
            if (*bstr && StrCmpIW(bstr, L"none")!=0)  // might be "" or "none" - both empty in trident language
            {
                hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_STYLESHEET, &m_rgpTags[m_cTags]);
                if (!FAILED(hr))
                    m_cTags++;
            }
            SysFreeString(bstr);
        }
        pRuleStyle->Release();
    }

    // try <BODY background=>
    pBody->get_background(&bstr);
    if (bstr) 
    {
        if (*bstr)  // might be ""
        {
            hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_BODYBACKGROUND, &m_rgpTags[m_cTags]);
            if (!FAILED(hr))
                m_cTags++;
        }
        SysFreeString(bstr);
        bstr = NULL;
    }
    
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

error:
    ReleaseObj(pBody);
    return hr;
}




HRESULT CreateBGImageTag(IHTMLDocument2 *pDoc, IUnknown *pUnk, DWORD dwType, IMimeEditTag **ppTag)
{
    CBGImage        *pImage=0;
    IHTMLElement    *pElem=0;
    HRESULT         hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create image
    pImage = new CBGImage();
    if (!pImage)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // init image with element
    hr = pImage->Init(pDoc, pElem, dwType);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pImage;
    pImage = NULL;

error:
    ReleaseObj(pImage);
    ReleaseObj(pElem);
    return hr;
}



HRESULT CreateBGImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages)
{
    CBGImageCollection *pImages=0;
    HRESULT             hr;

    if (ppImages == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppImages = NULL;

    // create collection
    pImages = new CBGImageCollection();
    if (!pImages)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pImages->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppImages = pImages;
    pImages = NULL;

error:
    ReleaseObj(pImages);
    return hr;
}






CBGSound::CBGSound()
{
}


CBGSound::~CBGSound()
{
}

HRESULT CBGSound::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    HrGetMember(pElem, (BSTR)c_bstr_SRC, VARIANT_FALSE, &m_bstrSrc);
    return CBaseTag::Init(pElem);
}

HRESULT CBGSound::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrDest);

    return S_OK;
}

HRESULT CBGSound::OnPostSave()
{
    // OnPostSave the original SRC attribute
    HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrSrc);
    return S_OK;
}


HRESULT CBGSound::CanPackage()
{
    return S_OK;
}

HRESULT CBGSound::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"audio/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
CBGSoundCollection::CBGSoundCollection()
{
}


CBGSoundCollection::~CBGSoundCollection()
{
}

HRESULT CBGSoundCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLElement            *pElem;
    ULONG                   uImage;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    m_cTags = UlGetCollectionCount(pCollect);
    if (m_cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * m_cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * m_cTags);

        for (uImage=0; uImage<m_cTags; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                hr = CreateBGSoundTag(pElem, &m_rgpTags[uImage]);
                if (FAILED(hr))
                {
                    pElem->Release();
                    goto error;
                }
                pElem->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateBGSoundTag(IHTMLElement *pElem, IMimeEditTag **ppTag)
{
    CBGSound    *pSound=0;
    HRESULT     hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create the sound
    pSound = new CBGSound();
    if (!pSound)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init sound with element
    hr = pSound->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pSound;
    pSound = NULL;

error:
    ReleaseObj(pSound);
    return hr;
}



HRESULT CreateBGSoundCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags)
{
    CBGSoundCollection *pSounds=0;
    HRESULT             hr;

    if (ppTags == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTags = NULL;

    // create collection
    pSounds = new CBGSoundCollection();
    if (!pSounds)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pSounds->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTags = pSounds;
    pSounds = NULL;

error:
    ReleaseObj(pSounds);
    return hr;
}

























CActiveMovie::CActiveMovie()
{
    m_pDisp = NULL;
    m_dispidSrc = DISPID_UNKNOWN;
}


CActiveMovie::~CActiveMovie()
{
    ReleaseObj(m_pDisp);
}

HRESULT CActiveMovie::Init(IHTMLElement *pElem)
{
    HRESULT hr;

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    hr = CBaseTag::Init(pElem);
    if (FAILED(hr))
        goto error;

    hr = _GetSrc(&m_bstrSrc);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CActiveMovie::_EnsureDispID()
{
    IHTMLObjectElement  *pObj;
    IDispatch           *pDisp=NULL;
    HRESULT             hr=E_FAIL;
    LPWSTR              pszW;

    if (m_pDisp && m_dispidSrc != DISPID_UNKNOWN)        // already have IDispatch and DISPID
        return S_OK;

    if (m_pElem->QueryInterface(IID_IHTMLObjectElement, (LPVOID *)&pObj)==S_OK)
    {
        // get the FileName parameter (points to the URL)
        pObj->get_object(&pDisp);
        if (pDisp)
        {
            // get the disp-id of the filename param (cache incase there is > 1)
            pszW = L"FileName";
            pDisp->GetIDsOfNames(IID_NULL, &pszW, 1, NULL, &m_dispidSrc);
    
            if (m_dispidSrc != DISPID_UNKNOWN)
            {
                // we have the DISPID, cache it and the IDispatch pointer
                m_pDisp = pDisp;
                pDisp->AddRef();
                hr = S_OK;
            }
            pDisp->Release();
        }
        pObj->Release();
    }
    return hr;
}

HRESULT CActiveMovie::_GetSrc(BSTR *pbstr)
{
    HRESULT     hr;
    VARIANTARG  v;

    hr = _EnsureDispID();
    if (FAILED(hr))
        goto error;

    hr = GetDispProp(m_pDisp, m_dispidSrc, NULL, &v, NULL);
    if (FAILED(hr))
        goto error;

    *pbstr = v.bstrVal;

error:
    return hr;
}

HRESULT CActiveMovie::SetSrc(BSTR bstr)
{
    HRESULT hr;
    VARIANTARG  v;

    hr = _EnsureDispID();
    if (FAILED(hr))
        goto error;

    v.vt = VT_BSTR;
    v.bstrVal = bstr;

    hr = SetDispProp(m_pDisp, m_dispidSrc, NULL, &v, NULL, DISPATCH_PROPERTYPUT);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CActiveMovie::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        SetSrc(m_bstrDest);

    return S_OK;
}

HRESULT CActiveMovie::OnPostSave()
{
    // OnPostSave the original SRC attribute
    SetSrc(m_bstrSrc);
    return S_OK;
}


HRESULT CActiveMovie::CanPackage()
{
    return S_OK;
}

HRESULT CActiveMovie::IsValidMimeType(LPWSTR pszTypeW)
{
    // allow all mime-types for active-movie controls
    // as many .avi's return appl/octet-stream
    return S_OK;
}

    
CActiveMovieCollection::CActiveMovieCollection()
{
}


CActiveMovieCollection::~CActiveMovieCollection()
{
}

HRESULT CActiveMovieCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLObjectElement      *pObject;
    ULONG                   uTag;
    HRESULT                 hr;
    ULONG                   cTags;
    BSTR                    bstr=NULL;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_OBJECT, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    cTags = UlGetCollectionCount(pCollect);
    if (cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * cTags);

        for (uTag=0; uTag<cTags; uTag++)
        {
            if (HrGetCollectionItem(pCollect, uTag, IID_IHTMLObjectElement, (LPVOID *)&pObject)==S_OK)
            {
                // get the object's class-id
                bstr = 0;
                pObject->get_classid(&bstr);
                if (bstr)
                {
                    // see if it's an active-movie control
                    if (StrCmpIW(bstr, L"CLSID:05589FA1-C356-11CE-BF01-00AA0055595A")==0)
                    {
                        hr = CreateActiveMovieTag(pObject, &m_rgpTags[uTag]);
                        if (FAILED(hr))
                        {
                            SysFreeString(bstr);
                            pObject->Release();
                            goto error;
                        }
                        m_cTags++;
                    }
                    SysFreeString(bstr);
                    bstr = NULL;
                }
                pObject->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateActiveMovieTag(IUnknown *pUnk, IMimeEditTag **ppTag)
{
    CActiveMovie    *pMovie=0;
    IHTMLElement    *pElem=0;
    HRESULT         hr;

    if (ppTag == NULL || pUnk == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // create the sound
    pMovie = new CActiveMovie();
    if (!pMovie)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init sound with element
    hr = pMovie->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pMovie;
    pMovie = NULL;

error:
    ReleaseObj(pMovie);
    ReleaseObj(pElem);
    return hr;
}



HRESULT CreateActiveMovieCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags)
{
    CActiveMovieCollection *pMovies=0;
    HRESULT             hr;

    if (ppTags == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTags = NULL;

    // create collection
    pMovies = new CActiveMovieCollection();
    if (!pMovies)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pMovies->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTags = pMovies;
    pMovies = NULL;

error:
    ReleaseObj(pMovies);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\triutil.h ===
/*
 *    t r i u t i l . c p p
 *    
 *    Purpose:
 *        Trident utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _TRIUTIL_H
#define _TRIUTIL_H

interface IHTMLDocument2;
interface IHTMLElement;
interface IHTMLBodyElement;

HRESULT HrCreateSyncTridentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv);
HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue);
HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect);
HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj);
ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect);
HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr);
HRESULT GetBodyStream(IUnknown *pUnkTrident, BOOL fHtml, LPSTREAM *ppstm);
HRESULT HrBindToUrl(LPCSTR pszUrl, LPSTREAM *ppstm);


// style sheets
HRESULT HrGetStyleTag(IHTMLDocument2 *pDoc, BSTR *pbstr);
HRESULT HrCopyStyleSheets(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest);
HRESULT HrCopyBackground(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest);
HRESULT HrRemoveStyleSheets(IHTMLDocument2 *pDoc);
HRESULT HrRemoveBackground(IHTMLDocument2 *pDoc);
HRESULT FindStyleRule(IHTMLDocument2 *pDoc, LPCWSTR pszSelectorW, IHTMLRuleStyle **ppRuleStyle);

#define FINDURL_SEARCH_RELATED_ONLY     0x01
HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, DWORD dwFlags, LPSTREAM *ppstm);
HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt);

// background images
HRESULT GetBackgroundImage(IHTMLDocument2 *pDoc, BSTR *pbstrUrl);
HRESULT SetBackgroundImage(IHTMLDocument2 *pDoc, BSTR bstrUrl);

// background sound
HRESULT GetBackgroundSound(IHTMLDocument2 *pDoc, int *pcRepeat, BSTR *pbstrUrl);
HRESULT SetBackgroundSound(IHTMLDocument2 *pDoc, int cRepeat, BSTR bstrUrl);

HRESULT UnWrapStyleSheetUrl(BSTR bstrStyleUrl, BSTR *pbstrUrl);
HRESULT WrapStyleSheetUrl(BSTR bstrUrl, BSTR *pbstrStyleUrl);
HRESULT FindNearestBaseUrl(IHTMLDocument2 *pDoc, IHTMLElement *pElemTag, BSTR *pbstrBaseUrl);

HRESULT SniffStreamForMimeType(LPSTREAM pstm, LPWSTR *ppszType);

// cache functions
HRESULT CreateCacheFileFromStream(LPSTR pszUrl, LPSTREAM pstm);

#endif //_TRIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\util.cpp ===
/*
 *    u t i l  . c p p
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <dllmain.h>
#include <resource.h>
#include "shared.h"
#include "util.h"
#include "mimeolep.h"
#include <icutil.h>
#include <strconst.h>
#include "demand.h"

extern BOOL                g_fCanEditBiDi;

INT_PTR CALLBACK BGSoundDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//NOTE: if *ppstm == NULL, then the stream is created.
//Otherwise it is written to.
HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm)
{
    HRESULT         hr=E_FAIL;
    HRSRC           hres;
    HGLOBAL         hGlobal;
    LPBYTE          pb;
    DWORD           cb;
    LPWSTR          pszW=0;
    ULONG           cchW;

    if (!ppstm || !lpszResourceName)
        return E_INVALIDARG;
    
    hres = FindResource(g_hLocRes, lpszResourceName, MAKEINTRESOURCE(RT_FILE));
    if (!hres)
        goto error;

    hGlobal = LoadResource(g_hLocRes, hres);
    if (!hGlobal)
        goto error;

    pb = (LPBYTE)LockResource(hGlobal);
    if (!pb)
        goto error;

    cb = SizeofResource(g_hLocRes, hres);
    if (!cb)
        goto error;

    cchW = (cb + 1);
    if (!MemAlloc ((LPVOID *)&pszW, sizeof(pszW[0]) * cchW))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    cchW = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, (LPSTR)pb, cb, pszW, cchW);
    if (cchW==0)
        goto error;
    
    if (*ppstm)
        hr = (*ppstm)->Write(pszW, cchW*sizeof(WCHAR), NULL);
    else
        {
        if (SUCCEEDED(hr = MimeOleCreateVirtualStream(ppstm)))
            hr = (*ppstm)->Write (pszW, cchW*sizeof(WCHAR), NULL);
        }

error:  
    SafeMemFree(pszW);
    return hr;
}


//
// REVIEW: We need this function because current version of USER.EXE does
//  not support pop-up only menu.
//
HMENU LoadPopupMenu(UINT id)
{
    HMENU hmenuParent = LoadMenu(g_hLocRes, MAKEINTRESOURCE(id));

    if (hmenuParent) {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}




UINT_PTR TTIdFromCmdId(UINT_PTR idCmd)
{
    if (idCmd >= IDM_FIRST && idCmd <= IDM_LAST)
        idCmd += TT_BASE;
    else
        idCmd = 0;
    return(idCmd);
}

// --------------------
//
// ProcessTooltips:
//
//      This function is used to process tooltips text notification.
//
// --------------------

void ProcessTooltips(LPTOOLTIPTEXTOE lpttt)
{
    if (lpttt->lpszText = MAKEINTRESOURCE(TTIdFromCmdId(lpttt->hdr.idFrom)))
        lpttt->hinst = g_hLocRes;
    else
        lpttt->hinst = NULL;
}


#define DEFAULT_FONTSIZE 2
INT PointSizeToHTMLSize(INT iPointSize)
{
    INT     iHTMLSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    if(iPointSize>=8 && iPointSize<9)
        iHTMLSize = 1;
    else if(iPointSize>=9 && iPointSize<12)
        iHTMLSize = 2;
    else if(iPointSize>=12 && iPointSize<14)
        iHTMLSize = 3;
    else if(iPointSize>=14 && iPointSize<18)
        iHTMLSize = 4;
    else if(iPointSize>=18 && iPointSize<24)
        iHTMLSize = 5;
    else if(iPointSize>=24 && iPointSize<36)
        iHTMLSize = 6;
    else if(iPointSize>=36)
        iHTMLSize = 7;
    else
        iHTMLSize = DEFAULT_FONTSIZE;

    return iHTMLSize;
}



HRESULT DoBackgroundSoundDlg(HWND hwnd, PBGSOUNDDLG pBGSoundDlg)
{
    if (DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddBackSound), hwnd, BGSoundDlgProc, (LPARAM)pBGSoundDlg)==IDOK)
        return S_OK;

    return E_FAIL;
}

static const HELPMAP g_rgBGSoundHlp[] =
{
    {ideSoundLoc, 50180},
    {idbtnBrowseSound, 50185},
    {idrbPlayNTimes, 50190},
    {idePlayCount, 50190},
    {IDC_SPIN1, 50190},
    {idrbPlayInfinite, 50195},
    {0, 0}
};

INT_PTR CALLBACK BGSoundDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PBGSOUNDDLG     pBGSoundDlg;
    WCHAR           wsz[10];
    OPENFILENAMEW   ofn;
    WCHAR           wszTitle[CCHMAX_STRINGRES],
                    wszFilter[CCHMAX_STRINGRES],
                    wszFile[MAX_PATH],
                    wszInitialDir[MAX_PATH];
    LPCWSTR         wszMediaDir = L"\\Media";
    LPWSTR          pwszFile = NULL;;
    UINT            rc;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            pBGSoundDlg = (PBGSOUNDDLG)lParam;

            Assert (pBGSoundDlg);
            SendMessage(GetDlgItem(hwnd, ideSoundLoc), EM_SETLIMITTEXT, MAX_PATH-1, 0);
            SendMessage(GetDlgItem(hwnd, idePlayCount), EM_SETLIMITTEXT, 3, 0);
            SetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), pBGSoundDlg->wszUrl);
            wnsprintfW(wsz, ARRAYSIZE(wsz), L"%d", max(pBGSoundDlg->cRepeat, 1));
            SetWindowTextWrapW(GetDlgItem(hwnd, idePlayCount), wsz);
            CheckRadioButton(hwnd, idrbPlayNTimes, idrbPlayInfinite, pBGSoundDlg->cRepeat==-1 ? idrbPlayInfinite:idrbPlayNTimes);
            SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0, MAKELONG(999, 1));
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgBGSoundHlp);            

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case idrbPlayInfinite:
                case idrbPlayNTimes:
                    EnableWindow(GetDlgItem(hwnd, idePlayCount), LOWORD(wParam)==idrbPlayNTimes);
                    break;

                case idbtnBrowseSound:

                    *wszFile=0;
                    *wszFilter=0;
                    *wszTitle=0;

                    LoadStringWrapW(g_hLocRes, idsFilterAudio, wszFilter, ARRAYSIZE(wszFilter));
                    ReplaceCharsW(wszFilter, L'|', L'\0');
    
                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hwnd;
                    ofn.lpstrFile = wszFile;
                    ofn.lpstrFilter = wszFilter;

                    LoadStringWrapW(g_hLocRes, idsPickBGSound, wszTitle, ARRAYSIZE(wszTitle));
                    ofn.lpstrTitle = wszTitle;
                    ofn.nMaxFile = ARRAYSIZE(wszFile);
                    ofn.Flags = OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_NONETWORKBUTTON|OFN_NOCHANGEDIR;
                    
                    // begin added for BUG 29778
                    rc = GetWindowsDirectoryWrapW(wszInitialDir, ARRAYSIZE(wszInitialDir));
                    if( rc > ARRAYSIZE(wszInitialDir))
                    {
                        // if cannot copy entire windows dir path then punt and default to desktop
                        *wszInitialDir = 0;
                    }
                    else
                    {
                        if (!StrCatBuffW(wszInitialDir, wszMediaDir, ARRAYSIZE(wszInitialDir)))
                        {
                            // punt if can't concat
                            *wszInitialDir = 0;
                        }
                    }

                    ofn.lpstrInitialDir = wszInitialDir;
                    // end added for BUG 29778
                    if (HrAthGetFileNameW(&ofn, TRUE)==S_OK)
                        SetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), wszFile);

                    return TRUE;

                case IDOK:
                    pBGSoundDlg = (PBGSOUNDDLG)GetWindowLongPtr(hwnd, DWLP_USER);

                    GetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), pBGSoundDlg->wszUrl, ARRAYSIZE(pBGSoundDlg->wszUrl));
                    if (!IsValidFileIfFileUrlW(pBGSoundDlg->wszUrl) &&
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsBgSound), MAKEINTRESOURCEW(idsErrBgSoundFileBad), NULL, MB_YESNO|MB_DEFBUTTON2)==IDNO)
                       break;
                    
                    pBGSoundDlg->cRepeat=1;
                    
                    if (IsDlgButtonChecked(hwnd, idrbPlayNTimes))
                        {
                        GetWindowTextWrapW(GetDlgItem(hwnd, idePlayCount), wsz, ARRAYSIZE(wsz));
                        pBGSoundDlg->cRepeat = StrToIntW(wsz);
                        if (pBGSoundDlg->cRepeat <= 0 || pBGSoundDlg->cRepeat > 999)
                            {
                            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsBgSound), MAKEINTRESOURCEW(idsErrBgSoundLoopRange), NULL, MB_OK);
                            break;
                            }
                        }                        
                    else
                        pBGSoundDlg->cRepeat=-1;    //infinite

                    // fall thro'

                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;
        }

    return FALSE;
}

static const HELPMAP g_rgFmtParaHlp[] =
{
    {idmFmtLeft, 50200},
    {idmFmtRight, 50200},
    {idmFmtCenter, 50200},
    {idmFmtJustify, 50200},
    {idmFmtNumbers, 50205},
    {idmFmtBullets, 50205},
    {idmFmtBulletsNone, 50205},
    {0, 0}
};

INT_PTR CALLBACK FmtParaDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    int                     id, i;
    LPPARAPROP              pParaProp;

    pParaProp = (LPPARAPROP)GetWindowLongPtr(hwnd, DWLP_USER);
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            Assert(lParam!= NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
            pParaProp = (LPPARAPROP)lParam;
            CenterDialog(hwnd);
            // Bug 96520
            // if we are in plain text mode then paragraph format should be set to left
            if(!(pParaProp->group[0].iID))
                pParaProp->group[0].iID = idmFmtLeft;

            CheckRadioButton( hwnd,  idmFmtLeft, idmFmtJustify, pParaProp->group[0].iID);
            CheckRadioButton( hwnd,  idmFmtNumbers, idmFmtBulletsNone, pParaProp->group[1].iID);
            CheckRadioButton( hwnd,  idmFmtBlockDirLTR, idmFmtBlockDirRTL, pParaProp->group[2].iID);
            if (!g_fCanEditBiDi)
            {
                ShowWindow(GetDlgItem(hwnd, idmFmtBlockDirRTL), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, idmFmtBlockDirLTR), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC1), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC2), SW_HIDE);
            }
        }
        return(TRUE);
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgFmtParaHlp);            

        case WM_COMMAND:
            switch(id=GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idmFmtBlockDirLTR:
                case idmFmtBlockDirRTL:
                // Dir Attribute implies alignment
                    CheckRadioButton( hwnd,  idmFmtLeft, idmFmtRight, id == idmFmtBlockDirLTR ? idmFmtLeft : idmFmtRight);
                   break;
                
                case IDOK:
                for (i = 0; i < 4; i++)
                {
                    if(IsDlgButtonChecked(hwnd, idmFmtLeft + i) == BST_CHECKED)
                    {
                        pParaProp->group[0].bChanged = !(pParaProp->group[0].iID - (idmFmtLeft + i) == 0);
                        pParaProp->group[0].iID = idmFmtLeft + i;
                    }
                }

                for (i = 0; i < 2; i++)
                {
                    if(IsDlgButtonChecked(hwnd, idmFmtNumbers + i) == BST_CHECKED)
                    {
                        pParaProp->group[1].bChanged = !(pParaProp->group[1].iID - (idmFmtNumbers + i) == 0);
                        pParaProp->group[1].iID = idmFmtNumbers + i;
                    }
                }
                // Bullets and Numbers are flip flops, let's force a change if the user selscts none
                // leaving the same previous ID
                if(IsDlgButtonChecked(hwnd, idmFmtBulletsNone) == BST_CHECKED)
                {
                    pParaProp->group[1].bChanged = TRUE;
                }

                if (g_fCanEditBiDi)
                {
                    for (i = 0; i < 2; i++)
                    {
                        if(IsDlgButtonChecked(hwnd, idmFmtBlockDirLTR + i) == BST_CHECKED)
                        {
                            pParaProp->group[2].bChanged = !(pParaProp->group[2].iID - (idmFmtBlockDirLTR + i) == 0);
                            pParaProp->group[2].iID = idmFmtBlockDirLTR + i;
                        }
                    }
                }                
                    // fall thro'

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
            break;
    } 
   return FALSE; 
}

BOOL CanEditBiDi(void)
{
    UINT cNumkeyboards = 0, i;
    HKL* phKeyboadList = NULL;
    BOOL fBiDiKeyBoard = FALSE;

    // Let's check how many keyboard the system has
    cNumkeyboards = GetKeyboardLayoutList(0, phKeyboadList);

    phKeyboadList = (HKL*)LocalAlloc(LPTR, cNumkeyboards * sizeof(HKL));  
    cNumkeyboards = GetKeyboardLayoutList(cNumkeyboards, phKeyboadList);

    for (i = 0; i < cNumkeyboards; i++)
    {
        LANGID LangID = PRIMARYLANGID(LANGIDFROMLCID(LOWORD(phKeyboadList[i])));
        if(  LangID == LANG_ARABIC
           ||LangID == LANG_HEBREW
           ||LangID == LANG_FARSI)
          {
            fBiDiKeyBoard = TRUE;
            break;
          }
    }
   if(phKeyboadList)
   {
       LocalFree((HLOCAL)phKeyboadList);
   }
   return  fBiDiKeyBoard;
}

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            OEWinHelp ((HWND)lphi->hItemHandle,
                c_szCtxHelpFile,
                HELP_WM_HELP,
                (DWORD_PTR)(LPVOID)rgCtxMap);
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU)
    {
        OEWinHelp ((HWND) wParam,
            c_szCtxHelpFile,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)rgCtxMap);
        return (TRUE);
    }
    
    Assert(0);
    
    return FALSE;
}

BOOL CALLBACK AthFixDialogFontsProc(HWND hChild, LPARAM lParam){
    HFONT hFont = (HFONT)lParam;

    if(hFont)
        SendMessage(hChild, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
    else
        return FALSE;

    return TRUE;
}

HRESULT AthFixDialogFonts(HWND hwndDlg)
{
    HFONT hFont = NULL;

    if(!IsWindow(hwndDlg))
        return E_INVALIDARG;

    if((FAILED(g_lpIFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont))) || (!hFont))
        return E_FAIL;

    EnumChildWindows(hwndDlg, AthFixDialogFontsProc, (LPARAM)hFont);

    return S_OK;
}

//
//  If you are calling this function and you use the result to draw text, you
//  must use a function that supports font substitution (DrawTextWrapW, ExtTextOutWrapW).
//
BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags)
{
    RECT    rect = {0};
    int     rc;

    rc = DrawTextWrapW(hdc, lpwString, cchString, &rect, DT_CALCRECT | dwFlags);
    
    lpSize->cx = rect.right - rect.left + 1;
    lpSize->cy = rect.bottom - rect.top + 1;

    return((BOOL)rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

// #include "msoert.h"

// forward references
typedef struct tagNMTTDISPINFOA NMTTDISPINFOA, FAR *LPNMTTDISPINFOA;
 
#ifndef LPTOOLTIPTEXTOE
#define LPTOOLTIPTEXTOE  LPNMTTDISPINFOA
#endif 


HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm);
HMENU LoadPopupMenu(UINT id);
void ProcessTooltips(LPTOOLTIPTEXTOE lpttt);
INT PointSizeToHTMLSize(INT iPointSize);

typedef struct BGSOUNDDLG_tag
{
    WCHAR   wszUrl[MAX_PATH];    // we clip this URL to MAX_PATH
    int     cRepeat;

} BGSOUNDDLG, *PBGSOUNDDLG;


typedef struct tagPARAPROP
{
struct {
           INT iID;
           BOOL bChanged;
       }group[3];
} PARAPROP,*LPPARAPROP;

HRESULT DoBackgroundSoundDlg(HWND hwnd, PBGSOUNDDLG pBgSoundDlg);
INT_PTR CALLBACK FmtParaDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CanEditBiDi(void);

// Context-sensitive Help utility.
typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);

#define AthMessageBox(hwnd, pszT, psz1, psz2, fu) MessageBoxInst(g_hLocRes, hwnd, pszT, psz1, psz2, fu)
#define AthMessageBoxW(hwnd, pwszT, pwsz1, pwsz2, fu) MessageBoxInstW(g_hLocRes, hwnd, pwszT, pwsz1, pwsz2, fu, LoadStringWrapW, MessageBoxWrapW)

#define AthFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags) \
        CchFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags, \
        GetDateFormatWrapW, GetTimeFormatWrapW, GetLocaleInfoWrapW)

HRESULT AthFixDialogFonts(HWND hwnd);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addparse.h ===
// -------------------------------------------------------------------------------
// Addparse.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// -------------------------------------------------------------------------------
#ifndef __ADDPARSE_H
#define __ADDPARSE_H

// -------------------------------------------------------------------------------
// Depends
// -------------------------------------------------------------------------------
#include "strconst.h"
#include "wstrpar.h"
#include "bytebuff.h"

// -------------------------------------------------------------------------------
// CAddressParser
// -------------------------------------------------------------------------------
class CAddressParser
{
public:
    // ---------------------------------------------------------------------------
    // CAddressParser Methods
    // ---------------------------------------------------------------------------
    void Init(LPCWSTR pszAddress, ULONG cchAddress);
    HRESULT Next(void);

    // ---------------------------------------------------------------------------
    // Accessors
    // ---------------------------------------------------------------------------
    LPCWSTR PszFriendly(void);
    ULONG  CchFriendly(void);
    LPCWSTR PszEmail(void);
    ULONG  CchEmail(void);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrAppendFriendly(void);
    HRESULT _HrAppendUnsure(WCHAR chStart, WCHAR chEnd);
    HRESULT _HrIsEmailAddress(WCHAR chStart, WCHAR chEnd, BOOL *pfIsEmail);
    HRESULT _HrQuotedEmail(WCHAR *pchToken);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    CStringParserW      m_cString;          // String Parser
    BYTE                m_rgbStatic1[256];  // Static Used for Friendly
    BYTE                m_rgbStatic2[256];  // Static Used for Email
    CByteBuffer         m_cFriendly;        // Parsed Friendly Name
    CByteBuffer         m_cEmail;           // Email Name
};

#endif // __ADDPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\viewsrc.h ===
#ifndef _VIEWSRC_
#define _VIEWSRC_

#include "richedit.h"
#include "richole.h"

interface IMimeMessage;

HRESULT ViewSource(HWND hwndParent, IMimeMessage *pMsg);


class CREMenu :
    public IRichEditOleCallback
{
public:
    CREMenu();
    ~CREMenu();

    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // *** IRichEditOleCallback methods ***
    HRESULT STDMETHODCALLTYPE GetNewStorage (LPSTORAGE FAR *);
    HRESULT STDMETHODCALLTYPE GetInPlaceContext(LPOLEINPLACEFRAME FAR *,LPOLEINPLACEUIWINDOW FAR *,LPOLEINPLACEFRAMEINFO);
    HRESULT STDMETHODCALLTYPE ShowContainerUI(BOOL);
    HRESULT STDMETHODCALLTYPE QueryInsertObject(LPCLSID, LPSTORAGE,LONG);
    HRESULT STDMETHODCALLTYPE DeleteObject(LPOLEOBJECT);
    HRESULT STDMETHODCALLTYPE QueryAcceptData(  LPDATAOBJECT,CLIPFORMAT FAR *, DWORD,BOOL, HGLOBAL);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);
    HRESULT STDMETHODCALLTYPE GetClipboardData(CHARRANGE FAR *, DWORD,LPDATAOBJECT FAR *);
    HRESULT STDMETHODCALLTYPE GetDragDropEffect(BOOL, DWORD,LPDWORD);
    HRESULT STDMETHODCALLTYPE GetContextMenu(WORD, LPOLEOBJECT,CHARRANGE FAR *,HMENU FAR *);

    HRESULT Init(HWND hwndEdit, int idMenu);

private:
    HWND    m_hwndEdit;
    ULONG   m_cRef;
    int     m_idMenu;
};


class CMsgSource:
    public IOleCommandTarget
{
public:
    CMsgSource();
    ~CMsgSource();

    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    HRESULT Init(HWND hwndParent, int id, IOleCommandTarget *pCmdTargetParent);
    HRESULT Show(BOOL fOn, BOOL fColor);
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT OnWMNotify(WPARAM wParam, NMHDR* pnmhdr, LRESULT *plRet);
    
    HRESULT Load(IStream *pstm);
    HRESULT Save(IStream **pstm);
    HRESULT SetRect(RECT *prc);
    HRESULT IsDirty();
    HRESULT SetDirty(BOOL fDirty);
    HRESULT OnTimer(WPARAM idTimer);
    HRESULT TranslateAccelerator(LPMSG lpmsg);
    HRESULT HasFocus();
    HRESULT SetFocus();

private:
    ULONG               m_cRef;
    HWND                m_hwnd;
    BOOL                m_fColor,
                        m_fDisabled;
    LPSTR               m_pszLastText;

    IOleCommandTarget   *m_pCmdTargetParent;

    void OnChange();
    void HideSelection(BOOL fHide, BOOL fChangeStyle);
    void GetSel(CHARRANGE *pcr);
    void SetSel(int nStart, int nEnd);
    void GetSelectionCharFormat(CHARFORMAT *pcf);
    void SetSelectionCharFormat(CHARFORMAT *pcf);
    HRESULT _GetText(LPSTR *ppsz);

};




class CViewSource
{
public:

    CViewSource();
    ~CViewSource();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Init(HWND hwndParent, IMimeMessage *pMsg);
    HRESULT Show();

    static INT_PTR CALLBACK _ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hwnd,     
                    m_hwndEdit;
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;

    HRESULT _BoldKids();
    
    INT_PTR    _DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
};


#endif //_VIEWSRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addparse.cpp ===
// --------------------------------------------------------------------------------
// Addparse.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "addparse.h"
#include "bytebuff.h"
#include "shlwapi.h"
#include <demand.h>     // must be last!

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
static const WCHAR c_wszAddressDelims[] = L"\",<(;";
static const WCHAR c_wszRfc822MustQuote[] = L"()<>,;:\\\"[] ";
static const WCHAR c_wszSpace[] = L" ";
static const WCHAR c_wszEmpty[] = L"";

// --------------------------------------------------------------------------------
// CAddressParser::Init
// --------------------------------------------------------------------------------
void CAddressParser::Init(LPCWSTR pszAddress, ULONG cchAddress)
{
    // Give the byte buffers some static space to reduce memory allocations
    m_cFriendly.Init(m_rgbStatic1, sizeof(m_rgbStatic1));
    m_cEmail.Init(m_rgbStatic2, sizeof(m_rgbStatic2));

    // Init the string parser
    m_cString.Init(pszAddress, cchAddress, PSF_NOTRAILWS | PSF_NOFRONTWS);
}

// --------------------------------------------------------------------------------
// CAddressParser::Next
// --------------------------------------------------------------------------------
HRESULT CAddressParser::Next(void)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       chToken;

    // Reset current Friendlay and Email Buffers
    m_cFriendly.SetSize(0);
    m_cEmail.SetSize(0);

    // Outer Loop
    while(1)
    {
        // Skip White Space
        chToken = m_cString.ChSkipWhite();

        // Done...
        if (L'\0' == chToken)
            break;

        // Parse until we hit a token
        chToken = m_cString.ChParse(c_wszAddressDelims, PSF_ESCAPED | PSF_NOTRAILWS);

        // No data was read
        if (0 == m_cString.CbValue())
        {
            // End of string hit
            if (L'\0' == chToken)
                break;

            // Otherwise, comma or semicolon and we have data
            else if ((L',' == chToken) || (L';' == chToken))
            {
                // If we have data, were done
                if (m_cFriendly.CbData() || m_cEmail.CbData())
                    break;

                // Otherwise, continue
                else
                    continue;
            }
        }

        // Email Addresses are never quoted
        if (L'\"' == chToken)
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendUnsure(L'\0', L'\0'));

            // Parse parameter value
            chToken = m_cString.ChParse(L'\"', L'\"', PSF_ESCAPED);

            // Raid-47099: We need to parse: "CN=first last/O=xyz> org/C=US"@xyz.innosoft.com
            CHECKHR(hr = _HrQuotedEmail(&chToken));

            // Returns S_OK if it was processed
            if (S_FALSE == hr)
            {
                // Write to Friendly
                CHECKHR(hr = _HrAppendFriendly());
            }
        }

        // Otherwise, < always flushes to email
        else if (L'<' == chToken)
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendFriendly());

            // Parse parameter value
            chToken = m_cString.ChParse(L">", 0);

            // Didn't find the end bracket
            if (L'>' == chToken)
            {
                // Write Friendly Name
                CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));
            }

            // Otherwise...
            else
            {
                // Should have an Email Address
                CHECKHR(hr = _HrAppendUnsure(L'<', L'>'));
            }
        }

        // Otherwise
        else
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendUnsure(L'\0', L'\0'));

            // If right paren, search to end
            if (L'(' == chToken)
            {
                // Parse to ending paren...
                chToken = m_cString.ChParse(L'(', L')', PSF_ESCAPED);

                // AppendUnsure
                CHECKHR(hr = _HrAppendUnsure(L'(', L')'));
            }
        }

        // Done
        if ((L',' == chToken) || (L';' == chToken))
            break;
    }

    // If friendly name has data, append a null, check email and return
    if (m_cFriendly.CbData())
    {
        // Append a Null
        m_cFriendly.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));

        // If Email is not empty, append a null
        if (m_cEmail.CbData())
            m_cEmail.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));
    }

    // Otherwise, if email has data, append null and return
    else if (m_cEmail.CbData())
    {
        // If Email is not empty, append a null
        m_cEmail.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));
    }

    // Are we really done ?
    else if (L'\0' == chToken)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Skip Commas and semicolons
    if (L',' == chToken)
        m_cString.ChSkip(L",");
    else if (L';' == chToken)
        m_cString.ChSkip(L";");

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrQuotedEmail
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrQuotedEmail(WCHAR *pchToken)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cchT=0;
    WCHAR   chDelim;
    BOOL    fSeenAt=FALSE;
    WCHAR   ch;
    WCHAR   szToken[2];

    // Invalid Arg
    Assert(pchToken);

    // We should have some data
    if (0 == m_cString.CbValue())
        return S_OK;

    // Get the character
    ch = m_cString.ChPeekNext(0);

    // Check for DBCS
    if (L'@' != ch)
        return S_FALSE;

    // Look ahead and check for: "CN=first last/O=xyz> org/C=US"@xyz.innosoft.com
    while(1)
    {
        // Get the character
        ch = m_cString.ChPeekNext(cchT);

        // Breaking Character
        if (L'\0' == ch || L' ' == ch || L',' == ch || L';' == ch || L'<' == ch || L'>' == ch || L'(' == ch || L')' == ch)
            break;

        // At Sign?
        if (L'@' == ch)
            fSeenAt = TRUE;

        // Increment
        cchT++;
    }

    // No At Sign
    if (0 == cchT || FALSE == fSeenAt)
        return S_FALSE;

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

    // Setup szToken
    szToken[0] = (L'\0' == ch) ? L' ' : ch;
    szToken[1] = L'\0';

    // Seek to next space
    ch = m_cString.ChParse(szToken, PSF_NOCOMMENTS);
    Assert(szToken[0] == ch || L'\0' == ch);

    // If there is data
    if (m_cString.CbValue() > 0)
    {
        // Append the Email Address
        CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));
    }

    // End Token
    *pchToken = szToken[0];

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrIsEmailAddress
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrIsEmailAddress(WCHAR chStart, WCHAR chEnd, BOOL *pfIsEmail)
{
    // Locals
    HRESULT        hr=S_OK;
    WCHAR          chToken;
    CStringParserW cString;

    // Invalid Arg
    Assert(pfIsEmail);

    // Init
    *pfIsEmail = FALSE;

    // Init
    cString.Init(m_cString.PszValue(), m_cString.CchValue(), PSF_NOCOMMENTS | PSF_ESCAPED | PSF_NOTRAILWS | PSF_NOFRONTWS);

    // Parse to the end to remove comments
    if (L'\0' != cString.ChParse(c_wszEmpty) || 0 == cString.CbValue())
        return S_OK;

    // Parse String
    if (NULL == StrChrW(cString.PszValue(), L' '))
    {
        // If in brackets, then its an email address for sure
        if (L'<' == chStart && L'>' == chEnd)
        {
            // Is Email
            *pfIsEmail = TRUE;

            // Write Friendly Name
            CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cString.CbValue()));
        }

        // Look for the last '@' sign and see if their are escapeable chars before the at sign
        else
        {
            // Locals
            LPWSTR      pszT=(LPWSTR)cString.PszValue();
            LPWSTR      pszLastAt=NULL;
            ULONG       cQuoteBeforeAt=0;
            ULONG       cQuoteAfterAt=0;

            // Raid - 62104: Outlook98 doesn't handle Lotus Domino RFC822 Address Construction
            while(*pszT)
            {
                // Check for '@' sign
                if (L'@' == *pszT)
                {
                    // If we already saw an at sign, move cQuoteAfterAt to cQuoteBeforeAt
                    if (pszLastAt)
                    {
                        cQuoteBeforeAt += cQuoteAfterAt;
                        cQuoteAfterAt = 0;
                    }

                    // Save Last At
                    pszLastAt = pszT;
                }

                // See if *pszT is in c_szRfc822MustQuote
                else if (NULL != StrChrW(c_wszRfc822MustQuote, *pszT))
                {
                    // If we've seen an at sign, track quote after at
                    if (pszLastAt)
                        cQuoteAfterAt++;
                    else
                        cQuoteBeforeAt++;
                }

                // Increment
                pszT++;
            }

            // Only if we saw an '@' sign
            if (NULL != pszLastAt)
            {
                // Is Email
                *pfIsEmail = TRUE;

                // If there were not chars that need quoting...
                if (0 == cQuoteBeforeAt)
                {
                    // Write Friendly Name
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cString.CbValue()));
                }

                // "Mailroute_TstSCC1[BOFATEST.MRTSTSCC]%SSW%EMAILDOM%BETA"@bankamerica.com
                else
                {
                    // Locals
                    ULONG cbComplete=cString.CbValue();
                    ULONG cbFirstPart=(ULONG)(pszLastAt - cString.PszValue());
                    ULONG cbLastPart=cbComplete - cbFirstPart;

                    // Append Doulbe Quote
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

                    // Append Firt part before last at
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cbFirstPart));

                    // Append Email Address
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

                    // Append Firt part before last at
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)pszLastAt, cbLastPart));
                }
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrAppendUnsure
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrAppendUnsure(WCHAR chStart, WCHAR chEnd)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fIsEmail=FALSE;

    // We have data
    if (0 == m_cString.CbValue())
        goto exit;

    // Email is not set yet ?
    if (m_cEmail.CbData() == 0)
    {
        // Is current parsed string an address ?
        CHECKHR(hr = _HrIsEmailAddress(chStart, chEnd, &fIsEmail));
    }

    // Not an Eamil Address
    if (FALSE == fIsEmail && m_cString.CbValue() > 0)
    {
        // Append a space
        if (m_cFriendly.CbData() > 0)
        {
            // Add a space
            CHECKHR(hr = m_cFriendly.Append((LPBYTE)c_wszSpace, sizeof(WCHAR)));

            // Start Character
            if (chStart)
            {
                // Append Start Delimiter
                CHECKHR(hr = m_cFriendly.Append((LPBYTE)&chStart, sizeof(WCHAR)));
            }
        }

        // Otherwise, don't write ending terminator
        else
            chEnd = L'\0';

        // Write Friendly Name
        CHECKHR(hr = m_cFriendly.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

        // Start Character
        if (chEnd)
        {
            // Append Start Delimiter
            CHECKHR(hr = m_cFriendly.Append((LPBYTE)&chEnd, sizeof(WCHAR)));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrAppendFriendly
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrAppendFriendly(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // We should have some data
    if (0 == m_cString.CbValue())
        return S_OK;

    // Append a space
    if (m_cFriendly.CbData() > 0)
    {
        // Add a space
        CHECKHR(hr = m_cFriendly.Append((LPBYTE)c_wszSpace, sizeof(WCHAR)));
    }

    // Write Friendly Name
    CHECKHR(hr = m_cFriendly.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::PszFriendly
// --------------------------------------------------------------------------------
LPCWSTR CAddressParser::PszFriendly(void)
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return c_wszEmpty;
    }

    // Return It
    return (m_cFriendly.CbData() ? (LPCWSTR)m_cFriendly.PbData() : PszEmail());
}

// --------------------------------------------------------------------------------
// CAddressParser::CchFriendly
// --------------------------------------------------------------------------------
ULONG CAddressParser::CchFriendly(void) 
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return 0;
    }

    // Return It
    return (m_cFriendly.CbData() ? (m_cFriendly.CbData() - sizeof(WCHAR)) / sizeof(WCHAR) : CchEmail());
}

// --------------------------------------------------------------------------------
// CAddressParser::PszEmail
// --------------------------------------------------------------------------------
LPCWSTR CAddressParser::PszEmail(void)    
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return c_wszEmpty;
    }

    // Return It
    return (m_cEmail.CbData() ? (LPCWSTR)m_cEmail.PbData() : PszFriendly());
}

// --------------------------------------------------------------------------------
// CAddressParser::CchEmail
// --------------------------------------------------------------------------------
ULONG  CAddressParser::CchEmail(void)    
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return 0;
    }

    // Return It
    return (m_cEmail.CbData() ? (m_cEmail.CbData() - sizeof(WCHAR)) / sizeof(WCHAR) : CchFriendly());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addrenum.h ===
// --------------------------------------------------------------------------------
// Addrenum.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ADDRENUM_H
#define __ADDRENUM_H

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
class CMimeEnumAddressTypes : public IMimeEnumAddressTypes
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeEnumAddressTypes(void);
    ~CMimeEnumAddressTypes(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeEnumAddressTypes
    // ----------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cItems, LPADDRESSPROPS prgAdr, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumAddressTypes **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

    // ----------------------------------------------------------------------------
    // CMimeEnumAddressTypes
    // ----------------------------------------------------------------------------
    HRESULT HrInit(IMimeAddressTable *pTable, ULONG iItem, LPADDRESSLIST pList, BOOL fDuplicate);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
	LONG				m_cRef;			// Reference count
    ADDRESSLIST         m_rList;        // Array of addresses
    ULONG               m_iAddress;     // Current Address
    IMimeAddressTable  *m_pTable;       // Point back to original address table
	CRITICAL_SECTION	m_cs;			// Thread safety
};

#endif // __ADDRENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addrenum.cpp ===
// --------------------------------------------------------------------------------
// AddrEnum.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "addrenum.h"
#include "olealloc.h"
#include "addressx.h"

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
CMimeEnumAddressTypes::CMimeEnumAddressTypes(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pTable = NULL;
    m_iAddress = 0;
    ZeroMemory(&m_rList, sizeof(ADDRESSLIST));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::~CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
CMimeEnumAddressTypes::~CMimeEnumAddressTypes(void)
{
    g_pMoleAlloc->FreeAddressList(&m_rList);
    SafeRelease(m_pTable);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeEnumAddressTypes == riid)
        *ppv = (IMimeEnumAddressTypes *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumAddressTypes::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumAddressTypes::Release(void)
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return cRef;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Next
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Next(ULONG cWanted, LPADDRESSPROPS prgAdr, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cFetch=0, 
                iAddress=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_rList.prgAdr)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_rList.cAdrs - m_iAddress);
    if (0 == cFetch)
        goto exit;

    // Invalid Arg
    if (NULL == prgAdr)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Copy cWanted
    for (iAddress=0; iAddress<cFetch; iAddress++)
    {
        // Zero
        ZeroMemory(&prgAdr[iAddress], sizeof(ADDRESSPROPS));

        // Copy Props
        CHECKHR(hr = HrCopyAddressProps(&m_rList.prgAdr[m_iAddress], &prgAdr[iAddress]));

        // Next
        m_iAddress++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Skip
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_iAddress + cSkip) >= m_rList.cAdrs) || NULL == m_rList.prgAdr)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_iAddress += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Reset
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_iAddress = 0;
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Count
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Count(ULONG *pcCount)
{
    // Invalid Arg
    if (NULL == pcCount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Count
    *pcCount = m_rList.cAdrs;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Clone(IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit(m_pTable, m_iAddress, &m_rList, TRUE));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::HrInit
// --------------------------------------------------------------------------------
HRESULT CMimeEnumAddressTypes::HrInit(IMimeAddressTable *pTable, ULONG iAddress, LPADDRESSLIST pList, BOOL fDuplicate)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Invalid Arg
    Assert(pTable && pList);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check param
    Assert(m_iAddress == 0 && m_rList.cAdrs == 0 && m_rList.prgAdr == NULL);

    // Empty Enumerator ?
    if (0 == pList->cAdrs)
    {
        Assert(pList->prgAdr == NULL);
        goto exit;
    }

    // No Duplicate ?
    if (FALSE == fDuplicate)
        CopyMemory(&m_rList, pList, sizeof(ADDRESSLIST));

    // Otherwise
    else
    {
        // Allocat an internal array
        CHECKHR(hr = HrAlloc((LPVOID *)&m_rList.prgAdr, sizeof(ADDRESSPROPS) * pList->cAdrs));

        // Copy prgPart
        for (i=0; i<pList->cAdrs; i++)
        {
            // Zero Dest
            ZeroMemory(&m_rList.prgAdr[i], sizeof(ADDRESSPROPS));

            // Copy Address Props
            CHECKHR(hr = HrCopyAddressProps(&pList->prgAdr[i], &m_rList.prgAdr[i]));
        }

        // Save Size and State
        m_rList.cAdrs = pList->cAdrs;
    }

    // Save Current Index
    Assert(iAddress < m_rList.cAdrs);
    m_iAddress = iAddress;

    // Assume the Table
    m_pTable = pTable;
    m_pTable->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addressx.h ===
// --------------------------------------------------------------------------------
// AddressX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ADDRESSX_H
#define __ADDRESSX_H

// -------------------------------------------------------------------------------
// Forward Decls
// -------------------------------------------------------------------------------
typedef struct tagADDRESSGROUP *LPADDRESSGROUP;

// -------------------------------------------------------------------------------
// ADDRESSTOKENW
// -------------------------------------------------------------------------------
typedef struct tagADDRESSTOKENW {
    ULONG               cbAlloc;            // Allocated Size
    ULONG               cch;                // Number of Characters
    LPWSTR              psz;                // Pointer to data
    BYTE                rgbScratch[256];    // Scratch Buffer
} ADDRESSTOKENW, *LPADDRESSTOKENW;

// -------------------------------------------------------------------------------
// ADDRESSTOKENA
// -------------------------------------------------------------------------------
typedef struct tagADDRESSTOKENA {
    ULONG               cbAlloc;            // Allocated Size
    ULONG               cch;                // Number of Characters
    LPSTR               psz;                // Pointer to data
    BYTE                rgbScratch[256];    // Scratch Buffer
} ADDRESSTOKENA, *LPADDRESSTOKENA;

// --------------------------------------------------------------------------------
// MIMEADDRESS
// --------------------------------------------------------------------------------
typedef struct tagMIMEADDRESS *LPMIMEADDRESS;
typedef struct tagMIMEADDRESS {
    DWORD           dwAdrType;              // IAP_ADRTYPE: Address Type
    HADDRESS        hThis;                  // IAP_HADDRESS: Handle of this address
    ADDRESSTOKENW   rFriendly;              // IAP_FRIENDLYW: Friendly Name (Unicode)
    ADDRESSTOKENW   rEmail;                 // IAP_EMAIL: Email Address
    LPINETCSETINFO  pCharset;               // IAP_HCHARSET: Charset used to encode pszFriendly
    CERTSTATE       certstate;              // IAP_CERTSTATE: Certificate State
    THUMBBLOB       tbSigning;              // IAP_SIGNING_PRINT: Thumbprint to be used for signing
    THUMBBLOB       tbEncryption;           // IAP_ENCRYPTION_PRINT: Thumbprint to be used for signing
    DWORD           dwCookie;               // IAP_COOKIE: User-defined cookie
    LPADDRESSGROUP  pGroup;                 // Address group
    LPMIMEADDRESS   pPrev;                  // Linked List
    LPMIMEADDRESS   pNext;                  // Linked List
} MIMEADDRESS;

// --------------------------------------------------------------------------------
// MIMEADDRESS Prototypes
// --------------------------------------------------------------------------------
void MimeAddressFree(LPMIMEADDRESS pAddress);
HRESULT HrMimeAddressCopy(LPMIMEADDRESS pSource, LPMIMEADDRESS pDest);
HRESULT HrCopyAddressProps(LPADDRESSPROPS pSource, LPADDRESSPROPS pDest);
void EmptyAddressTokenW(LPADDRESSTOKENW pToken);
void FreeAddressTokenW(LPADDRESSTOKENA pToken);
HRESULT HrSetAddressTokenW(LPCWSTR psz, ULONG cch, LPADDRESSTOKENW pToken);

#endif // __ADDRESSX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\addressx.cpp ===
// --------------------------------------------------------------------------------
// AddressX.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "AddressX.h"
#include "dllmain.h"
#include "internat.h"
#include "mimeapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// EmptyAddressTokenW - Makes sure the pToken is empty
// --------------------------------------------------------------------------------
void EmptyAddressTokenW(LPADDRESSTOKENW pToken)
{
    if (pToken->psz)
        *pToken->psz = L'\0';
    pToken->cch = 0;
}

// --------------------------------------------------------------------------------
// FreeAddressTokenW
// --------------------------------------------------------------------------------
void FreeAddressTokenW(LPADDRESSTOKENW pToken)
{
    if (pToken->psz && pToken->psz != (LPWSTR)pToken->rgbScratch)
        g_pMalloc->Free(pToken->psz);
    ZeroMemory(pToken, sizeof(ADDRESSTOKENW));
}

// --------------------------------------------------------------------------------
// HrSetAddressTokenW
// --------------------------------------------------------------------------------
HRESULT HrSetAddressTokenW(LPCWSTR psz, ULONG cch, LPADDRESSTOKENW pToken)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;
    LPWSTR      pszNew;

    // Invalid Arg
    Assert(psz && psz[cch] == L'\0' && pToken);

    // cbAlloc is big enough
    if ((cch + 1) * sizeof(WCHAR) > pToken->cbAlloc)
    {
        // Use Static
        if (NULL == pToken->psz && ((cch + 1) * sizeof(WCHAR)) < sizeof(pToken->rgbScratch))
        {
            pToken->psz = (LPWSTR)pToken->rgbScratch;
            pToken->cbAlloc = sizeof(pToken->rgbScratch);
        }

        // Otherwise
        else
        {
            // If currently set to scratch, NULL it
            if (pToken->psz == (LPWSTR)pToken->rgbScratch)
            {
                Assert(pToken->cbAlloc == sizeof(pToken->rgbScratch));
                pToken->psz = NULL;
            }

            // Compute Size of new blob
            cbAlloc = ((cch + 1) * sizeof(WCHAR));

            // Realloc New Blob
            CHECKALLOC(pszNew = (LPWSTR)g_pMalloc->Realloc((LPVOID)pToken->psz, cbAlloc));

            // Save
            pToken->psz = pszNew;
            pToken->cbAlloc = cbAlloc;
        }
    }

    // Copy the String
    CopyMemory((LPBYTE)pToken->psz, (LPBYTE)psz, ((cch + 1) * sizeof(WCHAR)));

    // Save the Size
    pToken->cch = cch;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeAddressFree
// --------------------------------------------------------------------------------
void MimeAddressFree(LPMIMEADDRESS pAddress)
{
    Assert(pAddress);
    FreeAddressTokenW(&pAddress->rFriendly);
    FreeAddressTokenW(&pAddress->rEmail);
    SafeMemFree(pAddress->tbSigning.pBlobData);
    SafeMemFree(pAddress->tbEncryption.pBlobData);
    ZeroMemory(pAddress, sizeof(MIMEADDRESS));
}

// --------------------------------------------------------------------------------
// HrCopyAddressData
// --------------------------------------------------------------------------------
HRESULT HrMimeAddressCopy(LPMIMEADDRESS pSource, LPMIMEADDRESS pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Friendly
    if (!FIsEmptyW(pSource->rFriendly.psz))
    {
        CHECKHR(hr = HrSetAddressTokenW(pSource->rFriendly.psz, pSource->rFriendly.cch, &pDest->rFriendly));
    }

    // Email
    if (!FIsEmptyW(pSource->rEmail.psz))
    {
        CHECKHR(hr = HrSetAddressTokenW(pSource->rEmail.psz, pSource->rEmail.cch, &pDest->rEmail));
    }

    // Copy Signature Blob
    if (pSource->tbSigning.pBlobData)
    {
        CHECKHR(hr = HrCopyBlob(&pSource->tbSigning, &pDest->tbSigning));
    }

    // Copy Encryption Blob
    if (pSource->tbEncryption.pBlobData)
    {
        CHECKHR(hr = HrCopyBlob(&pSource->tbEncryption, &pDest->tbEncryption));
    }

    // Save Other Stuff
    pDest->pCharset = pSource->pCharset;
    pDest->dwCookie = pSource->dwCookie;
    pDest->certstate = pSource->certstate;
    pDest->dwAdrType = pSource->dwAdrType;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyAddressProps
// --------------------------------------------------------------------------------
HRESULT HrCopyAddressProps(LPADDRESSPROPS pSource, LPADDRESSPROPS pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_HADDRESS
    if (ISFLAGSET(pSource->dwProps, IAP_HANDLE))
    {
        pDest->hAddress = pSource->hAddress;
        FLAGSET(pDest->dwProps, IAP_HANDLE);
    }

    // IAP_ENCODING
    if (ISFLAGSET(pSource->dwProps, IAP_ENCODING))
    {
        pDest->ietFriendly = pSource->ietFriendly;
        FLAGSET(pDest->dwProps, IAP_ENCODING);
    }

    // IAP_HCHARSET
    if (ISFLAGSET(pSource->dwProps, IAP_CHARSET))
    {
        pDest->hCharset = pSource->hCharset;
        FLAGSET(pDest->dwProps, IAP_CHARSET);
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pSource->dwProps, IAP_ADRTYPE))
    {
        pDest->dwAdrType = pSource->dwAdrType;
        FLAGSET(pDest->dwProps, IAP_ADRTYPE);
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pSource->dwProps, IAP_CERTSTATE))
    {
        pDest->certstate = pSource->certstate;
        FLAGSET(pDest->dwProps, IAP_CERTSTATE);
    }

    // IAP_COOKIE
    if (ISFLAGSET(pSource->dwProps, IAP_COOKIE))
    {
        pDest->dwCookie = pSource->dwCookie;
        FLAGSET(pDest->dwProps, IAP_COOKIE);
    }

    // IAP_FRIENDLYW
    if (ISFLAGSET(pSource->dwProps, IAP_FRIENDLYW))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_FRIENDLYW))
        {
            SafeMemFree(pDest->pszFriendlyW);
            FLAGCLEAR(pDest->dwProps, IAP_FRIENDLYW);
        }

        // Dup
        CHECKALLOC(pDest->pszFriendlyW = PszDupW(pSource->pszFriendlyW));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_FRIENDLYW);
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pSource->dwProps, IAP_FRIENDLY))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_FRIENDLY))
        {
            SafeMemFree(pDest->pszFriendly);
            FLAGCLEAR(pDest->dwProps, IAP_FRIENDLY);
        }

        // Dup
        CHECKALLOC(pDest->pszFriendly = PszDupA(pSource->pszFriendly));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_FRIENDLY);
    }

    // IAP_EMAIL
    if (ISFLAGSET(pSource->dwProps, IAP_EMAIL))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_EMAIL))
        {
            SafeMemFree(pDest->pszEmail);
            FLAGCLEAR(pDest->dwProps, IAP_EMAIL);
        }

        // Dup
        CHECKALLOC(pDest->pszEmail = PszDupA(pSource->pszEmail));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_EMAIL);
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pSource->dwProps, IAP_SIGNING_PRINT))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_SIGNING_PRINT))
        {
            SafeMemFree(pDest->tbSigning.pBlobData);
            pDest->tbSigning.cbSize = 0;
            FLAGCLEAR(pDest->dwProps, IAP_SIGNING_PRINT);
        }

        // Dup
        CHECKHR(hr = HrCopyBlob(&pSource->tbSigning, &pDest->tbSigning));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_SIGNING_PRINT);
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pSource->dwProps, IAP_ENCRYPTION_PRINT))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_ENCRYPTION_PRINT))
        {
            SafeMemFree(pDest->tbEncryption.pBlobData);
            pDest->tbEncryption.cbSize = 0;
            FLAGCLEAR(pDest->dwProps, IAP_ENCRYPTION_PRINT);
        }

        // Dup
        CHECKHR(hr = HrCopyBlob(&pSource->tbEncryption, &pDest->tbEncryption));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_ENCRYPTION_PRINT);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bindstm.h ===
// --------------------------------------------------------------------------------
// BINDSTM.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BINDSTM_H
#define __BINDSTM_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "vstream.h"

// --------------------------------------------------------------------------------
// CBindStream
// --------------------------------------------------------------------------------
class CBindStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBindStream(IStream *pSource);
    ~CBindStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(void HUGEP_16 *, ULONG, ULONG *);
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Write(const void HUGEP_16 *, ULONG, ULONG *) {
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) {
        return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CBindStream Methods
    // -------------------------------------------------------------------------
    void HandsOffSource(void) {
        EnterCriticalSection(&m_cs);
        SafeRelease(m_pSource);
        LeaveCriticalSection(&m_cs);
    }

    // -------------------------------------------------------------------------
    // CBindStream Debug Methods
    // -------------------------------------------------------------------------
#ifdef DEBUG
    void DebugDumpDestStream(LPCSTR pszFile);
#endif

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
#ifdef DEBUG
    void DebugAssertOffset(void);
#endif

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG             m_cRef;            // Reference count
    CVirtualStream   m_cDest;           // The Destination Stream
    IStream         *m_pSource;         // The Source Stream
    DWORD            m_dwDstOffset;     // CBindStream Offset
    DWORD            m_dwSrcOffset;     // Source Offset
#ifdef DEBUG
    IStream         *m_pDebug;
#endif
    CRITICAL_SECTION m_cs;              // Critical Section for m_pStream
};

#endif // __BINDSTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\binhex.h ===
// --------------------------------------------------------------------------------
// Binxhex.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BINHEX_H
#define __BINHEX_H

// ---------------------------------------------------------------------------------------
// MACBINARY Header
// ---------------------------------------------------------------------------------------

// Byte packing
#pragma pack(1)
typedef struct
{
    BYTE    bMustBeZero1;
    BYTE    cchFileName;
    char    rgchFileName[63];
    DWORD   dwType;
    DWORD   dwCreator;
    BYTE    bFinderFlags;
    BYTE    bMustBeZero2;
    WORD    xIcon;
    WORD    yIcon;
    WORD    wFileID;
    BYTE    fProtected;
    BYTE    bMustBeZero3;
    DWORD   lcbDataFork;
    DWORD   lcbResourceFork;
    DWORD   dwCreationDate;
    DWORD   dwModificationDate;
    union
    {
        struct
        {
            WORD    cbGetInfo;
            BYTE    bFinderFlags2;
            BYTE    wGap[14];
            DWORD   lcbUnpacked;
            WORD    cbSecondHeader;
            BYTE    bVerMacBin2;
            BYTE    bMinVerMacBin2;
            WORD    wCRC;
        };
        struct
        {
            WORD    wDummy;
            BYTE    bByte101ToByte125[25];

        };
        BYTE    Reserved[27];
    };
    WORD    wMachineID;
} MACBINARY, *LPMACBINARY;
#pragma pack()

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
// Non Mac Creator Types

typedef struct _screatortype
{
    char  szCreator[5];
    char  szType[5];
} sCreatorType;

extern sCreatorType * g_lpCreatorTypes;

// --------------------------------------------------------------------------------
// MAPI Types
// --------------------------------------------------------------------------------
typedef ULONG		 CB;		//	Count of bytes
typedef ULONG		 C;		    //	Count
typedef LPBYTE		 PB;		//	pointer to bytes

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define BINHEX_INVALID              0x7f
#define BINHEX_REPEAT               0x90
#define XXXX                        BINHEX_INVALID
#define MIN(a,b)	                ( (a) > (b) ? (b) : (a) )
#define hrSuccess                   S_OK

// Uncomment for Binhex debugging support
// #define BINHEX_TRACE 1

#if defined(_X86_) || defined(_AMD64_) || defined(_IA64_)

// host is little endian

#define NATIVE_LONG_FROM_BIG(lpuch)  ( (*(unsigned char *) (lpuch))      << 24 \
                                     | (*(unsigned char *)((lpuch) + 1)) << 16 \
                                     | (*(unsigned char *)((lpuch) + 2)) << 8  \
                                     | (*(unsigned char *)((lpuch) + 3)))
#elif defined(_MPPC_)
#define NATIVE_LONG_FROM_BIG(lpuch)  (*(unsigned long *) (lpuch))
#else
    #error "Must define NATIVE_LONG_FROM_BIG for this architecture!"
#endif

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
const CB cbLineLengthUnlimited	    = 0;
const CB cbMIN_BINHEX_HEADER_SIZE   = 21;
const WORD  wZero                   = 0;

// --------------------------------------------------------------------------------
// g_rgchBinHex8to6
// --------------------------------------------------------------------------------
const CHAR g_rgchBinHex8to6[] =
    "!\"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";

// --------------------------------------------------------------------------------
// g_rgchBinHex6to8
// --------------------------------------------------------------------------------
const CHAR g_rgchBinHex6to8[] =
{
    // 0x00

    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x20

    XXXX, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, XXXX, XXXX,

    // 0x30

    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, XXXX,
    0x14, 0x15, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x40

    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
    0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, XXXX,

    // 0x50

    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, XXXX,
    0x2C, 0x2D, 0x2E, 0x2F, XXXX, XXXX, XXXX, XXXX,

    // 0x60

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, XXXX,
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, XXXX, XXXX,

    // 0x70

    0x3D, 0x3E, 0x3F, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x80

    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
};

// --------------------------------------------------------------------------------
// BINHEX post processing data
// --------------------------------------------------------------------------------
typedef struct _sbinhexreturndata
{
	MACBINARY 	    macbinHdr;
	BOOL		    fIsMacFile;
} BINHEXRETDATA;

//-----------------------------------------------------------------------------
// Apple Macintosh BinHex 4.0 encoder class.
//-----------------------------------------------------------------------------

class CBinhexEncoder
{
public:
    CBinhexEncoder(void);
    ~CBinhexEncoder(void);

    HRESULT HrConfig(IN CB cbLineLength, IN C cMaxLines, IN void * pvParms);
    HRESULT HrEmit(IN PB pbRead, IN OUT CB * pcbRead, OUT PB pbWrite, IN OUT CB * pcbWrite);

private:

    // Binhex's the supplied buffer into m_pbWrite, modified m_cbProduced

    HRESULT HrBinHexBuffer( LPBYTE lpbIn, CB cbIn, CB * lpcbConsumed );

    // Binhex byte and outputs to m_pbWrite

    HRESULT HrBinHexByte( BYTE b );

	// Did we generate the maximum number of output lines?
	virtual	BOOL	FMaxLinesReached(void)
		{ return (m_cMaxLines > 0 && m_cLines >= m_cMaxLines); }

	// Are we operating under restricted line length?
	virtual	BOOL	FLineLengthLimited(void)
		{ return m_cbLineLength != cbLineLengthUnlimited; }

    LPMACBINARY m_lpmacbinHdr;              // pointer to passed in Mac Binary header
    ULONG       m_ulAccum;                  // acculator to store chars when converting from 6bytes to 8 bytes.
    ULONG       m_cAccum;                   // count of characters accumulated (0 - 3)
    BYTE        m_bRepeat;                  // repeat char
    CB          m_cbRepeat;                 // amount to repeat
    BYTE        m_bPrev;                    // Previous byte processed
    BYTE        m_bCurr;                    // current byte being processed;
    WORD        m_wCRC;                     // CRC used for data or Resource forks
    CB          m_cbLine;                   // Number of chars currently encoded for a line of output
    CB          m_cbFork;                   // Size of fork to process
    CB          m_cbLeftInFork;             // How much of current fork we've processed.
    CB          m_cbProduced;               // number of chars produces after decoding and RLE expansion
    CB          m_cbLeftInOutputBuffer;     // number of bytes left in passed in Output buffer
    CB          m_cbConsumed;               // number of bytes used from passed in input buffer
    CB          m_cbLeftInInputBuffer;      // number of bytes in passed in Input buffer
    CB          m_cbWrite;                  // number of bytes written out to output buffer
    LPBYTE      m_pbWrite;                  // pointer to output buffer.
    BOOL        m_fHandledx90;              // flag to preserve literal x90 processing across buffer resets.
    CB          m_cbPad;                    // byte count of padding across buffer refreshes.
    CB          m_cbLineLength;             // Maximum length of output line
    BOOL        m_fConfigured;              // Has HrConfig been called successfully?
    CB		    m_cbLeftOnLastLine;	        // Number of bytes left on last line of output
    C		    m_cMaxLines;		        // Maximum number of output lines requested
    C		    m_cLines;			        // Lines of output generated

    // Encoding states

    enum _BinHexStateEnc
    {
        sHEADER, sDATA, sRESOURCE, sEND
    } m_eBinHexStateEnc;

#if defined (DEBUG) && defined (BINHEX_TRACE)
    LPSTREAM m_lpstreamEncodeRLE;           // trace of Run Length encoding of the raw source data
    LPSTREAM m_lpstreamEncodeRAW;           // trace of raw data before RLE has been applied
#endif
};

#endif // __BINHEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bindstm.cpp ===
// --------------------------------------------------------------------------------
// BINDSTM.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bindstm.h"
#include "demand.h"

#ifdef DEBUG
//#define DEBUG_DUMP_SOURCE
#endif

// --------------------------------------------------------------------------------
// CBindStream::CBindStream
// --------------------------------------------------------------------------------
CBindStream::CBindStream(IStream *pSource) : m_pSource(pSource)
{
    Assert(pSource);
    m_cRef = 1;
    m_pSource->AddRef();
    m_dwDstOffset = 0;
    m_dwSrcOffset = 0;
#ifdef DEBUG_DUMP_SOURCE
    OpenFileStream("c:\\bindsrc.txt", CREATE_ALWAYS, GENERIC_WRITE, &m_pDebug);
#endif
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBindStream::CBindStream
// --------------------------------------------------------------------------------
CBindStream::~CBindStream(void)
{
#ifdef DEBUG_DUMP_SOURCE
    m_pDebug->Commit(STGC_DEFAULT);
    m_pDebug->Release();
#endif
    SafeRelease(m_pSource);
    DeleteCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CBindStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CBindStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBindStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindStream::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBindStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// CBindStream::DebugAssertOffset
// --------------------------------------------------------------------------------
void CBindStream::DebugAssertOffset(void)
{
    // Locals
    DWORD           dw;
    ULARGE_INTEGER  uliSize;
    ULARGE_INTEGER  uliOffset;

    // Validate the size, sizeof m_cDest should always be equal to m_dwSrcOffset
    m_cDest.QueryStat(&uliOffset, &uliSize);

    // Assert Offset
    Assert(uliOffset.HighPart == 0 && m_dwDstOffset == uliOffset.LowPart);

    // Assert Size
    Assert(uliSize.HighPart == 0 && m_dwSrcOffset == uliSize.LowPart);
}

// --------------------------------------------------------------------------------
// CBindStream::DebugDumpDestStream
// --------------------------------------------------------------------------------
void CBindStream::DebugDumpDestStream(LPCSTR pszFile)
{
    // Locals
    IStream *pStream;

    // Open Stream
    if (SUCCEEDED(OpenFileStream((LPSTR)pszFile, CREATE_ALWAYS, GENERIC_WRITE, &pStream)))
    {
        HrRewindStream(&m_cDest);
        HrCopyStream(&m_cDest, pStream, NULL);
        pStream->Commit(STGC_DEFAULT);
        pStream->Release();
    }
    else
        Assert(FALSE);

    // Reset Position of both stream
    HrStreamSeekSet(&m_cDest, m_dwDstOffset);
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// CBindStream::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Read(void HUGEP_16 *pv, ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrRead=S_OK;
    ULONG           cbReadDst=0;
    ULONG           cbReadSrc=0;
    ULONG           cbGet;

    // Invalid Arg
    Assert(pv);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Destination offset is less than source offset
    if (m_dwDstOffset < m_dwSrcOffset)
    {
        // Compute amount to get
        cbGet = min(cb, m_dwSrcOffset - m_dwDstOffset);

        // Validate the offsets
#ifdef DEBUG
        DebugAssertOffset();
#endif

        // Read the amount from the destination
        CHECKHR(hr = m_cDest.Read(pv, cbGet, &cbReadDst));

        // Increment offset
        m_dwDstOffset += cbReadDst;
    }

    // If we didn't read cb, try to read some more
    if (cbReadDst < cb && m_pSource)
    {
        // Compute amount to get
        cbGet = cb - cbReadDst;

        // Read the amount from the source
        hrRead = m_pSource->Read((LPBYTE)pv + cbReadDst, cbGet, &cbReadSrc);

        // Raid-43408: MHTML: images don't load on first load over http, but refresh makes them appear
        if (FAILED(hrRead))
        {
            // If I got an E_PENDING with data read, don't fail yet
            if (E_PENDING == hrRead && cbReadSrc > 0)
                hrRead = S_OK;

            // Otherwise, we really failed, might still be an E_PENDING
            else
            {
                TrapError(hrRead);
                goto exit;
            }
        }

        // Debug Dumping
#ifdef DEBUG_DUMP_SOURCE
        SideAssert(SUCCEEDED(m_pDebug->Write(pv, cbReadSrc + cbReadDst, NULL)));
#endif
        // If we read something
        if (cbReadSrc)
        {
            // Increment source offset
            m_dwSrcOffset += cbReadSrc;

            // Write to Dest
            CHECKHR(hr = m_cDest.Write((LPBYTE)pv + cbReadDst, cbReadSrc, NULL));

            // Update Dest offset
            m_dwDstOffset += cbReadSrc;

            // Validate the offsets
#ifdef DEBUG
            DebugAssertOffset();
#endif
        }

        // Check
        Assert(m_dwDstOffset == m_dwSrcOffset);
    }

    // Return pcbRead
    if (pcbRead)
        *pcbRead = cbReadDst + cbReadSrc;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return FAILED(hr) ? hr : hrRead;
}

// --------------------------------------------------------------------------------
// CBindStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliOffset;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Seek m_cDest
    CHECKHR(hr = m_cDest.Seek(dlibMove, dwOrigin, plibNew));

    // Get the current offset
    m_cDest.QueryStat(&uliOffset, NULL);

    // Update m_dwDstOffset
    m_dwDstOffset = uliOffset.LowPart;

    // Should be less than m_dwSrcOffset
    Assert(m_dwDstOffset <= m_dwSrcOffset);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBindStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Stat(STATSTG *pStat, DWORD dw)
{
    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // As long as we have m_pSource, the size is pending
    if (m_pSource)
        return TrapError(E_PENDING);

    // ZeroInit
    ZeroMemory(pStat, sizeof(STATSTG));

    // Fill pStat
    pStat->type = STGTY_STREAM;
    m_cDest.QueryStat(NULL, &pStat->cbSize);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\binhex.cpp ===
// --------------------------------------------------------------------------------
// Binxhex.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
//
// Copied from \\tdsrc\src1911\mapi\src\imail2\decoder.cpp
// Copied from \\tdsrc\src1911\mapi\src\imail2\encoder.cpp
// Copied from \\tdsrc\src1911\mapi\src\imail2\_encoder.h
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "binhex.h"
#include <shlwapi.h>

// --------------------------------------------------------------------------------
// Module data
// --------------------------------------------------------------------------------
#ifdef MAC
const CHAR szBINHEXHDRLINE[] = "(This file must be converted with BinHex 4.0)\n\r\n\r";
#else   // !MAC
const CHAR szBINHEXHDRLINE[] = "(This file must be converted with BinHex 4.0)\r\n\r\n";
#endif  // MAC
const ULONG cbBINHEXHDRLINE = lstrlen( szBINHEXHDRLINE );
static BOOL g_bCreatorTypeInit = FALSE;    // TRUE ->array initialized
sCreatorType * g_lpCreatorTypes    = NULL;     // ptr.to Creator-Type pairs
static int g_cCreatorTypes     = 0;        // # of Creator-Type pairs

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void CalcCRC16(LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC);
BOOL bIsMacFile(DWORD dwCreator, DWORD dwType);
VOID ReadCreatorTypes(void);

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::CBinhexEncoder
//
// Description:
//                  Ctor
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
CBinhexEncoder::CBinhexEncoder(void)
{
	m_fConfigured = FALSE;
    m_cbLineLength = cbLineLengthUnlimited;
    m_cbLeftOnLastLine = m_cbLineLength;
    m_cMaxLines = 0;
    m_cLines = 0;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::~CBinhexEncoder
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
CBinhexEncoder::~CBinhexEncoder( void )
{
#if defined (DEBUG) && defined (BINHEX_TRACE)

    if ( m_lpstreamEncodeRLE )
    {
        m_lpstreamEncodeRLE->Commit( 0 );
        m_lpstreamEncodeRLE->Release();
    }

    if ( m_lpstreamEncodeRAW )
    {
        m_lpstreamEncodeRAW->Commit( 0 );
        m_lpstreamEncodeRAW->Release();
    }
#endif
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrConfig
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrConfig( IN CB cbLineLength, IN C cMaxLines,
        IN void * pvParms )
{
    // Is this a repeat call?

    if (m_fConfigured)
    {
        return ERROR_ALREADY_INITIALIZED;
    }

    // Objects of this class may have pvParms point to a various additional
    // configuration values to consider when encoding.

    if ( pvParms == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_cbLineLength          = cbLineLength;
    m_lpmacbinHdr           = (LPMACBINARY)pvParms;
    m_ulAccum               = 0;
    m_cAccum                = 0;
    m_cbRepeat              = 0;
    m_bRepeat               = BINHEX_INVALID;
    m_wCRC                  = 0;
    m_cbFork                = 0;
    m_cbLeftInFork          = 0;
    m_eBinHexStateEnc       = sHEADER;
    m_cbProduced            = 0;
    m_cbConsumed            = 0;
    m_pbWrite               = NULL;
    m_cbLeftInOutputBuffer  = 0;
    m_cbLeftInInputBuffer   = 0;
    m_bPrev                 = BINHEX_INVALID;
    m_cbWrite               = 0;
    m_cbLine                = 0;
    m_fHandledx90           = FALSE;
    m_cbPad                 = 0;

#if defined (DEBUG) && defined (BINHEX_TRACE)
{
    CHAR        szFilePath[MAX_PATH];
    CHAR        szPath[MAX_PATH];
    ULONG       ulDirLen            = 0;
    HRESULT     hr                  = hrSuccess;

    ulDirLen = GetPrivateProfileString( "IMAIL2 ITP",
                                        "InboundFilePath",
                                        "",
                                        (LPSTR) szFilePath,
                                        sizeof( szFilePath ),
                                        "mapidbg.ini");

    if ( ulDirLen ==  0 )
    {
        // Default to %TEMP%\IMAIL

        ulDirLen = GetTempPath( sizeof( szFilePath ), szFilePath );

        AssertSz( ulDirLen < sizeof( szFilePath), "Temp directory name too long" );

        StrCatBuff(szFilePath, "imail", ARRAYSIZE(szFilePath));
        ulDirLen = lstrlen(szFilePath);
    }

    // Open stream on file for input file

    StrCatBuff(szFilePath, "\\", ARRAYSIZE(szFilePath));
    StrCpyN( szPath, szFilePath, ARRAYSIZE(szPath));
    StrCatBuff( szFilePath,  "enc_rle.rpt", ARRAYSIZE(szFilePath));

    hr = OpenStreamOnFile( MAPIAllocateBuffer, MAPIFreeBuffer,
            STGM_READWRITE | STGM_CREATE,
            szFilePath, NULL, &m_lpstreamEncodeRLE );

    if ( hr )
        AssertSz( FALSE, "Debug encode stream failed to initialize\n" );

    StrCpyN (szFilePath, szPath, ARRAYSIZE(szFilePath));
    StrCatBuff(szFilePath, "enc_raw.rpt", ARRAYSIZE(szFilePath));

    hr = OpenStreamOnFile( MAPIAllocateBuffer, MAPIFreeBuffer,
            STGM_READWRITE | STGM_CREATE,
            szFilePath, NULL, &m_lpstreamEncodeRAW );

    if ( hr )
        AssertSz( FALSE, "Debug encode stream failed to initialize\n" );
}
#endif

    m_fConfigured   = fTrue;

    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrEmit
// Description:
//
// Parameters:
// Returns:
// Effects:
//
// Notes:
//      Handle Data Fork
//      Resource fork.
//
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrEmit( IN PB pbRead, IN OUT CB * pcbRead, OUT PB pbWrite,
        IN OUT CB * pcbWrite )
{
    HRESULT     hr                      = ERROR_SUCCESS;
    CB          cbHeader                = 0;
    CB          cbToProcess;
    CB          cbInputCheckPoint       = 0;
    CB          cbOut;
    CB          cb;
    BYTE        rgbHeader[ cbMIN_BINHEX_HEADER_SIZE + 64 ];

    m_cbConsumed            = 0;
    m_cbProduced            = 0;
    m_cbLeftInOutputBuffer  = 0;
    m_cbLeftInInputBuffer   = 0;


    // Have to be initialized first

    if ( !m_fConfigured )
    {
        return ERROR_BAD_COMMAND;
    }

    // Handle common 'bad parameter' errors

    if ( !pbRead || !pbWrite || !pcbRead || !pcbWrite )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Repeated calls after maximum number of output lines were generated
    // will not go through

    if ( FMaxLinesReached() )
    {
        *pcbRead = *pcbWrite = 0;
        return ERROR_SUCCESS;
    }

    // If line length is unlimited, set m_cbLeftOnLastLine to be equal to
    // the length of the input buffer

    if ( !FLineLengthLimited() )
    {
        m_cbLeftOnLastLine = *pcbWrite;
    }

    m_pbWrite = pbWrite;
    m_cbWrite = *pcbWrite;

    while ( TRUE )
    {
        m_cbLeftInInputBuffer  = *pcbRead - m_cbConsumed;
        m_cbLeftInOutputBuffer = *pcbWrite - m_cbProduced;

        // If we have room in the output buffer keep going if in sEnd and no input left

        if ( 0 == m_cbLeftInOutputBuffer || (0 == m_cbLeftInInputBuffer && sEND != m_eBinHexStateEnc) )
        {
                goto Cleanup;
        }

        switch ( m_eBinHexStateEnc )
        {
            case sHEADER:
            {
                // Output BinHex Header line

                CopyMemory( pbWrite, szBINHEXHDRLINE, cbBINHEXHDRLINE );
                m_cbProduced += cbBINHEXHDRLINE;
                m_cLines += 2;

                // Output leading ':'

                m_pbWrite[m_cbProduced++] = ':';
                ++m_cbLine;

                // Output MACBIN Header; Header filename length

                rgbHeader[cbHeader++] = m_lpmacbinHdr->cchFileName;

                // Header filename

                CopyMemory( rgbHeader + cbHeader, m_lpmacbinHdr->rgchFileName, m_lpmacbinHdr->cchFileName );
                cbHeader += m_lpmacbinHdr->cchFileName;

                // Null terminate filename

                rgbHeader[cbHeader++] = '\0';

                // Macfile TYPE

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->dwType, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Macfile CREATOR

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->dwCreator, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Macfile FLAGS

                rgbHeader[cbHeader++] = m_lpmacbinHdr->bFinderFlags;
                rgbHeader[cbHeader++] = m_lpmacbinHdr->bFinderFlags2;

                // Macfile Fork lengths

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->lcbDataFork, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->lcbResourceFork, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Calculate the binhex header CRC

                CalcCRC16( rgbHeader, cbHeader, &m_wCRC );
                CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                // BinHex the header into pbWrite.  The initial assumption is that
                // the buffer is going to big enough to encode the header.
                // Output goes into m_pbWrite.

                cbOut = 0;
                hr = HrBinHexBuffer( rgbHeader, cbHeader, &cbOut );

                // setup for the data fork

                m_eBinHexStateEnc = sDATA;
                m_cbFork = NATIVE_LONG_FROM_BIG( (LPBYTE)&m_lpmacbinHdr->lcbDataFork );
                m_cbLeftInFork = m_cbFork;
                m_wCRC = 0;
            }

                break;

            case sDATA:
            {
                // determine how much we can process

                cbToProcess = m_cbLeftInFork < m_cbLeftInInputBuffer ? m_cbLeftInFork : m_cbLeftInInputBuffer;
                cbInputCheckPoint = m_cbConsumed;

                hr = HrBinHexBuffer( pbRead + cbInputCheckPoint, cbToProcess, &m_cbConsumed );

                CalcCRC16( pbRead + cbInputCheckPoint, m_cbConsumed - cbInputCheckPoint, &m_wCRC );

                m_cbLeftInFork -= m_cbConsumed - cbInputCheckPoint;

                // flush output buffer

                if ( hr )
                    goto Cleanup;

                if ( !m_cbLeftInFork )
                {
                    // write out the last CRC

                    CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                    cbHeader = 0;

                    rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                    rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                    cbOut = 0;
                    hr = HrBinHexBuffer( rgbHeader, 2, &cbOut );

                    // discard padding

                    if ( m_cbFork % 128 )
                    {
                        cb = 128 - ( m_cbFork % 128 );

                        if ( *pcbRead - m_cbConsumed < cb )
                        {
                            DebugTrace( "Note: Support refilling input buffer to remove padding for Data\n" );

                            // need to pull in more data

                            m_cbPad = cb - (*pcbRead - m_cbConsumed);
                            m_cbConsumed -= (*pcbRead - m_cbConsumed);
                        }
                        else
                        {
                            m_cbConsumed = cb;
                        }
                    }

                    // Set up for resource for if there is one and  reset counters

                    m_cbFork = NATIVE_LONG_FROM_BIG( (LPBYTE)&m_lpmacbinHdr->lcbResourceFork );
                    m_cbLeftInFork = m_cbFork;

                    if ( !m_cbFork )
                    {
                        // handle 0 byte resource fork

                        m_eBinHexStateEnc = sEND;

                        // write out crc for 0 length

                        cbOut = 0;
                        hr = HrBinHexBuffer( (LPBYTE)&wZero, sizeof(WORD), &cbOut );
                    }
                    else
                    {
                        m_eBinHexStateEnc = sRESOURCE;
                    }

                    m_wCRC = 0;
                }
            }
                break;

            case sRESOURCE:
            {
                if ( m_cbPad )
                {
                    m_cbConsumed -= m_cbPad;
                    m_cbPad = 0;
                }

                // determine how much we can process

                cbToProcess = m_cbLeftInFork < m_cbLeftInInputBuffer ? m_cbLeftInFork : m_cbLeftInInputBuffer;
                cbInputCheckPoint = m_cbConsumed;

                hr = HrBinHexBuffer( pbRead + cbInputCheckPoint, cbToProcess, &m_cbConsumed );

                CalcCRC16( pbRead + cbInputCheckPoint, m_cbConsumed - cbInputCheckPoint, &m_wCRC );

                m_cbLeftInFork -= m_cbConsumed - cbInputCheckPoint;

                // flush output buffer

                if ( hr )
                    goto Cleanup;

                if ( !m_cbLeftInFork )
                {
                    // write out the last CRC

                    CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                    cbHeader = 0;

                    rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                    rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                    cbOut = 0;
                    hr = HrBinHexBuffer( rgbHeader, 2, &cbOut );

                    // discard padding

                    if ( m_cbFork % 128 )
                    {
                        cb = 128 - ( m_cbFork % 128 );

                        if ( *pcbRead - m_cbConsumed < cb )
                        {
                            DebugTrace( "Note: Support refilling input buffer to remove padding for Resource\n" );

                            // need to pull in more data

                            m_cbPad = cb - (*pcbRead - m_cbConsumed);
                            m_cbConsumed -= (*pcbRead - m_cbConsumed);
                        }
                        else
                        {
                            m_cbConsumed = cb;
                        }
                    }

                    // set up to terminate

                    m_eBinHexStateEnc = sEND;
                }
            }
                break;

            case sEND:
            {
                if ( m_cbPad )
                {
                    m_cbConsumed -= m_cbPad;
                    m_cbPad = 0;
                }

                if ( (*pcbWrite - m_cbProduced) == 0 )
                    break;

                // flush out any repeated chars

                if ( m_cbRepeat )
                {
                    if ( m_cbRepeat > 1 )
                    {
                        // bump up the repeat count so it reflects actual number of chars to repeat.

                        m_cbRepeat++;

                        // encode the repeat code char
                        // note that we've already emitted the char that we're supplying
                        // the repeat info for.

                        hr = HrBinHexByte( BINHEX_REPEAT );
                        m_bPrev = BINHEX_REPEAT;

                        Assert( m_cbRepeat <= 255 );

                        // encode repeat count

                        hr = HrBinHexByte( (BYTE)(m_cbRepeat) );
                        m_bPrev = (BYTE)(m_cbRepeat);
                    }
                    else
                    {
                        hr = HrBinHexByte( m_bRepeat );
                        m_bPrev = m_bRepeat;
                    }
                }

                // check to see if we have bits in the accumulator

                if ( m_cAccum )
                {
                    switch( m_cAccum )
                    {
                        case 1:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x03) << 4)];
                            break;

                        case 2:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x0f) << 2)];
                            break;

                        case 3:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[m_bCurr & 0x3f];
                            break;

                        default:
                            AssertSz( FALSE, "HrBinHexByte: bad shift state\n" );
                            hr = ERROR_INVALID_PARAMETER;
                            goto Cleanup;
                    }
                }

                // tack on terminating ':'

                m_pbWrite[m_cbProduced++] = ':';
                m_cbConsumed = *pcbRead;

                // probably not so we would have to flush the
                // bits out.

                goto Cleanup;
            }
        }
    }

Cleanup:

    if (hr == ERROR_SUCCESS || hr == ERROR_MORE_DATA)
    {
        // Check that at least some processing was done.
        // Also this error is returned if we've exhausted the output
        // buffer.

        if ( (m_cbProduced == 0) || (m_cbLeftInInputBuffer > m_cbLeftInOutputBuffer)
            || (0 == m_cbLeftInOutputBuffer && sEND == m_eBinHexStateEnc) )
        {
            hr = ERROR_INSUFFICIENT_BUFFER;
        }
        else if ( m_cbConsumed < *pcbRead )
        {
            // Was all input processed?
            // Note that it is okay to encode only part of the input buffer
            // if maximum number of output lines was exceeded.

            hr = ERROR_MORE_DATA;
        }
    }

    // Report the new sizes to the caller.

    Assert( m_cbConsumed <= *pcbRead );
    Assert( m_cbProduced <= *pcbWrite );

    *pcbRead  = m_cbConsumed;
    *pcbWrite = m_cbProduced;

    return hr;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrBinHexBuffer
//
// Description:
//                  Output goes into m_pbWrite
//
// Parameters:
// Returns:
// Effects:
// Notes:
//
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrBinHexBuffer( IN LPBYTE lpbIn, IN CB cbIn, CB * lpcbConsumed )
{
    HRESULT     hr          = ERROR_SUCCESS;
    BOOL        fEndRepeat  = FALSE;
    CB          cbInUsed        = 0;

#if defined (DEBUG) && defined (BINHEX_TRACE)
    CB          cbOrigCbIn = cbIn;
#endif

    while ( cbIn && m_cbProduced + 5 < m_cbWrite )
    {
        // process the next char in input buffer

        m_bCurr = lpbIn[cbInUsed++];
        --cbIn;

        // check to see if we've seen this char before.  Don't repeat
        // if we just added a literal 0x90.

        if ( m_bCurr == m_bPrev && !m_fHandledx90 )
        {
            // m_cbRepeat is the count of  repeat chars after the initial char.
            // e.g., if there are two repeating chars, m_cbRepeat will be 1.
            // Note that we've already emitted the char after which to add the repeat
            // code and count.

            if ( m_cbRepeat < 254 )
            {
                m_cbRepeat++;
                m_bRepeat = m_bCurr;
                continue;
            }
        }

        m_fHandledx90 = FALSE;

        // we were counting repeating characters and the run stopped.

        if ( m_cbRepeat > 1 )
        {
            // set up to emit the run length encoding

            fEndRepeat = TRUE;
        }

        // Are we in repeat mode...

        if ( m_cbRepeat > 1 && fEndRepeat == TRUE )
        {
            // bump up the repeat count so it reflects actual number of chars to repeat.

            m_cbRepeat++;

            // if we're repeating 0x90 tack on the trailing 0x00

            if ( m_bRepeat == BINHEX_REPEAT )
            {
                hr = HrBinHexByte( '\0' );
            }

            // encode the repeat code char
            // note that we've already emitted the char that we're supplying
            // the repeat info for.

            hr = HrBinHexByte( BINHEX_REPEAT );

            Assert( m_cbRepeat <= 255 );

            // encode repeat count

            hr = HrBinHexByte( (BYTE)(m_cbRepeat) );

            fEndRepeat = FALSE;
            m_cbRepeat = 0;
        }
        else if ( m_cbRepeat )      // check if we've got two chars to encode.
        {
            // encode the one char since we've already emitted
            // the first one.

            hr = HrBinHexByte( m_bRepeat );

            if ( m_bRepeat == BINHEX_REPEAT )
            {
                hr = HrBinHexByte( '\0' );
            }

            m_cbRepeat = 0;
        }

        // special handling for 0x90 chars in stream but 0x90 can repeat

        if ( m_bCurr == BINHEX_REPEAT && m_bPrev != BINHEX_REPEAT )
        {
            hr = HrBinHexByte( BINHEX_REPEAT );

            hr = HrBinHexByte( '\0' );

            m_fHandledx90 = TRUE;

            continue;
        }

        // encode the char

        hr = HrBinHexByte( m_bCurr );

        if ( hr )
            goto exit;
    }

    // Check if we filled the output buffer

    if ( cbIn && m_cbProduced + 5 >= m_cbWrite )
    {
        hr = ERROR_INSUFFICIENT_BUFFER;
    }

exit:

#if defined (DEBUG) && defined (BINHEX_TRACE)
    m_lpstreamEncodeRAW->Write( lpbIn, cbOrigCbIn - cbIn, NULL );
#endif

    *lpcbConsumed += cbInUsed;

    return hr;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrBinHexByte
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrBinHexByte( IN BYTE b )
{
    HRESULT     hr      = ERROR_SUCCESS;

#if defined (DEBUG) & defined (BINHEX_TRACE)
    hr = m_lpstreamEncodeRLE->Write( &b, 1, NULL );
#endif

    switch( m_cAccum++ )
    {
        case 0:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[b >> 2];
            ++m_cbLine;
            break;

        case 1:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x03) << 4) | (b >> 4)];
            ++m_cbLine;
            break;

        case 2:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x0f) << 2) | (b >> 6)];
            ++m_cbLine;

            if ( m_cbLine >= 64 )
            {
                m_pbWrite[m_cbProduced++] = chCR;
                m_pbWrite[m_cbProduced++] = chLF;
                m_cbLine = 0;
                ++m_cLines;
            }

            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[b & 0x3f];
            ++m_cbLine;
            m_cAccum = 0;
            break;

        default:
            AssertSz( FALSE, "HrBinHexByte: bad shift state\n" );
            hr = ERROR_INVALID_PARAMETER;
            goto exit;
    }

    if ( m_cbLine >= 64 )
    {
        m_pbWrite[m_cbProduced++] = chCR;
        m_pbWrite[m_cbProduced++] = chLF;
        m_cbLine = 0;
        ++m_cLines;
    }

    m_bPrev = b;

exit:

    return hr;
}

//-----------------------------------------------------------------------------
//
//  CBinhexDecoder class implementation
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Name:            CalcCRC16
// Description:
//                      Used to calculate a 16 bit CRC using the
//                      CCITT polynomial 0x1021.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:7/30/1996
//-----------------------------------------------------------------------------
void CalcCRC16( LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC )
{
    LPBYTE  lpb;
    BYTE    b;
    WORD    uCRC;
    WORD    fWrap;
    ULONG   i;

    uCRC = *wCRC;

    for ( lpb = lpbBuff; lpb < lpbBuff + cBuff; lpb++ )
    {
        b = *lpb;

        for ( i = 0; i < 8; i++ )
        {
            fWrap = uCRC & 0x8000;
            uCRC = (uCRC << 1) | (b >> 7);

            if ( fWrap )
            {
                uCRC = uCRC ^ 0x1021;
            }

            b = b << 1;
        }
    }

    *wCRC = uCRC;
}

//-----------------------------------------------------------------------------
// Name:            bIsMacFile
// Description:
//
// Parameters:
// Returns:
//                  FALSE: if the given dwCreator/dwType matches one of the
//                  pairs in g_lpCreatorTypes;
//
//                  TRUE:  otherwise
//
// Effects:
// Notes:
// Revision:
//                  Initial:10/15/1996
//-----------------------------------------------------------------------------
BOOL bIsMacFile(DWORD dwCreator, DWORD dwType)
{
    BOOL    bRet            = TRUE;
    int     i;
    char    szCreator[5]    = { 0 };
    char    szType[5]       = { 0 };

    if ( dwType == 0 && dwCreator == 0 )
    {
        bRet = FALSE;
        goto exit;
    }

    if ( g_bCreatorTypeInit != TRUE )
    {
        ReadCreatorTypes();
    }

    if ( g_lpCreatorTypes == NULL )
        goto exit;

    // Convert dwCreator & dwType to strings

    CopyMemory( szCreator, &dwCreator, 4 );
    CopyMemory( szType, &dwType, 4 );

    for ( i = 0; i < g_cCreatorTypes; i ++ )
    {
        if ( g_lpCreatorTypes[i].szCreator[0] == 0 && g_lpCreatorTypes[i].szType[0] == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if ( g_lpCreatorTypes[i].szCreator[0] == 0 && lstrcmpi( g_lpCreatorTypes[i].szType, szType ) == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if( g_lpCreatorTypes[i].szType[0] == 0 && lstrcmpi( g_lpCreatorTypes[i].szCreator, szCreator ) == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if( lstrcmpi( g_lpCreatorTypes[i].szCreator, szCreator ) == 0 && lstrcmpi( g_lpCreatorTypes[i].szType, szType  ) == 0 )
        {
            bRet = FALSE;
            break;
        }
    }

exit:
    return bRet ;
}

//-----------------------------------------------------------------------------
// Name:            ReadCreatorTypes
//
// Description:
//
//              Read "NonMacCreatorTypes" registry key (REG_MULTI_SZ type)
//              from the registry & build an array of Creator-Type pairs
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:10/15/1996
//-----------------------------------------------------------------------------
VOID ReadCreatorTypes( VOID )
{
#ifdef MAC
    g_bCreatorTypeInit = TRUE;
#else   // !MAC
    DWORD   dwStatus;
    DWORD   dwType;
    DWORD   cbData;
    char *  lpData      = NULL;
    char *  lpCurrent   = NULL;
    char *  lpNext      = NULL;
    int     i;
    LONG    lRet;
    HKEY    hKey = 0;
    SCODE   sc          = S_OK;

    g_bCreatorTypeInit = TRUE;

    // Open IMC parameter registry

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersSystem\\InternetContent",
            0, KEY_READ, &hKey );

    if ( lRet != ERROR_SUCCESS )
        goto exit;

    // read the registry key

    dwStatus = RegQueryValueEx( hKey, "NonMacCreatorTypes", 0, &dwType, (LPBYTE)NULL, &cbData );

    if ( dwStatus != ERROR_SUCCESS      // key missing
      || dwType   != REG_MULTI_SZ       // wrong type
      || cbData   <= 4 )                // invalid size
    {
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *)&lpData, cbData)))
        goto exit;

    ZeroMemory( (LPVOID)lpData, cbData );

    dwStatus = RegQueryValueEx( hKey, "NonMacCreatorTypes", NULL, &dwType, (LPBYTE)lpData, &cbData );

    if ( dwStatus != ERROR_SUCCESS )
      goto exit;

    // Determine # of pairs read:

    g_cCreatorTypes = 0;

    for ( i= 0; i < (LONG)cbData-1; i++ )
    {
      if ( lpData[i] == '\0' )
        g_cCreatorTypes ++;
    }

    if (FAILED(HrAlloc((LPVOID *)&g_lpCreatorTypes, sizeof(sCreatorType) * g_cCreatorTypes)))
        goto exit;

    ZeroMemory( (LPVOID)g_lpCreatorTypes, sizeof(sCreatorType) * g_cCreatorTypes );

    // Build the Creator-Type array

    lpCurrent = lpData;

    i = 0;
    while ( lpCurrent < (lpData + cbData -1) )
    {
        lpNext = StrChr( lpCurrent, ':' );

        if( lpNext == NULL )
        {
            //no ':' found; skip to next string

            lpCurrent = StrChr( lpCurrent, '\0' ) + 1;
            continue;
        }

        *lpNext = '\0';
        if ( StrChr( lpCurrent, '*' ) == NULL )
            CopyMemory( &g_lpCreatorTypes[i].szCreator, lpCurrent, MIN(4, lpNext-lpCurrent) );

        lpCurrent = lpNext + 1;

        lpNext = StrChr( lpCurrent, '\0' );

        if ( lpNext == NULL )
            break;

        if ( StrChr( lpCurrent, '*' ) == NULL )
        {
            CopyMemory( &g_lpCreatorTypes[i].szType, lpCurrent, MIN( 4, lpNext-lpCurrent) );
        }

        lpCurrent = lpNext + 1;
        i++;
    }

    g_cCreatorTypes = i;

exit:

    if ( hKey != 0 )
        RegCloseKey( hKey );

    SafeMemFree(lpData);

    if ( g_cCreatorTypes == 0  && g_lpCreatorTypes != NULL )
    {
        SafeMemFree(g_lpCreatorTypes);
    }
#endif  // !MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bookbody.cpp ===
// --------------------------------------------------------------------------------
// BookBody.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bookbody.h"
#include "dllmain.h"
#include "ibdylock.h"
#include "stmlock.h"
#include "ibdystm.h"
#include "resource.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "urlmon.h"
#include "symcache.h"
#include "booktree.h"
#include <demand.h>
#include "mimeapi.h"
#include <shlwapi.h>
#include "webdocs.h"

// --------------------------------------------------------------------------------
// ASSERTINIT
// --------------------------------------------------------------------------------
#define ASSERTINIT \
    AssertSz(m_pContainer, "Object is being used before a call to InitNew")

// --------------------------------------------------------------------------------
// Default Body Options
// --------------------------------------------------------------------------------
static const BODYOPTIONS g_rDefBodyOptions = {
    IET_UNKNOWN,                // OID_TRANSMIT_BODY_FORMAT
    DEF_CBMAX_BODY_LINE,        // OID_CBMAX_BODY_LINE
    DEF_WRAP_BODY_TEXT,         // OID_WRAP_BODY_TEXT
    DEF_BODY_REMOVE_NBSP,       // OID_BODY_REMOVE_NBSP
    DEF_DBCS_ESCAPE_IS_8BIT,    // OID_DBCS_ESCAPE_IS_8BIT
    DEF_HIDE_TNEF_ATTACHMENTS,  // OID_HIDE_TNEF_ATTACHMENTS
    MST_NONE,                   // OID_SECURITY_TYPE
    NULL,                       // OID_SECURITY_ALG_HASH and OID_SECURITY_ALG_HASH_RG
    { 0, NULL },                // OID_SECURITY_ALG_BULK
    NULL,                       // OID_SECURITY_CERT_SIGNING and OID_SECURITY_CERT_SIGNING_RG
    0,                          // OID_SECURITY_CERT_DECRYPTION
    NULL,                       // OID_SECURITY_HCERTSTORE and OID_SECURITY_HCERTSTORE_RG
    { 0, NULL },                // OID_SECURITY_SEARCHSTORES
    0,
    NULL,                       // OID_SECURITY_RG_IASN
#ifdef SMIME_V3
    NULL,                       // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    NULL,                       // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    NULL,                       // OID_SECURITY_UNPROTECTATTR_RG
#else  // !SMIME_V3
    NULL,                       // OID_SECURITY_SYMCAPS and OID_SECURITY_SYMCAPS_RG
    NULL,                       // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    NULL,                       // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    NULL,                       // OID_SECURITY_SIGNTIME and OID_SECURITY_SIGNTIME_RG
#endif // SMIME_V3
    NULL,                       // OID_SECURITY_USER_VALIDITY and OID_SECURITY_USER_VALIDITY_RG
    NULL,                       // OID_SECURITY_RO_MSG_VALIDITY and OID_SECURITY_RO_MSG_VALIDITY_RG
    0,                          // OID_SECURITY_HCRYPTPROV
    0,                          // OID_SECURITY_ENCODE_FLAGS
    FALSE,                      // OID_SECURITY_CERT_INCLUDED
    // This is NULL b/c default is generated at runtime
    NULL,                       // OID_SECURITY_HWND_OWNER
    // Base64 is the recommended value in the S/MIME spec
    IET_BASE64,                 // OID_SECURITY_REQUESTED_CTE
#ifdef SMIME_V3
    NULL,                       // OID_SECURITY_RECEIPT_RG
    NULL,                       // OID_SECURITY_MESSAGE_HASH_RG
    NULL,                       // OID_SECURITY_KEY_PROMPT
#endif // SMIME_V3
    DEF_SHOW_MACBINARY,         // OID_SHOW_MACBINARY
    DEF_SUPPORT_EXTERNAL_BODY,  // OID_SUPPORT_EXTERNAL_BODY
    0,                          // cSecurityLayers (size of arrays of
                                //     OID_SECURITY_ALG_HASH
                                //     OID_SECURITY_CERT_SIGNING
                                //     OID_SECURITY_HCERTSTORE
                                //     OID_SECURITY_SYMCAPS
                                //     OID_SECURITY_AUTHATTR
                                //     OID_SECURITY_UNAUTHATTR
                                //     OID_SECURITY_SIGNTIME
                                //     OID_SECURITY_USER_VALIDITY
                                //     OID_SECURITY_RO_MSG_VALIDITY)
    FALSE,                      // OID_NOSECURITY_ON_SAVE
#ifdef SMIME_V3
    0, 0, NULL,                 // cRecipients/rgRecipients
#endif // SMIME_V3
    NULL,                       // OID_SECURITY_ENCRYPT_CERT_BAG
};

static const BLOB blobNULL = {0, NULL};

HRESULT HrCopyBlobArray(LPCBLOB pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyDwordArray(LPDWORD pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyIntoUlonglongArray(ULARGE_INTEGER * pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyFiletimeArray(LPFILETIME pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
DWORD MergeDWORDFlags(LPDWORD rgdw, ULONG cEntries);
extern HRESULT HrGetLastError(void);
extern BOOL FIsMsasn1Loaded();


// --------------------------------------------------------------------------------
// WebBookContentBody_CreateInstance
// --------------------------------------------------------------------------------
HRESULT WebBookContentBody_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageBody *pNew = new CMessageBody(NULL, pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::CMessageBody
// --------------------------------------------------------------------------------
CMessageBody::CMessageBody(LPTREENODEINFO pNode, IUnknown *pUnkOuter)
    : m_pNode(pNode), CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_cRef = 1;
    m_dwState = 0;
    m_pszDisplay = NULL;
    m_ietEncoding = IET_BINARY;
    m_ietPrevious = IET_UNKNOWN;
    m_pCharset = CIntlGlobals::GetDefBodyCset();
    m_pCsetTagged = NULL;
    m_pContainer = NULL;
    m_cbExternal = 0xFFFFFFFF;
    ZeroMemory(&m_rStorage, sizeof(BODYSTORAGE));
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));
    // (t-erikne) need to get this default at run time
    m_rOptions.hwndOwner = HWND_DESKTOP;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::~CMessageBody
// --------------------------------------------------------------------------------
CMessageBody::~CMessageBody(void)
{
    SafeRelease(m_pContainer);
    SafeMemFree(m_pszDisplay);
    SafeRelease(m_rStorage.pUnkRelease);

    // Clear out the options
    _FreeOptions();

    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMessageBody::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CMessageBody::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IMimeBody == riid)
        *ppv = (IMimeBody *)this;
    else if (IID_IMimeBodyW == riid)
        *ppv = (IMimeBodyW *)this;
    else if (IID_IMimePropertySet == riid)
        *ppv = (IMimePropertySet *)this;
    else if (IID_IPersist == riid)
        *ppv = (IPersist *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_CMessageBody == riid)
        *ppv = (CMessageBody *)this;
#ifdef SMIME_V3
    else if (IID_IMimeSecurity2 == riid)
        *ppv = (IMimeSecurity2 *) this;
#endif
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::RevokeTreeNode
// --------------------------------------------------------------------------------
void CMessageBody::RevokeTreeNode(void)
{
    EnterCriticalSection(&m_cs);
    m_pNode = NULL;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::HrBindToTree
// --------------------------------------------------------------------------------
HRESULT CMessageBody::HrBindToTree(CStreamLockBytes *pStmLock, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT             hr=S_OK;
    HCHARSET            hCharset=NULL;
    IStream             *pstmBody=NULL;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Arg
    Assert(pNode && NULL == pNode->pLockBytes && pStmLock && m_pNode == pNode);

    // Create the body lock bytes
    CHECKALLOC(pNode->pLockBytes = new CBodyLockBytes(pStmLock, pNode));

    // Just assume it
    m_rStorage.riid = IID_ILockBytes;
    m_rStorage.pLockBytes = (ILockBytes *)pNode->pLockBytes;
    m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    m_rStorage.pUnkRelease->AddRef();

    // Test for binhex
    if (S_FALSE == m_pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTXFER)) && m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_BINHEX) == S_OK)
    {
        // Locals
        PROPVARIANT     rVariant;

        // Setup the variant
        rVariant.vt = VT_LPSTR;

        // If there is a filename, lets re-compute the content-type
        if (SUCCEEDED(m_pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), 0, &rVariant)))
        {
            // Locals
            LPSTR       pszCntType;
            LPSTR       pszSubType;

            // Get mime file information
            if (SUCCEEDED(MimeOleGetFileInfo(rVariant.pszVal, &pszCntType, &pszSubType, NULL, NULL, NULL)))
            {
                // ContentType
                if (pszCntType && pszSubType)
                {
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), pszCntType));
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), pszSubType));
                }

                // application/octet-stream
                else
                {
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), STR_MIME_APPL_STREAM));
                }

                // Cleanup
                SafeMemFree(pszCntType);
                SafeMemFree(pszSubType);
            }

            // Clenaup
            SafeMemFree(rVariant.pszVal);
        }

        // Set the Content-Transfer-Encoding to binhex
        m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTXFER), STR_ENC_BINHEX40);

        // The encoding type better be binhex
        Assert(m_pContainer->GetEncodingType() == IET_BINHEX40);
    }

    // Otherwise, test for message/external-body
    else if (m_rOptions.fExternalBody && S_OK == m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_EXTERNAL))
    {
        // Bind to External-Body
        _BindToExternalBody();
    }

    // Save The Format
    m_ietPrevious = m_ietEncoding = m_pContainer->GetEncodingType();

    // Raid 2215: Map a CTE of binary to 8bit so that it gets decoded correctly from the internet character set
    if (IET_BINARY == m_ietEncoding)
    {
        // Switch to 8bit because ibdystm.cpp will not do the charset translation right if the source is binary...
        m_ietEncoding = IET_8BIT;
    }

    // LateTnef Check
    if (ISFLAGSET(pNode->dwState, NODESTATE_VERIFYTNEF))
    {
        // Get the data stream
        if (SUCCEEDED(GetData(IET_BINARY, &pstmBody)))
        {
            // If TNEF, apply content type...
            if (MimeOleIsTnefStream(pstmBody) == S_OK)
            {
                // application/ms-tnef
                CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPLY_MSTNEF));
            }
        }

        // Clear the flag
        FLAGCLEAR(pNode->dwState, NODESTATE_VERIFYTNEF);
    }

    // If I'm a message with crypto mime types, say I'm "secure"
    if (IsSecureContentType(m_pContainer))
    {
        // TREENODE_SECURE
        FLAGSET(m_dwState, BODYSTATE_SECURE);
    }

    // If the Header was tagged with a charset, use that charset
    if (m_pContainer->IsState(COSTATE_CSETTAGGED) == S_OK)
    {
        // Get Internal Character Set
        if (SUCCEEDED(m_pContainer->GetCharset(&hCharset)))
        {
            // Get Pointer
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

            // Save this as m_pCsetTagged
            m_pCsetTagged = m_pCharset;
        }

        // I was tagged with a charset
        FLAGSET(m_dwState, BODYSTATE_CSETTAGGED);
    }

    // Bound to tree
    FLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE);

exit:
    // Cleanup
    SafeRelease(pstmBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::_BindToExternalBody
// ---------------------------------------------------------------------------
void CMessageBody::_BindToExternalBody(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTR               pszAccessType=NULL;
    LPSTR               pszUrl=NULL;
    IStream             *pstmBody=NULL;
    DWORD               cbSize=0xFFFFFFFF;
    CMimeWebDocument    *pWebDoc=NULL;

    // Get par:content-type:access-type
    CHECKHR(hr = m_pContainer->GetProp(STR_PAR_ACCESSTYPE, &pszAccessType));

    // Handle Access-Types that I know about
    if (lstrcmpi(pszAccessType, "X-URL") == 0)
    {
        // Locals
        PROPVARIANT rSize;

        // Get par:content-type:xurl
        CHECKHR(hr = m_pContainer->GetProp(STR_PAR_XURL, &pszUrl));

        // Create the WebDoc
        CHECKALLOC(pWebDoc = new CMimeWebDocument);

        // Initialize It
        CHECKHR(hr = pWebDoc->HrInitialize(NULL, pszUrl));

        // Setup Variant
        rSize.vt = VT_UI4;

        // Get par:content-type:size
        if (SUCCEEDED(m_pContainer->GetProp(STR_PAR_SIZE, 0, &rSize)))
            cbSize = rSize.ulVal;
    }

    // If we have a webdocument...
    if (pWebDoc)
    {
        // Get the Body Data
        if (SUCCEEDED(GetData(IET_BINARY, &pstmBody)))
        {
            // Locals
            PROPVARIANT rOption;

            // Setup the option variant
            rOption.vt = VT_UI4;
            rOption.ulVal = RELOAD_HEADER_REPLACE;

            // Set special option since I'm realoding the header...
            CHECKHR(hr = m_pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption));

            // Load this body into the container
            CHECKHR(hr = m_pContainer->Load(pstmBody));

            // Reset the option variant
            rOption.vt = VT_UI4;
            rOption.ulVal = DEF_HEADER_RELOAD_TYPE_PROPSET;

            // Set special option since I'm realoding the header...
            CHECKHR(hr = m_pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption));
        }

        // SetData
        CHECKHR(hr = SetData(IET_BINARY, NULL, NULL, IID_IMimeWebDocument, (LPVOID)pWebDoc));

        // Create a External Body Info Structure: MUST BE SET AFTER CALL TO SETDATA
        FLAGSET(m_dwState, BODYSTATE_EXTERNAL);

        // Set Size: MUST BE SET AFTER CALL TO SETDATA
        m_cbExternal = cbSize;
    }

exit:
    // Cleanup
    SafeMemFree(pszAccessType);
    SafeMemFree(pszUrl);
    SafeRelease(pstmBody);
    SafeRelease(pWebDoc);

    // Done
    return;
}

#if 0
// ---------------------------------------------------------------------------
// CMessageBody::UseOriginalCharset
// ---------------------------------------------------------------------------
void CMessageBody::UseOriginalCharset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We should have m_pCsetTagged
    Assert(m_pCsetTagged);

    // Set the Charset
    if (m_pCsetTagged)
        SetCharset(m_pCsetTagged->hCharset, CSET_APPLY_ALL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
#endif

// ---------------------------------------------------------------------------
// CMessageBody::SetDisplayName
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetDisplayName(LPCSTR pszDisplayName)
{
    LPWSTR  pwszDispName;
    HRESULT hr = S_OK;

    Assert(pszDisplayName);

    IF_NULLEXIT(pwszDispName = PszToUnicode(CP_ACP, pszDisplayName));

    hr = SetDisplayNameW(pwszDispName);

exit:
    MemFree(pwszDispName);

    return hr;
}

#define DisplayMaxLen 64

STDMETHODIMP CMessageBody::SetDisplayNameW(LPCWSTR pszDisplayName)
{
    // Locals
    HRESULT         hr=S_OK;
    WCHAR           szSize[30],
                    szScratch[30],
                    szBuf[MAX_PATH];
    ULONG           cbSize=0,
                    cAlloc,
                    cLen;
    ASSERTINIT;

    // check params
    if (NULL == pszDisplayName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free current display name
    SafeMemFree(m_pszDisplay);

    // Get Data Size...
    GetEstimatedSize(IET_BINARY, &cbSize);

    // Format the Size
    StrFormatByteSizeW(cbSize, szScratch, ARRAYSIZE(szScratch));
    StrCpyNW(szSize, L"(", ARRAYSIZE(szSize));
    StrCatBuffW(szSize, szScratch, ARRAYSIZE(szSize));
    StrCatBuffW(szSize, L")", ARRAYSIZE(szSize));

    cLen = lstrlenW(pszDisplayName);
    if (cLen+1 > ARRAYSIZE(szBuf))
        cLen = ARRAYSIZE(szBuf) - 1;
    StrCpyNW(szBuf, pszDisplayName, cLen+1);
    PathStripPathW(szBuf);
    cLen = lstrlenW(szBuf);
    if (cLen > DisplayMaxLen)
    {
        WCHAR szBuf2[MAX_PATH];
        WCHAR *szExt;
        szExt = PathFindExtensionW(szBuf);
        if (*szExt)
        {
            int cExt = lstrlenW(szExt);
            if (cExt < DisplayMaxLen-3)
            {
                WCHAR szExt2[DisplayMaxLen];
                StrCpyNW(szExt2, szExt, ARRAYSIZE(szExt2));
                PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen-cExt, 0);
                StrCatBuffW(szBuf2, szExt2, ARRAYSIZE(szBuf2));
            }
            else
                PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen, 0);
        }
        else
        {
            PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen, 0);
        }
        StrCpyNW(szBuf, szBuf2, ARRAYSIZE(szBuf));
    }

    // Size to allocate: filename.dat (x)\0
    cAlloc = lstrlenW(szBuf) + lstrlenW(szSize) + 2;

    // Dup the display name
    CHECKALLOC(m_pszDisplay = PszAllocW(cAlloc));

    // Format the Display Name
    StrCpyNW(m_pszDisplay, szBuf, cAlloc);
    StrCatBuffW(m_pszDisplay, L" ", cAlloc);
    StrCatBuffW(m_pszDisplay, szSize, cAlloc);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::GetDisplayName
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetDisplayName(LPSTR *ppszDisplayName)
{
    LPWSTR  pwszDispName = NULL;
    HRESULT hr;

    Assert(ppszDisplayName);

    *ppszDisplayName = NULL;

    IF_FAILEXIT(hr = GetDisplayNameW(ppszDisplayName ? &pwszDispName : NULL));

    IF_NULLEXIT(*ppszDisplayName = PszToANSI(CP_ACP, pwszDispName));

exit:
    MemFree(pwszDispName);
    return TraceResult(hr);
}

STDMETHODIMP CMessageBody::GetDisplayNameW(LPWSTR *ppszDisplayName)
{
    // Locals
    HRESULT         hr=S_OK;
    ASSERTINIT;

    // check params
    if (NULL == ppszDisplayName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszDisplayName = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Do I have an internal displayname ?
    if (NULL == m_pszDisplay)
    {
        LPSTR   pszVal = NULL;
        LPWSTR  pwszVal = NULL;

        // Use m_pszURL first
        if (IID_IMimeWebDocument == m_rStorage.riid && SUCCEEDED(m_rStorage.pWebDocument->GetURL(&pszVal)))
            SetDisplayName(pszVal);

        // Raid-38681 - mail:file name is incorrect when attaching renamed saved message
        // Raid-18813 - Single Bodies messages can have a filename and a subject.
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_ATT_FILENAME, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // If I'm an message/rfc822
        else if (m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_RFC822) == S_OK && FExtractRfc822Subject(&pwszVal))
            SetDisplayNameW(pwszVal);

        // Parent is multipart/digest
        else if (m_pNode && m_pNode->pParent && m_pNode->pParent->pBody && m_pNode->pParent->pBody->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK && FExtractRfc822Subject(&pwszVal))
            SetDisplayNameW(pwszVal);

        // Use Subject
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_HDR_SUBJECT, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // Use Generated File Name...
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_ATT_GENFNAME, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // Content Description
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_HDR_CNTDESC, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        SafeMemFree(pszVal);
        SafeMemFree(pwszVal);
    }

    // If there is a display name now, then dup it.
    if (m_pszDisplay)
        CHECKALLOC(*ppszDisplayName = PszDupW(m_pszDisplay));
    else
        hr = MIME_E_NO_DATA;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::FExtractRfc822Subject
// ---------------------------------------------------------------------------
BOOL CMessageBody::FExtractRfc822Subject(LPWSTR *ppwszVal)
{
    // Locals
    HRESULT           hr=S_OK;
    IStream          *pstmData=NULL;
    IMimePropertySet *pPropertySet=NULL;
    PROPVARIANT       rSubject;
    ASSERTINIT;

    // Invalid Arg
    Assert(ppwszVal);

    // Init
    MimeOleVariantInit(&rSubject);
    *ppwszVal = NULL;

    // Get the data
    CHECKHR(hr = GetData(IET_BINARY, &pstmData));

    // Lets create a header
    CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pPropertySet));

    // Parse the header
    CHECKHR(hr = pPropertySet->Load(pstmData));

    // Init Variant
    rSubject.vt = VT_LPWSTR;

    // Get the subject and set the display name
    CHECKHR(hr = pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject));

    // Raid-38681 - mail:file name is incorrect when attaching renamed saved message
    if (FIsEmptyW(rSubject.pwszVal))
    {
        SafeMemFree(rSubject.pwszVal);
        goto exit;
    }

    // Set this subject on my self so that STR_ATT_GENFNAME works
    m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTDESC), 0, &rSubject);

    // Return It
    *ppwszVal = rSubject.pwszVal;

exit:
    // Cleanup
    SafeRelease(pstmData);
    SafeRelease(pPropertySet);

    // Done
    return (NULL == *ppwszVal) ? FALSE : TRUE;
}

// ---------------------------------------------------------------------------
// CMessageBody::SetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetOption(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    return InternalSetOption(oid, pValue, FALSE, FALSE);
}

// ---------------------------------------------------------------------------
// CMessageBody::InternalSetOption
// ---------------------------------------------------------------------------
HRESULT CMessageBody::InternalSetOption(const TYPEDID oid, LPCPROPVARIANT pValue, BOOL fInternal, BOOL fNoDirty)
{
    // Locals
#ifdef SMIME_V3
    DWORD       cb;
#endif // SMIME_V3
    HRESULT     hr=S_OK;
    DWORD       i;
    ASSERTINIT;
    CAPROPVARIANT capv;
    CAUL        caul;
    CAUH        cauh;
    CAFILETIME  cafiletime;
#ifdef SMIME_V3
    BYTE                rgb[50];
#endif // SMIME_V3

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_SUPPORT_EXTERNAL_BODY:
        if (m_rOptions.fExternalBody != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fExternalBody = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SHOW_MACBINARY:
        if (m_rOptions.fShowMacBin != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fShowMacBin = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;


    case OID_CBMAX_BODY_LINE:
        if (pValue->ulVal < MIN_CBMAX_BODY_LINE || pValue->ulVal > MAX_CBMAX_BODY_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pValue->ulVal)
        {
            m_rOptions.cbMaxLine = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_TRANSMIT_BODY_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietTransmit != (ENCODINGTYPE)pValue->ulVal)
        {
            m_rOptions.ietTransmit = (ENCODINGTYPE)pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_WRAP_BODY_TEXT:
        if (m_rOptions.fWrapText != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fWrapText = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        if (m_rOptions.fHideTNEF != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fHideTNEF = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_DBCS_ESCAPE_IS_8BIT:
        if (m_rOptions.fDBCSEscape8 != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fDBCSEscape8 = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_TYPE:
        if (m_rOptions.ulSecurityType != pValue->ulVal)
        {
            m_rOptions.ulSecurityType = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_ALG_HASH: // innermost signing algorithm
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (CompareBlob(&m_rOptions.rgblobHash[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobHash[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobHash[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_ALG_HASH_RG: // signing algorithms
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobHash, fNoDirty);
        break;

    case OID_SECURITY_ALG_BULK:
        if (CompareBlob(&m_rOptions.blobBulk, &pValue->blob))
            {
            ReleaseMem(m_rOptions.blobBulk.pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.blobBulk);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#ifndef _WIN64
    case OID_SECURITY_CERT_SIGNING:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != (PCCERT_CONTEXT)pValue->ulVal)
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->ulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            caul = pValue->caul;
            Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                for (i = 0; i < caul.cElems; i++) {
                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)caul.pElems[i])
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)caul.pElems[i]);
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION:
        if (m_rOptions.pcCertDecryption != (PCCERT_CONTEXT)pValue->ulVal)
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->ulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT:
#ifdef SMIME_V3
        for (i=0; i<pValue->caul.cElems; i++)
        {
            CMS_RECIPIENT_INFO          info = {0};
            info.pccert = (PCCERT_CONTEXT) pValue->caul.pElems[i];
            hr = AddRecipient((i == 0) ? SMIME_RECIPIENT_REPLACE_ALL : 0, 1, &info);
            if (FAILED(hr))
            {
                break;
            }
        }
        if (SUCCEEDED(hr) && !fNoDirty)
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
#else  // !SMIME_V3
        if (SUCCEEDED(hr = _CAULToCERTARRAY(pValue->caul, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
#endif // !SMIME_V3
        break;

    case OID_SECURITY_HCERTSTORE:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->ulVal)
            m_rOptions.hCertStore = CertDuplicateStore((HCERTSTORE)pValue->ulVal);
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG:
        CertCloseStore(m_rOptions.hstoreEncrypt, 0);
        if (pValue->ulVal)
            m_rOptions.hstoreEncrypt = CertDuplicateStore((HCERTSTORE) pValue->ulVal);
        else
            m_rOptions.hstoreEncrypt = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG:
        if (SUCCEEDED(hr = _CAULToCertStore(pValue->caul, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES:
        if (SUCCEEDED(hr = _CAULToSTOREARRAY(pValue->caul, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN:
        //N TODO: OID_SECURITY_RG_IASN
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    // 2 Key implementation
    case OID_SECURITY_2KEY_CERT_BAG:
        {
            hr = S_OK;
            //  Create a new store if needed
            if (m_rOptions.hCertStore == NULL)
            {
                m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
            }

            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
            }

            for (i=0; i < (pValue->caul).cElems; i++)
            {
                if (!CertAddCertificateContextToStore(m_rOptions.hCertStore,
                                              (PCCERT_CONTEXT) IntToPtr((pValue->caul).pElems[i]),
                                              CERT_STORE_ADD_ALWAYS, NULL))
                {
                    hr = HrGetLastError();
                }
            }
            if(hr == S_OK)
            {
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }

        }
        break;

    case OID_SECURITY_HCRYPTPROV:
        if (m_rOptions.hCryptProv != pValue->ulVal)
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#else // _WIN64
    case OID_SECURITY_CERT_SIGNING_64:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != (PCCERT_CONTEXT)pValue->pulVal)
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->pulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG_64: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            cauh = pValue->cauh;
            Assert(cauh.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != cauh.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            } else {
                for (i = 0; i < cauh.cElems; i++)
                {
                    PCCERT_CONTEXT pCert = *(PCCERT_CONTEXT *) (&(cauh.pElems[i]));

                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)(pCert))
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)(pCert));
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION_64:
        if (m_rOptions.pcCertDecryption != (PCCERT_CONTEXT)pValue->pulVal)
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->pulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT_64:
#ifdef SMIME_V3
        for (i=0; i<pValue->cauh.cElems; i++)
        {
            CMS_RECIPIENT_INFO          info = {0};
            info.pccert = *((PCCERT_CONTEXT*) &(pValue->cauh.pElems[i]));
            hr = AddRecipient((i == 0) ? SMIME_RECIPIENT_REPLACE_ALL : 0, 1, &info);
            if (FAILED(hr))
            {
                break;
            }
        }
        if (SUCCEEDED(hr) && !fNoDirty)
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
#else  // !SMIME_V3
        if (SUCCEEDED(hr = _CAUHToCERTARRAY(pValue->cauh, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
#endif // !SMIME_V3
        break;

    case OID_SECURITY_HCERTSTORE_64:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->pulVal)
            m_rOptions.hCertStore = CertDuplicateStore((HCERTSTORE)pValue->pulVal);
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG_64:
        CertCloseStore(m_rOptions.hstoreEncrypt, 0);
        if (pValue->pulVal)
            m_rOptions.hstoreEncrypt = CertDuplicateStore((HCERTSTORE) pValue->pulVal);
        else
            m_rOptions.hstoreEncrypt = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG_64:
        if (SUCCEEDED(hr = _CAUHToCertStore(pValue->cauh, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES_64:
        if (SUCCEEDED(hr = _CAUHToSTOREARRAY(pValue->cauh, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN_64:
        //N TODO: OID_SECURITY_RG_IASN
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    // 2 Key implementation
    case OID_SECURITY_2KEY_CERT_BAG_64:
        {
            hr = S_OK;
            //  Create a new store if needed
            if (m_rOptions.hCertStore == NULL)
            {
                m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
            }

            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
            }

            for (i=0; i < (pValue->cauh).cElems; i++)
            {
                if (!CertAddCertificateContextToStore(m_rOptions.hCertStore,
                                              *((PCCERT_CONTEXT *) (&((pValue->cauh).pElems[i]))),
                                              CERT_STORE_ADD_ALWAYS, NULL))
                {
                    hr = HrGetLastError();
                }
            }
            if(hr == S_OK)
            {
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }

        }
        break;

    case OID_SECURITY_HCRYPTPROV_64:
        if (m_rOptions.hCryptProv != (((HCRYPTPROV) (pValue->pulVal))))
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = (HCRYPTPROV) pValue->pulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#endif //_WIN64

    case OID_SECURITY_CRL:
        if (m_rOptions.hCertStore == NULL)
        {
            m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                  X509_ASN_ENCODING,
                                                  NULL, 0, NULL);
            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
                break;
            }
        }
        if (!CertAddEncodedCRLToStore(m_rOptions.hCertStore, X509_ASN_ENCODING,
                                      pValue->blob.pBlobData,
                                      pValue->blob.cbSize,
                                      CERT_STORE_ADD_ALWAYS, NULL))
        {
            hr = HrGetLastError();
        }
        else if (!fNoDirty)
        {
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

   case OID_SECURITY_SYMCAPS:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
       hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                            szOID_RSA_SMIMECapabilities,
                            pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobSymCaps[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobSymCaps[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobSymCaps[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SYMCAPS_RG: // symetric capabilities
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                szOID_RSA_SMIMECapabilities,
                                pValue->capropvar.pElems[i].blob.cbSize,
                                pValue->capropvar.pElems[i].blob.pBlobData);

           if (FAILED(hr))
               break;
       }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobSymCaps, fNoDirty);
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                             NULL, pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobAuthAttr[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobAuthAttr[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobAuthAttr[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR_RG: // authenticated attributes
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                 NULL, pValue->capropvar.pElems[i].blob.cbSize,
                                 pValue->capropvar.pElems[i].blob.pBlobData);
            if (FAILED(hr))
                break;
        }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobAuthAttr, fNoDirty);
#endif // SMIME_V3
        break;


    case OID_SECURITY_UNAUTHATTR:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0],
                             NULL, pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobUnauthAttr[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobUnauthAttr[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobUnauthAttr[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_UNAUTHATTR_RG: // unauthenticated attributes
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i],
                                 NULL, pValue->capropvar.pElems[i].blob.cbSize,
                                 pValue->capropvar.pElems[i].blob.pBlobData);
            if (FAILED(hr))
                break;
        }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobUnauthAttr, fNoDirty);
#endif // SMIME_V3
        break;


    case OID_SECURITY_SIGNTIME:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        if ((pValue->filetime.dwLowDateTime == 0) &&
            (pValue->filetime.dwHighDateTime == 0))
        {
            hr = DeleteAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, 0,
                                 szOID_RSA_signingTime);
        }
        else
        {
            cb = sizeof(rgb);
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                     &pValue->filetime, 0, NULL,
                                     rgb, &cb))
            {
                hr = HrGetLastError();
                break;
            }

            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                                 szOID_RSA_signingTime, cb, rgb);
        }
#else  // !SMIME_V3
        if (CompareFileTime(&m_rOptions.rgftSigning[0], (FILETIME FAR*)&pValue->filetime))
            {
            CopyMemory(&m_rOptions.rgftSigning[0], &pValue->filetime, sizeof(FILETIME));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME_RG: // signing times
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->cafiletime.cElems; i++)
        {
            if ((pValue->cafiletime.pElems[i].dwLowDateTime == 0) &&
            (pValue->cafiletime.pElems[i].dwHighDateTime == 0))
            {
                hr = DeleteAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, 0,
                                     szOID_RSA_signingTime);
            }
            else
            {
                cb = sizeof(rgb);
                if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                         &pValue->cafiletime.pElems[i], 0, NULL,
                                         rgb, &cb))
                {
                    hr = HrGetLastError();
                    break;
                }

                hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                  szOID_RSA_signingTime, cb, rgb);
            }
        }
#else  // !SMIME_V3
        cafiletime = pValue->cafiletime;
        Assert(cafiletime.cElems == m_rOptions.cSigners);
        if (m_rOptions.cSigners != cafiletime.cElems)
        {
            hr = E_INVALIDARG;
        } else {
            for (i = 0; i < cafiletime.cElems; i++)
            {
                if (CompareFileTime(&m_rOptions.rgftSigning[i], (FILETIME FAR*)&cafiletime.pElems[i]))
                {
                    CopyMemory(&m_rOptions.rgftSigning[i], &cafiletime.pElems[i], sizeof(FILETIME));
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_USER_VALIDITY:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgulUserDef[0] != pValue->ulVal)
            {
            m_rOptions.rgulUserDef[0] = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_USER_VALIDITY_RG: // user validity flags
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        caul = pValue->caul;
        Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
        if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
        {
            hr = E_INVALIDARG;
        } else {
            for (i = 0; i < caul.cElems; i++)
            {
                if (m_rOptions.rgulUserDef[i] != caul.pElems[i])
                {
                    m_rOptions.rgulUserDef[i] = caul.pElems[i];
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (fInternal)
            {
            if (m_rOptions.rgulROValid[0] != pValue->ulVal)
                {
                m_rOptions.rgulROValid[0] = pValue->ulVal;
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY_RG:  // message validity flags
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        caul = pValue->caul;
        Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
        if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            for (i = 0; i < caul.cElems; i++)
            {
                if (m_rOptions.rgulROValid[i] != caul.pElems[i])
                {
                    m_rOptions.rgulROValid[i] = caul.pElems[i];
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        if (m_rOptions.ulEncodeFlags != pValue->ulVal)
            {
            m_rOptions.ulEncodeFlags = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_CERT_INCLUDED:
        if (fInternal)
            {
            if (m_rOptions.fCertWithMsg != pValue->boolVal)
                {
                m_rOptions.fCertWithMsg = pValue->boolVal;
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

#ifndef _WIN64
    case OID_SECURITY_HWND_OWNER:
        m_rOptions.hwndOwner = HWND(pValue->ulVal);
        break;
#endif

    case OID_SECURITY_REQUESTED_CTE:
        if (m_rOptions.ietRequested != pValue->lVal)
            {
            m_rOptions.ietRequested = ENCODINGTYPE(pValue->lVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_SIGNATURE_COUNT:
        // M00BUG - I just found out that if lVal >0 but lVal < m_rOptions.cSigners
        //      then we don't do any adjustments to handle this case.
        if (pValue->lVal == 0)
            {
            if (m_rOptions.cSigners)
                {
                // OID_SECURITY_ALG_HASH
                SafeMemFree(m_rOptions.rgblobHash[0].pBlobData);


                // OID_SECURITY_CERT_SIGNING
                for (i = 0; i < m_rOptions.cSigners; i++)
                    {
                    CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);

#ifdef SMIME_V3
                    //  Attributes
                    SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i]);
                    SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i]);

                    // OID_SECURITY_RECEIPT_RG
                    SafeMemFree(m_rOptions.rgblobReceipt[i].pBlobData);
                    // OID_SECURITY_MESSAGE_HASH_RG
                    SafeMemFree(m_rOptions.rgblobMsgHash[i].pBlobData);
                    // OID_SECURITY_KEY_PROMPT
                    SafeMemFree(m_rOptions.pwszKeyPrompt);
#else // !SMIME_V3
                    // OID_SECURITY_SYMCAPS
                    SafeMemFree(m_rOptions.rgblobSymCaps[i].pBlobData);

                    // OID_SECURITY_AUTHATTR
                    SafeMemFree(m_rOptions.rgblobAuthAttr[i].pBlobData);

                    // OID_SECURITY_UNAUTHATTR
                    SafeMemFree(m_rOptions.rgblobUnauthAttr[i].pBlobData);
#endif // SMIME_V3
                    }

                // OID_SECURITY_HCERTSTORE
                CertCloseStore(m_rOptions.hCertStore, 0);
                m_rOptions.hCertStore = NULL;

                _FreeLayerArrays();
                m_rOptions.cSigners = 0;
                }
            }
        else if (m_rOptions.cSigners <= pValue->ulVal)
            {
                hr = _HrEnsureBodyOptionLayers(pValue);
            }
        break;

#ifdef SMIME_V3
    case OID_SECURITY_RECEIPT_RG:
        if (fInternal)
            {
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobReceipt, fNoDirty);
            }
        else
            hr = MIME_E_READ_ONLY;
        break;

    case OID_SECURITY_MESSAGE_HASH_RG:
        if (fInternal)
            {
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
                {
                break;
                }
            hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobMsgHash, fNoDirty);
            }
        else
            hr = MIME_E_READ_ONLY;
        break;

    case OID_SECURITY_KEY_PROMPT:
        if ((m_rOptions.pwszKeyPrompt == NULL) ||
            (pValue->pwszVal == NULL) ||
            (lstrcmpW(m_rOptions.pwszKeyPrompt,pValue->pwszVal) != 0))
            {
            SafeMemFree(m_rOptions.pwszKeyPrompt);
            if (pValue->pwszVal != NULL)
                {
                m_rOptions.pwszKeyPrompt = PszDupW(pValue->pwszVal);
                if (NULL == m_rOptions.pwszKeyPrompt)
                    hr = E_OUTOFMEMORY;
                }
            }
        break;

#endif // SMIME_V3

    case OID_NOSECURITY_ONSAVE:
        m_rOptions.fNoSecurityOnSave = !!pValue->boolVal;
        break;
#ifdef _WIN65
// (YST) This was checked in by BriMo at 01/22/99
    case OID_SECURITY_CERT_SIGNING2:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != *(PCCERT_CONTEXT *)(&(pValue->uhVal)))
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(pValue->uhVal)));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG2: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            cauh = pValue->cauh;
            Assert(cauh.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != cauh.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            } else {
                for (i = 0; i < cauh.cElems; i++)
                {
                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)(cauh.pElems[i]))
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT )(cauh.pElems[i]));
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION2:
        if (m_rOptions.pcCertDecryption != *(PCCERT_CONTEXT *)(&(pValue->uhVal)))
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(pValue->uhVal)));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT2:
        if (SUCCEEDED(hr = _CAUHToCERTARRAY(pValue->cauh, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_HCERTSTORE2:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->ulVal)
            m_rOptions.hCertStore = CertDuplicateStore(*(HCERTSTORE *)(&(pValue->uhVal)));
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG2:
        if (SUCCEEDED(hr = _CAUHToCertStore(pValue->cauh, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES2:
        if (SUCCEEDED(hr = _CAUHToSTOREARRAY(pValue->cauh, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN2:
        //N TODO: OID_SECURITY_RG_IASN2
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    case OID_SECURITY_HCRYPTPROV2:
        if (m_rOptions.hCryptProv != *(HCRYPTPROV *)(&(pValue->uhVal)))
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = *(HCRYPTPROV *)(&(pValue->uhVal));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;
// End of BriMo checkin
#endif // _WIN65

#ifdef _WIN64
    case OID_SECURITY_HWND_OWNER_64:
        m_rOptions.hwndOwner = (HWND)(pValue->pulVal);
        break;
#endif // _WIN64

    default:
        hr = m_pContainer->SetOption(oid, pValue);
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return TrapError(hr);
}

// ---------------------------------------------------------------------------
// CMessageBody::GetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetOption(const TYPEDID oid, LPPROPVARIANT pValue)
{
    // Locals
    DWORD               cb;
    HRESULT             hr=S_OK;
    DWORD               i;
    LPBYTE              pb;
    ASSERTINIT;
    ULONG iLayer;
#ifdef SMIME_V3
    CRYPT_ATTRIBUTE UNALIGNED *pattr;
#endif // SMIME_V3

#ifdef _WIN64
    void UNALIGNED *pv = NULL;
    PCCERT_CONTEXT pTmpCert = NULL;
    PCCERT_CONTEXT      pcCert = NULL;
#endif // _WIN64
    CRYPT_ATTR_BLOB UNALIGNED *pVal = NULL;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    pValue->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_SUPPORT_EXTERNAL_BODY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fExternalBody;
        break;

    case OID_SHOW_MACBINARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fShowMacBin;
        break;

    case OID_CBMAX_BODY_LINE:
        pValue->ulVal = m_rOptions.cbMaxLine;
        break;

    case OID_TRANSMIT_BODY_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietTransmit;
        break;

    case OID_WRAP_BODY_TEXT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fWrapText;
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHideTNEF;
        break;

    case OID_DBCS_ESCAPE_IS_8BIT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fDBCSEscape8;
        break;

    case OID_SECURITY_TYPE:
        pValue->ulVal = m_rOptions.ulSecurityType;
        break;

    case OID_SECURITY_ALG_HASH:
        if (m_rOptions.cSigners)
        {
            hr = HrCopyBlob(&m_rOptions.rgblobHash[0], &pValue->blob);
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_ALG_HASH_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobHash, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_ALG_BULK:
        hr = HrCopyBlob(&m_rOptions.blobBulk, &pValue->blob);
        break;

#ifndef _WIN64
    case OID_SECURITY_CERT_SIGNING:
        if (m_rOptions.cSigners)
            pValue->ulVal = (ULONG)CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
         else
            pValue->ulVal = 0;  // ?
        break;

    case OID_SECURITY_CERT_SIGNING_RG:
        hr = HrCopyDwordArray((ULONG*)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
        {
            pValue->caul.pElems[iLayer] = (ULONG)CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->caul.pElems[iLayer]);
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION:

        pValue->ulVal = (ULONG)CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
        break;

#ifndef SMIME_V3
    case OID_SECURITY_RG_CERT_ENCRYPT:
        hr = _CERTARRAYToCAUL(m_rOptions.caEncrypt, &pValue->caul);
        break;
#endif // !SMIEM_V3

    case OID_SECURITY_HCERTSTORE:
        pValue->ulVal = 0;
        if (m_rOptions.hCertStore)
            pValue->ulVal = (ULONG)CertDuplicateStore(m_rOptions.hCertStore);
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG:
        pValue->ulVal = 0;
        if (m_rOptions.hstoreEncrypt != NULL)
            pValue->ulVal = (ULONG) CertDuplicateStore(m_rOptions.hstoreEncrypt);
        break;

    case OID_SECURITY_RG_CERT_BAG:
        hr = _CertStoreToCAUL(m_rOptions.hCertStore, &pValue->caul);
        break;

    case OID_SECURITY_SEARCHSTORES:
        hr = _STOREARRAYToCAUL(m_rOptions.saSearchStore, &pValue->caul);
        break;

    case OID_SECURITY_RG_IASN:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV:
        pValue->ulVal = m_rOptions.hCryptProv;
        m_rOptions.hCryptProv = NULL;   // read-once
        break;

#else //_WIN64
    case OID_SECURITY_CERT_SIGNING_64:
        if (m_rOptions.cSigners)
            pValue->pulVal = (ULONG *)CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
        else 
            pValue->pulVal = 0;  // ?
        break;

    case OID_SECURITY_CERT_SIGNING_RG_64:
        hr = HrCopyIntoUlonglongArray((ULARGE_INTEGER *)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        if(m_rOptions.cSigners > 0)
        {
          for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
          {
            pv = (void*) (&(pValue->cauh.pElems[iLayer]));
            pTmpCert = *((PCCERT_CONTEXT *) pv);
                        pcCert = CertDuplicateCertificateContext(pTmpCert);
            pValue->cauh.pElems[iLayer] = *((ULARGE_INTEGER *)(&(pcCert)));
          }
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION_64:
        pValue->pulVal = (ULONG *)CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
        break;

#ifndef SMIME_V3
    case OID_SECURITY_RG_CERT_ENCRYPT_64:
        hr = _CERTARRAYToCAUH(m_rOptions.caEncrypt, &pValue->cauh);
        break;
#endif // !SMIEM_V3

    case OID_SECURITY_HCERTSTORE_64:
        pValue->pulVal = 0;
        if (m_rOptions.hCertStore)
            pValue->pulVal = (ULONG *)CertDuplicateStore(m_rOptions.hCertStore);
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG_64:
        pValue->pulVal = 0;
        if (m_rOptions.hstoreEncrypt != NULL)
            pValue->pulVal = (ULONG *) CertDuplicateStore(m_rOptions.hstoreEncrypt);
        break;

    case OID_SECURITY_RG_CERT_BAG_64:
        hr = _CertStoreToCAUH(m_rOptions.hCertStore, &pValue->cauh);
        break;

    case OID_SECURITY_SEARCHSTORES_64:
        hr = _STOREARRAYToCAUH(m_rOptions.saSearchStore, &pValue->cauh);
        break;

    case OID_SECURITY_RG_IASN_64:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV_64:
        pValue->pulVal = (ULONG *) (m_rOptions.hCryptProv);
        m_rOptions.hCryptProv = NULL;   // read-once
        break;

#endif //_WIN64

    case OID_SECURITY_CRL:
        //        hr = HrCopyBlob(&m_rOptions.blobCRL, &pValue->blob);
        Assert(FALSE);
        // M00BUG -- MUST IMPLEMENT THIS
        break;

    case OID_SECURITY_SYMCAPS:
#ifdef SMIME_V3
        pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                               szOID_RSA_SMIMECapabilities, 0);
        if (pattr != NULL)
        {
            pVal = &(pattr->rgValue[0]);

            Assert(pattr->cValue == 1);
            if (!MemAlloc((LPVOID UNALIGNED *) &pValue->blob.pBlobData,
                          pVal->cbData))
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            pValue->blob.cbSize = pVal->cbData;
            memcpy(pValue->blob.pBlobData, pVal->pbData,
                   pVal->cbData);
        }
        else {
            pValue->blob.cbSize = 0;
            pValue->blob.pBlobData = NULL;
        }
        pValue->vt = VT_BLOB;
#else  // !SMIME_V3
        if (m_rOptions.cSigners)
        {
            hr = HrCopyBlob(&m_rOptions.rgblobSymCaps[0], &pValue->blob);
        } else {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SYMCAPS_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED],
                         szOID_RSA_SMIMECapabilities, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobSymCaps, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR:
        if (m_rOptions.cSigners)
        {
#ifdef SMIME_V3
            memset(pValue, 0, sizeof(*pValue));
            pValue->vt = VT_BLOB;
            if ((m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0] != NULL) &&
                !CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pValue->blob.pBlobData,
                                     &pValue->blob.cbSize))
            {
                hr = HrGetLastError();
            }
#else  // !SMIME_V3
            hr = HrCopyBlob(&m_rOptions.rgblobAuthAttr[0], &pValue->blob);
#endif // SMIME_V3
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_AUTHATTR_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED], NULL, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobAuthAttr, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_UNAUTHATTR:
        if (m_rOptions.cSigners)
        {
#ifdef SMIME_V3
            memset(pValue, 0, sizeof(*pValue));
            pValue->vt = VT_BLOB;
            if ((m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0] != NULL) &&
                !CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0],
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pValue->blob.pBlobData,
                                     &pValue->blob.cbSize))
            {
                hr = HrGetLastError();
            }
#else  // !SMIME_V3
            hr = HrCopyBlob(&m_rOptions.rgblobUnauthAttr[0], &pValue->blob);
#endif // SMIME_V3
        } else {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_UNAUTHATTR_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED], NULL, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobUnauthAttr, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME:
#ifdef SMIME_V3
        pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0], szOID_RSA_signingTime, 0);

        pValue->vt = VT_FILETIME;

        if (pattr == NULL)
        {
            pValue->filetime.dwLowDateTime = 0;
            pValue->filetime.dwHighDateTime = 0;
        }
        else
        {
            cb = sizeof(pValue->filetime);
            Assert(pattr->cValue == 1);
            pVal = &(pattr->rgValue[0]);
            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                     pVal->pbData,
                                     pVal->cbData,
                                     0, NULL, &pValue->filetime, &cb))
            {
                hr = HrGetLastError();
                break;
            }
        }
#else  // !SMIME_V3
        if (m_rOptions.cSigners)
        {
            CopyMemory(&pValue->filetime, &m_rOptions.rgftSigning[0], sizeof(FILETIME));
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME_RG:
#ifdef SMIME_V3
        pValue->vt = VT_VECTOR | VT_VARIANT;
        pValue->capropvar.cElems = m_rOptions.cSigners;
        if (m_rOptions.cSigners > 0)
        {
            hr = HrAlloc((LPVOID *) &pValue->capropvar.pElems,
                         m_rOptions.cSigners * sizeof(PROPVARIANT));
            if (FAILED(hr))
            {
                break;
            }
            memset(pValue->capropvar.pElems, 0, m_rOptions.cSigners * sizeof(PROPVARIANT));
            for (i=0; i<m_rOptions.cSigners; i++)
            {
                pValue->capropvar.pElems[i].vt = VT_FILETIME;

                pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                       szOID_RSA_signingTime, 0);
                if (pattr != NULL)
                {
                    cb = sizeof(pValue->filetime);
                    Assert(pattr->cValue == 1);

                    pVal = &(pattr->rgValue[0]);
                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                             pVal->pbData,
                                             pVal->cbData, 0, NULL,
                                             &pValue->capropvar.pElems[i].filetime,
                                             &cb))
                    {
                        hr = HrGetLastError();
                        MemFree(pValue->capropvar.pElems);
                        pValue->capropvar.pElems = NULL;
                        break;
                    }
                }
            }
        }
#else  // !SMIME_V3
        hr = HrCopyFiletimeArray(m_rOptions.rgftSigning, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_USER_VALIDITY:
        if (m_rOptions.cSigners)
        {
            pValue->ulVal = m_rOptions.rgulUserDef[0];
        } else {
            pValue->ulVal = 0;
        }
        break;

    case OID_SECURITY_USER_VALIDITY_RG:
        hr = HrCopyDwordArray(m_rOptions.rgulUserDef, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_RO_MSG_VALIDITY:
        if (m_rOptions.cSigners)
        {
            pValue->ulVal = m_rOptions.rgulROValid[0];
        } else {
            pValue->ulVal = 0;
        }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY_RG:
        hr = HrCopyDwordArray(m_rOptions.rgulROValid, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        pValue->ulVal = m_rOptions.ulEncodeFlags;
        break;

    case OID_SECURITY_CERT_INCLUDED:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCertWithMsg;
        break;

#ifndef _WIN64
    case OID_SECURITY_HWND_OWNER:
        pValue->ulVal = ULONG(m_rOptions.hwndOwner);
        break;
#endif  // _WIN64

    case OID_SECURITY_REQUESTED_CTE:
        pValue->lVal = m_rOptions.ietRequested;
        break;

    case OID_SECURITY_SIGNATURE_COUNT:
        pValue->ulVal = ULONG(m_rOptions.cSigners);
        break;

#ifdef SMIME_V3
    case OID_SECURITY_RECEIPT_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobReceipt, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_MESSAGE_HASH_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobMsgHash, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_KEY_PROMPT:
        ZeroMemory(&(pValue->pwszVal), sizeof(pValue->pwszVal));
        if (m_rOptions.pwszKeyPrompt != NULL)
                {
            pValue->pwszVal = PszDupW(m_rOptions.pwszKeyPrompt);
            if (NULL == pValue->pwszVal)
                hr = E_OUTOFMEMORY;
                }
        break;
#endif // SMIME_V3

    case OID_NOSECURITY_ONSAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fNoSecurityOnSave;
        break;

#ifdef _WIN65
// BriMo checkin at 01/22/99
    case OID_SECURITY_CERT_SIGNING2:
        if (m_rOptions.cSigners)
        {
            PCCERT_CONTEXT      pcCert = CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
            pValue->uhVal = *(ULARGE_INTEGER *)(&(pcCert));
        } else {
                ZeroMemory(&(pValue->uhVal), sizeof(pValue->uhVal));
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG2:
        hr = HrCopyIntoUlonglongArray((ULARGE_INTEGER *)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
        {
                        PCCERT_CONTEXT  pcCert = CertDuplicateCertificateContext((PCCERT_CONTEXT)(pValue->cauh.pElems[iLayer]));
            pValue->cauh.pElems[iLayer] = *(ULARGE_INTEGER *)(&(pcCert));
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION2:
                {
                        PCCERT_CONTEXT  pcCert = CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
            pValue->uhVal = *(ULARGE_INTEGER *)(&(pcCert));
                }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT2:
        hr = _CERTARRAYToCAUH(m_rOptions.caEncrypt, &pValue->cauh);
        break;

    case OID_SECURITY_HCERTSTORE2:
        ZeroMemory(&(pValue->uhVal), sizeof(pValue->uhVal));
        if (m_rOptions.hCertStore)
                {
                        HCERTSTORE      hCertStore = CertDuplicateStore(m_rOptions.hCertStore);

            pValue->uhVal = *(ULARGE_INTEGER *)(&(hCertStore));
                }
        break;

    case OID_SECURITY_RG_CERT_BAG2:
        hr = _CertStoreToCAUH(m_rOptions.hCertStore, &pValue->cauh);
        break;

    case OID_SECURITY_SEARCHSTORES2:
        hr = _STOREARRAYToCAUH(m_rOptions.saSearchStore, &pValue->cauh);
        break;

    case OID_SECURITY_RG_IASN2:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV2:
        pValue->uhVal = *(ULARGE_INTEGER *)(&(m_rOptions.hCryptProv));
        m_rOptions.hCryptProv = NULL;   // read-once
        break;
// End of BriMo check-in
#endif // _WIN65

#ifdef _WIN64
    case OID_SECURITY_HWND_OWNER_64:
        pValue->pulVal = (ULONG *)(m_rOptions.hwndOwner);
        break;
#endif _WIN64

    default:
        hr = m_pContainer->GetOption(oid, pValue);
        break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::InitNew(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release Lock Bytes
    EmptyData();

    // These flags are based on the data objects
    m_dwState = 0;

    // Change Size
    m_cbExternal = 0xFFFFFFFF;

    // Have I Created my property set yet ?
    if (NULL == m_pContainer)
    {
        // Create Init
        CHECKALLOC(m_pContainer = new CMimePropertyContainer);
    }

    // Reset the property set
    CHECKHR(hr = m_pContainer->InitNew());

    // Reset m_pCsetTagged
    m_pCsetTagged = NULL;

    // Reset Options
    _FreeOptions();

    // Reset to default options (this is probably a bug)
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));

    // (t-erikne) need to get this default at run time
    m_rOptions.hwndOwner = HWND_DESKTOP;

    // Reset Charset
    m_pCharset = CIntlGlobals::GetDefBodyCset();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::EmptyData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::EmptyData(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free current display name
    SafeMemFree(m_pszDisplay);

    // Do I have Data
    SafeRelease(m_rStorage.pUnkRelease);

    // Zero
    ZeroMemory(&m_rStorage, sizeof(BODYSTORAGE));

    // Removed CSETTAGGED state
    FLAGCLEAR(m_dwState, BODYSTATE_CSETTAGGED);
    FLAGCLEAR(m_dwState, BODYSTATE_EXTERNAL);

    // Change Size
    m_cbExternal = 0xFFFFFFFF;

    // Reset Encoding
    m_ietEncoding = IET_7BIT;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetState
// --------------------------------------------------------------------------------
void CMessageBody::SetState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::ClearState
// --------------------------------------------------------------------------------
void CMessageBody::ClearState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::ClearDirty
// --------------------------------------------------------------------------------
void CMessageBody::ClearDirty(void)
{
    ASSERTINIT;
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, BODYSTATE_DIRTY);
    m_pContainer->ClearState(COSTATE_DIRTY);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::IsType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsType(IMSGBODYTYPE type)
{
    // Locals
    HRESULT         hr;
    STATSTG         rStat;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Type
    if (IBT_SECURE == type)
    {
        // Is Secure Flag Set
        hr = (ISFLAGSET(m_dwState, BODYSTATE_SECURE)) ? S_OK : S_FALSE;
    }

    // Charset Tagged
    else if (IBT_CSETTAGGED == type)
    {
        hr = ISFLAGSET(m_dwState, BODYSTATE_CSETTAGGED) ? S_OK : S_FALSE;
    }

    // Is this an attachment
    else if (IBT_ATTACHMENT == type)
    {
        // If container returns IMF_ATTACHMENTS, it must be an attachment
        DWORD dw = m_pContainer->DwGetMessageFlags(m_rOptions.fHideTNEF);
        hr = (ISFLAGSET(dw, IMF_ATTACHMENTS) || ISFLAGSET(dw, IMF_HASVCARD)) ? S_OK : S_FALSE;
    }

    // Was AUTOATTACH
    else if (IBT_AUTOATTACH == type)
    {
        hr = (m_pNode && ISFLAGSET(m_pNode->dwState, NODESTATE_AUTOATTACH)) ? S_OK : S_FALSE;
    }

    // Is the body empty
    else if (IBT_EMPTY == type)
    {
        // Body is not empty if it is a multipart with children
        if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK && m_pNode && m_pNode->cChildren > 0)
            hr = S_FALSE;
        else if (m_rStorage.pUnkRelease)
            hr = S_FALSE;
        else
            hr = S_OK;
    }

    // Error
    else
    {
        hr = TrapError(MIME_E_INVALID_BODYTYPE);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsDirty(void)
{
    ASSERTINIT;
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, BODYSTATE_DIRTY) || m_pContainer->IsDirty() == S_OK) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetOffsets
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetOffsets(LPBODYOFFSETS pOffsets)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == pOffsets)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pOffsets, sizeof(BODYOFFSETS));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not Bound
    if (NULL == m_pNode || (0 == m_pNode->cbBodyStart && 0 == pOffsets->cbBodyEnd))
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Get Offset Info
    pOffsets->cbBoundaryStart = m_pNode->cbBoundaryStart;
    pOffsets->cbHeaderStart = m_pNode->cbHeaderStart;
    pOffsets->cbBodyStart = m_pNode->cbBodyStart;
    pOffsets->cbBodyEnd = m_pNode->cbBodyEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetEstimatedSize
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetEstimatedSize(ENCODINGTYPE ietEncoding, ULONG *pcbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSize=0;
    STATSTG         rStat;
    DOCCONVTYPE     dctConvert;
    ILockBytes     *plb=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(MIME_E_INVALID_ENCODINGTYPE);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If external..
    if (ISFLAGSET(m_dwState, BODYSTATE_EXTERNAL) && TRUE == m_rOptions.fExternalBody && 0xFFFFFFFF != m_cbExternal)
    {
        *pcbSize = m_cbExternal;
        goto exit;
    }

    // No internal lockbytes yet ?
    CHECKHR(hr = HrGetLockBytes(&plb));

    // Query m_pLockBytes Size
    CHECKHR(hr = plb->Stat(&rStat, STATFLAG_NONAME));
    cbSize = (ULONG)rStat.cbSize.QuadPart;

    // Otheriwse
    if (IET_CURRENT != ietEncoding)
    {
        // Compute ietEncoding type...
        dctConvert = g_rgConversionMap[m_pContainer->GetEncodingType()].rgDestType[ietEncoding];

        // Handle Conversion type
        if (DCT_ENCODE == dctConvert)
            cbSize = (ULONG)((cbSize * 4) / 3);
        else if (DCT_DECODE == dctConvert)
            cbSize = (ULONG)((cbSize * 3) / 4);
    }

    // Set Return Size
    *pcbSize = cbSize;

exit:
    // Cleanup
    SafeRelease(plb);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SaveToFile
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SaveToFile(ENCODINGTYPE ietEncoding, LPCSTR pszFilePath)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFilePathW=NULL;

    // Trace
    TraceCall("CMessageBody::SaveToFile");

    // Convert
    IF_NULLEXIT(pszFilePathW = PszToUnicode(CP_ACP, pszFilePath));

    // Do it as unicode
    IF_FAILEXIT(hr = SaveToFileW(ietEncoding, pszFilePathW));

exit:
    // Cleanup
    MemFree(pszFilePathW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageBody::SaveToFileW
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SaveToFileW(ENCODINGTYPE ietEncoding, LPCWSTR pszFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    LPSTREAM        pstmFile=NULL,
                    pstmBody=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(MIME_E_INVALID_ENCODINGTYPE);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call Get Data
    CHECKHR(hr = GetData(ietEncoding, &pstmBody));

    // Open File Stream
    CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFilePath, CREATE_ALWAYS, GENERIC_WRITE, &pstmFile));

    // Copy Stream
    CHECKHR(hr = _HrCopyDataStream(pstmBody, pstmFile));
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

    // Commit
    CHECKHR(hr = pstmFile->Commit(STGC_DEFAULT));

exit:
    // Cleanup
    SafeRelease(pstmFile);
    SafeRelease(pstmBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetData(ENCODINGTYPE ietEncoding, IStream **ppStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BODYSTREAMINIT  rStreamInit;
    CBodyStream    *pBodyStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init StreamInit
    ZeroMemory(&rStreamInit, sizeof(BODYSTREAMINIT));

    // Initialzie
    rStreamInit.ietExternal = ietEncoding;
    rStreamInit.ietInternal = m_ietEncoding;
    rStreamInit.fRemoveNBSP = m_rOptions.fRemoveNBSP;
    rStreamInit.pCharset    = m_pCharset;

    // Create a new body stream...
    CHECKALLOC(pBodyStream = new CBodyStream());

    // Initialize the body stream
    CHECKHR(hr = pBodyStream->HrInitialize(&rStreamInit, this));

    // Set return
    *ppStream = (IStream *)pBodyStream;
    (*ppStream)->AddRef();

exit:
    // Cleanup
    SafeRelease(pBodyStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetDataHere
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetDataHere(ENCODINGTYPE ietEncoding, IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    IStream    *pBodyStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the body stream
    CHECKHR(hr = GetData(ietEncoding, &pBodyStream));

    // Copy Stream
    CHECKHR(hr = _HrCopyDataStream(pBodyStream, pStream));
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

exit:
    // Cleanup
    SafeRelease(pBodyStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrCopyDataStream
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_HrCopyDataStream(IStream *pstmSource, IStream *pstmDest)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BYTE        rgBuffer[4096];
    ULONG       cbRead;
    DWORD       cbStream = 0;
    STATSTG     statstg;

    // Invalid Arg
    Assert(pstmSource && pstmDest);

    // get the size of the stream
    CHECKHR(pstmSource->Stat(&statstg, STATFLAG_NONAME));
    cbStream = statstg.cbSize.LowPart;

    // Loop for ever
    while(cbStream)
    {
        // Read a buffer
        CHECKHR(hr = pstmSource->Read(rgBuffer, ARRAYSIZE(rgBuffer), &cbRead));
        if (S_OK != hr)
            hrWarnings = TrapError(hr);

        // Done
        if (0 == cbRead)
            break;

        cbStream = cbStream - cbRead;

        // Write It
        CHECKHR(hr = pstmDest->Write(rgBuffer, cbRead, NULL));
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::HrGetLockBytes
// --------------------------------------------------------------------------------
HRESULT CMessageBody::HrGetLockBytes(ILockBytes **ppLockBytes)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    Assert(ppLockBytes);

    // Init
    *ppLockBytes = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_rStorage.pUnkRelease)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // IID_ILockBytes
    if (IID_ILockBytes == m_rStorage.riid)
    {
        // AddRef It
        *ppLockBytes = m_rStorage.pLockBytes;
        (*ppLockBytes)->AddRef();
    }

    // IID_IMimeWebDocument
    else if (IID_IMimeWebDocument == m_rStorage.riid)
    {
        // BindToStorage
        CHECKHR(hr = m_rStorage.pWebDocument->BindToStorage(IID_ILockBytes, (LPVOID *)ppLockBytes));

        // Lets Cache ppLockBytes
        SafeRelease(m_rStorage.pUnkRelease);

        // Assume the lock bytes
        m_rStorage.pLockBytes = (*ppLockBytes);
        m_rStorage.pLockBytes->AddRef();

        // Set pUnkRelease
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;

        // Set Storage Id
        m_rStorage.riid = IID_ILockBytes;
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetData(ENCODINGTYPE ietEncoding, LPCSTR pszPriType, LPCSTR pszSubType,
    REFIID riid, LPVOID pvObject)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pvObject || ietEncoding >= IET_UNKNOWN || FALSE == FBODYSETDATAIID(riid))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If multipart...
    if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // RAID-29817: Only fail if there are children
        if (m_pNode && m_pNode->cChildren > 0)
        {
            hr = TrapError(MIME_E_MULTIPART_NO_DATA);
            goto exit;
        }

        // Lets adjust the Content-Type to application/octet-stream now so that things don't get confused
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM));
    }

    // Release current m_pLockBytes
    EmptyData();

    // IID_IStream
    if (IID_IStream == riid)
    {
        // New CBodyLockBytes
        CHECKALLOC(m_rStorage.pLockBytes = new CStreamLockBytes((IStream *)pvObject));

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    }

    // IID_ILockBytes
    else if (IID_ILockBytes == riid)
    {
        // Just assume it
        m_rStorage.pLockBytes = (ILockBytes *)pvObject;
        m_rStorage.pLockBytes->AddRef();

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    }

    // IID_IMimeBody
    else if (IID_IMimeBody == riid)
    {
        // CopyTo
        CHECKHR(hr = ((IMimeBody *)pvObject)->CopyTo(this));
    }

    // IID_IMimeMessage
    else if (IID_IMimeMessage == riid)
    {
        // Locals
        IMimePropertySet *pProps;
        IMimeMessage *pMessage=(IMimeMessage *)pvObject;

        // Get the message source
        CHECKHR(hr = pMessage->GetMessageSource(&pStream, 0));

        // New CBodyLockBytes
        CHECKALLOC(m_rStorage.pLockBytes = new CStreamLockBytes(pStream));

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;

        // Set Content Type message/rfc822
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822));

        // Get Root Property Container
        if (SUCCEEDED(pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pProps)))
        {
            // Locals
            MIMEPROPINFO rPropInfo;

            // I don't actualy want any props, just want to know if its set
            rPropInfo.dwMask = 0;

            // News Message ?
            if (SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &rPropInfo)) ||
                SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_XNEWSRDR), &rPropInfo)) ||
                SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUP), &rPropInfo)))
                m_pContainer->SetState(COSTATE_RFC822NEWS);
            else
                m_pContainer->ClearState(COSTATE_RFC822NEWS);

            // Release
            pProps->Release();
        }
    }

    // IID_IMimeWebDocument
    else if (IID_IMimeWebDocument == riid)
    {
        // Just assume it
        m_rStorage.pWebDocument = (IMimeWebDocument *)pvObject;
        m_rStorage.pWebDocument->AddRef();

        // Set m_rStorage type
        m_rStorage.riid = IID_IMimeWebDocument;
        m_rStorage.pUnkRelease = m_rStorage.pWebDocument;
    }

    // Save The Format
    m_ietEncoding = ietEncoding;

    // Save Format per bert
    if (g_rgEncodingMap[ietEncoding].pszName)
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTXFER, g_rgEncodingMap[ietEncoding].pszName));

    // Set PriType
    if (pszPriType)
        CHECKHR(hr = m_pContainer->SetProp(SYM_ATT_PRITYPE, pszPriType));

    // Set SubType
    if (pszSubType)
        CHECKHR(hr = m_pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

    // Assume The User is now controlling the Character Set Properties of this body
    FLAGCLEAR(m_dwState, BODYSTATE_CSETTAGGED);

    // We are now dirty
    FLAGSET(m_dwState, BODYSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CMessageBody::SetDataW(ENCODINGTYPE ietEncoding, LPCWSTR pwszPriType, LPCWSTR pwszSubType,
    REFIID riid, LPVOID pvObject)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::CopyTo(IMimeBody *pBodyIn)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEBODY   pBody=NULL;
    LPCONTAINER     pContainer=NULL;

    // Invalid Arg
    if (NULL == pBodyIn)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for Private CMessageBody
    CHECKHR(hr = pBodyIn->QueryInterface(IID_CMessageBody, (LPVOID *)&pBody));

    // Thread Safety
    EnterCriticalSection(&pBody->m_cs);

    // Copy Data Over
    pBody->m_dwState = m_dwState;

    // Release Current Data
    pBody->EmptyData();

    // Copy body props
    CHECKHR(hr = m_pContainer->Clone(&pContainer));

    // Release the Bodies' Current Container
    SafeRelease(pBody->m_pContainer);

    // Reset the Container
    pBody->m_pContainer = pContainer;
    pBody->m_pContainer->AddRef();

    // Assume new container in pNode
    if (pBody->m_pNode)
    {
        SafeRelease(pBody->m_pNode->pContainer);
        pBody->m_pNode->pContainer = pContainer;
        pContainer->AddRef();
    }

    // Copy Display Name
    if (m_pszDisplay)
        CHECKALLOC(pBody->m_pszDisplay = PszDupW(m_pszDisplay));

    // Copy Options

    // BUGBUG: This is pretty iffy.  BODYOPTIONS contains pointers, each of which should
    // be duplicated.  Caller beware!

    CopyMemory(&pBody->m_rOptions, &m_rOptions, sizeof(BODYOPTIONS));

    // Current Encoding
    pBody->m_ietEncoding = m_ietEncoding;

    // Charset
    pBody->m_pCharset = m_pCharset;

    // If we have data
    if (m_rStorage.pUnkRelease)
    {
        // IID_ILockBytes
        if (IID_ILockBytes == m_rStorage.riid)
        {
            pBody->m_rStorage.pLockBytes = m_rStorage.pLockBytes;
            pBody->m_rStorage.pLockBytes->AddRef();
            pBody->m_rStorage.pUnkRelease = pBody->m_rStorage.pLockBytes;
            pBody->m_rStorage.riid = IID_ILockBytes;
        }

        // IID_IMimeWebDocument
        else if (IID_IMimeWebDocument == m_rStorage.riid)
        {
            pBody->m_rStorage.pWebDocument = m_rStorage.pWebDocument;
            pBody->m_rStorage.pWebDocument->AddRef();
            pBody->m_rStorage.pUnkRelease = pBody->m_rStorage.pWebDocument;
            pBody->m_rStorage.riid = IID_IMimeWebDocument;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

exit:
    // Release Thread Safety
    if (pBody)
        LeaveCriticalSection(&pBody->m_cs);

    // Cleanup
    SafeRelease(pBody);
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetCurrentEncoding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetCurrentEncoding(ENCODINGTYPE ietEncoding)
{
    // Parameter Check
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set the current encoding
    m_ietEncoding = ietEncoding;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetCurrentEncoding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetCurrentEncoding(ENCODINGTYPE *pietEncoding)
{
    // Invalid Arg
    if (NULL == pietEncoding)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Return
    *pietEncoding = m_ietEncoding;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetTransmitInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetTransmitInfo(LPTRANSMITINFO pTransmit)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    ULONG           cbRead,
                    cbLine=0,
                    cEscapeChars=0,
                    i;
    BYTE            rgBuffer[4096];
    LPSTREAM        pStream=NULL;
    BYTE            bPrev='\0';
    BOOL            fBadEOL=FALSE;
    DWORD           cbStream = 0;
    STATSTG         statstg;
    ASSERTINIT;

    // Parmaeters
    if (NULL == pTransmit)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(pTransmit, sizeof(TRANSMITINFO));

    // Set the current code page
    pTransmit->ietCurrent = m_ietEncoding;

    // Init Format
    pTransmit->ietXmitMime = IET_7BIT;
    pTransmit->ietXmit822  = IET_7BIT;

    // Don't call for multipart types...
    if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        Assert(FALSE);
        hr = TrapError(MIME_E_MULTIPART_NO_DATA);
        goto exit;
    }

    // Lets a binary stream of the data
    CHECKHR(hr = GetData(IET_INETCSET, &pStream));

    // get the size of the stream
    CHECKHR(pStream->Stat(&statstg, STATFLAG_NONAME));
    cbStream = statstg.cbSize.LowPart;

    // Scan It
    while(cbStream)
    {
        // Read a buffer
        CHECKHR(hr = pStream->Read(rgBuffer, sizeof(rgBuffer), &cbRead));
        if (S_OK != hr)
            hrWarnings = TrapError(hr);

        // Done
        if (0 == cbRead)
            break;

        cbStream = cbStream - cbRead;

        // Scan the buffer
        for (i=0; i<cbRead; i++, cbLine++)
        {
            // If End of line, reset line length
            if (chLF == rgBuffer[i])
            {
                // Count lines
                pTransmit->cLines++;
                cbLine = 0;

                // Raid-41839: x-bitmap images are not correctly transferred via Schotzie
                // Don't write out lines that end with only a \n, not legal
                if (chCR != bPrev)
                    fBadEOL = TRUE;
            }

            // Line too long
            if (cbLine > pTransmit->cbLongestLine)
                pTransmit->cbLongestLine++;

            // Tests for extended and control characters
            if (IS_EXTENDED(rgBuffer[i]))
            {
                // Count Extneded
                pTransmit->cExtended++;

                // Count Escape Characters
                if (0x1B == rgBuffer[i])
                    cEscapeChars++;
            }

            // Save Previous
            bPrev = rgBuffer[i];
        }

        // Increment Total
        pTransmit->cbSize += cbRead;
    }

    // No Data ?
    if (0 == pTransmit->cbSize)
    {
        pTransmit->ulPercentExt = 0;
        goto exit;
    }

    // RAID-22542: FE-J:Athena:mail:sending mail with text/plain  has Content-transfer-encording:8bit
    if (FALSE == m_rOptions.fDBCSEscape8 && cEscapeChars > 0 && m_pCharset && g_pInternat->IsDBCSCharset(m_pCharset->hCharset) == S_OK)
    {
        // Subtract the Number of EscapeChars off of the number of extended chars
        Assert(cEscapeChars <= pTransmit->cExtended);
        pTransmit->cExtended -= cEscapeChars;
    }

    if (IET_UNKNOWN == m_rOptions.ietTransmit)
    {
        // More than 25% extended characters
        pTransmit->ulPercentExt = ((pTransmit->cExtended * 100) / pTransmit->cbSize);

        // Raid-41839: x-bitmap images are not correctly transferred via Schotzie
        // More than 17 percent extended
        if (pTransmit->ulPercentExt > 17)
        {
            pTransmit->ietXmitMime = IET_BASE64;
            pTransmit->ietXmit822  = IET_UUENCODE;
        }

        // Some Extended Characters or line longer than max
        else if (pTransmit->cExtended || pTransmit->cbLongestLine > m_rOptions.cbMaxLine || TRUE == fBadEOL)
        {
            pTransmit->ietXmitMime = IET_QP;
            pTransmit->ietXmit822  = IET_7BIT;
        }

        // Otherwise, 7bit
        else
        {
            pTransmit->ietXmitMime = IET_7BIT;
            pTransmit->ietXmit822  = IET_7BIT;
        }
    }
    else
    {
        // the client specifically set this option, so honor it
        pTransmit->ietXmitMime = m_rOptions.ietTransmit;

        // we may need to fixup ietXmit822 if the XmitMime
        // option does not make sense for it
        switch (m_rOptions.ietTransmit)
        {
            case IET_BASE64:
                pTransmit->ietXmit822 = IET_UUENCODE;
                break;
            case IET_QP:
                pTransmit->ietXmit822 = IET_7BIT;
                break;
            default:
                pTransmit->ietXmit822 = m_rOptions.ietTransmit;
                break;
        }
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SwitchContainers
// --------------------------------------------------------------------------------
void CMessageBody::SwitchContainers(CMessageBody *pBody)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);
    EnterCriticalSection(&pBody->m_cs);

    // Invalid Arg
    Assert(pBody && pBody->m_pContainer && m_pContainer && m_pNode && pBody->m_pNode);

    // Simple Varialbe Swap
    LPCONTAINER pTemp = m_pContainer;
    m_pNode->pContainer = m_pContainer = pBody->m_pContainer;
    pBody->m_pNode->pContainer = pBody->m_pContainer = pTemp;

    // Thread Safety
    LeaveCriticalSection(&pBody->m_cs);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::GetHandle
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetHandle(LPHBODY phBody)
{
    // Local
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Not Bound...
    if (NULL == m_pNode || NULL == m_pNode->hBody)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // Set Handle
    *phBody = m_pNode->hBody;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetClassID
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetClassID(CLSID *pClassID)
{
    ASSERTINIT;

    // Parmaeters
    if (NULL == pClassID)
        return TrapError(E_INVALIDARG);

    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimeBody, sizeof(CLSID));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetSizeMax
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cbSize;
    ASSERTINIT;

    // Get The Size
    CHECKHR(hr = GetEstimatedSize(IET_BINARY, &cbSize));

    // Return the Size
    pcbSize->QuadPart = cbSize;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Load(LPSTREAM pStream)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Load(pStream));
}

// ---------------------------------------------------------------------------
// CMessageBody::Load
// ---------------------------------------------------------------------------
HRESULT CMessageBody::Load(CInternetStream *pInternet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Load(pInternet));
}

// --------------------------------------------------------------------------------
// CMessageBody::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Save(pStream, fClearDirty));
}

// --------------------------------------------------------------------------------
// CMessageBody::IsContentType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    ASSERTINIT;
    return TrapError(m_pContainer->IsContentType(pszPriType, pszSubType));
}

// --------------------------------------------------------------------------------
// CMessageBody::GetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetCharset(LPHCHARSET phCharset)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetCharset(phCharset));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Lookiup Charset Info
    if (FALSE == g_pInternat->FIsValidHandle(hCharset))
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // If I'm already tagged with a charset, and applytype is CSET_APPLY_UNTAGGED, then leave
    if (ISFLAGSET(m_dwState, BODYSTATE_SKIPCSET) == TRUE && CSET_APPLY_UNTAGGED == applytype)
        goto exit;

    // Pass it into the property set
    CHECKHR(hr = m_pContainer->SetCharset(hCharset, applytype));

    // If I'm already tagged with a charset, and applytype is CSET_APPLY_UNTAGGED, then leave
    if (ISFLAGSET(m_dwState, BODYSTATE_CSETTAGGED) == TRUE && CSET_APPLY_UNTAGGED == applytype)
        goto exit;

    // Save the character set...
    SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

    // Mark as Tagged
    if (CSET_APPLY_TAG_ALL == applytype)
    {
        // Mark the body as being tagged with a charset

        // Get Internal Character Set
        if (SUCCEEDED(m_pContainer->GetCharset(&hCharset)))
        {
            // Get Pointer
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

            // Save this as m_pCsetTagged
            m_pCsetTagged = m_pCharset;
        }

        // I was tagged with a charset
        FLAGSET(m_dwState, BODYSTATE_CSETTAGGED);

        // Mark the charset as explicitly set
        FLAGSET(m_dwState, BODYSTATE_SKIPCSET);
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetProp(pszName, dwFlags, pValue));
}

// ---------------------------------------------------------------------------
// CMessageBody::AppendProp
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->AppendProp(pszName, dwFlags, pValue));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->SetProp(pszName, dwFlags, pValue));
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::DeleteProp(LPCSTR pszName)
{
    ASSERTINIT;
    return TrapError(m_pContainer->DeleteProp(pszName));
}

// ---------------------------------------------------------------------------
// CMessageBody::QueryProp
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    ASSERTINIT;
    return TrapError(m_pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive));
}

// --------------------------------------------------------------------------------
// CMessageBody::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Clone(IMimePropertySet **ppPropertySet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Clone(ppPropertySet));
}

// --------------------------------------------------------------------------------
// CMessageBody::BindToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::BindToObject(REFIID riid, void **ppvObject)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IID_IStream
    if (IID_IStream == riid)
    {
        // Get Data...
        CHECKHR(hr = GetData(IET_INETCSET, (IStream **)ppvObject));
    }

    // IID_IUnicodeStream
    else if (IID_IUnicodeStream == riid)
    {
        // Get Data...
        CHECKHR(hr = GetData(IET_UNICODE, (IStream **)ppvObject));
    }

    // IID_IMimeMessage... (returns message/rfc822 or message/partial bodies)
    else if (IID_IMimeMessage == riid)
    {
        // Better be message/rfc822 or message/partial...
        if (m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_RFC822) == S_OK ||
            m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
        {
            // Locals
            LPSTREAM        pstmMsg=NULL;
            IMimeMessage   *pMessage=NULL;

            // Create a message object
            CHECKHR(hr = MimeOleCreateMessage(NULL, &pMessage));

            // Get the body stream...
            hr = GetData(IET_BINARY, &pstmMsg);
            if (FAILED(hr))
            {
                pMessage->Release();
                TrapError(hr);
                goto exit;
            }

            // Load the message...
            hr = pMessage->Load(pstmMsg);
            if (FAILED(hr))
            {
                pstmMsg->Release();
                pMessage->Release();
                TrapError(hr);
                goto exit;
            }

            // Return the message
            *ppvObject = pMessage;
            ((IUnknown *)*ppvObject)->AddRef();

            // Cleanup
            SafeRelease(pstmMsg);
            SafeRelease(pMessage);
        }

        // Otherwise, fail
        else
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Otheriwse, do a normal QI of the body/property set
    else if (SUCCEEDED(QueryInterface(riid, ppvObject)))
        goto exit;

    // Otherwise, try to do a bindtoobject on the container
    else if (SUCCEEDED(m_pContainer->BindToObject(riid, ppvObject)))
        goto exit;

    // Not Found
    else
        hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteExcept
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::DeleteExcept(ULONG cNames, LPCSTR *prgszName)
{
    ASSERTINIT;
    return TrapError(m_pContainer->DeleteExcept(cNames, prgszName));
}

// ---------------------------------------------------------------------------
// CMessageBody::GetParameters
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetParameters(pszName, pcParams, pprgParam));
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->CopyProps(cNames, prgszName, pPropSet));
}

// --------------------------------------------------------------------------------
// CMessageBody::MoveProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->MoveProps(cNames, prgszName, pPropSet));
}

// --------------------------------------------------------------------------------
// CMessageBody::GetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetPropInfo(pszName, pInfo));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo)
{
    ASSERTINIT;
    return TrapError(m_pContainer->SetPropInfo(pszName, pInfo));
}

// --------------------------------------------------------------------------------
// CMessageBody::EnumProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum)
{
    ASSERTINIT;
    return TrapError(m_pContainer->EnumProps(dwFlags, ppEnum));
}

// --------------------------------------------------------------------------------
// CMessageBody::DwGetFlags
// --------------------------------------------------------------------------------
DWORD CMessageBody::DwGetFlags(BOOL fHideTnef)
{
    DWORD dwFlags = 0;
    ASSERTINIT;

    dwFlags |= m_pContainer->DwGetMessageFlags(fHideTnef);

    // if it isn't x-pkcs7-mime, we already know the flags, so no need for the call
    // check the flag first b/c it is cheap
    if (dwFlags & IMF_SECURE &&
        (S_OK == m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
        S_OK == m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME)))
        dwFlags |= _GetSecureTypeFlags();
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMessageBody::_GetSecureTypeFlags
// --------------------------------------------------------------------------------
DWORD CMessageBody::_GetSecureTypeFlags()
{
    DWORD           dwSecType;
    DWORD           dwFlags;

    // if the data isn't ASN.1, then this call should fail
    if (SUCCEEDED(TrapError(CSMime::StaticGetMessageType(m_rOptions.hwndOwner,
        (IMimeBody *)this, &dwSecType))))
        {
        dwFlags = IMF_SECURE;
        if (MST_THIS_SIGN & dwSecType)
            dwFlags |= IMF_SIGNED;
        if (MST_THIS_ENCRYPT & dwSecType)
            dwFlags |= IMF_ENCRYPTED;
        }
    else
        dwFlags = 0;

    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyOptionsTo
// --------------------------------------------------------------------------------
void CMessageBody::CopyOptionsTo(CMessageBody *pBody, BOOL fNewOnwer /*=FALSE*/)
{
    // Locals
    ENCODINGTYPE ietTransmit;
    ASSERTINIT;

    // Valid State
    Assert(pBody);

    // critsec both bodies since we are using information on both
    EnterCriticalSection(&m_cs);
    EnterCriticalSection(&pBody->m_cs);

    // Copy Body Options
    pBody->m_rOptions = m_rOptions;

    // Raid 33207 - Preserve transmit body encoding
    ietTransmit = m_rOptions.ietTransmit;

    // If pBody->m_rOptions is the new owner, then clear my structure
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));

    // Raid 33207 - Restore transmit body encoding
    m_rOptions.ietTransmit = ietTransmit;

    LeaveCriticalSection(&pBody->m_cs);
    LeaveCriticalSection(&m_cs);
}

#ifndef _WIN64
// -----------------------------------------------------------------------------
// CMessageBody::_CAULToCertStore
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CAULToCertStore(const CAUL caul, HCERTSTORE * phcertstor)
{
    DWORD               i;

    //  Release the old store -- we don't want it anymore

    if (*phcertstor != NULL)
    {
        CertCloseStore(*phcertstor, 0);
        *phcertstor = NULL;
    }

    //  Create a new store if needed
    if (*phcertstor == NULL)
    {
        *phcertstor = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
    }

    if (*phcertstor == NULL)
    {
        return HrGetLastError();
    }

    for (i=0; i<caul.cElems; i++)
    {
        if (!CertAddCertificateContextToStore(*phcertstor,
                                              (PCCERT_CONTEXT) caul.pElems[i],
                                              CERT_STORE_ADD_ALWAYS, NULL))
        {
            return HrGetLastError();
        }
    }
    return S_OK;
}
#endif // _WIN64

// -----------------------------------------------------------------------------
// CMessageBody::_CertStoreToCAUL
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CertStoreToCAUL(const HCERTSTORE hcertstor, CAUL * pcaul)
{
    DWORD               cCerts = 0;
    PCCERT_CONTEXT      pccert = NULL;
    PCCERT_CONTEXT *    rgpccert;

    if (hcertstor != NULL)
    {
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
        {
            cCerts += 1;
        }
    }

    if (cCerts == 0)
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
        return S_OK;
    }

    pcaul->pElems = (ULONG *) g_pMalloc->Alloc(cCerts*sizeof(PCCERT_CONTEXT *));
    if (pcaul->pElems == NULL)
    {
        return TrapError(E_OUTOFMEMORY);
    }

    rgpccert = (PCCERT_CONTEXT *) pcaul->pElems;
    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
    {
        *rgpccert = CertDuplicateCertificateContext(pccert);
        rgpccert++;
    }

    pcaul->cElems = cCerts;
    return S_OK;
}

#ifndef SMIME_V3
// --------------------------------------------------------------------------------
// CMessageBody::_CAULToCERTARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAULToCERTARRAY(const CAUL caul, CERTARRAY *pca)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&pca->rgpCerts, caul.cElems*sizeof(PCCERT_CONTEXT))))
    {
        for (i = 0; i < pca->cCerts; i++)
            CertFreeCertificateContext(pca->rgpCerts[i]);

        pca->cCerts = caul.cElems;
        for (i = 0; i < caul.cElems; i++)
            pca->rgpCerts[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)caul.pElems[i]);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_CERTARRAYToCAUL
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CERTARRAYToCAUL(const CERTARRAY ca, CAUL *pcaul)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;

    if (ca.cCerts)
    {
        if ((pcaul->pElems = (ULONG*)(PCCERT_CONTEXT*)g_pMalloc->Alloc(ca.cCerts*sizeof(PCCERT_CONTEXT))))
        {
            pcaul->cElems = ca.cCerts;
            for (i = 0; i < ca.cCerts; i++)
                pcaul->pElems[i] = (ULONG)CertDuplicateCertificateContext(ca.rgpCerts[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
    }

    // Done
    return hr;
}
#endif // !SMIEM_V3

#ifndef _WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_CAULToSTOREARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAULToSTOREARRAY(const CAUL caul, STOREARRAY *psa)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&psa->rgStores, caul.cElems*sizeof(HCERTSTORE))))
    {
        for (i = 0; i < psa->cStores; i++)
            CertCloseStore(psa->rgStores[i], 0);

        psa->cStores = caul.cElems;
        for (i = 0; i < caul.cElems; i++)
            psa->rgStores[i] = CertDuplicateStore((HCERTSTORE)caul.pElems[i]);
    }

    // Done
    return hr;
}
#endif // _WIN64

#ifndef _WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_STOREARRAYToCAUL
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_STOREARRAYToCAUL(const STOREARRAY sa, CAUL *pcaul)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;

    if (sa.cStores)
    {
        if ((pcaul->pElems = (ULONG*)(HCERTSTORE*)g_pMalloc->Alloc(sa.cStores*sizeof(HCERTSTORE))))
        {
            pcaul->cElems = sa.cStores;
            for (i = 0; i < sa.cStores; i++)
                pcaul->pElems[i] = (ULONG)CertDuplicateStore(sa.rgStores[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
    }

    // Done
    return hr;
}
#endif // _WIN64

// -----------------------------------------------------------------------------
// CMessageBody::_CAUHToCertStore
// -----------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToCertStore(const CAUH cauh, HCERTSTORE * phcertstor)
{
    DWORD               i;

#ifndef NEED             // This prevent us from send 2 certificates.
    //  Release the old store -- we don't want it anymore

    if (*phcertstor != NULL)
    {
        CertCloseStore(*phcertstor, 0);
        *phcertstor = NULL;
    }
#endif

    //  Create a new store if needed
    if (*phcertstor == NULL)
    {
        *phcertstor = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
    }

    if (*phcertstor == NULL)
    {
        return HrGetLastError();
    }

    for (i=0; i<cauh.cElems; i++)
    {
        if (!CertAddCertificateContextToStore(*phcertstor,
                                              *(PCCERT_CONTEXT *) (&(cauh.pElems[i])),
                                              CERT_STORE_ADD_ALWAYS, NULL))
        {
            return HrGetLastError();
        }
    }
    return S_OK;
}

// -----------------------------------------------------------------------------
// CMessageBody::_CertStoreToCAUH
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CertStoreToCAUH(const HCERTSTORE hcertstor, CAUH * pcauh)
{
    DWORD               cCerts = 0;
    PCCERT_CONTEXT      pccert = NULL;
    PCCERT_CONTEXT *    rgpccert;

    if (hcertstor != NULL)
    {
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
        {
            cCerts += 1;
        }
    }

    if (cCerts == 0)
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
        return S_OK;
    }

    pcauh->pElems = (ULARGE_INTEGER *) g_pMalloc->Alloc(cCerts*sizeof(PCCERT_CONTEXT *));
    if (pcauh->pElems == NULL)
    {
        return TrapError(E_OUTOFMEMORY);
    }

    rgpccert = (PCCERT_CONTEXT *) pcauh->pElems;
    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
    {
        *rgpccert = CertDuplicateCertificateContext(pccert);
        rgpccert++;
    }

    pcauh->cElems = cCerts;
    return S_OK;
}

#ifdef _WIN65
// --------------------------------------------------------------------------------
// CMessageBody::_CAUHToCERTARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToCERTARRAY(const CAUH cauh, CERTARRAY *pca)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&pca->rgpCerts, cauh.cElems*sizeof(PCCERT_CONTEXT))))
    {
        for (i = 0; i < pca->cCerts; i++)
            CertFreeCertificateContext(pca->rgpCerts[i]);

        pca->cCerts = cauh.cElems;
        for (i = 0; i < cauh.cElems; i++)
            pca->rgpCerts[i] = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(cauh.pElems[i])));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_CERTARRAYToCAUH
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CERTARRAYToCAUH(const CERTARRAY ca, CAUH *pcauh)
{
    // Locals
    HRESULT                             hr = S_OK;
    register DWORD              i;
    PCCERT_CONTEXT *    rgpccert = NULL;

    if (ca.cCerts)
    {
        if ((pcauh->pElems = (ULARGE_INTEGER *)g_pMalloc->Alloc(ca.cCerts*sizeof(PCCERT_CONTEXT))))
        {
            pcauh->cElems = ca.cCerts;
                        rgpccert = *(PCCERT_CONTEXT **)(&(pcauh->pElems));
            for (i = 0; i < ca.cCerts; i++)
                rgpccert[i] = CertDuplicateCertificateContext(ca.rgpCerts[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
    }

    // Done
    return hr;
}
#endif // _WIN65

// --------------------------------------------------------------------------------
// CMessageBody::_CAUHToSTOREARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToSTOREARRAY(const CAUH cauh, STOREARRAY *psa)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&psa->rgStores, cauh.cElems*sizeof(HCERTSTORE))))
    {
        for (i = 0; i < psa->cStores; i++)
            CertCloseStore(psa->rgStores[i], 0);

        psa->cStores = cauh.cElems;
        for (i = 0; i < cauh.cElems; i++)
            psa->rgStores[i] = CertDuplicateStore(*(HCERTSTORE *)(&(cauh.pElems[i])));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_STOREARRAYToCAUH
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_STOREARRAYToCAUH(const STOREARRAY sa, CAUH *pcauh)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;
        HCERTSTORE *    rgStores = NULL;

    if (sa.cStores)
    {
        if ((pcauh->pElems = (ULARGE_INTEGER *)g_pMalloc->Alloc(sa.cStores*sizeof(HCERTSTORE))))
        {
            pcauh->cElems = sa.cStores;
                        rgStores = *(HCERTSTORE **)(&(pcauh->pElems));
            for (i = 0; i < sa.cStores; i++)
                rgStores[i] = CertDuplicateStore(sa.rgStores[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
    }

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CMessageBody::_FreeOptions
// --------------------------------------------------------------------------------
void CMessageBody::_FreeOptions()
{
    DWORD i;

    if (m_rOptions.cSigners)
    {
        // OID_SECURITY_ALG_HASH
        SafeMemFree(m_rOptions.rgblobHash[0].pBlobData);

        // OID_SECURITY_CERT_SIGNING
        for (i = 0; i < m_rOptions.cSigners; i++)
        {
            CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);

#ifdef SMIME_V3
            //  Attributes
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i]);
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i]);

            // OID_SECURITY_RECEIPT_RG
            SafeMemFree(m_rOptions.rgblobReceipt[i].pBlobData);
            // OID_SECURITY_MESSAGE_HASH_RG
            SafeMemFree(m_rOptions.rgblobMsgHash[i].pBlobData);
            // OID_SECURITY_KEY_PROMPT
            SafeMemFree(m_rOptions.pwszKeyPrompt);
#else  // !SMIME_V3
            // OID_SECURITY_SYMCAPS
            SafeMemFree(m_rOptions.rgblobSymCaps[i].pBlobData);

            // OID_SECURITY_AUTHATTR
            SafeMemFree(m_rOptions.rgblobAuthAttr[i].pBlobData);

            // OID_SECURITY_UNAUTHATTR
            SafeMemFree(m_rOptions.rgblobUnauthAttr[i].pBlobData);
#endif // SMIME_V3
        }

        // OID_SECURITY_HCERTSTORE
        CertCloseStore(m_rOptions.hCertStore, 0);

        _FreeLayerArrays();

        if (m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED] != NULL) {
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED][0]);
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED]);
        }
    }

    // OID_SECURITY_ALG_BULK
    SafeMemFree(m_rOptions.blobBulk.pBlobData);

    // OID_SECURITY_CERT_DECRYPTION
    if (m_rOptions.pcCertDecryption)
        CertFreeCertificateContext(m_rOptions.pcCertDecryption);

#ifdef SMIME_V3
    if (m_rOptions.rgRecipients != 0)
    {
        for (i=0; i<m_rOptions.cRecipients; i++)
        {
            FreeRecipientInfoContent(&m_rOptions.rgRecipients[i]);
        }
    }
    SafeMemFree(m_rOptions.rgRecipients);
    m_rOptions.cRecipients = 0;
    m_rOptions.cRecipsAllocated = 0;
#else  // SMIME_V3
    // OID_SECURITY_RG_CERT_ENCRYPT
    for (i=0; i<m_rOptions.caEncrypt.cCerts; i++)
        CertFreeCertificateContext(m_rOptions.caEncrypt.rgpCerts[i]);
    SafeMemFree(m_rOptions.caEncrypt.rgpCerts);
#endif // !SMIEM_V3

    // OID_SECURITY_SEARCHSTORES
    for (i=0; i<m_rOptions.saSearchStore.cStores; i++)
        CertCloseStore(m_rOptions.saSearchStore.rgStores[i], 0);
    SafeMemFree(m_rOptions.saSearchStore.rgStores);

    // OID_SECURITY_RG_IASN
    // nyi

    // OID_SECURITY_HCRYPTPROV
    if (m_rOptions.hCryptProv)
        CryptReleaseContext(m_rOptions.hCryptProv, 0);

    return;
}

#ifdef _WIN64
#define REALLOC_AND_INIT_OPTION(Option)                                                 \
    if (FAILED(hr = HrRealloc((void**)&Option, LcbAlignLcb(ulLayers * sizeof(*Option))))) {          \
        goto exit;                                                                      \
    }                                                                                   \
    ZeroMemory(&Option[m_rOptions.cSigners], LcbAlignLcb((ulLayersNew) * sizeof(*Option)));
#else
#define REALLOC_AND_INIT_OPTION(Option)                                                 \
    if (FAILED(hr = HrRealloc((void**)&Option, ulLayers * sizeof(*Option)))) {          \
        goto exit;                                                                      \
    }                                                                                   \
    ZeroMemory(&Option[m_rOptions.cSigners], (ulLayersNew) * sizeof(*Option));
#endif //_WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_HrEnsureBodyOptionLayers
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_HrEnsureBodyOptionLayers(ULONG ulLayers)
{
    HRESULT hr = S_OK;
    ULONG ulLayersNew = ulLayers - m_rOptions.cSigners;

    if (m_rOptions.cSigners < ulLayers)
    {
        // Time to grow the arrays
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobHash);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgpcCertSigning);
#ifdef SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED]);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED]);
#else  // !SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobSymCaps);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobAuthAttr);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobUnauthAttr);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgftSigning);
#endif // SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgulUserDef);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgulROValid);
#ifdef SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobReceipt);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobMsgHash);
#endif // SMIME_V3

        m_rOptions.cSigners = ulLayers;
    }

exit:
    return(hr);
}


HRESULT CMessageBody::_HrEnsureBodyOptionLayers(LPCPROPVARIANT ppv)
{
    CAUL * pcaul = (CAUL *)&ppv->caul;

    return(_HrEnsureBodyOptionLayers(pcaul->cElems));
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrEnsureBodyOptionLayers
// --------------------------------------------------------------------------------
void CMessageBody::_FreeLayerArrays(void)
{
    if (m_rOptions.cSigners)
    {
        SafeMemFree(m_rOptions.rgblobHash);
        SafeMemFree(m_rOptions.rgpcCertSigning);
#ifdef SMIME_V3
        SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED]);
        SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED]);
#else  // !SMIME_V3
        SafeMemFree(m_rOptions.rgblobSymCaps);
        SafeMemFree(m_rOptions.rgblobAuthAttr);
        SafeMemFree(m_rOptions.rgblobUnauthAttr);
        SafeMemFree(m_rOptions.rgftSigning);
#endif // SMIME_V3
        SafeMemFree(m_rOptions.rgulUserDef);
        SafeMemFree(m_rOptions.rgulROValid);
#ifdef SMIME_V3
        SafeMemFree(m_rOptions.rgblobReceipt);
        SafeMemFree(m_rOptions.rgblobMsgHash);
#endif // SMIME_V3
        m_rOptions.cSigners = 0;
    }
}


HRESULT CMessageBody::_CompareCopyBlobArray(const PROPVARIANT FAR * pvSource, BLOB FAR * FAR * prgblDestination, BOOL fNoDirty)
{
    HRESULT hr = S_OK;
    ULONG i;
    BOOL fReplace;
    CAPROPVARIANT capropvar = pvSource->capropvar;
    ULONG ulSize = capropvar.cElems;

    Assert(ulSize == m_rOptions.cSigners);
    Assert(*prgblDestination);

    if (ulSize == m_rOptions.cSigners)
    {
        for (i = 0; i < ulSize; i++)
        {
            if ((*prgblDestination)[i].pBlobData)
            {
                if (fReplace = CompareBlob(&(*prgblDestination)[i], (BLOB FAR *)&capropvar.pElems[i]))
                {
                    ReleaseMem((VOID FAR *)(*prgblDestination)[i].pBlobData);
                }
            } else {
                fReplace = TRUE;
            }

            if (fReplace)
            {
                if (FAILED(hr = HrCopyBlob(&(capropvar.pElems[i].blob), &(*prgblDestination)[i])))
                {
                    goto exit;
                }

                if (!fNoDirty)
                {
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
    } else {
        hr = E_INVALIDARG;
    }
exit:
    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyBlobArray
//
// Allocate a new propvariant blob array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyBlobArray(LPCBLOB pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    // Locals
    HRESULT hr = S_OK;
    CAPROPVARIANT * pcapropvar;
    PROPVARIANT * ppv;
    ULONG i;

    pvOut->vt = VT_VECTOR | VT_VARIANT;
    pcapropvar = &pvOut->capropvar;
    pcapropvar->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&ppv, cEntries * sizeof(PROPVARIANT))))
        {
            goto exit;
        }

        pcapropvar->pElems = ppv;

        // Fill in the array of BLOBs
        for (i = 0; i < cEntries; i++)
        {
            ppv[i].vt = VT_BLOB;
            // HrCopyBlob allocates memory for the blob data.
            if (FAILED(hr = HrCopyBlob((BLOB FAR *)&pIn[i] , &ppv[i].blob)))
            {
                goto exit;
            }
        }
    } else {
        pcapropvar->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyArray
//
// Allocate a new array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyArray(LPBYTE pIn, ULONG cEntries, PROPVARIANT FAR * pvOut, ULONG cbElement)
{
    // Locals
    HRESULT hr = S_OK;
    BYTE * pb;
    ULONG i;
    ULONG cbArray = cEntries * cbElement;
    CAUL * pcaul = &pvOut->caul;

    pcaul->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&pb, cbArray)))
        {
            goto exit;
        }

        pcaul->pElems = (PULONG)pb;

        // Fill in the array of BLOBs
        memcpy(pb, pIn, cbArray);
    } else {
        pcaul->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyDwordArray
//
// Allocate a new dword array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyDwordArray(LPDWORD pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    pvOut->vt = VT_VECTOR | VT_UI4;
    return(HrCopyArray((LPBYTE)pIn, cEntries, pvOut, sizeof(DWORD)));
}

// --------------------------------------------------------------------------------
// HrCopyIntoUlonglongArray
//
// Allocate a new Ulonglong array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyIntoUlonglongArray(ULARGE_INTEGER *pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    // Locals
    HRESULT hr = S_OK;
    ULARGE_INTEGER * pullBuff;
    CAUH * pcauh = &pvOut->cauh;

    pvOut->vt = VT_VECTOR | VT_UI8;
    pcauh->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&pullBuff, cEntries * sizeof(ULARGE_INTEGER *))))
        {
            goto exit;
        }

        pcauh->pElems = (ULARGE_INTEGER *) pullBuff;

        // Fill in the array of BLOBs
        for (; cEntries > 0; cEntries--, pullBuff++, pIn++)
        {
            *pullBuff = *pIn;
        }
    }
    else
    {
        pcauh->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyFiletimeArray
//
// Allocate a new filetime array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyFiletimeArray(LPFILETIME pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    pvOut->vt = VT_VECTOR | VT_FILETIME;
    return(HrCopyArray((LPBYTE)pIn, cEntries, pvOut, sizeof(FILETIME)));
}


// --------------------------------------------------------------------------------
// MergeDWORDFlags
//
// Merge the flags from an array of DWORDs into one DWORD
// --------------------------------------------------------------------------------
DWORD MergeDWORDFlags(LPDWORD rgdw, ULONG cEntries)
{
    DWORD dwReturn = 0;

    for (ULONG i = 0; i < cEntries; i++)
    {
        dwReturn |= rgdw[i];
    }

    return(dwReturn);
}

#ifdef SMIME_V3

// --------------------------------------------------------------------------------
// CMessageBody::Encode
// --------------------------------------------------------------------------------

HRESULT CMessageBody::Encode(HWND hwnd, DWORD dwFlags)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::Decode
// --------------------------------------------------------------------------------

HRESULT CMessageBody::Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetRecipientCount
// --------------------------------------------------------------------------------

HRESULT CMessageBody::GetRecipientCount(DWORD dwFlags, DWORD * pdwRecipCount)
{
    Assert(dwFlags == 0);
    if (dwFlags != 0) return E_INVALIDARG;
    *pdwRecipCount = m_rOptions.cRecipients;
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::AddRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageBody::AddRecipient(DWORD dwFlags, DWORD cRecipData,
                                   PCMS_RECIPIENT_INFO precipData)
{
    DWORD       cbExtra;
    DWORD       dw;
    DWORD       dwCaps;
    HRESULT     hr;
    DWORD       i;

    Assert((dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL)) == 0);
    if ((dwFlags & (~SMIME_RECIPIENT_REPLACE_ALL)) != 0) return E_INVALIDARG;

    //
    //  Query capabilities
    //

    CHECKHR(hr = CapabilitiesSupported(&dwCaps));

    //
    //  Start by running the verification code on the structures.
    //

    for (i=0; i<cRecipData; i++)
    {
        switch(precipData[i].dwRecipientType)
        {
            //
            //  If you tell use that you don't know whats going on, then you must
            //  1. Give us a certificate
            //  2. If you don't specify an alg, we must recognize the alg in the cert
            //

        case CMS_RECIPIENT_INFO_TYPE_UNKNOWN:
            if (precipData[i].pccert == NULL)
            {
                hr = E_INVALIDARG;
                goto exit;
            }
            if (precipData[i].KeyEncryptionAlgorithm.pszObjId == NULL)
            {
                hr = _HrMapPublicKeyAlg(&precipData[i].pccert->pCertInfo->SubjectPublicKeyInfo,
                                        &dw, NULL);
                if (FAILED(hr))
                {
                    goto exit;
                }

                if (dw == CMS_RECIPIENT_INFO_TYPE_KEYTRANS) {
                    ;
                }
                else if (dw == CMS_RECIPIENT_INFO_TYPE_KEYAGREE) {
                    if (!(dwCaps & SMIME_SUPPORT_KEY_AGREE)) {
                        return MIME_E_SECURITY_NOTIMPLEMENTED;
                    }
                }
                else {
                    return E_INVALIDARG;
                }
            }
            break;

        //
        //  We have no requirements here.
        //
        case CMS_RECIPIENT_INFO_TYPE_KEYTRANS:
            break;

        case CMS_RECIPIENT_INFO_TYPE_KEYAGREE:
            if (!(dwCaps & SMIME_SUPPORT_KEY_AGREE)) {
                return MIME_E_SECURITY_NOTIMPLEMENTED;
            }
            break;

        //
        //  If you give use a mail list key, you must also tell us the
        //      public key identifier and the mail list key or we are going
        //      to fail big time
        //

        case CMS_RECIPIENT_INFO_TYPE_MAIL_LIST:
            if (!(dwCaps & SMIME_SUPPORT_MAILLIST)) {
                return MIME_E_SECURITY_NOTIMPLEMENTED;
            }
            if ((precipData[i].dwU1 != CMS_RECIPIENT_INFO_PUBKEY_PROVIDER) ||
                (precipData[i].dwU3 != CMS_RECIPIENT_INFO_KEYID_KEY_ID))
            {
                hr = E_INVALIDARG;
                goto exit;
            }
            break;

        default:
            Assert(FALSE);
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    //
    //

    if (dwFlags & SMIME_RECIPIENT_REPLACE_ALL)
    {
        for (i=0; i<m_rOptions.cRecipients; i++)
        {
            FreeRecipientInfoContent(&m_rOptions.rgRecipients[i]);
        }
        m_rOptions.cRecipients = 0;
    }

    //

    Assert(m_rOptions.cRecipients <= m_rOptions.cRecipsAllocated);
    if (m_rOptions.cRecipients >= m_rOptions.cRecipsAllocated)
    {
        hr = HrRealloc((LPVOID *) &m_rOptions.rgRecipients,
                       (m_rOptions.cRecipsAllocated+cRecipData+5)*sizeof(CMS_RECIPIENT_INFO));
        if (FAILED(hr))
        {
            goto exit;
        }
        m_rOptions.cRecipsAllocated += 5 + cRecipData;
    }

    //
    //  Do the actual copy of the data
    //

    CHECKHR(hr = _HrCopyRecipInfos(cRecipData, precipData,
                                   &m_rOptions.rgRecipients[m_rOptions.cRecipients]));

    m_rOptions.cRecipients += cRecipData;
    hr = S_OK;

exit:
    return hr;
}

// ------------------------------------------------------------------------------
// CMessageBody::_HrMapPublicKeyAlg
// ------------------------------------------------------------------------------

HRESULT CMessageBody::_HrMapPublicKeyAlg(CERT_PUBLIC_KEY_INFO * pkey, DWORD * pdw,
                                         CRYPT_ALGORITHM_IDENTIFIER ** ppalg)
{
    HRESULT     hr = E_INVALIDARG;

    static      CRYPT_ALGORITHM_IDENTIFIER      rgAlgs[] = {
        {szOID_RSA_RSA, {0, 0}},
        {szOID_RSA_SMIMEalgESDH, {0, 0}}
    };

    if (lstrcmp(pkey->Algorithm.pszObjId, szOID_RSA_RSA) == 0)
    {
        *pdw = CMS_RECIPIENT_INFO_TYPE_KEYTRANS;
        if (ppalg != NULL)
        {
            *ppalg = &rgAlgs[0];
        }
        hr = S_OK;
    }
    else if (lstrcmp(pkey->Algorithm.pszObjId, szOID_ANSI_X942_DH) == 0)
    {
        *pdw = CMS_RECIPIENT_INFO_TYPE_KEYAGREE;
        if (ppalg != NULL)
        {
            *ppalg = &rgAlgs[1];
        }
        hr = S_OK;
    }
    else {
        *pdw = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
    }
    return hr;
}

// ------------------------------------------------------------------------------
// CMessageBody::_HrCopyRecipInfos
// ------------------------------------------------------------------------------

HRESULT CMessageBody::_HrCopyRecipInfos(DWORD cItems,
                                        const CMS_RECIPIENT_INFO * precipSrc,
                                        PCMS_RECIPIENT_INFO precipDst)
{
    DWORD       cb;
    DWORD                               dw;
    HRESULT     hr;
    DWORD       i;
    CRYPT_ALGORITHM_IDENTIFIER *        palg;

    memset(precipDst, 0, cItems*sizeof(*precipDst));

    for (i=0; i<cItems; i++, precipSrc++, precipDst++)
    {
        //
        //  Now copy over the information
        //

        precipDst->dwRecipientType = precipSrc->dwRecipientType;

        if (precipSrc->pccert != NULL)
        {
            precipDst->pccert = CertDuplicateCertificateContext(
                                            (PCCERT_CONTEXT) precipSrc->pccert);
        }

        //  Move over the key encryption alg if it exists

        if (precipSrc->KeyEncryptionAlgorithm.pszObjId != NULL)
        {
            CHECKHR(hr = HrCopyOID(precipSrc->KeyEncryptionAlgorithm.pszObjId,
                                   &precipDst->KeyEncryptionAlgorithm.pszObjId));
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->KeyEncryptionAlgorithm.Parameters,
                                             &precipDst->KeyEncryptionAlgorithm.Parameters));
        }
        else {
            //
            //  If the data does not exist, then we need to create the data
            //  from scratch.  We do this by pulling information out of the
            //  certificate and create the algorithm information about this.
            //
            //  Maps RSA->RSA; DH -> smimeAlgESDH
            //

            Assert(precipSrc->pccert != NULL);
            hr = _HrMapPublicKeyAlg(&precipDst->pccert->pCertInfo->SubjectPublicKeyInfo,
                                    &dw, &palg);
            Assert(hr == S_OK);
            precipDst->dwRecipientType = dw;

            CHECKHR(hr = HrCopyCryptAlgorithm(palg, &precipDst->KeyEncryptionAlgorithm));
        }

        //
        //  Move over the aux encryption info if it exists.  The length has already
        //      been copied over
        //

        if (precipSrc->cbKeyEncryptionAuxInfo != 0)
        {
            CHECKHR(hr = HrAlloc(&precipDst->pvKeyEncryptionAuxInfo,
                                 precipSrc->cbKeyEncryptionAuxInfo));
        }

        //
        //  Copy over the subject key id information
        //

        precipDst->dwU1 = precipSrc->dwU1;
        switch (precipSrc->dwU1)
        {
        case CMS_RECIPIENT_INFO_PUBKEY_CERTIFICATE:
            if (precipDst->dwRecipientType == CMS_RECIPIENT_INFO_TYPE_KEYTRANS)
            {
                precipDst->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS;

                CHECKHR(hr = HrCopyCryptBitBlob(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                           &precipDst->u1.SubjectPublicKey));

            }
            else if (precipDst->dwRecipientType == CMS_RECIPIENT_INFO_TYPE_KEYAGREE)
            {
                precipDst->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE;

                CHECKHR(hr = HrCopyCryptBitBlob(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                           &precipDst->u1.u3.SubjectPublicKey));

                // precipDst->u1.u3.UserKeyingMaterial = NULL;

                CHECKHR(hr = HrCopyCryptAlgorithm(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm,
                           &precipDst->u1.u3.EphemeralAlgorithm));
            }
            else {
                hr = E_INVALIDARG;
                goto exit;
            }
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS:
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.SubjectPublicKey,
                                            &precipDst->u1.SubjectPublicKey));
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u1.u3.UserKeyingMaterial,
                                             &precipDst->u1.u3.UserKeyingMaterial));
            CHECKHR(hr = HrCopyCryptAlgorithm(&precipSrc->u1.u3.EphemeralAlgorithm,
                                              &precipDst->u1.u3.EphemeralAlgorithm));
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.u3.SubjectPublicKey,
                                            &precipDst->u1.u3.SubjectPublicKey));
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u1.u4.UserKeyingMaterial,
                                             &precipDst->u1.u4.UserKeyingMaterial));
            if (!CryptContextAddRef(precipSrc->u1.u4.hprov, 0, 0))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u4.hprov = precipSrc->u1.u4.hprov;
            precipDst->u1.u4.dwKeySpec = precipSrc->u1.u4.dwKeySpec;
            CHECKHR(hr = HrCopyCertId(&precipSrc->u1.u4.senderCertId,
                                      &precipDst->u1.u4.senderCertId));
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.u4.SubjectPublicKey,
                                            &precipDst->u1.u4.SubjectPublicKey));
            break;

            // hprov & hkey are already copied over
        case CMS_RECIPIENT_INFO_PUBKEY_PROVIDER:
            if (!CryptContextAddRef(precipDst->u1.u2.hprov, 0, 0))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u2.hprov = precipSrc->u1.u2.hprov;
            if (!CryptDuplicateKey(precipSrc->u1.u2.hkey, 0, 0,
                                   &precipDst->u1.u2.hkey))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u2.hkey = precipSrc->u1.u2.hkey;
            break;
        }

        precipDst->dwU3 = precipSrc->dwU3;
        switch (precipSrc->dwU3)
        {
        case CMS_RECIPIENT_INFO_KEYID_CERTIFICATE:
            precipDst->dwU3 = CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL;
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->pccert->pCertInfo->Issuer,
                                             &precipDst->u3.IssuerSerial.Issuer));
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->pccert->pCertInfo->SerialNumber,
                                             &precipDst->u3.IssuerSerial.SerialNumber));
            break;

        case CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL:
            CHECKHR(hr = HrCopyCryptDataBlob( &precipSrc->u3.IssuerSerial.Issuer,
                                              &precipDst->u3.IssuerSerial.Issuer));
            CHECKHR(hr = HrCopyCryptDataBlob( &precipSrc->u3.IssuerSerial.SerialNumber,
                                              &precipDst->u3.IssuerSerial.SerialNumber));
            break;

        case CMS_RECIPIENT_INFO_KEYID_KEY_ID:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u3.KeyId, &precipDst->u3.KeyId));
            break;
        }

        precipDst->filetime = precipSrc->filetime;
        if (precipSrc->pOtherAttr != NULL)
        {
            Assert(FALSE);
        }
    }

    hr = S_OK;
exit:
    return hr;
}


// ------------------------------------------------------------------------------
// CMessageBody::GetRecipient
// ------------------------------------------------------------------------------

HRESULT CMessageBody::GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData)
{
    DWORD                       cbAlloc;
    HRESULT                     hr;
    LPBYTE                      pb;
    PCMS_RECIPIENT_INFO         precip;

    if (iRecipient+cRecipients > m_rOptions.cRecipients)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    precip = &m_rOptions.rgRecipients[iRecipient];

    //
    //  Copy the buffer
    //

    CHECKHR(hr = _HrCopyRecipInfos(cRecipients, precip, pRecipData));
    hr = S_OK;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageBody::DeleteRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   DWORD iInstance, LPCSTR pszObjId,
                                   CRYPT_ATTRIBUTE ** ppattr)
{
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    DWORD               i1;
    PCRYPT_ATTRIBUTE    pattr = NULL;
    PCRYPT_ATTRIBUTES   pattrs;
    PCRYPT_ATTRIBUTE    pattrSrc;
    LPBYTE              pb;
    LPBLOB              pblob;

    //
    //  Start with some simple parameter checks
    //

    if ( // (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED)
    {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;
        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL)
            return S_FALSE;
    }
    else if (iSigner >= m_rOptions.cSigners)
    {
        return E_INVALIDARG;
    }

    //
    //  Special case of getting every single attribute on record
    //

    if (pszObjId == NULL) {
        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                 szOID_Microsoft_Attribute_Sequence,
                                 m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                                 0, NULL, NULL, &cb))
        {
            hr = HrGetLastError();
            goto exit;
        }

        if (!MemAlloc((LPVOID *) &pattr, cb + sizeof(CRYPT_ATTRIBUTE) +
                      sizeof(CRYPT_ATTR_BLOB))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pattr->cValue = 1;
        pattr->rgValue = (PCRYPT_ATTR_BLOB) &pattr[1];
        pb = (LPBYTE) &pattr->rgValue[1];

        pattr->pszObjId = NULL;
        pattr->rgValue[0].pbData = pb;
        pattr->rgValue[0].cbData = cb;

        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                 szOID_Microsoft_Attribute_Sequence,
                                 m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                                 0, NULL, pb, &cb))
        {
            hr = HrGetLastError();
            goto exit;
        }

        *ppattr = pattr;
        pattr = NULL;
        hr = S_OK;
        goto exit;
    }

    //
    //

    pattrSrc = _FindAttribute(m_rOptions.rgrgpattrs[iAttribSet][iSigner], pszObjId,
                           iInstance);
    if (pattrSrc != NULL)
    {
#ifdef _WIN64
        cb = sizeof(CRYPT_ATTRIBUTE) + LcbAlignLcb(strlen(pszObjId) + 1);
#else
        cb = sizeof(CRYPT_ATTRIBUTE) + strlen(pszObjId) + 1;
#endif 
        for (i1=0; i1<pattrSrc->cValue; i1++)
        {
            cb += sizeof(CRYPT_ATTR_BLOB);
#ifdef _WIN64
            cb += LcbAlignLcb(pattrSrc->rgValue[i1].cbData);
#else
            cb += pattrSrc->rgValue[i1].cbData;
#endif 
        }

        if (!MemAlloc((LPVOID *) &pattr, cb))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pattr->cValue = pattrSrc->cValue;
        pattr->rgValue = (PCRYPT_ATTR_BLOB) &pattr[1];
        pb = (LPBYTE) &pattr->rgValue[pattrSrc->cValue];

        pattr->pszObjId = (LPSTR) pb;
        cb = strlen(pszObjId)+1;
        memcpy(pattr->pszObjId, pszObjId, cb);
#ifdef _WIN64
		pb += LcbAlignLcb(cb);
#else
        pb += cb;
#endif //_WIN64

        for (i1=0; i1<pattrSrc->cValue; i1++)
        {
            pattr->rgValue[i1].pbData = pb;
            pattr->rgValue[i1].cbData = pattrSrc->rgValue[i1].cbData;
            memcpy(pb, pattrSrc->rgValue[i1].pbData,
                   pattrSrc->rgValue[i1].cbData);
#ifdef _WIN64
            pb += LcbAlignLcb(pattrSrc->rgValue[i1].cbData);
#else
            pb += pattrSrc->rgValue[i1].cbData;
#endif //_WIN64
        }

        *ppattr = pattr;
        pattr = NULL;
        hr = S_OK;
    }
    else {
        hr = S_FALSE;
    }

exit:
    if (pattr != NULL)          MemFree(pattr);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   const CRYPT_ATTRIBUTE * pattr)
{
    HRESULT     hr;
    DWORD       i;

    //
    //  Start with some simple parameter checks
    //

    if (// (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_ATTR_ADD_TO_EXISTING |
                    SMIME_ATTR_ADD_IF_NOT_EXISTS))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED) {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;

        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL) {
            if (!MemAlloc((LPVOID *) &m_rOptions.rgrgpattrs[iAttribSet],
                          sizeof(LPVOID))) {
                return E_OUTOFMEMORY;
            }

            m_rOptions.rgrgpattrs[iAttribSet][0] = NULL;
        }
    }
    else if ((iSigner >= m_rOptions.cSigners) && (iSigner != (DWORD) -1))
    {
        return E_INVALIDARG;
    }

    //
    //  Now make the correct utility call to put things right
    //

    Assert(pattr->cValue == 1);

    if (iSigner == (DWORD) -1)
    {
        Assert(iAttribSet != SMIME_ATTRIBUTE_SET_UNPROTECTED);

        for (i=0; i<m_rOptions.cSigners; i++)
        {
            hr = _HrSetAttribute(dwFlags, &m_rOptions.rgrgpattrs[iAttribSet][i],
                                 pattr->pszObjId, pattr->rgValue[0].cbData,
                                 pattr->rgValue[0].pbData);
            if (FAILED(hr))
            {
                break;
            }
        }
    }
    else {
        hr = _HrSetAttribute(dwFlags, &m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                             pattr->pszObjId, pattr->rgValue[0].cbData,
                             pattr->rgValue[0].pbData);
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::DeleteAttribute(DWORD dwFlags, DWORD iSigner,
                                      DWORD iAttribSet, DWORD iInstance,
                                      LPCSTR pszObjId)
{
    UINT                i;
    PCRYPT_ATTRIBUTE    pattr;
    PCRYPT_ATTRIBUTES   pattrs;

    //
    //  Start with some simple parameter checks
    //

    if (// (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED) {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;
        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL)
            return S_OK;
    }
    else if (iSigner >= m_rOptions.cSigners)
    {
        return E_INVALIDARG;
    }

    //

    pattrs = m_rOptions.rgrgpattrs[iAttribSet][iSigner];

    pattr = _FindAttribute(pattrs, pszObjId, iInstance);
    if (pattr != NULL)
    {
        i = (UINT) (pattr - &pattrs->rgAttr[0]);
        Assert( (0 <= ((int) i)) && (((int) i) < pattrs->cAttr));
        memcpy(pattr, pattr+1, (pattrs->cAttr - i - 1) * sizeof(CRYPT_ATTRIBUTE));
        pattrs->cAttr -= 1;
    }
    else {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CMessageBody::_SetNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD       cb;
    HRESULT     hr = S_OK;
    DWORD       i;
    LPBYTE      pb;

    if (pnames->rgNames != NULL)
    {
        MemFree(pnames->rgNames);
        pnames->rgNames = NULL;
        pnames->cNames = 0;
    }

    for (i=0, cb=cNames*sizeof(CERT_NAME_BLOB); i<cNames; i++)
#ifdef _WIN64
		cb += LcbAlignLcb(rgNames[i].cbData);
#else
        cb += rgNames[i].cbData;
#endif //_WIN64

    CHECKHR(hr = HrAlloc((LPVOID *)&pnames->rgNames, cb));

    pb = (LPBYTE) &pnames->rgNames[cNames];
    for (i=0; i<cNames; i++)
    {
        pnames->rgNames[i].pbData = pb;
        pnames->rgNames[i].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(rgNames[i].cbData);
#else
        pb += rgNames[i].cbData;
#endif //_WIN64
    }

    pnames->cNames = cNames;
exit:
    return hr;
}

HRESULT CMessageBody::_MergeNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD               cb;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               i1;
    LPBYTE              pb;
    CERT_NAME_BLOB *    p;

    for (i=0, cb=0; i<pnames->cNames; i++)
#ifdef _WIN64
        cb += LcbAlignLcb(pnames->rgNames[i].cbData);
#else
        cb += pnames->rgNames[i].cbData;
#endif //_WIN64

    for (i=0; i<cNames; i++)
#ifdef _WIN64
        cb += LcbAlignLcb(rgNames[i].cbData);
#else
        cb += rgNames[i].cbData;
#endif //_WIN64

    CHECKHR(hr = HrAlloc((LPVOID *)&p, cb + (pnames->cNames + cNames) *
                                  sizeof(CERT_NAME_BLOB)));

    pb = (LPBYTE) &p[pnames->cNames + cNames];
    for (i=0, i1=0; i<pnames->cNames; i++, i1++)
    {
        p[i1].pbData = pb;
        p[i1].cbData = pnames->rgNames[i].cbData;
        memcpy(pb, pnames->rgNames[i].pbData, pnames->rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(pnames->rgNames[i].cbData);
#else
        pb += pnames->rgNames[i].cbData;
#endif //_WIN64
    }

    for (i=0; i<pnames->cNames; i++, i1++)
    {
        p[i1].pbData = pb;
        p[i1].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(rgNames[i].cbData);
#else
        pb += rgNames[i].cbData;
#endif //_WIN64
    }

    MemFree(pnames->rgNames);
    pnames->rgNames = p;
    pnames->cNames = i1;

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------
// CMessageBody::_GetReceiptRequest
//--------------------------------------------------------------------------------
HRESULT CMessageBody::_GetReceiptRequest(DWORD dwFlags,
                                         PSMIME_RECEIPT_REQUEST *ppreq,
                                         ReceiptNames *pReceiptsTo,
                                         DWORD *pcbReceipt,
                                         LPBYTE *ppbReceipt,
                                         DWORD *pcbMsgHash,
                                         LPBYTE *ppbMsgHash)
{
    DWORD                       cb;
    DWORD                       cbMLHistory = 0;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbReceipt = 0;
    DWORD                       cSendersList = 0;
    DWORD                       dwReciptsFrom;
    HRESULT                     hr = S_OK;
    DWORD                       i;
    DWORD                       iAttr;
    DWORD                       iSigner;
    PCRYPT_ATTRIBUTES           pattrs = NULL;
    LPBYTE                      pb;
    LPBYTE                      pbMLHistory = NULL;
    LPBYTE                      pbMsgHash = NULL;
    LPBYTE                      pbReceipt = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    ReceiptNames                receiptsTo = {0, NULL};
    CERT_NAME_BLOB              *rgSendersList = NULL;
    PROPVARIANT                 var;

    *ppreq = NULL;
    if (pReceiptsTo != NULL)
    {
        pReceiptsTo->cNames = 0;
        pReceiptsTo->rgNames = NULL;
    }
    if (pcbReceipt != NULL) *pcbReceipt = 0;
    if (ppbReceipt != NULL) *ppbReceipt = NULL;
    Assert(((pcbReceipt == NULL) && (ppbReceipt == NULL)) ||
           ((pcbReceipt != NULL) && (ppbReceipt != NULL)));
    if (pcbMsgHash != NULL) *pcbMsgHash = 0;
    if (ppbMsgHash != NULL) *ppbMsgHash = NULL;
    Assert(((pcbMsgHash == NULL) && (ppbMsgHash == NULL)) ||
           ((pcbMsgHash != NULL) && (ppbMsgHash != NULL)));

    //
    //  If this is the bottom layer then
    //      find and Decode Receipt Request
    //      Set ReceiptsTo from the request
    //  if not then
    //          check lower layers
    //          if mlExpansion in this layer? No -- Skip to next layer
    //          Receipt for First Tier only? Yes - return S_FALSE
    //          Policy override on mlExpansion?
    //              None - return S_FALSE
    //  return S_OK

    // If this is not the bottom layer then look for MLHistory
    if (IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK)
    {
        Assert(m_pNode->cChildren == 1);

        hr = m_pNode->pChildHead->pBody->_GetReceiptRequest(
                                        dwFlags,
                                        &preq,
                                        (pReceiptsTo) ? &receiptsTo : NULL,
                                        (pcbReceipt) ? &cbReceipt : NULL,
                                        (ppbReceipt) ? &pbReceipt : NULL,
                                        (pcbMsgHash) ? &cbMsgHash : NULL,
                                        (ppbMsgHash) ? &pbMsgHash : NULL);
        if (hr)
            goto exit;

        //
        //  Walk through each signer's  authenticated attributes processing the
        //  relevant attribute.
        //

        for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
        {
            //
            //  Walk through each attribute looking for
            //      a Mail List expansion history
            //

            pattrs = m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner];
            for (iAttr=0; iAttr<pattrs->cAttr; iAttr++)
            {
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                            szOID_SMIME_MLExpansion_History) == 0)
                {
                    //
                    //  If receipts are from first tier only and we are at
                    //     this layer then we are not first tier by definition.
                    //
                    if (preq->ReceiptsFrom.AllOrFirstTier == SMIME_RECEIPTS_FROM_FIRST_TIER)
                    {
                        hr = S_FALSE;
                        goto exit;
                    }

                    if (cbMLHistory == 0)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbMLHistory,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData));
                        memcpy(pbMLHistory,pattrs->rgAttr[iAttr].rgValue[0].pbData,
                               pattrs->rgAttr[iAttr].rgValue[0].cbData);
                        cbMLHistory = pattrs->rgAttr[iAttr].rgValue[0].cbData;
                    }
                    else if ((pattrs->rgAttr[iAttr].rgValue[0].cbData != cbMLHistory) ||
                             (memcmp(pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                     pbMLHistory, cbMLHistory)))
                    {
                        // Hey, all MLHistorys should match
                         hr = S_FALSE;
                        goto exit;
                    }
                    break;
                }
            }
        }

        // Decode and respect the MLHistory
        if (cbMLHistory != 0)
        {
            PSMIME_ML_EXPANSION_HISTORY     pmlhist = NULL;

            //
            //  Crack the attribute
            //

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                     szOID_SMIME_MLExpansion_History,
                                     pbMLHistory,
                                     cbMLHistory,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pmlhist, &cb))
                goto GeneralFail;

            PSMIME_MLDATA     pMLData = &pmlhist->rgMLData[pmlhist->cMLData-1];

            switch( pMLData->dwPolicy)
            {
                //  No receipt is to be returned
                case SMIME_MLPOLICY_NONE:
                    hr = S_FALSE;
                    SafeMemFree(pmlhist);
                    goto exit;

                //  Return receipt to a new list
                case SMIME_MLPOLICY_INSTEAD_OF:
                    if (pReceiptsTo != NULL)
                        _SetNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_IN_ADDITION_TO:
                    if (pReceiptsTo != NULL)
                        _MergeNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_NO_CHANGE:
                    break;

                default:
                    SafeMemFree(pmlhist);
                    goto GeneralFail;
            }

            SafeMemFree(pmlhist);
        }
    }
    else
    {
        // Else this is the bottom layer so look for receipt request

        //
        //  Walk through each signer's  authenticated attributes processing the
        //  two relevant attributes.
        //

        for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
        {
            // Check if receipt was created for this signer if not then
            // it's signature must have been bad or it had not request
            if (m_rOptions.rgblobReceipt[iSigner].cbSize == 0)
                continue;

            // if we have a receipt we should also have a message hash
            if (m_rOptions.rgblobMsgHash[iSigner].cbSize == 0)
            {
                Assert(FALSE);
                continue;
            }

            if (m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner] == NULL)
            {
                // Hey how did we get a receipt without any attributes
                Assert(FALSE);
                goto GeneralFail;
            }

            pattrs = m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner];

            //
            //  Walk through each attribute looking for the receipt request
            //

            for (iAttr=0; iAttr<pattrs->cAttr; iAttr++)
            {
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_MLExpansion_History) == 0)
                {
                    // We are at the bottom so we should not have found a ML History
                    hr = S_FALSE;
                    goto exit;
                }
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_Receipt_Request) == 0)
                {
                    //
                    // Crack the contents of the receipt request
                    //

                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                             szOID_SMIME_Receipt_Request,
                                             pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                             CRYPT_DECODE_ALLOC_FLAG,
                                             &CryptDecodeAlloc, &preq, &cb) ||
                        (preq->cReceiptsTo == 0))
                        goto GeneralFail;

                    //
                    //  Initialize the ReceiptsTo list
                    //

                    if (pReceiptsTo != NULL)
                        _SetNames(&receiptsTo, preq->cReceiptsTo, preq->rgReceiptsTo);

                    if (ppbReceipt != NULL)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbReceipt,
                                             m_rOptions.rgblobReceipt[iSigner].cbSize));
                        memcpy(pbReceipt,m_rOptions.rgblobReceipt[iSigner].pBlobData,
                               m_rOptions.rgblobReceipt[iSigner].cbSize);
                    }
                    if (pcbReceipt != NULL) cbReceipt = m_rOptions.rgblobReceipt[iSigner].cbSize;

                    if (ppbMsgHash != NULL)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbMsgHash,
                                             m_rOptions.rgblobMsgHash[iSigner].cbSize));
                        memcpy(pbMsgHash,m_rOptions.rgblobMsgHash[iSigner].pBlobData,
                               m_rOptions.rgblobMsgHash[iSigner].cbSize);
                    }
                    if (pcbMsgHash != NULL) cbMsgHash = m_rOptions.rgblobMsgHash[iSigner].cbSize;
                    break;
                }
            }
        }

        if (preq == NULL)
        {
            // We are at the bottom so we should have found a receipt request
            hr = S_FALSE;
            goto exit;
        }
    }

    *ppreq = preq;
    preq = NULL;
    if (pReceiptsTo != NULL)
    {
        pReceiptsTo->cNames = receiptsTo.cNames;
        pReceiptsTo->rgNames = receiptsTo.rgNames;
        receiptsTo.cNames = 0;
        receiptsTo.rgNames = NULL;
    }
    if (pcbReceipt != NULL)
    {
        *pcbReceipt = cbReceipt;
        cbReceipt = 0;
    }
    if (ppbReceipt != NULL)
    {
        *ppbReceipt = pbReceipt;
        pbReceipt = NULL;
    }
    if (pcbMsgHash != NULL)
    {
        *pcbMsgHash = cbMsgHash;
        cbMsgHash = 0;
    }
    if (ppbMsgHash != NULL)
    {
        *ppbMsgHash = pbMsgHash;
        pbMsgHash = NULL;
    }

exit:
    SafeMemFree(preq);
    SafeMemFree(receiptsTo.rgNames);
    SafeMemFree(pbReceipt);
    SafeMemFree(pbMsgHash);
    SafeMemFree(pbMLHistory);
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

//--------------------------------------------------------------------------------
// CMessageBody::CreateReceipt
//--------------------------------------------------------------------------------

HRESULT CMessageBody::CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                                    const BYTE *pbFromNames, DWORD cSignerCertificates,
                                    PCCERT_CONTEXT *rgSignerCertificates,
                                    IMimeMessage ** ppMimeMessageReceipt)
{
    CRYPT_ATTRIBUTE             attrMsgHash;
    DWORD                       cb;
    DWORD                       cbEncodedMsgHash = 0;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbReceipt = 0;
    DWORD                       cLayers;
    DWORD                       dwReceiptsFrom;
    BOOL                        fAddedAddress = FALSE;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    DWORD                       iLayer;
    LPBYTE                      pbEncodedMsgHash = NULL;
    LPBYTE                      pbMsgHash = NULL;
    LPBYTE                      pbReceipt = NULL;
    IMimeAddressTable *         pmatbl = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeSecurity2 *            pms = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    LPSTREAM                    pstm = NULL;
    ReceiptNames                receiptsTo = {0, NULL};
    PROPVARIANT                 var;
    CRYPT_ATTR_BLOB             valMsgHash;


    hr = _GetReceiptRequest(dwFlags,
                            &preq,
                            &receiptsTo,
                            &cbReceipt,
                            &pbReceipt,
                            &cbMsgHash,
                            &pbMsgHash);
    if (hr)
        goto exit;

    //
    //  Am I on the ReceiptsFrom List --
    //

    if (preq->ReceiptsFrom.cNames != 0)
    {
        BOOL    fFoundMe = FALSE;
        CERT_ALT_NAME_INFO *    pname2 = NULL;

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 pbFromNames,
                                 cbFromNames,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname2, &cb))
            goto GeneralFail;

        for (i=0; !fFoundMe && (i<preq->ReceiptsFrom.cNames); i++)
        {
            CERT_ALT_NAME_INFO *    pname = NULL;

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                     preq->ReceiptsFrom.rgNames[i].pbData,
                                     preq->ReceiptsFrom.rgNames[i].cbData,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pname, &cb))
                goto GeneralFail;

            for (i1=0; i1<pname->cAltEntry; i1++)
            {
                for (i2=0; i2<pname2->cAltEntry; i2++)
                {
                    if (pname->rgAltEntry[i1].dwAltNameChoice !=
                        pname2->rgAltEntry[i2].dwAltNameChoice)
                        continue;

                    switch (pname->rgAltEntry[i1].dwAltNameChoice)
                    {
                        case CERT_ALT_NAME_RFC822_NAME:
                            if (lstrcmpiW(pname->rgAltEntry[i1].pwszRfc822Name,
                                          pname2->rgAltEntry[i2].pwszRfc822Name) == 0)
                            {
                                fFoundMe = TRUE;
                                goto FoundMe;
                            }
                    }
                }
            }

        FoundMe:
            SafeMemFree(pname);
        }

        SafeMemFree(pname2);
        if (!fFoundMe)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    //  Create a stream object to hold the receipt and put the receipt into the
    //  stream -- this supplies the body of the receipt message.

    CHECKHR(hr = MimeOleCreateVirtualStream(&pstm));
    CHECKHR(hr = pstm->Write(pbReceipt, cbReceipt, NULL));

    CHECKHR(hr = MimeOleCreateMessage(NULL, &pmm));
    CHECKHR(hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb));
    CHECKHR(hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms));
    CHECKHR(hr = pmb->SetData(IET_BINARY, "OID", szOID_SMIME_ContentType_Receipt,
                      IID_IStream, pstm));

    //
    //  Address the receipt back to the receipients
    //

    CHECKHR(hr = pmm->GetAddressTable(&pmatbl));

    for (i=0; i<receiptsTo.cNames; i++)
    {
        CERT_ALT_NAME_INFO *    pname = NULL;

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 receiptsTo.rgNames[i].pbData,
                                 receiptsTo.rgNames[i].cbData,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname, &cb))
            goto GeneralFail;

        for (i1=0; i1<pname->cAltEntry; i1++)
        {
            int     cch;
            TCHAR   rgch[256];

            if (pname->rgAltEntry[i1].dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME)
            {
                cch = WideCharToMultiByte(CP_ACP, 0,
                                          pname->rgAltEntry[i1].pwszRfc822Name,
                                          -1, rgch, sizeof(rgch), NULL, NULL);
                if (cch > 0)
                {
                    CHECKHR(hr = pmatbl->AppendRfc822(IAT_TO, IET_DECODED,
                                              rgch));
                    fAddedAddress = TRUE;
                }
                break;
            }
        }
        SafeMemFree(pname);
    }

    if (!fAddedAddress)
    {
        hr = S_FALSE;
        goto exit;
    }

    var.vt = VT_UI4;
    var.ulVal = MST_CLASS_SMIME_V1 | MST_THIS_BLOBSIGN;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_TYPE, &var));

#ifndef _WIN64
    var.vt = (VT_VECTOR | VT_UI4);
    var.caul.cElems = cSignerCertificates;
    var.caul.pElems = (DWORD *) rgSignerCertificates;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var));
#else
    var.vt = (VT_VECTOR | VT_UI8);
    var.cauh.cElems = cSignerCertificates;
    var.cauh.pElems = (ULARGE_INTEGER *) rgSignerCertificates;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var));
#endif

    //
    //  Setup the authorized attribute block so that
    //  we can get the correct information transfered.  At present we
    //  are only looking at one item to be included here.
    //  1.  The Message Hash of the message requesting the receipt

    valMsgHash.cbData = cbMsgHash;
    valMsgHash.pbData = pbMsgHash;
    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_OCTET_STRING,
                            &valMsgHash, CRYPT_ENCODE_ALLOC_FLAG,
                            &CryptEncodeAlloc, &pbEncodedMsgHash, &cbEncodedMsgHash))
        goto GeneralFail;

    attrMsgHash.pszObjId = szOID_SMIME_Msg_Sig_Digest;
    attrMsgHash.cValue = 1;
    attrMsgHash.rgValue = &valMsgHash;
    valMsgHash.cbData = cbEncodedMsgHash;
    valMsgHash.pbData = pbEncodedMsgHash;
    CHECKHR(hr = pms->SetAttribute(0, -1, SMIME_ATTRIBUTE_SET_SIGNED, &attrMsgHash));

    hr = S_OK;
    *ppMimeMessageReceipt = pmm;
    pmm->AddRef();

exit:
    SafeMemFree(preq);
    SafeMemFree(receiptsTo.rgNames);
    SafeMemFree(pbEncodedMsgHash);
    SafeMemFree(pbMsgHash);
    SafeMemFree(pbReceipt);
    if (pstm != NULL)           pstm->Release();
    if (pmatbl != NULL)         pmatbl->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    if (pmm != NULL)            pmm->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

//--------------------------------------------------------------------------------
// CMessageBody::GetReceiptSendersList
//--------------------------------------------------------------------------------
HRESULT CMessageBody::GetReceiptSendersList(DWORD dwFlags, DWORD *pcSendersList,
                                            CERT_NAME_BLOB  * *rgSendersList)
{
    DWORD                       cb;
    HRESULT                     hr;
    DWORD                       i;
    LPBYTE                      pb;
    PSMIME_RECEIPT_REQUEST      preq = NULL;

    hr = _GetReceiptRequest(dwFlags,
                            &preq,
                            NULL, NULL, NULL, NULL, NULL);
    if (hr)
        goto exit;

    if (preq->ReceiptsFrom.cNames == 0)
    {
        *rgSendersList = NULL;
        *pcSendersList = preq->ReceiptsFrom.cNames;
        goto exit;
    }

    cb = 0;
    for (i =0; i < preq->ReceiptsFrom.cNames; i++)
#ifdef _WIN64
        cb += sizeof(CERT_NAME_BLOB) + LcbAlignLcb(preq->ReceiptsFrom.rgNames[i].cbData);
#else
        cb += sizeof(CERT_NAME_BLOB) + preq->ReceiptsFrom.rgNames[i].cbData;
#endif // _WIN64
    CHECKHR(hr = HrAlloc((LPVOID *)rgSendersList, cb));
    *pcSendersList = preq->ReceiptsFrom.cNames;
    pb = (LPBYTE)*rgSendersList + (sizeof(CERT_NAME_BLOB) * (*pcSendersList));

    for (i =0; i < preq->ReceiptsFrom.cNames; i++)
    {
        (*rgSendersList)[i].cbData = preq->ReceiptsFrom.rgNames[i].cbData;
        (*rgSendersList)[i].pbData = pb;
        memcpy(pb, preq->ReceiptsFrom.rgNames[i].pbData, preq->ReceiptsFrom.rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb((*rgSendersList)[i].cbData);
#else
        pb += (*rgSendersList)[i].cbData;
#endif // _WIN64
    }

exit:
    SafeMemFree(preq);
    return hr;

}

// --------------------------------------------------------------------------------
// CMessageBody::VerifyReceipt
//
// Assumes the passed in pMimeMessageReceipt has been decoded and
//     it's signature verified.
//
// This function verifies that the values in the Receipt content are
//     identical to those i the original sigendData signerInfo that
//     requested the receipt and that the message hash of the original message
//     is identical to the msgSigDigest sigend Attribute of the receipt
//
// --------------------------------------------------------------------------------
HRESULT CMessageBody::VerifyReceipt(DWORD dwFlags,
                                    IMimeMessage * pMimeMessageReceipt)
{
    PCRYPT_ATTRIBUTE            pattrMsgHash = NULL;
    PCRYPT_ATTRIBUTE            pattrMsgHash2 = NULL;
    DWORD                       cb;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbData;
    HRESULT                     hr;
    DWORD                       iReceiptSigner;
    DWORD                       iSigner;
    LPBYTE                      pb;
    LPBYTE                      pbData = NULL;
    PCRYPT_ATTR_BLOB            pblobMsgHash = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            pms = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    PSMIME_RECEIPT              pSecReceipt = NULL;
    LPSTREAM                    pstm = NULL;
    STATSTG                     statstg;
    PROPVARIANT                 var;

    // If this is not the bottom layer then ask child to verify receipt
    if (IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK)
    {
        Assert(m_pNode->cChildren == 1);

        hr = m_pNode->pChildHead->pBody->VerifyReceipt(
                                        dwFlags,
                                        pMimeMessageReceipt);
        goto exit;
    }

    CHECKHR(hr = pMimeMessageReceipt->BindToObject(HBODY_ROOT, IID_IMimeBody,
                                            (LPVOID *) &pmb));
    CHECKHR(hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms));
    CHECKHR(hr = pmb->GetData(IET_BINARY, &pstm));
    CHECKHR(hr = pstm->Stat(&statstg,STATFLAG_NONAME));

    Assert(statstg.cbSize.HighPart == 0);

    CHECKHR(hr = HrAlloc((LPVOID *)&pbData, statstg.cbSize.LowPart));
    CHECKHR(hr = pstm->Read(pbData, statstg.cbSize.LowPart, &cbData));

    // Check if receipt is the receipt we expect
    for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
    {
        if ((m_rOptions.rgblobReceipt[iSigner].cbSize == cbData) &&
             !memcmp(m_rOptions.rgblobReceipt[iSigner].pBlobData,pbData,cbData))
            break;
    }

    // check if we found a matching receipt
    if (iSigner == m_rOptions.cSigners)
    {
        hr = MIME_E_SECURITY_RECEIPT_NOMATCHINGRECEIPTBODY;
        goto exit;
    }

    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_ContentType_Receipt,
                             pbData,
                             cbData,
                             CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                             &pSecReceipt, &cb))
        goto GeneralFail;

    //
    // Get the first signatures MsgSigDigest
    //
    CHECKHR(hr = pms->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED,
                                   0, szOID_SMIME_Msg_Sig_Digest,
                                   &pattrMsgHash));

    if ((hr == S_FALSE) ||
        (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                              X509_OCTET_STRING,
                              pattrMsgHash->rgValue[0].pbData,
                              pattrMsgHash->rgValue[0].cbData,
                              CRYPT_DECODE_ALLOC_FLAG,
                              &CryptDecodeAlloc, &pblobMsgHash, &cbMsgHash)))
    {
        hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
        goto exit;
    }

    if ((m_rOptions.rgblobMsgHash[iSigner].cbSize != pblobMsgHash->cbData) ||
         memcmp(m_rOptions.rgblobMsgHash[iSigner].pBlobData,
                pblobMsgHash->pbData, pblobMsgHash->cbData))
    {
        hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
        goto exit;
    }

    CHECKHR(hr = pmb->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var));
    for (iReceiptSigner = 1; iReceiptSigner < var.ulVal; iReceiptSigner++)
    {
        CHECKHR(hr = pms->GetAttribute(0, iReceiptSigner, SMIME_ATTRIBUTE_SET_SIGNED,
                                       0, szOID_SMIME_Msg_Sig_Digest,
                                       &pattrMsgHash2));

        if ((hr == S_FALSE) ||
            (pattrMsgHash->rgValue[0].cbData != pattrMsgHash2->rgValue[0].cbData) ||
             memcmp(pattrMsgHash->rgValue[0].pbData,
                    pattrMsgHash2->rgValue[0].pbData,
                    pattrMsgHash->rgValue[0].cbData))
        {
            hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
            goto exit;
        }

        SafeMemFree(pattrMsgHash2);
    }

exit:
    SafeMemFree(pblobMsgHash);
    SafeMemFree(pbData);
    SafeMemFree(pSecReceipt);
    SafeMemFree(pattrMsgHash);
    SafeMemFree(pattrMsgHash2);
    if (pstm != NULL)           pstm->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

// --------------------------------------------------------------------------------
// CMessageBody::CapabilitiesSupported
// --------------------------------------------------------------------------------

HRESULT CMessageBody::CapabilitiesSupported(DWORD * pdwFlags)
{
    //  Assume no capabilities
    *pdwFlags = 0;

    //  If we have msasn1.dll on the system, then we can support labels
    if (FIsMsasn1Loaded())  *pdwFlags |= SMIME_SUPPORT_LABELS;

    //  If we have a correct crypt32, then we can support receipts & key agreement

    DemandLoadCrypt32();
    if (g_FSupportV3 && FIsMsasn1Loaded())
        *pdwFlags |= SMIME_SUPPORT_RECEIPTS;

    if (g_FSupportV3)
        *pdwFlags |= SMIME_SUPPORT_KEY_AGREE;

    //  If we have a correct advapi32, then we can support maillist keys
    DemandLoadAdvApi32();
    if (VAR_CryptContextAddRef != MY_CryptContextAddRef)
        *pdwFlags |= SMIME_SUPPORT_MAILLIST;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessage::_HrGetAttrs
//
// Utility function to retrieve attributes
// --------------------------------------------------------------------------------

HRESULT CMessageBody::_HrGetAttrs(DWORD cSigners, PCRYPT_ATTRIBUTES * rgpattrs,
                                  LPCSTR pszObjId, PROPVARIANT FAR * pvOut)
{
    // Locals
    CRYPT_ATTRIBUTES    attrs;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               i1;
    CRYPT_ATTRIBUTES UNALIGNED *pattrs;
    CAPROPVARIANT UNALIGNED *pcapropvar;
    PROPVARIANT *ppv = NULL;

    pvOut->vt = VT_VECTOR | VT_VARIANT;
    pcapropvar = &pvOut->capropvar;
    pcapropvar->cElems = cSigners;

    if (cSigners > 0)
    {
        Assert(rgpattrs && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&ppv, cSigners * sizeof(PROPVARIANT))))
        {
            goto exit;
        }
        memset(ppv, 0, cSigners * sizeof(PROPVARIANT));

        pcapropvar->pElems = ppv;

        // Fill in the array of BLOBs
        for (i = 0; i < cSigners; i++)
        {
            ppv[i].vt = VT_BLOB;
            // HrCopyBlob allocates memory for the blob data.
            if (rgpattrs[i] == NULL)
                continue;

            if (pszObjId == NULL)
            {
                pattrs = rgpattrs[i];
            }
            else
            {
                pattrs = NULL;
                for (i1=0; i1<rgpattrs[i]->cAttr; i1++)
                {
                    if (lstrcmp(rgpattrs[i]->rgAttr[i1].pszObjId, pszObjId) == NULL)
                    {
                        pattrs = &attrs;
                        attrs.cAttr = 1;
                        attrs.rgAttr = &rgpattrs[i]->rgAttr[i1];
                        break;
                    }
                }
                if (pattrs == NULL)
                    continue;
            }

            if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     pattrs, CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &ppv[i].blob.pBlobData,
                                     &ppv[i].blob.cbSize))
            {
                hr = HrGetLastError();
                goto exit;
            }
        }
    } else {
        pcapropvar->pElems = NULL;
    }

    hr = S_OK;
exit:
    if (FAILED(hr) && (ppv != NULL))
    {
        for (i=0; i<cSigners; i++)
        {
            MemFree(&ppv[i].blob.pBlobData);
        }
        MemFree(ppv);
    }

    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageBody::_FindAttribute
//
// Utility function designed to find attributes in an attribute set
// --------------------------------------------------------------------------------

PCRYPT_ATTRIBUTE CMessageBody::_FindAttribute(PCRYPT_ATTRIBUTES pattrs,
                                              LPCSTR pszObjId, DWORD iInstance)
{
    DWORD               i;

    if (pattrs == NULL)
        return NULL;

    for (i=0; i<pattrs->cAttr; i++)
    {
        if (lstrcmp(pattrs->rgAttr[i].pszObjId, pszObjId) == 0)
        {
            if (iInstance == 0)
            {
                return &pattrs->rgAttr[i];
            }
            else
            {
                iInstance -= 1;
            }
        }
    }

    return NULL;
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrSetAttribute
//
// Utility function designed to set attributes.  Called from set property as well
//      as public interface set attribute function
// --------------------------------------------------------------------------------

HRESULT CMessageBody::_HrSetAttribute(DWORD dwFlags, PCRYPT_ATTRIBUTES * ppattrs,
                                      LPCSTR pszObjId, DWORD cbNew, const BYTE * pbNew)
{
    DWORD               cAttr =0;
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    PCRYPT_ATTRIBUTES   pattrs = *ppattrs;
    PCRYPT_ATTRIBUTES   pattrs2 = NULL;
    LPBYTE              pb;
    CRYPT_ATTR_BLOB UNALIGNED *pVal = NULL;

    //
    //  We have a special case of pszObjId == NULL, in this case the entire
    //  encoded item is passed in
    //

    if (pszObjId == NULL)
    {
        hr = HrDecodeObject(pbNew, cbNew, szOID_Microsoft_Attribute_Sequence, 0,
                            &cb, (LPVOID *) &pattrs2);
        if (SUCCEEDED(hr))
        {
#ifdef _WIN64
        *ppattrs = (PCRYPT_ATTRIBUTES) MyPbAlignPb(*ppattrs);
#endif //_WIN64
            MemFree(*ppattrs);
            *ppattrs = NULL;
            *ppattrs = pattrs2;
            pattrs2 = NULL;
        }
        goto exit;
    }

    //
    //  Compute size of buffer we are going to need to hold the result
    //

    if (pattrs == NULL)
    {
        cb = sizeof(CRYPT_ATTRIBUTES);
    }
    else
    {
        cb = sizeof(CRYPT_ATTRIBUTES);

        for (i=0; i<pattrs->cAttr; i++)
        {
            Assert(pattrs->rgAttr[i].cValue == 1);

            //
            // If we are going to replace something, then set it's oid to NULL
            //

            if ((lstrcmp(pattrs->rgAttr[i].pszObjId, pszObjId) == 0) &&
                !(dwFlags & SMIME_ATTR_ADD_TO_EXISTING))
            {
                if (dwFlags & SMIME_ATTR_ADD_IF_NOT_EXISTS)
                {
                    return S_OK;
                }

                pattrs->rgAttr[i].pszObjId = NULL;
                continue;
            }

            pVal = &(pattrs->rgAttr[i].rgValue[0]);

            cb += ((DWORD) (sizeof(CRYPT_ATTRIBUTE) + sizeof(CRYPT_ATTR_BLOB) +
                strlen(pattrs->rgAttr[i].pszObjId) + 1 +
                pVal->cbData));
#ifdef _WIN64
            cb = LcbAlignLcb(cb);
#endif // _WIN64
            cAttr += 1;
        }
    }

    //
    // Add room for the one we are about to include
    //
#ifdef _WIN64
    cb = LcbAlignLcb(cb);
#endif // _WIN64

    cb += (DWORD)(sizeof(CRYPT_ATTRIBUTE) + sizeof(CRYPT_ATTR_BLOB) +
#ifdef _WIN64
        LcbAlignLcb(strlen(pszObjId) + 1) + cbNew);
#else
        strlen(pszObjId) + 1 + cbNew);
#endif // _WIN64
    cAttr += 1;

    //
    // Allocate Memory to hold the result
    //

    pattrs2 = (PCRYPT_ATTRIBUTES) g_pMalloc->Alloc(cb);
    if (pattrs2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    //
    //  Now copy over the items appending our item at the end
    //

    pattrs2->rgAttr = (PCRYPT_ATTRIBUTE) &pattrs2[1];
    pb = (LPBYTE) &pattrs2->rgAttr[cAttr];

    cAttr = 0;
    if (pattrs != NULL)
    {
        for (i=0; i<pattrs->cAttr; i++)
        {
            if (pattrs->rgAttr[i].pszObjId == NULL) continue;

            pattrs2->rgAttr[cAttr].pszObjId = (LPSTR) pb;
#ifdef _WIN64
            cb = LcbAlignLcb(strlen(pattrs->rgAttr[i].pszObjId) + 1);
#else
            cb = strlen(pattrs->rgAttr[i].pszObjId) + 1;
#endif // _WIN64
            memcpy(pb, pattrs->rgAttr[i].pszObjId, cb);
            pb += cb;

            pattrs2->rgAttr[cAttr].cValue = 1;
            pattrs2->rgAttr[cAttr].rgValue = (PCRYPT_ATTR_BLOB) pb;
#ifdef _WIN64
            pb += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB));
#else
            pb += sizeof(CRYPT_ATTR_BLOB);
#endif
            pVal = &(pattrs->rgAttr[i].rgValue[0]);

            cb = ((DWORD) (pVal->cbData));

#ifdef _WIN64
//             cb = LcbAlignLcb(cb);
#endif // _WIN64

            pVal = &(pattrs2->rgAttr[cAttr].rgValue[0]);

            pVal->pbData = pb;
            pVal->cbData = cb;

            pVal = &(pattrs->rgAttr[i].rgValue[0]);
            memcpy(pb, pVal->pbData, cb);

#ifdef _WIN64
            pb += LcbAlignLcb(cb);
#else
            pb += cb;
#endif
            cAttr += 1;
        }
    }

    //
    // Append the new one
    //

#ifdef _WIN64
    cb = LcbAlignLcb(strlen(pszObjId) + 1);
#else
    cb = strlen(pszObjId) + 1;
#endif // _WIN64
    pattrs2->rgAttr[cAttr].pszObjId = (LPSTR) pb;
    memcpy(pb, pszObjId, cb);
    pb += cb;

    pattrs2->rgAttr[cAttr].cValue = (DWORD) 1;
    pattrs2->rgAttr[cAttr].rgValue = (PCRYPT_ATTR_BLOB) pb;
#ifdef _WIN64
    pb += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB));
#else
    pb += sizeof(CRYPT_ATTR_BLOB);
#endif

    pVal = &(pattrs2->rgAttr[cAttr].rgValue[0]);

    pVal->cbData = (DWORD) cbNew;
    pVal->pbData = pb;
    memcpy(pb, pbNew, cbNew);
#ifdef _WIN64
    pb += LcbAlignLcb(cbNew);
#else
    pb += cbNew;
#endif

    pattrs2->cAttr = cAttr + 1;


    MemFree(*ppattrs);                  
    *ppattrs = NULL;
    *ppattrs = pattrs2;                 
    pattrs2 = NULL;

    hr = S_OK;
exit:
    if (pattrs2 != NULL)                MemFree(pattrs2);
    return hr;
}


#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bookbody.h ===
// --------------------------------------------------------------------------------
// BookBody.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BOOKBODY_H
#define __BOOKBODY_H

// --------------------------------------------------------------------------------
// IID_CMessageBody - {CDBC9B51-A489-11d0-85C4-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CMessageBody, 0xcdbc9b51, 0xa489, 0x11d0, 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "containx.h"
#include "privunk.h"

// --------------------------------------------------------------------------------
// Forward Refs
// --------------------------------------------------------------------------------
class CMessageBody;
class CBodyLockBytes;
typedef struct _CERT_CONTEXT CERT_CONTEXT;
typedef const CERT_CONTEXT *PCCERT_CONTEXT;
typedef void *HCERTSTORE;
typedef ULONG_PTR HCRYPTPROV;
typedef struct tagTREENODEINFO *LPTREENODEINFO;

#ifdef _WIN64
// --------------------------------------------------------------------------------
// CERTARRAY
// --------------------------------------------------------------------------------
struct tagCERTARRAY
{
    DWORD           cCerts;
    PCCERT_CONTEXT *rgpCerts;
};
typedef struct tagCERTARRAY CERTARRAY;
#endif // _WIN64

// --------------------------------------------------------------------------------
// STOREARRAY
// --------------------------------------------------------------------------------
struct tagSTOREARRAY
{
    DWORD           cStores;
    HCERTSTORE     *rgStores;
};
typedef struct tagSTOREARRAY STOREARRAY;

// --------------------------------------------------------------------------------
// BODYOPTIONS
// --------------------------------------------------------------------------------
typedef struct tagBODYOPTIONS {
    ENCODINGTYPE            ietTransmit;                // User specified transmission encoding...
    ULONG                   cbMaxLine;                  // Max Line length
    BOOL                    fWrapText;                  // Wrap the text in this body
    BOOL                    fRemoveNBSP;                // Remove NBSP on GetData
    BOOL                    fDBCSEscape8;               // Treat Escape (0x1b) characters in a dbcs encoding as 8bit
    BOOL                    fHideTNEF;                  // Hide TNEF Attachments
    // Security Options
    ULONG                   ulSecurityType;             // OID_SECURITY_TYPE
    BLOB *                  rgblobHash;                 // OID_SECURITY_ALG_HASH and OID_SECURITY_ALG_HASH_RG
    BLOB                    blobBulk;                   // OID_SECURITY_ALG_BULK
    PCCERT_CONTEXT *        rgpcCertSigning;            // OID_SECURITY_CERT_SIGNING and OID_SECURITY_CERT_SIGNING_RG
    PCCERT_CONTEXT          pcCertDecryption;           // OID_SECURITY_CERT_DECRYPTION
#ifdef _WIN65
    CERTARRAY               caEncrypt;                  // OID_SECURITY_RG_CERT_ENCRYPT
#endif // _WIN65
    HCERTSTORE              hCertStore;                 // OID_SECURITY_HCERTSTORE
    STOREARRAY              saSearchStore;              // OID_SECURITY_SEARCHSTORES
    DWORD                   cIASN;
    ULONG                  *rgIASN;                     // OID_SECURITY_RG_IASN
#ifdef SMIME_V3
    PCRYPT_ATTRIBUTES *     rgrgpattrs[3];              // OID_SECURITY_AUTHATTR_RG
#else // !SMIME_V3
    BLOB *                  rgblobSymCaps;              // OID_SECURITY_SYMCAPS and OID_SECURITY_SYMCAPS_RG
    BLOB *                  rgblobAuthAttr;             // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    BLOB *                  rgblobUnauthAttr;           // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    FILETIME *              rgftSigning;                // OID_SECURITY_SIGNTIME and OID_SECURITY_SIGNTIME_RG
#endif // SMIME_V3
    ULONG *                 rgulUserDef;                // OID_SECURITY_USER_VALIDITY and OID_SECURITY_USER_VALIDITY_RG
    ULONG *                 rgulROValid;                // OID_SECURITY_RO_MSG_VALIDITY and OID_SECURITY_RO_MSG_VALIDITY_RG
    HCRYPTPROV              hCryptProv;                 // OID_SECURITY_HCRYPTPROV
    ULONG                   ulEncodeFlags;              // OID_SECURITY_ENCODE_FLAGS
    BOOL                    fCertWithMsg;               // OID_SECURITY_CERT_INCLUDED
    HWND                    hwndOwner;                  // OID_SECURITY_HWND_OWNER
    ENCODINGTYPE            ietRequested;               // OID_SECURITY_REQUESTED_CTE
#ifdef SMIME_V3
    BLOB *                  rgblobReceipt;              // OID_SECURITY_RECEIPT_RG
    BLOB *                  rgblobMsgHash;              // OID_SECURITY_MESSAGE_HASH_RG
    LPWSTR                  pwszKeyPrompt;              // OID_SECURITY_KEY_PROMPT
#endif // SMIME_V3
    BOOL                    fShowMacBin;                // OID_SHOW_MACBINARY
    BOOL                    fExternalBody;              // OID_SUPPORT_EXTERNAL_BODY
    ULONG                   cSigners;                   // OID_SECURITY_SIGNATURE_COUNT // How many signers?
    BOOL                    fNoSecurityOnSave;          // OID_NOSECURITY_ON_SAVE
#ifdef SMIME_V3
    DWORD                   cRecipients;                // Actual Recipients
    DWORD                   cRecipsAllocated;           // Allocated Recipients
    PCMS_RECIPIENT_INFO     rgRecipients;               // Recipient Information
    HCERTSTORE              hstoreEncrypt;              // OID_SECURITY_ENCRYPT_CERT_BAG
#endif // SMIME_V3
} BODYOPTIONS, *LPBODYOPTIONS;

// --------------------------------------------------------------------------------
// BODYSTORAGE
// --------------------------------------------------------------------------------
typedef struct tagBODYSTORAGE {
    IID                     riid;           // Type of data source
    IUnknown               *pUnkRelease;    // Release this to free this object
    union {
        ILockBytes         *pLockBytes;     // IID_ILockBytes
        IMimeWebDocument   *pWebDocument;   // IID_IMimeWebDocument
    };
} BODYSTORAGE, *LPBODYSTORAGE;

// --------------------------------------------------------------------------------
// FCANSETDATAIID - IIDs that can be passed into IMimeBody::SetData
// --------------------------------------------------------------------------------
#define FBODYSETDATAIID(_iid) \
    (IID_IStream          == riid || \
     IID_ILockBytes       == riid || \
     IID_IMimeBody        == riid || \
     IID_IMimeMessage     == riid || \
     IID_IMimeWebDocument == riid)

// --------------------------------------------------------------------------------
// BODYSTATE
// --------------------------------------------------------------------------------
#define BODYSTATE_DIRTY       FLAG01        // The body is dirty
#define BODYSTATE_CSETTAGGED  FLAG02        // The body is tagged with a character set
#define BODYSTATE_SECURE      FLAG03        // The body is secure
#define BODYSTATE_EXTERNAL    FLAG04        // The body was content-Type: message/external-body
#define BODYSTATE_SKIPCSET    FLAG05        // The body character set has been set explicitly

#ifdef SMIME_V3
// --------------------------------------------------------------------------------
// ReceiptNames
// --------------------------------------------------------------------------------
typedef struct {
    DWORD               cNames;
    CERT_NAME_BLOB *    rgNames;
} ReceiptNames;
#endif // SMIME_V3


// --------------------------------------------------------------------------------
// Definition of IMimeBody
// --------------------------------------------------------------------------------
class CMessageBody : public CPrivateUnknown, public IMimeBodyW
#ifdef SMIME_V3 
                , public IMimeSecurity2
#endif // SMIME_V3
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMessageBody(LPTREENODEINFO pNode, IUnknown *pUnkOuter=NULL);
    ~CMessageBody(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {
        return CPrivateUnknown::Release(); };

    // ---------------------------------------------------------------------------
    // IPersistStreamInit members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);

    // ---------------------------------------------------------------------------
    // IMimePropertySet members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP DeleteExcept(ULONG cNames, LPCSTR *prgszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam);
    STDMETHODIMP IsContentType(LPCSTR pszCntType, LPCSTR pszSubType);
    STDMETHODIMP Clone(IMimePropertySet **ppPropertySet);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo);
    STDMETHODIMP SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo);
    STDMETHODIMP EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum);

    // ---------------------------------------------------------------------------
    // IMimeBody members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetEstimatedSize(ENCODINGTYPE ietEncoding, ULONG *pcbSize);
    STDMETHODIMP GetDataHere(ENCODINGTYPE ietEncoding, IStream *pStream);
    STDMETHODIMP GetData(ENCODINGTYPE ietEncoding, IStream **ppStream);
    STDMETHODIMP SetData(ENCODINGTYPE ietEncoding, LPCSTR pszPriType, LPCSTR pszSubType, REFIID riid, LPVOID pvObject);
    STDMETHODIMP CopyTo(IMimeBody *pBody);
    STDMETHODIMP GetCurrentEncoding(ENCODINGTYPE *pietEncoding);
    STDMETHODIMP SetCurrentEncoding(ENCODINGTYPE ietEncoding);
    STDMETHODIMP GetHandle(LPHBODY phBody);
    STDMETHODIMP GetTransmitInfo(LPTRANSMITINFO pTransmit);
    STDMETHODIMP GetOffsets(LPBODYOFFSETS pOffsets);
    STDMETHODIMP SetDisplayName(LPCSTR pszDisplay);
    STDMETHODIMP GetDisplayName(LPSTR *ppszDisplay);
    STDMETHODIMP IsType(IMSGBODYTYPE type);
    STDMETHODIMP SaveToFile(ENCODINGTYPE ietEncoding, LPCSTR pszFilePath);
    STDMETHODIMP EmptyData(void);

    // ---------------------------------------------------------------------------
    // IMimeBodyW members
    // ---------------------------------------------------------------------------
    STDMETHODIMP SetDisplayNameW(LPCWSTR pwszDisplay);
    STDMETHODIMP GetDisplayNameW(LPWSTR *ppwszDisplay);
    STDMETHODIMP SetDataW(ENCODINGTYPE ietEncoding, LPCWSTR pwszPriType, LPCWSTR pwszSubType, REFIID riid, LPVOID pvObject);
    STDMETHODIMP SaveToFileW(ENCODINGTYPE ietEncoding, LPCWSTR pwszFilePath);

#ifdef SMIME_V3
    // ---------------------------------------------------------------------------
    // IMimeSecurity2 members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Encode(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback);
    STDMETHODIMP GetRecipientCount(DWORD dwFlags, DWORD *pdwRecipCount);
    STDMETHODIMP AddRecipient(DWORD dwFlags, DWORD cRecipData, PCMS_RECIPIENT_INFO recipData);
    STDMETHODIMP GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData);
    STDMETHODIMP DeleteRecipient(DWORD dwFlags, DWORD iRecipent, DWORD cRecipients);
    STDMETHODIMP GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              DWORD iInstance, LPCSTR pszObjId,
                              CRYPT_ATTRIBUTE ** ppattr);
    STDMETHODIMP SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              const CRYPT_ATTRIBUTE * pattr);
    STDMETHODIMP DeleteAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                                 DWORD iInstance, LPCSTR pszObjid);
    STDMETHODIMP CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                               const BYTE * pbFromNames, DWORD cSignerCertificates,
                               PCCERT_CONTEXT * rgSignerCertificates,
                               IMimeMessage ** ppMimeMessageReceipt);
    STDMETHODIMP GetReceiptSendersList(DWORD dwFlags, DWORD * pcSendersList,
                                       CERT_NAME_BLOB ** rgSendersList);
    STDMETHODIMP VerifyReceipt(DWORD dwFlags, IMimeMessage * pMimeMessageReceipt);
    STDMETHODIMP CapabilitiesSupported(DWORD * pdwFeatures);
#endif // SMIME_V3

    // ---------------------------------------------------------------------------
    // CMessageBody members
    // ---------------------------------------------------------------------------
    BOOL    FExtractRfc822Subject(LPWSTR *ppwszVal);
    void    ClearDirty(void);
    void    SetState(DWORD dwState);
    void    ClearState(DWORD dwState);
    HRESULT Load(CInternetStream *pInternet);
    HRESULT HrGetLockBytes(ILockBytes **ppLockBytes);
    HRESULT HrBindToTree(CStreamLockBytes *pStmLock, LPTREENODEINFO pNode);
    DWORD   DwGetFlags(BOOL fHideTnef);
    void    SwitchContainers(CMessageBody *pBody);
    void    CopyOptionsTo(CMessageBody *pBody, BOOL fNewOnwer=FALSE);
    HRESULT InternalSetOption(const TYPEDID oid, LPCPROPVARIANT pValue, BOOL fInternal, BOOL fNoDirty);

    // ---------------------------------------------------------------------------
    // Inlines
    // ---------------------------------------------------------------------------
    LPINETCSETINFO PGetTaggedCset(void) {
        EnterCriticalSection(&m_cs);
        LPINETCSETINFO p = m_pCsetTagged;
        LeaveCriticalSection(&m_cs);
        return p;
    }
    HRESULT GetPreviousEncoding(ENCODINGTYPE * pietEncoding) {
        if (ISFLAGSET(m_dwState, BODYSTATE_DIRTY)) {
            *pietEncoding = m_ietPrevious = IET_UNKNOWN;
        }
        else {
            *pietEncoding = m_ietPrevious;
        }
        return S_OK;
    }
    HRESULT SetPreviousEncoding(ENCODINGTYPE ietEncoding) {
        m_ietPrevious = ietEncoding;
        return S_OK;
    }

    // ---------------------------------------------------------------------------
    // CMessageBody Accessor Functions
    // ---------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    void RevokeTreeNode(void);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    DWORD _GetSecureTypeFlags();
    HRESULT _HrCopyDataStream(IStream *pstmSource, IStream *pstmDest);
    void _FreeOptions();
    void _BindToExternalBody(void);
#ifdef SMIME_V3
    static HRESULT _HrGetAttrs(DWORD cAttrs, PCRYPT_ATTRIBUTES * rgpattrs, LPCSTR pszOid, PROPVARIANT FAR * pvOut);
    static PCRYPT_ATTRIBUTE _FindAttribute(PCRYPT_ATTRIBUTES pattrs, LPCSTR pszObjId, DWORD iInstance);
    static HRESULT _HrSetAttribute(DWORD dwFlags, PCRYPT_ATTRIBUTES * ppattrs, LPCSTR pszObjectId, DWORD cb, const BYTE * pb);
#endif // SMIME_V3
#ifdef _WIN64
    static HRESULT _CAULToCERTARRAY(const CAUL caul, CERTARRAY *pca);
    static HRESULT _CERTARRAYToCAUL(const CERTARRAY ca, CAUL *pcaul);
    static HRESULT _CAUHToCERTARRAY(const CAUH cauh, CERTARRAY *pca);
    static HRESULT _CERTARRAYToCAUH(const CERTARRAY ca, CAUH *pcauh);
#endif // _WIN64
    static HRESULT _CAULToCertStore(const CAUL caul, HCERTSTORE * phcertstore);
    static HRESULT _CertStoreToCAUL(const HCERTSTORE hcertstore, CAUL *pcaul);
    static HRESULT _CAULToSTOREARRAY(const CAUL caul, STOREARRAY *psa);
    static HRESULT _STOREARRAYToCAUL(const STOREARRAY sa, CAUL *pcaul);
    static HRESULT _CAUHToCertStore(const CAUH cauh, HCERTSTORE * phcertstore);
    static HRESULT _CertStoreToCAUH(const HCERTSTORE hcertstore, CAUH *pcauh);
    static HRESULT _CAUHToSTOREARRAY(const CAUH cauh, STOREARRAY *psa);
    static HRESULT _STOREARRAYToCAUH(const STOREARRAY sa, CAUH *pcauh);

    HRESULT _HrEnsureBodyOptionLayers(LPCPROPVARIANT ppv);
    HRESULT _HrEnsureBodyOptionLayers(ULONG ulLayers);
    void _FreeLayerArrays(void);
    HRESULT _CompareCopyBlobArray(const PROPVARIANT FAR * pvSource, BLOB FAR * FAR * prgblDestination, BOOL fNoDirty);
#ifdef SMIME_V3
    HRESULT     _HrSizeOfRecipInfos(DWORD cItems, const CMS_RECIPIENT_INFO *);
    HRESULT     _HrCopyRecipInfos(DWORD cItems, const CMS_RECIPIENT_INFO * precipSrc,
                                  PCMS_RECIPIENT_INFO precipDst);
    HRESULT     _HrMapPublicKeyAlg(CERT_PUBLIC_KEY_INFO *, DWORD *,
                                   CRYPT_ALGORITHM_IDENTIFIER **);
    HRESULT     _SetNames(ReceiptNames * pnames, DWORD cNames, 
                          CERT_NAME_BLOB * rgNames);
    HRESULT     _MergeNames(ReceiptNames * pnames, DWORD cNames, 
                            CERT_NAME_BLOB * rgNames);
    STDMETHODIMP _GetReceiptRequest(DWORD dwFlags, 
                                    PSMIME_RECEIPT_REQUEST *ppreq,
                                    ReceiptNames *pReceiptsTo,
                                    DWORD *pcbReceipt,
                                    LPBYTE *ppbReceipt,
                                    DWORD *pcbMsgHash,
                                    LPBYTE *ppbMsgHash);
#endif // SMIME_V3


private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Counting
    DWORD               m_dwState;      // State of this body
    DWORD               m_cbExternal;   // Size of external body if m_dwState, BODYSTATE_EXTERNAL
    LPWSTR              m_pszDisplay;   // Display Name
    BODYOPTIONS         m_rOptions;     // Body Options
    BODYSTORAGE         m_rStorage;     // Body Data Source/Storage
    ENCODINGTYPE        m_ietEncoding;  // Internal Body Format
    LPINETCSETINFO      m_pCharset;     // Character set to be sent with
    LPINETCSETINFO      m_pCsetTagged;  // Original Character Set
    LPCONTAINER         m_pContainer;   // Property Container
    LPTREENODEINFO      m_pNode;        // Tree NodeInfo
    CRITICAL_SECTION    m_cs;           // Thread Safety
    ENCODINGTYPE        m_ietPrevious;  // Previous CTE 
};

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
typedef CMessageBody *LPMESSAGEBODY;

#endif // __BOOKBODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\booktree.cpp ===
// --------------------------------------------------------------------------------
// BookTree.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <stddef.h>
#include "dllmain.h"
#include "booktree.h"
#include "stmlock.h"
#include "ibdylock.h"
#include "resource.h"
#include "vstream.h"
#include "ixputil.h"
#include "olealloc.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "icoint.h"
#include "ibdystm.h"
#include "symcache.h"
#include "urlmon.h"
#include "mhtmlurl.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "inetstm.h"
#include "imnxport.h"
#include "bookbody.h"
#include "mimeapi.h"
#include "strconst.h"
#include "bindstm.h"
#include "enriched.h"
#include "webpage.h"
#include "demand.h"

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// _IsMultiPart
// --------------------------------------------------------------------------------
inline BOOL _IsMultiPart(LPTREENODEINFO pNode)
{ 
    return pNode->pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK; 
}

// --------------------------------------------------------------------------------
// BINDASSERTARGS
// --------------------------------------------------------------------------------
#define BINDASSERTARGS(_bindstate, _fBoundary) \
    Assert(m_pBindNode && m_pBindNode->pBody && m_pBindNode->pContainer && _bindstate == m_pBindNode->bindstate && (FALSE == _fBoundary || ISVALIDSTRINGA(&m_pBindNode->rBoundary)))

// --------------------------------------------------------------------------------
// Array of Bind Parsing States to Functions
// --------------------------------------------------------------------------------
const PFNBINDPARSER CMessageTree::m_rgBindStates[BINDSTATE_LAST] = {
    NULL,                                                              // BINDSTATE_COMPLETE
    (PFNBINDPARSER)CMessageTree::_HrBindParsingHeader,          // BINDSTATE_PARSING_HEADER
    (PFNBINDPARSER)CMessageTree::_HrBindFindingMimeFirst,       // BINDSTATE_FINDING_MIMEFIRST
    (PFNBINDPARSER)CMessageTree::_HrBindFindingMimeNext,        // BINDSTATE_FINDING_MIMENEXT
    (PFNBINDPARSER)CMessageTree::_HrBindFindingUuencodeBegin,   // BINDSTATE_FINDING_UUBEGIN
    (PFNBINDPARSER)CMessageTree::_HrBindFindingUuencodeEnd,     // BINDSTATE_FINDING_UUEND
    (PFNBINDPARSER)CMessageTree::_HrBindRfc1154,                // BINDSTATE_PARSING_RFC1154
};

// --------------------------------------------------------------------------------
// Used in IMimeMessageTree::ToMultipart
// --------------------------------------------------------------------------------
static LPCSTR g_rgszToMultipart[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

// --------------------------------------------------------------------------------
// Used in IMimeMessage::AttachObject IID_IMimeBody
// --------------------------------------------------------------------------------
static LPCSTR g_rgszAttachBody[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

static const WEBPAGEOPTIONS g_rDefWebPageOpt = {
    sizeof(WEBPAGEOPTIONS),                        // cbsize
    WPF_NOMETACHARSET | WPF_HTML | WPF_AUTOINLINE, // dwFlags
    3000,                                          // dwDelay
    NULL                                           // wchQuote
};

// --------------------------------------------------------------------------------
// Default Tree Options
// --------------------------------------------------------------------------------
static const TREEOPTIONS g_rDefTreeOptions = {
    DEF_CLEANUP_TREE_ON_SAVE,       // OID_CLEANUP_TREE_ON_SAVE
    DEF_HIDE_TNEF_ATTACHMENTS,      // OID_HIDE_TNEF_ATTACHMENTS
    DEF_ALLOW_8BIT_HEADER,          // OID_ALLOW_8BIT_HEADER
    DEF_GENERATE_MESSAGE_ID,        // OID_GENERATE_MESSAGE_ID
    DEF_WRAP_BODY_TEXT,             // OID_WRAP_BODY_TEXT
    DEF_CBMAX_HEADER_LINE,          // OID_CBMAX_HEADER_LINE
    DEF_CBMAX_BODY_LINE,            // OID_CBMAX_BODY_LINE
    SAVE_RFC1521,                   // OID_SAVE_FORMAT
    NULL,                           // hCharset
    CSET_APPLY_UNTAGGED,            // csetapply
    DEF_TRANSMIT_TEXT_ENCODING,     // OID_TRANSMIT_TEXT_ENCODING
    DEF_XMIT_PLAIN_TEXT_ENCODING,   // OID_XMIT_PLAIN_TEXT_ENCODING
    DEF_XMIT_HTML_TEXT_ENCODING,    // OID_XMIT_HTML_TEXT_ENCODING
    0,                              // OID_SECURITY_ENCODE_FLAGS
    DEF_HEADER_RELOAD_TYPE_TREE,    // OID_HEADER_REALOD_TYPE
    DEF_CAN_INLINE_TEXT_BODIES,     // OID_CAN_INLINE_TEXT_BODIES
    DEF_SHOW_MACBINARY,             // OID_SHOW_MACBINARY
    DEF_SAVEBODY_KEEPBOUNDARY,      // OID_SAVEBODY_KEEPBOUNDARY
    FALSE,                          // OID_LOAD_USE_BIND_FILE
    DEF_HANDSOFF_ONSAVE,            // OID_HANDSOFF_ONSAVE
    DEF_SUPPORT_EXTERNAL_BODY,      // OID_SUPPORT_EXTERNAL_BODY
    DEF_DECODE_RFC1154              // OID_DECODE_RFC1154
};

extern BOOL FIsMsasn1Loaded();

#ifdef DEBUG
// --------------------------------------------------------------------------------
// These booleans determine if the tree is dumped to the output window
// --------------------------------------------------------------------------------
static BOOL s_fWriteMessageDump     = 0;
static BOOL s_fKeepBoundary         = 0;
static BOOL s_fDumpMessage          = 0;
static BOOL s_fWriteXClient         = 0;

// --------------------------------------------------------------------------------
// This writes the message X-Mailer or X-Newsreader
// --------------------------------------------------------------------------------
void CMessageTree::DebugWriteXClient()
{
    if (s_fWriteXClient)
    {
        LPSTR pszX;
        if (SUCCEEDED(m_pRootNode->pContainer->GetProp(SYM_HDR_XMAILER, &pszX)) && pszX)
        {
            DebugTrace("X-Mailer: %s\n", pszX);
            MemFree(pszX);
        }
        else if (SUCCEEDED(m_pRootNode->pContainer->GetProp(SYM_HDR_XNEWSRDR, &pszX)) && pszX)
        {
            DebugTrace("X-Newsreader: %s\n", pszX);
            MemFree(pszX);
        }
    }
}

// --------------------------------------------------------------------------------
// This dumps the current tree to debug output window
// --------------------------------------------------------------------------------
void CMessageTree::DebugDumpTree(LPSTR pszfunc, BOOL fWrite)
{
    if (TRUE == fWrite)
    {
        DebugTrace("---------------------------------------------------------------------------\n");
        DebugTrace("CMessageTree::%s\n", pszfunc);
    }
    DebugDumpTree(m_pRootNode, 0, fWrite);
}

// --------------------------------------------------------------------------------
// This macros writes _pstm to a file
// --------------------------------------------------------------------------------
#define DEBUGMESSAGEOUT "c:\\lastmsg.txt"
void DebugWriteMsg(LPSTREAM pstm)
{
    if (TRUE == s_fDumpMessage)
    {
        LPSTREAM pstmFile;
        if (SUCCEEDED(OpenFileStream(DEBUGMESSAGEOUT, CREATE_ALWAYS, GENERIC_WRITE, &pstmFile)))
        {
            HrRewindStream(pstm);
            HrCopyStream(pstm, pstmFile, NULL);
            pstmFile->Commit(STGC_DEFAULT);
            pstmFile->Release();
        }
    }
}

#else // DEBUG

#define DebugDumpTree           1 ? (void)0 : (void)
#define DebugWriteMsg           1 ? (void)0 : (void)
#define DebugAssertNotLinked    1 ? (void)0 : (void)
#define DebugIsRootContainer    1 ? (void)0 : (void)

#endif // DEBUG

// --------------------------------------------------------------------------------
// WebBookContentTree_CreateInstance
// --------------------------------------------------------------------------------
HRESULT WebBookContentTree_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageTree *pNew = new CMessageTree(pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// Text Type Information Array
// --------------------------------------------------------------------------------
static const TEXTTYPEINFO g_rgTextInfo[] = {
    { TXT_PLAIN,    STR_SUB_PLAIN,      0 },
    { TXT_HTML,     STR_SUB_HTML,       5 }
};

// --------------------------------------------------------------------------------
// CMessageTree::CMessageTree
// --------------------------------------------------------------------------------
CMessageTree::CMessageTree(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_dwState = 0;
    m_pCallback = NULL;
    m_pBindNode = NULL;
    m_pRootStm = NULL;
    m_pInternet = NULL;
    m_pStmBind = NULL;
    m_pBinding = NULL;
    m_pMoniker = NULL;
    m_pBC = NULL;
    m_cbMessage = 0;
    m_pStmLock = NULL;
    m_pRootNode = NULL;
    m_pwszFilePath = NULL;
    m_hrBind = S_OK;
    m_pPending = NULL;
    m_pComplete = NULL;
    m_wTag = LOWORD(GetTickCount());
    m_pActiveUrl = NULL;
    m_pWebPage = NULL;
    m_fApplySaveSecurity = FALSE;
    m_pBT1154 = NULL;
    while(m_wTag == 0 || m_wTag == 0xffff) m_wTag++;
    ZeroMemory(&m_rRootUrl, sizeof(PROPSTRINGA));
    ZeroMemory(&m_rTree, sizeof(TREENODETABLE));
    CopyMemory(&m_rWebPageOpt, &g_rDefWebPageOpt, sizeof(WEBPAGEOPTIONS));
    CopyMemory(&m_rOptions, &g_rDefTreeOptions, sizeof(TREEOPTIONS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageTree::~CMessageTree
// --------------------------------------------------------------------------------
CMessageTree::~CMessageTree(void)
{
    if(m_pActiveUrl && g_pUrlCache)
    {
        //Bug #101348 - free CActiveUrl leaked to the CMimeActiveUrlCache
        g_pUrlCache->RemoveUrl(m_pActiveUrl);
        m_pActiveUrl = NULL;
    }
	
    // Reset the Object
    _ResetObject(BOOKTREE_RESET_DECONSTRUCT);
    SafeRelease(m_pStmLock);


    // Kill the Critical Section
    DeleteCriticalSection(&m_cs);

    // Releaes the Dll
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMessageTree::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CMessageTree::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Interface Map
    if (IID_IPersist == riid)
        *ppv = (IPersist *)(IPersistStreamInit *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_IMimeMessage == riid)
        *ppv = (IMimeMessage *)this;
    else if (IID_IMimeMessageW == riid)
        *ppv = (IMimeMessageW *)this;
    else if (IID_IMimeMessageTree == riid)
        *ppv = (IMimeMessageTree *)this;
    else if (IID_IDataObject == riid)
        *ppv = (IDataObject *)this;
    else if (IID_IPersistFile == riid)
        *ppv = (IPersistFile *)this;
    else if (IID_IBindStatusCallback == riid)
        *ppv = (IBindStatusCallback *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_CMessageTree == riid)
        *ppv = (CMessageTree *)this;
    else if (IID_IPersistMoniker == riid)
        *ppv = (IPersistMoniker *)this;
#ifdef SMIME_V3
    else if (IID_IMimeSecurity2 == riid)
        *ppv = (IMimeSecurity2 *) this;
#endif // SMIME_V3   

    // E_NOINTERFACE
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// CMessageTree::DebugDumpTree
// --------------------------------------------------------------------------------
void CMessageTree::DebugDumpTree(LPTREENODEINFO pParent, ULONG ulLevel, BOOL fVerbose)
{
    // Locals
    LPSTR           pszPriType=NULL,
                    pszEncoding=NULL,
                    pszFileName=NULL;
    LPTREENODEINFO  pChild,
                    pPrev,
                    pNext;
    ULONG           cChildren;
    LONG            lRendered=-1;
    PROPVARIANT     rVariant;

    // Get Content Type
    if (fVerbose)
    {
        Assert(pParent->pContainer->GetProp(SYM_HDR_CNTTYPE, &pszPriType) == S_OK);
        Assert(pParent->pContainer->GetProp(SYM_HDR_CNTXFER,  &pszEncoding) == S_OK);
        Assert(pParent->pContainer->GetProp(SYM_ATT_GENFNAME,  &pszFileName) == S_OK);

        rVariant.vt = VT_UI4;
        if (SUCCEEDED(pParent->pContainer->GetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)))
            lRendered = (LONG)rVariant.ulVal;

        for (ULONG i=0; i<ulLevel; i++)
            DebugTrace("     ");
        DebugTrace("%0x == > %s (%s - %s) Rendered: %ld\n", pParent->hBody, pszPriType, pszFileName, pszEncoding, lRendered);
    }
 
    // IsMultiPart
    if (_IsMultiPart(pParent))
    {
        // Count Children
        cChildren = 0;
        pPrev = NULL;

        // Increment the level
        ulLevel++;

        // Loop Chilren
        for (pChild=pParent->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Verify Handle
            Assert(_FIsValidHandle(pChild->hBody));

            // Check Parent
            AssertSz(pChild->pParent == pParent, "Parent is wrong");

            // Check pParent Child Head
            if (NULL == pChild->pPrev)
                Assert(pParent->pChildHead == pChild);

            // Check pParent Child Tail
            if (NULL == pChild->pNext)
                Assert(pParent->pChildTail == pChild);

            // Valid Prev
            Assert(pChild->pPrev == pPrev);

            // Dump This Child
            DebugDumpTree(pChild, ulLevel, fVerbose);

            // Count Children
            cChildren++;

            // Set Previous
            pPrev = pChild;
        }

        // Verify Children
        Assert(pParent->cChildren == cChildren);
    }

    // Cleanup
    SafeMemFree(pszPriType);
    SafeMemFree(pszEncoding);
    SafeMemFree(pszFileName);
}

// --------------------------------------------------------------------------------
// CMessageTree::DebugAssertNotLinked
// This insures that pNode is not referenced by the tree
// --------------------------------------------------------------------------------
void CMessageTree::DebugAssertNotLinked(LPTREENODEINFO pNode)
{
    // Better not be the root
    Assert(m_pRootNode != pNode);

    // Loop through bodies
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        if (NULL == m_rTree.prgpNode[i])
            continue;
        
        // Check if linked to pBody
        Assert(m_rTree.prgpNode[i]->pParent != pNode);
        Assert(m_rTree.prgpNode[i]->pChildHead != pNode);
        Assert(m_rTree.prgpNode[i]->pChildTail != pNode);
        Assert(m_rTree.prgpNode[i]->pNext != pNode);
        Assert(m_rTree.prgpNode[i]->pPrev != pNode);
    }
}

#endif // DEBUG

// --------------------------------------------------------------------------------
// CMessageTree::IsState
// --------------------------------------------------------------------------------
HRESULT CMessageTree::IsState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, dwState)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetRootMoniker (This Function will die soon)
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetRootMoniker(LPMONIKER *ppmk)
{
    Assert(FALSE);
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::CreateWebPage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, 
    IMimeMessageCallback *pCallback, IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pwszRootUrl=NULL;

    // Invalid Arg
    if (NULL == ppMoniker)
        return TrapError(E_INVALIDARG);

    // If an options structure was passed in, is it the right size ?
    if (pOptions && sizeof(WEBPAGEOPTIONS) != pOptions->cbSize)
        return TrapError(E_INVALIDARG);

    // Init
    *ppMoniker = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release Current BindRoot Stream
    SafeRelease(m_pRootStm);
    SafeRelease(m_pWebPage);

    // Null pStream is allowed
    if (pStmRoot)
    {
        // Save Root Stream
        m_pRootStm = pStmRoot;
        m_pRootStm->AddRef();
    }

    // Otherwise, we can inline text bodies...
    else
    {
        // Change Option
        m_rOptions.fCanInlineText = TRUE;
    }

    // Release current webpage callback
    SafeRelease(m_pCallback);

    // Setup the new webpage callback
    if (pCallback)
    {
        m_pCallback = pCallback;
        m_pCallback->AddRef();
    }

    // Save WebPageOptions
    if (pOptions)
        CopyMemory(&m_rWebPageOpt, pOptions, sizeof(WEBPAGEOPTIONS));
    else
        CopyMemory(&m_rWebPageOpt, &g_rDefWebPageOpt, sizeof(WEBPAGEOPTIONS));

    // Already have a Base Url from IMimeMessageTree::IPersitMoniker::Load
    if (NULL == m_rRootUrl.pszVal)
    {
        // Locals
        CHAR szRootUrl[CCHMAX_MID + 8];

        // Build MessageID
        m_rRootUrl.cchVal = wnsprintf(szRootUrl, ARRAYSIZE(szRootUrl), "mhtml:mid://%08d/", DwCounterNext());

        // Allocate
        CHECKALLOC(m_rRootUrl.pszVal = (LPSTR)g_pMalloc->Alloc(m_rRootUrl.cchVal + 1));

        // Copy memory
        CopyMemory((LPBYTE)m_rRootUrl.pszVal, (LPBYTE)szRootUrl, m_rRootUrl.cchVal + 1);

        // Register this object in the list of active objects
        Assert(g_pUrlCache);
        CHECKHR(hr = g_pUrlCache->RegisterActiveObject(m_rRootUrl.pszVal, this));

        // We shuould have a m_pActiveUrl now
        Assert(m_pActiveUrl != NULL);

        // Set some flags on the activeurl
        m_pActiveUrl->SetFlag(ACTIVEURL_ISFAKEURL);

        // Is valid
        Assert(ISVALIDSTRINGA(&m_rRootUrl));
    }

    // Convert Url to Wide
    CHECKALLOC(pwszRootUrl = PszToUnicode(CP_ACP, m_rRootUrl.pszVal));

    // Create a dummy moniker
    CHECKHR(hr = CreateURLMoniker(NULL, pwszRootUrl, ppMoniker));

exit:
    // Cleanup
    SafeMemFree(pwszRootUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::SetActiveUrl
// ---------------------------------------------------------------------------
HRESULT CMessageTree::SetActiveUrl(CActiveUrl *pActiveUrl)  
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NULL ?
    if (NULL == pActiveUrl)
    {
        Assert(m_pActiveUrl);
        SafeRelease(m_pActiveUrl);
    }
    else
    {
        Assert(NULL == m_pActiveUrl);
        m_pActiveUrl = pActiveUrl;
        m_pActiveUrl->AddRef();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::CompareRootUrl
// --------------------------------------------------------------------------------
HRESULT CMessageTree::CompareRootUrl(LPCSTR pszUrl) 
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid ARg
    Assert(pszUrl);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Root Url
    if (NULL == m_rRootUrl.pszVal)
    {
        Assert(FALSE);
        hr = S_FALSE;
        goto exit;
    }

    // This url must start with mhtml:
    Assert(StrCmpNI(m_rRootUrl.pszVal, "mhtml:", 6) == 0);

    // Compare
    hr = MimeOleCompareUrl(m_rRootUrl.pszVal + 6, FALSE, pszUrl, FALSE);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Load
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pStream=NULL;
    ULONG           cb;
    LPOLESTR        pwszUrl=NULL;
    LPSTR           pszUrl=NULL;
    ULONG           cchUrl;
    BOOL            fReSynchronize;

    // Invalid Arg
    if (NULL == pMoniker)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Remember if TREESTATE_RESYNCHRONIZE is set...
    fReSynchronize = ISFLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE);

    // InitNew
    CHECKHR(hr = _HrLoadInitNew());

    // Reset pragma no cache
    if (fReSynchronize)
    {
        // Reset 
        FLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE);
    }

    // We better have a tree
    Assert(NULL == m_pMoniker);

    // Assume the Moniker
    m_pMoniker = pMoniker;
    m_pMoniker->AddRef();

    // No Bind Context was given ?
    if (NULL == pBindCtx)
    {
        // Create me a BindContext
        CHECKHR(hr = CreateBindCtx(0, &pBindCtx));
    }

    // Otherwise, assume the Bind Context Passed Into me
    else
        pBindCtx->AddRef();

    Assert (m_pBC==NULL);
    m_pBC = pBindCtx;   // released in OnStopBinding
    
    // Get the Url from this dude
    CHECKHR(hr = m_pMoniker->GetDisplayName(NULL, NULL, &pwszUrl));

    // Save as Root Url
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Raid-2508: Comment tag ( <! comment> ) doesn't work in mhtml
    ReplaceChars(pszUrl, '!', '_');

    // Better not have mhtml: on it
    Assert(StrCmpNI(pszUrl, "mhtml:", 6) != 0);

    // Get the length of pszUrl
    cchUrl = lstrlen(pszUrl);

    // Create "mhtml://" + pszUrl + '/' + '\0'
    DWORD cchSize = (10 + cchUrl);
    CHECKALLOC(m_rRootUrl.pszVal = (LPSTR)g_pMalloc->Alloc(cchSize));

    // Format the string
    SideAssert(wnsprintf(m_rRootUrl.pszVal, cchSize, "%s%s", c_szMHTMLColon, pszUrl) <= (LONG)(10 + cchUrl));

    // Register my bind status callback in the bind context
    CHECKHR(hr = RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *)this, NULL, 0));

    // Assume the Bind has Finished
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // I only support share deny none
    FLAGSET(m_dwState, TREESTATE_BINDUSEFILE);

    // I was loaded by a moniker
    FLAGSET(m_dwState, TREESTATE_LOADEDBYMONIKER);

    // This better be synchronous
    hr = m_pMoniker->BindToStorage(pBindCtx, NULL, IID_IStream, (LPVOID *)&pStream);
    if (FAILED(hr) || MK_S_ASYNCHRONOUS == hr)
    {
        TrapError(hr);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pwszUrl);
    SafeMemFree(pszUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetCurMoniker
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCurMoniker(IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppMoniker)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pMoniker)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Return It
    *ppMoniker = m_pMoniker;
    (*ppMoniker)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetCurFile
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCurFile(LPOLESTR *ppszFileName)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Return File Name
    if (NULL == m_pwszFilePath)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Dup and return
    CHECKALLOC(*ppszFileName = PszDupW(m_pwszFilePath));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Load
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmFile=NULL;
    DWORD       dwAccess=GENERIC_READ;
    DWORD       dwShare=FILE_SHARE_READ|FILE_SHARE_WRITE;
    BOOL        fBindUseFile;

    // Invalid Arg
    if (NULL == pszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Determine Access
    if (ISFLAGSET(dwMode, STGM_WRITE))
        FLAGSET(dwAccess, GENERIC_WRITE);
    if (ISFLAGSET(dwMode, STGM_READWRITE))
        FLAGSET(dwAccess, GENERIC_READ | GENERIC_WRITE);

    // Determine Share Mode
    dwMode &= 0x00000070; //  the STGM_SHARE_* flags are not individual bits
    if (STGM_SHARE_DENY_NONE == dwMode)
        dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
    else if (STGM_SHARE_DENY_READ == dwMode)
        dwShare = FILE_SHARE_WRITE;
    else if (STGM_SHARE_DENY_WRITE == dwMode)
        dwShare = FILE_SHARE_READ;
    else if (STGM_SHARE_EXCLUSIVE == dwMode)
        dwShare = 0;

    // Save Option
    fBindUseFile = m_rOptions.fBindUseFile;

    // If the user wants file sharing on this file, then I need to put this into my own file
    if (ISFLAGSET(dwShare, FILE_SHARE_WRITE))
        m_rOptions.fBindUseFile = TRUE;

    // Open File Stream
    CHECKHR(hr = OpenFileStreamShareW((LPWSTR)pszFileName, OPEN_EXISTING, dwAccess, dwShare, &pstmFile));

    // Bind the message
    CHECKHR(hr = Load(pstmFile));

    // Reset Option
    m_rOptions.fBindUseFile = fBindUseFile;

    // Free Current File
    SafeMemFree(m_pwszFilePath);

    // Assume new file
    CHECKALLOC(m_pwszFilePath = PszDupW(pszFileName));

exit:
    // Cleanup
    SafeRelease(pstmFile);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Save
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmFile=NULL,
               *pstmSource=NULL;

    // Invalid Arg
    if (NULL == pszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Open File Stream
    CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFileName, CREATE_ALWAYS, GENERIC_READ | GENERIC_WRITE, &pstmFile));
   
    // If Remember
    if (fRemember)
    {
        // Bind the message
        CHECKHR(hr = Save(pstmFile, TRUE));
    }

    // Otherwise, get message source, and copy...
    else
    {
        // Get Message Source
        CHECKHR(hr = GetMessageSource(&pstmSource, COMMIT_ONLYIFDIRTY));

        // Copy...
        CHECKHR(hr = HrCopyStream(pstmSource, pstmFile, NULL));
    }

    // Commit
    CHECKHR(hr = pstmFile->Commit(STGC_DEFAULT));

    // If Remember
    if (fRemember)
    {
        // Free Current File
        SafeMemFree(m_pwszFilePath);

        // Assume new file
        CHECKALLOC(m_pwszFilePath = PszDupW(pszFileName));
    }

exit:
    // Cleanup
    SafeRelease(pstmFile);
    SafeRelease(pstmSource);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::SaveCompleted
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetClassID
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetClassID(CLSID *pClassID)
{
    // Invalid Arg
    if (NULL == pClassID)
        return TrapError(E_INVALIDARG);

    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimeMessageTree, sizeof(CLSID));

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetSizeMax
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cbSize;

    // Invalid Arg
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);

    // INit
    pcbSize->QuadPart = 0;

    // Get Message Size
    CHECKHR(hr = GetMessageSize(&cbSize, COMMIT_ONLYIFDIRTY));

    // Set Size
    pcbSize->QuadPart = cbSize;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::_FIsValidHandle
// ----------------------------------------------------------------------------
BOOL CMessageTree::_FIsValidHandle(HBODY hBody)
{
    // Its Valid
    if ((WORD)HBODYTAG(hBody) == m_wTag && 
        HBODYINDEX(hBody) < m_rTree.cNodes && 
        m_rTree.prgpNode[HBODYINDEX(hBody)] && 
        m_rTree.prgpNode[HBODYINDEX(hBody)]->hBody == hBody)
        return TRUE;

    // Not Valid
    return FALSE;
}

// ----------------------------------------------------------------------------
// CMessageTree::_PNodeFromHBody
// ----------------------------------------------------------------------------
LPTREENODEINFO CMessageTree::_PNodeFromHBody(HBODY hBody)
{
    Assert(_FIsValidHandle(hBody));
    return m_rTree.prgpNode[HBODYINDEX(hBody)];
}

// --------------------------------------------------------------------------------
// CMessageTree::GetMessageSize
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetMessageSize(ULONG *pcbSize, DWORD dwFlags)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmSource=NULL;

    // Invalid Arg
    if (pcbSize == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *pcbSize = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the message source
    CHECKHR(hr = GetMessageSource(&pstmSource, dwFlags));

    // Get the stream Size
    CHECKHR(hr = HrGetStreamSize(pstmSource, pcbSize));

    // If you hit this assert, please let me know. t-erikne
    // I'm trying to see if we have to call HrGetStreamSize here.
    Assert(m_cbMessage == *pcbSize);

exit:
    // Cleanup
    SafeRelease(pstmSource);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::_ApplyOptionToAllBodies
// ---------------------------------------------------------------------------
void CMessageTree::_ApplyOptionToAllBodies(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // Loop through bodies and set on each body
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Check if deleted
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Dirty Header...
        m_rTree.prgpNode[i]->pBody->SetOption(oid, pValue);
    }
}

// ---------------------------------------------------------------------------
// CMessageTree::SetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetOption(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_HANDSOFF_ONSAVE:
        m_rOptions.fHandsOffOnSave = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_SUPPORT_EXTERNAL_BODY:
        _ApplyOptionToAllBodies(oid, pValue);
        break;

    case OID_SHOW_MACBINARY:
        if (m_rOptions.fShowMacBin != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fShowMacBin = pValue->boolVal ? TRUE : FALSE;
            _ApplyOptionToAllBodies(oid, pValue);
        }
        break;

    case OID_HEADER_RELOAD_TYPE:
        if (pValue->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pValue->ulVal;
        }
        break;

    case OID_LOAD_USE_BIND_FILE:
        m_rOptions.fBindUseFile = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_CLEANUP_TREE_ON_SAVE:
        m_rOptions.fCleanupTree = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_SAVEBODY_KEEPBOUNDARY:
        if (m_rOptions.fKeepBoundary != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fKeepBoundary = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CAN_INLINE_TEXT_BODIES:
        if (m_rOptions.fCanInlineText != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fCanInlineText = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        if (m_rOptions.fHideTnef != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fHideTnef = pValue->boolVal ? TRUE : FALSE;
            _ApplyOptionToAllBodies(oid, pValue);
        }
        break;

    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bitHeader != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fAllow8bitHeader = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CBMAX_HEADER_LINE:
        if (pValue->ulVal < MIN_CBMAX_HEADER_LINE || pValue->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cchMaxHeaderLine != pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.cchMaxHeaderLine = pValue->ulVal;
        }
        break;

    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pValue->ulVal && SAVE_RFC1521 != pValue->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pValue->ulVal;
        }
        break;

    case OID_TRANSMIT_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietTextXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietTextXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_XMIT_PLAIN_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietPlainXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietPlainXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_XMIT_HTML_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietHtmlXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietHtmlXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_WRAP_BODY_TEXT:
        if (m_rOptions.fWrapBodyText != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fWrapBodyText = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CBMAX_BODY_LINE:
        if (pValue->ulVal < MIN_CBMAX_BODY_LINE || pValue->ulVal > MAX_CBMAX_BODY_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cchMaxBodyLine != pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.cchMaxBodyLine = pValue->ulVal;
        }
        break;

    case OID_GENERATE_MESSAGE_ID:
        if (m_rOptions.fGenMessageId != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fGenMessageId = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        m_rOptions.ulSecIgnoreMask = pValue->ulVal;
        break;

    case OID_DECODE_RFC1154:
        m_rOptions.fDecodeRfc1154 = pValue->boolVal ? TRUE : FALSE;
        break;

    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::GetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetOption(const TYPEDID oid, LPPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    pValue->vt = TYPEDID_TYPE(oid);

    // Handle Optid
    switch(oid)
    {
    case OID_HANDSOFF_ONSAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHandsOffOnSave;
        break;

    case OID_LOAD_USE_BIND_FILE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fBindUseFile;
        break;

    case OID_SHOW_MACBINARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fShowMacBin;
        break;

    case OID_HEADER_RELOAD_TYPE:
        pValue->ulVal = m_rOptions.ReloadType;
        break;

    case OID_CAN_INLINE_TEXT_BODIES:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCanInlineText;
        break;

    case OID_CLEANUP_TREE_ON_SAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCleanupTree;
        break;

    case OID_SAVEBODY_KEEPBOUNDARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fKeepBoundary;
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHideTnef;
        break;

    case OID_ALLOW_8BIT_HEADER:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fAllow8bitHeader;
        break;

    case OID_WRAP_BODY_TEXT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fWrapBodyText;
        break;

    case OID_CBMAX_HEADER_LINE:
        pValue->ulVal = m_rOptions.cchMaxHeaderLine;
        break;

    case OID_SAVE_FORMAT:
        pValue->ulVal = (ULONG)m_rOptions.savetype;
        break;    

    case OID_TRANSMIT_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietTextXmit;
        break;

    case OID_XMIT_PLAIN_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietPlainXmit;
        break;

    case OID_XMIT_HTML_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietHtmlXmit;
        break;

    case OID_CBMAX_BODY_LINE:
        pValue->ulVal = m_rOptions.cchMaxBodyLine;
        break;

    case OID_GENERATE_MESSAGE_ID:
        pValue->boolVal = m_rOptions.fGenMessageId;
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        pValue->ulVal = m_rOptions.ulSecIgnoreMask;
        break;

    case OID_DECODE_RFC1154:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fDecodeRfc1154;
        break;

    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_ResetObject
// --------------------------------------------------------------------------------
void CMessageTree::_ResetObject(BOOKTREERESET ResetType)
{
    // Load InitNew
    if (BOOKTREE_RESET_LOADINITNEW == ResetType)
    {
        // There has to be a root (look at impl of ::_HrLoadInitNew)
        Assert(m_pRootNode);

        // Don't Crash
        if (m_pRootNode)
        {
            // Delete all bodies, except for the root, if there is one...
            if (m_pRootNode->pBody->IsType(IBT_EMPTY) == S_FALSE || m_pRootNode->pContainer->CountProps() > 0)
            {
                // Delete the root body, this simply removed properties and empties the body, but leave the root body
                DeleteBody(m_pRootNode->hBody, 0);
            }

            // Lighweight FreeTree Node Info
            _FreeTreeNodeInfo(m_pRootNode, FALSE);

            // Validate
            Assert(m_pRootNode->cChildren == 0);
            Assert(m_pRootNode->pParent == NULL);
            Assert(m_pRootNode->pNext == NULL);
            Assert(m_pRootNode->pPrev == NULL);
            Assert(m_pRootNode->pChildHead == NULL);
            Assert(m_pRootNode->pChildTail == NULL);
            Assert(m_pRootNode->pBody);
            Assert(m_pRootNode->pContainer);

            // Quick Reset
            TREENODEINFO rTemp;
            CopyMemory(&rTemp, m_pRootNode, sizeof(TREENODEINFO));
            ZeroMemory(m_pRootNode, sizeof(TREENODEINFO));
            m_pRootNode->pBody = rTemp.pBody;
            m_pRootNode->pContainer = rTemp.pContainer;
            m_pRootNode->hBody = rTemp.hBody;

            // Set OID_RELOAD_HEADER_TYPE
            PROPVARIANT rOption;
            rOption.vt = VT_UI4;
            rOption.ulVal = (ULONG)m_rOptions.ReloadType;
            m_pRootNode->pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption);
        }
    }

    // Free All Elements
    else
        _FreeNodeTableElements();

    // Free Bind Request Table
    _ReleaseUrlRequestList(&m_pPending);
    _ReleaseUrlRequestList(&m_pComplete);

    // Free and Release Objects
    SafeRelease(m_pCallback);
    SafeRelease(m_pWebPage);
    SafeMemFree(m_pwszFilePath);
    SafeRelease(m_pBinding);
    SafeRelease(m_pMoniker);
    SafeRelease(m_pBC);
    SafeRelease(m_pInternet);
    SafeRelease(m_pStmBind);
    SafeRelease(m_pRootStm);
    SafeMemFree(m_rRootUrl.pszVal);
    SafeMemFree(m_pBT1154);

    // Clear Current BindNode
    m_pBindNode = NULL;

    // Orphan CStreamLockBytes
    if (m_pStmLock)
    {
        m_pStmLock->HrHandsOffStorage();
        m_pStmLock->Release();
        m_pStmLock = NULL;
    }

    // If Deconstructing
    if (BOOKTREE_RESET_DECONSTRUCT == ResetType)
    {
        // Release the body table array
        SafeMemFree(m_rTree.prgpNode);

        // If I'm registered as a Url
        if (m_pActiveUrl)
            m_pActiveUrl->RevokeWebBook(this);

        // Better not have an active Url
        Assert(NULL == m_pActiveUrl);
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrLoadInitNew
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrLoadInitNew(void)
{
    // Locals
    HRESULT hr=S_OK;

    // If there is not root body, normal InitNew
    if (NULL == m_pRootNode || RELOAD_HEADER_RESET == m_rOptions.ReloadType)
    {
        // InitNew
        CHECKHR(hr = InitNew());
    }

    // Otherwise, smart init new, allowing root header merge
    else
    {
        // Reset the Object
        _ResetObject(BOOKTREE_RESET_LOADINITNEW);

        // Reset Vars
        m_cbMessage = 0;
        m_dwState = 0;

        // Assume the Bind has Finished
        FLAGSET(m_dwState, TREESTATE_BINDDONE);

        // Reset charset to system charset
        m_rOptions.pCharset = CIntlGlobals::GetDefBodyCset();
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_InitNewWithoutRoot
// --------------------------------------------------------------------------------
void CMessageTree::_InitNewWithoutRoot(void)
{
    // Reset the Object
    _ResetObject(BOOKTREE_RESET_INITNEW);

    // Reset Vars
    m_cbMessage = 0;
    m_dwState = 0;
    m_wTag++;

    // Invalid Tag Numbers
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // Assume the Bind has Finished
    FLAGSET(m_dwState, TREESTATE_BINDDONE);

    // Reset charset to system charset
    m_rOptions.pCharset = CIntlGlobals::GetDefBodyCset();
}

// --------------------------------------------------------------------------------
// CMessageTree::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::InitNew(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // _InitNewWithoutRoot
    _InitNewWithoutRoot();

    // Init the Root Body...
    CHECKHR(hr = InsertBody(IBL_ROOT, NULL, NULL));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::IsDirty(void)
{
    // Locals
    HRESULT     hr=S_FALSE;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty...
    if (ISFLAGSET(m_dwState, TREESTATE_DIRTY))
    {
        hr = S_OK;
        goto exit;
    }

    // Loop through bodies and ask IMimeHeader's and IMimeBody's
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Better have it
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Dirty Header...
        if (m_rTree.prgpNode[i]->pBody->IsDirty() == S_OK)
        {
            hr = S_OK;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_RecursiveGetFlags
// --------------------------------------------------------------------------------
void CMessageTree::_RecursiveGetFlags(LPTREENODEINFO pNode, LPDWORD pdwFlags, BOOL fInRelated)
{
    // Locals
    DWORD           dw;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode && pdwFlags);

    // $$WARNING$$ Don't use pNode->pContainer here, that will circumvent CMimeBody's chance to set some flags
    dw = pNode->pBody->DwGetFlags(m_rOptions.fHideTnef);

    // If in related, clear IMF_ATTACHMENTS
    if (fInRelated)
        FLAGCLEAR(dw, IMF_ATTACHMENTS);

    // Raid-44446: not getting paperclip icon in listview on pegasus messages w/ text attach
    // If dw has text and no attachments and pdwFlags has text and no attachments, add attachments
    //
    // Raid-11617: OE: GetAttachmentCount should not include vcards
    if (ISFLAGSET(dw, IMF_TEXT) && !ISFLAGSET(dw, IMF_HASVCARD) && ISFLAGSET(*pdwFlags, IMF_TEXT) && !ISFLAGSET(dw, IMF_ATTACHMENTS) && !ISFLAGSET(*pdwFlags, IMF_ATTACHMENTS))
    {
        // As long as pNode is not in an alternative section
        if (NULL == pNode->pParent || pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_FALSE)
        {
            // This message must have text attachments
            FLAGSET(*pdwFlags, IMF_ATTACHMENTS);
        }
    }

    // Add in Flags
    FLAGSET(*pdwFlags, dw);

    // Partial...
    if (ISFLAGSET(pNode->dwType, NODETYPE_INCOMPLETE))
        FLAGSET(*pdwFlags, IMF_PARTIAL);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Sub-multipart
        FLAGSET(*pdwFlags, IMF_SUBMULTIPART);

        // If fInRelated == FALSE...
        if (FALSE == fInRelated)
            fInRelated = (S_OK == pNode->pContainer->IsContentType(NULL, STR_SUB_RELATED) ? TRUE : FALSE);

        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Get the flags for this child node
            _RecursiveGetFlags(pChild, pdwFlags, fInRelated);
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::DwGetFlags
// --------------------------------------------------------------------------------
DWORD CMessageTree::DwGetFlags(void)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Recurse the tree
    if (m_pRootNode && m_pRootNode->pBody->IsType(IBT_EMPTY) == S_FALSE)
        _RecursiveGetFlags(m_pRootNode, &dwFlags, (S_OK == m_pRootNode->pContainer->IsContentType(NULL, STR_SUB_RELATED) ? TRUE : FALSE));

    if (m_pRootNode && ISFLAGSET(m_pRootNode->dwType, NODETYPE_RFC1154_ROOT))
        FLAGSET(dwFlags, IMF_RFC1154);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetFlags
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetFlags(DWORD *pdwFlags)
{
    // Invalid Arg
    if (NULL == pdwFlags)
        return TrapError(E_INVALIDARG);

    // dwgetflags has a critsec
    *pdwFlags = DwGetFlags();

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMessageTree::_FreeTreeNodeInfo
// ----------------------------------------------------------------------------
void CMessageTree::_FreeTreeNodeInfo(LPTREENODEINFO pNode, BOOL fFull /* TRUE */)
{
    // Invalid
    Assert(pNode);

    // Free Boundary info
    if (!ISFLAGSET(pNode->dwState, NODESTATE_BOUNDNOFREE))
        SafeMemFree(pNode->rBoundary.pszVal);

    // Full Free
    if (TRUE == fFull)
    {
        // Release the Container
        SafeRelease(pNode->pContainer);

        // Revoke the TreeNode from the body
        if (pNode->pBody)
        {
            // Revoke pNode
            pNode->pBody->RevokeTreeNode();

            // Release the body object
            SafeRelease(pNode->pBody);

            // Null It
            pNode->pBody = NULL;
        }
    }

    // Orphan the lockbytes
    if (pNode->pLockBytes)
    {
        // Orhpan It
        pNode->pLockBytes->HrHandsOffStorage();

        // Release Body Lock Bytes
        SafeRelease(pNode->pLockBytes);
    }

    // Free Bind Request List
    if (pNode->pResolved)
        _ReleaseUrlRequestList(&pNode->pResolved);

    // Free the node
    if (fFull)
        g_pMalloc->Free(pNode);
}

// ----------------------------------------------------------------------------
// CMessageTree::_FreeNodeTableElements
// ----------------------------------------------------------------------------
void CMessageTree::_FreeNodeTableElements(void)
{
    // Release all of the headers
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Better have a bindinfo
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Free the node info
        _FreeTreeNodeInfo(m_rTree.prgpNode[i]);
    }

    // Zero
    m_rTree.cNodes = 0;
    m_rTree.cEmpty = 0;

    // No Root Body...
    m_pRootNode = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrAllocateTreeNode
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrAllocateTreeNode(ULONG ulIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // Check Params
    Assert(ulIndex < m_rTree.cAlloc);

    // Allocate a TREENODEINFO Object
    CHECKALLOC(pNode = (LPTREENODEINFO)g_pMalloc->Alloc(sizeof(TREENODEINFO)));

    // ZeroInit
    ZeroMemory(pNode, sizeof(TREENODEINFO));

    // Allocate the body
    CHECKALLOC(pNode->pBody = new CMessageBody(pNode));

    // InitNew
    CHECKHR(hr = pNode->pBody->InitNew());

    // Pass Down Some Inherited Options
    if (m_rOptions.fExternalBody != DEF_SUPPORT_EXTERNAL_BODY)
    {
        // Locals
        PROPVARIANT Variant;

        // Initialize the Variant
        Variant.vt = VT_BOOL;
        Variant.boolVal = (VARIANT_BOOL) !!m_rOptions.fExternalBody;

        // Set the Option
        SideAssert(SUCCEEDED(pNode->pBody->SetOption(OID_SUPPORT_EXTERNAL_BODY, &Variant)));
    }

    // Get the Container
    SideAssert(SUCCEEDED(pNode->pBody->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pNode->pContainer)));

    // Create hBody
    pNode->hBody = HBODYMAKE(ulIndex);

    // Readability
    m_rTree.prgpNode[ulIndex] = pNode;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::LoadOffsetTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::LoadOffsetTable(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    CACHEINFOV2     rInfo;
    LPCACHENODEV2   prgNode=NULL;
    ULONG           cbNodes,
                    i;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init New
    _InitNewWithoutRoot();

    // Free the root
    Assert(NULL == m_pRootNode && 0 == m_rTree.cNodes);

    // Read Header...
    CHECKHR(hr = pStream->Read(&rInfo, sizeof(CACHEINFOV2), NULL));

    // Current Version...
    if (VER_BODYTREEV2 == rInfo.wVersion)
    {
        // Save Message Size
        m_cbMessage = rInfo.cbMessage;

        // Are there bodies...
        Assert(rInfo.cNodes >= 1);

        // Better have a root
        if (FVerifySignedNode(rInfo, rInfo.iRoot) == FALSE)
        {
            hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
            goto exit;
        }

        // Compute sizeof Nodes
        cbNodes = sizeof(CACHENODEV2) * rInfo.cNodes;
        Assert(cbNodes % 4 == 0);

        // Allocate prgNode array
        CHECKHR(hr = HrAlloc((LPVOID *)&prgNode, cbNodes));
    
        // Read Nodes...
        CHECKHR(hr = pStream->Read(prgNode, cbNodes, NULL));

        // Set body count
        m_rTree.cNodes = rInfo.cNodes;
        m_rTree.cAlloc = m_rTree.cNodes + 5;

        // Build Body Table
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTree.prgpNode, sizeof(LPTREENODEINFO) * m_rTree.cAlloc));

        // Zero Init
        ZeroMemory(m_rTree.prgpNode, sizeof(LPTREENODEINFO) * m_rTree.cAlloc);

        // Build bodies
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Allocate LPBINDINFO
            CHECKHR(hr = _HrAllocateTreeNode(i));
        }

        // Link Body Table
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability
            pNode = m_rTree.prgpNode[i];
            Assert(pNode);

            // Flags
            pNode->dwType = prgNode[i].dwType;

            // Number of Children
            pNode->cChildren = prgNode[i].cChildren;

            // Valid Boundary
            if (prgNode[i].dwBoundary >= BOUNDARY_LAST || 2 == prgNode[i].dwBoundary)
                pNode->boundary = BOUNDARY_NONE;
            else
                pNode->boundary = (BOUNDARYTYPE)prgNode[i].dwBoundary;

            // Offset
            pNode->cbBoundaryStart = prgNode[i].cbBoundaryStart;
            pNode->cbHeaderStart = prgNode[i].cbHeaderStart;
            pNode->cbBodyStart = prgNode[i].cbBodyStart;
            pNode->cbBodyEnd = prgNode[i].cbBodyEnd;

            // Parent
            if (prgNode[i].iParent)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iParent) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the parent
                pNode->pParent = PNodeFromSignedNode(prgNode[i].iParent);
            }

            // Next
            if (prgNode[i].iNext)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iNext) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the Next
                pNode->pNext = PNodeFromSignedNode(prgNode[i].iNext);
            }

            // Prev
            if (prgNode[i].iPrev)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iPrev) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the Prev
                pNode->pPrev = PNodeFromSignedNode(prgNode[i].iPrev);
            }

            // First Child
            if (prgNode[i].iChildHead)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iChildHead) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the first child
                pNode->pChildHead = PNodeFromSignedNode(prgNode[i].iChildHead);
            }

            // Tail
            if (prgNode[i].iChildTail)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iChildTail) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the last child
                pNode->pChildTail = PNodeFromSignedNode(prgNode[i].iChildTail);
            }
        }

        // Save Root Handle
        Assert(NULL == m_pRootNode);
        m_pRootNode = PNodeFromSignedNode(rInfo.iRoot);
    }

    // Otherwise, bad version...
    else
    {
        hr = TrapError(MIME_E_UNKNOWN_BODYTREE_VERSION);
        goto exit;
    }

    // Tree Loaded
    FLAGSET(m_dwState, TREESTATE_LOADED);

exit:
    // Cleanup
    SafeMemFree(prgNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SaveOffsetTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveOffsetTable(LPSTREAM pStream, DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i,
                    cbNodes=0,
                    iNode;
    LPTREENODEINFO  pNode;
    CACHEINFOV2     rInfo;
    LPCACHENODEV2   prgNode=NULL;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We better have some bodies (we always have a root)
    Assert(m_rTree.cNodes >= 1);

    // If Dirty, SaveMessage needs to be called first...
    if (ISFLAGSET(dwFlags, COMMIT_ONLYIFDIRTY) && IsDirty() == S_OK)
    {
        // Commit it
        CHECKHR(hr = Commit(dwFlags));
    }

    // I removed this check because of the addition of OID_HANDSOFF_ONSAVE option
    // I need to be able to save the offsettable even if i don't have m_pStmLock
    Assert(NULL == m_pStmLock ? S_FALSE == IsDirty() : TRUE);
#if 0 
    if (NULL == m_pStmLock)
    {
        hr = TrapError(MIME_E_NOTHING_TO_SAVE);
        goto exit;
    }
#endif

    // Init rHeader
    ZeroMemory(&rInfo, sizeof(CACHEINFOV2));

    // Loop bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        if (m_rTree.prgpNode[i])
            m_rTree.prgpNode[i]->iCacheNode = rInfo.cNodes++;
    }

    // Version
    rInfo.wVersion = VER_BODYTREEV2;
    rInfo.wSignature = m_wTag;
    rInfo.cbMessage = m_cbMessage;

    // Better have a root
    Assert(m_pRootNode);

    // Compute sizeof Nodes
    cbNodes = sizeof(CACHENODEV2) * rInfo.cNodes;
    Assert(cbNodes % 4 == 0);

    // Allocate prgNode array
    CHECKHR(hr = HrAlloc((LPVOID *)&prgNode, cbNodes));

    // Zero the array
    ZeroMemory(prgNode, cbNodes);

    // Loop bodies
    for (i=0, iNode=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];
        if (NULL == pNode)
            continue;

        // Validate this node
        Assert(pNode->hBody == HBODYMAKE(i));
        Assert(pNode->iCacheNode == iNode);

        // Is this the root
        if (pNode == m_pRootNode)
        {
            Assert(0 == rInfo.iRoot);
            rInfo.iRoot = DwSignNode(rInfo, pNode->iCacheNode);
            Assert(FVerifySignedNode(rInfo, rInfo.iRoot));
        }

        // Copy Offset Information
        prgNode[iNode].dwBoundary = pNode->boundary;
        prgNode[iNode].cbBoundaryStart = pNode->cbBoundaryStart;
        prgNode[iNode].cbHeaderStart = pNode->cbHeaderStart;
        prgNode[iNode].cbBodyStart = pNode->cbBodyStart;
        prgNode[iNode].cbBodyEnd = pNode->cbBodyEnd;

        // Bitmask of NODETYPE_xxx describing this body
        prgNode[iNode].dwType = pNode->dwType;

        // Number of children
        prgNode[iNode].cChildren = pNode->cChildren;

        // Parent
        if (pNode->pParent)
        {
            prgNode[iNode].iParent = DwSignNode(rInfo, pNode->pParent->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iParent));
        }

        // ChildHead
        if (pNode->pChildHead)
        {
            prgNode[iNode].iChildHead = DwSignNode(rInfo, pNode->pChildHead->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iChildHead));
        }

        // ChildTail
        if (pNode->pChildTail)
        {
            prgNode[iNode].iChildTail = DwSignNode(rInfo, pNode->pChildTail->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iChildTail));
        }

        // Next
        if (pNode->pNext)
        {
            prgNode[iNode].iNext = DwSignNode(rInfo, pNode->pNext->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iNext));
        }

        // Prev
        if (pNode->pPrev)
        {
            prgNode[iNode].iPrev = DwSignNode(rInfo, pNode->pPrev->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iPrev));
        }

        // Increment iNode
        iNode++;
    }

    // Write the header...
    Assert(sizeof(CACHEINFOV2) % 4 == 0 && rInfo.iRoot);
    CHECKHR(hr = pStream->Write(&rInfo, sizeof(CACHEINFOV2), NULL));

    // Write the nodes
    CHECKHR(hr = pStream->Write(prgNode, cbNodes, NULL));

exit:
    // Cleanup
    SafeMemFree(prgNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Commit
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Commit(DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pStream=NULL;
    ULARGE_INTEGER  uli;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not Dirty and it has been saved into m_pStmLock
    if (IsDirty() == S_FALSE && m_pStmLock)
        goto exit;

    // Reuse Storage
    if (ISFLAGSET(dwFlags, COMMIT_REUSESTORAGE) && ISFLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE) && m_pStmLock)
    {
        // Get the current stream from m_pStmLock
        m_pStmLock->GetCurrentStream(&pStream);

        // Hands off of current storage
        CHECKHR(hr = HandsOffStorage());

        // Rewind the stream
        CHECKHR(hr = HrRewindStream(pStream));

        // SetSize to Zero
        INT64SET(&uli, 0);
        pStream->SetSize(uli);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, TRUE, FALSE, FALSE));
    }

    // Otherwise, I'll create my own storage
    else
    {
        // Create a new stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, TRUE, FALSE,
                                     !!(dwFlags & COMMIT_SMIMETRANSFERENCODE)));

        // Hands are off..
        FLAGCLEAR(m_dwState, TREESTATE_HANDSONSTORAGE);
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Save(IStream *pStream, BOOL fClearDirty)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;

    // check params
    if (pStream == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not dirty, and we have a stream $$$INFO$$ should be using m_pLockBytes here if we have one
    if (IsDirty() == S_FALSE && m_pStmLock)
    {
        // Copy Lock Bytes to Stream
        CHECKHR(hr = HrCopyLockBytesToStream(m_pStmLock, pStream, NULL));

        // Commit
        CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

        // Raid-33985: MIMEOLE: CMessageTree:Save does not respect fHandsOffOnSave == FALSE if the message is not dirty
        if (FALSE == m_rOptions.fHandsOffOnSave)
        {
            // Replace internal stream
            m_pStmLock->ReplaceInternalStream(pStream);

            // Hands are on..
            FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);
        }

        // Were Done
        goto exit;
    }

    // Write the message
    CHECKHR(hr = _HrWriteMessage(pStream, fClearDirty, m_rOptions.fHandsOffOnSave, FALSE));

    // Return Warnings
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteMessage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteMessage(IStream *pStream, BOOL fClearDirty, BOOL fHandsOffOnSave, BOOL fSMimeCTE)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    MIMEPROPINFO    rPropInfo;
    DWORD           dwSaveFlags;
    INETCSETINFO    rCharset;
    LPINETCSETINFO  pOriginal=NULL;

    // This Function is re-entrant when saving a message that is signed and/or encrypted
    if (FALSE == m_fApplySaveSecurity)
    {
        // Character Set Fixup
        if (m_rOptions.pCharset)
        {
            // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect Internet Encoded and Windows Encoding are CPI_AUTODETECT 
            if (CP_JAUTODETECT == m_rOptions.pCharset->cpiInternet)
            {
                // Save Current Charset
                pOriginal = m_rOptions.pCharset;

                // Find ISO-2022-JP
                SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(c_szISO2022JP, &m_rOptions.pCharset)));
            }

            // Raid-8436: OE: non standard MIME header is composed when send from Send as Unicode dialog, if UTF-7 or UTF-8, and not saving as mime...
            else if (SAVE_RFC822 == m_rOptions.savetype && (CP_UTF7 == m_rOptions.pCharset->cpiInternet || CP_UTF8 == m_rOptions.pCharset->cpiInternet))
            {
                // Save Current Charset
                pOriginal = m_rOptions.pCharset;

                // Get the default body charset
                if (FAILED(g_pInternat->HrOpenCharset(GetACP(), CHARSET_BODY, &m_rOptions.pCharset)))
                    m_rOptions.pCharset = NULL;
            }
        }

        // State
        m_fApplySaveSecurity = TRUE;

        // Do Message Save Security
        hr = _HrApplySaveSecurity();

        // Not in Apply Save security
        m_fApplySaveSecurity = FALSE;

        // Failure
        if (FAILED(hr))
            goto exit;
    }

    // Cleanup the message (i.e. remove empty multiparts, multiparts that have a single child that is a multipart, TNEF)
    if (TRUE == m_rOptions.fCleanupTree)
    {
        // Call Espiranza and have her do the cleaning
        CHECKHR(hr = _HrCleanupMessageTree(m_pRootNode));
    }

    // Generate Message Id...
    if (m_rOptions.fGenMessageId)
    {
        // Set the message Id
        _HrSetMessageId(m_pRootNode);
    }

    // Determine if we are saving a News Message
    rPropInfo.dwMask = 0;
    if (SUCCEEDED(m_pRootNode->pContainer->GetPropInfo(PIDTOSTR(PID_HDR_XNEWSRDR), &rPropInfo)) ||
        SUCCEEDED(m_pRootNode->pContainer->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &rPropInfo)))
        FLAGSET(m_dwState, TREESTATE_SAVENEWS);

    // Set MIME Version
    CHECKHR(hr = m_pRootNode->pContainer->SetProp(PIDTOSTR(PID_HDR_MIMEVER), c_szMimeVersion));

    // X-MimeOLE Version
    CHECKHR(hr = m_pRootNode->pContainer->SetProp(STR_HDR_XMIMEOLE, STR_MIMEOLE_VERSION));

    // Remove Types...
    m_pRootNode->pContainer->DeleteProp(STR_HDR_ENCODING);

    // Root
    m_pRootNode->boundary = BOUNDARY_ROOT;
    m_pRootNode->cbBoundaryStart = 0;

    // Set SaveBody Flags
    dwSaveFlags = SAVEBODY_UPDATENODES;
    if (m_rOptions.fKeepBoundary)
        FLAGSET(dwSaveFlags, SAVEBODY_KEEPBOUNDARY);

    if (fSMimeCTE)
        FLAGSET(dwSaveFlags, SAVEBODY_SMIMECTE);

    // Save Root body
    CHECKHR(hr = _HrSaveBody(fClearDirty, dwSaveFlags, pStream, m_pRootNode, 0));
    if ( S_OK != hr )
        hrWarnings = TrapError(hr);

    // Commit
    CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

    // Hands Off On Save ?
    if (FALSE == fHandsOffOnSave)
    {
        // Reset message size
        CHECKHR(hr = HrSafeGetStreamSize(pStream, &m_cbMessage));

        // Save this new stream
        SafeRelease(m_pStmLock);

        // Create a new Stream Lock Bytes Wrapper
        CHECKALLOC(m_pStmLock = new CStreamLockBytes(pStream));

        // Hands are on the storage
        FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);
    }

    // Debug to temp file...
    DebugWriteMsg(pStream);

    // Clear Dirty
    if (fClearDirty)
        ClearDirty();

exit:
    // Reset Original Charset
    if (pOriginal)
        m_rOptions.pCharset = pOriginal;

    // Remove state flag the tells us to reuse multipart/signed boundaries
    FLAGCLEAR(m_dwState, TREESTATE_REUSESIGNBOUND);

    // Reset
    FLAGCLEAR(m_dwState, TREESTATE_SAVENEWS);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrApplySaveSecurity
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrApplySaveSecurity(void)
{
    // Locals
    HRESULT            hr=S_OK;
    PROPVARIANT        var;
    CSMime            *pSMime=NULL;

    // Invalid Arg
    Assert(m_pRootNode);

    m_pRootNode->pBody->GetOption(OID_NOSECURITY_ONSAVE, &var);
    if (var.boolVal) goto exit;

    // Query the root body for secure status
    m_pRootNode->pBody->GetOption(OID_SECURITY_TYPE, &var);
    if (MST_NONE != var.ulVal)
    {
        // Create the object
        CHECKALLOC(pSMime = new CSMime);

        // Initialize the object
        CHECKHR(hr = pSMime->InitNew());

        // Set state flag the tells us to reuse multipart/signed boundaries
        FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);

        // Encode the message
        CHECKHR(hr = pSMime->EncodeMessage(this, m_rOptions.ulSecIgnoreMask));
    }

exit:
    ReleaseObj(pSMime);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrCleanupMessageTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrCleanupMessageTree(LPTREENODEINFO pParent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;
    ULONG           i;
    BOOL            fKeepOnTruckin=TRUE;

    // check params
    Assert(pParent);

    // This could require multiple passes
    while(fKeepOnTruckin)
    {
        // Assume we will not have to do another pass
        fKeepOnTruckin = FALSE;

        // Loop through bodies
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability
            pNode = m_rTree.prgpNode[i];
            if (NULL == pNode)
                continue;

            // Hiding TNEF Attachments ?
            if (TRUE == m_rOptions.fHideTnef && pNode->pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_MSTNEF) == S_OK)
            {
                // Remove this TNEF attachment
                CHECKHR(hr = DeleteBody(pNode->hBody, 0));

                // Lets Stop right here, and start another pass
                fKeepOnTruckin = TRUE;

                // Done
                break;
            }

            // Empty multipart... and not the root... ?
            else if (_IsMultiPart(pNode))
            {
                // No Children ?
                if (0 == pNode->cChildren)
                {
                    // If this is the root...simply change the content type
                    if (m_pRootNode == pNode)
                    {
                        // Make the body empty
                        pNode->pBody->EmptyData();

                        // text/plain
                        pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);
                    }

                    // Otherwise, delete the body
                    else
                    {
                        // Delete delete the body
                        CHECKHR(hr = DeleteBody(pNode->hBody, 0));

                        // Lets Stop right here, and start another pass
                        fKeepOnTruckin = TRUE;

                        // Done
                        break;
                    }
                }

                // Otherwise, Multipart with a single child...
                else if (pNode->cChildren == 1)
                {
                    // Do a ReplaceBody
                    CHECKHR(hr = DeleteBody(pNode->hBody, DELETE_PROMOTE_CHILDREN));

                    // Lets Stop right here, and start another pass
                    fKeepOnTruckin = TRUE;

                    // Done
                    break;
                }
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SaveBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveBody(HBODY hBody, DWORD dwFlags, IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pNode;

    // Invalid ARg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Save From This Body On Down
    CHECKHR(hr = _HrSaveBody(TRUE, dwFlags, pStream, pNode, 0));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveBody(BOOL fClearDirty, DWORD dwFlags, IStream *pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    TREENODEINFO    rOriginal;
    BOOL            fWeSetSaveBoundary=FALSE;

    // Parameters
    Assert(pStream && pNode);

    if (ISFLAGSET(dwFlags, SAVEBODY_KEEPBOUNDARY))
        {
        if (!ISFLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND))
            {
            fWeSetSaveBoundary = TRUE;
            FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);
            }
        }

    // Save the Current Node
    if (!ISFLAGSET(dwFlags, SAVEBODY_UPDATENODES))
        CopyMemory(&rOriginal, pNode, sizeof(TREENODEINFO));

    // Override Options
    _HrBodyInheritOptions(pNode);

    // Starting Boundary pNode->boundary and pNode->cbBoundaryStart are expected to be set on entry
    pNode->cbHeaderStart = 0;
    pNode->cbBodyStart = 0;
    pNode->cbBodyEnd = 0;

    // If this is a multipart content item, lets read its child
    if (_IsMultiPart(pNode))
    {
        // Save Multipart Children
        CHECKHR(hr = _HrSaveMultiPart(fClearDirty, dwFlags, pStream, pNode, ulLevel));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);
    }

#ifdef SMIME_V3
    //  OID content types are saved by just copying the body into the save
    //  location.
    else if (pNode->pContainer->IsContentType("OID", NULL) == S_OK) 
    {
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_BINARY, pStream));
        if (hr != S_OK) 
        {
            hrWarnings = TrapError(hr);
        }
    }
#endif // SMIME_V3

    // Otherwise, parse single part
    else
    {
        // Save SinglePart Children
        CHECKHR(hr = _HrSaveSinglePart(fClearDirty, dwFlags, pStream, pNode, ulLevel));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);
    }

    // Reset the Node
    if (!ISFLAGSET(dwFlags, SAVEBODY_UPDATENODES))
        CopyMemory(pNode, &rOriginal, sizeof(TREENODEINFO));

exit:
    if (fWeSetSaveBoundary)
        FLAGCLEAR(m_dwState, TREESTATE_REUSESIGNBOUND);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSetMessageId
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSetMessageId(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT     hr= S_OK;
    CHAR        szMessageId[CCHMAX_MID];
    FILETIME    ft;
    SYSTEMTIME  st;

    // Invalid Arg
    Assert(pNode);

    // Get Current Time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    CHECKHR(hr = MimeOleGenerateMID(szMessageId, sizeof(szMessageId), FALSE));

    // Write the message Id
    CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_MESSAGEID, szMessageId));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GenerateBoundary
// --------------------------------------------------------------------------------
void CMessageTree::_GenerateBoundary(LPSTR pszBoundary, DWORD cchSize, ULONG ulLevel)
{
    // Locals
    SYSTEMTIME  stNow;
    FILETIME    ftNow;
    WORD        wCounter;

    // Get Local Time
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    // Format the string
    wnsprintfA(pszBoundary, cchSize, "----=_NextPart_%03d_%04X_%08.8lX.%08.8lX", ulLevel, DwCounterNext(), ftNow.dwHighDateTime, ftNow.dwLowDateTime);
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteBoundary(LPSTREAM pStream, LPSTR pszBoundary, BOUNDARYTYPE boundary, 
    LPDWORD pcboffStart, LPDWORD pcboffEnd)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;

    // Invalid Arg
    Assert(pStream && pszBoundary);

    // Header body CRLF
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // Starting Boundary Start
    if (pcboffStart)
        CHECKHR(hr = HrGetStreamPos(pStream, pcboffStart));

    // --
    CHECKHR(hr = pStream->Write(c_szDoubleDash, lstrlen(c_szDoubleDash), NULL));

    // Write the boundary
    CHECKHR(hr = pStream->Write(pszBoundary, lstrlen(pszBoundary), NULL));

    // If end
    if (BOUNDARY_MIMEEND == boundary)
    {
        // Write ending double dash
        CHECKHR(hr = pStream->Write(c_szDoubleDash, lstrlen(c_szDoubleDash), NULL));
    }

    // Otherwise, set pNode->cbBoundaryStart
    else
        Assert(BOUNDARY_MIMENEXT == boundary);

    // Emit Line Break;
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // BUG 38411: to be complient with RFC 1847 we have to include
    // the last CRLF in the hash of a signed message.  The S/MIME
    // code relies on cbBodyEnd, so place this after the CRLF emit.

    // Ending offset
    if (pcboffEnd)
        CHECKHR(hr = HrGetStreamPos(pStream, pcboffEnd));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrComputeBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrComputeBoundary(LPTREENODEINFO pNode, ULONG ulLevel, LPSTR pszBoundary, LONG cchMax)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fGenerate=TRUE;
    LPSTR           pszCurrent=NULL;

    // If reusing tree boundaries...
    if (ISFLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND))
    {
        // (this is required for multipart/signed -- t-erikne)
        if (SUCCEEDED(pNode->pContainer->GetProp(SYM_PAR_BOUNDARY, &pszCurrent)))
        {
            // Better fit into cchMax
            if (lstrlen(pszCurrent) <= cchMax - 1)
            {
                // Copy it to the out param
                StrCpyN(pszBoundary, pszCurrent, cchMax);

                // Don't generate
                fGenerate = FALSE;
            }
        }
    }

    // Generate a boundary ?
    if (TRUE == fGenerate)
    {
        // Generate boundary
        _GenerateBoundary(pszBoundary, cchMax, ulLevel);

        // Set the boundary property...
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_PAR_BOUNDARY, pszBoundary));
    }


exit:
    // Cleanup
    SafeMemFree(pszCurrent);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveMultiPart
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveMultiPart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    CHAR            szRes[100];
    CHAR            szBoundary[CCHMAX_BOUNDARY];
    LPTREENODEINFO  pChild;
    LPSTR           pszBoundary=NULL;

    // Invalid Arg
    Assert(pStream && pNode);

    // MIME
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Remove Fake Multipart flag, its a real multipart now...
        FLAGCLEAR(pNode->dwType, NODETYPE_FAKEMULTIPART);
        FLAGCLEAR(pNode->dwType, NODETYPE_RFC1154_ROOT);
        FLAGCLEAR(pNode->dwType, NODETYPE_RFC1154_BINHEX);

        // HrComputeBoundary
        CHECKHR(hr = _HrComputeBoundary(pNode, ulLevel, szBoundary, ARRAYSIZE(szBoundary)));

        // Delete any charset information (doesn't make sense on a multipart)
        pNode->pContainer->DeleteProp(SYM_PAR_CHARSET);

        // Write the header
        CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));

        // Remove SMIME_CTE for Multipart/signed 
        if ((pNode->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) == S_OK) &&
            (pNode->cChildren == 2))
        {
            FLAGCLEAR(dwFlags, SAVEBODY_SMIMECTE);
            FLAGSET(dwFlags, SAVEBODY_REUSECTE);
        }

        // Multipart-Preamble
        if (0 == ulLevel)
        {
            LoadString(g_hLocRes, IDS_MULTIPARTPROLOG, szRes, ARRAYSIZE(szRes));
            CHECKHR(hr = pStream->Write(szRes, lstrlen(szRes), NULL));
        }

        // Increment Level
        ulLevel++;

        // Loop Chilren
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Set Boundary
            pChild->boundary = BOUNDARY_MIMENEXT;

            // Write Boundary
            CHECKHR(hr = _HrWriteBoundary(pStream, szBoundary, BOUNDARY_MIMENEXT, &pChild->cbBoundaryStart, NULL));

            // Bind the body table for this dude
            CHECKHR(hr = _HrSaveBody(fClearDirty, dwFlags, pStream, pChild, ulLevel));
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Write Ending Boundary
        CHECKHR(hr = _HrWriteBoundary(pStream, szBoundary, BOUNDARY_MIMEEND, NULL, &pNode->cbBodyEnd));
    }

    // Otherwise, SAVE_RFC822
    else
    {
        // Only write UUENCODED root header...
        if (0 == ulLevel)
        {
            // Write the header
            CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));
        }

        // Increment Level
        ulLevel++;

        // Now its a fakemultipart...
        FLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART);
        
        // Loop Chilren
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrSaveBody(fClearDirty, dwFlags, pStream, pChild, ulLevel));
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Body Start...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteHeader
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteHeader(BOOL fClearDirty, IStream *pStream, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pStream && pNode);

    // Better be the root
    Assert(pNode->boundary == BOUNDARY_ROOT || pNode->boundary == BOUNDARY_MIMENEXT ||
           pNode->boundary == BOUNDARY_NONE);

    // Get current stream position
    CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbHeaderStart));

    // Write the header...
    CHECKHR(hr = pNode->pContainer->Save(pStream, fClearDirty));

    // Header body CRLF
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // Get Header End
    CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GetContentTransferEncoding
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_GetContentTransferEncoding(LPTREENODEINFO pNode, BOOL fText, 
    BOOL fPlain, BOOL fMessage, BOOL fAttachment, DWORD dwFlags,
    ENCODINGTYPE *pietEncoding)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    TRANSMITINFO    rXmitInfo;
    PROPVARIANT     rOption;

    *pietEncoding=IET_UNKNOWN;

    if (ISFLAGSET(dwFlags, SAVEBODY_REUSECTE))
    {
        pNode->pBody->GetPreviousEncoding(pietEncoding);
        if (*pietEncoding != IET_UNKNOWN)
            goto exit;
    }


    // If mesage/*, always use 7bit
    if (fMessage)
    {
        // Don't Wrap It
        rOption.vt = VT_BOOL;
        rOption.boolVal = FALSE;
        pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rOption);

        // Set Encoding
        *pietEncoding = (SAVE_RFC1521 == m_rOptions.savetype) ? IET_7BIT : IET_UUENCODE;

        // Done
        goto smimeExit;
    }

    // Use Option for text transmit format
    if (fText && !fAttachment)
    {
        // Default to plain text encoding first
        if (IET_UNKNOWN != m_rOptions.ietTextXmit)
            *pietEncoding = m_rOptions.ietTextXmit;

        // Plain
        if (IET_UNKNOWN != m_rOptions.ietPlainXmit && pNode->pContainer->IsContentType(NULL, STR_SUB_PLAIN) == S_OK)
            *pietEncoding = m_rOptions.ietPlainXmit;

        // Html
        else if (IET_UNKNOWN != m_rOptions.ietHtmlXmit && pNode->pContainer->IsContentType(NULL, STR_SUB_HTML) == S_OK)
            *pietEncoding = m_rOptions.ietHtmlXmit;
    }

    // Not known yet, using body option...
    if (IET_UNKNOWN == *pietEncoding)
    {
        // Try to get the body option
        if (SUCCEEDED(pNode->pBody->GetOption(OID_TRANSMIT_BODY_ENCODING, &rOption)) && IET_UNKNOWN != rOption.ulVal)
            *pietEncoding = (ENCODINGTYPE)rOption.ulVal;
    }

    // Save as MIME
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Get the current encoding of the body..
        if (IET_UNKNOWN == *pietEncoding)
            pNode->pBody->GetCurrentEncoding(pietEncoding);

        // If CTE is IET_QP or IET_BASE64 or IET_UUENCODE, were done
        if (IET_QP == *pietEncoding || IET_BASE64 == *pietEncoding || IET_UUENCODE == *pietEncoding)
            goto exit;

        // Ask the pody to suggest an ietEncoding
        hr = pNode->pBody->GetTransmitInfo(&rXmitInfo);
        if (SUCCEEDED(hr) )
        {
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);

            // Must not need wrapping
            if (IET_7BIT == rXmitInfo.ietXmitMime)
            {
                rOption.vt = VT_BOOL;
                rOption.boolVal = FALSE;
                pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rOption);
            }

            // If IET_7BIT and there are 8bit chars, bump upto 8bit
            if (IET_7BIT == *pietEncoding || IET_8BIT == *pietEncoding)
            {
                // 8bit
                *pietEncoding = (rXmitInfo.cExtended > 0) ? IET_8BIT : IET_7BIT;
            }

            // Just use the suggested mime cte from GetTransmitInfo
            else
                *pietEncoding = rXmitInfo.ietXmitMime;
        }

        // Transmit ietEncoding still unknown
        else
            *pietEncoding = (IET_UNKNOWN == *pietEncoding) ? (fText ? IET_QP : IET_BASE64) : *pietEncoding;
    }

    // Save a non-MIME
    else
    {
        // If I already know this body is TREENODE_INCOMPLETE, it will be 7bit...
        if (ISFLAGSET(pNode->dwType, NODETYPE_INCOMPLETE))
        {
            // No Encoding
            *pietEncoding = IET_7BIT;

            // Tell the body that its 7bit
            pNode->pBody->SetCurrentEncoding(IET_7BIT);
        }

        // Raid 41599 - lost/munged attachments on forward/uuencode - Text attachments were not 
        // getting encoded when: *pietEncoding = (fText && fPlain) ? IET_7BIT : IET_UUENCODE;
        else
            *pietEncoding = (fText && fPlain && !fAttachment) ? IET_7BIT : IET_UUENCODE;
    }

    //  If we are doing S/MIME at this point, we need to make sure that the
    //  content encoding rules for S/MIME are followed.  Specifically we
    //  want to make sure that binary and 8bit are not allowed.
smimeExit:
    if (ISFLAGSET(dwFlags, SAVEBODY_SMIMECTE))
    {
        if (*pietEncoding == IET_8BIT)
            *pietEncoding = IET_QP;
        if (*pietEncoding == IET_BINARY)
            *pietEncoding = IET_BASE64;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteUUFileName
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteUUFileName(IStream *pStream, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rFileName;

    // Init rFileName
    ZeroMemory(&rFileName, sizeof(PROPVARIANT));
    rFileName.vt = VT_LPSTR;

    // RAID-22479: FE-J:Athena:SJIS is used on file name on the message source with Uuencode/JIS.
    if (FAILED(pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_GENFNAME), PDF_ENCODED, &rFileName)))
    {
        // Write the filename
        CHECKHR(hr = pStream->Write(c_szUUENCODE_DAT, lstrlen(c_szUUENCODE_DAT), NULL));

        // Done
        goto exit;
    }

    // Write the filename
    CHECKHR(hr = pStream->Write(rFileName.pszVal, lstrlen(rFileName.pszVal), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveSinglePart
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveSinglePart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    LPSTR           pszFileName=NULL;
    BOOL            fText=FALSE;
    BOOL            fMessage=FALSE;
    BOOL            fAttachment=FALSE;
    ENCODINGTYPE    ietEncoding;
    BOOL            fPlain=FALSE;
    PROPVARIANT     val;
    LPINETCSETINFO  pTaggedCset=NULL;

    // Invalid Arg
    Assert(pStream && pNode);

    // Text/Plain
    if (pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) == S_OK)
        fText = fPlain = TRUE;

    // Text Body
    else if (pNode->pContainer->IsContentType(STR_CNT_TEXT, NULL) == S_OK)
        fText = TRUE;

    // Message/*
    else if (pNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
    {
        // We have a message
        fMessage = TRUE;
        fAttachment = TRUE;
    }

    // fAttachment has not been set yet
    if (!fAttachment)
    {
        fAttachment = (pNode->pContainer->QueryProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT, FALSE, FALSE) == S_OK ||
                       pNode->pContainer->IsPropSet(PIDTOSTR(PID_PAR_FILENAME)) == S_OK ||
                       pNode->pContainer->IsPropSet(PIDTOSTR(PID_PAR_NAME)) == S_OK);
    }

    // Get Content Transfer Encoding
    hr = _GetContentTransferEncoding(pNode, fText, fPlain, fMessage, fAttachment,
                                     dwFlags, &ietEncoding);
    if ( S_OK != hr )
        hrWarnings = TrapError(hr);

    // Sanity Check
    Assert(ietEncoding != IET_UNKNOWN && (SAVE_RFC1521 == m_rOptions.savetype || SAVE_RFC822 == m_rOptions.savetype));

    // Set Content-Transfer-Encoding...
    CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, g_rgEncodingMap[ietEncoding].pszName));
    pNode->pBody->SetPreviousEncoding(ietEncoding);

    // Compute Character Set for the message...
    if (m_rOptions.pCharset && TRUE == fText && (FALSE == fAttachment || S_OK == pNode->pBody->IsType(IBT_CSETTAGGED)))
    {


#if 0 // Raid-69667: OE5: Kor: Only the charset, euc-kr, is used for news message
        // ISO-2022-KR -> EUC-KR for News text/plain
        if (ISFLAGSET(m_dwState, TREESTATE_SAVENEWS) && 949 == m_rOptions.pCharset->cpiWindows && pNode->pContainer->IsContentType(NULL, STR_SUB_PLAIN) == S_OK)
        {
            // Locals
            LPINETCSETINFO pEUCKR;

            // Find EUC-KR
            if (SUCCEEDED(g_pInternat->HrOpenCharset("EUC-KR", &pEUCKR)))
                pNode->pBody->SetCharset(pEUCKR->hCharset, CSET_APPLY_UNTAGGED);
        }

        // Otherwise, use current charset
        else
#endif // Raid-69667: OE5: Kor: Only the charset, euc-kr, is used for news message

        // Store the Character set
        pNode->pBody->SetCharset(m_rOptions.pCharset->hCharset, m_rOptions.csetapply);

        // Get original charset
        if (fAttachment && S_OK == pNode->pBody->IsType(IBT_CSETTAGGED))
        {
            // Get the tagged charset
            pTaggedCset = pNode->pBody->PGetTaggedCset();

            // Set the charset property
            pNode->pContainer->SetProp(PIDTOSTR(PID_PAR_CHARSET), pTaggedCset->szName);

            // Remove the CSETTAGGED state, and then reset it after we write the body
            // This will keep the body from being character set converted
            pNode->pBody->ClearState(BODYSTATE_CSETTAGGED);
        }
    }

    // Otherwise, remove the charset parameter, we don't encode attachments in a character set
    else
    {
        // Remove the CharacterSet parameter from the body
        pNode->pContainer->DeleteProp(SYM_PAR_CHARSET);
    }

    // Write the header...
    if (SAVE_RFC1521 == m_rOptions.savetype || 0 == ulLevel)
    {
        // Write the header
        CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));
    }

    // Determine the send ietEncoding
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Write body data into the stream
        CHECKHR(hr = pNode->pBody->GetDataHere(ietEncoding, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

    // Otherwise, SAVE_RFC822
    else if (SAVE_RFC822 == m_rOptions.savetype && IET_UUENCODE == ietEncoding)
    {
        // Starting boundary/header
        if (ulLevel > 0)
            pNode->boundary = BOUNDARY_UUBEGIN;

        // Start new line
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Get Boundary Start
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBoundaryStart));

        // Header Start and boundary start are the same
        if (ulLevel > 0)
            pNode->cbHeaderStart = pNode->cbBoundaryStart;

        // Write begin
        CHECKHR(hr = pStream->Write(c_szUUENCODE_BEGIN, lstrlen(c_szUUENCODE_BEGIN), NULL));

        // Write the file permission
        CHECKHR(hr = pStream->Write(c_szUUENCODE_666, lstrlen(c_szUUENCODE_666), NULL));

        // Write UU File Name
        CHECKHR(hr = _HrWriteUUFileName(pStream, pNode));

        // Start new line
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Get Header End
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

        // Write the data
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_UUENCODE, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));

        // Write end
        CHECKHR(hr = pStream->Write(c_szUUENCODE_END, lstrlen(c_szUUENCODE_END), NULL));
    }

    // Otherwise, SAVE_RFC822 and IET_7BIT
    else if (SAVE_RFC822 == m_rOptions.savetype && IET_7BIT == ietEncoding)
    {
        // Get Boundary Start....
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

        // Starting boundary/header
        if (ulLevel > 0)
        {
            // No Boundary
            pNode->boundary = BOUNDARY_NONE;

            // Boundoff
            pNode->cbBoundaryStart = pNode->cbBodyStart;

            // Same as header start
            pNode->cbHeaderStart = pNode->cbBoundaryStart;
        }

        // Write the data
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_7BIT, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write final crlf
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

    // Otherwise...
    else
        AssertSz(FALSE, "A body is about to be lost. Contact sbailey at x32553 NOW!!!");

exit:
    // Try to fixup the body
    if (pTaggedCset)
    {
        pNode->pBody->SetCharset(pTaggedCset->hCharset, CSET_APPLY_UNTAGGED);
        pNode->pBody->SetState(BODYSTATE_CSETTAGGED);
    }

    // Free BodyInfo
    SafeMemFree(pszFileName);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBodyInheritOptions
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBodyInheritOptions(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT     hr=S_OK;
    PROPVARIANT rValue;

    // Invalid ARg
    Assert(pNode);

    // Allow 8bit in header
    rValue.boolVal = m_rOptions.fAllow8bitHeader;
    CHECKHR(hr = pNode->pBody->SetOption(OID_ALLOW_8BIT_HEADER, &rValue));

    // Wrap Body Text
    rValue.boolVal = m_rOptions.fWrapBodyText;
    CHECKHR(hr = pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rValue));

    // Max Header Line
    rValue.ulVal = m_rOptions.cchMaxHeaderLine;
    CHECKHR(hr = pNode->pBody->SetOption(OID_CBMAX_HEADER_LINE, &rValue));

    // Persist Type
    rValue.ulVal = (ULONG)m_rOptions.savetype;
    CHECKHR(hr = pNode->pBody->SetOption(OID_SAVE_FORMAT, &rValue));

    // Max Body Line
    rValue.ulVal = m_rOptions.cchMaxBodyLine;
    CHECKHR(hr = pNode->pBody->SetOption(OID_CBMAX_BODY_LINE, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    ULONG               i;
    HCHARSET            hCharset;
    PROPVARIANT         rVersion;
    STGMEDIUM           rMedium;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Assume the Bind has Finished
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // Release m_pStmLock
    SafeRelease(m_pStmLock);

    // Do I have a tree already...
    if (!ISFLAGSET(m_dwState, TREESTATE_LOADED) || FAILED(_HrBindOffsetTable(pStream, &m_pStmLock)))
    {
        // InitNew
        CHECKHR(hr = _HrLoadInitNew());

        // Use file
        if (m_rOptions.fBindUseFile)
            FLAGSET(m_dwState, TREESTATE_BINDUSEFILE);

        // If this fails, I assume the clients stream is already rewound and they don't support this
        HrRewindStream(pStream);

        // Fake OnStartBinding
        OnStartBinding(0, NULL);

        // Setup the Storage Medium
        ZeroMemory(&rMedium, sizeof(STGMEDIUM));
        rMedium.tymed = TYMED_ISTREAM;
        rMedium.pstm = pStream;

        // Fake OnDataAvailable
        OnDataAvailable(BSCF_LASTDATANOTIFICATION, 0, NULL, &rMedium);

        // Fake OnStartBinding
        OnStopBinding(S_OK, NULL);

        // If bind failed, return warnings
        if (FAILED(m_hrBind))
            hrWarnings = MIME_S_INVALID_MESSAGE;
    }

    // Otherwise, we are finished binding
    else
    {
        // HandleCanInlineTextOption
        _HandleCanInlineTextOption();

        // Bind Finished
        FLAGSET(m_dwState, TREESTATE_BINDDONE);

        // DispatchBindRequest
        _HrProcessPendingUrlRequests();
    }

    // Assume the stream
    Assert(m_pStmLock);

    // Allow for zero-byte stream to be Loaded
    if (m_cbMessage)
    {
        // Is MIME ?
        rVersion.vt = VT_UI4;
        if (SUCCEEDED(m_pRootNode->pContainer->GetProp(PIDTOSTR(PID_HDR_MIMEVER), 0, &rVersion)))
        {
            // Its a Mime Message
            m_rOptions.savetype = SAVE_RFC1521;

            // Invalid Version
            if (rVersion.ulVal != TREE_MIMEVERSION)
                hrWarnings = MIME_S_MIME_VERSION;
        }

        // Otherwise, savetype should default to rfc822
        else
            m_rOptions.savetype = SAVE_RFC822;

        // Detect Partials and Set FileName/Encoding Correctly
        _FuzzyPartialRecognition(m_rOptions.savetype == SAVE_RFC822 ? FALSE : TRUE);

        // Bind All Bodies to the Tree
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability - Should not have any deleted bodies yet
            if (m_rTree.prgpNode[i] && !ISFLAGSET(m_rTree.prgpNode[i]->dwState, NODESTATE_BOUNDTOTREE))
            {
                // BindState is done
                m_rTree.prgpNode[i]->bindstate = BINDSTATE_COMPLETE;

                // Bind to the tree
                CHECKHR(hr = m_rTree.prgpNode[i]->pBody->HrBindToTree(m_pStmLock, m_rTree.prgpNode[i]));
            }
        }

        // Determine the dominent charcter set of the message
        if (SUCCEEDED(_HrGetCharsetTree(m_pRootNode, &hCharset)) && hCharset)
        {
            // Apply Charset to Untagged bodies
            SetCharset(hCharset, CSET_APPLY_UNTAGGED);
        }
    }

#ifdef DEBUG
    // Write X-Mailer or X-NewsReader
    DebugWriteXClient();
#endif

    // My hands are on the storage
    FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);

    // Dirty
    ClearDirty();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HandleCanInlineTextOption
// --------------------------------------------------------------------------------
void CMessageTree::_HandleCanInlineTextOption(void)
{
    // Locals
    FINDBODY        rFind;
    HBODY           hMixed;
    LPTREENODEINFO  pNode;
    LPTREENODEINFO  pChild;
    LPTREENODEINFO  pText=NULL;

    // Only do this if the client doesn't support inlining multiple text bodies, such as Outlook Express
    if (TRUE == m_rOptions.fCanInlineText)
        return;

    // Raid 53456: mail: We should be displaying the plain text portion and making enriched text an attachment for attached msg
    // Raid 53470: mail:  We are not forwarding the attachment in the attached message
    // I am going to find the first multipart/mixed section, then find the first text/plain body, and then 
    // mark all of the text/*, non-attachment bodies after that as attachments
    ZeroMemory(&rFind, sizeof(FINDBODY));
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_MIXED;

    // Find First
    if (FAILED(FindFirst(&rFind, &hMixed)))
        goto exit;

    // Get node for hMixed
    pNode = _PNodeFromHBody(hMixed);

    // Loop
    for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
    {
        // Not an attachment
        if (S_FALSE == pChild->pBody->IsType(IBT_ATTACHMENT))
        {
            // Is text/plain
            if (S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) ||
                S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
            {
                pText = pChild;
                break;
            }
        }
    }

    // If we found a text body
    if (NULL == pText)
        goto exit;

    // Loop through the children again
    for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
    {
        // Is text/*
        if (pChild != pText && S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, NULL) && S_FALSE == pChild->pBody->IsType(IBT_ATTACHMENT))
        {
            // Mark as attachment
            pChild->pContainer->SetProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT);

            // Set a special flag to denote it was converted to an attachment
            FLAGSET(pChild->dwState, NODESTATE_AUTOATTACH);
        }
    }

exit:
    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindOffsetTable
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindOffsetTable(IStream *pStream, CStreamLockBytes **ppStmLock)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cb;
    CInternetStream cInternet;

    // Init
    *ppStmLock = NULL;

    // Get Sizeof Stream
    CHECKHR(hr = HrSafeGetStreamSize(pStream, &cb));

    // Otherwise bind the body table
    if (cb != m_cbMessage)
    {
        hr = TrapError(MIME_E_MSG_SIZE_DIFF);
        goto exit;
    }

    // Init the Internet Stream
    CHECKHR(hr = cInternet.HrInitNew(pStream));

    // Fast Parse Body
    CHECKHR(hr = _HrFastParseBody(&cInternet, m_pRootNode));

    // Success, get the lockbytes from the internet stream
    cInternet.GetLockBytes(ppStmLock);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBodyOffsets
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBodyOffsets(HBODY hBody, LPBODYOFFSETS pOffsets)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // Invalid Arg
    if (NULL == hBody || NULL == pOffsets)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // No Data ?
    CHECKHR(hr = pNode->pBody->GetOffsets(pOffsets));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::ClearDirty
// --------------------------------------------------------------------------------
void CMessageTree::ClearDirty(void)
{
    // If Dirty...
    FLAGCLEAR(m_dwState, TREESTATE_DIRTY);

    // Loop through bodies and ask IMimeHeader's and IMimeBody's
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // If NULL...
        if (NULL == m_rTree.prgpNode[i])
            continue;
        
        // Dirty Header...
        m_rTree.prgpNode[i]->pBody->ClearDirty();
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::GetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCharset(LPHCHARSET phCharset)
{
    // Locals
    HRESULT     hr=S_OK;
    HCHARSET    hCharset;

    // Check Params
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phCharset = NULL;

    // Recurse the current tree
    if (NULL == m_rOptions.pCharset && m_pRootNode)
    {
        // Get charset
        if (SUCCEEDED(_HrGetCharsetTree(m_pRootNode, &hCharset)))
        {
            // Get Pointer to Charset
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_rOptions.pCharset)));
        }
    }

    // No Charset
    if (NULL == m_rOptions.pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Set Return
    *phCharset = m_rOptions.pCharset->hCharset;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrGetCharsetTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrGetCharsetTree(LPTREENODEINFO pNode, LPHCHARSET phCharset)
{
    // Locals
    LPTREENODEINFO pChild;

    // Invalid Arg
    Assert(pNode && phCharset && m_rOptions.pCharset);

    // Init
    *phCharset = NULL;

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            if (SUCCEEDED(_HrGetCharsetTree(pChild, phCharset)) && *phCharset)
                break;
        }
    }

    // If the Header was tagged with a charset, use that charset
    else if (pNode->pContainer->IsState(COSTATE_CSETTAGGED) == S_OK)
    {     
        // Get Internal Character Set
        if (SUCCEEDED(pNode->pContainer->GetCharset(phCharset)) && *phCharset)
            goto exit;
    }

exit:
    // Done
    return (*phCharset) ? S_OK : E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Lookiup Charset Info
    if (FALSE == g_pInternat->FIsValidHandle(hCharset))
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Save the charset
    SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_rOptions.pCharset)));

    // Save apply type
    m_rOptions.csetapply = applytype;

    // If we have a root body
    if (m_pRootNode)
    {
        // Recurse all bodies and set the charset
        CHECKHR(hr = _HrSetCharsetTree(m_pRootNode, m_rOptions.pCharset->hCharset, m_rOptions.csetapply));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSetCharsetTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSetCharsetTree(LPTREENODEINFO pNode, HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode);

    // Raid-22662: OExpress: if content-type on fileattach does not have charset should apply same as message body
    pNode->pBody->SetCharset(hCharset, applytype);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrSetCharsetTree(pChild, hCharset, applytype));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrValidateOffsets
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrValidateOffsets(LPTREENODEINFO pNode)
{
    // Invalid Arg
    Assert(pNode);

    // Validate the offsets
    if (pNode->cbBodyStart > m_cbMessage || pNode->cbBodyEnd > m_cbMessage ||
        pNode->cbHeaderStart > m_cbMessage || pNode->cbBoundaryStart > m_cbMessage)
    {
        Assert(FALSE);
        return TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
    }

    // Validate the offsets
    if (pNode->cbBodyStart > pNode->cbBodyEnd || pNode->cbBoundaryStart > pNode->cbHeaderStart ||
        pNode->cbHeaderStart > pNode->cbBodyStart || pNode->cbBoundaryStart > pNode->cbBodyEnd)
    {
        Assert(FALSE);
        return TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrValidateStartBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrValidateStartBoundary(CInternetStream *pInternet, LPTREENODEINFO pNode, 
    LPSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;

    // Is there a boundary to read...
    if (BOUNDARY_MIMENEXT == pNode->boundary)
    {
        // Seek to the boundary start..
        pInternet->Seek(pNode->cbBoundaryStart);

        // Readline and verify the header
        CHECKHR(hr = pInternet->HrReadLine(&rLine));

        // Read and verify the boundary...
        if (!ISVALIDSTRINGA(&pNode->rBoundary) || BOUNDARY_MIMENEXT != _GetMimeBoundaryType(&rLine, &pNode->rBoundary))
        {
            AssertSz(FALSE, "MIME_E_BODYTREE_OUT_OF_SYNC");
            hr = TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
            goto exit;
        }
    }

    // Otherwise, verify UU boundary
    else if (BOUNDARY_UUBEGIN == pNode->boundary)
    {
        // Seek to the boundary start..
        pInternet->Seek(pNode->cbBoundaryStart);

        // Readline and verify the header
        CHECKHR(hr = pInternet->HrReadLine(&rLine));

        // Read and verify the boundary...
        if (FALSE == _FIsUuencodeBegin(&rLine, ppszFileName))
        {
            AssertSz(FALSE, "MIME_E_BODYTREE_OUT_OF_SYNC");
            hr = TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
            goto exit;
        }

        // FileName..
        AssertSz(!ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART), "pszFileName is not going to get set.");
    }

    // Otherwise, header start should be same as boundary start
    else 
        Assert(BOUNDARY_ROOT == pNode->boundary ? TRUE : pNode->cbBoundaryStart == pNode->cbHeaderStart);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrFastParseBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrFastParseBody(CInternetStream *pInternet, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rVariant;
    LPSTR           pszFileName=NULL;
    LPTREENODEINFO  pChild, 
                    pTemp;

    // check params
    Assert(pInternet && pNode);

    // Validate Offset
    CHECKHR(hr = _HrValidateOffsets(pNode));

    // Validate Start Boundary
    CHECKHR(hr = _HrValidateStartBoundary(pInternet, pNode, &pszFileName));

    // Is there a header to read...
    if (BOUNDARY_MIMENEXT == pNode->boundary || BOUNDARY_ROOT == pNode->boundary)
    {
        // Load the header
        Assert(pNode->boundary == BOUNDARY_ROOT ? m_pRootNode == pNode : TRUE);

        // Seek to the boundary start..
        pInternet->Seek(pNode->cbHeaderStart);

        // Load the Header
        CHECKHR(hr = pNode->pContainer->Load(pInternet));

        // Raid-38646: Mimeole:  Multipart/Digest not being parsed correctly initially, but save fine
        // Message In a Message
        if (pNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
        {
            // We are parsing a message attachment
            FLAGSET(pNode->dwState, NODESTATE_MESSAGE);
        }

        // Otherwise, if parent and parent is a multipart/digest
        else if (pNode->pParent && pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK &&
                 pNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTTYPE)) == S_FALSE)
        {
            // Change the Content Type
            pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822);

            // This is a message
            FLAGSET(pNode->dwState, NODESTATE_MESSAGE);
        }
    }

    // Encoding
    else if (!ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART))
    {
        // ComputeDefaultContent
        CHECKHR(hr = _HrComputeDefaultContent(pNode, pszFileName));
    }

    // Fake Multipart...
    if (ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART))
    {
        // Application/octet-stream
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

        // Loop children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check pChild
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrFastParseBody(pInternet, pChild));
        }
    }

    // If Multipart...cruise through the children
    else if (_IsMultiPart(pNode))
    {
        // Get the boundary from the header
        rVariant.type = MVT_STRINGA;
        if (FAILED(pNode->pContainer->GetProp(SYM_PAR_BOUNDARY, 0, &rVariant)))
        {
            hr = TrapError(MIME_E_NO_MULTIPART_BOUNDARY);
            goto exit;
        }

        // But the Boundary into pNode->rBoundary
        pNode->rBoundary.pszVal = rVariant.rStringA.pszVal;
        pNode->rBoundary.cchVal = rVariant.rStringA.cchVal;

        // Free this boundary later
        FLAGCLEAR(pNode->dwState, NODESTATE_BOUNDNOFREE);

        // Loop children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check pChild
            Assert(pChild->pParent == pNode);

            // Put the Boundary into pChild
            pChild->rBoundary.pszVal = rVariant.rStringA.pszVal;
            pChild->rBoundary.cchVal = rVariant.rStringA.cchVal;

            // Done free the boundary
            FLAGSET(pChild->dwState, NODESTATE_BOUNDNOFREE);

            // Bind the body table for this dude
            CHECKHR(hr = _HrFastParseBody(pInternet, pChild));
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FuzzyPartialRecognition
// --------------------------------------------------------------------------------
void CMessageTree::_FuzzyPartialRecognition(BOOL fIsMime)
{
    // Locals
    CHAR            szFile[MAX_PATH];
    ULONG           ulTotal;
    ULONG           ulPart;
    BOOL            fCntTypeSet=FALSE;
    LPSTR           pszContentType=NULL;
    CHAR            szExt[_MAX_EXT];

    // Better have a Root
    Assert(m_pRootNode);

    // Only if this is the 
    if (fIsMime || m_pRootNode->cChildren || m_pRootNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) == S_FALSE)
        goto exit;

    // Extract FileName and part/total from the subject
    if (FAILED(MimeOleGetSubjectFileName(m_pRootNode->pBody, &ulPart, &ulTotal, szFile, MAX_PATH)))
        goto exit;

    // Mark as Partial
    FLAGSET(m_pRootNode->dwType, NODETYPE_INCOMPLETE);

    // A Little Debugging
    DebugTrace("FuzzyPartialRecognition - FileName = '%s', Part = %d, Total = %d\n", szFile, ulPart, ulTotal);

    // Store the FileName
    if (FAILED(m_pRootNode->pContainer->SetProp(SYM_ATT_FILENAME, szFile)))
        goto exit;

    // Get File Extesion
    if (SUCCEEDED(MimeOleGetFileExtension(szFile, szExt, sizeof(szExt))))
    {
        // GetExtContentType
        if (SUCCEEDED(MimeOleGetExtContentType(szExt, &pszContentType)))
        {
            // Set Content Type
            m_pRootNode->pContainer->SetProp(SYM_HDR_CNTTYPE, pszContentType);

            // We Set the content type
            fCntTypeSet = TRUE;
        }
    }

    // Default to Application/octet-stream
    if (FALSE == fCntTypeSet)
        m_pRootNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM);

    // Set Encoding
    m_pRootNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT);

    // I Should Actualy do some detection...
    if (FALSE == fIsMime)
        m_pRootNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_UUENCODE);

exit:
    // Cleanup
    SafeMemFree(pszContentType);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrComputeDefaultContent
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrComputeDefaultContent(LPTREENODEINFO pNode, LPCSTR pszFileName)
{
    // Locals
    HRESULT          hr=S_OK;
    CHAR             szExt[256];
    LPSTR            pszContentType=NULL;
    LPSTR            pszDecoded=NULL;

    // Invalid Arg
    Assert(pNode);

    // Otherwise, lets get the content type
    if (pszFileName)
    {
        // Set File Name
        PROPVARIANT rVariant;
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)pszFileName;

        // Set the file name
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_FILENAME), PDF_ENCODED, &rVariant));

        // Get the filename back out so that its decoded...
        CHECKHR(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), &pszDecoded));

        // Test for winmail.dat
        if (lstrcmpi(pszDecoded, c_szWinmailDotDat) == 0)
        {
            // Make sure the stream is really TNEF
            FLAGSET(pNode->dwState, NODESTATE_VERIFYTNEF);
        }

        // Get File Extesion
        if (SUCCEEDED(MimeOleGetFileExtension(pszDecoded, szExt, sizeof(szExt))))
        {
            // GetExtContentType
            if (SUCCEEDED(MimeOleGetExtContentType(szExt, &pszContentType)))
            {
                // Set Content Type
                CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, pszContentType));
            }
            else
            {
                // Set Content Type
                CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM));
            }
        }

        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
    }

    // Otherwise
    else
    {
        // Default to text/plain
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));
    }

    // Boundary Was UUencode
    if (BOUNDARY_UUBEGIN == pNode->boundary)
    {
        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_UUENCODE));
    }

    else if (ISFLAGSET(pNode->dwType,NODETYPE_RFC1154_BINHEX))
    {
        // This is BINHEX from RFC1154
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), STR_CNT_APPLICATION));
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), STR_SUB_BINHEX));
    }

    // Otherwise
    else
    {
        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));
    }

exit:
    // Cleanup
    SafeMemFree(pszContentType);
    SafeMemFree(pszDecoded);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::HandsOffStorage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::HandsOffStorage(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmNew=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Internal Stream...
    if (NULL == m_pStmLock)
        goto exit;

    // I own the stream
    if (!ISFLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE))
        goto exit;

    // Copy m_pStmLock to a local place...
    CHECKALLOC(pstmNew = new CVirtualStream);

    // Go through m_pLockBytes to continue to provide thread safety to m_pStmLock
    CHECKHR(hr = HrCopyLockBytesToStream(m_pStmLock, pstmNew, NULL));

    // Rewind and commit
    CHECKHR(hr = pstmNew->Commit(STGC_DEFAULT));

    // Replace internal stream
    m_pStmLock->ReplaceInternalStream(pstmNew);

    // Hands are off..
    FLAGCLEAR(m_dwState, TREESTATE_HANDSONSTORAGE);

exit:
    // Cleanup
    SafeRelease(pstmNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetMessageSource
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetMessageSource(IStream **ppStream, DWORD dwFlags)
{
    // Locals
    HRESULT          hr=S_OK;
    IStream         *pStream=NULL;

    // Invalid Arg
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Init
    *ppStream = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty
    if (ISFLAGSET(dwFlags, COMMIT_ONLYIFDIRTY) && IsDirty() == S_OK && FALSE == m_rOptions.fHandsOffOnSave)
    {
        // Commit
        CHECKHR(hr = Commit(dwFlags));
    }

    // Raid-19644: MIMEOLE: GetMessageSource fails with MIME_E_NO_DATA (because of OID_HANDSOFF_ONSAVE = TRUE)
    if (NULL == m_pStmLock || TRUE == m_rOptions.fHandsOffOnSave)
    {
        // Create a new stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, FALSE, m_rOptions.fHandsOffOnSave, FALSE));

        // All good
        *ppStream = pStream;

        // Null pStream
        pStream = NULL;
    }

    // Otherwise, just wrap m_pStmLock
    else if (m_pStmLock)
    {
        // Locked Stream
        CHECKALLOC(*ppStream = (IStream *)new CLockedStream(m_pStmLock, m_cbMessage));
    }

    // Otherwise, failure
    else
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryService
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryService(REFGUID rsid, REFIID riid, void **ppvObject) /* IServiceProvider */
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IID_IBindMessageStream
    if (IID_IBindMessageStream == riid)
    {
        // We should not have a lock bytes yet
        Assert(NULL == m_pStmLock);

        // Create a Virtual Stream
        CHECKHR(hr = MimeOleCreateVirtualStream((IStream **)ppvObject));
    }

    // IID_IBinding
    else if (IID_IBinding == riid)
    {
        // No Bind Context Yet
        if (NULL == m_pBinding)
        {
            hr = TrapError(E_UNEXPECTED);
            goto exit;
        }

        // Return It
        (*ppvObject) = m_pBinding;
        ((IUnknown *)*ppvObject)->AddRef();
    }

    // IID_IMoniker
    else if (IID_IMoniker == riid)
    {
        // No Bind Context Yet
        if (NULL == m_pMoniker)
        {
            hr = TrapError(E_UNEXPECTED);
            goto exit;
        }

        // Return It
        (*ppvObject) = m_pMoniker;
        ((IUnknown *)*ppvObject)->AddRef();
    }

    // Otherwise, no object
    else
    {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::BinToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::BindToObject(const HBODY hBody, REFIID riid, void **ppvObject)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // BindToObject on the body
    CHECKHR(hr = pNode->pBody->BindToObject(riid, ppvObject));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr; 
}

// --------------------------------------------------------------------------------
// CMessageTree::_PoseCreateTreeNode
// --------------------------------------------------------------------------------
void CMessageTree::_PostCreateTreeNode(HRESULT hrResult, LPTREENODEINFO pNode)
{
    // Failure...
    if (FAILED(hrResult) && pNode)
    {
        // Set Index
        ULONG ulIndex = HBODYINDEX(pNode->hBody);

        // This body better be here
        Assert(m_rTree.prgpNode[ulIndex] == pNode);

        // Lets make sure nobody else is referencing this node...
#ifdef DEBUG
        for (ULONG i=0; i<m_rTree.cNodes; i++)
        {
            if (m_rTree.prgpNode[i])
            {
                AssertSz(m_rTree.prgpNode[i]->pPrev != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pNext != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pParent != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pChildHead != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pChildTail != pNode, "Killing a linked node is not good");
            }
        }
#endif

        // This node should not have been linked yet...
        AssertSz(pNode->pPrev == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pNext == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pParent == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pChildHead == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pChildTail == NULL, "Killing a linked node is not good");
        AssertSz(pNode->cChildren == 0, "Deleting a node with children");

        // Free It
        _FreeTreeNodeInfo(pNode);

        // Reset entry in table
        m_rTree.prgpNode[ulIndex] = NULL;

        // If Index is last item
        if (ulIndex + 1 == m_rTree.cNodes)
            m_rTree.cNodes--;

        // Otherwise, Increment Empty Count...
        else
            m_rTree.cEmpty++;
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrCreateTreeNode
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrCreateTreeNode(LPTREENODEINFO *ppNode)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i=0;
    BOOL        fUsingEmpty=FALSE;

    // Invalid Arg
    Assert(ppNode);

    // Use Empty Cell
    if (m_rTree.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Empty ?
            if (NULL == m_rTree.prgpNode[i])
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rTree.cNodes + 1 > m_rTree.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rTree.prgpNode, sizeof(LPTREENODEINFO) * (m_rTree.cAlloc + 10)));

            // Increment alloc size
            m_rTree.cAlloc += 10;
        }

        // Index to use
        i = m_rTree.cNodes;
    }

    // Set to empty
    m_rTree.prgpNode[i] = NULL;

    // Allocate this node...
    CHECKHR(hr = _HrAllocateTreeNode(i));

    // Return It
    *ppNode = m_rTree.prgpNode[i];

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rTree.cNodes++;

    // Otherwise, decrement number of empty cells
    else
        m_rTree.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::InsertBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::InsertBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode=NULL; 
    LPTREENODEINFO  pPivot=NULL;
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // Invalid Arg
    if (IBL_PARENT == location)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Handle Body Type
    if (IBL_ROOT == location)
    {
        // Currently No root
        if (NULL == m_pRootNode)
        {
            // Create Object
            CHECKHR(hr = _HrCreateTreeNode(&pNode));

            // Better not be any bodies
            Assert(m_rTree.cNodes == 1);

            // Set as root
            m_pRootNode = pNode;
        }

        // Otherwise, re-use the root
        else
        {
            hr = TrapError(MIME_E_CANT_RESET_ROOT);
            goto exit;
        }
    }

    // All non-root inserts
    else
    {
        // Get Pivot
        if (_FIsValidHandle(hPivot) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast it..
        pPivot = _PNodeFromHBody(hPivot);

        // Create Object
        CHECKHR(hr = _HrCreateTreeNode(&pNode));

        // First or Last Child
        if (IBL_LAST == location || IBL_FIRST == location)
        {
            // Better be a multipart
            if (!_IsMultiPart(pPivot))
            {
                hr = TrapError(MIME_E_NOT_MULTIPART);
                goto exit;
            }

            // DON'T FAIL FROM HERE TO END OF FUNCTION
            // No Children on pPivot
            if (NULL == pPivot->pChildHead)
            {
                Assert(pPivot->pChildTail == NULL);
                pPivot->pChildHead = pNode;
                pPivot->pChildTail = pNode;
                pNode->pParent = pPivot;
            }

            // IBL_LAST
            else if (IBL_LAST == location)
            {
                pPrev = pPivot->pChildTail;
                pNode->pPrev = pPrev;
                pPrev->pNext = pNode;
                pPivot->pChildTail = pNode;
                pNode->pParent = pPivot;
            }

            // IBL_FIRST
            else if (IBL_FIRST == location)
            {
                pNext = pPivot->pChildHead;
                pNode->pNext = pNext;
                pNext->pPrev = pNode;
                pPivot->pChildHead = pNode;
                pNode->pParent = pPivot;
            }

            // Increment Count
            pPivot->cChildren++;
        }

        // Otherwise
        else if (IBL_NEXT == location || IBL_PREVIOUS == location)
        {
            // Need a parent
            pParent = pPivot->pParent;

            // No Parent
            if (NULL == pParent)
            {
                hr = TrapError(MIME_E_NOT_MULTIPART);
                goto exit;
            }

            // DON'T FAIL FROM HERE TO END OF FUNCTION
            // Parent Better be a multipart
            Assert(_IsMultiPart(pParent));

            // Set Parent
            pNode->pParent = pParent;

            // IBL_NEXT
            if (IBL_NEXT == location)
            {
                // Set Previous
                pPrev = pPivot;

                // Append to the end
                if (NULL == pPrev->pNext)
                {
                    pPrev->pNext = pNode;
                    pNode->pPrev = pPrev;
                    pParent->pChildTail = pNode;
                }

                // Otherwise, inserting between two nodes
                else
                {
                    pNext = pPrev->pNext;
                    pNode->pPrev = pPrev;
                    pNode->pNext = pNext;
                    pPrev->pNext = pNode;
                    pNext->pPrev = pNode;
                }
            }

            // IBL_PREVIOUS
            else if (IBL_PREVIOUS == location)
            {
                // Set Previous
                pNext = pPivot;

                // Append to the end
                if (NULL == pNext->pPrev)
                {
                    pNext->pPrev = pNode;
                    pNode->pNext = pNext;
                    pParent->pChildHead = pNode;
                }

                // Otherwise, inserting between two nodes
                else
                {
                    pPrev = pNext->pPrev;
                    pNode->pNext = pNext;
                    pNode->pPrev = pPrev;
                    pPrev->pNext = pNode;
                    pNext->pPrev = pNode;
                }
            }

            // Increment Count
            pParent->cChildren++;
        }

        // Otherwise bad body location
        else
        {
            hr = TrapError(MIME_E_BAD_BODY_LOCATION);
            goto exit;
        }
    }

    // Set Return
    if (phBody)
        *phBody = pNode->hBody;

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Failure
    _PostCreateTreeNode(hr, pNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody)
{
    // Locals
    HRESULT     hr=S_OK;
    LPTREENODEINFO  pPivot, pCurr;

    // check params
    if (NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Handle Root Case
    if (IBL_ROOT == location)
    {
        if (m_pRootNode)
            *phBody = m_pRootNode->hBody;
        else
            hr = MIME_E_NOT_FOUND;
    }

    // Otherwise
    else
    {
        // Validate handle
        if (_FIsValidHandle(hPivot) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast It
        pPivot = _PNodeFromHBody(hPivot);

        // Handle Get Type
        switch(location)
        {
        // ----------------------------------------------
        case IBL_PARENT:
            if (pPivot->pParent)
                *phBody = pPivot->pParent->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_FIRST:
            if (pPivot->pChildHead)
                *phBody = pPivot->pChildHead->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_LAST:
            if (pPivot->pChildTail)
                *phBody = pPivot->pChildTail->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_NEXT:
            if (pPivot->pNext)
                *phBody = pPivot->pNext->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_PREVIOUS:
            if (pPivot->pPrev)
                *phBody = pPivot->pPrev->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        default:
            hr = TrapError(MIME_E_BAD_BODY_LOCATION);
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteBody(HBODY hBody, DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;
    BOOL            fMultipart;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate handle
    if (_FIsValidHandle(hBody) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Cast
    pNode = _PNodeFromHBody(hBody);

    // Free Children...
    fMultipart = (_IsMultiPart(pNode)) ? TRUE :FALSE;

    // Promote Children ?
    if (TRUE == fMultipart && ISFLAGSET(dwFlags, DELETE_PROMOTE_CHILDREN) && pNode->cChildren > 0)
    {
        // Call Helper
        CHECKHR(hr = _HrDeletePromoteChildren(pNode));
    }

    // Otherwise
    else
    {
        // If multipart, delete children
        if (fMultipart && pNode->cChildren > 0)
        {
            // Remove the children
            _DeleteChildren(pNode);
        }

        // If Not Children Only
        if (!ISFLAGSET(dwFlags, DELETE_CHILDREN_ONLY))
        {
            // Was this the root
            if (pNode == m_pRootNode)
            {
                // Delete the content type
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTBASE);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTLOC);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTID);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTTYPE);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTXFER);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTDISP);

                // Empty the body
                m_pRootNode->pBody->EmptyData();
            }

            // Otherwise, not deleting the root
            else
            {
                // Unlink the node
                _UnlinkTreeNode(pNode);

                // Fix up the table
                m_rTree.prgpNode[HBODYINDEX(hBody)] = NULL;

                // Increment Empty Count
                m_rTree.cEmpty++;

                // Free this node
                _FreeTreeNodeInfo(pNode);
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDeletePromoteChildren
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDeletePromoteChildren(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO    pParent, pChild, pNext, pPrev;

    // Get Parent
    pParent = pNode->pParent;

    // Single Child...
    if (1 == pNode->cChildren)
    {
        // Promote the child up one level...
        Assert(pNode->pChildHead && pNode->pChildHead && pNode->pChildHead == pNode->pChildTail);

        // Get Child
        pChild = pNode->pChildHead;
        Assert(pChild->pNext == NULL && pChild->pPrev == NULL && pChild->pParent == pNode);

        // Replace pBody with pChild
        pChild->pParent = pNode->pParent;
        pChild->pNext = pNode->pNext;
        pChild->pPrev = pNode->pPrev;

        // Is there a parent ?
        if (pParent)
        {
            // Fixup pChildHead and pChildTail
            if (pParent->pChildHead == pNode)
                pParent->pChildHead = pChild;
            if (pParent->pChildTail == pNode)
                pParent->pChildTail = pChild;
        }

        // pNode's next and Previous
        LPTREENODEINFO pNext = pNode->pNext;
        LPTREENODEINFO pPrev = pNode->pPrev;

        // Fixup Next and Previuos
        if (pNext)
            pNext->pPrev = pChild;
        if (pPrev)
            pPrev->pNext = pChild;

        // pNode Basically does not have any children now
        Assert(pNode->cChildren == 1);
        pNode->cChildren = 0;

        // Was this the root ?
        if (m_pRootNode == pNode)
        {
            // OE5 Raid: 51543
            if(S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN))
            {
                pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);
            }

            // Raid 41595 - Athena: Reply to a message includes the body of the message being replied to as an attachment
            CHECKHR(hr = pChild->pContainer->MoveProps(0, NULL, m_pRootNode->pBody));

            // Reset Header on pChild
            pChild->pBody->SwitchContainers(m_pRootNode->pBody);

            // Copy Options from p and tell m_pRootNode->pBody
            m_pRootNode->pBody->CopyOptionsTo(pChild->pBody, TRUE);

            // New root
            m_pRootNode = pChild;
        }

        // We have now totally unlinked pNode
        DebugAssertNotLinked(pNode);

        // Fix up the table
        m_rTree.prgpNode[HBODYINDEX(pNode->hBody)] = NULL;

        // Increment Empty Count
        m_rTree.cEmpty++;

        // Free this node
        _FreeTreeNodeInfo(pNode);
    }

    // Or parent is a multipart
    else
    {
        // No parent or not multipart
        if (NULL == pParent || FALSE == _IsMultiPart(pParent))
        {
            hr = TrapError(MIME_E_INVALID_DELETE_TYPE);
            goto exit;
        }

        // Set Previous
        pPrev = pParent->pChildTail;

        // Walk children of pBody and append as children of pParent
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // pPrev
            pChild->pPrev = pPrev;

            // pNext
            pChild->pNext = NULL;
            
            // pPrev->pNext
            if (pPrev)
                pPrev->pNext = pChild;

            // pChildTail
            pParent->pChildTail = pChild;

            // Set Parent
            pChild->pParent = pParent;

            // Increment pParent child count
            pParent->cChildren++;

            // Save pPrev
            pPrev = pChild;
        }

        // Unlink the node
        _UnlinkTreeNode(pNode);

        // Fix up the table
        m_rTree.prgpNode[HBODYINDEX(pNode->hBody)] = NULL;

        // Increment Empty Count
        m_rTree.cEmpty++;

        // Free this node
        _FreeTreeNodeInfo(pNode);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_DeleteChildren
// --------------------------------------------------------------------------------
void CMessageTree::_DeleteChildren(LPTREENODEINFO pParent)
{
    // Locals
    ULONG           i;
    LPTREENODEINFO  pNode;

    // check params
    Assert(pParent);

    // Loop through bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];

        // Could be null if I already deleted it
        if (NULL == pNode)
            continue;

        // pBody is Parent...
        if (pParent == pNode->pParent)
        {
            // Free Children...
            if (_IsMultiPart(pNode))
            {
                // Delete Children
                _DeleteChildren(pNode);
            }

            // Unlink the node
            _UnlinkTreeNode(pNode);

            // Free this node
            _FreeTreeNodeInfo(pNode);

            // Fix up the table
            m_rTree.prgpNode[i] = NULL;

            // Increment Empty Count
            m_rTree.cEmpty++;
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::MoveBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::MoveBody(HBODY hBody, BODYLOCATION location)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode; 
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate handle
    if (_FIsValidHandle(hBody) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Cast
    pNode = _PNodeFromHBody(hBody);

    // Handle Location Type
    switch(location)
    {
    // ------------------------------------------------------------------------------------
    case IBL_PARENT:
        // Root already
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pParent || NULL == pNode->pParent->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Parent better be a multipart
        Assert(_IsMultiPart(pParent) && _IsMultiPart(pNode->pParent));

        // Unlink from tree
        _UnlinkTreeNode(pNode);

        // Get the current first child
        pPrev = pParent->pChildTail;

        // Fixup pCurrent
        pNode->pPrev = pPrev;

		if (pPrev)
        {
            // Fixup pPrev
            pPrev->pNext = pNode;
        }

        // Fixup Tail
        pParent->pChildTail = pNode;

        // Increment child count
        pParent->cChildren++;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    // This is a swap of two nodes in a doubly-linked list
    case IBL_NEXT:
        // No Next ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pNext)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Setup for move
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // Set pNext up...
        Assert(pNext->pPrev == pNode);
        pNext->pPrev = pPrev;

        // Setup pPrev
        if (pPrev)
        {
            Assert(pPrev->pNext == pNode);
            pPrev->pNext = pNext;
        }

        // Setup pNode->pNext
        pNode->pNext = pNext->pNext;
        if (pNode->pNext)
        {
            Assert(pNode->pNext->pPrev == pNext);
            pNode->pNext->pPrev = pNode;
        }
        pNext->pNext = pNode;

        // Setup pNode->pPrev
        pNode->pPrev = pNext;    

        // Get Parent
        pParent = pNode->pParent;

        // Adjust Child and Tail...
        if (pNode == pParent->pChildHead)
            pParent->pChildHead = pNext;
        if (pNext == pParent->pChildTail)
            pParent->pChildTail = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    // This is a swap of two nodes in a doubly-linked list (reverse of IBL_NEXT)
    case IBL_PREVIOUS:
        // No pPrev ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pPrev)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Setup for move
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // Set pNext
        Assert(pPrev->pNext == pNode);
        pPrev->pNext = pNext;

        // Setup pPrev
        pPrev->pPrev = pNode;

        // Fixup Net
        if (pNext)
        {
            Assert(pNext->pPrev == pNode);
            pNext->pPrev = pPrev;
        }

        // Setup pNode->pNext
        pNode->pNext = pPrev;

        // Setup pNode->pPrev
        pNode->pPrev = pPrev->pPrev;

        // Setup two(prev)->next
        if (pNode->pPrev)
        {
            Assert(pNode->pPrev->pNext == pPrev);
            pNode->pPrev->pNext = pNode;
        }

        // Get Parent
        pParent = pNode->pParent;

        // Adjust Child and Tail...
        if (pNode == pParent->pChildTail)
            pParent->pChildTail = pPrev;
        if (pPrev == pParent->pChildHead)
            pParent->pChildHead = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_FIRST:
        // No Parent ?
        if (NULL == pNode->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Better be first child
        if (NULL == pNode->pPrev)
        {
            Assert(pNode == pParent->pChildHead);
            goto exit;
        }

        // Unlink this body
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // If pPrev
        pPrev->pNext = pNext;

        // If pNext or pChildTail
        if (pNext)
        {
            Assert(pNext->pPrev == pNode);
            pNext->pPrev = pPrev;
        }
        else if (pParent)
        {
            Assert(pParent->pChildTail == pNode);
            pParent->pChildTail = pPrev;
        }

        // Setup pNode
        pNode->pNext = pParent->pChildHead;
        pParent->pChildHead->pPrev = pNode;
        pNode->pPrev = NULL; 
        pParent->pChildHead = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_LAST:
        // No Parent ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Better be first child
        if (NULL == pNode->pNext)
        {
            Assert(pNode == pParent->pChildTail);
            goto exit;
        }

        // Unlink this body
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // If pPrev
        pNext->pPrev = pPrev;

        // If pNext or pChildTail
        if (pPrev)
        {
            Assert(pPrev->pNext == pNode);
            pPrev->pNext = pNext;
        }
        else if (pParent)
        {
            Assert(pParent->pChildHead == pNode);
            pParent->pChildHead = pNext;
        }

        // Setup pNode
        pNode->pPrev = pParent->pChildTail;
        pNode->pNext = NULL; 
        pParent->pChildTail = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_ROOT:
        hr = TrapError(MIME_E_CANT_MOVE_BODY);
        goto exit;

    // ------------------------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_BAD_BODY_LOCATION);
        goto exit;
    }

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#ifndef WIN16

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkTreeNode
// --------------------------------------------------------------------------------
void CMessageTree::_UnlinkTreeNode(LPTREENODEINFO pNode)
{
    // Locals
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // Check Params
    Assert(pNode);

    // Set Next and Previous
    pParent = pNode->pParent;
    pPrev = pNode->pPrev;
    pNext = pNode->pNext;

    // If pPrev
    if (pPrev)
        pPrev->pNext = pNext;
    else if (pParent)
        pParent->pChildHead = pNext;

    // If pNext
    if (pNext)
        pNext->pPrev = pPrev;
    else if (pParent)
        pParent->pChildTail = pPrev;

    // Delete Children on Parent
    if (pParent)
        pParent->cChildren--;

    // Cleanup pNode
    pNode->pParent = NULL;
    pNode->pNext = NULL;
    pNode->pPrev = NULL;
    pNode->pChildHead = NULL;
    pNode->pChildTail = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::CountBodies
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::CountBodies(HBODY hParent, boolean fRecurse, ULONG *pcBodies)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pcBodies)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcBodies = 0;

    // No Parent ?
    if (NULL == hParent || HBODY_ROOT == hParent)
    {
        // Is there a root..
        if (NULL == m_pRootNode)
            goto exit;

        // Use Root
        pNode = m_pRootNode;
    }

    // Otherwise, get parent...
    else
    {
        // Validate handle
        if (_FIsValidHandle(hParent) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast
        pNode = _PNodeFromHBody(hParent);
    }

    // Include the root
    (*pcBodies)++;

    // Count the children...
    _CountChildrenInt(pNode, fRecurse, pcBodies);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_CountChildrenInt
// --------------------------------------------------------------------------------
void CMessageTree::_CountChildrenInt(LPTREENODEINFO pParent, BOOL fRecurse, ULONG *pcChildren)
{
    // Locals
    LPTREENODEINFO pNode;

    // check params
    Assert(pParent && pcChildren);

    // Loop through bodies
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];

        // Empty..
        if (NULL == pNode)
            continue;

        // pNode is Parent...
        if (pParent == pNode->pParent)
        {
            // Increment Count
            (*pcChildren)++;

            // Free Children...
            if (fRecurse && _IsMultiPart(pNode))
                _CountChildrenInt(pNode, fRecurse, pcChildren);
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::FindFirst
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::FindFirst(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Invalid Arg
    if (NULL == pFindBody)
        return TrapError(E_INVALIDARG);

    // Init Find
    pFindBody->dwReserved = 0;

    // Find Next
    return FindNext(pFindBody, phBody);
}

// --------------------------------------------------------------------------------
// CMessageTree::FindNext
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::FindNext(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pFindBody || NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Loop
    for (i=pFindBody->dwReserved; i<m_rTree.cNodes; i++)
    {
        // If delete
        pNode = m_rTree.prgpNode[i];

        // Empty
        if (NULL == pNode)
            continue;

        // Compare content type
        if (pNode->pContainer->IsContentType(pFindBody->pszPriType, pFindBody->pszSubType) == S_OK)
        {
            // Save Index of next item to search
            pFindBody->dwReserved = i + 1;
            *phBody = pNode->hBody;
            goto exit;
        }
    }

    // Error
    pFindBody->dwReserved = m_rTree.cNodes; 
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::ToMultipart
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::ToMultipart(HBODY hBody, LPCSTR pszSubType, LPHBODY phMultipart)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pNode;
    LPTREENODEINFO      pNew=NULL;
    LPTREENODEINFO      pParent;
    LPTREENODEINFO      pNext; 
    LPTREENODEINFO      pPrev;

    // check params
    if (NULL == hBody || NULL == pszSubType)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phMultipart)
        *phMultipart = NULL;

    // Get the body from hBody
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // We better have a root
    Assert(m_pRootNode);

    // If pNode does not have a parent...
    if (NULL == pNode->pParent)
    {
        // pNode must be the root ?
        Assert(m_pRootNode == pNode);

        // Create Object
        //N duplicated
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // Set pNode First and Last...
        pNew->pChildHead = m_pRootNode;
        pNew->pChildTail = m_pRootNode;
        m_pRootNode->pParent = pNew;

        // Set Children Count
        pNew->cChildren = 1;

        // Set new root
        m_pRootNode = pNew;

        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Swap Property Sets...
        Assert(m_pRootNode != pNode);
        m_pRootNode->pBody->SwitchContainers(pNode->pBody);

        // Copy Some Props Across
        CHECKHR(hr = m_pRootNode->pBody->MoveProps(ARRAYSIZE(g_rgszToMultipart), g_rgszToMultipart, pNode->pBody));
    }

    // Otherwise, create a body that takes the place of pNode
    else
    {
        // Create a body object
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // DON'T FAIL FROM HERE TO END OF FUNCTION
        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Assume the position of pNode
        pNew->pParent = pNode->pParent;
        pNew->pPrev = pNode->pPrev;
        pNew->pNext = pNode->pNext;
        pNew->pChildHead = pNode;
        pNew->pChildTail = pNode;
        pNew->cChildren = 1;

        // Set pParnet
        pParent = pNode->pParent;

        // Fix up parent head and child
        if (pParent->pChildHead == pNode)
            pParent->pChildHead = pNew;
        if (pParent->pChildTail == pNode)
            pParent->pChildTail = pNew;

        // Set pNode Parent
        pNode->pParent = pNew;

        // Fixup pNext and pPrev
        pNext = pNode->pNext;
        pPrev = pNode->pPrev;
        if (pNext)
            pNext->pPrev = pNew;
        if (pPrev)
            pPrev->pNext = pNew;

        // Clear pNext and pPrev
        pNode->pNext = NULL;
        pNode->pPrev = NULL;
    }

    // Change this nodes content type
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_PRITYPE, STR_CNT_MULTIPART));
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

    pNode->pBody->CopyOptionsTo(pNew->pBody);

exit:
    // Create Worked
    _PostCreateTreeNode(hr, pNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrNodeFromHandle
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrNodeFromHandle(HBODY hBody, LPTREENODEINFO *ppBody)
{
    // Invalid Arg
    Assert(hBody && ppBody);

    // Root ?
    if ((HBODY)HBODY_ROOT == hBody)
    {
        // No Root
        if (NULL == m_pRootNode)
            return MIME_E_NO_DATA;

        // Otherwise, use root
        *ppBody = m_pRootNode;
    }

    // Otherwise
    else
    {
        // Validate handle
        if (_FIsValidHandle(hBody) == FALSE)
            return TrapError(MIME_E_INVALID_HANDLE);

        // Get Node
        *ppBody = _PNodeFromHBody(hBody);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsBodyType
// --------------------------------------------------------------------------------
HRESULT CMessageTree::IsBodyType(HBODY hBody, IMSGBODYTYPE bodytype)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pBody->IsType(bodytype);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsContentType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::IsContentType(HBODY hBody, LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->IsContentType(pszPriType, pszSubType);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryBodyProp(HBODY hBody, LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->GetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->SetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteBodyProp(HBODY hBody, LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->DeleteProp(pszName);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FIsUuencodeBegin
// --------------------------------------------------------------------------------
BOOL CMessageTree::_FIsUuencodeBegin(LPPROPSTRINGA pLine, LPSTR *ppszFileName)
{
    // Locals
    ULONG i;

    // check params
    Assert(ISVALIDSTRINGA(pLine));

    // Length must be at least 11 to accomodate "begin 666 " and the first character of a filename.
    if (pLine->cchVal < 11)
        return FALSE;
    
    // First 6 characters must be "begin ", or we're not a valid line.
    if (StrCmpN(pLine->pszVal, "begin ", 6) != 0)
        return FALSE;
    
    // Check characters 6-8 for valid Unix filemode. They must all be digits between 0 and 7.
    for (i=6; i<pLine->cchVal; i++)
    {
        if (pLine->pszVal[i] < '0' || pLine->pszVal[i] > '7')
            break;
    }
    
    // Not a begin line
    if (pLine->pszVal[i] != ' ')
        return FALSE;

    // Get File Name
    if (ppszFileName)
    {
        *ppszFileName = PszDupA(pLine->pszVal + i + 1);
        ULONG cbLine = lstrlen (*ppszFileName);
        StripCRLF(*ppszFileName, &cbLine);
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GetMimeBoundaryType
// --------------------------------------------------------------------------------
BOUNDARYTYPE CMessageTree::_GetMimeBoundaryType(LPPROPSTRINGA pLine, LPPROPSTRINGA pBoundary)
{
    // Locals
    BOUNDARYTYPE boundary=BOUNDARY_NONE;
    CHAR         ch;
    ULONG        cchLine=pLine->cchVal;
    LPSTR        psz1, psz2;

    // Check Params
    Assert(ISVALIDSTRINGA(pBoundary) && ISVALIDSTRINGA(pLine));

    // Check First two chars of the line
    if ('-' != pLine->pszVal[0] || '-' != pLine->pszVal[1])
        goto exit;

    // Removes trailing white spaces
    while(pLine->cchVal > 0)
    {
        // Get the last character
        ch = *(pLine->pszVal + (pLine->cchVal - 1));

        // No LWSP or CRLF
        if (' ' != ch && '\t' != ch && chCR != ch && chLF != ch)
            break;

        // Decrement Length
        pLine->cchVal--;
    }

    // Decrement two for --
    pLine->cchVal -= 2;

    // Checks line length against boundary length
    if (pLine->cchVal != pBoundary->cchVal && pLine->cchVal != pBoundary->cchVal + 2)
        goto exit;

    // Compare the line with the boundary
    if (StrCmpN(pLine->pszVal + 2, pBoundary->pszVal, (size_t)pBoundary->cchVal) == 0)
    {
        // BOUNDARY_MIMEEND
        if ((pLine->cchVal > pBoundary->cchVal) && (pLine->pszVal[pBoundary->cchVal+2] == '-') && (pLine->pszVal[pBoundary->cchVal+3] == '-'))
            boundary = BOUNDARY_MIMEEND;

        // BOUNDARY_MIMENEXT
        else if (pLine->cchVal == pBoundary->cchVal)
            boundary = BOUNDARY_MIMENEXT;
    }

exit:
    // Relace the Length
    pLine->cchVal = cchLine;

    // Done
    return boundary;
}

// --------------------------------------------------------------------------------
// CMessageTree::ResolveURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::ResolveURL(HBODY hRelated, LPCSTR pszBase, LPCSTR pszURL, 
    DWORD dwFlags, LPHBODY phBody)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pSearchRoot;
    RESOLVEURLINFO      rInfo;
    HBODY               hBody=NULL;
    PROPSTRINGA         rBaseUrl;
    LPSTR               pszFree=NULL;
    LPSTR               pszFree2=NULL;
    BOOL                fMultipartBase=FALSE;

    // InvalidArg
    if (NULL == pszURL)
        return TrapError(E_INVALIDARG);

    // Init
    if (phBody)
        *phBody = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If hRelated is NULL, find the first multipart/related
    if (NULL == hRelated)
    {
        // Find the Related
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
        {
            // Use Root
            hRelated = m_pRootNode->hBody;
        }
    }

    // Get Default Base
    if (NULL == pszBase && FALSE == ISFLAGSET(dwFlags, URL_RESULVE_NO_BASE))
    {
        // Compute the content-base
        if (SUCCEEDED(MimeOleComputeContentBase(this, hRelated, &pszFree, &fMultipartBase)))
            pszBase = pszFree;
    }

    // Setup Resolve URL Info
    ZeroMemory(&rInfo, sizeof(RESOLVEURLINFO));

    // This is the base that we will use to absolutify URLs that are in the text/html body
    rInfo.pszBase = pszBase;

    // Set the url that we are looking for, could be combined with rInfo.pszBase
    rInfo.pszURL = pszURL;

    // Are we searching for a CID type URL.
    if (StrCmpNI(pszURL, c_szCID, lstrlen(c_szCID)) == 0)
    {
        rInfo.fIsCID = TRUE;
        rInfo.pszURL += 4;
    }
    else
        rInfo.fIsCID = FALSE;

    // Raid-62579: Athena: Need to support MHTML content-base inheritance
    if (hRelated)
    {
        // Did pszBase come from the multipart/related section ?
        if (fMultipartBase)
            rInfo.pszInheritBase = pszBase;

        // Otherwise, lookup the multipart/related base header
        else
            rInfo.pszInheritBase = pszFree2 = MimeOleContentBaseFromBody(this, hRelated);
    }

    // Get a Body from the Handle
    CHECKHR(hr = _HrNodeFromHandle(rInfo.fIsCID ? HBODY_ROOT : hRelated, &pSearchRoot));

    // Recurse the Tree
    CHECKHR(hr = _HrRecurseResolveURL(pSearchRoot, &rInfo, &hBody));

    // Not found
    if (NULL == hBody)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Return It ?
    if (phBody)
        *phBody = hBody;

    // Mark as Resolved ?
    if (ISFLAGSET(dwFlags, URL_RESOLVE_RENDERED))
    {
        // Defref the body
        LPTREENODEINFO pNode = _PNodeFromHBody(hBody);

        // Set Rendered
        PROPVARIANT rVariant;
        rVariant.vt = VT_UI4;
        rVariant.ulVal = TRUE;

        // Set the Property
        SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszFree2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrRecurseResolveURL
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrRecurseResolveURL(LPTREENODEINFO pNode, LPRESOLVEURLINFO pInfo, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pChild;

    // Invalid Arg
    Assert(pNode && pInfo && phBody);

    // We must have not found the body yet ?
    Assert(NULL == *phBody);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrRecurseResolveURL(pChild, pInfo, phBody));

            // Done
            if (NULL != *phBody)
                break;
        }
    }

    // Get Character Set Information
    else 
    {
        // Ask the container to do the resolution
        if (SUCCEEDED(pNode->pContainer->HrResolveURL(pInfo)))
        {
            // Cool we found the body, we resolved the URL
            *phBody = pNode->hBody;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::GetPropW(LPCWSTR pwszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::SetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->SetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::SetPropW(LPCWSTR pwszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteProp(LPCSTR pszName)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->DeleteProp(pszName);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::DeletePropW(LPCWSTR pwszName)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::QueryPropW(LPCWSTR pwszName, LPCWSTR pwszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressTable(IMimeAddressTable **ppTable)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->BindToObject(IID_IMimeAddressTable, (LPVOID *)ppTable);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetSender
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetSender(LPADDRESSPROPS pAddress)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetSender(pAddress);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetTypes(dwAdrTypes, dwProps, pList);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressFormat
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetFormat(dwAdrType, format, ppszFormat);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressFormatW
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppszFormat)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetFormatW(dwAdrType, format, ppszFormat);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::EnumAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::EnumAddressTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->EnumTypes(dwAdrTypes, dwProps, ppEnum);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrGetTextTypeInfo
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrGetTextTypeInfo(DWORD dwTxtType, LPTEXTTYPEINFO *ppTextInfo)
{
    // Invalid Arg
    Assert(ppTextInfo);

    // Init
    *ppTextInfo = NULL;

    // Locate the text type
    for (ULONG i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
    {
        // Desired Text Type
        if (g_rgTextInfo[i].dwTxtType == dwTxtType)
        {
            // Found It
            *ppTextInfo = (LPTEXTTYPEINFO)&g_rgTextInfo[i];
            return S_OK;
        }
    }

    // Un-identified text type
    if (NULL == *ppTextInfo)
        return TrapError(MIME_E_INVALID_TEXT_TYPE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FindDisplayableTextBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_FindDisplayableTextBody(LPCSTR pszSubType, 
    LPTREENODEINFO pNode, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cBodies;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode && phBody && pszSubType && NULL == *phBody);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            hr = _FindDisplayableTextBody(pszSubType, pChild, phBody);

            // Done ?
            if (SUCCEEDED(hr))
            {
                Assert(*phBody);
                goto exit;
            }
        }
    }

    // Otherwise...
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, pszSubType))
    {
        // If not an attachment...
        if (S_FALSE == IsBodyType(pNode->hBody, IBT_ATTACHMENT))
        {
            *phBody = pNode->hBody;
            goto exit;
        }

        // Otherwise...Raid 43444: Inbox Direct messages showing as attachments
        else
        {
            // Count Bodies
            CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

            // Only one body...
            if (cBodies == 1)
            {
                // Inline or Disposition is not set
                if (m_pRootNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_INLINE, FALSE, FALSE) == S_OK || 
                    m_pRootNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTDISP)) == S_FALSE)
                {
                    *phBody = pNode->hBody;
                    goto exit;
                }
            }
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageTree::GetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    IStream **ppStream, LPHBODY phBody)
{
    // Locals
    HRESULT              hr=S_OK;
    HRESULT              hrFind;
    LPTEXTTYPEINFO       pTextInfo=NULL;
    FINDBODY             rFind;
    IMimeBody           *pBody=NULL;
    PROPVARIANT          rStart;
    PROPVARIANT          rVariant;
    HBODY                hAlternativeParent;
    HBODY                hFirst=NULL;
    HBODY                hChild;
    HBODY                hBody=NULL;
    HBODY                hRelated;
    LPSTR                pszStartCID=NULL;
    BOOL                 fMarkRendered=TRUE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;
    if (ppStream)
        *ppStream = NULL;

    // Init
    MimeOleVariantInit(&rStart);

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // MimeHTML
    if (SUCCEEDED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
    {
        // Get start= parameter
        if (SUCCEEDED(GetBodyProp(hRelated, STR_PAR_START, 0, &rStart)))
        {
            // Raid 63823: Mail : Content-Location Href's inside the message do not work if there is a Start Parameter in headers
            //             The start parameter can only specify a CID.     

            // I need to prefix cid: onto the front of rStart
            DWORD cchSize = (lstrlen(rStart.pszVal) + lstrlen(c_szCID) + 1);
            CHECKALLOC(pszStartCID = PszAllocA(cchSize));

            // Format the CID
            wnsprintfA(pszStartCID, cchSize, "%s%s", c_szCID, rStart.pszVal);

            // Resolve this URL
            ResolveURL(hRelated, NULL, pszStartCID, URL_RESULVE_NO_BASE, &hBody);
        }
    }

    // Still haven't found a text body ?
    if (NULL == hBody)
    {
        // FindTextBody
        hr = _FindDisplayableTextBody(pTextInfo->pszSubType, m_pRootNode, &hBody);

        // If that failed and we were looking for html, try to get enriched text...
        if (FAILED(hr) && ISFLAGSET(dwTxtType, TXT_HTML))
        {
            // Looking for text/html, lets try to find text/enriched
            hr = _FindDisplayableTextBody(STR_SUB_ENRICHED, m_pRootNode, &hBody);
        }

        // Not Found
        if (FAILED(hr))
        {
            hr = TrapError(MIME_E_NOT_FOUND);
            goto exit;
        }

        // Reset hr
        hr = S_OK;
    }

    // Get the stream...
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If Empty...
    if (pBody->IsType(IBT_EMPTY) == S_OK)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // User Wants the Data
    if (ppStream)
    {
        // If content-type is text/enriched, convert to html
        if (pBody->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED) == S_OK)
        {
            // Better be asking for html
            Assert(ISFLAGSET(dwTxtType, TXT_HTML));

            // Do the Conversion
            CHECKHR(hr = MimeOleConvertEnrichedToHTMLEx(pBody, ietEncoding, ppStream));
        }

        // Otherwise, non-text enriched case
        else
        {
            // Get Data
            CHECKHR(hr = pBody->GetData(ietEncoding, ppStream));
        }
    }

    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_OE5))
    {
        // If there is no stream requested, then don't mark rendered
        if (NULL == ppStream)
        {
            // Don't Mark Rendered
            fMarkRendered = FALSE;
        }
    }

    // Mark Rendered
    if (fMarkRendered)
    {
        // Rendered
        rVariant.vt = VT_UI4;
        rVariant.ulVal = TRUE;

        // Lets set the resourl flag
        SideAssert(SUCCEEDED(pBody->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

        // Raid-45116: new text attachment contains message body on Communicator inline image message
        if (FAILED(GetBody(IBL_PARENT, hBody, &hAlternativeParent)))
            hAlternativeParent = NULL;

        // Try to find an alternative parent...
        while(hAlternativeParent)
        {
            // If multipart/alternative, were done
            if (IsContentType(hAlternativeParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
                break;

            // Get Next Parent
            if (FAILED(GetBody(IBL_PARENT, hAlternativeParent, &hAlternativeParent)))
                hAlternativeParent = NULL;
        }

        // Get Parent
        if (hAlternativeParent)
        {
            // Resolve all first level children
            hrFind = GetBody(IBL_FIRST, hAlternativeParent, &hChild);
            while(SUCCEEDED(hrFind) && hChild)
            {
                // Set Resolve Property
                SideAssert(SUCCEEDED(SetBodyProp(hChild, PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

                // Find Next
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }
        }
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody); 
    SafeMemFree(pszStartCID);
    MimeOleVariantFree(&rStart);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    HBODY hAlternative, IStream *pStream, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    HBODY           hRoot,
                    hBody,
                    hTextBody=NULL,
                    hSection,
                    hParent,
                    hPrevious, 
                    hInsertAfter;
    LPTEXTTYPEINFO  pTextInfo=NULL;
    BOOL            fFound,
                    fFoundInsertLocation;
    DWORD           dwWeightBody;
    ULONG           i;
    IMimeBody      *pBody=NULL;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Debug Dump
    // DebugDumpTree("SetTextBody", TRUE);

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // Raid-45369: message from Eudora Pro comes in .txt attachment which is lost when forwarded.
    // If hAlternative is NULL, then this means that the client wants to replace all text bodies
    // with this new text body. If hAlternative is not NULL, then the client has already inserted
    // a text body and created a alternative section, no more deleting.
    if (NULL == hAlternative)
    {
        // Loop through the text type
        for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
        {
            // Get the Current Text Body Associated with this type
            if (SUCCEEDED(GetTextBody(g_rgTextInfo[i].dwTxtType, IET_BINARY, NULL, &hBody)))
            {
                // If the parent of hBody is an alternative section, delete the alternative
                if (SUCCEEDED(GetBody(IBL_PARENT, hBody, &hParent)) && IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
                {
                    // Delete multipart/alternative
                    hBody = hParent;
                }

                // Not if hBody is equal to hAlternative
                if (hBody != hAlternative)
                {
                    // Locals
                    HRESULT     hrFind;
                    HBODY       hFind;

                    // Raid-54277: Mail : Inline replying losses inline images sent from Nav4 using Plain text & HTML format
                    hrFind = GetBody(IBL_FIRST, hBody, &hFind);
                    while(SUCCEEDED(hrFind) && hFind)
                    {
                        // If not a multipart/related, delete it
                        if (S_FALSE == IsContentType(hFind, STR_CNT_MULTIPART, STR_SUB_RELATED))
                        {
                            // Delete this body
                            CHECKHR(hr = DeleteBody(hFind, 0));

                            // Use the hPrevious
                            hrFind = GetBody(IBL_FIRST, hBody, &hFind);
                        }

                        // Get Next
                        else
                        {
                            // Find Next
                            hrFind = GetBody(IBL_NEXT, hFind, &hFind);
                        }
                    }

                    // Delete the multipart/alternative section, promoting any multipart/related section
                    CHECKHR(hr = DeleteBody(hBody, DELETE_PROMOTE_CHILDREN));

                    // Done
                    break;
                }
            }
        }
    }

    // Get Root
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // If only one body..
    if (IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Just use the root
        hTextBody = hRoot;
    }

    // Otherwise, if not inserting an alternative body, we must need a multipart/mixed or multipart/related section
    else if (NULL == hAlternative)
    {
        // Better not be an alternative section
        Assert(FAILED(MimeOleGetAlternativeSection(this, &hSection, NULL)));

        // If there is a related section use it
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hSection, NULL)))
        {
            // Find or Create a multipart/mixed section
            CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
        }

        // Insert an element at the head of this section...
        CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
    }

    // Otherwise, if inserting an alternative body
    else if (hAlternative != NULL)
    {
        // Verify pBody is STR_CNT_TEXT
        Assert(IsContentType(hAlternative, STR_CNT_TEXT, NULL) == S_OK);

        // Get hAlternative's parent
        if (FAILED(GetBody(IBL_PARENT, hAlternative, &hParent)))
            hParent = NULL;

        // If hAlternative is the root
        if (hRoot == hAlternative || NULL == hParent || IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_FALSE)
        {
            // Convert this body to a multipart/alternative
            CHECKHR(hr = ToMultipart(hAlternative, STR_SUB_ALTERNATIVE, &hSection));
        }

        // Otherwise, hSection is equal to hParent
        else
            hSection = hParent;

        // We better have an alternative section now...
        Assert(IsContentType(hSection, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK);

        // Init Search
        hPrevious = NULL;
        fFound = FALSE;
        fFoundInsertLocation = FALSE;
        dwWeightBody = 0;
        hInsertAfter = NULL;

        // Lets enum the children of rLayout.hAlternative and verify that hAlternative is still a child...and decide what alternative body to insert after
        hrFind = GetBody(IBL_FIRST, hSection, &hBody);
        while(SUCCEEDED(hrFind) && hBody)
        {
            // Default dwWeightBody
            dwWeightBody = 0xffffffff;

            // Get Weight of hBody
            for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
            {
                // Compare Content Type
                if (IsContentType(hBody, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                {
                    dwWeightBody = g_rgTextInfo[i].dwWeight;
                    break;
                }
            }

            // Get Alternative Weight of the body we are inserting
            if (pTextInfo->dwWeight <= dwWeightBody && FALSE == fFoundInsertLocation)
            {
                fFoundInsertLocation = TRUE;
                hInsertAfter = hPrevious;
            }

            // Is this the alternative brother...
            if (hAlternative == hBody)
                fFound = TRUE;

            // Set hPrev
            hPrevious = hBody;

            // Find Next
            hrFind = GetBody(IBL_NEXT, hBody, &hBody);
        }

        // If we didn't find hAlternative, we're hosed
        if (FALSE == fFound)
        {
            Assert(FALSE);
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // If no after was found... insert first..
        if (NULL == hInsertAfter)
        {
            // BODY_LAST_CHILD
            if (pTextInfo->dwWeight > dwWeightBody)
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hTextBody));
            }

            // BODY_FIRST_CHILD
            else
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
            }
        }

        // Otherwise insert after hInsertAfter
        else
        {
            // Insert a new body...
            CHECKHR(hr = InsertBody(IBL_NEXT, hInsertAfter, &hTextBody));
        }
    }

    // Open the object
    Assert(hTextBody);
    CHECKHR(hr = BindToObject(hTextBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set the root...
    CHECKHR(hr = pBody->SetData(ietEncoding, STR_CNT_TEXT, pTextInfo->pszSubType, IID_IStream, (LPVOID)pStream));

    // Release This
    SafeRelease(pBody);

    // Set multipart/related; type=...
    if (SUCCEEDED(GetBody(IBL_PARENT, hTextBody, &hParent)))
    {
        // If parent is multipart/related, set type
        if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
        {
            // Get Parent
            CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

            // type = text/plain
            if (ISFLAGSET(dwTxtType, TXT_PLAIN))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }

            // type = text/plain
            else if (ISFLAGSET(dwTxtType, TXT_HTML))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_HTML;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }
            else
                AssertSz(FALSE, "UnKnown dwTxtType passed to IMimeMessage::SetTextBody");
        }

        // Otherwise, if hParent is multipart/alternative
        else if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Set multipart/related; type=...
            if (SUCCEEDED(GetBody(IBL_PARENT, hParent, &hParent)))
            {
                // If parent is multipart/related, set type
                if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
                {
                    // Get Parent
                    CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

                    // Setup Variant
                    rVariant.vt = VT_LPSTR;
                    rVariant.pszVal = (LPSTR)STR_MIME_MPART_ALT;

                    // Set the Properyt
                    CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
                }
            }
        }
    }

    // Set body handle
    if (phBody)
        *phBody = hTextBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AttachObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachObject(REFIID riid, void *pvObject, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody,
                    hMixed;
    IMimeBody      *pBody=NULL;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pvObject || FALSE == FBODYSETDATAIID(riid))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Get Mixed Section
    CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hMixed, NULL));

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hMixed, &hBody));

    // Bind to the Body Object
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set Data Object
    CHECKHR(hr = pBody->SetData(IET_INETCSET, NULL, NULL, riid, pvObject));

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)STR_DIS_ATTACHMENT;

    // Mark as Attachment
    CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTDISP), 0, &rVariant));

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AttachFile
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachFile(LPCSTR pszFilePath, IStream *pstmFile, LPHBODY phBody)
{
    LPWSTR  pwszFilePath;
    HRESULT hr = S_OK;

    IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, pszFilePath));

    IF_FAILEXIT(hr = AttachFileW(pwszFilePath, pstmFile, phBody));

exit:
    MemFree(pwszFilePath);

    return hr;
}

STDMETHODIMP CMessageTree::AttachFileW(LPCWSTR pszFilePath, IStream *pstmFile, LPHBODY phBody)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmTemp=NULL;
    LPWSTR      pszCntType=NULL,
                pszSubType=NULL,
                pszFName=NULL;
    HBODY       hBody;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Did the user give me a file stream
    if (NULL == pstmFile)
    {
        // Get File Stream
        CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFilePath, OPEN_EXISTING, GENERIC_READ, &pstmTemp));

        // Set The File Stream
        pstmFile = pstmTemp;
    }

    // Attach as object
    CHECKHR(hr = AttachObject(IID_IStream, (LPVOID)pstmFile, &hBody));

    // Get mime file info
    hr = MimeOleGetFileInfoW((LPWSTR)pszFilePath, &pszCntType, &pszSubType, NULL, &pszFName, NULL);

    // Failure
    if (FAILED(hr) && NULL == pszFName)
    {
        Assert(FALSE);
        hr = TrapError(hr);
        goto exit;
    }

    // Success
    hr = S_OK;

    // Attachment FileName
    if (pszFName)
    {
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszFName;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_FILENAME), 0, &rVariant));
    }

    // ContentType
    if (pszCntType && pszSubType)
    {
        // PriType
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszCntType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_PRITYPE), 0, &rVariant));

        // SubType
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszSubType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_SUBTYPE), 0, &rVariant));
    }

    // Otherwise, default content type
    else
    {
        // Default to text/plain
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    ReleaseObj(pstmTemp);
    MemFree(pszCntType);
    MemFree(pszSubType);
    MemFree(pszFName);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    LPHBODY     prghBody=NULL;
    ULONG       cAlloc=0;
    ULONG       cCount=0;
    ULONG       i;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Setup Variant
    rVariant.vt = VT_UI4;

    // Walk through the tree and look for unrendered bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Better have it
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Not a multipart
        if (_IsMultiPart(m_rTree.prgpNode[i]))
            continue;

        // Raid-44193: reply to multipart/digest message yields  text attachment
        if (m_rTree.prgpNode[i]->pBody->IsType(IBT_EMPTY) == S_OK)
            continue;

        // Raid-56665: We are showing tnef attachments again
        if (TRUE == m_rOptions.fHideTnef && S_OK == m_rTree.prgpNode[i]->pBody->IsContentType(STR_CNT_APPLICATION, STR_SUB_MSTNEF))
            continue;

        // an attachment shows up in the attachment well if it has NOT been rendered yet, OR it has been renderd but was auto inlined
        // eg: if (!r || a) (as a implies r)

        if ( (!(m_rTree.prgpNode[i]->pContainer->GetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant) == S_OK && TRUE == rVariant.ulVal)) ||
             (m_rTree.prgpNode[i]->pContainer->GetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)==S_OK && TRUE == rVariant.ulVal))
        {
            // Realloc
            if (cCount + 1 > cAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&prghBody, sizeof(HBODY) * (cAlloc + 10)));

                // Increment cAlloc
                cAlloc += 10;
            }

            // Insert the hBody
            prghBody[cCount] = m_rTree.prgpNode[i]->hBody;

            // Increment Count
            cCount++;
        }
    }

    // Done
    *pcAttach = cCount;

    // Return hBody Array
    if (pprghAttach)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }


exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#if 0
// --------------------------------------------------------------------------------
// CMessageTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cBodies;
    LPHBODY     prghBody=NULL;
    HBODY       hRoot;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Count the number of items in the tree
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // No Data
    if (0 == cBodies)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // Get the root body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // Allocate an array that can old the handle to all text items
    CHECKALLOC(prghBody = (LPHBODY)g_pMalloc->Alloc(sizeof(HBODY) * cBodies));

    // Zero Init
    ZeroMemory(prghBody, sizeof(HBODY) * cBodies);

    // Get Content
    CHECKHR(hr = _HrEnumeratAttachments(hRoot, pcAttach, prghBody));

    // Return this array
    if (pprghAttach && *pcAttach > 0)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }

exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrEnumeratAttachments
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrEnumeratAttachments(HBODY hBody, ULONG *pcBodies, LPHBODY prghBody)
{
    // Locals
    HRESULT     hr=S_OK,
                hrFind;
    HBODY       hChild;
    ULONG       i;

    // multipart/alternative
    if (IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Is Alternative
        if (IsContentType(hBody, NULL, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Get First Child
            hrFind = GetBody(IBL_FIRST, hBody, &hChild);
            while(SUCCEEDED(hrFind) && NULL != hChild)
            {
                // If this text type is support by the client, then 
                for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
                {
                    // text/XXXX
                    if (IsContentType(hChild, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                        goto exit;
                }

                // Next Child
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }
        }

        // Get First Child
        hrFind = GetBody(IBL_FIRST, hBody, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Bind the body table for this dude
            CHECKHR(hr = _HrEnumeratAttachments(hChild, pcBodies, prghBody));

            // Next Child
            hrFind = GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Otherwise, is it an attachment
    else if (IsBodyType(hBody, IBT_ATTACHMENT) == S_OK)
    {
        // Insert as an attachment
        prghBody[(*pcBodies)] = hBody;
        (*pcBodies)++;
    }

exit:
    // Done
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// CMessageTree::AttachURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachURL(LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, 
    IStream *pstmURL, LPSTR *ppszCIDURL, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    HBODY             hRoot,
                      hBody=NULL,
                      hSection;
    CHAR              szCID[CCHMAX_CID];
    LPSTR             pszFree=NULL;
    LPSTR             pszBaseFree=NULL;
    IMimeBody        *pBody=NULL;
    LPWSTR            pwszUrl=NULL;
    IMimeWebDocument *pWebDocument=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the Root Body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // multipart/mixed
    if (ISFLAGSET(dwFlags, URL_ATTACH_INTO_MIXED))
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
    }

    // multipart/related
    else
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetRelatedSection(this, TRUE, &hSection, NULL));
    }

    // Get Default Base
    if (NULL == pszBase && SUCCEEDED(MimeOleComputeContentBase(this, hSection, &pszBaseFree, NULL)))
        pszBase = pszBaseFree;

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hBody));

    // Bind to IMimeBody
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If I have a stream
    if (pstmURL)
    {
        // Set the data
        CHECKHR(hr = pBody->SetData(IET_INETCSET, NULL, NULL, IID_IStream, (LPVOID)pstmURL));
    }

    // Otherwise, Set the content type
    else
    {
        // Create a WebDocument
        CHECKHR(hr = MimeOleCreateWebDocument(pszBase, pszURL, &pWebDocument));

        // Set Web Document on the body object
        CHECKHR(hr = pBody->SetData(IET_BINARY, NULL, NULL, IID_IMimeWebDocument, (LPVOID)pWebDocument));
    }

    // URL_ATTACH_SET_CNTTYPE
    if (ISFLAGSET(dwFlags, URL_ATTACH_SET_CNTTYPE))
    {
        // Locals
        LPSTR pszCntType=(LPSTR)STR_MIME_APPL_STREAM;
        PROPVARIANT rVariant;

        // Get the Content Type from the Url
        if (SUCCEEDED(MimeOleContentTypeFromUrl(pszBase, pszURL, &pszFree)))
            pszCntType = pszFree;

        // Setup the Variant
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszCntType;

        // Set the Content Type
        CHECKHR(hr = pBody->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Set Content-Base
    if (pszBase && pszBase != pszBaseFree)
    {
        // Set Base
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTBASE), 0, pszBase));
    }

    // User Wants a CID: URL Back
    if (ISFLAGSET(dwFlags, URL_ATTACH_GENERATE_CID))
    {
        // Generate CID
        CHECKHR(hr = MimeOleGenerateCID(szCID, CCHMAX_CID, FALSE));

        // Set the Body Property
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTID), 0, szCID));

        // User Wants CID Back...
        if (ppszCIDURL)
            {
            DWORD cchSize = (lstrlen(szCID) + 5);
            CHECKALLOC(MemAlloc((LPVOID *)ppszCIDURL, cchSize));
            StrCpyN(*ppszCIDURL, "cid:", cchSize);
            StrCatBuff(*ppszCIDURL, szCID, cchSize);
            }
    }
    else
    {
        if (pszURL)
            // Setup Content-Location
            CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTLOC), 0, pszURL));
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszBaseFree);
    SafeMemFree(pwszUrl);
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CMessageTree::AttachURLW(LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, 
    IStream *pstmURL, LPWSTR *ppwszCIDURL, LPHBODY phBody)
{
    return TraceResult(E_NOTIMPL);
}

STDMETHODIMP CMessageTree::ResolveURLW(HBODY hRelated, LPCWSTR pwszBase, LPCWSTR pwszURL, 
                                       DWORD dwFlags, LPHBODY phBody)
{
    return TraceResult(E_NOTIMPL);
}



// --------------------------------------------------------------------------------
// CMessageTree::SplitMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SplitMessage(ULONG cbMaxPart, IMimeMessageParts **ppParts)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = MimeOleSplitMessage(this, cbMaxPart, ppParts);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::EnumFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFormat=0;
    DATAOBJINFO     rgFormat[CFORMATS_IDATAOBJECT];
    ULONG           cBodies;
    IEnumFORMATETC *pEnum=NULL;
    DWORD           dwFlags;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);
    if (DATADIR_SET == dwDirection)
        return TrapError(E_NOTIMPL);
    else if (DATADIR_GET != dwDirection)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // No Data...
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // If there are bodies...
    if (cBodies)
    {
        // I can always give CF_INETMSG now...
        SETDefFormatEtc(rgFormat[cFormat].fe, CF_INETMSG, TYMED_ISTREAM |  TYMED_HGLOBAL);
        cFormat++;

        // Get Some Flags
        dwFlags = DwGetFlags();

        // Get the HTML body stream
        if (ISFLAGSET(dwFlags, IMF_HTML))
        {
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_HTML, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }

        // Get the TEXT body stream
        if (ISFLAGSET(dwFlags, IMF_PLAIN))
        {
            // Unicode Text
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_UNICODETEXT, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;

            // Plain Text
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_TEXT, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }
    }

    // Create the enumerator
    CHECKHR(hr = CreateEnumFormatEtc(GetInner(), cFormat, rgFormat, NULL, &pEnum));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();
    
exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetCanonicalFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCanonicalFormatEtc(FORMATETC *pFormatIn, FORMATETC *pFormatOut)
{
    // E_INVALIDARG
    if (NULL == pFormatOut)
        return E_INVALIDARG;

    // Target device independent
    pFormatOut->ptd = NULL;

    // Done
    return DATA_S_SAMEFORMATETC;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetData(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    BOOL            fFreeGlobal=FALSE;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // Use a fast IStream
        if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;
        pMedium->pstm = pstmData;
        pstmData->AddRef();
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        fFreeGlobal = TRUE;

        // don't have the stream release the global
        if (FAILED(CreateStreamOnHGlobal(NULL, FALSE, &pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }
        
        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Create HGLOBAL from stream
        if (FAILED(GetHGlobalFromStream(pstmData, &pMedium->hGlobal)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;
        // Release the strema
        pstmData->Release();
        pstmData = NULL;
        fFreeGlobal = FALSE;
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    if (pstmData)
    {
        if (fFreeGlobal)
        {
            // we may fail had have to free the hglobal
            HGLOBAL hGlobal;

            // Free the underlying HGLOBAL
            if (SUCCEEDED(GetHGlobalFromStream(pstmData, &hGlobal)))
                GlobalFree(hGlobal);
        }

        // Release the Stream
        pstmData->Release();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetDataHere
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetDataHere(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    ULONG           cb;
    LPVOID          pv=NULL;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // No dest stream...
        if (NULL == pMedium->pstm)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;

        // Get the data
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pMedium->pstm));
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        // No dest stream...
        if (NULL == pMedium->hGlobal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;

        // Create a place to store the data
        if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData));

        // Get Size
        CHECKHR(hr = HrGetStreamSize(pstmData, &cb));

        // Is it big enought ?
        if (cb > GlobalSize(pMedium->hGlobal))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Lock the hglobal
        pv = GlobalLock(pMedium->hGlobal);
        if (NULL == pv)
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Copy the Data
        CHECKHR(hr = HrCopyStreamToByte(pstmData, (LPBYTE)pv, NULL));

        // Unlock it
        GlobalUnlock(pMedium->hGlobal);
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pstmData);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectWriteHeaderA
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectWriteHeaderA(LPSTREAM pStream, UINT idsHeader, LPSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_STRINGRES];

    // Invalid Arg
    Assert(idsHeader && pStream && pszData);

    // Load Localized Header Name
    LoadString(g_hLocRes, idsHeader, szRes, ARRAYSIZE(szRes));

    // Write Header Name
    CHECKHR(hr = pStream->Write(szRes, lstrlen(szRes), NULL));

    // Write space
    CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pszData, lstrlen(pszData), NULL));

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetHeaderA
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetHeaderA(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;

    // Init
    MimeOleVariantInit(&rVariant);

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_FROM, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_TO), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_TO, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CC), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_CC, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_SUBJECT, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_FILETIME;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
    {
        // Locals
        CHAR szDate[CCHMAX_STRINGRES];

        // Convert to user friendly date format
        CchFileTimeToDateTimeSz(&rVariant.filetime, szDate, ARRAYSIZE(szDate), DTM_NOSECONDS | DTM_LONGDATE);

        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_DATE, szDate));
    }

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectWriteHeaderW
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectWriteHeaderW(LPSTREAM pStream, UINT idsHeader, LPWSTR pwszData)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_STRINGRES];
    LPWSTR          pwszRes=NULL;

    // Invalid Arg
    Assert(idsHeader && pStream && pwszData);

    // Load Localized Header Name
    LoadString(g_hLocRes, idsHeader, szRes, ARRAYSIZE(szRes));

    // Convert to Unicode
    IF_NULLEXIT(pwszRes = PszToUnicode(CP_ACP, szRes));

    // Write Header Name
    CHECKHR(hr = pStream->Write(pwszRes, (lstrlenW(pwszRes) * sizeof(WCHAR)), NULL));

    // Write space
    CHECKHR(hr = pStream->Write(L": ", (lstrlenW(L": ") * sizeof(WCHAR)), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pwszData, (lstrlenW(pwszData) * sizeof(WCHAR)), NULL));

    // Final CRLF
    CHECKHR(hr = pStream->Write(L"\r\n", (lstrlenW(L"\r\n") * sizeof(WCHAR)), NULL));

exit:
    // Cleanup
    SafeMemFree(pwszRes);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetHeaderW
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetHeaderW(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszDate=NULL;
    PROPVARIANT     rVariant;

    // Init
    MimeOleVariantInit(&rVariant);

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_FROM, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_TO), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_TO, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CC), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_CC, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_SUBJECT, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_FILETIME;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
    {
        // Locals
        WCHAR  wszDate[CCHMAX_STRINGRES];

        // Convert to user friendly date format
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS | DTM_LONGDATE);

        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_DATE, wszDate));
    }

    // Final CRLF
    CHECKHR(hr = pStream->Write(L"\r\n", (lstrlenW(L"\r\n") * sizeof(WCHAR)), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetSource
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetSource(CLIPFORMAT cfFormat, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmSrc=NULL;

    // Invalid Arg
    Assert(pStream);

    // text body
    if (CF_TEXT == cfFormat || CF_UNICODETEXT == cfFormat)
    {
        // Get Plain Text Source
        CHECKHR(hr = GetTextBody(TXT_PLAIN, (cfFormat == CF_UNICODETEXT) ? IET_UNICODE : IET_BINARY, &pstmSrc, NULL));
    }

    // HTML Body
    else if (CF_HTML == cfFormat)
    {
        // Get HTML Text Source
        CHECKHR(hr = GetTextBody(TXT_HTML, IET_INETCSET, &pstmSrc, NULL));
    }

    // Raw Message Stream
    else if (CF_INETMSG == cfFormat)
    {
        // Get source
        CHECKHR(hr = GetMessageSource(&pstmSrc, COMMIT_ONLYIFDIRTY));
    }

    // Format not handled
    else
    {
        hr = DV_E_FORMATETC;
        goto exit;
    }

    // No Data
    if (NULL == pstmSrc)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Rewind Source
    CHECKHR(hr = HrRewindStream(pstmSrc));

    // If TEXT, put in friendly header
    if (CF_TEXT == cfFormat)
    {
        CHECKHR(hr = _HrDataObjectGetHeaderA(pStream));
    }

    // Otherwise, unicode
    else if (CF_UNICODETEXT == cfFormat)
    {
        CHECKHR(hr = _HrDataObjectGetHeaderW(pStream));
    }

    // Copy Source to destination
    CHECKHR(hr = HrCopyStream(pstmSrc, pStream, NULL));

    // Write a NULL
    if (CF_TEXT == cfFormat)
    {
        CHECKHR(hr = pStream->Write(c_szEmpty, 1, NULL));
    }

    // Otherwise, unicode
    else if (CF_UNICODETEXT == cfFormat)
    {
        CHECKHR(hr = pStream->Write(L"", 2, NULL));
    }

    // Commit
    CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

    // Rewind it
    CHECKHR(hr = HrRewindStream(pStream));

exit:
    // Cleanup
    SafeRelease(pstmSrc);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryGetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryGetData(FORMATETC *pFormat)
{
    // Invalid Arg
    if (NULL == pFormat)
        return TrapError(E_INVALIDARG);

    // Bad Medium
    if (!(TYMED_ISTREAM & pFormat->tymed) && !(TYMED_HGLOBAL & pFormat->tymed))
        return DV_E_TYMED;

    // Bad format
    if (CF_TEXT != pFormat->cfFormat && CF_HTML != pFormat->cfFormat &&
        CF_UNICODETEXT  != pFormat->cfFormat && CF_INETMSG != pFormat->cfFormat)
        return DV_E_FORMATETC;

    // Success
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnStartBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnStartBinding(DWORD dwReserved, IBinding *pBinding)
{
    // Locals
    HBODY hBody;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // I Should not have a current binding
    Assert(NULL == m_pBinding);

    // Remove Bind Finished Flag
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // Assume the Binding
    if (pBinding)
    {
        // Assume It
        m_pBinding = pBinding;
        m_pBinding->AddRef();
    }

    // Get the Root Body
    Assert(m_pRootNode);

    // Current Bind Result
    m_hrBind = S_OK;

    // Bind to that object
    m_pBindNode = m_pRootNode;

    // Set Bound Start
    m_pBindNode->boundary = BOUNDARY_ROOT;

    // Set Node Bind State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetPriority
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetPriority(LONG *plPriority)
{
    // Normal Priority
    *plPriority = THREAD_PRIORITY_NORMAL;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnLowResource
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnLowResource(DWORD reserved)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a binding operation, try to abort it
    if (m_pBinding)
        m_pBinding->Abort();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText)
{
    // Debuging
    //DebugTrace("CMessageTree::OnProgress - %d of %d Bytes\n", ulProgress, ulProgressMax);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnStopBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnStopBinding(HRESULT hrResult, LPCWSTR pszError)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release the Binding Object
    SafeRelease(m_pBinding);

    // Bind Finished
    FLAGSET(m_dwState, TREESTATE_BINDDONE);

    // Nuke the no cache flag....
    FLAGCLEAR(m_dwState, TREESTATE_RESYNCHRONIZE);

    // No m_pInternet Object ?
    if (NULL == m_pInternet)
    {
        m_hrBind = TrapError(E_FAIL);
        goto exit;
    }

    // It must be fully available
    m_pInternet->SetFullyAvailable(TRUE);

    // Make sure we have read all the way to the end of the stream
    m_pInternet->HrReadToEnd();

    // Keep Saving Total
    m_cbMessage = m_pInternet->DwGetOffset();

#ifdef DEBUG
    STATSTG rStat;
    SideAssert(SUCCEEDED(m_pStmLock->Stat(&rStat, STATFLAG_NONAME)));
    if (rStat.cbSize.QuadPart != m_cbMessage)
        DebugTrace("CMessageTree Size Difference m_pStmLock::Stat = %d, m_cbMessage = %d\n", rStat.cbSize.QuadPart, m_cbMessage);
#endif

    // Terminate current parsing state
    if (m_pBindNode)
    {
        // Set Error
        if (SUCCEEDED(m_hrBind))
            m_hrBind = TrapError(E_FAIL);

        // Mark remaining bodies as incomplete
        while(m_pBindNode)
        {
            // Must not be complete
            FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

            // Must not have found the end
            Assert(0 == m_pBindNode->cbBodyEnd);

            // cbBodyEnd
            m_pBindNode->cbBodyEnd = m_cbMessage;

            // Pop the stack
            m_pBindNode = m_pBindNode->pBindParent;
        }
    }

    // Check hrResult
    if (FAILED(hrResult) && SUCCEEDED(m_hrBind))
        m_hrBind = hrResult;

    // DispatchBindRequest
    _HrProcessPendingUrlRequests();

    // Tell the webpage that we are done
    if (m_pWebPage)
    {
        m_pWebPage->OnBindComplete(this);
        m_pWebPage->Release();
        m_pWebPage = NULL;
    }

    // Bind Node Better be Null
    m_pBindNode = NULL;

    // Release the Internet Stream Object
    SafeRelease(m_pInternet);

    // If we have a bind stream...
    if (m_pStmBind)
    {
#ifdef DEBUG
        // m_pStmBind->DebugDumpDestStream("d:\\binddst.txt");
#endif
        // Get hands off source
        m_pStmBind->HandsOffSource();

        // Release, m_pStmLock should still have this object
        SideAssert(m_pStmBind->Release() > 0);

        // Don't release it again
        m_pStmBind = NULL;
    }

    // HandleCanInlineTextOption
    _HandleCanInlineTextOption();

exit:
    if (m_pBC)
        {
        // we only regiser our own bscb is m_pbc is set
        RevokeBindStatusCallback(m_pBC, (IBindStatusCallback *)this);
        SafeRelease(m_pBC);
        }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return m_hrBind;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBindInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBindInfo(DWORD *grfBINDF, BINDINFO *pBindInfo)
{
    // Setup the BindInfo
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;

    // No CACHE?
    if (ISFLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE))
    {
        // Don't load from cache
        FLAGSET(*grfBINDF, BINDF_RESYNCHRONIZE);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrInitializeStorage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrInitializeStorage(IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwOffset;

    // Invalid Arg
    Assert(pStream && NULL == m_pInternet && NULL == m_pStmLock && NULL == m_pStmBind);

    // TREESTATE_BINDUSEFILE
    if (ISFLAGSET(m_dwState, TREESTATE_BINDUSEFILE))
    {
        // Create a Binding Stream
        CHECKALLOC(m_pStmBind = new CBindStream(pStream));

        // Set pStmSource
        pStream = (IStream *)m_pStmBind;
    }

    // $$BUGBUG$$ Urlmon fails on getting the current position of a stream
    if (FAILED(HrGetStreamPos(pStream, &dwOffset)))
        dwOffset = 0;

    // Create a ILockBytes
    CHECKALLOC(m_pStmLock = new CStreamLockBytes(pStream));

    // Create a Text Stream
    CHECKALLOC(m_pInternet = new CInternetStream);

    // Initialize the TextStream
    m_pInternet->InitNew(dwOffset, m_pStmLock);

exit:
    // Failure
    if (FAILED(hr))
    {
        SafeRelease(m_pStmLock);
        SafeRelease(m_pInternet);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnDataAvailable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;

    // No Storage Medium
    if (NULL == pMedium || TYMED_ISTREAM != pMedium->tymed || NULL == pMedium->pstm)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Trace
    // DebugTrace("CMessageTree::OnDataAvailable - Nodes=%d, m_pBindNode=%0x, dwSize = %d\n", m_rTree.cNodes, m_pBindNode, dwSize);

    // Do I have an internal lock bytes yet ?
    if (NULL == m_pStmLock)
    {
        // InitializeStorage
        CHECKHR(hr = _HrInitializeStorage(pMedium->pstm));

        // Assume not fully available
        if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
            m_pInternet->SetFullyAvailable(TRUE);
        else
            m_pInternet->SetFullyAvailable(FALSE);
    }

    // Done downloading the data
    else if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
        m_pInternet->SetFullyAvailable(TRUE);

    // If we are in a failed read state
    if (SUCCEEDED(m_hrBind))
    {
        // State Pumper
        while(m_pBindNode)
        {
            // Execute current - could return E_PENDING
            hr = ((this->*m_rgBindStates[m_pBindNode->bindstate])());

            // Failure
            if (FAILED(hr))
            {
                // E_PENDING
                if (E_PENDING == hr)
                    goto exit;

                // Otherwise, set m_hrBind
                m_hrBind = hr;

                // Done
                break;
            }
        }
    }

    // If m_hrBind has failed, read until endof stream
    if (FAILED(m_hrBind))
    {
        // Read to the end of the internet stream
        CHECKHR(hr = m_pInternet->HrReadToEnd());
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindParsingHeader
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindParsingHeader(void)
{
    // Locals
    HRESULT     hr=S_OK;
    MIMEVARIANT rVariant;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_PARSING_HEADER, FALSE);

    // Load the Current Body with the header
    CHECKHR(hr = m_pBindNode->pContainer->Load(m_pInternet));

    // End of the Header
    m_pBindNode->cbBodyStart = m_pInternet->DwGetOffset();

    // Multipart ?
    if (_IsMultiPart(m_pBindNode))
    {
        // Setup the variant
        rVariant.type = MVT_STRINGA;

        // Get the boundary String
        hr = m_pBindNode->pContainer->GetProp(SYM_PAR_BOUNDARY, 0, &rVariant);

        // Raid-63150: Athena version 1 MSN issue:  unable to download messages from SCSPromo
        if (FAILED(hr))
        {
            // Incomplete Body
            FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

            // Convert to a text part only if we read more than two bytes from body start
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);

            // Boundary Mismatch
            hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

            // Done
            goto exit;
        }

        // Set PropStringA
        m_pBindNode->rBoundary.pszVal = rVariant.rStringA.pszVal;
        m_pBindNode->rBoundary.cchVal = rVariant.rStringA.cchVal;

        // Free this boundary later
        FLAGCLEAR(m_pBindNode->dwState, NODESTATE_BOUNDNOFREE);

        // Modify Bind Parser State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }

    // Otherwise
    else
    {
        // Message In a Message
        if (m_pBindNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
        {
            // We are parsing a message attachment
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // Otherwise, if parent and parent is a multipart/digest
        else if (m_pBindNode->pParent && m_pBindNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK &&
                 m_pBindNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTTYPE)) == S_FALSE)
        {
            // Change the Content Type
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822);

            // This is a message
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // If parsing a body inside of a parent multipart section
        if (m_pBindNode->pParent && !ISFLAGSET(m_pBindNode->pParent->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Find Next Mime Part
            m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;
        }

        // Otherwise, Reading Body and Looking for a uuencode begin boundary
        else
        {
            // Parse the RFC1154 header
            _DecodeRfc1154();

            if (m_pBT1154)
            {
                HBODY hBody;

                // This is an RFC1154 message.  We convert the root node
                // to a multi-part, and create a new node for the first
                // of the body parts.
                Assert(m_pBindNode == m_pRootNode);
                m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
                m_pBindNode->cbBodyEnd = m_pBindNode->cbBodyStart;
                FLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART);
                FLAGSET(m_pBindNode->dwType, NODETYPE_RFC1154_ROOT);
                CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));
                CHECKHR(hr = InsertBody(IBL_LAST,m_pBindNode->hBody,&hBody));
                m_pBindNode = _PNodeFromHBody(hBody);
                m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
            }
            else
            {
                // Search for nested uuencoded block of data
                m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrOnFoundNodeEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrOnFoundNodeEnd(DWORD cbBoundaryStart, HRESULT hrBind /* =S_OK */)
{
    // Locals
    HRESULT hr =S_OK;

    // Compute the real body end
    if (cbBoundaryStart < 2 || cbBoundaryStart == m_pBindNode->cbBodyStart)
        m_pBindNode->cbBodyEnd = m_pBindNode->cbBodyStart;
    else
        m_pBindNode->cbBodyEnd = cbBoundaryStart - 2;

    // This node is finished binding
    CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, hrBind));

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrOnFoundMultipartEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrOnFoundMultipartEnd(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Set m_pBindNode which is a multipart, end
    m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

    // This node is finished binding
    CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

    // Finished with the multipart, pop it off the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // If I still have a bind node, it should now be looking for a mime first boundary
    if (m_pBindNode)
    {
        // New Bind State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingMimeFirst
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingMimeFirst(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMEFIRST, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Is MimeBoundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // BOUNDARY_MIMENEXT
    if (BOUNDARY_MIMENEXT == boundary)
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

    // RAID-38241: Mail:  some attached files not getting parsed from Communicator to OE
    // RAID-31255: multipart/mixed with single child which is multipart/alternative
    else if (BOUNDARY_MIMEEND == boundary)
    {
        // Finished with a multipart
        if (_IsMultiPart(m_pBindNode))
        {
            // Done
            CHECKHR(hr = _HrOnFoundMultipartEnd());
        }

        // Found end of current node
        else
        {
            // Done
            CHECKHR(hr = _HrOnFoundNodeEnd(cbBoundaryStart));
        }
    }

    else
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Get Offset
        DWORD dwOffset = m_pInternet->DwGetOffset();

        // Convert to a text part only if we read more than two bytes from body start
        if (dwOffset > m_pBindNode->cbBodyStart && dwOffset - m_pBindNode->cbBodyStart > 2)
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _HrOnFoundNodeEnd(dwOffset, hr);

        // Done
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrMultipartMimeNext
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrMultipartMimeNext(DWORD cbBoundaryStart)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody;
    LPTREENODEINFO  pChild;

    // Get the Root Body
    CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

    // Bind to that object
    pChild = _PNodeFromHBody(hBody);

    // Align the stack correctly
    pChild->pBindParent = m_pBindNode;

    // Setup Offset Information
    pChild->boundary = BOUNDARY_MIMENEXT;
    pChild->cbBoundaryStart = cbBoundaryStart;
    pChild->cbHeaderStart = m_pInternet->DwGetOffset();

    // Assume the Boundary
    pChild->rBoundary.pszVal = m_pBindNode->rBoundary.pszVal;
    pChild->rBoundary.cchVal = m_pBindNode->rBoundary.cchVal;

    // Don't Free this string...
    FLAGSET(pChild->dwState, NODESTATE_BOUNDNOFREE);

    // New State for parent
    m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;

    // Set New Current Node
    m_pBindNode = pChild;

    // Change State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingMimeNext
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingMimeNext(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMENEXT, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Next or Ending Mime Boundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // Not found
    if (BOUNDARY_NONE == boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _HrOnFoundNodeEnd(m_pInternet->DwGetOffset(), hr);

        // Done
        goto exit;
    }

    // Compute Ending Offset
    CHECKHR(hr = _HrOnFoundNodeEnd(cbBoundaryStart));
   
    // If BOUNDARY_MIMEEND
    if (BOUNDARY_MIMEEND == boundary)
    {
        // OnFoundMultipartEnd
        CHECKHR(hr = _HrOnFoundMultipartEnd());
    }

    // BOUNDARY_MIMENEXT
    else
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// _FIsUuencodeEnd
// --------------------------------------------------------------------------------
BOOL _FIsUuencodeEnd(LPCSTR pszVal)
{

    // UU Encode End
    if (StrCmpN(pszVal, "end", 3) == 0)
    {

        // Skip the first three chars
        pszVal += 3;

        // Make sure there is only space after the word end
        while (*pszVal)
        {
            // LWSP or CRLF
            if (' ' != *pszVal && '\t' != *pszVal && chCR != *pszVal && chLF != *pszVal)
            {
                // Oops, this isn't the end
                return (FALSE);

                // Done
                break;
            }

            // Next Char
            pszVal++;
        }
        return (TRUE);
    }
    return (FALSE);
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindRfc1154
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindRfc1154(void)
{
    static CHAR szBINHEXSTART[] = "(This file must be converted with BinHex";
    HRESULT         hr=S_OK;
    ULONG           cbThisLine;
    PROPSTRINGA     rLine;
    BT1154BODY     *pCurrBody;
    ULONG           cbLastLine=0;

    BINDASSERTARGS(BINDSTATE_PARSING_RFC1154, FALSE);
    Assert(m_pBT1154 != NULL);
    Assert(m_pBT1154->cBodies > m_pBT1154->cCurrentBody);

    pCurrBody = &m_pBT1154->aBody[m_pBT1154->cCurrentBody];
    Assert((BT1154ENC_MINIMUM <= pCurrBody->encEncoding) &&
           (BT1154ENC_MAXIMUM >= pCurrBody->encEncoding));

    // Sit and Spin
    while (1)
    {
        // Get the current offset, and read a line
        cbThisLine = m_pInternet->DwGetOffset();
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        if (0 == m_pBT1154->cCurrentLine)
        {
            // This is the first line in the body.
            m_pBindNode->cbBoundaryStart = cbThisLine;
            m_pBindNode->cbHeaderStart = cbThisLine;
            switch (pCurrBody->encEncoding)
            {
                case BT1154ENC_TEXT:
                    // For a TEXT body, the "body start" and the "boundary start"
                    // are the same thing.
                    m_pBindNode->cbBodyStart = cbThisLine;
                    m_pBindNode->boundary = BOUNDARY_NONE;
                    _HrComputeDefaultContent(m_pBindNode,NULL);
                    break;

                case BT1154ENC_UUENCODE:
                    // This is UUENCODE - we won't know the "content type" until we
                    // see the filename.
                    m_pBindNode->boundary = BOUNDARY_UUBEGIN;
                    break;

                case BT1154ENC_BINHEX:
                    // For a BINHEX body, we set the "body start" and "boundary start"
                    // to the same thing - the "body start" will be set forward later
                    // if we see the BINHEX start line.  We set the "content disposition"
                    // to "attachment", the "content type" to be "application/mac-binhex40",
                    // and HrBindNodeComplete will end up setting the "content transfer
                    // encoding" to "mac-binhex40".
                    m_pBindNode->cbBodyStart = cbThisLine;
                    m_pBindNode->boundary = BOUNDARY_NONE;
                    FLAGSET(m_pBindNode->dwType,NODETYPE_RFC1154_BINHEX);
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), STR_CNT_APPLICATION));
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), STR_SUB_BINHEX));
                    break;

                default:
                    AssertSz(FALSE,"Unknown encoding type.");
                    break;
            }
        }

        if (0 == rLine.cchVal)
        {
            // Zero bytes read, we're done
            if ((pCurrBody->cLines != 0xffffffff) &&
                (m_pBT1154->cCurrentLine+1 <= pCurrBody->cLines))
            {
                // We weren't in the special "read as many lines as
                // we can" state, and we haven't consumed all of
                // the lines yet for this body part.  So, we need to
                // go into the "There were parsing errors" state.
                m_pBT1154->hrLoadResult = MIME_E_NO_DATA;
            }
            break;
        }

        if (m_pBT1154->cCurrentLine == pCurrBody->cLines)
        {
            // We have just read the line past the end
            // of the body.  Let's remember this spot...
            cbLastLine = cbThisLine;
        }

        m_pBT1154->cCurrentLine++;

        if (m_pBT1154->cCurrentLine > pCurrBody->cLines)
        {
            // We are reading lines past the end of a body part.

            if ((rLine.cchVal != 2) || (rLine.pszVal[0] != '\r') || (rLine.pszVal[1] != '\n'))
            {
                // All of the lines past the end of a body part (i.e. lines that are
                // either between body parts, or at the end of the message) should be
                // blank - and this one isn't.  Since it isn't, we go into the "There
                // were parsing errors" state.
                m_pBT1154->hrLoadResult = MIME_E_NO_MULTIPART_BOUNDARY;
            }

            if (m_pBT1154->cCurrentBody+1 < m_pBT1154->cBodies)
            {
                // We are *between* body parts, which means we just
                // consumed the single (blank) line which is between
                // them.  So we break out so we can add this body part
                // and move on to the next one.
                break;
            }

            // If we get to this point, it means that we are consuming the
            // (blank) lines which are beyond the end of the last body
            // part.  We continue consuming all of those lines until they
            // are gone.  If any of them were non-blank, then we will have
            // set the m_pBT1154->hrLoadResult member to MIME_E_NO_MULTIPART_BOUNDARY
            // (above).
            Assert(m_pBT1154->cCurrentBody+1 == m_pBT1154->cBodies);
        }
        else if (BT1154ENC_UUENCODE == pCurrBody->encEncoding)
        {
            // This is an else-if clause because we never look for the UUENCODE
            // begin and end keywords past the end of the body part.
            LPSTR pszFileName = NULL;

            // We are dealing with UUENCODE.
            if ((0 == m_pBindNode->cbBodyStart) && _FIsUuencodeBegin(&rLine, &pszFileName))
            {
                // We are looking for the start of UUENCODE - and this is it!  We set
                // the boundary start to be at the begin marker, and the body start to be
                // *after* the begin marker.
                m_pBindNode->cbBoundaryStart = cbThisLine;
                m_pBindNode->cbHeaderStart = cbThisLine;
                m_pBindNode->cbBodyStart = m_pInternet->DwGetOffset();
                _HrComputeDefaultContent(m_pBindNode, pszFileName);
                SafeMemFree(pszFileName);
            }
            else if ((0 != m_pBindNode->cbBodyStart) &&
                     (0 == m_pBindNode->cbBodyEnd) &&
                     _FIsUuencodeEnd(rLine.pszVal))
            {
                // We are looking for the end of UUENCODE - and this is it!  We set
                // the body end to be *before* the end marker.
                m_pBindNode->cbBodyEnd = cbThisLine;

                // We *don't* break out - we keep reading until we've consumed all
                // of the lines for this body.
            }
        }
        else if (BT1154ENC_BINHEX == pCurrBody->encEncoding)
        {
            // This is an else-if clause because we never look for the BINHEX
            // start line past the end of the body part.
            if (m_pBindNode->cbBodyStart == m_pBindNode->cbBoundaryStart)
            {
                // We haven't found the BINHEX start line yet.
                if (StrCmpNI(szBINHEXSTART,rLine.pszVal,sizeof(szBINHEXSTART)-1) == 0)
                {
                    // And this is it!  So set the body start to this line.
                    m_pBindNode->cbBodyStart = cbThisLine;
                }
            }
        }
    }

    // We only get to this point when we are at the end of a body - either
    // by having consumed the correct number of lines (plus the blank line
    // between bodies), or by having run off the end of the message.
    Assert((0 == rLine.cchVal) || (m_pBT1154->cCurrentLine == pCurrBody->cLines+1));

    // The only way we should have set the body end is if we are UUENCODE.
    Assert((BT1154ENC_UUENCODE == pCurrBody->encEncoding) || (0 == m_pBindNode->cbBodyEnd));

    if (0 == m_pBindNode->cbBodyEnd)
    {
        // We are either a TEXT or BINHEX body, or we are a UUENCODE and we
        // didn't find the end.

        if (BT1154ENC_UUENCODE == pCurrBody->encEncoding)
        {
            // We are doing UUENCODE, and we haven't seen the end keyword (and
            // maybe not even the begin keyword).  So we go into the "There
            // were parsing errors" state.
            if (0 == m_pBindNode->cbBodyStart)
            {
                // We haven't seen the begin keyword - so set the
                // body start to be the same as the boundary start.
                m_pBindNode->cbBodyStart = m_pBindNode->cbBoundaryStart;
            }
            m_pBT1154->hrLoadResult = MIME_E_BOUNDARY_MISMATCH;
        }

        // We need to set the body end...
        if (0 != cbLastLine)
        {
            // We found the "last line" above, so we set the
            // body end to that line.
            m_pBindNode->cbBodyEnd = cbLastLine;
        }
        else
        {
            // Since we didn't find the "last line" above, we set the
            // body end to this line.
            m_pBindNode->cbBodyEnd = cbThisLine;
        }
    }

    // We're done with this body part, so bind it.
    _HrBindNodeComplete(m_pBindNode, m_pBT1154->hrLoadResult);

    if (0 == rLine.cchVal)
    {
        // We have consumed the entire message - so clean everything up.

        // ****************************************************
        // NOTE - We set hr to the return value for the binding
        // operation.  Don't change hr between this point and
        // where we return.
        // ****************************************************

        m_pRootNode->cbBodyEnd = m_pInternet->DwGetOffset();
        _HrBindNodeComplete(m_pRootNode,S_OK);

        hr = m_pBT1154->hrLoadResult;

        SafeMemFree(m_pBT1154);
        m_pBindNode = NULL;
    }
    else
    {
        HBODY           hBody;

        // When we are processing the last body part, we consume all
        // of the lines after the last body part.  So, if we haven't
        // consumed the entire message, that means that we must have
        // some bodies left to process...
        Assert(m_pBT1154->cBodies > m_pBT1154->cCurrentBody+1);

        m_pBT1154->cCurrentBody++;
        m_pBT1154->cCurrentLine = 0;
        Assert(m_pBindNode != m_pRootNode);
        m_pBindNode = NULL;  // set this to NULL in case we get an error from InsertBody
        CHECKHR(hr = InsertBody(IBL_LAST, m_pRootNode->hBody, &hBody));
        m_pBindNode = _PNodeFromHBody(hBody);
        m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
    }

    // *********************************************************
    // NOTE - Don't change hr below this point.  See NOTE above.
    // *********************************************************

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingUuencodeBegin
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingUuencodeBegin(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;
    LPTREENODEINFO  pChild;
    LPSTR           pszFileName=NULL;
    HBODY           hBody;
    BOOL            fAddTextBody=FALSE;
    ULONG           cbTextBodyStart=0;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUBEGIN, FALSE);

    // Sit and Spin
    while(1)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // If not parsing a message
        if (!ISFLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE))
        {
            // Is uuencode begine line
            if (_FIsUuencodeBegin(&rLine, &pszFileName) == TRUE)
            {
                boundary = BOUNDARY_UUBEGIN;
                break;
            }
        }
    }

    // No Boundary
    if (BOUNDARY_NONE == boundary)
    {
        // Stuff after the last UUENCODED body must be appended as a text body
        if (m_pBindNode->pChildTail)
        {
            // De-ref Last Child
            pChild = m_pBindNode->pChildTail;

            // Artificial text body start
            cbTextBodyStart = pChild->cbBodyEnd;

            // AddTextBody ? lstrlen(end\r\n) = 5
            if (BOUNDARY_UUBEGIN == pChild->boundary && !ISFLAGSET(pChild->dwType, NODETYPE_INCOMPLETE))
                cbTextBodyStart += 5;

            // Space between last body end and boundary start is greater than sizeof(crlf)
            if (cbBoundaryStart > cbTextBodyStart && cbBoundaryStart - cbTextBodyStart > 2)
            {
                // Create Root Body Node
                CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

                // Bind to that object
                pChild = _PNodeFromHBody(hBody);

                // Fixup the STack
                pChild->pBindParent = m_pBindNode;

                // This body should assume the new text offsets
                CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));

                // Set Encoding
                CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

                // Set Offsets
                pChild->boundary = BOUNDARY_NONE;
                pChild->cbBoundaryStart = cbTextBodyStart;
                pChild->cbHeaderStart = cbTextBodyStart;
                pChild->cbBodyStart = cbTextBodyStart;
                pChild->cbBodyEnd = cbBoundaryStart;

                // This node is finished binding
                CHECKHR(hr = _HrBindNodeComplete(pChild, S_OK));
            }
        }

        // Body Offset Information
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

        // Pop the parsing Stack
        m_pBindNode = m_pBindNode->pBindParent;
    }

    // Otherwise, if we hit a uuencode boundary
    else
    {
        // If not a fake multipart yet...
        if (!ISFLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Its a faked multipart
            FLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART);

            // Free current content type
            CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));

            // Modify this dudes bound start
            Assert(m_pBindNode->boundary == BOUNDARY_ROOT);

            // Set the parse state
            m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
        }

        // ------------------------------------------------------------------------------------
        // \/ \/ \/ Raid 41599 - lost/munged attachments on forward/uuencode \/ \/ \/

        // If root node and body size is greater than sizeof(crlf)
        if (NULL == m_pBindNode->pChildTail && cbBoundaryStart - m_pBindNode->cbBodyStart > 2)
        {
            // Validate bind node
            Assert(m_pRootNode == m_pBindNode && m_pBindNode->cChildren == 0);

            // Set artificial text body start
            cbTextBodyStart = m_pBindNode->cbBodyStart;

            // Yes, add artificial text body
            fAddTextBody = TRUE;
        }

        // Otherwise, if last child parsed had an ending boundary of UUEND, and body size is greater than sizeof(crlf)
        else if (m_pBindNode->pChildTail)
        {
            // De-ref Last Child
            pChild = m_pBindNode->pChildTail;

            // Artificial text body start
            cbTextBodyStart = pChild->cbBodyEnd;

            // AddTextBody ? lstrlen(end\r\n) = 5
            if (BOUNDARY_UUBEGIN == pChild->boundary && !ISFLAGSET(pChild->dwType, NODETYPE_INCOMPLETE))
                cbTextBodyStart += 5;

            // Otherwise, what was the ending boundary
            else
                AssertSz(FALSE, "I should have only seen and uuencoded ending boundary.");

            // Space between last body end and boundary start is greater than sizeof(crlf)
            if (cbBoundaryStart > cbTextBodyStart && cbBoundaryStart - cbTextBodyStart > 2)
                fAddTextBody = TRUE;
        }

        // /\ /\ /\ Raid 41599 - lost/munged attachments on forward/uuencode /\ /\ /\
        // ------------------------------------------------------------------------------------

        // Create Root Body Node
        CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

        // Bind to that object
        pChild = _PNodeFromHBody(hBody);

        // Fixup the STack
        pChild->pBindParent = m_pBindNode;

        // Enough text to create a text/plain body ?
        if (fAddTextBody)
        {
            // This body should assume the new text offsets
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));

            // Set Encoding
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

            // Set Offsets
            pChild->boundary = BOUNDARY_NONE;
            pChild->cbBoundaryStart = cbTextBodyStart;
            pChild->cbHeaderStart = cbTextBodyStart;
            pChild->cbBodyStart = cbTextBodyStart;
            pChild->cbBodyEnd = cbBoundaryStart;

            // This node is finished binding
            CHECKHR(hr = _HrBindNodeComplete(pChild, S_OK));

            // Create Root Body Node
            CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

            // Bind to that object
            pChild = _PNodeFromHBody(hBody);

            // Fixup the STack
            pChild->pBindParent = m_pBindNode;
        }

        // Set Offsets
        pChild->boundary = BOUNDARY_UUBEGIN;
        pChild->cbBoundaryStart = cbBoundaryStart;
        pChild->cbHeaderStart = cbBoundaryStart;
        pChild->cbBodyStart = m_pInternet->DwGetOffset();

        // Update m_pBindNode
        Assert(m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN);
        m_pBindNode = pChild;

        // Default Node Content Type
        _HrComputeDefaultContent(m_pBindNode, pszFileName);

        // New Node BindState
        m_pBindNode->bindstate = BINDSTATE_FINDING_UUEND;
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingUuencodeEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingUuencodeEnd(void)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;
    DWORD           cbBoundaryStart;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUEND, FALSE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // UU Encode End
        if (_FIsUuencodeEnd(rLine.pszVal))
        {
            boundary = BOUNDARY_UUEND;
        }
    }

    // Incomplete
    if (BOUNDARY_UUEND != boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Adjust body start to boundary start
        m_pBindNode->cbBodyStart = m_pBindNode->cbBoundaryStart;

        // Body End
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

        // Pop the tree
        m_pBindNode = m_pBindNode->pBindParent;

        // Done
        goto exit;
    }

    // Get the offset
    m_pBindNode->cbBodyEnd = cbBoundaryStart;

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // Should now be looking for next uubegin
    Assert(m_pBindNode ? m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN : TRUE);
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindNodeComplete
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindNodeComplete(LPTREENODEINFO pNode, HRESULT hrResult)
{
    // Locals
    HRESULT         hr=S_OK;
    LPURLREQUEST    pRequest;
    LPURLREQUEST    pNext;

    // The bind for this node is complete
    pNode->bindstate = BINDSTATE_COMPLETE;

    // Save the bind result
    pNode->hrBind = hrResult;

    // If pNode has not been bound yet, lets do it
    if (!ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Bind it to the tree
        hr = pNode->pBody->HrBindToTree(m_pStmLock, pNode);

        // If HrBindToTree failed
        if (SUCCEEDED(pNode->hrBind) && FAILED(hr))
            pNode->hrBind = hr;

        // Process the bind Request Table
        CHECKHR(hr = _HrProcessPendingUrlRequests());

        // If there is a WebPage being built, lets add this body
        if (m_pWebPage)
        {
            // Add the Body
            m_pWebPage->OnBodyBoundToTree(this, pNode);
        }
    }

    // Init the Loop
    pRequest = pNode->pResolved;

    // Loop
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &pNode->pResolved, &m_pComplete);

        // OnComplete
        pRequest->OnBindingComplete(pNode->hrBind);

        // Set pRequest
        pRequest = pNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::HrRegisterRequest
// --------------------------------------------------------------------------------
HRESULT CMessageTree::HrActiveUrlRequest(LPURLREQUEST pRequest)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == pRequest)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(m_rRootUrl.pszVal);

    // AddRef the Request
    pRequest->GetInner()->AddRef();

    // Put the Request into the pending list
    _LinkUrlRequest(pRequest, &m_pPending);

    // Process Pending Url Requests
    CHECKHR(hr = _HrProcessPendingUrlRequests());

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrProcessPendingUrlRequests
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrProcessPendingUrlRequests(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPURLREQUEST    pRequest=m_pPending;
    LPURLREQUEST    pNext;
    HBODY           hBody;
    BOOL            fResolved;

    // Loop the request
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // Try to resolve the request
        CHECKHR(hr = _HrResolveUrlRequest(pRequest, &fResolved));
        
        // Resolved
        if (FALSE == fResolved && ISFLAGSET(m_dwState, TREESTATE_BINDDONE))
        {
            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Not found, use default protocol
            pRequest->OnBindingComplete(E_FAIL);
        }

        // Next
        pRequest = pNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrResolveUrlRequest
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrResolveUrlRequest(LPURLREQUEST pRequest, BOOL *pfResolved)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody=NULL;
    LPTREENODEINFO  pNode;
    LPWSTR          pwszCntType=NULL;
    IStream        *pStream=NULL;

    // Invalid Arg
    Assert(pfResolved);

    // Initialize
    *pfResolved = FALSE;

    // Is this the root request ?
    if (NULL == pRequest->m_pszBodyUrl)
    {
        // Do I have a user supplied root data stream...I assume its html
        if (m_pRootStm)
        {
            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Use client driven root html stream
            pRequest->OnFullyAvailable(STR_TEXTHTML, m_pRootStm, this, NULL);

            // Resolved
            *pfResolved = TRUE;

            // Done
            goto exit;
        }

        // Otherwise, try to resolve the text/html body
        else
        {
            // We should not have a webpage object yet...
            Assert(NULL == m_pWebPage);

            // Create a CMessageWebPage Object
            CHECKALLOC(m_pWebPage = new CMessageWebPage(pRequest));

            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Feed the current amount of data read into the binder
            pRequest->OnStartBinding(STR_TEXTHTML, (IStream *)m_pWebPage, this, HBODY_ROOT);

            // Initialize
            CHECKHR(hr = m_pWebPage->Initialize(m_pCallback, this, &m_rWebPageOpt));

            // I need to feed all bound nodes to the web page for generation...
            CHECKHR(hr = _HrSychronizeWebPage(m_pRootNode));

            // If the entire tree bind is complete, then tell the webpage we are complete
            if (ISFLAGSET(m_dwState, TREESTATE_BINDDONE))
            {
                // Tell the webpage that we are done
                m_pWebPage->OnBindComplete(this);
                m_pWebPage->Release();
                m_pWebPage = NULL;
            }

            // Resolved
            *pfResolved = TRUE;

            // Done
            goto exit;
        }
    }

    // Otherwise, look for the Url
    else if (FAILED(ResolveURL(NULL, NULL, pRequest->m_pszBodyUrl, URL_RESOLVE_RENDERED, &hBody)))
        goto exit;

    // We better have a body handle by now
    Assert(_FIsValidHandle(hBody) && pRequest);

    // Dereference the body
    pNode = _PNodeFromHBody(hBody);

    // Get the Content Type
    MimeOleGetPropW(pNode->pBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &pwszCntType);

    // Get the BodyStream
    if (FAILED(pNode->pBody->GetData(IET_INETCSET, &pStream)))
        goto exit;

    // Complete
    if (BINDSTATE_COMPLETE == pNode->bindstate)
    {
        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

        // OnComplete
        pRequest->OnFullyAvailable(pwszCntType, pStream, this, pNode->hBody);

        // Resolved
        *pfResolved = TRUE;

        // Done
        goto exit;
    }

    // Otherwise, start binding
    else if (ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Should have pNode->pLockBytes
        Assert(pNode->pLockBytes);

        // Relink Request into the Node
        _RelinkUrlRequest(pRequest, &m_pPending, &pNode->pResolved);

        // Feed the current amount of data read into the binder
        pRequest->OnStartBinding(pwszCntType, pStream, this, pNode->hBody);

        // Resolved
        *pfResolved = TRUE;

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pwszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSychronizeWebPage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSychronizeWebPage(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(m_pWebPage && pNode);

    // Clear the "OnWebPage" Flag, we are re-generating the webpage
    FLAGCLEAR(pNode->dwState, WEBPAGE_NODESTATE_BITS);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Get the flags for this child node
            CHECKHR(hr = _HrSychronizeWebPage(pChild));
        }

        // Bind the multipart to the webpage
        m_pWebPage->OnBodyBoundToTree(this, pNode);
    }

    // Otherwise, if the node is bound and gagged...
    else if (BINDSTATE_COMPLETE == pNode->bindstate)
    {
        // Append to the WebPage
        m_pWebPage->OnBodyBoundToTree(this, pNode);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_RelinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppSource, 
    LPURLREQUEST *ppDest)
{
    // Unlink this pending request
    _UnlinkUrlRequest(pRequest, ppSource);

    // Link the bind request into pNode
    _LinkUrlRequest(pRequest, ppDest);
}

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_UnlinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Debug make sure pRequest is part of *ppHead chain
#ifdef DEBUG
    for(LPURLREQUEST pCurr=*ppHead; pCurr!=NULL; pCurr=pCurr->m_pNext)
        if (pCurr == pRequest)
            break;
    AssertSz(pCurr, "pRequest is not part of *ppHead linked list");
#endif

    // Fixup Previous and Next
    LPURLREQUEST pNext = pRequest->m_pNext;
    LPURLREQUEST pPrev = pRequest->m_pPrev;

    // Fixup Links
    if (pNext)
        pNext->m_pPrev = pPrev;
    if (pPrev)
        pPrev->m_pNext = pNext;

    // Fixup ppHead
    if (pRequest == *ppHead)
    {
        Assert(pPrev == NULL);
        *ppHead = pNext;
    }

    // Set Next and Prev
    pRequest->m_pNext = NULL;
    pRequest->m_pPrev = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::_LinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_LinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Is the head set
    if (NULL != *ppHead)
    {
        // Set Next
        pRequest->m_pNext = *ppHead;

        // Set Previous
        (*ppHead)->m_pPrev = pRequest;
    }

    // Set the head
    (*ppHead) = pRequest;
}

// --------------------------------------------------------------------------------
// CMessageTree::_ReleaseUrlRequestList
// --------------------------------------------------------------------------------
void CMessageTree::_ReleaseUrlRequestList(LPURLREQUEST *ppHead)
{
    // Locals
    LPURLREQUEST pCurr;
    LPURLREQUEST pNext;

    // Invalid Arg
    Assert(ppHead);

    // Init
    pCurr = *ppHead;

    // Loop the Elements
    while(pCurr)
    {
        // Set Next
        pNext = pCurr->m_pNext;

        // Free pCurr
        pCurr->GetInner()->Release();

        // Next
        pCurr = pNext;
    }

    // Done
    *ppHead = NULL;
}

// --------------------------------------------------------------------------------
// IsRfc1154Token
//
// --------------------------------------------------------------------------------
inline BOOL IsRfc1154Token(LPSTR pszDesired, LPSTR pszEndPtr, ULONG cchLen)
{

    if (StrCmpNI(pszDesired,pszEndPtr,cchLen) != 0)
    {
        return (FALSE);
    }
    if ((pszEndPtr[cchLen] != '\0') &&
        (pszEndPtr[cchLen] != ' ') &&
        (pszEndPtr[cchLen] != '\t') &&
        (pszEndPtr[cchLen] != ','))
    {
        return (FALSE);
    }
    return (TRUE);
}

// --------------------------------------------------------------------------------
// CMessageTree::_DecodeRfc1154
// --------------------------------------------------------------------------------
void CMessageTree::_DecodeRfc1154() {
    BOOL bRes = FALSE;
    HRESULT hr;
    LPSTR pszEncoding = NULL;
    LPSTR pszEndPtr;
    ULONG cAlloc = 0;

    if (!m_rOptions.fDecodeRfc1154)
    {
        goto exit;
    }
    hr = m_pBindNode->pContainer->GetProp(SYM_HDR_ENCODING, &pszEncoding);
    if (!SUCCEEDED(hr))
    {
        goto exit;
    }
    pszEndPtr = pszEncoding;
    // Each time we enter this loop, pszEndPtr points to the start of the
    // next subfield.  Each subfield is something like "103 TEXT".  The
    // number is always decimal, and the number is optional in the last
    // subfield.
    while (1)
    {
        LPSTR pszTmp;
        ULONG cLines;
        BOOL bNumberFound;
        BT1154ENCODING encEncoding;

        // ------------------------------------
        // "  103  TEXT  , ..."
        //  ^
        //  |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //  ^
        //  |-- pszEndPtr
        // ------------------------------------

        bNumberFound = FALSE;

        // Skip past any leading whitespace.
        while ((*pszEndPtr==' ')||(*pszEndPtr=='\t'))
        {
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //    ^
        //    |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        pszTmp = pszEndPtr;

        // We use strtoul to convert a decimal number.
        // pszEndPtr will be left pointing at the
        // character which terminated the number.
        cLines = strtoul(pszTmp, &pszEndPtr, 10);

        if (0xffffffff == cLines)
        {
            // We don't allow this - we use cLines == 0xffffffff to signal
            // the case where the body part didn't include a line count and
            // thus should consume all remaining lines.  So we'll (silently)
            // convert this to 0xfffffffe...
            cLines = 0xfffffffe;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //       ^
        //       |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        if (cLines && !((*pszEndPtr==' ')||(*pszEndPtr=='\t')))
        {
            // Malformed - if the subfield specifies a number, then
            // the number *must* be followed by whitespace.
            goto exit;
        }
        // Now we skip past any whitespace...
        while ((*pszEndPtr==' ') || (*pszEndPtr=='\t'))
        {
            bNumberFound = TRUE;
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        // We should now be pointing at the body type.
        if (IsRfc1154Token("text",pszEndPtr,4))
        {
            encEncoding = BT1154ENC_TEXT;
            pszEndPtr += 4;
        }
        else if (IsRfc1154Token("uuencode",pszEndPtr,8))
        {
            encEncoding = BT1154ENC_UUENCODE;
            pszEndPtr += 8;
        }
        else if (IsRfc1154Token("x-binhex",pszEndPtr,8))
        {
            encEncoding = BT1154ENC_BINHEX;
            pszEndPtr += 8;
        }
        else
        {
            // Malformed - we don't really support anything except
            // TEXT, UUENCODE, and X-BINHEX.  But, instead of
            // falling back to "fake multipart" handling, we'll just
            // pretend that this body part is TEXT...
            encEncoding = BT1154ENC_TEXT;
            // We need to consume the body part from the Encoding: string - that means
            // that we advance until we see a NULL, a space, a tab, or a comma.
            while ((*pszEndPtr != '\0') &&
                   (*pszEndPtr != ' ') &&
                   (*pszEndPtr != '\t') &&
                   (*pszEndPtr != ','))
            {
                pszEndPtr++;
            }
            // TBD - We could add the body type as a property on the
            // body part.  To do that, we would need to save it in the
            // m_pBT1154 structure.  We'd also have to figure out which
            // property to set it as.
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //             ^
        //             |-- pszEndPtr
        // ------------------------------------

        // Now we skip past any whitespace...
        while ((*pszEndPtr==' ') || (*pszEndPtr=='\t'))
        {
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //               ^
        //               |-- pszEndPtr
        // ------------------------------------

        if ((*pszEndPtr!='\0') && (*pszEndPtr!=','))
        {
            // Malformed - a subfield is terminated either by a comma,
            // or by a NULL.
            goto exit;
        }
        if (*pszEndPtr != '\0' && !bNumberFound)
        {
            // Malformed - only the *last* subfield can get away with
            // not specifying a line count.
            goto exit;
        }
        if (*pszEndPtr == '\0' && !bNumberFound)
        {
            // This is the last subfield, and there wasn't
            // a line count specified.  This means that the
            // last body part should consume all of the remaining
            // lines - so we'll set the line count really high...
            cLines = 0xffffffff;
        }
        if (!m_pBT1154 || (m_pBT1154->cBodies == cAlloc))
        {
            ULONG cbCurrSize = offsetof(BOOKTREE1154, aBody) + (sizeof(BT1154BODY) * cAlloc);
            ULONG cbAllocSize = cbCurrSize + sizeof(BT1154BODY) * 4;
            LPBOOKTREE1154 pTmp;

            CHECKALLOC(pTmp = (LPBOOKTREE1154)g_pMalloc->Alloc(cbAllocSize));
            if (!m_pBT1154)
            {
                ZeroMemory(pTmp, cbAllocSize);
            }
            else
            {
                CopyMemory(pTmp, m_pBT1154, cbCurrSize);
                ZeroMemory(((LPBYTE) pTmp) + cbCurrSize, cbAllocSize - cbCurrSize);
            }
            SafeMemFree(m_pBT1154);
            m_pBT1154 = pTmp;
            cAlloc += 4;
        }
        Assert(0 == m_pBT1154->aBody[m_pBT1154->cBodies].encEncoding);
        Assert(0 == m_pBT1154->aBody[m_pBT1154->cBodies].cLines);
        m_pBT1154->aBody[m_pBT1154->cBodies].encEncoding = encEncoding;
        m_pBT1154->aBody[m_pBT1154->cBodies].cLines = cLines;
        m_pBT1154->cBodies++;
        if (*pszEndPtr == '\0')
        {
            // The end of the line...
            break;
        }
        // Skip past the comma.
        Assert(*pszEndPtr==',');
        Assert(bNumberFound);
        pszEndPtr++;

        // ------------------------------------
        // "         ... , 975 UUENCODE"
        //                ^
        //                |-- pszEndPtr
        // ------------------------------------

    }
    Assert(m_pBT1154);
    Assert(m_pBT1154->cBodies);
    Assert(!m_pBT1154->cCurrentBody);
    Assert(!m_pBT1154->cCurrentLine);
    Assert(S_OK == m_pBT1154->hrLoadResult);

    bRes = TRUE;

exit:
    SafeMemFree(pszEncoding);
    if (!bRes)
    {
        SafeMemFree(m_pBT1154);
    }
}

#endif // !WIN16

#ifdef SMIME_V3
// --------------------------------------------------------------------------------
// CMessageTree::Encode
// --------------------------------------------------------------------------------

HRESULT CMessageTree::Encode(HWND hwnd, DWORD dwFlags)
{
    HRESULT            hr;
    CSMime *           pSMime = NULL;

    //  Create the object
    CHECKALLOC(pSMime = new CSMime);

    //  Initialize the object
    CHECKHR(hr = pSMime->InitNew());

    //  Set the state flag to tell us about re-use of boundaries
    FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);

    //  Encode the message
    CHECKHR(hr = pSMime->EncodeMessage2(this, m_rOptions.ulSecIgnoreMask |
                                        dwFlags, hwnd));

exit:
    ReleaseObj(pSMime);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Decode
// --------------------------------------------------------------------------------

HRESULT CMessageTree::Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback)
{
    HRESULT             hr;
    CSMime *            pSMime = NULL;

    //  Create the object
    CHECKALLOC(pSMime = new CSMime);

    //  Initialize the object
    CHECKHR(hr = pSMime->InitNew());

    //  Encode the message
    CHECKHR(hr = pSMime->DecodeMessage2(this, m_rOptions.ulSecIgnoreMask |
                                        dwFlags, hwnd, pCallback));

exit:
    ReleaseObj(pSMime);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetRecipientCount
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetRecipientCount(DWORD dwFlags, DWORD * pdwRecipCount)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetRecipientCount(dwFlags, pdwRecipCount));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AddRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageTree::AddRecipient(DWORD dwFlags, DWORD cRecipData,
                                   PCMS_RECIPIENT_INFO precipData)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->AddRecipient(dwFlags, cRecipData, precipData));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}


// ------------------------------------------------------------------------------
// CMessageTree::GetRecipient
// ------------------------------------------------------------------------------

HRESULT CMessageTree::GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetRecipient(dwFlags, iRecipient, cRecipients, pRecipData));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageTree::DeleteRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->DeleteRecipient(dwFlags, iRecipient, cRecipients));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   DWORD iInstance, LPCSTR pszObjId,
                                   CRYPT_ATTRIBUTE ** ppattr)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetAttribute(dwFlags, iSigner, iAttribSet, iInstance,
                                    pszObjId, ppattr));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   const CRYPT_ATTRIBUTE * ppattr)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->SetAttribute(dwFlags, iSigner, iAttribSet, ppattr));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::DeleteAttribute(DWORD dwFlags, DWORD iSigner,
                                      DWORD iAttributeSet, DWORD iInstance,
                                      LPCSTR pszObjId)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->DeleteAttribute(dwFlags, iSigner, iAttributeSet,
                                       iInstance, pszObjId));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::CreateReceipt
// --------------------------------------------------------------------------------

HRESULT CMessageTree::CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                                    const BYTE *pbFromNames, DWORD cSignerCertificates,
                                    PCCERT_CONTEXT *rgSignerCertificates,
                                    IMimeMessage ** ppMimeMessageReceipt)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetReceiptSendersList
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetReceiptSendersList(DWORD dwFlags, DWORD *pcSendersList,
                                            CERT_NAME_BLOB  * *rgSendersList)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::VerifyReceipt
// --------------------------------------------------------------------------------

HRESULT CMessageTree::VerifyReceipt(DWORD dwFlags,
                                    IMimeMessage * pMimeMessageReceipt)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::CapabilitiesSupported
// --------------------------------------------------------------------------------

HRESULT CMessageTree::CapabilitiesSupported(DWORD * pdwFlags)
{
    //  Assume no capabilities
    *pdwFlags = 0;
    
    //  If we have msasn1.dll on the system, then we can support labels
    if (FIsMsasn1Loaded())  *pdwFlags |= SMIME_SUPPORT_LABELS;

    //  If we have a correct crypt32, then we can support receipts & key agreement
    DemandLoadCrypt32();
    if (g_FSupportV3 && FIsMsasn1Loaded())
        *pdwFlags |= SMIME_SUPPORT_RECEIPTS;

    if (g_FSupportV3)
        *pdwFlags |= SMIME_SUPPORT_KEY_AGREE;

    //  If we have a correct advapi32, then we can support maillist keys
    DemandLoadAdvApi32();
    if (VAR_CryptContextAddRef != MY_CryptContextAddRef)
        *pdwFlags |= SMIME_SUPPORT_MAILLIST;
    
    return S_OK;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\viewsrc.cpp ===
#include <pch.hxx>
#include "dllmain.h"
#include "demand.h"
#include "resource.h"
#include "viewsrc.h"
#include "util.h"

#define idTimerEditChange   401

/////////////////////////////////////////////////////////////////////////////
// Parsing constants

//	Ignore all <'s and >'s in the following environments:
//	Script				<script> here </script>
//  Denali				<% here %>
//  Comment				<!-- here -->
//  String literal		< ... "here" ... >
//	 (as tag attribute)	< ... 'here' ... >

static enum
{
	ENV_NORMAL	= 0,	// normal
	ENV_COMMENT = 1,	// ignore <'s and >'s
	ENV_QUOTE	= 2,	// " "
	ENV_SCRIPT	= 3,	// " "
	ENV_DENALI	= 4,	// " "
	ENV_QUOTE_SCR= 5,	// " "; string literal in SCRIPT tag
};

static const char	QUOTE_1 = '\'';
static const char	QUOTE_2 = '\"';


HRESULT CALLBACK FreeViewSrcDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt)
{
    // Loop through the data and free it all
    if (pDataObjInfo)
        {
        for (DWORD i = 0; i < celt; i++)
            SafeMemFree(pDataObjInfo[i].pData);
        SafeMemFree(pDataObjInfo);    
        }
    return S_OK;
}


HRESULT ViewSource(HWND hwndParent, IMimeMessage *pMsg)
{
    CViewSource     *pViewSrc=0;
    HRESULT         hr;

    TraceCall("MimeEditViewSource");

    if (!DemandLoadRichEdit())
        return TraceResult(MIMEEDIT_E_LOADLIBRARYFAILURE);


    pViewSrc = new CViewSource();
    if (!pViewSrc)
        return E_OUTOFMEMORY;
            
    hr = pViewSrc->Init(hwndParent, pMsg);
    if (FAILED(hr))
        goto exit;

    hr = pViewSrc->Show();
    if (FAILED(hr))
        goto exit;

    // pViewSrc will maintain it's own refcount and self-destruct on close
exit:
    ReleaseObj(pViewSrc);
    return hr;
}


CViewSource::CViewSource()
{
    m_hwnd = NULL;
    m_hwndEdit = NULL;
    m_pMsg = NULL;
    m_cRef = 1;
}


CViewSource::~CViewSource()
{
    SafeRelease(m_pMsg);
}


ULONG CViewSource::AddRef()
{
    return ++m_cRef;
}

ULONG CViewSource::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CViewSource::Init(HWND hwndParent, IMimeMessage *pMsg)
{
    ReplaceInterface(m_pMsg, pMsg);

    if (!CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddMsgSource), hwndParent, CViewSource::_ExtDlgProc, (LPARAM)this))
        return E_OUTOFMEMORY;

    return S_OK;
}


HRESULT CViewSource::Show()
{
    ShowWindow(m_hwnd, SW_SHOW);
    return S_OK;
}


INT_PTR CALLBACK CViewSource::_ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CViewSource     *pThis = (CViewSource *)GetWindowLongPtr(hwnd, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pThis = (CViewSource *)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
    }

    return pThis ? pThis->_DlgProc(hwnd, msg, wParam, lParam) : FALSE;
}


INT_PTR CViewSource::_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPSTREAM        pstm;
    CHARFORMAT      cf;
    BODYOFFSETS     rOffset;
    CREMenu         *pMenu;

    switch(msg)
        {
        case WM_INITDIALOG:
            m_hwnd = hwnd;
            m_hwndEdit=GetDlgItem(hwnd, idcTxtSource);
            DllAddRef();
            AddRef();

            if (m_pMsg && 
                m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
            {
                ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
                cf.cbSize = sizeof(CHARFORMAT);
                cf.dwMask = CFM_SIZE|CFM_COLOR|CFM_FACE|CFM_BOLD|
                            CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT;
                StrCpyN(cf.szFaceName, TEXT("Courier New"), ARRAYSIZE(cf.szFaceName));
                cf.yHeight = 200;
                cf.crTextColor = 0;
                cf.dwEffects |= CFE_AUTOCOLOR;
                cf.bPitchAndFamily = FIXED_PITCH;
                cf.yOffset = 0;
                SendMessage(m_hwndEdit, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
                SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR, 0, (LONG)GetSysColor(COLOR_3DFACE));
                SendMessage(m_hwndEdit, EM_SETLIMITTEXT, 0, 0x100000);

                pMenu = new CREMenu();
                if (pMenu)
                {
                    pMenu->Init(m_hwndEdit, idmrCtxtViewSrc);
                    SendMessage(m_hwndEdit, EM_SETOLECALLBACK, 0, (LPARAM)pMenu);
                    pMenu->Release();
                }

                RicheditStreamIn(m_hwndEdit, pstm, SF_TEXT);
                _BoldKids();
                pstm->Release();
            }
            PostMessage(m_hwndEdit, EM_SETSEL, 0, 0);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idmCopy:
                    SendMessage(m_hwndEdit, WM_COPY, 0, 0);
                    return TRUE;

                case idmSelectAll:
                    Edit_SetSel(m_hwndEdit, 0, -1);
                    return TRUE;
            }
            break;

        case WM_SIZE:
            SetWindowPos(m_hwndEdit,0,0,0,
                    LOWORD(lParam), HIWORD(lParam),SWP_NOACTIVATE|SWP_NOZORDER);
            break;

        case WM_DESTROY:
            DllRelease();
            Release();
            break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        }

    return FALSE;
}



HRESULT CViewSource::_BoldKids()
{
    HBODY       hBody;
    FINDBODY    fb={0};
    CHARFORMAT  cf;
    BODYOFFSETS rOffset;

    ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_BOLD|CFM_ITALIC;

    // bold the root
    m_pMsg->GetBodyOffsets(HBODY_ROOT, &rOffset);
    Edit_SetSel(m_hwndEdit, 0, rOffset.cbBodyStart);
    cf.dwEffects=CFE_BOLD;
    SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    // bold the kids
    if (m_pMsg->FindFirst(&fb, &hBody)==S_OK)
        {
        do
            {
            // italic the boundaries and bold the headers
            m_pMsg->GetBodyOffsets(hBody, &rOffset);
            
            Edit_SetSel(m_hwndEdit, rOffset.cbBoundaryStart, rOffset.cbHeaderStart);
            cf.dwEffects=CFE_ITALIC;
            SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

            Edit_SetSel(m_hwndEdit, rOffset.cbHeaderStart, rOffset.cbBodyStart);
            cf.dwEffects=CFE_BOLD;
            SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
            
            }
        while (m_pMsg->FindNext(&fb, &hBody)==S_OK);
        }
    return S_OK;
}



CREMenu::CREMenu()
{
    m_hwndEdit = NULL;
    m_cRef = 1;
}


CREMenu::~CREMenu()
{
}


ULONG CREMenu::AddRef()
{
    return ++m_cRef;
}

ULONG CREMenu::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CREMenu::QueryInterface(REFIID riid, LPVOID FAR * lplpObj)
{
    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (void*)(IUnknown*)this;
    else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        *lplpObj = (void*)(IRichEditOleCallback*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CREMenu::Init(HWND hwndEdit, int idMenu)
{
    m_hwndEdit = hwndEdit;
    m_idMenu = idMenu;
    return S_OK;
}

HRESULT CREMenu::GetNewStorage (LPSTORAGE FAR * ppstg)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::GetInPlaceContext( LPOLEINPLACEFRAME *lplpFrame, LPOLEINPLACEUIWINDOW *lplpDoc, 
                                        LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::ShowContainerUI(BOOL fShow)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::QueryInsertObject(LPCLSID lpclsid, LPSTORAGE lpstg, LONG cp)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::DeleteObject(LPOLEOBJECT lpoleobj)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::QueryAcceptData(   LPDATAOBJECT pdataobj, CLIPFORMAT *pcfFormat,  DWORD reco, 
                                        BOOL fReally,  HGLOBAL hMetaPict)
{
    *pcfFormat = CF_TEXT;
    return S_OK;
}


HRESULT CREMenu::ContextSensitiveHelp(BOOL fEnterMode)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::GetClipboardData(CHARRANGE *pchrg, DWORD reco, LPDATAOBJECT *ppdataobj)
{
    HRESULT     hr;
    DATAOBJINFO *pDataInfo=NULL;
    FORMATETC   fetc;
    TEXTRANGE   txtRange;
    CHARRANGE   chrg;
    LONG        cchStart=0,
                cchEnd=0,
                cchMax=0,
                cchLen=0;
    LPSTR       pszData=0;    

    *ppdataobj = NULL;

    if (pchrg)
    {
        chrg = *pchrg;
        
        cchMax = (LONG) SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);

        // validate the range
        chrg.cpMin = max(0, chrg.cpMin);
        chrg.cpMin = min(cchMax, chrg.cpMin);
        
        if(chrg.cpMax < 0 || chrg.cpMax > cchMax)
            chrg.cpMax = cchMax;
    }
    else
    {
        // if no charrange, then get the current selection
        SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&cchStart, (LPARAM)&cchEnd);
        chrg.cpMin = cchStart;
        chrg.cpMax = cchEnd;
    }
    
    if (chrg.cpMin >= chrg.cpMax)
    {
        *ppdataobj = NULL;
        return chrg.cpMin == chrg.cpMax ? NOERROR : E_INVALIDARG;
    }


    cchLen = chrg.cpMax - chrg.cpMin;

    if (!MemAlloc((LPVOID *)&pszData, cchLen+1))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    txtRange.chrg = chrg;
    txtRange.lpstrText = pszData;

    SendMessage(m_hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&txtRange);

    if (!MemAlloc((LPVOID*)&pDataInfo, sizeof(DATAOBJINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    SETDefFormatEtc(pDataInfo->fe, CF_TEXT, TYMED_HGLOBAL);
    
    pDataInfo->cbData = cchLen+1;
    pDataInfo->pData = pszData;

    hr = CreateDataObject(pDataInfo, 1, (PFNFREEDATAOBJ)FreeViewSrcDataObj, ppdataobj);
    if (FAILED(hr))
        goto error;

    pDataInfo = NULL;   // freed by dataobject
    pszData = NULL;

error:
    SafeMemFree(pszData);
    SafeMemFree(pDataInfo);
    return hr;
}

HRESULT CREMenu::GetDragDropEffect(BOOL fDrag,  DWORD grfKeyState, LPDWORD pdwEffect)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::GetContextMenu(WORD seltype, LPOLEOBJECT pOleObject, CHARRANGE *pchrg, HMENU *phMenu)
{
    HMENU           hMenu;

    if (!(hMenu=LoadPopupMenu(m_idMenu)))
        return E_OUTOFMEMORY;

    if (SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0)==SEL_EMPTY)
    {
        EnableMenuItem(hMenu, idmCopy, MF_GRAYED|MF_BYCOMMAND);
        EnableMenuItem(hMenu, idmCut, MF_GRAYED|MF_BYCOMMAND);
    }

    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
    {
        EnableMenuItem(hMenu, idmCut, MF_GRAYED|MF_BYCOMMAND);
        EnableMenuItem(hMenu, idmPaste, MF_GRAYED|MF_BYCOMMAND);
    }

    *phMenu=hMenu;
    return S_OK;
}





ULONG CMsgSource::AddRef()
{
    return ++m_cRef;
};

ULONG CMsgSource::Release()
{
    m_cRef--;
    if (m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


CMsgSource::CMsgSource()
{
    m_hwnd = 0;
    m_cRef = 1;
    m_fColor=0;
    m_fDisabled=0;
    m_pCmdTargetParent=0;
    m_pszLastText = 0;
}

CMsgSource::~CMsgSource()
{
    SafeMemFree(m_pszLastText);
}


HRESULT CMsgSource::Init(HWND hwndParent, int id, IOleCommandTarget *pCmdTargetParent)
{
    CHARFORMAT  cf;
    CREMenu     *pMenu;

    DemandLoadRichEdit();

    m_hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
                                "RICHEDIT", 
                                NULL,
                                WS_CHILD|WS_TABSTOP|ES_MULTILINE|ES_SAVESEL|ES_WANTRETURN|WS_VSCROLL|ES_AUTOVSCROLL,
                                0, 0, 0, 0,
                                hwndParent, 
                                (HMENU)IntToPtr(id), 
                                g_hLocRes, 
                                NULL);
    if (!m_hwnd)
        return E_FAIL;

    ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_SIZE|CFM_COLOR|CFM_FACE|CFM_BOLD|
                CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT;
    StrCpyN(cf.szFaceName, TEXT("Courier New"), ARRAYSIZE(cf.szFaceName));
    cf.yHeight = 200;
    cf.crTextColor = 0;
    cf.dwEffects |= CFE_AUTOCOLOR;
    cf.bPitchAndFamily = FIXED_PITCH;
    cf.bCharSet = DEFAULT_CHARSET;
    cf.yOffset = 0;
    SendMessage(m_hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    SendMessage(m_hwnd, EM_SETEVENTMASK, 0, ENM_KEYEVENTS|ENM_CHANGE|ENM_SELCHANGE|ENM_UPDATE);
    SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_OR, ECO_SELECTIONBAR);

    pMenu = new CREMenu();
    if (pMenu)
    {
        pMenu->Init(m_hwnd, idmrCtxtViewSrc);
        SendMessage(m_hwnd, EM_SETOLECALLBACK, 0, (LPARAM)pMenu);
        pMenu->Release();
    }

    m_pCmdTargetParent = pCmdTargetParent;  // loose reference, as parent never changes
    return S_OK;
}

HRESULT CMsgSource::Show(BOOL fOn, BOOL fColor)
{
    ShowWindow(m_hwnd, fOn?SW_SHOW:SW_HIDE);
    m_fDisabled = !fColor;
    return S_OK;
}

    
HRESULT CMsgSource::Load(IStream *pstm)
{
    RicheditStreamIn(m_hwnd, pstm, SF_TEXT);
    Edit_SetModify(m_hwnd, FALSE);
    return S_OK;
}

HRESULT CMsgSource::IsDirty()
{
    return Edit_GetModify(m_hwnd) ? S_OK : S_FALSE;
}


HRESULT CMsgSource::Save(IStream **ppstm)
{
    if (MimeOleCreateVirtualStream(ppstm)!=S_OK)
        return E_FAIL;

    RicheditStreamOut(m_hwnd, *ppstm, SF_TEXT);
    return S_OK;
}

HRESULT CMsgSource::SetRect(RECT *prc)
{
    SetWindowPos(m_hwnd, 0, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOACTIVATE|SWP_NOZORDER);
    return S_OK;
}

HRESULT CMsgSource::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


HRESULT CMsgSource::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;

    if (pguidCmdGroup == NULL)
        {
        for (uCmd=0;uCmd<cCmds; uCmd++)
            {
            prgCmds[uCmd].cmdf = 0;
            
            if (GetFocus() == m_hwnd)
                {
                switch (prgCmds[uCmd].cmdID)
                    {
                    case OLECMDID_CUT:
                    case OLECMDID_COPY:
                        if (SendMessage(m_hwnd, EM_SELECTIONTYPE, 0, 0)!=SEL_EMPTY)
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_SELECTALL:
                        prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_UNDO:
                        if (SendMessage(m_hwnd, EM_CANUNDO, 0, 0))
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_PASTE:
                        if (SendMessage(m_hwnd, EM_CANPASTE, 0, 0))
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;
                    }
                }
            }
        return S_OK;
        }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
            {
            // disable all these commands
            for (uCmd=0; uCmd < cCmds; uCmd++)
                {
                // bail if we see MECMDID_SHOWSOURCETABS and goto default handler
                if (prgCmds[uCmd].cmdID == MECMDID_SHOWSOURCETABS)
                    return OLECMDERR_E_UNKNOWNGROUP;

                prgCmds[uCmd].cmdf = 0;
                }
            return S_OK;
            }
        else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3))
            {
            // disable all these commands
            for (uCmd=0; uCmd < cCmds; uCmd++)
                {
                prgCmds[uCmd].cmdf = 0;
                }
            return S_OK;
            }

    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CMsgSource::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup == NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_CUT:
                SendMessage(m_hwnd, WM_CUT, 0, 0);
                return S_OK;

            case OLECMDID_COPY:
                SendMessage(m_hwnd, WM_COPY, 0, 0);
                return S_OK;

            case OLECMDID_PASTE:
                SendMessage(m_hwnd, WM_PASTE, 0, 0);
                return S_OK;

            case OLECMDID_SELECTALL:
                SendMessage(m_hwnd, EM_SETSEL, 0, -1);
                return S_OK;

            case OLECMDID_UNDO:
                SendMessage(m_hwnd, EM_UNDO, 0, 0);
                return S_OK;
            
            default:
                return OLECMDERR_E_NOTSUPPORTED;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CMsgSource::OnWMNotify(WPARAM wParam, NMHDR* pnmhdr, LRESULT *plRet)
{
    MSGFILTER   *pmf;

    *plRet = 0;

    if (pnmhdr->hwndFrom != m_hwnd)
        return S_FALSE;

    switch (pnmhdr->code)
    {
        case EN_MSGFILTER:
        {
            // if we get a control-tab, then richedit snags this and inserts a
            // tab char, we hook the wm_keydown and never pass to richedit
            if (((MSGFILTER *)pnmhdr)->msg == WM_KEYDOWN &&
                ((MSGFILTER *)pnmhdr)->wParam == VK_TAB && 
                (GetKeyState(VK_CONTROL) & 0x8000))
            {
                *plRet = TRUE;
                return S_OK;
            }
        }
        break;

        case EN_SELCHANGE:
        {
            if (m_pCmdTargetParent)
                m_pCmdTargetParent->Exec(NULL, OLECMDID_UPDATECOMMANDS, NULL, NULL, NULL);
            return S_OK;
        }

    }

    return S_FALSE;
}

static HACCEL   g_hAccelSrc=0;

HRESULT CMsgSource::TranslateAccelerator(LPMSG lpmsg)
{
    MSG msg;

    if (GetFocus() != m_hwnd)
        return S_FALSE;

    if (!g_hAccelSrc)   // cache this as NT4 SP3 leaks internal accerator tables
        g_hAccelSrc = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(idacSrcView));

    // see if it one of ours
    if (::TranslateAcceleratorWrapW(GetParent(m_hwnd), g_hAccelSrc, &msg))
        return S_OK;


    // insert tabs
    if (lpmsg->message == WM_KEYDOWN &&
        lpmsg->wParam == VK_TAB &&
        !(GetKeyState(VK_CONTROL) & 0x8000) &&
        !(GetKeyState(VK_SHIFT) & 0x8000))
        {
        Edit_ReplaceSel(m_hwnd, TEXT("\t"));
        return S_OK;
        }

    return S_FALSE;
}


HRESULT CMsgSource::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    if (GetFocus() == m_hwnd)
    {
        // context menu commands
        switch (id)
        {
            case idmTab:
                Edit_ReplaceSel(m_hwnd, TEXT("\t"));
                return S_OK;

            case idmCopy:
                SendMessage(m_hwnd, WM_COPY, 0, 0);
                return S_OK;

            case idmPaste:
                SendMessage(m_hwnd, WM_PASTE, 0, 0);
                return S_OK;

            case idmCut:
                SendMessage(m_hwnd, WM_CUT, 0, 0);
                return S_OK;

            case idmUndo:
                SendMessage(m_hwnd, EM_UNDO, 0, 0);
                return S_OK;

            case idmSelectAll:
                SendMessage(m_hwnd, EM_SETSEL, 0, -1);
                return S_OK;

        }
    }

    if (hwnd != m_hwnd) // not our window
        return S_FALSE;

    if (wCmd == EN_CHANGE)
    {
        OnChange();
        return S_OK;
    }

    return S_FALSE;
}




HRESULT CMsgSource::HasFocus()
{
    return GetFocus() == m_hwnd ? S_OK : S_FALSE;
}

HRESULT CMsgSource::SetFocus()
{
    ::SetFocus(m_hwnd);
    return S_OK;
}


void CMsgSource::OnChange() 
{
	// batch up the change commands with a timer
    if (!m_fColor)
	    {
        KillTimer(GetParent(m_hwnd), idTimerEditChange);
		SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
	    }
}


HRESULT CMsgSource::OnTimer(WPARAM idTimer)
{
	CHARFORMAT	cf;
	int 		inTag = 0;
	BOOL		pastTag = FALSE;
	COLORREF	crTag = RGB(0x80, 0, 0x80);
	COLORREF	crInTag = RGB(0xFF, 0, 0);
	COLORREF	crNormal = RGB(0, 0, 0);
	COLORREF	crLiteral = RGB(0, 0, 0xFF);
	COLORREF	crHere;
	COLORREF	crLast = crNormal;
	int			i, n;
	int			nChange=0;
	BOOL		bHidden = FALSE;
	CHARRANGE	cr;
	int			ignoreTags = ENV_NORMAL;
	char		quote_1 = QUOTE_1;
	char		quote_2 = QUOTE_2;
    BOOL        fRestoreScroll=FALSE,
                fShowProgress=FALSE;
    DWORD       dwStartTime = GetTickCount();
    HCURSOR     hCur = NULL;
    DWORD       dwProgress=0,
                dwTmp;
    VARIANTARG  va;
    TCHAR       rgch[CCHMAX_STRINGRES],
                rgchFmt[CCHMAX_STRINGRES];
    LPSTR       pszText=0;
    int         cch;
    BOOL        fSetTimer=FALSE;

	// Save modificationness
	BOOL bModified = Edit_GetModify(m_hwnd);
		
    if (idTimer!=idTimerEditChange)
        return S_FALSE;

	// Kill outstanding timer
	KillTimer(GetParent(m_hwnd), idTimerEditChange);

	//
	// If the user is mousing around (say for scrolling) then don't drag down
	// his performance!
	//
	if (GetCapture())
	    {
		SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
		return S_OK;
	    }
	
    // Turn off the color syntax
	if (m_fDisabled)
	    {
		// Already all one color

		m_fColor = TRUE;

		// Save current selection and hide
		GetSel(&cr);
        HideSelection(TRUE, FALSE);
		bHidden = TRUE;
		
		SetSel(0, -1); // select all
		GetSelectionCharFormat(&cf);
		cf.dwMask = CFM_COLOR;
		cf.dwEffects = 0;
		cf.crTextColor = crNormal;
		SetSelectionCharFormat(&cf);
	    }
	else
	    { 
        // Start color fiddling
		// Get text, find the change
        
        if (_GetText(&pszText)!=S_OK)
            return E_FAIL;

		const char* start = (const char*)pszText;
		const char* old = (const char*) m_pszLastText;
		const char* s;

        for (s = start; *s && old && *old && *s == *old; s++, old++)
			continue;

		// If no change, nothing to do
		if (*s == 0)
        {
			MemFree(pszText);
            return S_OK;
        }

		// Otherwise, track place where we'll start to examine colors for changes
		nChange = (int) (s - start);
		
		// Only examine 2000 chars at a time
		if (lstrlen(s) > 2000)
		{
            // Reset timer to process other characters
            fSetTimer = TRUE;
			
            // Truncate text so we only examine limited amount
			cch  = lstrlen(pszText);
			cch = min(cch, nChange + 2000);
			pszText[cch] = 0;
			start = (const char*)pszText;
		}
		
        SafeMemFree(m_pszLastText);
        m_pszLastText = pszText;

		m_fColor = TRUE;

		// Workaround for scrolling bug in REC 1.0
		if (GetFocus() == m_hwnd)
        {
            SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_XOR, ECO_AUTOVSCROLL);
            // BUGBUG: richedit1.0 on NT4 will remove the WS_VISIBLE bit when XORing ECO_AUTOVSCROLL
            // call show window after this to esure that the visible bit is displayed
            ShowWindow(m_hwnd, SW_SHOW);
            fRestoreScroll=TRUE;
        }

		const char* range = start;
		for (s = start; *s; s++)
		{
            // if we've been going for >2 seconds then show an hourglass and 
            // start showing progress
            if (hCur == NULL &&
                GetTickCount() >= dwStartTime + 2000)
            {
                hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                if (m_pCmdTargetParent)
                {
                    fShowProgress=TRUE;
                    *rgchFmt=NULL;
                    LoadString(g_hLocRes, idsColorSourcePC, rgchFmt, ARRAYSIZE(rgchFmt));
                }
            }

            if (fShowProgress)
            {
                dwTmp = (DWORD) ((((s - start))*100)/cch);
                if (dwTmp > dwProgress)
                {
                    // did overall percentage change, if so update statusbar
                    dwProgress = dwTmp;

                    wnsprintf(rgch, ARRAYSIZE(rgch), rgchFmt, dwProgress);
                    va.vt = VT_BSTR;
                    if (HrLPSZToBSTR(rgch, &va.bstrVal)==S_OK)
                    {
                        m_pCmdTargetParent->Exec(NULL, OLECMDID_SETPROGRESSTEXT, 0, &va, NULL);
                        SysFreeString(va.bstrVal);
                    }
                }
            }

            // entering/leaving string literal in tag
			if (inTag && (*s == quote_1 || *s == quote_2))
			{
				if (ignoreTags == ENV_QUOTE ||
					ignoreTags == ENV_QUOTE_SCR) //leaving
				{
					ignoreTags = (ignoreTags == ENV_QUOTE) ?
								ENV_NORMAL : ENV_SCRIPT;
					quote_1 = QUOTE_1;
					quote_2 = QUOTE_2;
				}
				else if (ignoreTags == ENV_NORMAL) // entering
				{
					ignoreTags = ENV_QUOTE;
					quote_1 = quote_2 = *s;
				}
				else if (ignoreTags == ENV_SCRIPT) // entering
				{
					ignoreTags = ENV_QUOTE_SCR;
					quote_1 = quote_2 = *s;
				}
			}
			// Update leaving tag
			else if (*s == '>')
			{
				switch (ignoreTags) // end of env?
				{
				case ENV_DENALI:
					if (s-1>=start && *(s-1) == '%')
						ignoreTags = ENV_NORMAL;
					break;
				
                case ENV_COMMENT:
					if (s-2>=start && *(s-1) == '-' && *(s-2) == '-')
						ignoreTags = ENV_NORMAL;
					break;
				
                case ENV_SCRIPT:
					if (s-7>=start &&
						StrCmpNIA(s-7, "/SCRIPT", 7)==0)
					{
						ignoreTags = ENV_NORMAL;
						// Color </SCRIPT> properly
						pastTag = TRUE;
						inTag = 0;
						s-=8;
					}
					else // end of <script ...>
						inTag = 0;
					break;
				
                default: // <SCRIPT> (no attribs)
					if (inTag && s-7>=start &&
						StrCmpNIA(s-7, "<SCRIPT", 7)==0)
					{
						ignoreTags = ENV_SCRIPT;
						pastTag = TRUE;
						inTag = 0;
					}
				}
				if (ignoreTags == ENV_NORMAL)
				{
					pastTag = TRUE;
					inTag--;
					if (inTag < 0)
						inTag = 0;
				}
			}

			// Check color
			crHere = inTag ? 
				(pastTag ? 
					(  (*s != '\"' &&
						(ignoreTags == ENV_QUOTE ||	ignoreTags == ENV_QUOTE_SCR)
						) ?
						 crLiteral : crInTag  )
					: crTag)
				: crNormal;

			// If different from last, need to update previous range
			if (crHere != crLast)
			{
				i = (int) (range - start);
				n = (int)(s - range);

				if (i+n >= nChange)
				{
					if (!bHidden)
					{
						// Save current selection and hide
						GetSel(&cr);
						HideSelection(TRUE, FALSE);
						bHidden = TRUE;
					}

					SetSel(i, i+n);
					GetSelectionCharFormat(&cf);
					// If color over range varies or doesn't match, need to apply color
					if ((cf.dwMask & CFM_COLOR) == 0 || cf.crTextColor != crLast)
					{
						cf.dwMask = CFM_COLOR;
						cf.dwEffects = 0;
						cf.crTextColor = crLast;
						SetSelectionCharFormat(&cf);
					}
				}

				// Reset range
				range = s;
				crLast = crHere;
			}

			// Now update entering tag
			if (*s == '<' && ignoreTags == ENV_NORMAL)
			{
				inTag++;
				if (inTag == 1)
					pastTag = FALSE;
			}
			else if (inTag && !pastTag && isspace(*s))
			{
				pastTag = TRUE;
				if (s-1 >= start && *(s-1) == '%')
					ignoreTags = ENV_DENALI;
				else if (s-3 >= start && *(s-1) == '-' 
					&& *(s-2) == '-' && *(s-3) == '!')
					ignoreTags = ENV_COMMENT;
				else if (inTag && s-7>=start &&
						StrCmpNIA(s-7, "<SCRIPT", 7)==0)
					ignoreTags = ENV_SCRIPT;
			}
		}

        // Make sure last range is right
		i = (int) (range - start);
		n = (int) (s - range);

		if (i+n >= nChange)
		{
			if (!bHidden)
			{
				// Save current selection and hide
				GetSel(&cr);
				HideSelection(TRUE, FALSE);
				bHidden = TRUE;
			}
			SetSel(i, i+n);
			GetSelectionCharFormat(&cf);
			// If color over range varies or doesn't match, need to apply color
			if ((cf.dwMask & CFM_COLOR) == 0 || cf.crTextColor != crLast)
			{
				cf.dwMask = CFM_COLOR;
				cf.dwEffects = 0;
				cf.crTextColor = crLast;
				SetSelectionCharFormat(&cf);
			}
		}
		// Workaround for scrolling bug in REC 1.0
		if (fRestoreScroll)
        {
            // BUGBUG: richedit1.0 on NT4 will remove the WS_VISIBLE bit when ORing ECO_AUTOVSCROLL
            // call show window after this to esure that the visible bit is displayed
			SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_OR, ECO_AUTOVSCROLL);
            ShowWindow(m_hwnd, SW_SHOW);
        }
	} // End color fiddling

	// Restore selection visibility
	if (bHidden)
	{
		SetSel(cr.cpMin, cr.cpMax);
		HideSelection(FALSE, FALSE);
	}
	
	// Restore modificationness
	if (!bModified)
		Edit_SetModify(m_hwnd, bModified);

    if (fShowProgress)
    {
        va.vt = VT_BSTR;
        va.bstrVal=NULL;
        m_pCmdTargetParent->Exec(NULL, OLECMDID_SETPROGRESSTEXT, 0, &va, NULL);
    }

    if (hCur)
        SetCursor(hCur);

    m_fColor = FALSE;
    if (fSetTimer)
        SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
    return S_OK;
}

void CMsgSource::HideSelection(BOOL fHide, BOOL fChangeStyle)
{
    SendMessage(m_hwnd, EM_HIDESELECTION, fHide, fChangeStyle);
}

void CMsgSource::GetSel(CHARRANGE *pcr)
{
    SendMessage(m_hwnd, EM_EXGETSEL, 0, (LPARAM)pcr);
}

void CMsgSource::SetSel(int nStart, int nEnd)
{
    SendMessage(m_hwnd, EM_SETSEL, nStart, nEnd);
}

extern BOOL                g_fCanEditBiDi;
void CMsgSource::GetSelectionCharFormat(CHARFORMAT *pcf)
{
    pcf->cbSize = sizeof(CHARFORMAT);
    pcf->dwMask = CFM_BOLD|CFM_COLOR|CFM_FACE|CFM_ITALIC|CFM_OFFSET|CFM_PROTECTED|CFM_SIZE|CFM_STRIKEOUT|CFM_UNDERLINE;

    SendMessage(m_hwnd, EM_GETCHARFORMAT, TRUE, (LPARAM)pcf);

    // On BiDi win9x, DEFAULT_CHARSET is treated as ANSI !!
    // need to reassign charset (Arabic for Arabic and Hebrew for Hebrew)
    if(g_fCanEditBiDi && (!pcf->bCharSet || pcf->bCharSet == DEFAULT_CHARSET))
    {
        // The best way to determine the OS language is from system font charset
        LOGFONT        lfSystem;
        static BYTE    lfCharSet = 0 ; // RunOnce
        if(!lfCharSet && GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfSystem), (LPVOID)& lfSystem))
        {
            if (lfSystem.lfCharSet == ARABIC_CHARSET
                || lfSystem.lfCharSet == HEBREW_CHARSET)
            {
                lfCharSet = lfSystem.lfCharSet; // Arabic/Hebrew charset for Arabic/Hebrew OS
            }
        }
        pcf->bCharSet = lfCharSet;
    }
 }


void CMsgSource::SetSelectionCharFormat(CHARFORMAT *pcf)
{
    pcf->cbSize = sizeof(CHARFORMAT);
    
    SendMessage(m_hwnd, EM_SETCHARFORMAT, TRUE, (LPARAM)pcf);
}


HRESULT CMsgSource::SetDirty(BOOL fDirty)
{
    Edit_SetModify(m_hwnd, fDirty);
    return S_OK;
}



HRESULT CMsgSource::_GetText(LPSTR *ppsz)
{
    LPSTR   psz;
    int     cch;

    *ppsz = 0;

    cch = GetWindowTextLength(m_hwnd);
        
    if (!MemAlloc((LPVOID *)&psz, sizeof(TCHAR) * cch+1))
        return E_OUTOFMEMORY;

    *psz = 0;
    GetWindowText(m_hwnd, psz, cch);
    *ppsz = psz;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bytebuff.cpp ===
// --------------------------------------------------------------------------------
// ByteBuff.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bytebuff.h"

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
CByteBuffer::CByteBuffer(LPBYTE pb /* =NULL */, ULONG cbAlloc /* =0 */, ULONG cb /* =0 */, ULONG i /* =0 */)
{
    m_cRef = 1;
    m_dwState = 0;
    m_cbGrow = BYTEBUFF_GROW;
    m_buffer.pb = pb;
    m_buffer.pbStatic = pb;
    m_buffer.cbAlloc = cbAlloc;
    m_buffer.cb = cb;
    m_buffer.i = i;
}

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
void CByteBuffer::Init(LPBYTE pb, ULONG cbAlloc, ULONG cb, ULONG i)
{
    m_buffer.pb = pb;
    m_buffer.cb = cb;
    m_buffer.i = i;
    m_buffer.cbAlloc = cbAlloc;
    m_buffer.pbStatic = pb;
}

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
CByteBuffer::~CByteBuffer(void)
{
    // Free memory if not equal to static
    if (m_buffer.pb != m_buffer.pbStatic)
        g_pMalloc->Free(m_buffer.pb);
}

// --------------------------------------------------------------------------------
// CByteBuffer::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteBuffer::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CByteBuffer::_HrRealloc
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::_HrRealloc(DWORD cbAlloc)
{
    // Locals
    HRESULT     hr=S_OK;
    LPBYTE      pbAlloc=NULL;

    // This should have been checked
    Assert(cbAlloc > m_buffer.cbAlloc);

    // Currently using static ?
    if (m_buffer.pb == m_buffer.pbStatic)
    {
        // Allocate
        CHECKALLOC(pbAlloc = (LPBYTE)g_pMalloc->Alloc(cbAlloc));

        // Copy Data into pbAlloc
        CopyMemory(pbAlloc, m_buffer.pb, min(cbAlloc, m_buffer.cb));
    }

    // Otherwise, realloc
    else
    {
        // Reallocate
        CHECKALLOC(pbAlloc = (LPBYTE)g_pMalloc->Realloc(m_buffer.pb, cbAlloc));
    }

    // Save pbAlloc
    m_buffer.pb = pbAlloc;

    // Save cbAlloc
    m_buffer.cbAlloc = cbAlloc;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteBuffer::Append
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::Append(LPBYTE pbData, ULONG cbData)
{
    // Locals
    HRESULT hr=S_OK;

    // Get Bigger and need to allocate
    if (m_buffer.cb + cbData > m_buffer.cbAlloc)
    {
        // Realloc
        CHECKHR(hr = _HrRealloc(m_buffer.cb + cbData + m_cbGrow));
    }

    // Append the data
    CopyMemory(m_buffer.pb + m_buffer.cb, pbData, cbData);

    // Save Size
    m_buffer.cb += cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteBuffer::SetSize
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::SetSize(DWORD cb)
{
    // Locals
    HRESULT hr=S_OK;

    // Get Bigger and need to allocate
    if (cb > m_buffer.cb && cb > m_buffer.cbAlloc)
    {
        // Realloc
        CHECKHR(hr = _HrRealloc(cb + m_cbGrow));
    }

    // Save Size
    m_buffer.cb = cb;

    // Adjust Index
    if (m_buffer.i > cb)
        m_buffer.i = cb;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\bytebuff.h ===
// --------------------------------------------------------------------------------
// ByteBuff.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef _BYTEBUFF_H
#define _BYTEBUFF_H

// --------------------------------------------------------------------------------
// Default Grow Amount
// --------------------------------------------------------------------------------
#define BYTEBUFF_GROW        256

// --------------------------------------------------------------------------------
// WBS_xxx - WebBuffer State
// --------------------------------------------------------------------------------
#define BBS_LAST     0x00000001      // Last Buffer     

// --------------------------------------------------------------------------------
// BUFFERINFO
// --------------------------------------------------------------------------------
typedef struct tagBUFFERINFO {       
    LPBYTE          pb;              // Current buffer
    DWORD           cb;              // Current Byte Count
    DWORD           i;               // Current Index
    DWORD           cbAlloc;         // Sizeof(m_pb)
    LPBYTE          pbStatic;        // Passed in, dont free
} BUFFERINFO, *LPBUFFERINFO;

// --------------------------------------------------------------------------------
// CByteBuffer
// --------------------------------------------------------------------------------
class CByteBuffer : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CByteBuffer(LPBYTE pb=NULL, ULONG cbAlloc=0, ULONG cb=0, ULONG i=0);
    ~CByteBuffer(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void) { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CByteBuffer Methods
    // ----------------------------------------------------------------------------
    void Init(LPBYTE pb=NULL, ULONG cbAlloc=0, ULONG cb=0, ULONG i=0);
    void SetGrowBy(DWORD cbGrow) { m_cbGrow = cbGrow; }
    const LPBYTE PbData(void) { return ((0 == m_buffer.cb) ? NULL : (const LPBYTE)(m_buffer.pb)); }
    const DWORD CbData(void) { return m_buffer.cb; }
    void SetIndex(DWORD i) { m_buffer.i = i; }
    HRESULT SetSize(DWORD cb);
    HRESULT Append(LPBYTE pbData, ULONG cbData); 

private:
    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    HRESULT _HrRealloc(DWORD cbAlloc);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference count
    DWORD           m_dwState;          // State
    DWORD           m_cbGrow;           // Grow Amount
    BUFFERINFO      m_buffer;           // Buffer
};

#endif // _BYTEBUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\booktree.h ===
// --------------------------------------------------------------------------------
// BookTree.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BOOKTREE_H
#define __BOOKTREE_H

// --------------------------------------------------------------------------------
// Depends On
// --------------------------------------------------------------------------------
#include "mimeole.h"
#include "privunk.h"
#include "variantx.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CBindStream;
class CMessageBody;
class CMessageWebPage;
typedef struct tagTEMPFILEINFO *LPTEMPFILEINFO;
typedef CMessageBody *LPMESSAGEBODY;
class CStreamLockBytes;
class CInternetStream;
class CMimePropertySet;
class CMessageTree;
class CBodyLockBytes;
class CActiveUrl;
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagRESOLVEURLINFO *LPRESOLVEURLINFO;
typedef class CActiveUrlRequest *LPURLREQUEST;

#define AthFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags) \
        CchFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags, \
        GetDateFormatWrapW, GetTimeFormatWrapW, GetLocaleInfoWrapW)


// --------------------------------------------------------------------------------
// For the Product Version
// --------------------------------------------------------------------------------
#include <ntverp.h>

// --------------------------------------------------------------------------------
// GUIDs
// --------------------------------------------------------------------------------
// {FD853CD8-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(IID_CMessageTree, 0xfd853cd8, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define VER_BODYTREEV2          0x00000001  // Version of the persisted body tree format
#define CCHMAX_BOUNDARY         71
#define STR_MIMEOLE_VERSION     "Produced By Microsoft MimeOLE V" VER_PRODUCTVERSION_STR
#define TREE_MIMEVERSION        1
#define CFORMATS_IDATAOBJECT    5          // Max number of formats in IDataObject impl

// --------------------------------------------------------------------------------
// Cache Node Signing
// --------------------------------------------------------------------------------
#define DwSignNode(_info, _index)           (DWORD)MAKELONG(_info.wSignature, _index)
#define FVerifySignedNode(_info, _snode)    (BOOL)(LOWORD(_snode) == _info.wSignature && HIWORD(_snode) < _info.cNodes)
#define PNodeFromSignedNode(_snode)         (m_rTree.prgpNode[HIWORD(_snode)])

// --------------------------------------------------------------------------------
// HBODY Macros
// --------------------------------------------------------------------------------
#define HBODYMAKE(_index)          (HBODY)MAKELPARAM(m_wTag, _index)
#define HBODYINDEX(_hbody)         (ULONG)HIWORD(_hbody)
#define HBODYTAG(_hbody)           (WORD)LOWORD(_hbody)

// --------------------------------------------------------------------------------
// TEXTTYPEINFO
// --------------------------------------------------------------------------------
typedef struct tagTEXTTYPEINFO {
    DWORD               dwTxtType;      // Text Type Flag
    LPCSTR              pszSubType;     // Text Subtype (plain)
    DWORD               dwWeight;       // Text Alternative Weight
} TEXTTYPEINFO, *LPTEXTTYPEINFO;

// --------------------------------------------------------------------------------
// CACHEINFOV2
// --------------------------------------------------------------------------------
typedef struct tagCACHEINFOV2 {
    WORD                wVersion;           // Version of the BIDXTABLE
    WORD                wSignature;         // Used to sign the nodes
    DWORD               dwReserved;         // Reserved
    DWORD               cbMessage;          // Size of the message this index was created for
    DWORD               iRoot;              // Zero-Based index of root node
    DWORD               cNodes;             // Number of nodes in the tree
    DWORD               rgReserved[6];      // Reserve 6 DWORDS for future use
} CACHEINFOV2, *LPCACHEINFOV2;

// --------------------------------------------------------------------------------
// CACHENODEV2
// --------------------------------------------------------------------------------
typedef struct tagCACHENODEV2 {
    DWORD               dwType;             // Flags for this node    
    DWORD               cChildren;          // Number of children
    DWORD               iParent;            // Index of parent of this node
    DWORD               iPrev;              // Index of next sibling to this node
    DWORD               iNext;              // Index of next sibling to this node
    DWORD               iChildHead;         // Index of first child
    DWORD               iChildTail;         // Tail Child
    DWORD               cbBodyStart;        // Byte offset to body start
    DWORD               cbBodyEnd;          // Byte offset to body end
    DWORD               cbHeaderStart;      // Byte offset to start of header
    DWORD               dwReserved;         // Not Used
    DWORD               dwBoundary;         // Boundary Type for this body
    DWORD               cbBoundaryStart;    // Byte offset to starting boundary
    DWORD               rgReserved[10];     // Reserve 6 DWORDS for future use
} CACHENODEV2, *LPCACHENODEV2;

// --------------------------------------------------------------------------------
// BINDNODESTATE
// --------------------------------------------------------------------------------
typedef enum tagBINDNODESTATE {
    BINDSTATE_COMPLETE=0,                   // The bind is complete
    BINDSTATE_PARSING_HEADER,               // Parsing a header
    BINDSTATE_FINDING_MIMEFIRST,            // Finding mime start boundary
    BINDSTATE_FINDING_MIMENEXT,             // Reading body to end mime boundary
    BINDSTATE_FINDING_UUBEGIN,              // begin uuencode
    BINDSTATE_FINDING_UUEND,                // End uuencode
    BINDSTATE_PARSING_RFC1154,              // Parsing an RFC1154 message
    BINDSTATE_LAST                          // Don't Use
} BINDNODESTATE;

// --------------------------------------------------------------------------------
// BOUNDARYTYPE
// --------------------------------------------------------------------------------
typedef enum tagBOUNDARYTYPE {
    BOUNDARY_NONE       = 0,                // No Boundary  
    BOUNDARY_ROOT       = 1,                // This is the root boundary (0)
    BOUNDARY_MIMEEND    = 3,                // Terminating mime boundary
    BOUNDARY_MIMENEXT   = 4,                // Mime Boundary non-terminating
    BOUNDARY_UUBEGIN    = 5,                // UUENCODE begining boundary
    BOUNDARY_UUEND      = 6,                // UUENCODE ending boundary
    BOUNDARY_LAST       = 7                 // Don't use
} BOUNDARYTYPE;

// --------------------------------------------------------------------------------
// PFNBINDPARSER
// --------------------------------------------------------------------------------
typedef HRESULT (CMessageTree::*PFNBINDPARSER)(THIS_);

// --------------------------------------------------------------------------------
// Node Flags
// --------------------------------------------------------------------------------
#define NODETYPE_INCOMPLETE         FLAG01  // The body's boundries do not match
#define NODETYPE_FAKEMULTIPART      FLAG02  // The body is a fake multipart    
#define NODETYPE_RFC1154_ROOT       FLAG03  // The body is the root of an RFC1154
#define NODETYPE_RFC1154_BINHEX     FLAG04  // The body is BINHEX from RFC1154

// --------------------------------------------------------------------------------
// Node State
// --------------------------------------------------------------------------------
#define NODESTATE_MESSAGE           FLAG01  // We are parsing a message/rfc822 body
#define NODESTATE_VERIFYTNEF        FLAG02  // Verify tnef signature after HrBindToTree
#define NODESTATE_BOUNDNOFREE       FLAG03  // Don't free BINDPARSEINFO::rBoundary (it is a copy)
#define NODESTATE_BOUNDTOTREE       FLAG04  // IMimeBody::HrBindToTree(pNode) has been called
#define NODESTATE_ONWEBPAGE         FLAG05  // CMessageWebPage has renedered the start body from this multipart/related body
#define NODESTATE_INSLIDESHOW       FLAG06  // CMessageWebPage will render this body in a slide show
#define WEBPAGE_NODESTATE_BITS      (NODESTATE_ONWEBPAGE | NODESTATE_INSLIDESHOW)
#define NODESTATE_AUTOATTACH        FLAG07  // Marked as an attachment in _HandleCanInlineTextOption

// --------------------------------------------------------------------------------
// TREENODEINFO
// --------------------------------------------------------------------------------
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef struct tagTREENODEINFO {
    HBODY               hBody;              // Index of this body in BODYTABLE::prgpBody
    DWORD               dwType;             // NODETYPE_xxx Flags
    DWORD               dwState;            // NODESTATE_xxx Flags
    HRESULT             hrBind;             // Bind Result
    ULONG               cChildren;          // Number of chilren if cnttype == CNT_MULTIPART
    DWORD               iCacheNode;         // Used for saving
    BINDNODESTATE       bindstate;          // Current parsing state
    PROPSTRINGA         rBoundary;          // Boundary
    BOUNDARYTYPE        boundary;           // Boundary Type for this body
    DWORD               cbBoundaryStart;    // Byte offset to starting boundary
    DWORD               cbHeaderStart;      // Byte offset to start of header
    DWORD               cbBodyStart;        // Byte offset to body start
    DWORD               cbBodyEnd;          // Byte offset to body end
    LPURLREQUEST        pResolved;          // Head Binding Requests
    LPTREENODEINFO      pBindParent;        // BindStackPrevious Node
    LPTREENODEINFO      pParent;            // Parent body
    LPTREENODEINFO      pNext;              // Next Sibling
    LPTREENODEINFO      pPrev;              // Previous Sibling
    LPTREENODEINFO      pChildHead;         // Handle to first child (if multipart)
    LPTREENODEINFO      pChildTail;         // Handle to first child (if multipart)
    LPCONTAINER         pContainer;         // The parsed header
    CBodyLockBytes     *pLockBytes;         // The binded tree data
    LPMESSAGEBODY       pBody;              // The body object for this tree node
} TREENODEINFO;                              

// --------------------------------------------------------------------------------
// TREENODETABLE
// --------------------------------------------------------------------------------
typedef struct tagTREENODETABLE {
    ULONG               cNodes;             // Number of valid elements in prgpBody
    ULONG               cEmpty;             // Number of empty cells in prgpBody
    ULONG               cAlloc;             // Number of elements allocated in prgpBody
    LPTREENODEINFO     *prgpNode;           // Array of pointers to bindinfo structs
} TREENODETABLE, *LPTREENODETABLE;

// --------------------------------------------------------------------------------
// Tree State
// --------------------------------------------------------------------------------
#define TREESTATE_DIRTY            FLAG01   // The tree is dirty
//#define TREESTATE_BOUND            FLAG02   // Load & LoadOffsetTable has bound success
#define TREESTATE_LOADED           FLAG03   // LoadOffsetTable has success
#define TREESTATE_HANDSONSTORAGE   FLAG04   // I have AddRef'ed somebodies storage
#define TREESTATE_SAVENEWS         FLAG05   // We are saving a news message    
#define TREESTATE_REUSESIGNBOUND   FLAG06   // Saving multipart/signed reuse boundary
#define TREESTATE_BINDDONE         FLAG07   // The bind operation is complete    
#define TREESTATE_BINDUSEFILE      FLAG08   // Hands off storage OnStopBinding
#define TREESTATE_LOADEDBYMONIKER  FLAG09   // IPersistMoniker::Load was called to load this
#define TREESTATE_RESYNCHRONIZE    FLAG10

// --------------------------------------------------------------------------------
// More Save Body Flags
// --------------------------------------------------------------------------------
#define SAVEBODY_UPDATENODES       FLAG32   // Update the node offsets to point to the new stream
#define SAVEBODY_SMIMECTE          FLAG31   // Change CTE rules for S/MIME bodies
#define SAVEBODY_REUSECTE          FLAG30   // Force CTE to be re-used

// --------------------------------------------------------------------------------
// Tree Options
// if you add anything to this struct, you *must* update g_rDefTreeOptions
// in imsgtree.cpp
// --------------------------------------------------------------------------------
typedef struct tagTREEOPTIONS {
    BYTE                fCleanupTree;       // Cleanup Tree On Save ?
    BYTE                fHideTnef;          // HIDE TNEF attachments?
    BYTE                fAllow8bitHeader;   // Allow 8bit in header
    BYTE                fGenMessageId;      // Should I generate the message id ?
    BYTE                fWrapBodyText;      // Wrap Body Text
    ULONG               cchMaxHeaderLine;   // Max header line length
    ULONG               cchMaxBodyLine;     // Max body line length
    MIMESAVETYPE        savetype;           // Commit type
    LPINETCSETINFO      pCharset;           // Current Character Set
    CSETAPPLYTYPE       csetapply;          // Method in which to use m_hCharset
    ENCODINGTYPE        ietTextXmit;        // Text transfer encoding
    ENCODINGTYPE        ietPlainXmit;       // Transmit Text Format
    ENCODINGTYPE        ietHtmlXmit;        // Transmit Text Format
    ULONG               ulSecIgnoreMask;    // Mask of ignorable errors
    RELOADTYPE          ReloadType;         // How the the root header be treated on a reload
    BOOL                fCanInlineText;     // Can the client inline multiple text bodies
    BOOL                fShowMacBin;        // Can the client handle macbinary??
    BOOL                fKeepBoundary;      // OID_SAVEBODY_KEEPBOUNDARY
    BOOL                fBindUseFile;       // If TRUE, I duplicate the stream on load
    BOOL                fHandsOffOnSave;    // Don't Hold onto pStream after IMimeMessage::Save
    BOOL                fExternalBody;      // Handle message/external-body
    BOOL                fDecodeRfc1154;     // Decode using RFC1154 (aka Encoding: header)
    // if you add anything to this struct, you *must* update g_rDefTreeOptions
    // in imsgtree.cpp
} TREEOPTIONS, *LPTREEOPTIONS;

// --------------------------------------------------------------------------------
// BOOKTREERESET - Used with _ResetObject
// --------------------------------------------------------------------------------
typedef enum tagBOOKTREERESET {
    BOOKTREE_RESET_DECONSTRUCT,
    BOOKTREE_RESET_LOADINITNEW,
    BOOKTREE_RESET_INITNEW
} BOOKTREERESET;

// --------------------------------------------------------------------------------
// BOOKTREE1154 - Used for RFC1154 Handling
// --------------------------------------------------------------------------------
typedef enum tagBT1154ENCODING {    // Body encoding type
    BT1154ENC_MINIMUM=0,
    BT1154ENC_TEXT=0,                   // text body
    BT1154ENC_UUENCODE=1,               // uuencoded body
    BT1154ENC_BINHEX=2,                 // binhex body
    BT1154ENC_MAXIMUM=2
} BT1154ENCODING;

typedef struct tagBT1154BODY {      // Info about one body
    BT1154ENCODING  encEncoding;        // Body encoding type
    ULONG           cLines;             // Number of lines in the body
} BT1154BODY;

typedef struct tagBOOKTREE1154 {    // Info about the state of RFC1154 handling
    ULONG       cBodies;                // Count of the number of bodies
    ULONG       cCurrentBody;           // The index of the current body (zero-based)
    ULONG       cCurrentLine;           // The current line number in the current body
    HRESULT     hrLoadResult;           // The result of the load.
    BT1154BODY  aBody[1];               // The bodies
} BOOKTREE1154, *LPBOOKTREE1154;

// --------------------------------------------------------------------------------
// CMessageTree Definition
// --------------------------------------------------------------------------------
class CMessageTree : public CPrivateUnknown,
                     public IMimeMessageW, 
                     public IDataObject,
                     public IPersistFile,
                     public IPersistMoniker,
                     public IServiceProvider,
#ifdef SMIME_V3
                     public IMimeSecurity2, 
#endif // SMIME_V3
                     public IBindStatusCallback
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMessageTree(IUnknown *pUnkOuter=NULL);
    virtual ~CMessageTree(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // ---------------------------------------------------------------------------
    // IDataObject members
    // ---------------------------------------------------------------------------
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFormatIn, FORMATETC *pFormatOut);
    STDMETHODIMP GetData(FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP GetDataHere(FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP QueryGetData(FORMATETC *pFormat);
    STDMETHODIMP SetData(FORMATETC *pFormat, STGMEDIUM *pMedium, BOOL fRelease) { 
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP DAdvise(FORMATETC *pFormat, DWORD, IAdviseSink *pAdvise, DWORD *pdwConn) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP DUnadvise(DWORD dwConn) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppEnum) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }

    // ---------------------------------------------------------------------------
    // IPersist Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // ---------------------------------------------------------------------------
    // IPersistMoniker Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    STDMETHODIMP GetCurMoniker(IMoniker **ppMoniker);
    STDMETHODIMP Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx) {
        return TrapError(E_NOTIMPL); }

    // ---------------------------------------------------------------------------
    // IPersistStreamInit Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);

    // ---------------------------------------------------------------------------
    // IPersistFile Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);

    // ----------------------------------------------------------------------------
    // IServiceProvider methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void **ppvObj); /* IServiceProvider */

    // ---------------------------------------------------------------------------
    // IBindStatusCallback
    // ---------------------------------------------------------------------------
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding *pBinding);
    STDMETHODIMP GetPriority(LONG *plPriority);
    STDMETHODIMP OnLowResource(DWORD reserved);
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText);
    STDMETHODIMP OnStopBinding(HRESULT hrResult, LPCWSTR pszError);
    STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pBindInfo);
    STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *pUnknown) { return TrapError(E_NOTIMPL); }

    // ---------------------------------------------------------------------------
    // IMimeMessageTree members
    // ---------------------------------------------------------------------------
    STDMETHODIMP LoadOffsetTable(IStream *pStream);
    STDMETHODIMP SaveOffsetTable(IStream *pStream, DWORD dwFlags);
    STDMETHODIMP GetMessageSize(ULONG *pcbSize, DWORD dwFlags);
    STDMETHODIMP Commit(DWORD dwFlags);
    STDMETHODIMP HandsOffStorage(void);
    STDMETHODIMP IsBodyType(HBODY hBody, IMSGBODYTYPE bodytype);
    STDMETHODIMP SaveBody(HBODY hBody, DWORD dwFlags, IStream *pStream);
    STDMETHODIMP BindToObject(const HBODY hBody, REFIID riid, void **ppvObject);
    STDMETHODIMP InsertBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody);
    STDMETHODIMP GetBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody);
    STDMETHODIMP DeleteBody(HBODY hBody, DWORD dwFlags);
    STDMETHODIMP MoveBody(HBODY hBody, BODYLOCATION location);
    STDMETHODIMP CountBodies(HBODY hParent, boolean fRecurse, ULONG *pcBodies);
    STDMETHODIMP FindFirst(LPFINDBODY pFindBody, LPHBODY phBody);
    STDMETHODIMP FindNext(LPFINDBODY pFindBody, LPHBODY phBody);
    STDMETHODIMP GetMessageSource(IStream **ppStream, DWORD dwFlags);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP ToMultipart(HBODY hBody, LPCSTR pszSubType, LPHBODY phMultipart);
    STDMETHODIMP GetBodyOffsets(HBODY hBody, LPBODYOFFSETS pOffsets);
    STDMETHODIMP IsContentType(HBODY hBody, LPCSTR pszCntType, LPCSTR pszSubType);
    STDMETHODIMP QueryBodyProp(HBODY hBody, LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeleteBodyProp(HBODY hBody, LPCSTR pszName);
    STDMETHODIMP GetFlags(DWORD *pdwFlags);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP ResolveURL(HBODY hRelated, LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, LPHBODY phBody);

    // ---------------------------------------------------------------------------
    // IMimeMessage members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetRootMoniker(LPMONIKER *ppmk); /* will die soon */
    STDMETHODIMP CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, IMimeMessageCallback *pCallback, IMoniker **ppMoniker);
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, IStream **ppStream, LPHBODY phBody);
    STDMETHODIMP SetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, HBODY hAlternative, IStream *pStream, LPHBODY phBody);
    STDMETHODIMP AttachObject(REFIID riid, void *pvObject, LPHBODY phBody);
    STDMETHODIMP AttachFile(LPCSTR pszFilePath, IStream *pstmFile, LPHBODY phBody);
    STDMETHODIMP GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach);
    STDMETHODIMP AttachURL(LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, IStream *pstmURL, LPSTR *ppszCID, LPHBODY phBody);
    STDMETHODIMP SplitMessage(ULONG cbMaxPart, IMimeMessageParts **ppParts);
    STDMETHODIMP GetAddressTable(IMimeAddressTable **ppTable);
    STDMETHODIMP GetSender(LPADDRESSPROPS pAddress);
    STDMETHODIMP GetAddressTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList);
    STDMETHODIMP GetAddressFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat);
    STDMETHODIMP EnumAddressTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum);

    // ---------------------------------------------------------------------------
    // IMimeMessageW members
    // ---------------------------------------------------------------------------
    STDMETHODIMP AttachFileW(LPCWSTR pszFilePath, IStream *pstmFile, LPHBODY phBody);
    STDMETHODIMP GetAddressFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppszFormat);
    STDMETHODIMP GetPropW(LPCWSTR pwszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetPropW(LPCWSTR pwszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeletePropW(LPCWSTR pwszName);
    STDMETHODIMP QueryPropW(LPCWSTR pwszName, LPCWSTR pwszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP AttachURLW(LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, IStream *pstmURL, LPWSTR *ppwszCID, LPHBODY phBody);
    STDMETHODIMP ResolveURLW(HBODY hRelated, LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, LPHBODY phBody);


#ifdef SMIME_V3
    // ---------------------------------------------------------------------------
    // IMimeSecurity2 members
    // ---------------------------------------------------------------------------

    STDMETHODIMP Encode(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pfn);
    STDMETHODIMP GetRecipientCount(DWORD dwFlags, DWORD *pdwRecipCount);
    STDMETHODIMP AddRecipient(DWORD dwFlags, DWORD cRecipData, PCMS_RECIPIENT_INFO recipData);
    STDMETHODIMP GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData);
    STDMETHODIMP DeleteRecipient(DWORD dwFlgas, DWORD iRecipient, DWORD cRecipients);
    STDMETHODIMP GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              DWORD iInstance, LPCSTR pszObjId,
                              CRYPT_ATTRIBUTE ** ppattr);
    STDMETHODIMP SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              const CRYPT_ATTRIBUTE * pattr);
    STDMETHODIMP DeleteAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                                 DWORD iInstance, LPCSTR pszObjid);
    STDMETHODIMP CreateReceipt(DWORD dwFlags, DWORD cbFromNames, const BYTE * pbFromNames, DWORD cSignerCertificates, PCCERT_CONTEXT * rgSignerCertificates, IMimeMessage ** ppMimeMessageRecipient);
    STDMETHODIMP GetReceiptSendersList(DWORD dwFlags, DWORD * pcSendersList, CERT_NAME_BLOB ** rgSendersList);
    STDMETHODIMP VerifyReceipt(DWORD dwFlags, IMimeMessage * pMimeMesageReceipt);
    STDMETHODIMP CapabilitiesSupported(DWORD * pdwFeatures);
#endif // SMIME_V3

    // ---------------------------------------------------------------------------
    // CMessageTree members
    // ---------------------------------------------------------------------------
    HRESULT IsState(DWORD dwState);
    DWORD   DwGetFlags(void);
    void    ClearDirty(void);
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    void SetState(DWORD dwState) {
        EnterCriticalSection(&m_cs);
        FLAGSET(m_dwState, dwState);
        LeaveCriticalSection(&m_cs);
    }

    // ---------------------------------------------------------------------------
    // Active Url Caching Methods
    // ---------------------------------------------------------------------------
    HRESULT HrActiveUrlRequest(LPURLREQUEST pRequest);
    HRESULT CompareRootUrl(LPCSTR pszUrl);
    HRESULT SetActiveUrl(CActiveUrl *pActiveUrl);

    // ---------------------------------------------------------------------------
    // CMessageTree members
    // ---------------------------------------------------------------------------
#ifdef DEBUG
    void DebugDumpTree(LPSTR pszfunc, BOOL fWrite);
    void DebugDumpTree(LPTREENODEINFO pParent, ULONG ulLevel, BOOL fVerbose);
    void DebugAssertNotLinked(LPTREENODEINFO pBody);
    void DebugWriteXClient();
#endif

private:
    // ----------------------------------------------------------------------------
    // Save Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrApplySaveSecurity(void);
    HRESULT _HrWriteMessage(IStream *pStream, BOOL fClearDirty, BOOL fHandsOffOnSave,
                            BOOL fSMimeCTE);
    HRESULT _HrCleanupMessageTree(LPTREENODEINFO pParent);
    HRESULT _HrSetMessageId(LPTREENODEINFO pNode);
    HRESULT _HrWriteUUFileName(IStream *pStream, LPTREENODEINFO pNode);
    HRESULT _HrWriteHeader(BOOL fClearDirty, IStream *pStream, LPTREENODEINFO pNode);
    HRESULT _HrWriteBoundary(LPSTREAM pStream, LPSTR pszBoundary, BOUNDARYTYPE boundary, LPDWORD pcboffStart, LPDWORD pcboffEnd);
    HRESULT _HrBodyInheritOptions(LPTREENODEINFO pNode);
    HRESULT _HrSaveBody(BOOL fClearDirty, DWORD dwFlags, IStream *pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrSaveMultiPart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrSaveSinglePart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrComputeBoundary(LPTREENODEINFO pNode, ULONG ulLevel, LPSTR pszBoundary, LONG cchMax);
    void    _GenerateBoundary(LPSTR pszBoundary, DWORD cchSize, ULONG ulLevel);
    void    _HandleCanInlineTextOption(void);
    HRESULT _GetContentTransferEncoding(LPTREENODEINFO pNode, BOOL fText, BOOL fPlain, BOOL fMessage, BOOL fAttachment, DWORD dwFlags, ENCODINGTYPE *pietEncoding);

    // ----------------------------------------------------------------------------
    // BindToOffsetTable Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrBindOffsetTable(IStream *pStream, CStreamLockBytes **ppStmLock);
    HRESULT _HrFastParseBody(CInternetStream *pInternet, LPTREENODEINFO pNode);
    HRESULT _HrValidateOffsets(LPTREENODEINFO pNode);
    HRESULT _HrValidateStartBoundary(CInternetStream *pInternet, LPTREENODEINFO pNode, LPSTR *ppszFileName);
    HRESULT _HrComputeDefaultContent(LPTREENODEINFO pNode, LPCSTR pszFileName);

    // ----------------------------------------------------------------------------
    // Allocators / De-Allocator Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrCreateTreeNode(LPTREENODEINFO *ppNode);
    HRESULT _HrAllocateTreeNode(ULONG ulIndex);
    void    _PostCreateTreeNode(HRESULT hrResult, LPTREENODEINFO pNode);
    void    _FreeNodeTableElements(void);
    void    _UnlinkTreeNode(LPTREENODEINFO pNode);
    void    _FreeTreeNodeInfo(LPTREENODEINFO pNode, BOOL fFull=TRUE);

    // ----------------------------------------------------------------------------
    // International Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrSetCharsetTree(LPTREENODEINFO pNode, HCHARSET hCharset, CSETAPPLYTYPE applytype);
    HRESULT _HrGetCharsetTree(LPTREENODEINFO pNode, LPHCHARSET phCharset);

    // ----------------------------------------------------------------------------
    // Boundary Methods
    // ----------------------------------------------------------------------------
    BOOL    _FIsUuencodeBegin(LPPROPSTRINGA pLine, LPSTR *ppszFileName);
    BOUNDARYTYPE _GetMimeBoundaryType(LPPROPSTRINGA pLine, LPPROPSTRINGA pBoundary);

    // ----------------------------------------------------------------------------
    // Interface Recursion and Helper Methods
    // ----------------------------------------------------------------------------
    void    _DeleteChildren(LPTREENODEINFO pParent);
    void    _CountChildrenInt(LPTREENODEINFO pParent, BOOL fRecurse, ULONG *pcChildren);
    void    _InitNewWithoutRoot(void);
    void    _ApplyOptionToAllBodies(const TYPEDID oid, LPCPROPVARIANT pValue);
    void    _FuzzyPartialRecognition(BOOL fIsMime);
    void    _ResetObject(BOOKTREERESET ResetType);    
    void    _RecursiveGetFlags(LPTREENODEINFO pNode, LPDWORD pdwFlags, BOOL fInRelated);
    BOOL    _FIsValidHandle(HBODY hBody);
    HRESULT _HrLoadInitNew(void);
    HRESULT _HrDeletePromoteChildren(LPTREENODEINFO pNode);
    HRESULT _HrNodeFromHandle(HBODY hBody, LPTREENODEINFO *ppNode);
    HRESULT _HrRecurseResolveURL(LPTREENODEINFO pRelated, LPRESOLVEURLINFO pInfo, LPHBODY phBody);
    HRESULT _HrEnumeratAttachments(HBODY hBody, ULONG *pcBodies, LPHBODY prghBody);
    HRESULT _HrDataObjectGetHeaderA(LPSTREAM pStream);
    HRESULT _HrDataObjectGetHeaderW(LPSTREAM pStream);
    HRESULT _HrDataObjectWriteHeaderA(LPSTREAM pStream, UINT idsHeader, LPSTR pszData);
    HRESULT _HrDataObjectWriteHeaderW(LPSTREAM pStream, UINT idsHeader, LPWSTR pwszData);
    HRESULT _HrDataObjectGetSource(CLIPFORMAT cfFormat, LPSTREAM pstmData);
    HRESULT _HrGetTextTypeInfo(DWORD dwTxtType, LPTEXTTYPEINFO *ppTextInfo);
    HRESULT _FindDisplayableTextBody(LPCSTR pszSubType, LPTREENODEINFO pNode, LPHBODY phBody);
    LPTREENODEINFO _PNodeFromHBody(HBODY hBody);

    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    void    _LinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead);
    void    _ReleaseUrlRequestList(LPURLREQUEST *ppHead);
    void    _UnlinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead);
    void    _RelinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppSource, LPURLREQUEST *ppDest);
    HRESULT _HrBindNodeComplete(LPTREENODEINFO pNode, HRESULT hrResult);
    HRESULT _HrOnFoundMultipartEnd(void);
    HRESULT _HrOnFoundNodeEnd(DWORD cbBoundaryStart, HRESULT hrBind=S_OK);
    HRESULT _HrProcessPendingUrlRequests(void);
    HRESULT _HrResolveUrlRequest(LPURLREQUEST pRequest, BOOL *pfResolved);
    HRESULT _HrMultipartMimeNext(DWORD cboffBoundary);
    HRESULT _HrInitializeStorage(IStream *pStream);
    HRESULT _HrBindTreeNode(LPTREENODEINFO pNode);
    HRESULT _HrSychronizeWebPage(LPTREENODEINFO pNode);
    void    _DecodeRfc1154();

    // ----------------------------------------------------------------------------
    // Bind State Handlers
    // ----------------------------------------------------------------------------
    HRESULT _HrBindParsingHeader(void);
    HRESULT _HrBindFindingMimeFirst(void);
    HRESULT _HrBindFindingMimeNext(void);
    HRESULT _HrBindFindingUuencodeBegin(void);
    HRESULT _HrBindFindingUuencodeEnd(void);
    HRESULT _HrBindRfc1154(void);

    // ----------------------------------------------------------------------------
    // Static Array of Function Pointers
    // ----------------------------------------------------------------------------
    static const PFNBINDPARSER m_rgBindStates[BINDSTATE_LAST];

    // ----------------------------------------------------------------------------
    // CMessageWebPage is a good friend
    // ----------------------------------------------------------------------------
    friend CMessageWebPage;

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    TREEOPTIONS             m_rOptions;         // Save options
    LPWSTR                  m_pwszFilePath;     // File Used in IPersistFile
    WORD                    m_wTag;             // HBODY Tag
    DWORD                   m_cbMessage;        // Sizeof message
    DWORD                   m_dwState;          // State of the tree TS_xxx
    LPTREENODEINFO          m_pRootNode;        // Root Body Object
    CStreamLockBytes       *m_pStmLock;         // Protective Wrapper for m_pStream
    IMoniker               *m_pMoniker;         // Current moniker
    IBinding               *m_pBinding;         // Used in async binding operation
    CInternetStream        *m_pInternet;        // Text Stream that wraps m_pStmLock
    CBindStream            *m_pStmBind;         // Used for tempfile binding
    IStream                *m_pRootStm;         // Root document stream
    HRESULT                 m_hrBind;           // Current Bind Result
    LPTREENODEINFO          m_pBindNode;        // Current Node being parsed
    LPURLREQUEST            m_pPending;         // Head Un-resolved bind request
    LPURLREQUEST            m_pComplete;        // Head Un-resolved bind request
    TREENODETABLE           m_rTree;            // Body Table
    PROPSTRINGA             m_rRootUrl;         // Moniker Base Url
    CActiveUrl             *m_pActiveUrl;       // Active Url
    CMessageWebPage        *m_pWebPage;         // CreateWebPage Results
    WEBPAGEOPTIONS          m_rWebPageOpt;      // Web Page Options
    IMimeMessageCallback   *m_pCallback;      // WebPage Callback
    BOOL                    m_fApplySaveSecurity;// Used to prevent re-entrancy into _HrWriteMessage
    CRITICAL_SECTION        m_cs;               // Thread Safety
    LPBC                    m_pBC;              // bindcontext for moniker
    BOOKTREE1154           *m_pBT1154;          // State of RFC1154 handling
};

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
typedef CMessageTree *LPMESSAGETREE;

#endif // __BOOKTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\contain2.cpp ===
// --------------------------------------------------------------------------------
// Contain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "internat.h"
#include "inetstm.h"
#include "dllmain.h"
#include "olealloc.h"
#include "objheap.h"
#include "vstream.h"
#include "addparse.h"
#include "enumhead.h"
#include "addrenum.h"
#include "stackstr.h"
#include "stmlock.h"
#include "enumprop.h"
#ifndef WIN16
#include "wchar.h"
#endif // !WIN16
#include "symcache.h"
#ifdef MAC
#include <stdio.h>
#endif  // MAC
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD   g_cSetPidLookups;
extern DWORD   g_cHashLookups;
extern DWORD   g_cHashInserts;
extern DWORD   g_cHashCollides;
#endif

// --------------------------------------------------------------------------------
// Default Header Options
// --------------------------------------------------------------------------------
extern const HEADOPTIONS g_rDefHeadOptions;

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
static const ENCODINGTABLE g_rgEncoding[] = {
    { STR_ENC_7BIT,         IET_7BIT     },
    { STR_ENC_QP,           IET_QP       },
    { STR_ENC_BASE64,       IET_BASE64   },
    { STR_ENC_UUENCODE,     IET_UUENCODE },
    { STR_ENC_XUUENCODE,    IET_UUENCODE },
    { STR_ENC_XUUE,         IET_UUENCODE },
    { STR_ENC_8BIT,         IET_8BIT     },
    { STR_ENC_BINARY,       IET_BINARY   }
};



// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrResolveURL
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrResolveURL(LPRESOLVEURLINFO pURL)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSTRINGA   pBase=NULL;
    LPPROPSTRINGA   pContentID=NULL;
    LPPROPSTRINGA   pLocation=NULL;
    LPSTR           pszAbsURL1=NULL;
    LPSTR           pszAbsURL2=NULL;

    // Invalid Arg
    Assert(pURL);

    // Init Stack Strings
    STACKSTRING_DEFINE(rCleanCID, 255);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Content-Location
    if (m_prgIndex[PID_HDR_CNTLOC])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTLOC]->rValue));
        pLocation = &m_prgIndex[PID_HDR_CNTLOC]->rValue.rStringA;
    }

    // Content-ID
    if (m_prgIndex[PID_HDR_CNTID])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTID]->rValue));
        pContentID = &m_prgIndex[PID_HDR_CNTID]->rValue.rStringA;
    }

    // Content-Base
    if (m_prgIndex[PID_HDR_CNTBASE])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTBASE]->rValue));
        pBase = &m_prgIndex[PID_HDR_CNTBASE]->rValue.rStringA;
    }

    // Both Null, no match
    if (!pLocation && !pContentID)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // If URL is a CID
    if (TRUE == pURL->fIsCID) 
    {
        // If we have a Content-Location
        if (pLocation)
        {
            // Match char for char
            if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pURL->pszURL, FALSE) == S_OK)
                goto exit;
        }

        // Otherwise, compare against pContentId
        else
        {
            // Match char for char minus cid:
            if (lstrcmpi(pURL->pszURL + 4, pContentID->pszVal) == 0)
                goto exit;

            // Get Stack Stream Read for
            STACKSTRING_SETSIZE(rCleanCID, lstrlen(pURL->pszURL));

            // Format the Cleaned CID
            wsprintf(rCleanCID.pszVal, "<%s>", pURL->pszURL + 4);

            // Match char for char minus cid:
            if (lstrcmpi(rCleanCID.pszVal, pContentID->pszVal) == 0)
                goto exit;
        }
    }

    // Otherwise, non-CID resolution
    else if (pLocation)
    {
        // Part Has Base
        if (NULL != pBase)
        {
            // Combine URLs
            CHECKHR(hr = MimeOleCombineURL(pBase->pszVal, pBase->cchVal, pLocation->pszVal, pLocation->cchVal, TRUE, &pszAbsURL1));

            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (lstrcmpi(pURL->pszURL, pszAbsURL1) == 0)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (lstrcmpi(pszAbsURL1, pszAbsURL2) == 0)
                    goto exit;
            }
        }

        // Part has no base
        else
        {
            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pURL->pszURL, FALSE) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pszAbsURL2, FALSE) == S_OK)
                    goto exit;
            }
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Cleanup
    STACKSTRING_FREE(rCleanCID);
    SafeMemFree(pszAbsURL1);
    SafeMemFree(pszAbsURL2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentType
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT hr=S_OK;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && lstrcmpi(pszPriType, STR_CNT_TEXT) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Comparing pszPriType
        if (pszPriType && lstrcmpi(pszPriType, pCntType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Comparing pszSubType
        if (pszSubType && lstrcmpi(pszSubType, pSubType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimePropertySet, (LPVOID *)ppPropertySet));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(LPCONTAINER *ppContainer)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCONTAINER         pContainer=NULL;

    // Invalid ARg
    if (NULL == ppContainer)
        return TrapError(E_INVALIDARG);

    // Init
    *ppContainer = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Create new container, NULL == no outer property set
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init that new container
    CHECKHR(hr = pContainer->InitNew());

    // Interate the Properties
    CHECKHR(hr = _HrClonePropertiesTo(pContainer));

    // If I have a stream, give it to the new table
    if (m_pStmLock)
    {
        // Just pass m_pStmLock into pTable
        pContainer->m_pStmLock = m_pStmLock;
        pContainer->m_pStmLock->AddRef();
        pContainer->m_cbStart = m_cbStart;
        pContainer->m_cbSize = m_cbSize;
    }

    // Give it my state
    pContainer->m_dwState = m_dwState;

    // Give it my options
    pContainer->m_rOptions.pDefaultCharset = m_rOptions.pDefaultCharset;
    pContainer->m_rOptions.cbMaxLine = m_rOptions.cbMaxLine;
    pContainer->m_rOptions.fAllow8bit = m_rOptions.fAllow8bit;

    // Return Clone
    (*ppContainer) = pContainer;
    (*ppContainer)->AddRef();

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrClonePropertiesTo
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrClonePropertiesTo(LPCONTAINER pContainer)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pCurrHash, pCurrValue, pDestProp;

    // Invalid Arg
    Assert(pContainer);

    // Loop through the item table
    for (ULONG i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
        {
            // Walk multiple Values
            for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
            {
                // Linked Attributes are Not Copied
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ATTRIBUTE) && NULL != pCurrValue->pSymbol->pLink)
                    continue;

                // Does the Property need to be parsed ?
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
                {
                    // Make sure the address is parsed
                    CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
                }

                // Insert Copy of pCurrValue into pContiner
                CHECKHR(hr = pContainer->HrInsertCopy(pCurrValue));
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pCurrValue;

    // Walk multiple Values
    for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
    {
        // Does the Property need to be parsed ?
        if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Make sure the address is parsed
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
        }

        // Insert pProperty into pDest
        CHECKHR(hr = pDest->HrInsertCopy(pCurrValue));
    }

    // If pCurrHash has Parameters, copy those over as well
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Copy Parameters
        CHECKHR(hr = _HrCopyParameters(pProperty, pDest));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;
    
    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Remove the parameter
        CHECKHR(hr = pDest->HrInsertCopy(pParameter));

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrInsertCopy
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrInsertCopy(LPPROPERTY pSource)
{
    // Locals
    HRESULT           hr=S_OK;
    LPPROPERTY        pDest;
    LPMIMEADDRESS    pAddress;
    LPMIMEADDRESS    pNew;

    // Invalid Arg
    Assert(pSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Append a new property to the 
    CHECKHR(hr = _HrAppendProperty(pSource->pSymbol, &pDest));

    // If this is an address...
    if (ISFLAGSET(pSource->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Both Address Group Better Exist
        Assert(pSource->pGroup && pDest->pGroup && !ISFLAGSET(pSource->dwState, PRSTATE_NEEDPARSE));

        // Loop Infos...
        for (pAddress=pSource->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Append pDest->pGroup
            CHECKHR(hr = _HrAppendAddressGroup(pDest->pGroup, &pNew));

            // Copy Current to New
            CHECKHR(hr = HrMimeAddressCopy(pAddress, pNew));
        }
    }

    // Otheriwse, just set the variant data on pDest
    else
    {
        // Set It
        CHECKHR(hr = _HrSetPropertyValue(pDest, 0, &pSource->rValue));
    }

    // Copy the State
    pDest->dwState = pSource->dwState;
    pDest->dwRowNumber = pSource->dwRowNumber;
    pDest->cboffStart = pSource->cboffStart;
    pDest->cboffColon = pSource->cboffColon;
    pDest->cboffEnd = pSource->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CopyProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty,
                    pCurrValue,
                    pCurrHash,
                    pNextHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);

                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest));
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);

                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest));
                }
            }
        }
    }

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::MoveProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurrHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            pCurrHash = m_prgHashTable[i];

            // Walk the Hash Chain
            while(pCurrHash)
            {
                // Delete Property from the destination
                pDest->DeleteProp(pCurrHash->pSymbol);

                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest));

                // Delete pProperty
                _UnlinkProperty(pCurrHash, &pCurrHash);
            }
        }
    }

    // Otherwise, selective move
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);

                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest));

                    // Delete pProperty
                    _UnlinkProperty(pProperty);
                }
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetOption(const TYPEDID oid, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        if (pVariant->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        if (m_rOptions.fNoDefCntType != (pVariant->boolVal ? TRUE : FALSE))
            m_rOptions.fNoDefCntType = pVariant->boolVal ? TRUE : FALSE;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bit != (pVariant->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.fAllow8bit = pVariant->boolVal ? TRUE : FALSE;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        if (pVariant->ulVal < MIN_CBMAX_HEADER_LINE || pVariant->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.cbMaxLine = pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pVariant->ulVal && SAVE_RFC1521 != pVariant->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pVariant->ulVal;
        }
        break;    

    // -----------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetOption(const TYPEDID oid, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    pVariant->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        pVariant->ulVal = m_rOptions.ReloadType;
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        pVariant->boolVal = m_rOptions.fNoDefCntType;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        pVariant->boolVal = m_rOptions.fAllow8bit;
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        pVariant->ulVal = m_rOptions.cbMaxLine;
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        pVariant->ulVal = (ULONG)m_rOptions.savetype;
        break;    

    // -----------------------------------------------------------------------
    default:
        pVariant->vt = VT_NULL;
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetMessageFlags
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetMessageFlags(BOOL fHideTnef)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPCSTR pszPriType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_PRITYPE], STR_CNT_TEXT);
    LPCSTR pszSubType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_SUBTYPE], STR_SUB_PLAIN);
    LPCSTR pszCntDisp = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDISP], STR_DIS_INLINE);

    // Mime
    if (m_prgIndex[PID_HDR_MIMEVER])
        FLAGSET(dwFlags, IMF_MIME);

    // IMF_NEWS
    if (m_prgIndex[PID_HDR_XNEWSRDR]  || m_prgIndex[PID_HDR_NEWSGROUPS] || m_prgIndex[PID_HDR_NEWSGROUP] || m_prgIndex[PID_HDR_PATH])
        FLAGSET(dwFlags, IMF_NEWS);

    // text
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
    {
        // There is text
        FLAGSET(dwFlags, IMF_TEXT);

        // text/plain
        if (lstrcmpi(pszSubType, STR_SUB_PLAIN) == 0)
            FLAGSET(dwFlags, IMF_PLAIN);

        // text/html
        else if (lstrcmpi(pszSubType, STR_SUB_HTML) == 0)
            FLAGSET(dwFlags, IMF_HTML);
    }

    // multipart
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
    {
        // Multipart
        FLAGSET(dwFlags, IMF_MULTIPART);

        // multipart/related
        if (lstrcmpi(pszSubType, STR_SUB_RELATED) == 0)
            FLAGSET(dwFlags, IMF_MHTML);

        // multipart/signed
        else if (0 == lstrcmpi(pszSubType, STR_SUB_SIGNED))
            FLAGSET(dwFlags, IMF_SIGNED | IMF_SECURE);
    }

    // message/partial
    else if (lstrcmpi(pszPriType, STR_CNT_MESSAGE) == 0 && lstrcmpi(pszSubType, STR_SUB_PARTIAL) == 0)
        FLAGSET(dwFlags, IMF_PARTIAL);

    // application
    else if (lstrcmpi(pszPriType, STR_CNT_APPLICATION) == 0)
    {
        // application/ms-tnef
        if (0 == lstrcmpi(pszSubType, STR_SUB_MSTNEF))
            FLAGSET(dwFlags, IMF_TNEF);

        // application/x-pkcs7-mime
        else if (0 == lstrcmpi(pszSubType, STR_SUB_XPKCS7MIME) ||
            0 == lstrcmpi(pszSubType, STR_SUB_PKCS7MIME))  // nonstandard
            FLAGSET(dwFlags, IMF_SECURE);
    }

    // Raid-37086 - Cset Tagged
    if (ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        FLAGSET(dwFlags, IMF_CSETTAGGED);

    // Attachment...
    if (!ISFLAGSET(dwFlags, IMF_MULTIPART) && (FALSE == fHideTnef || !ISFLAGSET(dwFlags, IMF_TNEF)))
    {
        // Marked as an attachment ?
        if (!ISFLAGSET(dwFlags, IMF_SECURE) && 0 != lstrcmpi(pszSubType, STR_SUB_PKCS7SIG))
        {
            // Not Rendered Yet
            if (NULL == m_prgIndex[PID_ATT_RENDERED])
            {
                // Marked as an Attachment
                if (lstrcmpi(pszCntDisp, STR_DIS_ATTACHMENT) == 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Type: xxx; name=xxx
                else if (NULL != m_prgIndex[PID_PAR_NAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Disposition: xxx; filename=xxx
                else if (NULL != m_prgIndex[PID_PAR_FILENAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Else if it is not marked as text
                else if (ISFLAGSET(dwFlags, IMF_TEXT) == FALSE)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // If not text/plain and not text/html
                else if (lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0 && lstrcmpi(pszSubType, STR_SUB_HTML) != 0 && lstrcmpi(pszSubType, STR_SUB_ENRICHED) != 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetEncodingType
// --------------------------------------------------------------------------------
ENCODINGTYPE CMimePropertyContainer::GetEncodingType(void)
{
    // Locals
    ENCODINGTYPE ietEncoding=IET_7BIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPPROPERTY pCntXfer = m_prgIndex[PID_HDR_CNTXFER];

    // Do we have data the I like ?
    if (pCntXfer && ISSTRINGA(&pCntXfer->rValue))
    {
        // Local
        CStringParser cString;

        // cString...
        cString.Init(pCntXfer->rValue.rStringA.pszVal, pCntXfer->rValue.rStringA.cchVal, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS);

        // Parse to end, remove white space and comments
        SideAssert('\0' == cString.ChParse(""));

        // Loop the table
        for (ULONG i=0; i<ARRAYSIZE(g_rgEncoding); i++)
        {
            // Match Encoding Strings
            if (lstrcmpi(g_rgEncoding[i].pszEncoding, cString.PszValue()) == 0)
            {
                ietEncoding = g_rgEncoding[i].ietEncoding;
                break;
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return ietEncoding;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetInlineSymbol
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szHeader[255];
    LPSTR       pszHeader=NULL;

    // Invalid Arg
    Assert(pszData && ppSymbol);

    // _HrParseInlineHeaderName
    CHECKHR(hr = _HrParseInlineHeaderName(pszData, szHeader, sizeof(szHeader), &pszHeader, pcboffColon));

    // Find Global Property
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, ppSymbol));

exit:
    // Cleanup
    if (pszHeader != szHeader)
        SafeMemFree(pszHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInlineHeaderName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch, 
    LPSTR *ppszHeader, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=(LPSTR)pszData,
                pszStart;
    ULONG       i=0;

    // Invalid Arg
    Assert(pszData && pszScratch && ppszHeader && pcboffColon);

    // Lets Parse the name out and find the symbol
    while (*psz && (' ' == *psz || '\t' == *psz))
    {
        i++;
        psz++;
    }

    // Done
    if ('\0' == *psz)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Seek to the colon
    pszStart = psz;
    while (*psz && ':' != *psz)
    {
        i++;
        psz++;
    }

    // Set Colon Position
    (*pcboffColon) = i;

    // Done
    if ('\0' == *psz || 0 == i)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Copy the name
    if (i + 1 <= cchScratch)
        *ppszHeader = pszScratch;

    // Otherwise, allocate
    else
    {
        // Allocate space for the name
        *ppszHeader = PszAllocA(i + 1);
        if (NULL == *ppszHeader)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Copy the data
    CopyMemory(*ppszHeader, pszStart, i);

    // Null
    *((*ppszHeader) + i) = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindFirstRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Invalid Arg
    if (NULL == pFindHeader)
        return TrapError(E_INVALIDARG);

    // Init pFindHeader
    pFindHeader->dwReserved = 0;

    // FindNext
    return FindNextRow(pFindHeader, phRow);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindNextRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pFindHeader || NULL == phRow)
        return TrapError(E_INVALIDARG);

    // Init
    *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=pFindHeader->dwReserved; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pFindHeader->pszHeader || lstrcmpi(pRow->pSymbol->pszName, pFindHeader->pszHeader) == 0)
        {
            // Save Index of next item to search
            pFindHeader->dwReserved = i + 1;

            // Return the handle
            *phRow = pRow->hRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    pFindHeader->dwReserved = m_rHdrTable.cRows; 
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CountRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountRows(LPCSTR pszHeader, ULONG *pcRows)
{
    // Locals
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Init
    *pcRows = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=0; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pszHeader || lstrcmpi(pRow->pSymbol->pszName, pszHeader) == 0)
            (*pcRows)++;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData, 
    LPHHEADERROW phRow)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    ULONG           cboffColon;
    LPPROPERTY      pProperty;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Init
    if (phRow)
        *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a header, lookup the symbol
    if (pszHeader)
    {
        // HTF_NAMEINDATA better not be set
        Assert(!ISFLAGSET(dwFlags, HTF_NAMEINDATA));

        // Lookup the symbol
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, &pSymbol));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Set the Data on this row
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData, cchData));
    }

    // Otherwise...
    else if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // GetInlineSymbol
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Remove IHF_NAMELINE
        FLAGCLEAR(dwFlags, HTF_NAMEINDATA);

        // Set the Data on this row
        Assert(cboffColon + 1 < cchData);
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData + cboffColon + 1, cchData - cboffColon - 1));
    }

    // Otherwise, failed
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteRow(HHEADERROW hRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Standard Delete Prop
    CHECKHR(hr = DeleteProp(pRow->pSymbol));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchData=0;
    LPPROPERTY  pRow;
    MIMEVARIANT rValue;
    DWORD       dwPropFlags;

    // Init
    if (ppszData)
        *ppszData = NULL;
    if (pcchData)
        *pcchData = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Compute dwPropFlags
    dwPropFlags = PDF_HEADERFORMAT | ((dwFlags & HTF_NAMEINDATA) ? PDF_NAMEINDATA : 0);

    // Speicify data type
    rValue.type = MVT_STRINGA;

    // Ask the value for the data
    CHECKHR(hr = _HrGetPropertyValue(pRow, dwPropFlags, &rValue));

    // Want Length
    cchData = rValue.rStringA.cchVal;

    // Want the data
    if (ppszData)
    {
        *ppszData = rValue.rStringA.pszVal;
        rValue.rStringA.pszVal = NULL;
    }

    // Else Free It
    else
        SafeMemFree(rValue.rStringA.pszVal);

    // Verify the NULL
    Assert(ppszData ? '\0' == *((*ppszData) + cchData) : TRUE);

    // Return Length ?
    if (pcchData)
        *pcchData = cchData;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    MIMEVARIANT     rValue;
    ULONG           cboffColon;
    LPPROPSYMBOL    pSymbol;
    LPSTR           psz=(LPSTR)pszData;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // If HTF_NAMEINDATA
    if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // Extract the name
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Symbol Must be the same
        if (pRow->pSymbol != pSymbol)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Adjust pszData
        Assert(cboffColon < cchData);
        psz = (LPSTR)(pszData + cboffColon + 1);
        cchData = cchData - cboffColon - 1;
        Assert(psz[cchData] == '\0');
    }

    // Setup the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = psz;
    rValue.rStringA.cchVal = cchData;

    // Tell value about the new row data
    CHECKHR(hr = _HrSetPropertyValue(pRow, 0, &rValue));

    // Clear Position Information
    pRow->cboffStart = 0;
    pRow->cboffColon = 0;
    pRow->cboffEnd = 0;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pInfo->dwRowNumber = pRow->dwRowNumber;
    pInfo->cboffStart = pRow->cboffStart;
    pInfo->cboffColon = pRow->cboffColon;
    pInfo->cboffEnd = pRow->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowNumber
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pRow->dwRowNumber = dwRowNumber;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         iEnum=0,
                         cEnumCount;
    LPENUMHEADERROW      pEnumRow=NULL;
    LPPROPERTY           pRow;
    CMimeEnumHeaderRows *pEnum=NULL;
    LPROWINDEX           prgIndex=NULL;
    ULONG                cRows;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Lets Count the Rows
    CHECKHR(hr = CountRows(pszHeader, &cEnumCount));

    // Allocate pEnumRow
    CHECKALLOC(pEnumRow = (LPENUMHEADERROW)g_pMalloc->Alloc(cEnumCount * sizeof(ENUMHEADERROW)));

    // ZeroInit
    ZeroMemory(pEnumRow, cEnumCount * sizeof(ENUMHEADERROW));

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Is this a header the client wants
        if (NULL == pszHeader || lstrcmpi(pszHeader, pRow->pSymbol->pszName) == 0)
        {
            // Valide
            Assert(iEnum < cEnumCount);

            // Set the symbol on this enum row
            pEnumRow[iEnum].dwReserved = (DWORD)pRow->pSymbol;

            // Lets always give the handle
            pEnumRow[iEnum].hRow = pRow->hRow;

            // If Enumerating only handles...
            if (!ISFLAGSET(dwFlags, HTF_ENUMHANDLESONLY))
            {
                // Get the data for this enum row
                CHECKHR(hr = GetRowData(pRow->hRow, dwFlags, &pEnumRow[iEnum].pszData, &pEnumRow[iEnum].cchData));
            }

            // Increment iEnum
            iEnum++;
        }
    }
        
    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, dwFlags, cEnumCount, pEnumRow, FALSE));

    // Don't Free pEnumRow
    pEnumRow = NULL;

    // Return it
    (*ppEnum) = (IMimeEnumHeaderRows *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeMemFree(prgIndex);
    if (pEnumRow)
        g_cMoleAlloc.FreeEnumHeaderRowArray(cEnumCount, pEnumRow, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream, 
    ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pStream && pcAddrsWrote);
    Assert(!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        CHECKHR(hr = _HrSaveAddress(pProperty, pAddress, pStream, pcAddrsWrote, format));

        // Increment cAddresses Count
        (*pcAddrsWrote)++;
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, 
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszName=NULL;
    BOOL            fWriteEmail=FALSE;
    LPSTR           pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyA(pAddress->rFriendly.psz) && FIsEmptyA(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_szAddressFold, lstrlen(c_szAddressFold), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyA(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyA(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if (AFT_RFC822_TRANSMIT == format && fWriteEmail && StrStr(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszName = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGA;
            rSource.type = MVT_STRINGA;

            // Init pszName
            pszName = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeString(CP_ACP, pszName, &pszEscape) == S_OK)
            {
                // Escaped
                pszName = pszEscape;
                rSource.rStringA.pszVal = pszName;
                rSource.rStringA.cchVal = lstrlen(pszName);
            }

            // Otherwise
            else
            {
                rSource.rStringA.pszVal = pAddress->rFriendly.psz;
                rSource.rStringA.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
            {
                // Encode It
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC | PDF_ENCODED, 0, &rSource, &rDest)))
                    pszName = rDest.rStringA.pszVal;
            }

            // Decoded
            else if (IET_ENCODED == pAddress->ietFriendly)
            {
                // Encode It
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC, 0, &rSource, &rDest)))
                    pszName = rDest.rStringA.pszVal;
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszName)
    {
        // Write Quote
        if (fRFC822)
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write display name
        CHECKHR(hr = pStream->Write(pszName, lstrlen(pszName), NULL));

        // Write Quote
        if (fRFC822)
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCSTR pszStart = pszName ? c_szEmailSpaceStart : c_szEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlen(pszStart), NULL));

        // Write email
        CHECKHR(hr = pStream->Write(pAddress->rEmail.psz, pAddress->rEmail.cch, NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria, 
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pszCriteria);

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        if (_HrQueryAddress(pProperty, pAddress, pszCriteria, fSubString, fCaseSensitive) == S_OK)
            goto exit;
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszDisplay;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pszCriteria);

    // Init
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Query Email Address First
    if (MimeOleQueryString(pAddress->rEmail.psz, pszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Decode Display Name
    pszDisplay = pAddress->rFriendly.psz;

    // Decode the Property
    if (IET_ENCODED == pAddress->ietFriendly)
    {
        // Set Source
        rDest.type = MVT_STRINGA;
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pAddress->rFriendly.psz;
        rSource.rStringA.cchVal = pAddress->rFriendly.cch;

        // Decode the Property
        if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC, 0, &rSource, &rDest)))
            pszDisplay = rDest.rStringA.pszVal;
    }

    // Query Email Address First
    if (MimeOleQueryString(pszDisplay, pszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Not Found
    hr = S_FALSE;

exit:
    // Cleanup
    MimeVariantFree(&rDest);

    // Done
    return hr;
}


// ----------------------------------------------------------------------------
// CMimePropertyContainer::Append
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly, 
    LPCSTR pszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(ADDRESSPROPS));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = (LPSTR)pszFriendly;
    }

    // Set pszEmail
    if (pszEmail)
    {
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = (LPSTR)pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Insert
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address and Address Type
    if (!ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) || (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail)))
        return TrapError(E_INVALIDARG);

    // Init
    if (phAddress)
        *phAddress = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

    // Open the group
    CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Append an Address to the group
    CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

    // The group is dirty
    Assert(pAddress->pGroup);
    pAddress->pGroup->fDirty = TRUE;

    // Set the Address Type
    pAddress->dwAdrType = pProps->dwAdrType;

    // Copy Address Props to Mime Address
    CHECKHR(hr = SetProps(pAddress->hThis, pProps));

    // Return the Handle
    if (phAddress)
        *phAddress = pAddress->hThis;

exit:
    // Failure
    if (FAILED(hr) && pAddress)
        Delete(pAddress->hThis);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
        pAddress->dwAdrType = pProps->dwAdrType;

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
        pAddress->ietFriendly = pProps->ietFriendly;

    // IAP_HCHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET) && pProps->hCharset)
    {
        // Resolve to pCharset
        LPINETCSETINFO pCharset;
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pProps->hCharset, &pCharset)))
            pAddress->pCharset = pCharset;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
        pAddress->certstate = pProps->certstate;

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
        pAddress->dwCookie = pProps->dwCookie;

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY) && pProps->pszFriendly)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenA(pProps->pszFriendly, lstrlen(pProps->pszFriendly), &pAddress->rFriendly));
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && pProps->pszEmail)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenA(pProps->pszEmail, lstrlen(pProps->pszEmail), &pAddress->rEmail));
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT) && pProps->tbSigning.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbSigning.pBlobData);
        pAddress->tbSigning.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbSigning, &pAddress->tbSigning));
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT) && pProps->tbEncryption.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbEncryption.pBlobData);
        pAddress->tbEncryption.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbEncryption, &pAddress->tbEncryption));
    }

    // pAddress->pGroup is Dirty
    Assert(pAddress->pGroup);
    if (pAddress->pGroup)
        pAddress->pGroup->fDirty = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_CHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET))
    {
        if (pAddress->pCharset && pAddress->pCharset->hCharset)
        {
            pProps->hCharset = pAddress->pCharset->hCharset;
        }
        else
        {
            pProps->hCharset = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_CHARSET);
        }
    }

    // IAP_HANDLE
    if (ISFLAGSET(pProps->dwProps, IAP_HANDLE))
    {
        Assert(pAddress->hThis);
        pProps->hAddress = pAddress->hThis;
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
    {
        Assert(pAddress->dwAdrType);
        pProps->dwAdrType = pAddress->dwAdrType;
    }

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
    {
        pProps->dwCookie = pAddress->dwCookie;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
    {
        pProps->certstate = pAddress->certstate;
    }

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
    {
        pProps->ietFriendly = pAddress->ietFriendly;
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY))
    {
        // Decode
        if (!FIsEmptyA(pAddress->rFriendly.psz))
        {
            // Encoded
            if (IET_ENCODED == pAddress->ietFriendly)
            {
                // Locals
                LPPROPSYMBOL    pSymbol;
                MIMEVARIANT     rSource;
                MIMEVARIANT     rDest;

                // Get the symbol of the address tyep
                CHECKHR(hr = g_pSymCache->HrOpenSymbol(pAddress->dwAdrType, &pSymbol));

                // Setup Source
                rSource.type = MVT_STRINGA;
                rSource.rStringA.pszVal = pAddress->rFriendly.psz;
                rSource.rStringA.cchVal = pAddress->rFriendly.cch;

                // Setup Dest
                rDest.type = MVT_STRINGA;

                // Decode It
                if (SUCCEEDED(HrConvertVariant(pSymbol, pAddress->pCharset, IET_ENCODED, 0, 0, &rSource, &rDest)))
                    pProps->pszFriendly = rDest.rStringA.pszVal;

                // Otherwise, dup it
                else
                {
                    // Dup
                    CHECKALLOC(pProps->pszFriendly = PszDupA(pAddress->rFriendly.psz));
                }
            }

            // Otherwise, just copy it
            else
            {
                // Dup
                CHECKALLOC(pProps->pszFriendly = PszDupA(pAddress->rFriendly.psz));
            }
        }
        else
        {
            pProps->pszFriendly = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLY);
        }
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL))
    {
        if (!FIsEmptyA(pAddress->rEmail.psz))
        {
            CHECKALLOC(pProps->pszEmail = PszDupA(pAddress->rEmail.psz));
        }
        else
        {
            pProps->pszEmail = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_EMAIL);
        }
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT))
    {
        if (pAddress->tbSigning.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbSigning, &pProps->tbSigning));
        }
        else
        {
            pProps->tbSigning.pBlobData = NULL;
            pProps->tbSigning.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_SIGNING_PRINT);
        }
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT))
    {
        if (pAddress->tbEncryption.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbEncryption, &pProps->tbEncryption));
        }
        else
        {
            pProps->tbEncryption.pBlobData = NULL;
            pProps->tbEncryption.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_ENCRYPTION_PRINT);
        }
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::SetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Address Type
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) && pProps->dwAdrType != pAddress->dwAdrType)
    {
        // Unlink this address from this group
        _UnlinkAddress(pAddress);

        // Get Header
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

        // Open the group
        CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // LinkAddress
        _LinkAddress(pAddress, pProperty->pGroup);

        // Dirty
        pProperty->pGroup->fDirty = TRUE;
    }

    // Changing other properties
    CHECKHR(hr = _HrSetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Email Address to Null
    CHECKHR(hr = _HrGetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetSender
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSender(LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPERTY          pProperty;
    LPPROPERTY          pSender=NULL;
    HADDRESS            hAddress=NULL;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find first from
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_FROM))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Take the first address
            if (pProperty->pGroup->pHead)
                hAddress = pProperty->pGroup->pHead->hThis;

            // Done
            break;
        }

        // Look for Sender:
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_SENDER) && NULL == pSender)
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Sender Property
            pSender = pProperty;
        }
    }

    // Is there a sender group
    if (NULL == hAddress && NULL != pSender && NULL != pSender->pGroup->pHead)
        hAddress = pSender->pGroup->pHead->hThis;

    // No Address
    if (NULL == hAddress)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get Props
    CHECKHR(hr = GetProps(hAddress, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::CountTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountTypes(DWORD dwAdrTypes, ULONG *pcAdrs)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    if (NULL == pcAdrs)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcAdrs = 0;

    // Loop through groups
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Increment Count
            (*pcAdrs) += pProperty->pGroup->cAdrs;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               iAddress;
    LPPROPERTY          pProperty;
    LPMIMEADDRESS       pAddress;

    // Invalid Arg
    if (NULL == pList)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through groups
    CHECKHR(hr = CountTypes(dwAdrTypes, &pList->cAdrs));

    // Nothing..
    if (0 == pList->cAdrs)
        goto exit;

    // Allocate an array
    CHECKHR(hr = HrAlloc((LPVOID *)&pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS)));

    // Init
    ZeroMemory(pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS));

    // Fill with types...
    for (iAddress=0, pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Loop Infos...
        for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Verify Size...
            Assert(iAddress < pList->cAdrs);

            // Zeromemory
            ZeroMemory(&pList->prgAdr[iAddress], sizeof(ADDRESSPROPS));

            // Set Desired Props
            pList->prgAdr[iAddress].dwProps = dwProps;

            // Get the Address Props
            CHECKHR(hr = _HrGetAddressProps(&pList->prgAdr[iAddress], pAddress));

            // Increment piCurrent
            iAddress++;
        }
    }

exit:
    // Failure..
    if (FAILED(hr))
    {
        g_cMoleAlloc.FreeAddressList(pList);
        ZeroMemory(pList, sizeof(ADDRESSLIST));
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::EnumTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT                hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;
    ADDRESSLIST            rList;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init out param in case of error
    *ppEnum = NULL;

    // Init rList
    ZeroMemory(&rList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the address lsit
    CHECKHR(hr = GetTypes(dwAdrTypes, dwProps, &rList));

    // Create a new Enumerator
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit((IMimeAddressTable *)this, 0, &rList, FALSE));

    // Clear rList
    rList.cAdrs = 0;
    rList.prgAdr = NULL;

    // Return it
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    if (rList.cAdrs)
        g_cMoleAlloc.FreeAddressList(&rList);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Delete
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Delete(HADDRESS hAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref Address
    pAddress = HADDRESSGET(hAddress);

    // Unlink this address
    _UnlinkAddress(pAddress);

    // Unlink this address
    _FreeAddress(pAddress);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::DeleteTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteTypes(DWORD dwAdrTypes)
{
    // Locals
    LPPROPERTY      pProperty;
    BOOL            fFound;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // While there are address types
    while(dwAdrTypes)
    {
        // Reset fFound
        fFound = FALSE;

        // Search for first delete-able address type
        for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
        {
            // Not the type I want
            if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            {
                // We found a properyt
                fFound = TRUE;

                // Clear this address type ad being deleted
                FLAGCLEAR(dwAdrTypes, pProperty->pSymbol->dwAdrType);

                // Unlink this property
                _UnlinkProperty(pProperty);

                // Done
                break;
            }
        }

        // No Property Found
        if (FALSE == fFound)
            break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetFormat
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat)
{
    // Locals
    HRESULT              hr=S_OK;
    CByteStream          cByteStream;
    ULONG                cAddrsWrote=0;
    LPPROPERTY           pProperty;

    // check params
    if (NULL == ppszFormat)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Fill with types...
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrType, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Tell the group object to write its display address into pStream
        CHECKHR(hr = _HrSaveAddressGroup(pProperty, &cByteStream, &cAddrsWrote, format));
     }

    // Did we write any for this address tyep ?
    if (cAddrsWrote)
    {
        // Get Text
        CHECKHR(hr = cByteStream.HrAcquireStringA(NULL, ppszFormat, ACQ_DISPLACE));
    }
    else
        hr = MIME_E_NO_DATA;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszRfc822Adr;
    rValue.rStringA.cchVal = lstrlen(pszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, 
    LPCSTR pszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    LPSTR               pszData=(LPSTR)pszRfc822Adr;
    PROPVARIANT         rDecoded;
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;

    // Invalid Arg
    if (NULL == pszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // LocalInit
    ZeroMemory(&rDecoded, sizeof(PROPVARIANT));

    // ZeroParse
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Decode...
    if (IET_DECODED != ietEncoding)
    {
        // Setup rfc1522Info
        rRfc1522Info.fRfc1522Allowed = TRUE;
        rRfc1522Info.fAllow8bit = FALSE;
        rDecoded.vt = VT_LPSTR;

        // Check for 1522 Encoding...
        if (SUCCEEDED(g_pInternat->DecodeHeader(NULL, pszData, &rDecoded, &rRfc1522Info)))
            pszData = rDecoded.pszVal;
    }

    // Initialize Parse Structure
    cAdrParse.Init(pszData, lstrlen(pszData));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(ADDRESSPROPS));

        // Copy the Friendly Name
        CHECKALLOC(pAddress->pszFriendly = PszDupA(cAdrParse.PszFriendly()));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszDupA(cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = ietEncoding;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_cMoleAlloc.FreeAddressList(pList);

    // Cleanup
    MimeOleVariantFree(&rDecoded);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeAddressTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeAddressTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrGenerateFileName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGenerateFileName(DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszDefExt=NULL,
                pszData=NULL,
                pszFree=NULL,
                pszSuggest=NULL;
    LPCSTR      pszCntType=NULL;
    LPPROPERTY  pProperty;
    MIMEVARIANT rSource;

    // Compute Content Type
    pszCntType = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTTYPE], STR_MIME_TEXT_PLAIN);

    // Compute Subject as suggested base file name...
    rSource.type = MVT_STRINGA;
    if (SUCCEEDED(GetProp(SYM_HDR_SUBJECT, 0, &rSource)))
        pszSuggest = pszFree = rSource.rStringA.pszVal;

    // PID_HDR_CNTDESC
    if (NULL == pszSuggest)
    {
        // Use PID_CNTDESC
        pszSuggest = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDESC], NULL);
    }

    // message/rfc822
    if (lstrcmpi(pszCntType, (LPSTR)STR_MIME_MSG_RFC822) == 0)
    {
        // If there is a news header, use c_szDotNws
        if (ISFLAGSET(m_dwState, COSTATE_RFC822NEWS))
            pszDefExt = (LPSTR)c_szDotNws;
        else
            pszDefExt = (LPSTR)c_szDotEml;

        // I will never lookup message/rfc822 extension
        pszCntType = NULL;
    }

    // Still no default
    else if (StrCmpNI(pszCntType, STR_CNT_TEXT, lstrlen(STR_CNT_TEXT)) == 0)
        pszDefExt = (LPSTR)c_szDotTxt;

    // Generate a filename based on the content type...
    CHECKHR(hr = MimeOleGenerateFileName(pszCntType, pszSuggest, pszDefExt, &pszData));

    // Setup rSource
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = pszData;
    rSource.rStringA.cchVal = lstrlen(pszData);

    // Return per user request
    CHECKHR(hr = HrConvertVariant(SYM_ATT_GENFNAME, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\capistm.cpp ===
/*
**  capistm.cpp
**
**  Purpose:
**      Implementation of a class to wrap around CAPI functionality
**
**  History
**      1/26/98; (brucek) triple wrap support
**      2/07/97: (t-erikne) multipart/signed
**      1/06/97: (t-erikne) Moved into MimeOLE
**     11/14/96: (t-erikne) CAPI Post-SDR work
**      8/27/96: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1996-1998.
*/

///////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include <wincrypt.h>
#include "olealloc.h"
#include "containx.h"
#include "smime.h"
#include "capistm.h"
#include "mimeapi.h"
#include "inetconv.h"
#include <capiutil.h>
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include <demand.h>
#include "strconst.h"

#include "smimepol.h"
BOOL    FHideMsgWithDifferentLabels(); 
enum ECertErrorProcessLabel {
    CertErrorProcessLabelAnyway = 0,
    CertErrorProcessLabelGrant = 1,
    CertErrorProcessLabelDeny = 2
};
DWORD   DwProcessLabelWithCertError(); 
HRESULT HrCheckLabelAccess(const DWORD dwFlags, const HWND hwnd, 
           PSMIME_SECURITY_LABEL plabel, const PCCERT_CONTEXT pccertDecrypt,
           const PCCERT_CONTEXT pccertSigner, const HCERTSTORE    hcertstor);

#ifdef MAC
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // MAC

// from dllmain.h
extern DWORD g_dwSysPageSize;
extern CMimeAllocator * g_pMoleAlloc;
extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

extern void DebugDumpStreamToFile(LPSTREAM pstm, LPSTR lpszFile);

// From smime.cpp
extern HRESULT HrGetLastError(void);
extern BOOL FIsMsasn1Loaded();

#ifdef WIN16
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextA
#else
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextW
#endif

///////////////////////////////////////////////////////////////////////////
//
// defines
//

#define THIS_AS_UNK ((IUnknown *)(IStream *)this)

#define CS_E_CANT_DECRYPT   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x2414)
#define CS_E_MSG_INVALID    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x2415)

const int CbCacheBufferSize = 4 * 1024;

///////////////////////////////////////////////////////////////////////////
//
// inlines
//

static INLINE void ReleaseCert(PCCERT_CONTEXT pc)
    { if (pc) CertFreeCertificateContext(pc); }

// Streaming state diagram
//
//            SF                GT                    SD-FW-TN-SO-SF
//             |                 |                   /[encryption]
//            SO                QT-------------------
//  [op encode] \              / [opaque decode]     \[signed]
//               ------NB------                       (FW-TN)-SO-SF
// [det encode] /              \ [detached decode]
//            DO                DO
//             |                 \
//            SF                  DF
//                                 |
//                                SO
//                                 |
//                                SF
//
//
//  New state diagram:
//                                                               encrypt
//                                                            SD--SO
//        opaque encode              opaque decode           /
//               SO            QT--------------------[QTF]---
//                 \          /                              \
//                  ---NB-----                                SO    signed
//                 /          \
//          SO---DO            DO ------------------ SO
//      detach encode               detach decode
//
//

#ifndef WIN16
enum CSstate {
    STREAM_NOT_BEGUN,
    STREAM_QUESTION_TIME,
    STREAM_QUESTION_TIME_FINAL,
    STREAM_SETUP_DECRYPT,
    STREAM_DETACHED_OCCURING,
    STREAM_OCCURING, // must be +1 of DF
    STREAM_ERROR,
    STREAM_GOTTYPE,

    CSTM_FIRST_WRITE = 32,
    CSTM_TEST_NESTING,
    CSTM_STREAMING,
    CSTM_STREAMING_DONE,
    CSTM_GOTTYPE,
    };
#endif // !WIN16

// low word is public.  see .h file.
#define CSTM_DECODE             0x00010000
#define CSTM_DONTRELEASEPROV    0x00020000
#define CSTM_RECURSED           0x00040000
#define CSTM_HAVECR             0x10000000
#define CSTM_HAVEEOL            0x20000000

static const char s_cszMy[]             = "My";
static const char s_cszWABCertStore[]   = "AddressBook";
static const char s_cszCA[]             = "CA";

static const char s_cszMimeHeader[]     = "Content-Type: application/x-pkcs7-mime"
                "; name=smime.p7m; smime-type=";
static const char s_cszMimeHeader2[]     = "Content-Disposition: attachment; "
                "filename=smime.p7m";

static const char s_cszOIDMimeHeader1[]   = "Content-Type: oid/";
static const char s_cszOIDMimeHeader2[]   = "\nContent-Transfer-Encoding: binary\n\n";



///////////////////////////////////////////////////////////////////////////
//
// static prototypes
//

#if 0
#define IV_LENGTH 8
static BOOL _GetIV(BYTE rgbIV[IV_LENGTH]);

static PBYTE _PVEncodeObject(
    LPCSTR lpszStructType,
    const void *pvStructInfo,
    DWORD *pcbEncoded);
#endif

static HRESULT _InitEncodedCert(IN HCERTSTORE hcertstor,
                                OUT PCERT_BLOB * rgblobCert, OUT DWORD * pcCerts,
                                OUT PCRL_BLOB * rgblobCRL, OUT DWORD * pcCrl);

static HRESULT _InitEncodedCertIncludingSigners(IN HCERTSTORE hcertstor,
                                DWORD cSigners, SignerData rgSigners[],
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl);

static void _SMimeCapsFromHMsg(HCRYPTMSG, DWORD id, LPBYTE * ppb, DWORD * pcb);

// ---------------------------- UTILITY FUNCTIONS --------------------------


HRESULT GetParameters(PCCERT_CONTEXT pccert, HCERTSTORE hstoreMsg, 
                      HCERTSTORE hstoreAll)
{
    CRYPT_DATA_BLOB     blob;
    DWORD               dw;
    HRESULT             hr = CRYPT_E_MISSING_PUBKEY_PARA;
    PCCERT_CONTEXT      pccertX;

    //  
    //  Start by looking for the issuer certificate on your own.  All that
    //  matters is that we find a certificate which claims to be the issuer
    //  and has parameters -- they will need to verify the parameters are
    //  correct at a later date.
    //

    pccertX = NULL;
    while (hstoreMsg != NULL) {
        //
        //  Find certificates by matching issuers -- ok for now as PKIX requires
        //  all issuers to have DNs
        //

        dw = CERT_STORE_SIGNATURE_FLAG;
        pccertX = CertGetIssuerCertificateFromStore(hstoreMsg, pccert, pccertX,
                                                    &dw);
        if (pccertX == NULL) {
            if (::GetLastError() == CRYPT_E_SELF_SIGNED) {
                return S_OK;
            }
            break;
        }

        //
        //  Only accept the item if we manage a signature validation on it.
        //

        if ((dw & CERT_STORE_SIGNATURE_FLAG)) {
            //
            //  We can't verify the signature, so get the issuers paramters and try again
            //

            hr = GetParameters(pccertX, hstoreMsg, hstoreAll);
            if (FAILED(hr)) {
                continue;
            }

            //
            //  The issuing cert has parameters, try the signature check again againist it.
            //
            
            dw = CERT_STORE_SIGNATURE_FLAG;
            if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                break;
            }
            hr = CRYPT_E_MISSING_PUBKEY_PARA;
        }
        else {
            if (pccertX->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData != 0) {
                hr = 0;
                break;
            }

            //
            //  If we found one but it does not have the parameters, it must be
            //  inheriting from it's issuer as well.
            //

            dw = CERT_STORE_SIGNATURE_FLAG;
            if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                hr = 0;
                break;
            }
        }
    }

    //
    //  If we still do not have a certificate, then search all of the system stores
    //  for an isuer.
    //

    if (pccertX == NULL) {
        while (hstoreAll != NULL) {
            //
            //  Find certificates by matching issuers -- ok for now as PKIX requires
            //  all issuers to have DNs
            //

            dw = CERT_STORE_SIGNATURE_FLAG;
            pccertX = CertGetIssuerCertificateFromStore(hstoreAll, pccert, pccertX,
                                                        &dw);

            if (pccertX == NULL) {
                if (::GetLastError() == CRYPT_E_SELF_SIGNED) {
                    return S_OK;
                }
                break;
            }

            //
            //  Only accept the item if we manage a signature validation on it.
            //

            if ((dw & CERT_STORE_SIGNATURE_FLAG)) {
                //
                //  We can't verify the signature, so get the issuers paramters and try again
                //

                hr = GetParameters(pccertX, hstoreMsg, hstoreAll);
                if (FAILED(hr)) {
                    continue;
                }

                //
                //  The issuing cert has parameters, try the signature check again againist it.
                //
            
                dw = CERT_STORE_SIGNATURE_FLAG;
                if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                    break;
                }
                hr = CRYPT_E_MISSING_PUBKEY_PARA;
            }
            else {
                if (pccertX->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData != 0) {
                    hr = 0;
                    break;
                }

                //
                //  If we found one but it does not have the parameters, it must be inheriting
                //  from it's issuer as well.
                //

                dw = CERT_STORE_SIGNATURE_FLAG;
                if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                    hr = 0;
                    break;
                }
            }
        }
    }

#if 0
    //
    //  We found a certificate, set the parameters onto the context so that we
    //  can successfully manage to validate the signature
    //

    if (pccertX != NULL) {
        CRYPT_DATA_BLOB *       pdata = NULL;
        
        hr = HrGetCertificateParam(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, (LPVOID *) &pdata, NULL);
        if (FAILED(hr)) {
            CertFreeCertificateContext(pccertX);
            return hr;
        }
        
        CertSetCertificateContextProperty(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, 0, pdata);
        
        ReleaseMem(pdata);
        CertFreeCertificateContext(pccertX);
        return S_OK;
    }
    
    //
    //  if we still have not found anything, then let the caller have a chance
    //  to tell us what the parameters ought to be.
    //
                    
    if (m_pSmimeCallback != NULL) {
        hr = m_pSmimeCallback->GetParameters(pSignerCert, NULL,
                                             &blob.cbData, &blob.pbData);
        if (SUCCEEDED(hr)) {
            if (!CertSetCertificateContextProperty(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, 0, &blob) {
                hr = HrGetLastError();
            }
        }
        if (pb != NULL) {
            LocalFree(blob.pbData);
        }
        if (SUCCEEDED(hr)) {
            goto retry;
        }
    }
#endif // 0

    return hr;
}

//*************************************************************************
//                      CCAPIStm
//*************************************************************************


///////////////////////////////////////////////////////////////////////////
//
// ctor/dtor
//


/***************************************************************************

    Name      : constructor

    Purpose   :

    Parameters: lpstmOut -> Output stream or NULL
                psld -> SECURITY_LAYER_DATA or NULL.  If NULL, one will be
                  created.

    Returns   : void

    Comment   :

***************************************************************************/
CCAPIStm::CCAPIStm(LPSTREAM lpstmOut) :
    m_pstmOut(lpstmOut), m_cRef(1)
{
    DOUT("CCAPIStm::constructor() %#x -> %d", this, m_cRef);
    if (m_pstmOut)
        m_pstmOut->AddRef();

    m_hProv = NULL;
    m_hMsg = NULL;
    //    m_buffer = NULL;
    m_csStatus = STREAM_NOT_BEGUN;
    m_csStream = CSTM_FIRST_WRITE;
    m_rgStores = NULL;
    m_cStores = 0;
    m_pUserCertDecrypt = NULL;
    m_pCapiInner = NULL;
    m_pConverter = NULL;
    m_psldData = NULL;    
    m_pattrAuth = NULL;

#if defined(DEBUG) && !defined(MAC)
    {
        char szFileName[MAX_PATH + 1];

        m_pstmDebugFile = NULL;
        // Create a debug output file name based on the CAPIStm pointer
        wnsprintfA(szFileName, ARRAYSIZE(szFileName), "c:\\capidump%08x.txt", this);
        OpenFileStream(szFileName, CREATE_ALWAYS, GENERIC_WRITE, &m_pstmDebugFile);
    }
#endif

    m_hwnd = NULL;
    m_pSmimeCallback = NULL;
    m_dwFlagsSEF = 0;
    m_pwszKeyPrompt = NULL;

    m_pbBuffer = NULL;
    m_cbBuffer = 0;

    // m_dwFlags set in HrInitialize
    // m_cbBeginWrite initialized before use
    // m_cbBufUsed handled in the Begin* functions
    // m_cbBufAlloc handled in the Begin* functions
}

CCAPIStm::~CCAPIStm()
{
    DOUT("CCAPIStm::destructor() %#x -> %d", this, m_cRef);
    if (m_hMsg) {
        CryptMsgClose(m_hMsg);
    }

    if (m_hProv) 
    {
        CryptReleaseContext(m_hProv, 0); 
    }

    m_hProv = NULL;
    ReleaseObj(m_pCapiInner);
    ReleaseObj(m_pstmOut);
    ReleaseObj(m_pConverter);
    if (m_pattrAuth)  {
        MemFree(m_pattrAuth);
    }
    if (m_pUserCertDecrypt) {
        CertFreeCertificateContext(m_pUserCertDecrypt);
    }
    if (m_cStores) {
        Assert(m_rgStores);
        for (DWORD i=0; i<m_cStores; i++) {
            CertCloseStore(m_rgStores[i], 0);
        }
        MemFree(m_rgStores);
    }

	// Fix: Releasing hProv is caller responcibility
    //if (m_hProv && !(m_dwFlagsStm & CSTM_DONTRELEASEPROV)) {
    //    CryptReleaseContext(m_hProv, 0);
    //}

#if defined(DEBUG) && !defined(MAC)
    SafeRelease(m_pstmDebugFile);
#endif

    if (m_psldData) {
        m_psldData->Release();
    }

    if (m_pbBuffer != NULL) {
        MemFree(m_pbBuffer);
    }
    
    SafeMemFree(m_pwszKeyPrompt);

    ReleaseObj(m_pSmimeCallback);
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CCAPIStm::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv) {
        return TrapError(E_INVALIDARG);
    }

    // Find IID
    if (IID_IUnknown == riid) {
        *ppv = THIS_AS_UNK;
    }
    else if (IID_IStream == riid) {
        *ppv = (IStream *)this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCAPIStm::AddRef(void)
{
    DOUT("CCAPIStm::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CCAPIStm::Release(void)
{
    DOUT("CCAPIStm::Release() %#x -> %d", this, m_cRef-1);
    if (0 == InterlockedDecrement((LPLONG)&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// IStream methods
//

STDMETHODIMP CCAPIStm::Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *plibNewPosition)
{
    if (!plibNewPosition) {
        return E_POINTER;
    }
    else {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = 0;
    }

    return S_OK;
}

////    CCAPIStm::Write
//
//  Description:
//      This function is called with the original message as the buffer
//      being written into this stream object.  We then make the appropriate
//      calls into the NT Crypto system in order to encrypt/decrypt the message.
//
//      Part of what this function needs to do is to interact with the
//      Crypto system in order to cause decryption of message to occur.

#ifndef WIN16
STDMETHODIMP CCAPIStm::Write(const void *pv, ULONG cb, ULONG *pcbActual)
#else
STDMETHODIMP CCAPIStm::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbActual)
#endif // !WIN16
{
    HRESULT hr;

    //
    //  Reset the return arg just incase
    //
    
    if (pcbActual != NULL) {
        *pcbActual = 0;
    }

    //
    //  If the CMS object is not still open, then we are dead and need to return an error.
    //
    
    if (!m_hMsg) {
        hr = CAPISTM_E_MSG_CLOSED;
        goto exit;
    }

    //
    //  Are we in the correct state to take anything.
    //
    
    switch (m_csStatus) {
        case STREAM_NOT_BEGUN:
            Assert(FALSE);              // Should never get here
            hr = CAPISTM_E_NOT_BEGUN;
            goto exit;
        case STREAM_DETACHED_OCCURING:
        case STREAM_QUESTION_TIME:
        case STREAM_SETUP_DECRYPT:
        case STREAM_OCCURING:
            break;
        case STREAM_ERROR:
            Assert(FALSE);              // Should never get here
            hr = CAPISTM_E_OVERDONE;
            goto exit;
        case STREAM_GOTTYPE:
            hr = CAPISTM_E_GOTTYPE;
            goto exit;

            //  We should go from QT to QTF in this function, and never come back
            //  until we have changed the state again.
        default:
            Assert(FALSE);
        case STREAM_QUESTION_TIME_FINAL:
            hr = E_UNEXPECTED;
            goto exit;
    }

#if defined(DEBUG) && !defined(MAC)
    //
    //  Flush the input buffer to disk so that we can debug it later if necessary
    //

    if (!m_pCapiInner && m_pstmDebugFile) {
        m_pstmDebugFile->Write((BYTE *)pv, cb, NULL);
    }
#endif

    //
    //  We need to start buffering data to make our messages shorter.  The output
    //  from the save code comes in one and two byte chucks often, we need to put
    //  the data out in larger blocks
    //

    if (m_pbBuffer != NULL) {
        //
        //  If we would overflow the buffer, then dump the cached buffer out
        //
        
        if (m_cbBuffer + cb > CbCacheBufferSize) {
            if (!CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, FALSE)) {
                // CryptMsgUpdate failed

                Assert(S_OK != HrGetLastError());
                hr = HrGetLastError();
                if (FAILED(hr)) {
                    m_csStatus = STREAM_ERROR;
                }
                goto exit;
            }
            m_cbBuffer = 0;
        }

        //
        //  If this buffer will over flow, then dump out just that item. Otherwise 
        //      we are just going to cache the buffer.
        //

        if (cb >= CbCacheBufferSize) {
            if (!CryptMsgUpdate(m_hMsg, (BYTE *) pv, cb, FALSE)) {
                // CryptMsgUpdate failed

                Assert(S_OK != HrGetLastError());
                hr = HrGetLastError();
                if (FAILED(hr)) {
                    m_csStatus = STREAM_ERROR;
                }
                goto exit;
            }
        }
        else {
            memcpy(m_pbBuffer + m_cbBuffer, pv, cb);
            m_cbBuffer += cb;
        }

        if (pcbActual != NULL) {
            *pcbActual = cb;
        }

        //
        //  The only time we should be here is when we are creating a new CMS object
        //      and thus all of the code below this is not relavent as we don't ever
        //      need to ask questions about what type of this message.
        //
        
        hr = S_OK;
        goto exit;
    }
    else {
        //
        //  Push the input buffer into the Crypto system.  On failures from the
        //  system we need to propigate the correct error state into our structure
        //  and into the return value.
        //

        if (!CryptMsgUpdate(m_hMsg, (BYTE *)pv, cb, FALSE)) {
            // CryptMsgUpdate failed

            Assert(S_OK != HrGetLastError());
            hr = HrGetLastError();
            if (FAILED(hr)) {
                m_csStatus = STREAM_ERROR;
            }
            goto exit;
        }
    }

    //
    // Since the CryptMsgUpdate call succeeded, return
    // a nice out param (specifically that we have consumed all of the passed
    // in bytes)
    //

    if (pcbActual) {
        *pcbActual = cb;
    }
    hr = S_OK;

    //
    // If we are in a state where we need to ask questions about the message,
    //  then proceed to do so.
    //

    if ((STREAM_QUESTION_TIME == m_csStatus) ||
        (STREAM_QUESTION_TIME_FINAL == m_csStatus)) {
        
        DWORD cbDWORD, dwMsgType;

        //  We should never be asking questions if encoding.
        Assert(m_dwFlagsStm & CSTM_DECODE);

        //
        //  Find out what security services have been placed onto this
        //      message object (if any).  If not enough bytes have been processed
        //      to find out what the encoding of the message is, then return
        //      success so we can get more bytes and get the question answered
        //      at a later date.
        //

        cbDWORD = sizeof(DWORD);
        if (!CryptMsgGetParam(m_hMsg, CMSG_TYPE_PARAM, 0, &dwMsgType, &cbDWORD)) {
            hr = HrGetLastError();
            Assert (S_OK != hr);
            if (CRYPT_E_STREAM_MSG_NOT_READY == hr) {
                hr = S_OK;
            }
            goto exit;
        }

        //  Since we are here, we must have a V1 type S/MIME message
        Assert(m_psldData);
        m_psldData->m_dwMsgEnhancement = MST_CLASS_SMIME_V1;
        hr = S_OK;

        //
        //  Set the correct flags based on the message type of the object we are
        //      decoding.
        //

        switch (dwMsgType) {
        case CMSG_ENVELOPED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_ENCRYPT;
            break;
        case CMSG_SIGNED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_BLOBSIGN;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_BLOBSIGN | MST_THIS_ENCRYPT;
            break;

        default:
            // K this is a little rude.  not my iface error.
            hr = MIME_E_SECURITY_BADSECURETYPE;

            // just return the CAPI type if we don't recognize
            m_psldData->m_dwMsgEnhancement = dwMsgType;
            break;
        }

        //
        //  If all we are asking for is a type and we don't have any other errors,
        //      mark the fact that we got the type and return that fact as the
        //      error (to prevent futher buffers being written into us.)
        //

        if (CSTM_TYPE_ONLY & m_dwFlagsStm) {
            CSSDOUT("Got Type on typeonly call.");
            CSSDOUT("You will now see 80041417 failures; they're okay.");
            m_csStatus = STREAM_GOTTYPE;
            if (SUCCEEDED(hr)) {
                hr = CAPISTM_E_GOTTYPE;
            }
            goto exit;
        }

        //
        //  Change the object state based on the message type.  If we need to
        //      setup a decryption, then we need to mark the state for that.
        //      If we are just signing, then we can just let the rest of the
        //      streaming occur.
        //

        if (CMSG_ENVELOPED == dwMsgType) {
            m_csStatus = STREAM_SETUP_DECRYPT;
        }
        else {
            m_csStatus = STREAM_OCCURING;
        }
    }

    //
    //  If we need to set-up the message for decryption, then do so at this
    //  point.
    //

    Assert(SUCCEEDED(hr));
    if (STREAM_SETUP_DECRYPT == m_csStatus) {
        //  Can't decrypt detached messages
        Assert(!(m_dwFlagsStm & CSTM_DETACHED));

        //  We are now streaming the data out, on the assumption that the
        //      decryption stats.
        m_csStatus = STREAM_OCCURING;
        hr = HandleEnveloped();

        //  If we failed to decrypt, then re-map some errors and change the
        //      state back in the event that not all of the lock boxes have
        //      been seen yet.
        if (FAILED(hr)) {
            if (CRYPT_E_STREAM_MSG_NOT_READY == hr) {
                m_csStatus = STREAM_SETUP_DECRYPT;
                hr = S_OK;
            }
            else if (CS_E_CANT_DECRYPT == hr) {
                hr = MIME_E_SECURITY_CANTDECRYPT;
                // m_csStatus = STREAM_FINAL; // M00QUEST
            }
            else {
                if (CS_E_MSG_INVALID == hr) {
                    hr = MIME_E_SECURITY_CANTDECRYPT;
                }
                m_csStatus = STREAM_ERROR;
            }
            goto exit;
        }
    }

    hr = S_OK;

exit:
#ifdef DEBUG
    if (CAPISTM_E_GOTTYPE != hr) {
        return TrapError(hr);
    }
    else {
        return hr;  // don't spew this
    }
#else
    return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////
//
// CCAPIStm public methods
//




/*  HrInnerInitialize:
**
**  Purpose:
**      the standard "my constructor can't return errors" function
**  Takes:
**      dwFlagsSEF  - Control Flags 
**      hwndParent  - modal UI parents to this
**      dwFlagsStm  - see capistm.h
**  Returns:
**      OLE_E_INVALIDHWND if you give me a bad window
**      MIME_E_SECURITY_NOOP if MST_NONE is the current psi type
**  Notes:
**      dwFlags is currently 0 for encode.  do it this way.
*/
HRESULT CCAPIStm::HrInnerInitialize(DWORD dwFlagsSEF, const HWND hwndParent,
                               DWORD dwFlagsStm, IMimeSecurityCallback * pCallback,
                               PSECURITY_LAYER_DATA psld)
{
    HRESULT hr = S_OK;

    //
    // Save the security layer data
    //

    if (psld)
    {
        psld->AddRef();
        m_psldData = psld;
    }
    else
    {
        IF_NULLEXIT(m_psldData = new(SECURITY_LAYER_DATA));
    }

    //
    // Save the flags
    //

    m_dwFlagsSEF = dwFlagsSEF;
    m_dwFlagsStm = dwFlagsStm;

    if (pCallback != NULL)
    {
        m_pSmimeCallback = pCallback;
        pCallback->AddRef();
    }

    //
    //  Make sure that if we have a window, it is a real window.
    //
    
    IF_TRUEEXIT((hwndParent && !IsWindow(hwndParent)), OLE_E_INVALIDHWND);

    //
    //  Shove the hwnd into any crypto provider we openned up.
    //
    
    CryptSetProvParam(NULL, PP_CLIENT_HWND, (BYTE *)&hwndParent, 0);
    m_hwnd = hwndParent;

exit:
    return hr;
    
}

/*  HrInitialize:
**
**  Purpose:
**      the standard "my constructor can't return errors" function
**  Takes:
**      dwFlagsSEF  - Control Flags 
**      hwndParent  - modal UI parents to this
**      fEncode     - trivial
**      psi         - message state information.  see smime.h
**      dwFlagsStm  - see capistm.h
**  Returns:
**      OLE_E_INVALIDHWND if you give me a bad window
**      MIME_E_SECURITY_NOOP if MST_NONE is the current psi type
**  Notes:
**      dwFlags is currently 0 for encode.  do it this way.
*/
HRESULT CCAPIStm::HrInitialize(DWORD dwFlagsSEF, const HWND hwndParent,
                               const BOOL fEncode, SMIMEINFO *const psi,
                               DWORD dwFlagsStm, IMimeSecurityCallback * pCallback,
                               PSECURITY_LAYER_DATA psld)
{
    HRESULT hr;


    // do the initialization common to all capi stream objects.
    CHECKHR(hr = HrInnerInitialize(dwFlagsSEF, hwndParent, dwFlagsStm, pCallback, psld));


    if (fEncode) {
        hr = BeginEncodeStreaming(psi);
    }
    else {
        hr = BeginDecodeStreaming(psi);
    }

exit:
    return TrapError(hr);
}



/*  EndStreaming:
**
**  Purpose:
**      Push CAPI's message state forward a notch
**  Returns:
**      HRESULT
*/
HRESULT CCAPIStm::EndStreaming()
{
    DWORD       dwMsgEnhancement = m_psldData->m_dwMsgEnhancement;
    HRESULT     hr = S_OK;
    PCMSG_ATTR  pUnprotectedAttrs = NULL;

    Assert(m_hMsg);


    //  If we are crurent in an error state then return
    if ((STREAM_ERROR == m_csStatus) || STREAM_GOTTYPE == m_csStatus) {
        goto exit;
    }

    //
    //  If we are decoding -- and we are doing a detached message we need
    //  to jump from the sign object to the real body here.
    //

    if ((CSTM_DECODE & m_dwFlagsStm) && (STREAM_DETACHED_OCCURING == m_csStatus)) {
        Assert(m_csStream == CSTM_STREAMING_DONE);

        // client has finished giving us the signature block
        m_csStatus = STREAM_OCCURING;
        m_csStream = CSTM_STREAMING;

        m_psldData->m_dwMsgEnhancement = MST_THIS_SIGN;

        CSSDOUT("Signature streaming finished.");
        if (! CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, TRUE)) {
            if ((hr = HrGetLastError()) == 0x80070000) {   // CAPI sometimes doesn't SetLastError
                hr = 0x80070000 | ERROR_ACCESS_DENIED;
            }
        }
        m_cbBuffer = 0;
        goto exit;
    }

    if (! CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, TRUE)) {
        if ((hr = HrGetLastError()) == 0x80070000) {   // CAPI sometimes doesn't SetLastError
            hr = 0x80070000 | ERROR_ACCESS_DENIED;
        }
        goto exit;
    }
    m_cbBuffer = 0;

    if (m_dwFlagsStm & CSTM_DETACHED) {
        m_csStatus = STREAM_OCCURING;
    }

    //
    // do final streaming and verification
    //

    if (CSTM_DECODE & m_dwFlagsStm) {
        if (MST_THIS_SIGN & dwMsgEnhancement) {
            hr = VerifySignedMessage();
            if (FAILED(hr)) {
                goto exit;
            }
        } else {
            Assert(STREAM_OCCURING == m_csStatus);
            Assert(CSTM_STREAMING_DONE == m_csStream);
            if (g_FSupportV3 &&  (MST_THIS_ENCRYPT & dwMsgEnhancement)) {
                BOOL                f;
                DWORD               cbData = 0;
                LPBYTE              pb = NULL;
                
                f = CryptMsgGetParam(m_hMsg, CMSG_UNPROTECTED_ATTR_PARAM, 0, NULL, &cbData);
                if (!f) {
                    // Probably, message doesn't have a CMSG_UNPROTECTED_ATTR_PARAM
                    hr = HrGetLastError();
                    if(hr != CRYPT_E_ATTRIBUTES_MISSING)
                        goto exit;
                    else
                    {
                        hr = S_OK;
                        cbData = 0;
                    }
                }
                if (cbData != 0) {
                    if (!MemAlloc((LPVOID *) &pUnprotectedAttrs, cbData)) {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    f = CryptMsgGetParam(m_hMsg, CMSG_UNPROTECTED_ATTR_PARAM, 0, pUnprotectedAttrs, &cbData);
                    Assert(f);
                    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                             pUnprotectedAttrs, CRYPT_ENCODE_ALLOC_FLAG,
                                             &CryptEncodeAlloc, &pb, &cbData)) {
                        hr = HrGetLastError();
                        goto exit;
                    }
                    m_psldData->m_blobUnprotectAttrs.cbData = cbData;
                    m_psldData->m_blobUnprotectAttrs.pbData = pb;
                }
            }
        }
    }

    //
    // fill in some more of the data structure
    //

    if ((CSTM_DECODE & m_dwFlagsStm) &&
        (dwMsgEnhancement & MST_THIS_ENCRYPT)) {
        _SMimeCapsFromHMsg(m_hMsg, CMSG_ENVELOPE_ALGORITHM_PARAM,
                           &m_psldData->m_blobDecAlg.pBlobData,
                           &m_psldData->m_blobDecAlg.cbSize);
    }

    if (m_pCapiInner) {
        hr = m_pCapiInner->EndStreaming();
    }
exit:
    SafeMemFree(pUnprotectedAttrs);
    if (hr == ERROR_ACCESS_DENIED) {
        hr = E_ACCESSDENIED;    // convert CAPI error to OLE HRESULT
    }
    return(hr);
}

PSECURITY_LAYER_DATA CCAPIStm::GetSecurityLayerData() const
{
    if (m_psldData) {
        m_psldData->AddRef();
    }
    return(m_psldData);
}



///////////////////////////////////////////////////////////////////////////
//
// Implementation methods
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//
// Encode / Decode
//


HRESULT CCAPIStm::BeginEncodeStreaming(SMIMEINFO *const psi)
{
    DWORD                   cb;
    DWORD                   cbData;
    DWORD                   cCrls = 0;
    DWORD                   cCerts = 0;
    DWORD                   cSigners = 0;
    HRESULT                 hr;
    DWORD                   i;
    DWORD                   dwMsgType;
    DWORD                   dwFlags = 0;
    PCRYPT_KEY_PROV_INFO    pKPI;
    CMSG_STREAM_INFO        cmsi;
    DWORD                   dwPsiType;
    DWORD                   iSigner;
    PCRYPT_ATTRIBUTES       pattrsUnprot = NULL;
    PCRYPT_ATTRIBUTES *     rgpattrAuth = NULL;
    PCRYPT_ATTRIBUTES *     rgpattrUnauth = NULL;
#ifndef SMIME_V3
    PCRYPT_SMIME_CAPABILITIES pcaps = NULL;
#endif // SMIME_V3
    CMSG_RC2_AUX_INFO       rc2Aux;
    CRL_BLOB*               rgCrlBlob;
    PCRYPT_SMIME_CAPABILITIES * rgpcaps = NULL;
    CMSG_SIGNER_ENCODE_INFO *   rgSigner;
// #ifndef _WIN64
    union {
        struct {
// #endif
            // anything that comes first must be common (in size)
            // to both structures
            CERT_INFO**                 rgpCertInfo;
            CMSG_ENVELOPED_ENCODE_INFO  ceei;
// #ifndef _WIN64
        };
        struct {
// #endif
            CERT_BLOB*                  rgCertBlob;
            CMSG_SIGNED_ENCODE_INFO     csei;
// #ifndef _WIN64
        };
    };
// #endif

    ////////////
    // can only return from here down

    m_csStatus = STREAM_ERROR;
    rgSigner = NULL;

    if (!psi) {
        return E_POINTER;
    }

    //
    // Get the security operations to be performed on this body layer.
    //          we only care about the current body properties so mask out
    //          other layers.
    //  If we don't have any security to perform, then get out of here
    //
    
    dwPsiType = m_psldData->m_dwMsgEnhancement & MST_THIS_MASK;

    if (MST_NONE == dwPsiType) {
        AssertSz(dwPsiType != MST_NONE, "Why are we here if we have no security to apply?");
        return TrapError(MIME_E_SECURITY_NOOP);
    }

    //
    // detached is the only allowed user settable flag
    //
    
    if ((m_dwFlagsStm & CSTM_ALLFLAGS) & ~CSTM_DETACHED) {
        return TrapError(E_INVALIDARG);
    }

    rgCertBlob = NULL;
    rgCrlBlob = NULL;
    pKPI = NULL;

    ////////////
    // can goto end from here down

    //
    //  We should never be in a situation where we are going to both encrypt and sign
    //  a message.
    //
    
    AssertSz((!!(dwPsiType & MST_THIS_SIGN) +
              !!(dwPsiType & MST_THIS_ENCRYPT)) == 1,
             "Encrypt and Sign Same Layer is not legal");

    if (dwPsiType & MST_THIS_SIGN) {
        dwMsgType = CMSG_SIGNED;

        if (!(m_psldData->m_dwMsgEnhancement & MST_BLOB_FLAG)) {
            dwFlags |= CMSG_DETACHED_FLAG;
        }

        cSigners = m_psldData->m_cSigners;

        if (m_psldData->m_hcertstor != NULL) {
            hr = _InitEncodedCertIncludingSigners(m_psldData->m_hcertstor,
                                  cSigners, m_psldData->m_rgSigners,
                                  &rgCertBlob, &cCerts,
                                  &rgCrlBlob, &cCrls);
            if (FAILED(hr)) {
                goto exit;
            }
        }

        cb = sizeof(CMSG_SIGNER_ENCODE_INFO) * cSigners;
        if (!MemAlloc((LPVOID *) &rgSigner, cb)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgSigner, 0, cb);

        cb = sizeof(PCRYPT_SMIME_CAPABILITIES) * cSigners;
        if (!MemAlloc((LPVOID *) &rgpcaps, cb)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpcaps, 0, cb);

        if (!MemAlloc((LPVOID *) &rgpattrAuth, cSigners*sizeof(PCRYPT_ATTRIBUTES))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpattrAuth, 0, cSigners*sizeof(PCRYPT_ATTRIBUTES));

        if (!MemAlloc((LPVOID *) &rgpattrUnauth, cSigners*sizeof(PCRYPT_ATTRIBUTES))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpattrUnauth, 0, cSigners*sizeof(PCRYPT_ATTRIBUTES));

        for (iSigner=0; iSigner<cSigners; iSigner++) {
            rgSigner[iSigner].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
            rgSigner[iSigner].pvHashAuxInfo = NULL;

            //  We need to pull apart the algorithm used to sign the message so
            //     we can pass it down to the crypt32 code

            hr = HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobHashAlg.pBlobData,
                                m_psldData->m_rgSigners[iSigner].blobHashAlg.cbSize,
                                PKCS_SMIME_CAPABILITIES, 0, &cbData,
                                (LPVOID *)&rgpcaps[iSigner]);
            if (FAILED(hr)) {
                goto exit;
            }

            // MOOBUG -- MEMORY LEAK ON PCAPS!!!!

            Assert(rgpcaps[iSigner] != NULL);
            Assert(rgpcaps[iSigner]->cCapability == 1);
            rgSigner[iSigner].HashAlgorithm.pszObjId = rgpcaps[iSigner]->rgCapability[0].pszObjId;
            rgSigner[iSigner].HashAlgorithm.Parameters.cbData = rgpcaps[iSigner]->rgCapability[0].Parameters.cbData;
            rgSigner[iSigner].HashAlgorithm.Parameters.pbData = rgpcaps[iSigner]->rgCapability[0].Parameters.pbData;

            //
            //  Need to setup the attributes to attach to the signed message
            //

            if (m_psldData->m_rgSigners[iSigner].blobAuth.cbSize != 0) {
                cbData = 0;
                hr = HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobAuth.pBlobData,
                                    m_psldData->m_rgSigners[iSigner].blobAuth.cbSize,
                                    szOID_Microsoft_Attribute_Sequence, 0,
                                    &cbData, (LPVOID *)&rgpattrAuth[iSigner]);
                if (FAILED(hr)) {
                    goto exit;
                }

                if (rgpattrAuth[iSigner] != NULL) {
                    rgSigner[iSigner].cAuthAttr = rgpattrAuth[iSigner]->cAttr;
                    rgSigner[iSigner].rgAuthAttr = rgpattrAuth[iSigner]->rgAttr;
                    Assert(m_pattrAuth == NULL);
                    if (!g_FSupportV3) {
                        //  This code exists for old versions of crypt32.  Prior to
                        //  the NT5 re-write the capi code did not copy the attributes
                        //  but assumed that we must have done so.
                        m_pattrAuth = rgpattrAuth[iSigner];
                        rgpattrAuth[iSigner] = NULL;
                    }
                } else {
                    Assert(rgSigner[iSigner].cAuthAttr == 0);
                    Assert(rgSigner[iSigner].rgAuthAttr == NULL);
                }
            }

            if (m_psldData->m_rgSigners[iSigner].blobUnauth.cbSize != 0) {
                cbData = 0;
                HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobUnauth.pBlobData,
                               m_psldData->m_rgSigners[iSigner].blobUnauth.cbSize,
                               szOID_Microsoft_Attribute_Sequence, 0,
                               &cbData, (LPVOID *)&rgpattrUnauth[iSigner]);
                if (FAILED(hr)) {
                    goto exit;
                }

                if (rgpattrUnauth[iSigner] != NULL) {
                    rgSigner[iSigner].cUnauthAttr = rgpattrUnauth[iSigner]->cAttr;
                    rgSigner[iSigner].rgUnauthAttr = rgpattrUnauth[iSigner]->rgAttr;
                } else {
                    Assert(rgSigner[iSigner].cUnauthAttr == 0);
                    Assert(rgSigner[iSigner].rgUnauthAttr == NULL);
                }
            }

            // load the provider information from the signing cert and then
            // acquire that provider with the appropriate key container

            hr = HrGetCertificateParam(m_psldData->m_rgSigners[iSigner].pccert,
                                       CERT_KEY_PROV_INFO_PROP_ID,
                                       (LPVOID *) &pKPI, NULL);
            if (FAILED(hr)) {
                goto gle;
            }

            if (!m_hProv && ! CRYPT_ACQUIRE_CONTEXT(&m_hProv, pKPI->pwszContainerName,
                                        pKPI->pwszProvName, pKPI->dwProvType,
                                        pKPI->dwFlags)) {
                goto gle;
            }
            Assert(0 == pKPI->cProvParam);

#ifdef SMIME_V3
            if (psi->pwszKeyPrompt != NULL) {
                CryptSetProvParam(m_hProv, PP_UI_PROMPT, (LPBYTE) psi->pwszKeyPrompt, 0);
            }
#endif // SMIME_V3

            rgSigner[iSigner].pCertInfo = m_psldData->m_rgSigners[iSigner].pccert->pCertInfo;
            rgSigner[iSigner].hCryptProv = m_hProv;
            rgSigner[iSigner].dwKeySpec = pKPI->dwKeySpec;

            //
            //  Need to change dsa to dsa-with-sha1
            //

            if (strcmp(rgSigner[iSigner].pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId, szOID_OIWSEC_dsa) == 0) {
                rgSigner[iSigner].HashEncryptionAlgorithm.pszObjId = szOID_OIWSEC_dsaSHA1;
            }
        }

        csei.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        csei.cSigners = m_psldData->m_cSigners;
        csei.rgSigners = rgSigner;
        csei.cCertEncoded = cCerts;
        csei.rgCertEncoded = rgCertBlob;
        csei.cCrlEncoded = cCrls;
        csei.rgCrlEncoded = rgCrlBlob;
    }
    
    //
    //  If it is not signed, then it must be encrypted.  Setup the calls for
    //  performing an encryption operation.
    //
    else {
        Assert((dwPsiType & MST_THIS_ENCRYPT) != 0);
        
        dwMsgType = CMSG_ENVELOPED;

        //
        //  If we are given a CSP, then we are going to pass it on to the Crypt32 code,
        //      However it turns out that we are the ones who release the CSP so store it
        //      locally into the class object.
        //

        Assert(m_hProv == NULL);
        m_hProv = psi->hProv;
        psi->hProv = NULL;

        //
        //  Extract out the bulk encryption algorithm we are going to apply to
        //      the body of the message.  This algorithm is the same across all
        //      the different key transfer algorthms.
        //

        //
        //  Setup the structure containing all of the encryption parameters for the 
        //      Message Encode function.  This structure gets setup differently
        //      depending on the version of Crypt32 which we are running on.
        //
        
        memset(&ceei, 0, sizeof(ceei));
        ceei.cbSize = sizeof(CMSG_ENVELOPED_ENCODE_INFO);
        ceei.hCryptProv = m_hProv;
        ceei.ContentEncryptionAlgorithm = m_psldData->m_ContentEncryptAlgorithm;
        ceei.pvEncryptionAuxInfo = m_psldData->m_pvEncryptAuxInfo;

        if (g_FSupportV3) {
            ceei.cRecipients = m_psldData->m_cEncryptItems;
            ceei.rgCmsRecipients = m_psldData->m_rgRecipientInfo;

            if (m_psldData->m_blobUnprotectAttrs.cbData > 0) {
                CHECKHR(hr = HrDecodeObject(m_psldData->m_blobUnprotectAttrs.pbData,
                                            m_psldData->m_blobUnprotectAttrs.cbData,
                                            szOID_Microsoft_Attribute_Sequence, 0,
                                            &cbData, (LPVOID *) &pattrsUnprot));
                ceei.cUnprotectedAttr = pattrsUnprot->cAttr;
                ceei.rgUnprotectedAttr = pattrsUnprot->rgAttr;
            }

            //
            //  Allow for certificates to be carried on the encryption package now
            //  need this for Fortezza static-static implementation.
            //
            
            if (m_psldData->m_hstoreEncrypt != NULL) {
                hr = _InitEncodedCert(m_psldData->m_hstoreEncrypt, &rgCertBlob, &cCerts,
                                      &rgCrlBlob, &cCrls);
                if (FAILED(hr)) {
                    goto exit;
                }

                ceei.cCertEncoded = cCerts;
                ceei.rgCertEncoded = rgCertBlob;
                ceei.cCrlEncoded = cCrls;
                ceei.rgCrlEncoded = rgCrlBlob;
            }
        }
        else {
            PCERT_INFO        pinfo;
            
            if (!MemAlloc((LPVOID *) &ceei.rgpRecipients,
                          (sizeof(CERT_INFO) + sizeof(PCERT_INFO)) * m_psldData->m_cEncryptItems)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(ceei.rgpRecipients, 0,
                   (sizeof(CERT_INFO) + sizeof(PCERT_INFO)) * m_psldData->m_cEncryptItems);
            ceei.cRecipients = m_psldData->m_cEncryptItems;
            pinfo = (PCERT_INFO) ((ceei.cRecipients * sizeof(PCERT_INFO)) +
                                  (LPBYTE) ceei.rgpRecipients);

            for (i=0; i<ceei.cRecipients; i++, pinfo++) {
                ceei.rgpRecipients[i] = pinfo;
                
                Assert(m_psldData->m_rgRecipientInfo[i].dwRecipientChoice == CMSG_KEY_TRANS_RECIPIENT);

                pinfo->SubjectPublicKeyInfo.Algorithm = m_psldData->m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm;
                pinfo->SubjectPublicKeyInfo.PublicKey = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey;

                
                Assert(m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_ISSUER_SERIAL_NUMBER);
                pinfo->Issuer = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer;
                pinfo->SerialNumber = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber;
            }
        }
    }

    // Do we need to recurse and wrap ourselves in an Outer Layer?
    if (m_psldData->m_psldOuter) {
        CSSDOUT("Streaming wrapped message (type: %x)", m_psldData->m_psldOuter->m_dwMsgEnhancement);

        hr = InitInner(psi, NULL, m_psldData->m_psldOuter);
        if (FAILED(hr)) {
            goto exit;
        }

        // This will write the header to the new inner CAPI stream
        if (m_pstmOut) {
            CONVINITINFO ci = {0};

            // Create a conversion stream
            ci.ietEncoding = IET_BASE64;
            ci.fEncoder = TRUE;
            TrapError(HrCreateInternetConverter(&ci, &m_pConverter));

            m_pstmOut->Write(s_cszMimeHeader, sizeof(s_cszMimeHeader)-1, NULL);
            if (m_psldData->m_dwMsgEnhancement & MST_THIS_ENCRYPT) {
                m_pstmOut->Write(STR_SMT_ENVELOPEDDATA,
                                 lstrlen(STR_SMT_ENVELOPEDDATA), NULL);
            }
            else {
                if ((psi->pszInnerContent != NULL) &&
                    (strcmp(psi->pszInnerContent,
                            szOID_SMIME_ContentType_Receipt) == 0)) {
                    m_pstmOut->Write(STR_SMT_SIGNEDRECEIPT,
                                     lstrlen(STR_SMT_SIGNEDRECEIPT), NULL);
                }
                else {
                    m_pstmOut->Write(STR_SMT_SIGNEDDATA,
                                     lstrlen(STR_SMT_SIGNEDDATA), NULL);
                }
            }

            m_pstmOut->Write(c_szCRLF,          lstrlen(c_szCRLF), NULL);
            m_pstmOut->Write(STR_HDR_CNTXFER,   lstrlen(STR_HDR_CNTXFER), NULL);
            m_pstmOut->Write(c_szColonSpace,    lstrlen(c_szColonSpace), NULL);
            if (m_pConverter) {
                m_pstmOut->Write(STR_ENC_BASE64,    lstrlen(STR_ENC_BASE64), NULL);
            } else {
                // Failed to create the conversion stream.  Try sending binary anyway.
                // (Netscape can't read it, but most others can.)
                m_pstmOut->Write(STR_ENC_BINARY,    lstrlen(STR_ENC_BINARY), NULL);
            }
            m_pstmOut->Write(c_szCRLF,          lstrlen(c_szCRLF), NULL);
            m_pstmOut->Write(s_cszMimeHeader2,  sizeof(s_cszMimeHeader2)-1, NULL);
            m_pstmOut->Write(c_szCRLFCRLF,      lstrlen(c_szCRLFCRLF), NULL);
        }
    }

    //
    //  Since the write code is so bad for buffering, lets do the buffering here.
    //  Ignore all errors on return, if the buffer is not allocated then we just
    //  get the same poor performance as before.
    //

    MemAlloc((LPVOID *) &m_pbBuffer, CbCacheBufferSize);

    //
    //

    if (psi->pszInnerContent != NULL) {
        cmsi.cbContent = psi->cbInnerContent;
    }
    else {
        cmsi.cbContent = (DWORD) -1;    // indefinite-lenght BER encoding
    }
    cmsi.pfnStreamOutput = CBStreamOutput;
    cmsi.pvArg = (void *)this;

    m_hMsg = CryptMsgOpenToEncode(
                                  CRYPT_ASN_ENCODING|PKCS_7_ASN_ENCODING,
                                  CMSG_CMS_ENCAPSULATED_CONTENT_FLAG | dwFlags,
                                  dwMsgType,                                
//                                  (dwMsgType == CMSG_SIGNED) ? ((void *) &csei) : ((void *) &ceei),      // really depends on the union
                                  &ceei, 
                                  psi->pszInnerContent,
                                  &cmsi);
    if (! m_hMsg) {
        goto gle;
    }

    //
    //  Put the top level into either DETACHED or STREAM based on if we are
    //  doing detached signing or blob signing/encryption.
    //
    //  Put the low level stream into the write through state so it moves all
    //  data out to the output stream. (If no output stream then mark as no
    //  output streaming.)
    //

    m_csStatus = (m_dwFlagsStm & CSTM_DETACHED) ? STREAM_DETACHED_OCCURING : STREAM_OCCURING;
    m_csStream = m_pstmOut ? CSTM_STREAMING : CSTM_GOTTYPE;
    hr = S_OK;

exit:
    if (!g_FSupportV3 && (dwPsiType & MST_THIS_ENCRYPT)) {
        MemFree(ceei.rgpRecipients);
    }
    
    ReleaseMem(pKPI);
    if (rgCertBlob)  {
        g_pMoleAlloc->Free(rgCertBlob);  //also rgpCertInfo
    }
    if (rgCrlBlob)  {
        g_pMoleAlloc->Free(rgCrlBlob);
    }
    if (rgpcaps != NULL) {
        for (iSigner=0; iSigner<cSigners; iSigner++) {
            MemFree(rgpcaps[iSigner]);
        }
        MemFree(rgpcaps);
    }
    SafeMemFree(rgSigner);
    SafeMemFree(pattrsUnprot);
    for (iSigner=0; iSigner<cSigners; iSigner++) {
        SafeMemFree(rgpattrAuth[iSigner]);
        SafeMemFree(rgpattrUnauth[iSigner]);
    }
    SafeMemFree(rgpattrAuth);
    SafeMemFree(rgpattrUnauth);

    Assert(m_hMsg || S_OK != hr);
    return TrapError(hr);
gle:
    hr = HrGetLastError();
    goto exit;
}

HRESULT CCAPIStm::BeginDecodeStreaming(
    SMIMEINFO *const  psi)
{
    CMSG_STREAM_INFO    cmsi;

    if (CSTM_TYPE_ONLY & m_dwFlagsStm) {
        if (CSTM_DETACHED & m_dwFlagsStm) {
            return E_INVALIDARG;
        }
    }

    m_dwFlagsStm |= CSTM_DECODE;

    if (psi) {
        // SMIME3: if there is a cert in the associated layer data, duplicate it up here.
        // BUGBUG: NYI

        m_hProv = psi->hProv;
        psi->hProv = NULL;

        // Copy the array of cert stores up here
        if (psi->cStores) {
            m_rgStores = (HCERTSTORE*)g_pMalloc->Alloc(psi->cStores * sizeof(HCERTSTORE));
            if (! m_rgStores) {
                return(E_OUTOFMEMORY);
            }

            for (DWORD i = 0; i < psi->cStores; i++) {
                m_rgStores[i] = CertDuplicateStore(psi->rgStores[i]);
            }
            m_cStores = psi->cStores;
        }
// HACK!!! HACK!!!! for WIN64
#ifndef _WIN64
#ifdef SMIME_V3
        UNALIGNED WCHAR *wsz = psi->pwszKeyPrompt;
        if (wsz != NULL) {
            m_pwszKeyPrompt = PszDupW((LPCWSTR) wsz);
            if (m_pwszKeyPrompt == NULL) {
                return(E_OUTOFMEMORY);
            }
        }
#endif // SMIME_V3
#endif //_WIN64
    }


    cmsi.cbContent = (DWORD)-1;  // indefinite-length BER encoding
    cmsi.pfnStreamOutput = CBStreamOutput;
    cmsi.pvArg = (void *)this;

    m_hMsg = CryptMsgOpenToDecode(
      CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
      (m_dwFlagsStm & CSTM_DETACHED) ? CMSG_DETACHED_FLAG : 0,
      0,          // don't know the type
      m_hProv,    // needed for verify, but not decrypt
      NULL,       // pRecipientInfo
      &cmsi);

    if (m_hMsg) {
        m_csStatus = (m_dwFlagsStm & CSTM_DETACHED) ? STREAM_DETACHED_OCCURING : STREAM_QUESTION_TIME;
    } else {
        m_csStatus = STREAM_ERROR;
    }

    Assert(m_hMsg || S_OK != HrGetLastError());
    return m_hMsg ? S_OK : HrGetLastError();
}


///////////////////////////////////////////////////////////////////////////
//
// Callback and helpers/crackers
//


BOOL WINAPI CCAPIStm::CBStreamOutput(
    const void *pvArg,
    BYTE *pbData,
    DWORD cbData,
    BOOL fFinal)
{
    Assert(pvArg);
    return((CCAPIStm*)pvArg)->StreamOutput(pbData, cbData, fFinal);
}


BOOL CCAPIStm::StreamOutput(
    BYTE *  pbData,
    DWORD   cbData,
    BOOL    fFinal)
{
    HRESULT             hr = S_OK;
    int                 iEOH;
#ifdef SMIME_V3
    LPSTR               szContentType = NULL;
#endif // SMIME_V3

    // m_csStream should be one of the CSTM states at this point, if not then
    //          we are in error.

    Assert((m_csStream == CSTM_GOTTYPE) || (m_csStream == CSTM_FIRST_WRITE) ||
           (m_csStream == CSTM_TEST_NESTING) || (m_csStream == CSTM_STREAMING));

    //  If all we are doing is looking for the type, then we know that
    //  we already have one at this point.  There is no need to put the
    //  output of the Crypto code anyplace as it is not part of what we
    //  are looking for.

    if (CSTM_GOTTYPE == m_csStream) {
        return TRUE;
    }

    //  If we have no output stream, then all we need to do is the state
    //  transistion on fFinal being true.
    if (m_pstmOut == NULL) {
        if (fFinal) {
            m_csStream = CSTM_STREAMING_DONE;
        }
        return TRUE;
    }

    //
    // Test for an enclosed opaque S/MIME message
    // the client doesn't care about this level of goo, so hide it and
    // stream this data into a new CAPIStm, letting it stream out the
    // real stuff.
    //

    if (CSTM_FIRST_WRITE == m_csStream) {
        // this is the position of the beginning of any
        // possible MIME header
        if (FAILED(HrGetStreamPos(m_pstmOut, &m_cbBeginWrite)) ||
            FAILED(HrGetStreamSize(m_pstmOut, &m_cbBeginSize))) {
            m_cbBeginWrite = 0;
            m_cbBeginSize = 0;
        } else {
            // reset position
            HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
        }

        m_csStream = CSTM_TEST_NESTING;
#ifdef SMIME_V3
        if (szContentType = (LPSTR)PVGetMsgParam(m_hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, NULL, NULL)) {
            if (lstrcmp(szOID_PKCS_7_DATA, szContentType)) {
                hr = m_pstmOut->Write(s_cszOIDMimeHeader1, strlen(s_cszOIDMimeHeader1), NULL);
                if (SUCCEEDED(hr)) {
                    hr = m_pstmOut->Write(szContentType, strlen(szContentType), NULL);
                }                    
                if (SUCCEEDED(hr)) {
                    hr = m_pstmOut->Write(s_cszOIDMimeHeader2, strlen(s_cszOIDMimeHeader2), NULL);
                }          
                if (FAILED(hr)) {
                    return FALSE;
                }
                m_csStream = CSTM_STREAMING;
            }
        }
#endif // SMIME_V3
        
    }

    if (CSTM_TEST_NESTING == m_csStream &&
        (-1 != (iEOH = SniffForEndOfHeader(pbData, cbData)))) {
        CMimePropertyContainer *pContHeader;

        // get the position of the first char of the body
        iEOH = cbData - iEOH + 1;

        pContHeader = new CMimePropertyContainer;
        if (pContHeader) {
            hr = pContHeader->InitNew();
            if (SUCCEEDED(hr)) {
                ULONG posCurrent;

                // write out the last bit of the header data
                // then move back to the header's start after
                // saving our current position
                hr = m_pstmOut->Write(pbData, iEOH, NULL);
                if (SUCCEEDED(hr)) {
                    // fixup the amount of data in pbData so
                    // only body stuff gets written to the stream
                    // . . . we've already written the header
                    pbData += iEOH;
                    cbData -= iEOH;

                    HrGetStreamPos(m_pstmOut, &posCurrent);
                    HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
                    hr = pContHeader->Load(m_pstmOut);
#ifdef DEBUG
                    BYTE *pbHeader;
                    DWORD cbHeader;
                    HrStreamToByte(m_pstmOut, &pbHeader, &cbHeader);
                    SafeMemFree(pbHeader);
#endif
                    // if we don't have an inner message, need to reset
                    // the stream back to where we were
                    HrStreamSeekSet(m_pstmOut, posCurrent);
                }
            }
            if (SUCCEEDED(hr)) {
                CSSDOUT("Loaded an inner header.");
                if (IsOpaqueSecureContentType(pContHeader)) {
                    CSSDOUT("Sniffed an inner PKCS#7.");

                    // the HandleNesting call will reset m_pstmOut
                    TrapError(HandleNesting(pContHeader));
                }

                m_csStream = CSTM_STREAMING;
            }
#ifdef DEBUG
            else {
                CSSDOUT("Load of inner header failed.");
            }
#endif
            pContHeader->Release();
        }
    }

    if (fFinal) {
        m_csStream = CSTM_STREAMING_DONE;
    }

    if (m_pConverter) {
        BLOB blob;

        blob.pBlobData = pbData;
        blob.cbSize = cbData;

        hr = m_pConverter->HrFillAppend(&blob);
        if (SUCCEEDED(hr)) {
            if (m_dwFlagsStm & CSTM_DECODE) {
                hr = m_pConverter->HrInternetDecode(fFinal);
            }
            else {
                hr = m_pConverter->HrInternetEncode(fFinal);
            }
        }
        if (SUCCEEDED(hr)) {
            hr = m_pConverter->HrWriteConverted(m_pstmOut);
        }
        else {
            hr = m_pstmOut->Write(pbData, cbData, NULL);
        }
    }
    else {
        hr = m_pstmOut->Write(pbData, cbData, NULL);
    }

#ifdef SMIME_V3
    MemFree(szContentType);
#endif // SMIME_V3
    return SUCCEEDED(hr) ? TRUE : FALSE;
}


/*  SniffForEndOfHeader:
**
**  Purpose:
**      see if we have accumulated two blank lines in a row
**  Takes:
**      a buffer to scan and size of the buffer
**  Returns:
**      number of characters from the end of the second \n
*/
int CCAPIStm::SniffForEndOfHeader(
    BYTE *  pbData,
    DWORD   cbData)
{
    BOOL fCR, fEOL;

    // state is saved b/c the double blank could cross
    // a buffer chunk's boundary

    // restore old state and also reset
    fCR = m_dwFlagsStm & CSTM_HAVECR;
    fEOL = m_dwFlagsStm & CSTM_HAVEEOL;
    if (fCR || fEOL) {
        m_dwFlagsStm &= ~(CSTM_HAVECR | CSTM_HAVEEOL);
    }

    while (cbData) {
        if (chCR == *pbData) {
            fCR = TRUE;
        }
        else if (fCR && (chLF == *pbData)) {
            if (fEOL) {
                // double blank line
                return cbData;
            }
            fCR = FALSE;
            fEOL = TRUE;
        }
        else {
            fCR = FALSE;
            fEOL = FALSE;
        }
        pbData++;
        cbData--;
    }

    // state was reset above.  persist if we need to.
    if (fCR || fEOL) {
        m_dwFlagsStm |= (fCR ? CSTM_HAVECR : 0) | (fEOL ? CSTM_HAVEEOL : 0);
    }
    return -1;
}

HRESULT CCAPIStm::HandleNesting(CMimePropertyContainer *pContHeader)
{
    ENCODINGTYPE    iet;

    iet = pContHeader->GetEncodingType();
    if (!(IET_BINARY == iet || IET_7BIT == iet || IET_8BIT == iet)) {
        CONVINITINFO    ciiDecode;

        // we actually need to decode

        ciiDecode.dwFlags = 0;
        ciiDecode.ietEncoding = iet;
        ciiDecode.fEncoder = FALSE;

        TrapError(HrCreateInternetConverter(&ciiDecode, &m_pConverter));
    }
    return InitInner();
}

HRESULT CCAPIStm::InitInner()
{
    SMIMEINFO       siBuilt;
    ULARGE_INTEGER  liSize;

    // Init siBuilt
    memset(&siBuilt, 0, sizeof(siBuilt));

    // now also fixup the stream back to a near original
    // state.  if for some reason the data written after
    // now is smaller than the header is, this
    // work will make sure we don't keep bits of the header
    HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
    liSize.LowPart = m_cbBeginSize;
    liSize.HighPart = m_cbBeginWrite;
    m_pstmOut->SetSize(liSize);

    siBuilt.hProv = m_hProv;

#ifdef OLD_STUFF
    // BUGBUG: Is something like this needed?
    siBuilt.ssEncrypt.pcDecryptionCert = m_pUserCertDecrypt;
#endif // OLD_STUFF

    siBuilt.cStores = m_cStores;
    siBuilt.rgStores = m_rgStores;
    return InitInner(&siBuilt);
}


HRESULT CCAPIStm::InitInner(
    SMIMEINFO *const    psi,
    CCAPIStm *          pOuter,
    PSECURITY_LAYER_DATA psldOuter)
{
    HRESULT     hr;

    if (! pOuter) {
        m_pCapiInner = new CCAPIStm(m_pstmOut);

        CHECKHR(hr = m_pCapiInner-> HrInnerInitialize(m_dwFlagsSEF, m_hwnd, m_dwFlagsStm, m_pSmimeCallback, psldOuter));

        if (!psldOuter) {
            // Hook up the chain of Security Layer Data objects.
            Assert(! m_psldData->m_psldInner);
            m_pCapiInner->m_psldData->AddRef();
            m_psldData->m_psldInner = m_pCapiInner->m_psldData;
            if (m_pCapiInner->m_psldData) {
                // Init the Up pointer of the new layer data
                m_pCapiInner->m_psldData->m_psldOuter = m_psldData;
            }
        }

        // recurse
        return m_pCapiInner->InitInner(psi, this, psldOuter);
    }

    Assert(!m_pCapiInner);
    Assert(pOuter);
    Assert(psi);

    m_dwFlagsStm = pOuter->m_dwFlagsStm & CSTM_ALLFLAGS;


    // This will get me involved
    ReleaseObj(pOuter->m_pstmOut);
    pOuter->m_pstmOut = (IStream*)this;
    AddRef();   // outer is holding 1

    m_dwFlagsStm |= CSTM_RECURSED;
    if (pOuter->m_dwFlagsStm & CSTM_DECODE) {
        hr = BeginDecodeStreaming(psi);
    }
    else {
        // don't support detached inner CRYPTMSGs
        m_dwFlagsStm &= ~CSTM_DETACHED;

        hr = BeginEncodeStreaming(psi);
    }
    m_dwFlagsStm &= ~CSTM_RECURSED;

exit:
    return hr;
}


//
// Gets the immediate outermost decryption cert (if any).
//
PCCERT_CONTEXT CCAPIStm::GetOuterDecryptCert()
{
    PCCERT_CONTEXT       pccertDecrypt = NULL;
    PSECURITY_LAYER_DATA psldOuter = NULL;

    Assert(NULL != m_psldData);
    if (NULL != m_psldData) {
        psldOuter = m_psldData->m_psldOuter;    
    }
    
    while (NULL != psldOuter) {
        if (NULL != psldOuter->m_pccertDecrypt) {
            Assert( MST_ENCRYPT_MASK & (psldOuter->m_dwMsgEnhancement) );
            pccertDecrypt = psldOuter->m_pccertDecrypt;
            break;
        }
        psldOuter = psldOuter->m_psldOuter;
    }
    
    return pccertDecrypt;
}

HCERTSTORE
OpenAllStore(
    IN DWORD cStores,
    IN HCERTSTORE rgStores[],
    IN OUT HCERTSTORE *phCertStoreAddr,
    IN OUT HCERTSTORE *phCertStoreCA,
    IN OUT HCERTSTORE *phCertStoreMy,
    IN OUT HCERTSTORE *phCertStoreRoot
    )
{
    HCERTSTORE hstoreAll;
    DWORD i;

    hstoreAll = CertOpenStore(CERT_STORE_PROV_COLLECTION, X509_ASN_ENCODING,
                              NULL, 0, NULL);
    if (hstoreAll == NULL) {
        return NULL;
    }


    for (i=0; i<cStores; i++) {
        CertAddStoreToCollection(hstoreAll, rgStores[i], 0, 0);
    }

    //  Open the standard system stores

    *phCertStoreAddr = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   s_cszWABCertStore);
    if (*phCertStoreAddr != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreAddr, 0, 0);
    }

    *phCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, s_cszMy);
    if (*phCertStoreMy != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreMy, 0, 0);
    }
    
    *phCertStoreCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, s_cszCA);
    if (*phCertStoreCA != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreCA, 0, 0);
    }

    *phCertStoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, "Root");
    if (*phCertStoreRoot != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreRoot, 0, 0);
    }

    return hstoreAll;
}

///////////////////////////////////////////////////////////////////////////
//
// The enveloped and signed message parsers
//


/*  VerifySignedMessage:
**
**  Purpose:
**      Using CAPI, this loads the certs from the message and tests to find
**      the one hopefully used to sign the message.  CAPI builds a new hash
**      using this cert and compares it with the hash from the SignerInfo.
**  Takes:
**      IN hMsg     - built CAPI message containing cyphertext
**      OUT psi     - certificate used for signing, and if it was part of hMsg
**      OUT OPTIONAL pPlain  - blob containing cleartext
**  Returns:
**      MIME_E_SECURITY_MULTSIGNERS if cSigners > 1.  We can't deal.
**      MIME_E_SECURITY_BADCONTENT if I don't understand the message type of the
**          inner data
**      else S_OK or E_FAIL
*/
HRESULT CCAPIStm::VerifySignedMessage()
{
    CRYPT_SMIME_CAPABILITIES cap;
    DWORD               cbData = 0;
    DWORD               cCerts;
    DWORD               cSigners = 0;
    DWORD               dexStore;
    BOOL                f;
#ifdef SMIME_V3    
    BOOL                fLookForReceiptRequest = TRUE;
#endif // SMIME_V3    
    HCERTSTORE          hCertStoreAddr = NULL;
    HCERTSTORE          hCertStoreCA = NULL;
    HCERTSTORE          hCertStoreMy = NULL;
    HCERTSTORE          hCertStoreRoot = NULL;
    HCERTSTORE          hMsgCertStore = NULL;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               iSigner;
#ifdef SMIME_V3
    DWORD               iSignData;
    CRYPT_ATTR_BLOB     attrReceiptReq = {0};
    CRYPT_ATTR_BLOB     attrSecLabel = {0};
    DWORD               cblabel;
    CMSG_CMS_SIGNER_INFO                cmsSignerInfo;
    DWORD                               dwCtrl;
    HCERTSTORE                          hstoreAll = NULL;
    PSMIME_RECEIPT_REQUEST preq = NULL;
    PSMIME_SECURITY_LABEL  plabel = NULL;
    CMSG_CMS_SIGNER_INFO *              pCmsSignerInfo = NULL;
    LPVOID                              pv;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA  verifySignature;
#endif // SMIME_V3    
    PCCERT_CONTEXT      pccertSigner = NULL;
    SignerData *        pSignerData = NULL;
    PCMSG_SIGNER_INFO   pSignerInfo = NULL;
    CERT_INFO           SignerId;
    LPSTR               szContentType = NULL;

    Assert(m_hMsg);
    Assert(m_psldData->m_fCertInLayer == FALSE);

    // Get the number of signers
    cbData = sizeof(cSigners);
    f = CryptMsgGetParam(m_hMsg, CMSG_SIGNER_COUNT_PARAM, 0, &cSigners, &cbData);
    if (!f) {
        goto CryptoError;
    }
    if (cSigners == 0) {
        hr = MIME_E_NO_SIGNER;
        goto ErrorReturn;
    }

    // Allocate space to hold the signer information

    if (!MemAlloc((LPVOID *) &pSignerData, cSigners * sizeof(SignerData))) {
        hr = E_OUTOFMEMORY;
        goto ErrorReturn;
    }
    m_psldData->m_rgSigners = pSignerData;
    m_psldData->m_cSigners = cSigners;

    //  Initialized to a known state
    memset(pSignerData, 0, cSigners * sizeof(SignerData));
    for (i=0; i<cSigners; i++) {
        pSignerData[i].ulValidity = MSV_UNVERIFIABLE;
    }

    // If there are certificates in the message, get a store provider which
    //  maps to the certificates in the message for later lookup.

    Assert(sizeof(cCerts) == cbData);
    f = CryptMsgGetParam(m_hMsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbData);
    Assert(f);

    if (f && cCerts) {
        // since there are certs included, let's try them first when matching
        // certs with signers.

        // get the store set
        // make sure we keep hold of our provider
        hMsgCertStore = CertOpenStore(CERT_STORE_PROV_MSG, X509_ASN_ENCODING,
                                      m_hProv, 0, m_hMsg);
        if (hMsgCertStore) {
            m_dwFlagsStm |= CSTM_DONTRELEASEPROV;  // given unto the store
        }

        // if it failed, we just don't have a store then
        Assert(hMsgCertStore != NULL);
        m_psldData->m_hcertstor = CertDuplicateStore(hMsgCertStore);
    }

    //
    //  Walk through each and every signature attempting to verify each signature
    //

    for (iSigner=0; iSigner<cSigners; iSigner++, pSignerData++) {
        //  Preconditions
        Assert(pccertSigner == NULL);

        // release the signer info from the previous iteration.
        SafeMemFree(pSignerInfo);
        if (pCmsSignerInfo != &cmsSignerInfo) {
            SafeMemFree(pCmsSignerInfo);
        }

        // get the issuer and serial number from the ith SignerInfo
        if (g_FSupportV3) {
            hr = HrGetMsgParam(m_hMsg, CMSG_CMS_SIGNER_INFO_PARAM, iSigner,
                               (LPVOID *) &pCmsSignerInfo, NULL);
            if (FAILED(hr)) {
                goto ErrorReturn;
            }
        }
        else {
            hr = HrGetMsgParam(m_hMsg, CMSG_SIGNER_INFO_PARAM, iSigner,
                               (LPVOID *) &pSignerInfo, NULL);
            if (FAILED(hr)) 
            {
                goto ErrorReturn;
            }
            cmsSignerInfo.dwVersion = pSignerInfo->dwVersion;
            cmsSignerInfo.SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            cmsSignerInfo.SignerId.IssuerSerialNumber.Issuer = pSignerInfo->Issuer;
            cmsSignerInfo.SignerId.IssuerSerialNumber.SerialNumber = pSignerInfo->SerialNumber;
            cmsSignerInfo.HashAlgorithm = pSignerInfo->HashAlgorithm;
            cmsSignerInfo.HashEncryptionAlgorithm = pSignerInfo->HashEncryptionAlgorithm;
            cmsSignerInfo.EncryptedHash = pSignerInfo->EncryptedHash;
            cmsSignerInfo.AuthAttrs = pSignerInfo->AuthAttrs;
            cmsSignerInfo.UnauthAttrs = pSignerInfo->UnauthAttrs;

            pCmsSignerInfo = &cmsSignerInfo;

            // (post-SDR)
            // Build up IASN

            SignerId.Issuer = pSignerInfo->Issuer;
            SignerId.SerialNumber = pSignerInfo->SerialNumber;
        }

        // Our best bet to easily find a certificate is in the message provided
        //      list of certificates.

        if (hMsgCertStore) {
            if (g_FSupportV3) {
                pccertSigner = CertFindCertificateInStore(hMsgCertStore, X509_ASN_ENCODING, 0,
                                                         CERT_FIND_CERT_ID, 
                                                         &pCmsSignerInfo->SignerId, NULL);
            }
            else {
                pccertSigner = CertGetSubjectCertificateFromStore(hMsgCertStore,
                                                         X509_ASN_ENCODING, &SignerId);
            }
            if (pccertSigner != NULL) {
                m_psldData->m_fCertInLayer = TRUE;
            }
        }

        if (pccertSigner == NULL) {
            if (g_FSupportV3) {
                hstoreAll = OpenAllStore(
                    m_cStores,
                    m_rgStores,
                    &hCertStoreAddr,
                    &hCertStoreCA,
                    &hCertStoreMy,
                    &hCertStoreRoot
                    );
                if (hstoreAll == NULL)
                    goto CryptoError;
                                       
                pccertSigner = CertFindCertificateInStore(hstoreAll, X509_ASN_ENCODING, 0,
                                                         CERT_FIND_CERT_ID, 
                                                         &pCmsSignerInfo->SignerId, NULL);
            }
            else {
                Assert(!g_FSupportV3);
                CSSDOUT("Couldn't find cert in message store");
                // Look in the caller specified cert store before the hard coded stores.
                for (dexStore=0; dexStore<m_cStores; dexStore++) {
                    if (m_rgStores[dexStore]) {
                        if (pccertSigner = CertGetSubjectCertificateFromStore(
                                  m_rgStores[dexStore], X509_ASN_ENCODING, &SignerId)) {
                            break;
                        }
                    }
                }

                if (!pccertSigner) {
                    // Look in the "Address Book" store
                    if (hCertStoreAddr == NULL) {
                        hCertStoreAddr = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                 X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                                       s_cszWABCertStore);
                    }
                    if (hCertStoreAddr != NULL) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                           hCertStoreAddr, X509_ASN_ENCODING, &SignerId);
                    }
                }

                if (!pccertSigner) {
                    // Look in the "My" store
                    if (hCertStoreMy == NULL) {
                        hCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                                     X509_ASN_ENCODING, NULL,
                                                     CERT_SYSTEM_STORE_CURRENT_USER,
                                                     s_cszMy);
                    }
                    if (hCertStoreMy != NULL) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                             hCertStoreMy, X509_ASN_ENCODING, &SignerId);
                    }
                }

                if (!pccertSigner) {
                    // Look in the "CA" store
                    if (hCertStoreCA == NULL) {
                        hCertStoreCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                                     X509_ASN_ENCODING, NULL, 
                                               CERT_SYSTEM_STORE_CURRENT_USER, s_cszCA);
                    }

                    if (hCertStoreCA) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                             hCertStoreCA, X509_ASN_ENCODING, &SignerId);
                    }
                }
            }
        }

        //
        //  By now we should have a certificate to verify with, if we don't then
        //      we need to say we can't do anything with it.
        //

        if (!pccertSigner) {
            // we still can't find the cert.  Therefore, cannot verify signer
            CSSDOUT("Cannot verify signer");
            pSignerData->ulValidity = MSV_UNVERIFIABLE;
        } else {
            pSignerData->pccert = CertDuplicateCertificateContext(pccertSigner);

            if (g_FSupportV3) {
                dwCtrl = CMSG_CTRL_VERIFY_SIGNATURE_EX;
                pv = &verifySignature;

                verifySignature.cbSize = sizeof(verifySignature);
                verifySignature.hCryptProv = NULL;
                verifySignature.dwSignerIndex = iSigner;
                verifySignature.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
                verifySignature.pvSigner = (LPVOID) pccertSigner;
            }
            else {
                dwCtrl = CMSG_CTRL_VERIFY_SIGNATURE;
                pv = pccertSigner->pCertInfo;
            }

        retry:
            if (!CryptMsgControl(m_hMsg, 0, dwCtrl, pv)) {
                HRESULT hr2 = HrGetLastError();
                CSSDOUT("Failed signer verify --> %lx", hr2);

                if (hr2 == CRYPT_E_MISSING_PUBKEY_PARA) {
                    if (NULL == hstoreAll && g_FSupportV3) {
                        hstoreAll = OpenAllStore(
                            m_cStores,
                            m_rgStores,
                            &hCertStoreAddr,
                            &hCertStoreCA,
                            &hCertStoreMy,
                            &hCertStoreRoot
                            );
                        if (NULL == hstoreAll)
                            goto CryptoError;
                    }
                    hr2 = GetParameters(pccertSigner, hMsgCertStore, hstoreAll);
                    if (hr2 == S_OK) {
                        goto retry;
                    }
                    pSignerData->ulValidity = MSV_UNVERIFIABLE;
                }
                else if (NTE_BAD_SIGNATURE == hr2 || CRYPT_E_HASH_VALUE == hr2) {
                    pSignerData->ulValidity = MSV_BADSIGNATURE;
                } else if (NTE_BAD_ALGID == hr2) {
                    pSignerData->ulValidity = MSV_UNKHASH;
                } else if (CRYPT_E_SIGNER_NOT_FOUND == hr2) {
                    pSignerData->ulValidity = MSV_UNVERIFIABLE;
                } else if (NTE_FAIL == hr2) {
                    // RSABASE returns errors.  This might
                    // be a failure or the hash might be changed.
                    // Have to be cautious -> make it bad.
                    pSignerData->ulValidity = MSV_BADSIGNATURE;
                } else {
                    pSignerData->ulValidity = MSV_MALFORMEDSIG;
                }
            } else {
                CSSDOUT("Verify of signature succeeded.");
                pSignerData->ulValidity &=
                    ~(MSV_SIGNATURE_MASK|MSV_SIGNING_MASK);
            }

            // Determine if certificate is expired
            if (0 != CertVerifyTimeValidityWithDelta(NULL, pccertSigner->pCertInfo, TIME_DELTA_SECONDS)) {
                pSignerData->ulValidity |= MSV_EXPIRED_SIGNINGCERT;
            }
        }


        if (szContentType = (LPSTR)PVGetMsgParam(m_hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, NULL, NULL)) {
            if (lstrcmp(szOID_PKCS_7_DATA, szContentType)) {
                CSSDOUT("Guess what, we have nested PKCS7 data types (maybe).");
            }
        } else {
            // CAPI failed... we are in trouble...
            pSignerData->ulValidity |= MSV_INVALID;

            hr = MIME_E_SECURITY_BADCONTENT;
            goto ErrorReturn;
        }

        //  Grab the hashing alg
        cap.cCapability = 1;
        cap.rgCapability = (CRYPT_SMIME_CAPABILITY *) &pCmsSignerInfo->HashAlgorithm;
        if (!CryptEncodeObjectEx(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                                 &cap, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                 &pSignerData->blobHashAlg.pBlobData,
                                 &pSignerData->blobHashAlg.cbSize)) {
            Assert(FALSE);
        }

        //
        //  Get the attributes, authenicated and unauthenicated, and put into the
        //          structure so we can push them back to the user later
        if (pCmsSignerInfo->AuthAttrs.cAttr != 0) {
#ifdef SMIME_V3
            for (i=0; i<pCmsSignerInfo->AuthAttrs.cAttr; i++) {
                // If we have a security label in this message, then we need to
                //      perform access validation.
                if (g_FSupportV3 && FIsMsasn1Loaded()) {
                    if (strcmp(pCmsSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                               szOID_SMIME_Security_Label) == 0) {

                        if ((pSignerData->ulValidity & MSV_SIGNATURE_MASK) != MSV_OK) {
                            DWORD dw = DwProcessLabelWithCertError();
                            if (CertErrorProcessLabelGrant == dw) {
                                hr = S_OK;
                                continue;
                            }
                            else if (CertErrorProcessLabelDeny == dw) {
                                hr = MIME_E_SECURITY_LABELACCESSDENIED;
                                goto ErrorReturn;
                            }
                            // else continue processing the label.
                        }
                        
                        if (pCmsSignerInfo->AuthAttrs.rgAttr[i].cValue != 1) {
                            hr = MIME_E_SECURITY_LABELCORRUPT;
                            goto ErrorReturn;
                        }

                        // Have we already seen a label?
                        if (attrSecLabel.pbData != NULL) {
                            // Check that the one we saw matches this one
                            if ((attrSecLabel.cbData != 
                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData) ||
                                memcmp(attrSecLabel.pbData,
                                       pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                       attrSecLabel.cbData)) {
                                if (FHideMsgWithDifferentLabels()) {
                                    hr = MIME_E_SECURITY_LABELCORRUPT;
                                    goto ErrorReturn;
                                }
                                else {
                                    continue;
                                }
                            }
                            else {
                                continue;
                            }
                        }
                        else {
                            // Save label.
                            attrSecLabel.cbData = pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData;
                            if (!MemAlloc((LPVOID*) (& attrSecLabel.pbData), attrSecLabel.cbData)) {
                                hr = MIME_E_SECURITY_LABELCORRUPT;
                                goto ErrorReturn; 
                            }
                            memcpy(attrSecLabel.pbData, pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                   attrSecLabel.cbData);
                        }
                        
                        // Clean-up from last loop
                        if (plabel != NULL)         CryptDecodeAlloc.pfnFree(plabel);
                                            
                        // Crack the contents of the label
                        if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_Security_Label,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
                                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                                 &plabel, &cblabel)) {
                            goto CryptoError;
                        }

                        // Query the policy.
                        hr = HrCheckLabelAccess((m_dwFlagsSEF & SEF_NOUI) ? 
                                                SMIME_POLICY_MODULE_NOUI: 0,
                                                m_hwnd, plabel, GetOuterDecryptCert(), 
                                                pccertSigner, hMsgCertStore);
                    

                        // If security policy returned an error, then abort.
                        if (FAILED(hr)) {
                            goto ErrorReturn;
                        }
                    }
                }

                if (g_FSupportV3 && FIsMsasn1Loaded() && (fLookForReceiptRequest) &&
                    ((pSignerData->ulValidity & (MSV_SIGNATURE_MASK | MSV_SIGNING_MASK)) == MSV_OK)) {
                    //  If we have a receipt request in this message than we need to build
                    //      the receipt body now while we have a chance.
    
                    if (strcmp(pCmsSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                               szOID_SMIME_Receipt_Request) == 0) {
                        if (pCmsSignerInfo->AuthAttrs.rgAttr[i].cValue != 1) {
                            if (attrReceiptReq.pbData != NULL) {
                   StopSendOfReceipt:
                                for (iSignData=0; iSignData < iSigner; iSignData++) {
                                    SafeMemFree(m_psldData->m_rgSigners[iSignData].blobReceipt.pBlobData);
                                    SafeMemFree(m_psldData->m_rgSigners[iSignData].blobHash.pBlobData);
                                    m_psldData->m_rgSigners[iSignData].blobReceipt.cbSize = 0;
                                    m_psldData->m_rgSigners[iSignData].blobHash.cbSize = 0;
                                    }
                            }
                            fLookForReceiptRequest = FALSE;
                            continue;
                        }

                        DWORD                       cb;
                        DWORD                       cbReceipt;
                        DWORD                       cbHash = 0;
                        LPBYTE                      pbReceipt = NULL;
                        LPBYTE                      pbHash = NULL;
                        SMIME_RECEIPT               receipt = {0};

                        // Clean-up from last loop
                        if (preq != NULL)         free(preq);
                        
                        // Have we already seen a receipt?
                        if (attrReceiptReq.pbData != NULL) {
                            // Check that the one we saw matches this one
                            if ((attrReceiptReq.cbData != 
                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData) ||
                               memcmp(attrReceiptReq.pbData,
                                      pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                      attrReceiptReq.cbData)) {
                                goto StopSendOfReceipt;
                            }
                        }
                        else {
                            // Save receipt request
                            attrReceiptReq.cbData = pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData;
                            if (!MemAlloc((LPVOID*) (& attrReceiptReq.pbData), attrReceiptReq.cbData)) {
                                // abort looking for receipt requests.
                                goto StopSendOfReceipt; 
                            }
                            memcpy(attrReceiptReq.pbData, pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                   attrReceiptReq.cbData);
                        }

                        // Crack the contents of the receipt
                        if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_Receipt_Request,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
                                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                                 &preq, &cb)) {
                            goto StopSendOfReceipt;
                        }

                        // Encode the receipt

                        receipt.Version = 1;
                        receipt.pszOIDContent = szContentType;
                        receipt.ContentIdentifier = preq->ContentIdentifier;
                        receipt.OriginatorSignature.cbData = pCmsSignerInfo->EncryptedHash.cbData;
                        receipt.OriginatorSignature.pbData = pCmsSignerInfo->EncryptedHash.pbData;

                        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_ContentType_Receipt,
                                                 &receipt, CRYPT_ENCODE_ALLOC_FLAG,
                                                 &CryptEncodeAlloc, &pbReceipt,
                                                 &cbReceipt)) {
                            goto StopSendOfReceipt;
                        }
                        
                        pSignerData->blobReceipt.cbSize = cbReceipt;
                        pSignerData->blobReceipt.pBlobData = pbReceipt;

                        pbHash = (LPBYTE)PVGetMsgParam(m_hMsg, CMSG_COMPUTED_HASH_PARAM, 
                                                         NULL, &cbHash);
                        if (pbHash == NULL) {
                            goto CryptoError;
                        }
                        pSignerData->blobHash.cbSize = cbHash;
                        pSignerData->blobHash.pBlobData = pbHash;
                    }
                }
            }

#endif // SMIME_V3
            //

            cbData = 0;
            LPBYTE  pb;
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                     &pCmsSignerInfo->AuthAttrs, CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pb, &cbData)) {
                goto CryptoError;
            }
            pSignerData->blobAuth.cbSize = cbData;
            pSignerData->blobAuth.pBlobData = pb;
        }

        if (pCmsSignerInfo->UnauthAttrs.cAttr != 0) {
            LPBYTE  pb;
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                     &pCmsSignerInfo->UnauthAttrs,
                                     CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                     &pb, &cbData)) {
                goto CryptoError;
            }

            pSignerData->blobUnauth.cbSize = cbData;
            pSignerData->blobUnauth.pBlobData = pb;
        }

        CertFreeCertificateContext(pccertSigner);
        pccertSigner = NULL;
    }

exit:
#ifdef SMIME_V3    
    if (preq != NULL)    CryptDecodeAlloc.pfnFree(preq);
    if (plabel != NULL)  CryptDecodeAlloc.pfnFree(plabel);
    SafeMemFree(attrReceiptReq.pbData);
    SafeMemFree(attrSecLabel.pbData);
#endif // SMIME_V3    
    if (hCertStoreAddr != NULL) CertCloseStore(hCertStoreAddr, 0);
    if (hCertStoreMy != NULL)   CertCloseStore(hCertStoreMy, 0);
    if (hCertStoreCA != NULL)   CertCloseStore(hCertStoreCA, 0);
    if (hCertStoreRoot != NULL) CertCloseStore(hCertStoreRoot, 0);
    if (hMsgCertStore != NULL)  CertCloseStore(hMsgCertStore, 0);
    MemFree(szContentType);
    ReleaseMem(pSignerInfo);
#ifdef SMIME_V3
    if (pCmsSignerInfo != &cmsSignerInfo) {
        ReleaseMem(pCmsSignerInfo);
    }
    if (hstoreAll != NULL)      CertCloseStore(hstoreAll, 0);
#endif // SMIME_V3
    ReleaseCert(pccertSigner);
    return hr;

CryptoError:
    hr = HrGetLastError();

ErrorReturn:
    // On error, release the cert store
    if (m_psldData->m_hcertstor != NULL) {
        CertCloseStore(m_psldData->m_hcertstor, 0);
        m_psldData->m_hcertstor = NULL;
    }


    if (S_OK == hr)
        // our generic error message
        hr = TrapError(MIME_E_SECURITY_BADMESSAGE);
    goto exit;
}

static HRESULT GetCSP(PCCERT_CONTEXT pccert, HCRYPTPROV * phprov, DWORD * pdwKeyId)
{
    HRESULT                 hr;
    PCRYPT_KEY_PROV_INFO    pKPI = NULL;

    Assert(*phprov == NULL);
    Assert(*pdwKeyId == 0);
    
    //
    //

    hr = HrGetCertificateParam(pccert, CERT_KEY_PROV_INFO_PROP_ID,
                               (LPVOID *) &pKPI, NULL);
    if (FAILED(hr)) {
        goto exit;
    }
    *pdwKeyId = pKPI->dwKeySpec;

    // If the cert specifies the base provider OR has no specification,
    //  then try to acquire RSAENH, else get RSABASE.

    if ((PROV_RSA_FULL == pKPI->dwProvType) &&
        (UnlocStrEqNW(pKPI->pwszProvName, MS_DEF_PROV_W,
                      sizeof(MS_DEF_PROV_W)/sizeof(WCHAR)-5) ||
         (*pKPI->pwszProvName == 0))) {
        if (!CRYPT_ACQUIRE_CONTEXT(phprov, pKPI->pwszContainerName,
                                   MS_ENHANCED_PROV_W, PROV_RSA_FULL,
                                   pKPI->dwFlags)) {
            CSSDOUT("CryptAcquireContext -> %x\n", HrGetLastError());
        }
    }

    if (*phprov == NULL) {
        if (! CRYPT_ACQUIRE_CONTEXT(phprov, pKPI->pwszContainerName,
                                    pKPI->pwszProvName, pKPI->dwProvType,
                                    pKPI->dwFlags)) {
            CSSDOUT("CryptAcquireContext -> %x\n", HrGetLastError());
            hr = HrGetLastError();
            goto exit;
        }
    }
    hr = S_OK;
exit:
    ReleaseMem(pKPI);
    return hr;
}

HRESULT CCAPIStm::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipientIndex,
                             const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                             HCERTSTORE hcertstore, DWORD * pdwCtrl, 
                             CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                             PCCERT_CONTEXT * ppCertDecrypt)
{
    HRESULT                 hr;
    HCRYPTPROV              hProv = NULL;
    DWORD                   i;
    PCMSG_CTRL_DECRYPT_PARA pccdp;
    PCCERT_CONTEXT          pCertDecrypt = NULL;
    PCCERT_CONTEXT          pCertOrig = NULL;

    if (g_FSupportV3) {
        switch (pRecipInfo->dwRecipientChoice) {
            //
            //  Given the certificate reference, see if we can find it in
            //  the passed in certificate stores, if yes then we will attempt
            //  to decrypt using that certificate
            //
            //  This is a Key Transport recipient info object.  The CAPI 2.0
            //  code can deal with both SKI and Issuer/Serial Number references
            //

        case CMSG_KEY_TRANS_RECIPIENT:
            pCertDecrypt = CertFindCertificateInStore(hcertstore, X509_ASN_ENCODING,
                                                      0, CERT_FIND_CERT_ID,
                                                      &pRecipInfo->pKeyTrans->RecipientId, NULL);
        
            if (pCertDecrypt != NULL) {
                hr = GetCSP(pCertDecrypt, &pDecryptInfo->trans.hCryptProv,
                            &pDecryptInfo->trans.dwKeySpec);
                if (SUCCEEDED(hr)) {
                    //
                    //  We find a certificate for this lock box.  Setup the
                    //      structure to be used in decrypting the message.
                    //
                        
                    *pdwCtrl = CMSG_CTRL_KEY_TRANS_DECRYPT;
                    pDecryptInfo->trans.cbSize = sizeof(pDecryptInfo->trans);
                    // pDecryptInfo->trans.hCryptProv = hProv;
                    // pDecryptInfo->trans.dwKeySpec = pKPI->dwKeySpec;
                    pDecryptInfo->trans.pKeyTrans = pRecipInfo->pKeyTrans;
                    pDecryptInfo->trans.dwRecipientIndex = dwRecipientIndex;
                }
                else {
                    ReleaseCert(pCertDecrypt);
                    pCertDecrypt = NULL;
                }
            }
            break;

        //
        //  Given the certificate reference, see if we can find it in
        //  the passed in certificate stores, if yes then we will attempt
        //  to decrypt using that certificate
        //
        //  This is a Key Agreement recipient info object.  The CAPI 2.0
        //  code can deal with both SKI and Issuer/Serial Number references
        //
        //  There may be multiple certificate references within a single
        //  recipient info object
        //

        case CMSG_KEY_AGREE_RECIPIENT:
            for (i=0; i<pRecipInfo->pKeyAgree->cRecipientEncryptedKeys; i++) {
                pCertDecrypt = CertFindCertificateInStore(
                                             hcertstore, X509_ASN_ENCODING, 0,
                                             CERT_FIND_CERT_ID, 
                  &pRecipInfo->pKeyAgree->rgpRecipientEncryptedKeys[i]->RecipientId,
                                             NULL);
                if (pCertDecrypt != NULL) {
                    hr = GetCSP(pCertDecrypt, &pDecryptInfo->agree.hCryptProv,
                                &pDecryptInfo->agree.dwKeySpec);
                    if (SUCCEEDED(hr)) {
                        //
                        //  We find a certificate for this lock box.  Setup the
                        //      structure to be used in decrypting the message.
                        //
                        
                        *pdwCtrl = CMSG_CTRL_KEY_AGREE_DECRYPT;
                        pDecryptInfo->agree.cbSize = sizeof(pDecryptInfo->agree);
                        pDecryptInfo->agree.pKeyAgree = pRecipInfo->pKeyAgree;
                        pDecryptInfo->agree.dwRecipientIndex = dwRecipientIndex;
                        pDecryptInfo->agree.dwRecipientEncryptedKeyIndex = i;

                        //
                        // Need to find the originator information
                        //

                        switch(pRecipInfo->pKeyAgree->dwOriginatorChoice) {
                        case CMSG_KEY_AGREE_ORIGINATOR_CERT:
                            pCertOrig = CertFindCertificateInStore( hcertstore, X509_ASN_ENCODING, 0, CERT_FIND_CERT_ID, &pRecipInfo->pKeyAgree->OriginatorCertId, NULL);
                            if (pCertOrig == NULL) {
                                hr = S_FALSE;
                                goto exit;
                            }

                            hr = HrCopyCryptBitBlob(&pCertOrig->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                                                    &pDecryptInfo->agree.OriginatorPublicKey);
                            if (FAILED(hr)) {
                                goto exit;
                            }
                            break;
                                
                        case CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY:
                            hr = HrCopyCryptBitBlob(&pRecipInfo->pKeyAgree->OriginatorPublicKeyInfo.PublicKey,
                                                    &pDecryptInfo->agree.OriginatorPublicKey);
                            if (FAILED(hr)) {
                                goto exit;
                            }
                            break;

                        default:
                            hr = NTE_FAIL;
                            goto exit;
                        }
                        break;
                    }
                    else {
                        ReleaseCert(pCertDecrypt);
                        pCertDecrypt = NULL;
                    }
                }
            }
            break;

        //
        //   We can't find this from a certificate
        //
                    
        case CMSG_MAIL_LIST_RECIPIENT:
            break;

        default:
            hr = NTE_FAIL;
            goto exit;
        }
    }
    else {
        CERT_INFO * pCertInfo = (CERT_INFO *) pRecipInfo;
                
        for (i=0; i<m_cStores; i++) {
            pCertDecrypt = CertGetSubjectCertificateFromStore(m_rgStores[i],
                                                X509_ASN_ENCODING, pCertInfo);
            if (pCertDecrypt != NULL) {
                pccdp = (PCMSG_CTRL_DECRYPT_PARA) pDecryptInfo;
                hr = GetCSP(pCertDecrypt, &pccdp->hCryptProv, &pccdp->dwKeySpec);
                if (SUCCEEDED(hr)) {
                    //
                    //  We find a certificate for this lock box.  Setup the
                    //      structure to be used in decrypting the message.
                    //
                        
                    *pdwCtrl = CMSG_CTRL_DECRYPT;
                    pccdp->cbSize = sizeof(CMSG_CTRL_DECRYPT_PARA);
                    pccdp->dwRecipientIndex = dwRecipientIndex;
                }
                else {
                    ReleaseCert(pCertDecrypt);
                    pCertDecrypt = NULL;
                }
                break;
            }
        }
    }


    //
    //  If we did not find a certificate, then return a failure code
    //
    
    if (pCertDecrypt == NULL) {
        hr = S_FALSE;
        goto exit;
    }

    //
    //  If we have a certificate, then return it for the user to examine.
    //
    
    if (pCertDecrypt != NULL) {
        *ppCertDecrypt = pCertDecrypt;
        pCertDecrypt = NULL;
    }

    hProv = NULL;
    hr = S_OK;
exit:
    ReleaseCert(pCertDecrypt);
    ReleaseCert(pCertOrig);
    if (hProv != NULL)          CryptReleaseContext(hProv, 0);

    return hr;
}

BOOL CCAPIStm::HandleEnveloped()
{
    DWORD                               cbData;
    DWORD                               cCerts;
    DWORD                               cRecips;
    CMS_CTRL_DECRYPT_INFO               decryptInfo = {0};
    DWORD                               dexRecip;
    DWORD                               dwCtrl;
    BOOL                                f;
    BOOL                                fGotoUser = FALSE;
    HCERTSTORE                          hcertstore = NULL;
    HCERTSTORE                          hMsgCertStore = NULL;
    HRESULT                             hr;
    DWORD                               i;
    PCCERT_CONTEXT                      pCertDecrypt = NULL;
    CMSG_CMS_RECIPIENT_INFO *           pCmsCertInfo;
    LPVOID                              pv = NULL;

    //
    //  If we are not suppose to display UI -- return an error about displaying UI now.
    //

    ////////////////////////////////////////////////////////////////////////////////////////
    // 591349 - Compiler Bug For Zero Initialization of Data Structure. Active WinNT 5.1 (Whistler) 1 Server RC1
    // the line above doesn't zero the structure due to this compiler bug
    memset(&decryptInfo, 0, sizeof(decryptInfo));

    if (m_dwFlagsSEF & SEF_NOUI) {
        return MIME_E_SECURITY_UIREQUIRED;
    }

    //
    // this call exists for one and only one purpose.  We must
    //  be sure that we have read and parsed all of the RecipientInfo structures
    //  before we start processing them.  Since the algorithm parameter is after
    //  the last of the last of the recipient structures, this make sure of that.
    //
    
    pv = PVGetMsgParam(m_hMsg, CMSG_ENVELOPE_ALGORITHM_PARAM, 0, NULL);
    if (pv == NULL) {
        goto gle;
    }
    MemFree(pv);                pv = NULL;

    //
    //  Fetch the set of certificates on the message object
    //

    cbData = sizeof(cCerts);
    f = CryptMsgGetParam(m_hMsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbData);
    Assert(f);

    if (f && (cCerts > 0)) {
        // since there are certs included, let's try them first when matching
        // certs with enryptors.

        // get the store set
        // make sure we keep hold of our provider
        hMsgCertStore = CertOpenStore(CERT_STORE_PROV_MSG, X509_ASN_ENCODING,
                                      m_hProv, 0, m_hMsg);
        if (hMsgCertStore) {
            m_dwFlagsStm |= CSTM_DONTRELEASEPROV;  // given unto the store
        }

        // if it failed, we just don't have a store then
        Assert(hMsgCertStore != NULL);
        m_psldData->m_hstoreEncrypt = CertDuplicateStore(hMsgCertStore);
    }

    //
    //  Retrieve the count of recipient infos on the message
    //
    
    cbData = sizeof(cRecips);
    if (!CryptMsgGetParam(m_hMsg, g_FSupportV3 ? CMSG_CMS_RECIPIENT_COUNT_PARAM :
                          CMSG_RECIPIENT_COUNT_PARAM, 0, &cRecips, &cbData)) {
        goto gle;
    }

    //
    // If we were provided an actual certificate, see if this is it...
    // We will either search for the provided certificate or in the provided
    //  certificate stores, but not both.
    //

    if (m_pUserCertDecrypt != NULL) {
        hcertstore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                   NULL, 0, NULL);
        if (hcertstore == NULL) {
            hr = HrGetLastError();
            goto exit;
        }

        if (!CertAddCertificateContextToStore(hcertstore, m_pUserCertDecrypt,
                                              CERT_STORE_ADD_ALWAYS, NULL)) {
            hr = HrGetLastError();
            goto exit;
        }
    }
    else {
        if (g_FSupportV3) {
            hcertstore = CertOpenStore(CERT_STORE_PROV_COLLECTION, X509_ASN_ENCODING,
                                       NULL, 0, NULL);
            if (hcertstore == NULL) {
                hr = HrGetLastError();
                goto exit;
            }

            for (i=0; i<m_cStores; i++) {
                CertAddStoreToCollection(hcertstore, m_rgStores[i], 0, 0);
            }

            if (hMsgCertStore != NULL) {
                CertAddStoreToCollection(hcertstore, hMsgCertStore, 0, 0);
            }
        }
    }

    //  For each possible recipient
tryAgain:
    for (dexRecip=0; dexRecip<cRecips; dexRecip++) {
        //
        //  Retrieve the desciption of the i-th recipient's lockbox
        //
            
        hr = HrGetMsgParam(m_hMsg, g_FSupportV3 ? CMSG_CMS_RECIPIENT_INFO_PARAM :
                           CMSG_RECIPIENT_INFO_PARAM, dexRecip, (LPVOID *) &pv, NULL);
        if (FAILED(hr)) {
            goto exit;
        }

        //
        //  Look to see if there is a decrypt item we can fill in here.
        //

        if (fGotoUser) {
            //
            //  Look to see if there is a decrypt item that the user can fill in.
            //
            
            hr = m_pSmimeCallback->FindKeyFor(m_hwnd, 0, dexRecip,
                                              (CMSG_CMS_RECIPIENT_INFO *) pv,
                                              &dwCtrl, &decryptInfo, &pCertDecrypt);
        }
        else {
            hr = FindKeyFor(m_hwnd, 0, dexRecip, (CMSG_CMS_RECIPIENT_INFO *) pv,
                            hcertstore, &dwCtrl, &decryptInfo, &pCertDecrypt);
        }
            
        if (FAILED(hr)) {
            goto exit;
        }

        if (hr == S_OK) {
#ifdef SMIME_V3
            if (m_pwszKeyPrompt != NULL) {
                PCMSG_CTRL_DECRYPT_PARA pccdp;
                
                switch (dwCtrl) {
                    case CMSG_CTRL_KEY_TRANS_DECRYPT:
                        CryptSetProvParam(decryptInfo.trans.hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;

                    case CMSG_CTRL_KEY_AGREE_DECRYPT:
                        CryptSetProvParam(decryptInfo.agree.hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;

                    case CMSG_CTRL_DECRYPT:
                        pccdp = (PCMSG_CTRL_DECRYPT_PARA) &decryptInfo;
                        CryptSetProvParam(pccdp->hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;
                    }
            }
#endif // SMIME_V3

            if (!CryptMsgControl(m_hMsg, CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
                                 dwCtrl, &decryptInfo)) {
                hr = HrGetLastError();

                //
                // Force any cleanups in the event of an error
                //

                switch (dwCtrl) {
                case CMSG_CTRL_KEY_TRANS_DECRYPT:
                    CryptReleaseContext(decryptInfo.trans.hCryptProv, 0);
                    break;
                    
                case CMSG_CTRL_KEY_AGREE_DECRYPT:
                    CryptReleaseContext(decryptInfo.agree.hCryptProv, 0);
                    break;
                    
                case CMSG_CTRL_MAIL_LIST_DECRYPT:
                    Assert(FALSE);
                    break;
                    
                case CMSG_CTRL_DECRYPT:
                    CryptReleaseContext(((PCMSG_CTRL_DECRYPT_PARA) &decryptInfo)->hCryptProv, 0);
                    break;
                }
                goto exit;
            }
            goto DecryptDone;
        }

        //
        //  Clean up the object returned describing the lock box, if we
        //      were unsuccessful in finding a decryption key.
        //

        MemFree(pv);                pv = NULL;
    }

    //
    //  If we are completely unsuccessful and the user has provided
    //  us a callback to play with, then give the user a shot at finding
    //  the correct decryption parameters.
    //
    
    if (!fGotoUser && g_FSupportV3 && (m_pSmimeCallback != NULL)) {
        fGotoUser = TRUE;
        goto tryAgain;
    }

    CSSDOUT("Could not decrypt the message");

    m_psldData->m_ulDecValidity = MSV_CANTDECRYPT;
    hr = CS_E_CANT_DECRYPT;
    goto exit;

    //
    //  If we get here, then we 
    //  1) found some parameters and
    //  2) the worked.
    //
    
DecryptDone:
    Assert(m_psldData && (m_psldData->m_pccertDecrypt == NULL));
    if (pCertDecrypt != NULL) {
        m_psldData->m_pccertDecrypt = CertDuplicateCertificateContext(pCertDecrypt);

        // Determine if certificate is expired
        if (0 != CertVerifyTimeValidityWithDelta(NULL, pCertDecrypt->pCertInfo,
                                                 TIME_DELTA_SECONDS)) {
            m_psldData->m_ulDecValidity |= MSV_ENC_FOR_EXPIREDCERT;
        }
    }
    hr = S_OK;

exit:
    if (pv != NULL)             MemFree(pv);

    CertFreeCertificateContext(pCertDecrypt);

    if (hMsgCertStore != NULL) {
        CertCloseStore(hMsgCertStore, 0);
    }
    
    if (hcertstore != NULL) {
        CertCloseStore(hcertstore, 0);
    }
        
    
    if (FAILED(hr)) {
#ifdef DEBUG
        if (NTE_BAD_DATA == hr) {
            CSSDOUT("Could not decrypt.  Maybe due to ImportKeyError since");
            CSSDOUT("NTE_BAD_DATA is the result.");
            // If this happens then it is somewhat likely that PKCS2Decrypt
            // failed inside the CSP. (assuming rsabase, rsaenh)
        }
#endif
        switch (hr) {
            case CS_E_CANT_DECRYPT:
            case CRYPT_E_STREAM_MSG_NOT_READY:
            case HRESULT_FROM_WIN32(ERROR_CANCELLED):
                break;

            default:
                // I suppose many things could have gone wrong.  We thought
                // we had a cert, though, so let's just say the message itself
                // is bogus.
                //N8 this is a bad idea if we are wrapping a signature
                // should be able to tell if the sig failed and display
                // a better error message.
                //N8 CAPI is simply going to return NTE_FAIL b/c they
                // are failing because our callback failed.  the
                // innerCAPI should have some failure state in it.
                // Maybe we could use this to set MSV_BADINNERSIG or something.
                // It would be an encryption error (inside that mask)
                //N8 also this is not being used well enough, even for
                // decryption.  the secUI should test this bit and
                // say something intelligent about the message.  NS does.
                m_psldData->m_ulDecValidity = MSV_INVALID;
                hr = CS_E_MSG_INVALID;
                break;
        }
    }

#ifdef DEBUG
    if (CRYPT_E_STREAM_MSG_NOT_READY != hr) {
        return TrapError(hr);
    } else {
        return hr;
    }
#else
    return hr;
#endif

gle:
    hr = HrGetLastError();
    Assert(S_OK != hr);
    goto exit;
}

///////////////////////////////////////////////////////////////////////////
//
// Class-static utility functions
//

HRESULT CCAPIStm::DuplicateSecurityLayerData(const PSECURITY_LAYER_DATA psldIn, PSECURITY_LAYER_DATA *const ppsldOut)
{
    if (!psldIn || !ppsldOut) {
        return E_POINTER;
    }

    // Just addref the original and return it
    psldIn->AddRef();
    *ppsldOut = psldIn;
    return(S_OK);
}

void CCAPIStm::FreeSecurityLayerData(PSECURITY_LAYER_DATA psld)
{
    if (! psld) {
        return;
    }

    psld->Release();
}


///////////////////////////////////////////////////////////////////////////
//
// Statics to file
//

static HRESULT _InitEncodedCert(IN HCERTSTORE hcertstor,
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl)
{
    DWORD               cbCerts = 0;
    DWORD               cbCRLs = 0;
    DWORD               cCerts = 0;
    DWORD               cCRLs = 0;
    DWORD               i;
    LPBYTE              pbCert = NULL;
    LPBYTE              pbCRL = NULL;
    PCCERT_CONTEXT      pccert = NULL;
    PCCRL_CONTEXT       pccrl = NULL;
    PCERT_BLOB          rgblobCerts = NULL;
    PCRL_BLOB           rgblobCRLs = NULL;

    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL) {
        cbCerts += LcbAlignLcb(pccert->cbCertEncoded);
        cCerts += 1;
    }

    while ((pccrl = CertEnumCRLsInStore(hcertstor, pccrl)) != NULL) {
        cbCRLs += LcbAlignLcb(pccrl->cbCrlEncoded);
        cCRLs += 1;
    }

    if (cCerts > 0) {
        rgblobCerts = (PCERT_BLOB) g_pMoleAlloc->Alloc(LcbAlignLcb(sizeof(CERT_BLOB) * cCerts + cbCerts));
        if (rgblobCerts == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    if (cCRLs > 0) {
        rgblobCRLs = (PCRL_BLOB) g_pMoleAlloc->Alloc(LcbAlignLcb(sizeof(CRL_BLOB) * cCRLs + cbCRLs));
        if (rgblobCRLs == NULL) {
            g_pMoleAlloc->Free(rgblobCerts);
            return E_OUTOFMEMORY;
        }
    }

    if (cCerts > 0) {
        pbCert = (LPBYTE) &rgblobCerts[cCerts];
        i = 0;
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL) {
            memcpy(pbCert, pccert->pbCertEncoded, pccert->cbCertEncoded);
            rgblobCerts[i].pbData = pbCert;
            rgblobCerts[i].cbData = pccert->cbCertEncoded;
            pbCert += LcbAlignLcb(pccert->cbCertEncoded);
            i++;
        }
        Assert(i == cCerts);
    }

    if (cCRLs > 0) {
        pbCRL = (LPBYTE) &rgblobCRLs[cCRLs];
        i = 0;
        while ((pccrl = CertEnumCRLsInStore(hcertstor, pccrl)) != NULL) {
            memcpy(pbCRL, pccrl->pbCrlEncoded, pccrl->cbCrlEncoded);
            rgblobCRLs[i].pbData = pbCRL;
            rgblobCRLs[i].cbData = pccrl->cbCrlEncoded;
            pbCRL += LcbAlignLcb(pccrl->cbCrlEncoded);
            i++;
        }
        Assert(i == cCRLs);
    }

    *prgblobCerts = rgblobCerts;
    *pcCerts = cCerts;
    *prgblobCrls = rgblobCRLs;
    *pcCrl = cCRLs;

    return S_OK;
}

// Ensures that the signer certificates are included in the returned
// array of blobs.
static HRESULT _InitEncodedCertIncludingSigners(IN HCERTSTORE hcertstor,
                                DWORD cSigners, SignerData rgSigners[],
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl)
{
    HRESULT hr;
    HCERTSTORE hCollection = NULL;
    DWORD i;

    // Loop through signers. Check that they are already included in the
    // certificate store. If not, then, create a collection and memory store
    // to include.

    for (i = 0; i < cSigners; i++) {
        PCCERT_CONTEXT pSignerCert = rgSigners[i].pccert;
        PCCERT_CONTEXT pStoreCert = NULL;

        while (NULL != (pStoreCert = CertEnumCertificatesInStore(
                hcertstor, pStoreCert))) {
            if (pSignerCert->cbCertEncoded == pStoreCert->cbCertEncoded &&
                    0 == memcmp(pSignerCert->pbCertEncoded,
                            pStoreCert->pbCertEncoded,
                            pSignerCert->cbCertEncoded))
                break;
        }

        if (pStoreCert)
            // Signer cert is already included in the store
            CertFreeCertificateContext(pStoreCert);
        else {
            if (NULL == hCollection) {
                // Create collection and memory store to contain the
                // signer certificate

                HCERTSTORE hMemory = NULL;
                BOOL fResult;
                
                hCollection = CertOpenStore(
                    CERT_STORE_PROV_COLLECTION,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL
                    );
                if (NULL == hCollection)
                    goto CommonReturn;

                if (!CertAddStoreToCollection(
                        hCollection,
                        hcertstor,
                        0,                  // dwUpdateFlags
                        0                   // dwPriority
                        ))
                    goto CommonReturn;

                hMemory = CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL
                    );

                if (NULL == hMemory)
                    goto CommonReturn;

                fResult = CertAddStoreToCollection(
                    hCollection,
                    hMemory,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    1                   // dwPriority
                    );
                CertCloseStore(hMemory, 0);
                if (!fResult)
                    goto CommonReturn;

                hcertstor = hCollection;
            }

            CertAddEncodedCertificateToStore(
                hCollection,
                pSignerCert->dwCertEncodingType,
                pSignerCert->pbCertEncoded,
                pSignerCert->cbCertEncoded,
                CERT_STORE_ADD_ALWAYS,
                NULL
                );
        }
    }


CommonReturn:
    hr = _InitEncodedCert(hcertstor, prgblobCerts, pcCerts, prgblobCrls, pcCrl);
    if (hCollection)
        CertCloseStore(hCollection, 0);
    return hr;
}

#ifndef SMIME_V3
static HRESULT _InitCertInfo(
    IN PCCERT_CONTEXT * rgpCerts,
    IN DWORD            cCerts,
    OUT PCERT_INFO **   prgpCertInfo)
{
    PCERT_INFO*     rgpCertInfo = NULL;
    DWORD           dwIdx;
    HRESULT         hr = S_OK;

    Assert(prgpCertInfo);

    if (cCerts) {
        rgpCertInfo = (PCERT_INFO*)g_pMoleAlloc->Alloc(sizeof(CERT_BLOB) * cCerts);
        if (NULL == rgpCertInfo) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        for (dwIdx = 0; dwIdx < cCerts; dwIdx++) {
            rgpCertInfo[dwIdx] = rgpCerts[dwIdx]->pCertInfo;
        }
    }

exit:
    *prgpCertInfo = rgpCertInfo;
    return hr;
}
#endif // !SMIME_V3

void _SMimeCapsFromHMsg(HCRYPTMSG hMsg, DWORD idParam, LPBYTE * ppb, DWORD * pcb)
{
    DWORD                       cbData = 0;
    CRYPT_SMIME_CAPABILITY      cap;
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL                        f;
    PCRYPT_ALGORITHM_IDENTIFIER paid = NULL;
    LPBYTE                      pb = NULL;

    f = CryptMsgGetParam(hMsg, idParam, 0, NULL, &cbData);
    if ((cbData == 0) || ! MemAlloc((LPVOID *) &paid, cbData)) {
        Assert(FALSE);
        goto error;
    }

    f = CryptMsgGetParam(hMsg, idParam, 0, paid, &cbData);
    Assert(f);

    caps.cCapability = 1;
    caps.rgCapability = &cap;

    cap.pszObjId = paid->pszObjId;
    cap.Parameters.cbData = paid->Parameters.cbData;
    cap.Parameters.pbData = paid->Parameters.pbData;

    cbData = 0;
    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_RSA_SMIMECapabilities,
                             &caps, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                             &pb, &cbData)) {
        Assert(FALSE);
        goto error;
    }

    *ppb = pb;
    *pcb = cbData;

exit:
    SafeMemFree(paid);
    return;

error:
    *ppb = NULL;
    *pcb = 0;
    goto exit;
}


#ifdef SMIME_V3
////    HrBuildContentEncryptionAlg
//
//  Description:
//      This function is used to decode a smime capability and build the
//      structure we need to pass into the Crypt32 code.
//

HRESULT HrBuildContentEncryptionAlg(PSECURITY_LAYER_DATA psld, BLOB * pblob)
{
    DWORD                       cbData;
    HRESULT                     hr;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;
    CMSG_RC2_AUX_INFO *         prc2Aux;

    //
    //  Decode the capability which is the bulk encryption algorithm
    //
    
    hr = HrDecodeObject(pblob->pBlobData, pblob->cbSize, PKCS_SMIME_CAPABILITIES,
                        0, &cbData, (LPVOID *)&pcaps);
    if (FAILED(hr)) {
        goto exit;
    }

    Assert(pcaps->cCapability == 1);
    DWORD cchSize = (lstrlen(pcaps->rgCapability[0].pszObjId) + 1);
    if (!MemAlloc((LPVOID *) &psld->m_ContentEncryptAlgorithm.pszObjId, cchSize * sizeof(psld->m_ContentEncryptAlgorithm.pszObjId[0])))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    StrCpyN(psld->m_ContentEncryptAlgorithm.pszObjId, pcaps->rgCapability[0].pszObjId, cchSize);

    //
    //  If this is the RC/2 algorithm, then we need to setup the aux info
    //  to pass in the algorithm size.
    //
    
    if (lstrcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
        psld->m_ContentEncryptAlgorithm.Parameters.cbData = 0;
        psld->m_ContentEncryptAlgorithm.Parameters.pbData = NULL;

        if (!MemAlloc((LPVOID *) &(psld->m_pvEncryptAuxInfo), sizeof(*prc2Aux))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        prc2Aux = (CMSG_RC2_AUX_INFO *) psld->m_pvEncryptAuxInfo;
        prc2Aux->cbSize = sizeof(*prc2Aux);
        
        if (pcaps->rgCapability[0].Parameters.cbData == 0) {
            prc2Aux->dwBitLen = 40;
        }
        else {
            switch(pcaps->rgCapability[0].Parameters.pbData[pcaps->rgCapability[0].Parameters.cbData-1]) {
            case 128:
            case 58:
                prc2Aux->dwBitLen = 128;
                break;

            case 64:
            case 120:
                prc2Aux->dwBitLen = 64;
                break;

            case 40:
            case 160:
            default:
                prc2Aux->dwBitLen = 40;
                break;
            }
        }
    }
    else if (pcaps->rgCapability[0].Parameters.cbData != 0) {
        if (!MemAlloc((LPVOID *) &psld->m_ContentEncryptAlgorithm.Parameters.pbData,
                      pcaps->rgCapability[0].Parameters.cbData)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        memcpy(psld->m_ContentEncryptAlgorithm.Parameters.pbData,
               pcaps->rgCapability[0].Parameters.pbData,
               pcaps->rgCapability[0].Parameters.cbData);
        
        psld->m_ContentEncryptAlgorithm.Parameters.cbData =
            pcaps->rgCapability[0].Parameters.cbData;
    }
    

    hr = S_OK;
exit:
    if (pcaps != NULL)                  MemFree(pcaps);

    return hr;
}

HRESULT HrDeriveKeyWrapAlg(PSECURITY_LAYER_DATA psld, CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO * pAgree)
{
    LPCSTR      pszObjId = psld->m_ContentEncryptAlgorithm.pszObjId;
    
    if (lstrcmp(pszObjId, szOID_RSA_RC2CBC) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        pAgree->pvKeyWrapAuxInfo = psld->m_pvEncryptAuxInfo;
    }
    else if (lstrcmp(pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMS3DESwrap;
        pAgree->pvKeyWrapAuxInfo = NULL;
    }
    else if (lstrcmp(pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = "2.16.840.1.101.2.1.1.24";
        pAgree->pvKeyWrapAuxInfo = NULL;
    }
    else {
        return NTE_NOT_FOUND;
    }
    return S_OK;
}
#endif // SMIME_V3



#ifdef SMIME_V3


//
// Read in admin option that determines whether a msg with disparate
// Labels is shown or not.
// 
BOOL FHideMsgWithDifferentLabels() 
{
    DWORD     cbData = 0;
    DWORD     dwType = 0;
    DWORD     dwValue = 0;
    BOOL      fHideMsg = FALSE;
    HKEY      hkey = NULL;
    LONG      lRes;
    
    // Open the security label admin defaults key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelAdminRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No admin label options were found.  
        goto exit;
    }

    cbData = sizeof(dwValue);
    lRes = RegQueryValueEx(hkey, c_szHideMsgWithDifferentLabels, NULL, 
                           &dwType, (LPBYTE) &dwValue, &cbData);
    if (ERROR_SUCCESS != lRes) {
        goto exit;
    }

    if (0x01 == dwValue) {
        fHideMsg = TRUE;
    }
    
exit:
    if (NULL != hkey)      RegCloseKey(hkey);
    return fHideMsg;
}

//
// Read in admin option that determines how to process a label in a 
// signture with errors.
// Returns 0, 1, 2 for ProcessAnyway, Grant, Deny(default).
//
DWORD DwProcessLabelWithCertError()
{
    DWORD     cbData = 0;
    DWORD     dwType = 0;
    DWORD     dwValue = CertErrorProcessLabelDeny;
    BOOL      dwProcessMsg = 0;
    HKEY      hkey = NULL;
    LONG      lRes;
    
    // Open the security label admin defaults key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelAdminRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No admin label options were found.  
        goto exit;
    }

    // Read in the admin option.
    cbData = sizeof(dwValue);
    lRes = RegQueryValueEx(hkey, c_szCertErrorWithLabel, NULL, 
                           &dwType, (LPBYTE) &dwValue, &cbData);
    if (ERROR_SUCCESS != lRes) {
        dwValue = CertErrorProcessLabelDeny;
        goto exit;
    }

    // If the value isn't one of the known ones, force it to the default value.
    if ( (CertErrorProcessLabelAnyway != dwValue) && (CertErrorProcessLabelGrant != dwValue) && 
         (CertErrorProcessLabelDeny != dwValue) ) {
        dwValue = CertErrorProcessLabelDeny;
    }

exit:
    if (NULL != hkey)      RegCloseKey(hkey);
    return dwValue;

}


//
// Given a label, queries the policy whether access is to be granted.
// (If reqd policy doesn't exist, it also tries to query the default
// policy, if one exists).
//
HRESULT HrCheckLabelAccess(const DWORD dwFlags, const HWND hwnd, 
           PSMIME_SECURITY_LABEL plabel, const PCCERT_CONTEXT pccertDecrypt,
           const PCCERT_CONTEXT pccertSigner, const HCERTSTORE hcertstor)
{                   
    HRESULT   hr = MIME_E_SECURITY_LABELACCESSDENIED;
    
    HKEY      hkey = NULL;
    HKEY      hkeySub = NULL;
    HINSTANCE hinstDll = NULL;
    PFNGetSMimePolicy pfnGetSMimePolicy = NULL;
    ISMimePolicyCheckAccess *pspca = NULL;
    LONG      lRes;
    DWORD     dwType;
    DWORD     cbData;
    CHAR      szDllPath[MAX_PATH];
    CHAR      szExpandedDllPath[MAX_PATH];
    CHAR      szFuncName[MAX_FUNC_NAME];

        
    if ((NULL == plabel) || (NULL == plabel->pszObjIdSecurityPolicy)) {
        hr = S_OK;    // No label/policyoid => access granted.
        goto exit;
    }



    // Open the security policies key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelPoliciesRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No security policies are registered. Deny access. 
        goto ErrorReturn;
    }

    // Open the security policy (or default policy regkey).
    lRes = RegOpenKeyEx(hkey, plabel->pszObjIdSecurityPolicy, 0, KEY_READ, &hkeySub); 
    if ((ERROR_SUCCESS != lRes) || (NULL == hkeySub)) {
        if (hkeySub != NULL) {
            RegCloseKey(hkeySub);
            hkeySub = NULL;
        }

        // Try opening the default policy, if one exists.
        lRes = RegOpenKeyEx(hkey, c_szDefaultPolicyOid, 0, KEY_READ, &hkeySub);
        if ((ERROR_SUCCESS != lRes) || (NULL == hkeySub)) {
            // couldn't find specified_and_default policy. deny access.
            goto ErrorReturn;
        }
    }

    Assert(NULL != hkeySub);
    // get the path to the policy dll, and load it.
    cbData = sizeof(szDllPath);
    lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyDllPath, NULL, 
                           &dwType, (LPBYTE)szDllPath, &cbData);
    if (ERROR_SUCCESS != lRes) {
        // policy not correctly registered. deny access.
        goto ErrorReturn;
    }
    szDllPath[ ARRAYSIZE(szDllPath) - 1 ] = '\0';
    // expand environment strings (if any) in the dll path we read in.
    if (REG_EXPAND_SZ == dwType)
    {
        ZeroMemory(szExpandedDllPath, ARRAYSIZE(szExpandedDllPath));
        ExpandEnvironmentStrings(szDllPath, szExpandedDllPath, ARRAYSIZE(szExpandedDllPath));
        szExpandedDllPath[ARRAYSIZE(szExpandedDllPath) - 1] = '\0';
        StrCpyN(szDllPath, szExpandedDllPath, ARRAYSIZE(szDllPath));
    }
    
    hinstDll = LoadLibraryEx(szDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);    
    if (NULL == hinstDll) {
        // couldn't load policy. deny access.
        goto ErrorReturn;
    }

    // get the entry func name.
    cbData = sizeof(szFuncName);
    lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyFuncName, NULL, 
                           &dwType, (LPBYTE)szFuncName, &cbData);
    if (ERROR_SUCCESS != lRes) {
        // policy not correctly registered. deny access.
        goto ErrorReturn;
    }
    pfnGetSMimePolicy = (PFNGetSMimePolicy) GetProcAddress(hinstDll, szFuncName);
    if (NULL == pfnGetSMimePolicy) {
        // couldn't get proc address. deny access.
        goto ErrorReturn;
    }


    hr = (pfnGetSMimePolicy) (0, plabel->pszObjIdSecurityPolicy, GetACP(), 
                              IID_ISMimePolicyCheckAccess, (LPUNKNOWN *) &pspca);
    if (FAILED(hr) || (NULL == pspca)) {
        // couldn't get required interface, 
        goto ErrorReturn;
    }

    // Call into the policy module to find out if access is to be denied/granted.
    hr = pspca->IsAccessGranted(dwFlags, hwnd, plabel, pccertDecrypt, 
                                pccertSigner, hcertstor);

        
    // fall through to exit.



exit:        
    if (pspca)     pspca->Release();
    if (hinstDll)  FreeLibrary(hinstDll);
    if (hkeySub)   RegCloseKey(hkeySub);
    if (hkey)      RegCloseKey(hkey);
    
    return hr;
    
ErrorReturn:
    if (! FAILED(hr)) {
        // If we had an error, but didn't get a failure code, force a failure.
        hr |= 0x80000000; 
    }
    goto exit;
}
#endif // SMIME_V3



/* * * END --- CAPISTM.CPP --- END * * */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\capistm.h ===
/*
**	c a p i s t m . h
**	
**	Purpose: declaration of an IStream that can talk to the
**           CAPI streaming methods
**
**  Owner:   t-erikne
**  Created: 6/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#ifndef __WINCRYPT_H__
#include <wincrypt.h>
#endif


//
// forwards
//
class CMimePropertyContainer;   // containx.h
class CInternetConverter;   // inetconv.h
typedef struct SMIMEINFOtag SMIMEINFO;  //smime.h
#ifndef WIN16
enum CSstate;   // capistm.cpp
#else // WIN16
enum CSstate {
    STREAM_NOT_BEGUN,
    STREAM_QUESTION_TIME,
    STREAM_QUESTION_TIME_FINAL,
    STREAM_SETUP_DECRYPT,
    STREAM_FIRST_WRITE_OUT,
    STREAM_TEST_NESTING,
    STREAM_DETACHED_OCCURING,
    STREAM_DETACHED_FINAL,  // must be +1 of DO
    STREAM_OCCURING, // must be +1 of DF
    STREAM_FINAL, // must be +1 of SO
    STREAM_ERROR,
    STREAM_GOTTYPE,
    };
#endif // !WIN16


//
// errors
//
#define CAPISTM_E_MSG_CLOSED    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1414)
#define CAPISTM_E_NOT_BEGUN     MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1415)
#define CAPISTM_E_OVERDONE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1416)
#define CAPISTM_E_GOTTYPE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1417)


//
// flags
//
#define CSTM_GO_ALL_THE_WAY     0x00000000
#define CSTM_TYPE_ONLY          0x00000001
#define CSTM_DETACHED           0x00000002
#define CSTM_ALLFLAGS           0x0000ffff
// high word is reserved.  see .cpp file

// NOTES on flags:
// CSTM_TYPE_ONLY -- Can't be called with CSTM_DETACHED.  You ever heard
// of detached encryption?  Also, calling EndStreaming is optional in this
// case since I'll fail my Write() eventually.  Call it and I'll noop. Hmm,
// having said that I recommend calling it.  Less pain in the future if it
// becomes needed.  Don't use this flag on encode, K?

//
// defines
//

//
// class
//
class CCAPIStm : public IStream
{
public:
    CCAPIStm(LPSTREAM lpstmOut);
    ~CCAPIStm(void);

    // --------------------------------------------------------------------
    // IUnknown
    // --------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // --------------------------------------------------------------------
    // IStream
    // --------------------------------------------------------------------
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *)
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *);
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *)
#endif // !WIN16
        { return E_ACCESSDENIED; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *)
        { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *, DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *)
        { return E_NOTIMPL; }
    STDMETHODIMP SetSize(ULARGE_INTEGER)
        { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP Revert(void)
        { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
        { return E_NOTIMPL; }

    // --------------------------------------------------------------------
    // CCAPIStm
    // --------------------------------------------------------------------
    HRESULT     HrInitialize(DWORD dwFlagsSEF, const HWND hwndParent, const BOOL fEncode, SMIMEINFO *const psi, DWORD dwFlagsStm, IMimeSecurityCallback * pCallback, PSECURITY_LAYER_DATA psld);
    HRESULT     HrInnerInitialize(DWORD dwFlagsSEF, const HWND hwndParent, DWORD dwFlagsStm, IMimeSecurityCallback * pCallback, PSECURITY_LAYER_DATA psld);
    HRESULT     EndStreaming();
    PSECURITY_LAYER_DATA GetSecurityLayerData() const;
    static HRESULT     DuplicateSecurityLayerData(const PSECURITY_LAYER_DATA pcsldIn, PSECURITY_LAYER_DATA *const ppsldOut);
    static void        FreeSecurityLayerData(PSECURITY_LAYER_DATA psld);

protected:
    static void FreeSecurityLayerData(PSECURITY_LAYER_DATA psld, BOOL fStackVar);
    BOOL SniffForEndOfHeader( BYTE *pbData, DWORD cbData);

private:
    DWORD           m_cRef;
    CSstate         m_csStatus;
    CSstate         m_csStream;
    HCRYPTMSG       m_hMsg;
    HCRYPTPROV      m_hProv;
    CCAPIStm *      m_pCapiInner;
    IStream *       m_pstmOut;
    PCCERT_CONTEXT  m_pUserCertDecrypt;
    DWORD           m_dwFlagsStm;
    DWORD           m_cStores;
    HCERTSTORE *    m_rgStores;
    ULONG           m_cbBeginWrite;
    ULONG           m_cbBeginSize;
    CInternetConverter *m_pConverter;
    PSECURITY_LAYER_DATA m_psldData;

    PCRYPT_ATTRIBUTES m_pattrAuth;
#ifndef MAC
#ifdef DEBUG
    IStream *       m_pstmDebugFile;
#endif
#endif  // !MAC
#ifdef SMIME_V3
    IMimeSecurityCallback * m_pSmimeCallback;
    HWND                m_hwnd;
    DWORD               m_dwFlagsSEF;
    UNALIGNED WCHAR *   m_pwszKeyPrompt; 
#endif // SMIME_V3

    LPBYTE          m_pbBuffer;
    DWORD           m_cbBuffer;


    HRESULT BeginEncodeStreaming(SMIMEINFO *const psi);
    HRESULT BeginDecodeStreaming(SMIMEINFO *const psi);

    HRESULT InitInner();
    HRESULT InitInner(SMIMEINFO *const psi, CCAPIStm *pOuter = NULL, PSECURITY_LAYER_DATA psldOuter = NULL);

#ifdef SMIME_V3
    HRESULT FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipientIndex,
                       const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                       HCERTSTORE hcertstor, DWORD * pdwCtrl,
                       CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                       PCCERT_CONTEXT * ppccertDecrypt);
    PCCERT_CONTEXT GetOuterDecryptCert();
#endif // SMIME_V3
    HRESULT VerifySignedMessage();
    BOOL    HandleEnveloped();
    HRESULT HandleNesting(CMimePropertyContainer *pContHeader);

    static BOOL WINAPI CBStreamOutput(const void *pvArg, BYTE *pbData, DWORD cbData, BOOL fFinal);
    BOOL    StreamOutput(BYTE *pbData, DWORD cbData, BOOL fFinal);
};


#ifdef SMIME_V3
HRESULT HrBuildContentEncryptionAlg(PSECURITY_LAYER_DATA psld, BLOB * pblob);
HRESULT HrDeriveKeyWrapAlg(PSECURITY_LAYER_DATA psld, CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO * pAgree);
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\capitype.h ===
#ifndef __CAPITYPE_H
#define __CAPITYPE_H

#ifndef __WINCRYPT_H__
#include "wincrypt.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN ADVAPI Functions

typedef
WINADVAPI
BOOL
WINAPI
CRYPTGETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTACQUIRECONTEXTA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
typedef
WINADVAPI
BOOL
WINAPI
CRYPTACQUIRECONTEXTW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#error this won't work
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTW
#else
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTA
#endif // !UNICODE


typedef
WINADVAPI
BOOL
WINAPI
CRYPTRELEASECONTEXT(
    HCRYPTPROV hProv,
    DWORD dwFlags);


typedef
WINADVAPI
BOOL
WINAPI
CRYPTGENKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTDESTROYKEY(
    HCRYPTKEY hKey);

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Hash Functions

typedef
WINADVAPI
BOOL
WINAPI
CRYPTCREATEHASH(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTHASHDATA(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTDESTROYHASH(
    HCRYPTHASH hHash);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTSIGNHASHA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Cryptograpic Functions

typedef
WINCRYPT32API
int
WINAPI
CRYPTSIGNMESSAGE(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTENCRYPTMESSAGE(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTSIGNANDENCRYPTMESSAGE(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeSignedAndEncrypted,
    IN DWORD cbToBeSignedAndEncrypted,
    OUT BYTE *pbSignedAndEncryptedBlob,
    IN OUT DWORD *pcbSignedAndEncryptedBlob
    );


typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTDECRYPTMESSAGE(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Store Functions

typedef
WINCRYPT32API HCERTSTORE WINAPI CERTOPENSYSTEMSTOREA(
    HCRYPTPROV      hProv,
    LPCSTR		szSubsystemProtocol
    );

typedef
WINCRYPT32API
HCERTSTORE
WINAPI
CERTOPENSTORE(
    IN LPCTSTR dwStoreProvType,
    IN DWORD dwCertEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN void const *pvPara
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTCLOSESTORE(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTENUMCERTIFICATESINSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTFINDCERTIFICATEINSTORE(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTADDCERTIFICATECONTEXTTOSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Certificate Functions

typedef
WINCRYPT32API
BOOL
WINAPI
CERTGETINTENDEDKEYUSAGE(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertInfo,
    OUT BYTE *pbKeyUsage,
    IN DWORD cbKeyUsage
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTGETCERTIFICATECONTEXTPROPERTY(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTGETSUBJECTCERTIFICATEFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTGETISSUERCERTIFICATEFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTFREECERTIFICATECONTEXT(
    IN PCCERT_CONTEXT pCertContext
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTDUPLICATECERTIFICATECONTEXT(
    IN PCCERT_CONTEXT pCertContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN CRL Functions

typedef
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CERTGETCRLFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL PCCERT_CONTEXT pIssuerContext,
    IN PCCRL_CONTEXT pPrevCrlContext,
    IN OUT DWORD *pdwFlags
    );

typedef
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CERTDUPLICATECRLCONTEXT(
    IN PCCRL_CONTEXT pCrlContext
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTFREECRLCONTEXT(
    IN PCCRL_CONTEXT pCrlContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Message Functions

typedef
WINCRYPT32API
HCRYPTMSG
WINAPI
CRYPTMSGOPENTODECODE(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGCLOSE(
    IN HCRYPTMSG hCryptMsg
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGUPDATE(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGCONTROL(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGGETPARAM(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Debug Functions

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTDECODEOBJECT(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTSETCERTIFICATECONTEXTPROPERTY(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Helper Functions

typedef
WINCRYPT32API
LPCSTR
WINAPI
CERTALGIDTOOID(
    IN DWORD dwAlgId
    );


typedef
WINCRYPT32API
DWORD
WINAPI
CERTOIDTOALGID(
    IN LPCSTR pszObjId
    );

typedef
WINCRYPT32API
DWORD
WINAPI
CERTNAMETOSTRA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    );

typedef
WINCRYPT32API
LONG
WINAPI
CERTVERIFYTIMEVALIDITY(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    );

typedef
WINCRYPT32API
PCERT_RDN_ATTR
WINAPI
CERTFINDRDNATTR(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    );

#ifdef __cplusplus
}
#endif // extern "C"

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\containx.h ===
// --------------------------------------------------------------------------------
// ContainX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __CONTAINX_H
#define __CONTAINX_H

// ---------------------------------------------------------------------------------------
// IID_CMimePropertyTable - {E31B34B2-8DA0-11d0-826A-00C04FD85AB4}
// ---------------------------------------------------------------------------------------
DEFINE_GUID(IID_CMimePropertyContainer, 0xe31b34b2, 0x8da0, 0x11d0, 0x82, 0x6a, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// ---------------------------------------------------------------------------------------
// Depends
// ---------------------------------------------------------------------------------------
#include "variantx.h"
#include "addressx.h"

// ---------------------------------------------------------------------------------------
// Forward Decls
// ---------------------------------------------------------------------------------------
class CInternetStream;
class CStreamLockBytes;
typedef struct tagWRAPTEXTINFO *LPWRAPTEXTINFO;
typedef struct tagRESOLVEURLINFO *LPRESOLVEURLINFO;
typedef struct tagPROPERTY *LPPROPERTY;
CODEPAGEID   MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset);

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD g_cSetPidLookups;
extern DWORD g_cHashLookups;
extern DWORD g_cHashInserts;
extern DWORD g_cHashCollides;
#endif

// --------------------------------------------------------------------------------
// HHEADERROW MACROS
// --------------------------------------------------------------------------------
#define HROWINDEX(_hrow)            (ULONG)HIWORD(_hrow)
#define HROWTICK(_hrow)             (WORD)LOWORD(_hrow)
#define HROWMAKE(_index)            (HHEADERROW)(MAKELPARAM(m_wTag, _index))
#define PRowFromHRow(_hrow)         (m_rHdrTable.prgpRow[HROWINDEX(_hrow)])

// --------------------------------------------------------------------------------
// HADDRESS MACROS
// --------------------------------------------------------------------------------
#define HADDRESSINDEX(_hadr)        (ULONG)HIWORD(_hadr)
#define HADDRESSTICK(_hadr)         (WORD)LOWORD(_hadr)
#define HADDRESSMAKE(_index)        (HADDRESS)(MAKELPARAM(m_wTag, _index))
#define HADDRESSGET(_hadr)          (m_rAdrTable.prgpAdr[HADDRESSINDEX(_hadr)])

// --------------------------------------------------------------------------------
// ADDRESSGROUP
// --------------------------------------------------------------------------------
typedef struct tagADDRESSGROUP {
    DWORD               cAdrs;                      // Number of addresses lin list    
    LPMIMEADDRESS       pHead;                      // Head Address props
    LPMIMEADDRESS       pTail;                      // Tail Address props
    LPPROPERTY          pNext;                      // Next Address Group
    LPPROPERTY          pPrev;                      // Previous Address Group
    BOOL                fDirty;                     // Dirty ?
} ADDRESSGROUP, *LPADDRESSGROUP;

// --------------------------------------------------------------------------------
// ADDRESSTABLE
// --------------------------------------------------------------------------------
typedef struct tagADDRESSTABLE {
    LPPROPERTY          pHead;                      // Head Address Group
    LPPROPERTY          pTail;                      // Tail Address Group
    ULONG               cEmpty;                     // Number of empty cells in prgAddr
    ULONG               cAdrs;                      // Count of addresses
    ULONG               cAlloc;                     // Number of items allocated in prgAddr
    LPMIMEADDRESS      *prgpAdr;                    // Array of addresses
} ADDRESSTABLE, *LPADDRESSTABLE;

// ---------------------------------------------------------------------------------------
// Container States
// ---------------------------------------------------------------------------------------
#define COSTATE_DIRTY          FLAG01               // The container is dirty
#define COSTATE_CSETTAGGED     FLAG02               // The object is tagged with a charset
#define COSTATE_1522CSETTAG    FLAG03               // I am using an rfc1522 charset as the default
#define COSTATE_HANDSONSTORAGE FLAG04               // I am holding a stream that I don't own
#define COSTATE_RFC822NEWS     FLAG05               // I am a message/rfc822 news message

// --------------------------------------------------------------------------------
// Property States
// --------------------------------------------------------------------------------
#define PRSTATE_ALLOCATED           FLAG02          // m_pbBlob has been allocated, free it
#define PRSTATE_HASDATA             FLAG03          // The value has had data set into it
#define PRSTATE_DIRTY               FLAG06          // Charset change, data change
#define PRSTATE_PARENT              FLAG07          // This prop is the parent of a multi-value prop
#define PRSTATE_RFC1522             FLAG08          // The data is encoded in rfc1522
#define PRSTATE_EXIST_BEFORE_LOAD   FLAG09          // The property existed before ::Load started
#define PRSTATE_USERSETROWNUM       FLAG10          // The user set the row number of this property
#define PRSTATE_NEEDPARSE           FLAG11          // The property contains address data, but has not been parsed into a groups
#define PRSTATE_SAVENOENCODE        FLAG12          // Don't encode or change the property data on save

// --------------------------------------------------------------------------------
// Number of Buckets in the Mime Property Container Hash Table
// --------------------------------------------------------------------------------
#define CBUCKETS        25

// --------------------------------------------------------------------------------
// PROPERTY
// --------------------------------------------------------------------------------
typedef struct tagPROPERTY {
    MIMEVARIANT         rValue;                     // Property Value
    LPINETCSETINFO      pCharset;                   // Character Set Information
    ENCODINGTYPE        ietValue;                   // State of this variable (IET_DECODED or IET_ENCODED)
    LPBYTE              pbBlob;                     // Data Blob
    ULONG               cbBlob;                     // Amount of valid date in m_pbBlob
    ULONG               cbAlloc;                    // Sizeof m_pbBlob
    BYTE                rgbScratch[170];            // Buffer to use if data fits
    HHEADERROW          hRow;                       // Handle to the header row
    LPPROPSYMBOL        pSymbol;                    // Property Symbol
    DWORD               dwState;                    // PDS_xxx
    LPPROPERTY          pNextHash;                  // Next Hash Value
    LPPROPERTY          pNextValue;                 // Next Property
    LPPROPERTY          pTailValue;                 // Tail data item (only for PRSTATE_PARENT) properties
    DWORD               dwRowNumber;                // Header Name to find
    ULONG               cboffStart;                 // Index into pStream where Header Starts (From: xxxx)
    ULONG               cboffColon;                 // Index into pStream of the Header Colon
    ULONG               cboffEnd;                   // Index into pStream where the Header Ends
    LPADDRESSGROUP      pGroup;                     // Head address if MPF_ADDRESS group
} PROPERTY;

// ---------------------------------------------------------------------------------------
// PSZDEFPRPOSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZDEFPROPSTRINGA(_pProperty, _pszDefault) \
    (((_pProperty) && ISSTRINGA(&(_pProperty)->rValue)) ? (_pProperty)->rValue.rStringA.pszVal : _pszDefault)

// --------------------------------------------------------------------------------
// HEADERTABLE
// --------------------------------------------------------------------------------
typedef struct tagHEADERTABLE {
    ULONG               cRows;                      // Number of lines in the header
    ULONG               cEmpty;                     // Number of empty (deleted) entries
    ULONG               cAlloc;                     // Number of items allocated in prgLine
    LPPROPERTY         *prgpRow;                    // Array of header rows
} HEADERTABLE, *LPHEADERTABLE;                      

// --------------------------------------------------------------------------------
// ROWINDEX
// --------------------------------------------------------------------------------
typedef struct tagROWINDEX {
    HHEADERROW          hRow;                       // Handle to the header row
    DWORD               dwWeight;                   // Position Weigth used to determine save order
    BOOL                fSaved;                     // Saved Yet?
} ROWINDEX, *LPROWINDEX;

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
typedef struct tagENCODINGTABLE {
    LPCSTR              pszEncoding;                // Encoding Name (i.e. base64)
    ENCODINGTYPE        ietEncoding;                // Encoding type
} ENCODINGTABLE;

// --------------------------------------------------------------------------------
// RESOLVEURLINFO
// --------------------------------------------------------------------------------
typedef struct tagRESOLVEURLINFO {
    LPCSTR              pszInheritBase;             // An Inherited base from multipart/realted
    LPCSTR              pszBase;                    // URL Base
    LPCSTR              pszURL;                     // Absolute or Relative URL
    BOOL                fIsCID;                     // Is pszURL a CID:<something>
} RESOLVEURLINFO, *LPRESOLVEURLINFO;

// --------------------------------------------------------------------------------
// FINDPROPERTY Information
// --------------------------------------------------------------------------------
typedef struct tagFINDPROPERTY {
    LPCSTR              pszPrefix;                  // Name Prefix to Find
    ULONG               cchPrefix;                  // Length of prefix
    LPCSTR              pszName;                    // Name of property to find par:xxx:
    ULONG               cchName;                    // Length of pszName
    DWORD               wHashIndex;                 // Current search bucket
    LPPROPERTY          pProperty;                  // Current property being searched
} FINDPROPERTY, *LPFINDPROPERTY;

// --------------------------------------------------------------------------------
// HEADOPTIONS
// --------------------------------------------------------------------------------
typedef struct tagHEADOPTIONS {
    LPINETCSETINFO      pDefaultCharset;            // Current character set for this message
    ULONG               cbMaxLine;                  // Max Line length                       
    BOOL                fAllow8bit;                 // Use rfc1522 encoding                  
    MIMESAVETYPE        savetype;                   // Save as SAVE_RFC1521 or SAVE_RFC822   
    BOOL                fNoDefCntType;              // Don't default content-type to text/plain on save
    RELOADTYPE          ReloadType;                 // How the the root header be treated on a reload
} HEADOPTIONS, *LPHEADOPTIONS;

// --------------------------------------------------------------------------------
// Global Default Header Options
// --------------------------------------------------------------------------------
extern const HEADOPTIONS g_rDefHeadOptions;
extern const ENCODINGTABLE g_rgEncoding[];

// --------------------------------------------------------------------------------
// TRIGGERTYPE
// --------------------------------------------------------------------------------
typedef DWORD                   TRIGGERTYPE;    // Trigger Type
#define IST_DELETEPROP          FLAG01          // Property is being deleted
#define IST_POSTSETPROP         FLAG02          // Before _HrSetPropertyValue
#define IST_POSTGETPROP         FLAG03          // Before _HrGetPropertyValue
#define IST_GETDEFAULT          FLAG04          // Property was not found, get the default 
#define IST_VARIANT_TO_STRINGA  FLAG05          // MVT_VARIANT -> MVT_STRINGA
#define IST_VARIANT_TO_STRINGW  FLAG06          // MVT_VARIANT -> MVT_STRINGW
#define IST_VARIANT_TO_VARIANT  FLAG07          // MVT_VARIANT -> MVT_VARIANT
#define IST_STRINGA_TO_VARIANT  FLAG08          // MVT_STRINGA -> MVT_VARIANT
#define IST_STRINGW_TO_VARIANT  FLAG09          // MVT_STRINGW -> MVT_VARIANT
#define IST_VARIANTCONVERT      (IST_VARIANT_TO_STRINGA  | IST_VARIANT_TO_STRINGW | IST_VARIANT_TO_VARIANT  | IST_VARIANT_TO_VARIANT | IST_STRINGA_TO_VARIANT  | IST_STRINGW_TO_VARIANT)

// --------------------------------------------------------------------------------
// TRIGGERCALL
// --------------------------------------------------------------------------------
typedef struct tagTRIGGERCALL {
    LPPROPSYMBOL        pSymbol;                // Property Symbol that generated the dispatch
    TRIGGERTYPE         tyTrigger;              // Reason or type of dispatch
} TRIGGERCALL, *LPTRIGGERCALL;

// --------------------------------------------------------------------------------
// TRIGGERCALLSTACK
// --------------------------------------------------------------------------------
#define CTSTACKSIZE 5
typedef struct tagTRIGGERCALLSTACK {
    WORD                cCalls;                 // Number of dispatch calls on the stack
    TRIGGERCALL         rgStack[CTSTACKSIZE];   // Dispatch Call Stack
} TRIGGERCALLSTACK, *LPTRIGGERCALLSTACK;

// --------------------------------------------------------------------------------
// DECLARE_TRIGGER Macro
// --------------------------------------------------------------------------------
#define DECLARE_TRIGGER(_pfnTrigger) \
    static HRESULT _pfnTrigger(LPCONTAINER, TRIGGERTYPE, DWORD, LPMIMEVARIANT, LPMIMEVARIANT)

// --------------------------------------------------------------------------------
// ISTRIGGERED - Does the symbol have an associated trigger
// --------------------------------------------------------------------------------
#define ISTRIGGERED(_pSymbol, _tyTrigger) \
    (NULL != (_pSymbol)->pTrigger && ISFLAGSET((_pSymbol)->pTrigger->dwTypes, _tyTrigger) && NULL != (_pSymbol)->pTrigger->pfnTrigger)

// --------------------------------------------------------------------------------
// PFNSYMBOLTRIGGER
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNSYMBOLTRIGGER)(LPCONTAINER, TRIGGERTYPE, DWORD, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// CALLTRIGGER - Executes a Trigger Based on a Symbol
// --------------------------------------------------------------------------------
#define CALLTRIGGER(_pSymbol, _pContainer, _tyTrigger, _dwFlags, _pSource, _pDest) \
    (*(_pSymbol)->pTrigger->pfnTrigger)(_pContainer, _tyTrigger, _dwFlags, _pSource, _pDest)

// --------------------------------------------------------------------------------
// CMimePropertyContainer
// --------------------------------------------------------------------------------
class CMimePropertyContainer : public IMimePropertySet,
                               public IMimeHeaderTable, 
                               public IMimeAddressTableW
{
public:
    // ----------------------------------------------------------------------------
    // CMimePropertyContainer
    // ----------------------------------------------------------------------------
    CMimePropertyContainer(void);
    ~CMimePropertyContainer(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IPersistStreamInit members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);

    // ---------------------------------------------------------------------------
    // IMimePropertySet members
    // ---------------------------------------------------------------------------
    STDMETHODIMP AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP DeleteExcept(ULONG cNames, LPCSTR *prgszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam);
    STDMETHODIMP Clone(IMimePropertySet **ppPropertySet);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo);
    STDMETHODIMP SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo);
    STDMETHODIMP EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum);
    STDMETHODIMP IsContentType(LPCSTR pszCntType, LPCSTR pszSubType);
    HRESULT IsContentTypeW(LPCWSTR pszPriType, LPCWSTR pszSubType);

    // ---------------------------------------------------------------------------
    // Overloaded IMimePropertySet members
    // ---------------------------------------------------------------------------
    HRESULT AppendProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT DeleteProp(LPPROPSYMBOL pSymbol);
    HRESULT QueryProp(LPPROPSYMBOL pSymbol, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT Clone(LPCONTAINER *ppContainer);

    // ---------------------------------------------------------------------------
    // Overloaded GetProp
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue); /* IMimePropertySet */
    HRESULT GetProp(LPCSTR pszName, LPSTR *ppszData);
    HRESULT GetProp(LPPROPSYMBOL pSymbol, LPSTR *ppszData);
    HRESULT GetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT GetPropW(LPPROPSYMBOL pSymbol, LPWSTR *ppwszData);

    // ---------------------------------------------------------------------------
    // Overloaded SetProp
    // ---------------------------------------------------------------------------
    HRESULT SetProp(LPCSTR pszName, LPCSTR pszData);
    HRESULT SetProp(LPPROPSYMBOL pSymbol, LPCSTR pszData);
    HRESULT SetProp(LPCSTR pszName, DWORD dwFlags, LPCSTR pszData);
    HRESULT SetProp(LPCSTR pszName, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT SetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPCMIMEVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue); /* IMimePropertySet */

    // ---------------------------------------------------------------------------
    // IMimeHeaderTable members
    // ---------------------------------------------------------------------------
    STDMETHODIMP FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow);
    STDMETHODIMP FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow);
    STDMETHODIMP CountRows(LPCSTR pszHeader, ULONG *pcRows);
    STDMETHODIMP AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData, LPHHEADERROW phRow);
    STDMETHODIMP DeleteRow(HHEADERROW hRow);
    STDMETHODIMP GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData);
    STDMETHODIMP SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData);
    STDMETHODIMP GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo);
    STDMETHODIMP SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber);
    STDMETHODIMP EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum);
    STDMETHODIMP Clone(IMimeHeaderTable **ppTable);

    // ----------------------------------------------------------------------------
    // IMimeAddressTable
    // ----------------------------------------------------------------------------
    STDMETHODIMP Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly, LPCSTR pszEmail, LPHADDRESS phAddress);
    STDMETHODIMP Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress);
    STDMETHODIMP SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps);
    STDMETHODIMP GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps);
    STDMETHODIMP GetSender(LPADDRESSPROPS pProps);
    STDMETHODIMP CountTypes(DWORD dwAdrTypes, ULONG *pcTypes);
    STDMETHODIMP GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList);
    STDMETHODIMP EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum);
    STDMETHODIMP Delete(HADDRESS hAddress);
    STDMETHODIMP DeleteTypes(DWORD dwAdrTypes);
    STDMETHODIMP GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat);
    STDMETHODIMP AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr);
    STDMETHODIMP ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr, LPADDRESSLIST pList);
    STDMETHODIMP Clone(IMimeAddressTable **ppTable);

    // ----------------------------------------------------------------------------
    // IMimeAddressTableW
    // ----------------------------------------------------------------------------
    STDMETHODIMP AppendW(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCWSTR pwszFriendly, LPCWSTR pwszEmail, LPHADDRESS phAddress);
    STDMETHODIMP GetFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppwszFormat);
    STDMETHODIMP AppendRfc822W(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCWSTR pwszRfc822Adr);
    STDMETHODIMP ParseRfc822W(DWORD dwAdrType, LPCWSTR pwszRfc822Adr, LPADDRESSLIST pList);
    // ---------------------------------------------------------------------------
    // Generic Stuff
    // ---------------------------------------------------------------------------
    HRESULT      IsState(DWORD dwState);
    void         ClearState(DWORD dwState);
    void         SetState(DWORD dwState);
    DWORD        DwGetState(LPDWORD pdwState);
    DWORD        DwGetMessageFlags(BOOL fHideTnef);
    HRESULT      Load(CInternetStream *pInternet);
    HRESULT      HrInsertCopy(LPPROPERTY pSource, BOOL fFromMovePropos);
    HRESULT      HrResolveURL(LPRESOLVEURLINFO pInfo);
    HRESULT      IsPropSet(LPCSTR pszName);
    ENCODINGTYPE GetEncodingType(void);

    // ---------------------------------------------------------------------------
    // Inline Public Stuff
    // ---------------------------------------------------------------------------
    ULONG CountProps(void) {
        EnterCriticalSection(&m_cs);
        ULONG c = m_cProps;
        LeaveCriticalSection(&m_cs);
        return c;
    }

    CODEPAGEID GetWindowsCP(void) {
        EnterCriticalSection(&m_cs);
        CODEPAGEID cp = MimeOleGetWindowsCPEx(m_rOptions.pDefaultCharset);
        LeaveCriticalSection(&m_cs);
        return cp;
    }

    // ---------------------------------------------------------------------------
    // Variant Conversion Stuff
    // ---------------------------------------------------------------------------
    HRESULT HrConvertVariant(LPPROPSYMBOL pSymbol, LPINETCSETINFO pCharset, ENCODINGTYPE ietSource, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522=NULL);
    HRESULT HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pDest);
    HRESULT HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522=NULL);

private:
    // ----------------------------------------------------------------------------
    // Property Methods
    // ----------------------------------------------------------------------------
    void    _FreeHashTableElements(void);
    void    _FreePropertyChain(LPPROPERTY pProperty);
    void    _UnlinkProperty(LPPROPERTY pProperty, LPPROPERTY *ppNextHash=NULL);
    void    _ReloadInitNew(void);
    void    _SetStateOnAllProps(DWORD dwState);
    BOOL    _FExcept(LPPROPSYMBOL pSymbol, ULONG cNames, LPCSTR *prgszName);
    HRESULT _HrFindProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrCreateProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrOpenProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrAppendProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrSetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue, BOOL fFromMovePropos);
    HRESULT _HrStoreVariantValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT _HrFindFirstProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty);
    HRESULT _HrFindNextProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty);
    HRESULT _HrGetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrGetMultiValueProperty(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrClonePropertiesTo(LPCONTAINER pContainer);
    HRESULT _HrGenerateFileName(LPCWSTR pszSuggest, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest);
    HRESULT _HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest, BOOL fFromMovePropos);
    HRESULT _GetFormatBase(DWORD dwAdrType, ADDRESSFORMAT format, LPPROPVARIANT pVariant);
    CODEPAGEID _GetAddressCodePageId(LPINETCSETINFO pDefaultCset, ENCODINGTYPE ietEncoding);

    // ----------------------------------------------------------------------------
    // Dispatch Members
    // ----------------------------------------------------------------------------
    HRESULT _HrCallSymbolTrigger(LPPROPSYMBOL pSymbol, TRIGGERTYPE tyTrigger, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrIsTriggerCaller(DWORD dwPropId, TRIGGERTYPE tyTrigger);

    // ----------------------------------------------------------------------------
    // Parameter Based Members
    // ----------------------------------------------------------------------------
    void    _DeleteLinkedParameters(LPPROPERTY pProperty);
    HRESULT _HrParseParameters(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT _HrBuildParameterString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);

    // ----------------------------------------------------------------------------
    // Internet Address Members
    // ----------------------------------------------------------------------------
    HRESULT _HrAppendAddressTable(LPPROPERTY pProperty);
    HRESULT _HrBuildAddressString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrParseInternetAddress(LPPROPERTY pProperty);
    HRESULT _HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format, VARTYPE vtFormat);
    HRESULT _HrSaveAddressA(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format);
    HRESULT _HrSaveAddressW(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format);
    HRESULT _HrAppendAddressGroup(LPADDRESSGROUP pGroup, LPMIMEADDRESS *ppAddress);
    HRESULT _HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT _HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT _HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress);
    HRESULT _HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress);
    void    _FreeAddressChain(LPADDRESSGROUP pGroup);
    void    _UnlinkAddressGroup(LPPROPERTY pProperty);
    void    _UnlinkAddress(LPMIMEADDRESS pAddress);
    void    _FreeAddress(LPMIMEADDRESS pAddress);
    void    _LinkAddress(LPMIMEADDRESS pAddress, LPADDRESSGROUP pGroup);

    // ----------------------------------------------------------------------------
    // IMimeHeaderTable Private Helpers
    // ----------------------------------------------------------------------------
    HRESULT _HrGetHeaderTableSaveIndex(ULONG *pcRows, LPROWINDEX *pprgIndex);
    void    _SortHeaderTableSaveIndex(LONG left, LONG right, LPROWINDEX prgIndex);
    BOOL    _FIsValidHRow(HHEADERROW hRow);
    BOOL    _FIsValidHAddress(HADDRESS hAddress);
    void    _UnlinkHeaderRow(HHEADERROW hRow);
    HRESULT _HrAppendHeaderTable(LPPROPERTY pProperty);
    HRESULT _HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch, LPSTR *ppszHeader, ULONG *pcboffColon);
    HRESULT _HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon);

public:
    // ----------------------------------------------------------------------------
    // Property Symbol Triggers
    // ----------------------------------------------------------------------------
    DECLARE_TRIGGER(TRIGGER_ATT_FILENAME);
    DECLARE_TRIGGER(TRIGGER_ATT_GENFNAME);
    DECLARE_TRIGGER(TRIGGER_ATT_NORMSUBJ);
    DECLARE_TRIGGER(TRIGGER_HDR_SUBJECT);
    DECLARE_TRIGGER(TRIGGER_HDR_CNTTYPE);
    DECLARE_TRIGGER(TRIGGER_ATT_PRITYPE);
    DECLARE_TRIGGER(TRIGGER_ATT_SUBTYPE);
    DECLARE_TRIGGER(TRIGGER_HDR_CNTXFER);
    DECLARE_TRIGGER(TRIGGER_PAR_NAME);
    DECLARE_TRIGGER(TRIGGER_PAR_FILENAME);
    DECLARE_TRIGGER(TRIGGER_ATT_SENTTIME);
    DECLARE_TRIGGER(TRIGGER_ATT_RECVTIME);
    DECLARE_TRIGGER(TRIGGER_ATT_PRIORITY);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;                     // Container Reference Count
    DWORD               m_dwState;                  // State of the container
    ULONG               m_cProps;                   // Current number of properties
    LPPROPERTY          m_prgIndex[PID_LAST];       // Array of pointers into local hash table for known items
    LPPROPERTY          m_prgHashTable[CBUCKETS];   // Hash table for properties
    TRIGGERCALLSTACK    m_rTrigger;                 // Current Property Id Owning the Dispatch
    WORD                m_wTag;                     // Handle Tag
    HEADERTABLE         m_rHdrTable;                // The header table
    ADDRESSTABLE        m_rAdrTable;                // The Address Table
    ULONG               m_cbSize;                   // Size of this header
    ULONG               m_cbStart;                  // Start Position of m_pStmLock
    CStreamLockBytes   *m_pStmLock;                 // Protective Wrapper for the stream object
    HEADOPTIONS         m_rOptions;                 // Header Options
    CRITICAL_SECTION    m_cs;                       // Thread Safety
};

// --------------------------------------------------------------------------------
// SYMBOLTRIGGER
// --------------------------------------------------------------------------------
typedef struct tagSYMBOLTRIGGER {
    DWORD               dwTypes;
    PFNSYMBOLTRIGGER    pfnTrigger;
} SYMBOLTRIGGER, *LPSYMBOLTRIGGER;

// --------------------------------------------------------------------------------
// Macro To Define a Trigger Function
// --------------------------------------------------------------------------------
#ifdef DEFINE_TRIGGERS
#define DEFINE_TRIGGER(_pfnTrigger, _dwTypes) \
    SYMBOLTRIGGER r##_pfnTrigger = \
    { \
        /* SYMBOLTRIGGER::dwTypes */        _dwTypes, \
        /* SYMBOLTRIGGER::pfnTrigger */     (PFNSYMBOLTRIGGER)CMimePropertyContainer::_pfnTrigger \
    }; \
    const LPSYMBOLTRIGGER LP##_pfnTrigger = &r##_pfnTrigger;
#else
#define DEFINE_TRIGGER(_pfnTrigger, _dwTypes) \
    extern const LPSYMBOLTRIGGER LP##_pfnTrigger;
#endif

// --------------------------------------------------------------------------------
// Trigger Definitions
// --------------------------------------------------------------------------------
DEFINE_TRIGGER(TRIGGER_ATT_FILENAME, IST_POSTSETPROP | IST_DELETEPROP | IST_POSTGETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_GENFNAME, IST_POSTGETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_NORMSUBJ, IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_HDR_SUBJECT,  IST_DELETEPROP);
DEFINE_TRIGGER(TRIGGER_HDR_CNTTYPE,  IST_DELETEPROP | IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_PRITYPE,  IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_SUBTYPE,  IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_HDR_CNTXFER,  IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_PAR_NAME,     IST_POSTSETPROP);
DEFINE_TRIGGER(TRIGGER_PAR_FILENAME, IST_DELETEPROP | IST_POSTSETPROP);
DEFINE_TRIGGER(TRIGGER_ATT_SENTTIME, IST_DELETEPROP | IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_RECVTIME, IST_DELETEPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_PRIORITY, IST_POSTSETPROP | IST_DELETEPROP | IST_GETDEFAULT | IST_VARIANTCONVERT);
   
#endif // __CONTAINX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\containx.cpp ===
// --------------------------------------------------------------------------------
// Contain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "internat.h"
#include "inetstm.h"
#include "dllmain.h"
#include "olealloc.h"
#include "objheap.h"
#include "vstream.h"
#include "addparse.h"
#include "enumhead.h"
#include "addrenum.h"
#include "stackstr.h"
#include "stmlock.h"
#include "enumprop.h"
#include "smime.h"
#ifndef WIN16
#include "wchar.h"
#endif // !WIN16
#include "symcache.h"
#ifdef MAC
#include <stdio.h>
#endif  // MAC
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "mimeutil.h"

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD   g_cSetPidLookups  = 0;
DWORD   g_cHashLookups    = 0;
DWORD   g_cHashInserts    = 0;
DWORD   g_cHashCollides   = 0;
#endif

// --------------------------------------------------------------------------------
// Default Header Options
// --------------------------------------------------------------------------------
const HEADOPTIONS g_rDefHeadOptions = {
    NULL,                           // hCharset
    DEF_CBMAX_HEADER_LINE,          // OID_CBMAX_HEADER_LINE
    DEF_ALLOW_8BIT_HEADER,          // OID_ALLOW_8BIT_HEADER
    DEF_SAVE_FORMAT,                // OID_SAVE_FORMAT
    DEF_NO_DEFAULT_CNTTYPE,         // OID_NO_DEFAULT_CNTTYPE
    DEF_HEADER_RELOAD_TYPE_PROPSET  // OID_HEADER_REALOD_TYPE
};

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
const ENCODINGTABLE g_rgEncoding[] = {
    { STR_ENC_7BIT,         IET_7BIT     },
    { STR_ENC_QP,           IET_QP       },
    { STR_ENC_BASE64,       IET_BASE64   },
    { STR_ENC_UUENCODE,     IET_UUENCODE },
    { STR_ENC_XUUENCODE,    IET_UUENCODE },
    { STR_ENC_XUUE,         IET_UUENCODE },
    { STR_ENC_8BIT,         IET_8BIT     },
    { STR_ENC_BINARY,       IET_BINARY   },
    { STR_ENC_BINHEX40,     IET_BINHEX40 }
};


// --------------------------------------------------------------------------------
// CMimePropertyContainer::CMimePropertyContainer
// --------------------------------------------------------------------------------
CMimePropertyContainer::CMimePropertyContainer(void)
{
    // Basic Stuff
    m_cRef = 1;
    m_dwState = 0;
    m_cProps = 0;
    m_wTag = 0;
    m_cbSize = 0;
    m_cbStart = 0;
    m_pStmLock = NULL;

    // Default Options
    CopyMemory(&m_rOptions, &g_rDefHeadOptions, sizeof(HEADOPTIONS));
    m_rOptions.pDefaultCharset = CIntlGlobals::GetDefHeadCset();

    // Address Table
    ZeroMemory(&m_rAdrTable, sizeof(ADDRESSTABLE));

    // Header Table
    ZeroMemory(&m_rHdrTable, sizeof(HEADERTABLE));

    // Dispatch Call Stack
    ZeroMemory(&m_rTrigger, sizeof(TRIGGERCALLSTACK));

    // Property Indexes
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));
    ZeroMemory(m_prgHashTable, sizeof(m_prgHashTable));

    // Thread Safety
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::~CMimePropertyContainer
// --------------------------------------------------------------------------------
CMimePropertyContainer::~CMimePropertyContainer(void)
{
    // I better not have any dispatch calls on the stack
    Assert(m_rTrigger.cCalls == 0);

    // Free Hash Table
    _FreeHashTableElements();

    // Free the Address Table
    SafeMemFree(m_rAdrTable.prgpAdr);

    // Free the Header Table
    SafeMemFree(m_rHdrTable.prgpRow);

    // Release Stream
    SafeRelease(m_pStmLock);

    // Delete CS
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimePropertySet *)this;
    else if (IID_IPersist == riid)
        *ppv = (IPersist *)(IMimePropertySet *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_IMimePropertySet == riid)
        *ppv = (IMimePropertySet *)this;
    else if (IID_IMimeHeaderTable == riid)
        *ppv = (IMimeHeaderTable *)this;
    else if (IID_IMimeAddressTable == riid)
        *ppv = (IMimeAddressTable *)this;
    else if (IID_IMimeAddressTableW == riid)
        *ppv = (IMimeAddressTableW *)this;
    else if (IID_CMimePropertyContainer == riid)
        *ppv = (CMimePropertyContainer *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimePropertyContainer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimePropertyContainer::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsState
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, dwState)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::ClearState
// --------------------------------------------------------------------------------
void CMimePropertyContainer::ClearState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetState
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetState(LPDWORD pdwState)
{
    Assert(pdwState);
    EnterCriticalSection(&m_cs);
    DWORD dw = m_dwState;
    LeaveCriticalSection(&m_cs);
    return dw;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetState
// --------------------------------------------------------------------------------
void CMimePropertyContainer::SetState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetClassID
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetClassID(CLSID *pClassID)
{
    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimePropertySet, sizeof(CLSID));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetSizeMax
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pStream=NULL;
    ULONG       cbSize;

    // Invalid Arg
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty
    if (ISFLAGSET(m_dwState, COSTATE_DIRTY))
    {
        // Create temp stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Commit
        CHECKHR(hr = Save(pStream, FALSE));

        // Get the Stream Size
        CHECKHR(hr = HrGetStreamSize(pStream, &cbSize));
    }

    // Otherwise, m_cbSize should be set to current size
    else
        cbSize = m_cbSize;

    // Return the Size
#ifdef MAC
    ULISet32(*pcbSize, cbSize);
#else   // !MAC
    pcbSize->QuadPart = cbSize;
#endif  // MAC

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::IsDirty(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, COSTATE_DIRTY)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_ReloadInitNew
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_ReloadInitNew(void)
{
    // Handle all reload types
    switch(m_rOptions.ReloadType)
    {
    // Default behavior is no InitNew
    case RELOAD_HEADER_NONE:
        return;

    // InitNew everytime Load is called
    case RELOAD_HEADER_RESET:
        InitNew();
        break;

    // Merge or replace headers
    case RELOAD_HEADER_APPEND:
        SafeRelease(m_pStmLock);
        break;

    case RELOAD_HEADER_REPLACE:
        SafeRelease(m_pStmLock);
        _SetStateOnAllProps(PRSTATE_EXIST_BEFORE_LOAD);
        break;
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_SetStateOnAllProps (only first level properties)
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_SetStateOnAllProps(DWORD dwState)
{
    // Locals
    ULONG           i;
    LPPROPERTY      pProperty;

    // Do I have any groups
    if (0 == m_cProps)
        return;

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Walk the hash list
        pProperty = m_prgHashTable[i];

        // Loop the overflows
        while(pProperty)
        {
            // Set the state on the property
            FLAGSET(pProperty->dwState, dwState);

            // Goto Next
            pProperty = pProperty->pNextHash;
        }
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::InitNew(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No dispatchs better be out...
    Assert(m_rTrigger.cCalls == 0);

    // Free the PropTable
    _FreeHashTableElements();

    // Release the Stream
    SafeRelease(m_pStmLock);

    // Reset m_wTag
    m_wTag = LOWORD(GetTickCount());
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // Clear State
    m_dwState = 0;
    m_cbSize = 0;
    m_cbStart = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Load(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    CStreamLockBytes   *pStmLock=NULL;
    CInternetStream     cInternet;
    ULONG               cbOffset;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Wrap pStream in a pStmLock
    CHECKALLOC(pStmLock = new CStreamLockBytes(pStream));

    // Get Current Stream Position
    CHECKHR(hr = HrGetStreamPos(pStream, &cbOffset));

    // Create text stream object
    cInternet.InitNew(cbOffset, pStmLock);

    // Load from text stream object
    CHECKHR(hr = Load(&cInternet));

exit:
    // Cleanup
    SafeRelease(pStmLock);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Load
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Load(CInternetStream *pInternet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbData,
                    cbStart,
                    cboffStart,
                    cboffEnd;
    LONG            cboffColon;
    LPSTR           psz;
    DWORD           dwRowNumber=1;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    MIMEVARIANT     rValue;
    PROPSTRINGA     rHeader;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Starting Position
    m_cbStart = pInternet->DwGetOffset();

    // Initialize the PropValue
    rValue.type = MVT_STRINGA;

    // Reload InitNewType
    _ReloadInitNew();

    // Read Headers into Rows
    while(1)
    {
        // Mark Start of this header
        cboffStart = pInternet->DwGetOffset();

        // Read header line...
        CHECKHR(hr = pInternet->HrReadHeaderLine(&rHeader, &cboffColon));
        Assert(ISVALIDSTRINGA(&rHeader));

        // Are we done - empty line signals end of header
        if (*rHeader.pszVal == '\0')
        {
            // Compute Header Size
            m_cbSize = (LONG)(pInternet->DwGetOffset() - m_cbStart);

            // Done
            break;
        }

        // If no colon found
        if (-1 == cboffColon)
        {
            // Use the Illegal Symbol
            pSymbol = SYM_ATT_ILLEGAL;
        }

        // Otherwise...
        else
        {
            // Skip whitespace
            cbData = cboffColon;
            psz = rHeader.pszVal;

#if 0
            while(*psz && (*psz == ' ' || *psz == '\t'))
            {
                cbData--;
                psz++;
            }
#endif

            // Save Header Name
            Assert(rHeader.pszVal[cboffColon] == ':');
            *(rHeader.pszVal + cboffColon) = '\0';

            // Find Global Property
            hr = g_pSymCache->HrOpenSymbol(rHeader.pszVal, TRUE, &pSymbol);

            // Replace the colon
            *(rHeader.pszVal + cboffColon) = ':';

            // Bad Header Name or Failure
            if (FAILED(hr))
            {
                // Unknown Failure
                if (MIME_E_INVALID_HEADER_NAME != hr)
                {
                    TrapError(hr);
                    goto exit;
                }

                // Use the Illegal Symbol
                pSymbol = SYM_ATT_ILLEGAL;

                // Were are S_OK
                hr = S_OK;
            }
        }

        // Assert pSymbol
        Assert(pSymbol);

        // If Not Illegal
        if (PID_ATT_ILLEGAL == pSymbol->dwPropId)
        {
            cbData = rHeader.cchVal;
            psz = rHeader.pszVal;
            cboffColon = 0;
        }

        // Otherwise
        else
        {
            // We better have a symbol
            Assert(rHeader.pszVal[cboffColon] == ':');

            // Step over space between colon and first character
            cbData = (rHeader.cchVal - cboffColon - 1);
            psz = rHeader.pszVal + cboffColon + 1;
            if (*psz == ' ' || *psz == '\t')
            {
                cbData--;
                psz++;
            }
        }

        // Invalid Arg
        Assert(psz && psz[cbData] == '\0');

        // Append a Property
        if (RELOAD_HEADER_REPLACE == m_rOptions.ReloadType)
        {
            // Dos the property pSymbol already exist?
            if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
            {
                // Did the property exist before the load
                if (ISFLAGSET(pProperty->dwState, PRSTATE_EXIST_BEFORE_LOAD))
                {
                    // Delete the Property
                    SideAssert(SUCCEEDED(DeleteProp(pSymbol)));
                }
            }
        }

        // Simply append any existing property
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Setup Property Value
        rValue.rStringA.pszVal = psz;
        rValue.rStringA.cchVal = cbData;

        // Store the data on the property
        CHECKHR(hr = _HrSetPropertyValue(pProperty, PDF_ENCODED, &rValue, FALSE));

        // Still Trying to detect a character set...
        if (!ISFLAGSET(m_dwState, COSTATE_CSETTAGGED) && PID_ATT_ILLEGAL != pSymbol->dwPropId)
        {
            // Content-Type charset=xxx
            if (PID_HDR_CNTTYPE == pSymbol->dwPropId && NULL != m_prgIndex[PID_PAR_CHARSET])
            {
                // Locals
                LPPROPERTY      pProperty;
                LPINETCSETINFO  pCharset;

                // Did we have a charset=xxxx yet
                pProperty = m_prgIndex[PID_PAR_CHARSET];

                // Make sure it is a valid string property
                Assert(ISSTRINGA(&pProperty->rValue));

                // Get charset handle...
                if (SUCCEEDED(g_pInternat->HrOpenCharset(pProperty->rValue.rStringA.pszVal, &pCharset)))
                {
                    // We are tagged
                    FLAGSET(m_dwState, COSTATE_CSETTAGGED);

                    // Save the charset
                    m_rOptions.pDefaultCharset = pCharset;
                }
            }

            // Otherwise, is the property encoded in an rfc1522 charset?
            else if (!ISFLAGSET(m_dwState, COSTATE_1522CSETTAG) && pProperty->pCharset)
            {
                // The header is tagged with a 1522 charset
                FLAGSET(m_dwState, COSTATE_1522CSETTAG);

                // Assume that charset
                m_rOptions.pDefaultCharset = pProperty->pCharset;
            }
        }

        // Set The Row Number
        pProperty->dwRowNumber = dwRowNumber++;

        // Set Start Offset
        pProperty->cboffStart = cboffStart;

        // Map cboffColon from Line to Stream offset
        pProperty->cboffColon = cboffColon + pProperty->cboffStart;

        // Save cbOffEnd
        pProperty->cboffEnd = pInternet->DwGetOffset();
    }

    // Save the Stream
    Assert(NULL == m_pStmLock);

    // Get the stream object from the text stream
    pInternet->GetLockBytes(&m_pStmLock);

    // If not character set tagged
    if (!ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
    {
        // If not tagged with a 1522 charset, use the default
        if (!ISFLAGSET(m_dwState, COSTATE_1522CSETTAG) && CIntlGlobals::GetDefHeadCset())
        {
            // Assume the Default character Set
            m_rOptions.pDefaultCharset = CIntlGlobals::GetDefHeadCset();
        }

        // Lookup Charset Info
        if (m_rOptions.pDefaultCharset)
        {
            // Locals
            MIMEVARIANT rValue;

            // Setup Variant
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = m_rOptions.pDefaultCharset->szName;
            rValue.rStringA.cchVal = lstrlen(m_rOptions.pDefaultCharset->szName);

            // Set the Charset Attribute
            SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, 0, &rValue)));
        }
    }

    // We better have a charset
    Assert(m_rOptions.pDefaultCharset);

    // Make sure we are not dirty
    FLAGCLEAR(m_dwState, COSTATE_DIRTY);

    // Any Illegal lines found ?
    hr = (NULL == m_prgIndex[PID_ATT_ILLEGAL]) ? S_OK : MIME_S_ILLEGAL_LINES_FOUND;

exit:
    // Failure
    if (FAILED(hr))
        InitNew();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetHeaderTableSaveIndex
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetHeaderTableSaveIndex(ULONG *pcRows, LPROWINDEX *pprgIndex)
{
    // Locals
    HRESULT      hr=S_OK;
    ULONG        i;
    LPPROPERTY   pRow;
    ULONG        cRows=0;
    LPROWINDEX   prgIndex=NULL;
    ULONG        cSymbols=g_pSymCache->GetCount();
    DWORD        dwMaxRow=0;

    // Invalid Arg
    Assert(pcRows && pprgIndex);

    // Init Row Count
    *pcRows = 0;
    *pprgIndex = NULL;

    // Allocate pprgdwIndex based on m_rHdrTable.cRows (this is the max)
    CHECKALLOC(prgIndex = (LPROWINDEX)g_pMalloc->Alloc(sizeof(ROWINDEX) * m_rHdrTable.cRows));

    // Zero
    ZeroMemory(prgIndex, sizeof(ROWINDEX) * m_rHdrTable.cRows);

    // I need to find the larged pProperty->dwRowNumber so that I can order the rows better
    for (i=0; i<m_rHdrTable.cRows; i++)
    {
        if (m_rHdrTable.prgpRow[i])
            if (!ISFLAGSET(m_rHdrTable.prgpRow[i]->dwState, PRSTATE_USERSETROWNUM))
                if (m_rHdrTable.prgpRow[i]->dwRowNumber > dwMaxRow)
                    dwMaxRow = m_rHdrTable.prgpRow[i]->dwRowNumber;
    }

    // Compute Position Weight for all items in the table
    for (i=0; i<m_rHdrTable.cRows; i++)
    {
        // Readability
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Save As SAVE_RFC822 and this is a MPF_MIME header
        if (SAVE_RFC822 == m_rOptions.savetype && ISFLAGSET(pRow->pSymbol->dwFlags, MPF_MIME))
            continue;

        // Init dwPosWeight
        prgIndex[cRows].dwWeight = 0;
        prgIndex[cRows].hRow = pRow->hRow;

        // Unknonw Row Number
        if (0 == pRow->dwRowNumber)
        {
            // Compute the Row Weigth
            Assert(pRow->pSymbol->dwRowNumber != 0);
            prgIndex[cRows].dwWeight = (ULONG)((pRow->pSymbol->dwRowNumber * 1000) / m_rHdrTable.cRows);
        }

        // User set the row number
        else if (ISFLAGSET(pRow->dwState, PRSTATE_USERSETROWNUM))
        {
            // Compute the Row Weigth
            prgIndex[cRows].dwWeight = (ULONG)((pRow->dwRowNumber * 1000) / m_rHdrTable.cRows);
        }

        // Otheriwse, this row number have been in the original row set from ::Load
        else if (dwMaxRow > 0)
        {
            // Weight within original row set
            DWORD dw1 = (DWORD)((pRow->dwRowNumber * 100) / dwMaxRow);

            // Compute global symbol row number
            DWORD dwRow = (DWORD)((float)((float)dw1 / (float)100) * cSymbols);

            // Compute the Row Weigth
            prgIndex[cRows].dwWeight = (ULONG)((dwRow * 1000) / m_rHdrTable.cRows);
        }

        // Increment Row Count
        cRows++;
    }

    // Set the Sort Order Index of all the rows
    if (cRows > 0)
        _SortHeaderTableSaveIndex(0, cRows - 1, prgIndex);

    // Return the Index
    *pprgIndex = prgIndex;
    *pcRows = cRows;
    prgIndex = NULL;

exit:
    // Cleanup
    SafeMemFree(prgIndex);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_SortHeaderTableSaveIndex
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_SortHeaderTableSaveIndex(LONG left, LONG right, LPROWINDEX prgIndex)
{
    // Locals
    register    long i, j;
    ROWINDEX    k, temp;

    i = left;
    j = right;
    CopyMemory(&k, &prgIndex[(i + j) / 2], sizeof(ROWINDEX));

    do
    {
        while(prgIndex[i].dwWeight < k.dwWeight && i < right)
            i++;
        while (prgIndex[j].dwWeight > k.dwWeight && j > left)
            j--;

        if (i <= j)
        {
            CopyMemory(&temp, &prgIndex[i], sizeof(ROWINDEX));
            CopyMemory(&prgIndex[i], &prgIndex[j], sizeof(ROWINDEX));
            CopyMemory(&prgIndex[j], &temp, sizeof(ROWINDEX));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _SortHeaderTableSaveIndex(left, j, prgIndex);
    if (i < right)
        _SortHeaderTableSaveIndex(i, right, prgIndex);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FIsValidHAddress
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FIsValidHAddress(HADDRESS hAddress)
{
    // Invalid Sig or index
    if ((WORD)(HADDRESSTICK(hAddress)) != m_wTag || HADDRESSINDEX(hAddress) >= m_rAdrTable.cAdrs)
        return FALSE;

    // Row has been deleted
    if (NULL == m_rAdrTable.prgpAdr[HADDRESSINDEX(hAddress)])
        return FALSE;

    // Otherwise, its valid
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FIsValidHRow
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FIsValidHRow(HHEADERROW hRow)
{
    // Invalid Sig or index
    if ((WORD)(HROWTICK(hRow)) != m_wTag || HROWINDEX(hRow) >= m_rHdrTable.cRows)
        return FALSE;

    // Row has been deleted
    if (NULL == m_rHdrTable.prgpRow[HROWINDEX(hRow)])
        return FALSE;

    // Otherwise, its valid
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    LPPROPERTY      pProperty;
    ULONG           i,
                    j,
                    cbWrote,
                    cRows;
    MIMEVARIANT     rValue;
    LPROWINDEX      prgIndex=NULL;
    INETCSETINFO    rCharset;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // There Better be a content type
    if (FALSE == m_rOptions.fNoDefCntType && NULL == m_prgIndex[PID_HDR_CNTTYPE])
    {
        // Set the content Type
        SideAssert(SUCCEEDED(SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN)));
    }

    // Validate the Charset
    if (m_rOptions.pDefaultCharset)
    {
        // Internet Encoded and Windows Encoding are CPI_AUTODETECT
        if (CP_JAUTODETECT == m_rOptions.pDefaultCharset->cpiInternet ||
            50222          == m_rOptions.pDefaultCharset->cpiInternet ||
            50221          == m_rOptions.pDefaultCharset->cpiInternet)
        {
            // Only for _autodetect
            if (CP_JAUTODETECT == m_rOptions.pDefaultCharset->cpiInternet)
            {
                // Change Charset
                SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(c_szISO2022JP, &m_rOptions.pDefaultCharset)));
            }

            // Reset It
            if (m_prgIndex[PID_PAR_CHARSET])
            {
                // Set the Charset...
                SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, c_szISO2022JP)));
            }
        }
    }

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Speicify data type
    rValue.type = MVT_STREAM;
    rValue.pStream = pStream;

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));

        // Saved already
        if (TRUE == prgIndex[i].fSaved)
            continue;

        // Readability
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Ask the value for the data
        CHECKHR(hr = _HrGetPropertyValue(pRow, PDF_HEADERFORMAT | PDF_NAMEINDATA, &rValue));

        // This block of code was disabled to fix:
        // Raid-62460: MimeOLE: IMimeAddressTable::AppendRfc822 does not work correctly
#if 0
        // Raid-43786: Mail:  Reply all to a message with multiple To: fields in header and the original recipient list is tripled
        if (ISFLAGSET(pRow->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Loop through remainin items and mark as saved
            for (j=i+1; j<cRows; j++)
            {
                // Get the row
                Assert(_FIsValidHRow(prgIndex[j].hRow));

                // Readability
                pProperty = PRowFromHRow(prgIndex[j].hRow);

                // Same Address Type
                if (pProperty->pSymbol->dwAdrType == pRow->pSymbol->dwAdrType)
                    prgIndex[j].fSaved = TRUE;
            }
        }
#endif
    }

    // Make sure we are not dirty
    if (fClearDirty)
        FLAGCLEAR(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeMemFree(prgIndex);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FreeHashTableElements
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_FreeHashTableElements(void)
{
    // Locals
    ULONG           i;
    LPPROPERTY      pCurrHash,
                    pNextHash;

    // Do I have any groups
    if (0 == m_cProps)
        return;

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Is this chain empty ?
        if (m_prgHashTable[i])
        {
            // Walk the hash list
            pCurrHash = m_prgHashTable[i];

            // Loop the overflows
            while(pCurrHash)
            {
                // Save Next
                pNextHash = pCurrHash->pNextHash;

                // Release This Chain
                _FreePropertyChain(pCurrHash);

                // Goto Next
                pCurrHash = pNextHash;
            }

            // Set to NULL
            m_prgHashTable[i] = NULL;
        }
    }

    // Empty the arrays
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));

    // No Groups
    m_cProps = 0;
    m_rAdrTable.cAdrs = 0;
    m_rHdrTable.cRows = 0;
    m_rHdrTable.cEmpty = 0;
    m_rAdrTable.cEmpty = 0;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreePropertyChain
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreePropertyChain(LPPROPERTY pProperty)
{
    // Locals
    LPPROPERTY   pCurrValue,
                 pNextValue;

    // Walk this list
    pCurrValue = pProperty;
    while(pCurrValue)
    {
        // Save Next Item
        pNextValue = pCurrValue->pNextValue;

        // Remove from header table
        if (pCurrValue->hRow)
            _UnlinkHeaderRow(pCurrValue->hRow);

        // Remove from address table
        if (pCurrValue->pGroup)
            _UnlinkAddressGroup(pCurrValue);

        // Free this item
        ObjectHeap_FreeProperty(pCurrValue);

        // Goto next
        pCurrValue = pNextValue;
    }
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkHeaderRow
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkHeaderRow(HHEADERROW hRow)
{
    // Validate the Handle
    Assert(_FIsValidHRow(hRow));

    // Get the row
    m_rHdrTable.prgpRow[HROWINDEX(hRow)] = NULL;

    // Increment Empty Count
    m_rHdrTable.cEmpty++;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkAddressGroup
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkAddressGroup(LPPROPERTY pProperty)
{
    // Invalid Arg
    Assert(pProperty && pProperty->pGroup);

    // Free This Address Chain
    _FreeAddressChain(pProperty->pGroup);

    // Prepare for unlink
    LPPROPERTY pNext = pProperty->pGroup->pNext;
    LPPROPERTY pPrev = pProperty->pGroup->pPrev;

    // If Previious...
    if (pPrev)
    {
        Assert(pPrev->pGroup);
        pPrev->pGroup->pNext = pNext;
    }

    // If Next
    if (pNext)
    {
        Assert(pNext->pGroup);
        pNext->pGroup->pPrev = pPrev;
    }

    // Was this the header ?
    if (m_rAdrTable.pHead == pProperty)
        m_rAdrTable.pHead = pNext;
    if (m_rAdrTable.pTail == pProperty)
        m_rAdrTable.pTail = pPrev;

    // Clear the Group
    ZeroMemory(pProperty->pGroup, sizeof(ADDRESSGROUP));
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreeAddressChain
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreeAddressChain(LPADDRESSGROUP pGroup)
{
    // Locals
    LPMIMEADDRESS  pCurr;
    LPMIMEADDRESS  pNext;

    // Loop through data structures
    pCurr = pGroup->pHead;
    while(pCurr)
    {
        // Set Next
        pNext = pCurr->pNext;

        // Unlink this address
        _FreeAddress(pCurr);

        // Goto Next
        pCurr = pNext;
    }

    // Fixup the Group
    pGroup->pHead = NULL;
    pGroup->pTail = NULL;
    pGroup->cAdrs = 0;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreeAddress
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreeAddress(LPMIMEADDRESS pAddress)
{
    // Validate the Handle
    Assert(_FIsValidHAddress(pAddress->hThis));

    // Get the row
    m_rAdrTable.prgpAdr[HADDRESSINDEX(pAddress->hThis)] = NULL;

    // Increment Empty Count
    m_rAdrTable.cEmpty++;

    // Free pCurr
    ObjectHeap_FreeAddress(pAddress);
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkAddress
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkAddress(LPMIMEADDRESS pAddress)
{
    // Invalid Arg
    Assert(pAddress && pAddress->pGroup);

    // Prepare for unlink
    LPMIMEADDRESS pNext = pAddress->pNext;
    LPMIMEADDRESS pPrev = pAddress->pPrev;

    // If Previious...
    if (pPrev)
    {
        Assert(pPrev->pGroup && pPrev->pGroup == pAddress->pGroup);
        pPrev->pNext = pNext;
    }

    // If Next
    if (pNext)
    {
        Assert(pNext->pGroup && pNext->pGroup == pAddress->pGroup);
        pNext->pPrev = pPrev;
    }

    // Was this the header ?
    if (pAddress->pGroup->pHead == pAddress)
        pAddress->pGroup->pHead = pNext;
    if (pAddress->pGroup->pTail == pAddress)
        pAddress->pGroup->pTail = pPrev;

    // Decrement Group Count
    pAddress->pGroup->cAdrs--;

    // Address group is dirty
    pAddress->pGroup->fDirty = TRUE;

    // Cleanup pAddress
    pAddress->pNext = NULL;
    pAddress->pPrev = NULL;
    pAddress->pGroup = NULL;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindFirstProperty
// ---------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindFirstProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty)
{
    // Validate pFind
    Assert(pFind->pszPrefix && pFind->pszName)
    Assert(pFind->pszPrefix[pFind->cchPrefix] == '\0' && pFind->pszName[pFind->cchName] == '\0');

    // Start with first hash table bucket
    pFind->wHashIndex = 0;

    // Start with first property in the hash table
    pFind->pProperty = m_prgHashTable[pFind->wHashIndex];

    // Find Next
    return _HrFindNextProperty(pFind, ppProperty);
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindNextProperty
// ---------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindNextProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Init
    *ppProperty = NULL;

    // Continue walking buckets
    while (1)
    {
        // Continue looping chain
        while (pFind->pProperty)
        {
            // Good Symbol
            Assert(SUCCEEDED(HrIsValidSymbol(pFind->pProperty->pSymbol)));

            // Readability
            pSymbol = pFind->pProperty->pSymbol;

            // Should I delete this one
            if (pSymbol->cchName >= pFind->cchPrefix + pFind->cchName)
            {
                // Compare Prefix
                if (StrCmpNI(pSymbol->pszName, pFind->pszPrefix, pFind->cchPrefix) == 0)
                {
                    // Compare Name
                    if (StrCmpNI(pSymbol->pszName + pFind->cchPrefix, pFind->pszName, pFind->cchName) == 0)
                    {
                        // We found a property
                        *ppProperty = pFind->pProperty;

                        // Goto the next in the chain
                        pFind->pProperty = pFind->pProperty->pNextHash;

                        // Done
                        goto exit;
                    }
                }
            }

            // Next in chain
            pFind->pProperty = pFind->pProperty->pNextHash;
        }

        // Next Bucket
        pFind->wHashIndex++;

        // Done
        if (pFind->wHashIndex >= CBUCKETS)
            break;

        // If not done, goto first item in the bucket
        pFind->pProperty = m_prgHashTable[pFind->wHashIndex];
    }

    // NOt Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fTryName=FALSE;

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // By Known Symbol
    if (ISKNOWNPID(pSymbol->dwPropId))
    {
        // Stats
#ifdef DEBUG
        g_cSetPidLookups++;
#endif
        // Is there data
        if (m_prgIndex[pSymbol->dwPropId])
        {
            // Set It (could be NULL)
            *ppProperty = m_prgIndex[pSymbol->dwPropId];

            // Done
            goto exit;
        }
    }

    // Otherwise, lookup by name
    else
    {
        // Stats
#ifdef DEBUG
        g_cHashLookups++;
#endif
        // Loop
        Assert(pSymbol->wHashIndex < CBUCKETS);
        for (LPPROPERTY pProperty=m_prgHashTable[pSymbol->wHashIndex]; pProperty!=NULL; pProperty=pProperty->pNextHash)
        {
            // Compare
            if (pProperty && pProperty->pSymbol->dwPropId == pSymbol->dwPropId)
            {
                // Validate Hash Index
                Assert(pProperty->pSymbol->wHashIndex == pSymbol->wHashIndex);

                // Set Return
                *ppProperty = pProperty;

                // Done
                goto exit;
            }
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Not Found
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrOpenProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrOpenProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // If we dont find it, try to create it
    if (FAILED(_HrFindProperty(pSymbol, ppProperty)))
        return TrapError(_HrCreateProperty(pSymbol, ppProperty));

    // We Found It, return
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCreateProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCreateProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty;
#ifdef DEBUG
    LPPROPERTY      pTemp;
#endif

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // Allocate an item...
    CHECKHR(hr = ObjectHeap_HrAllocProperty(&pProperty));

    // Set the symbol
    pProperty->pSymbol = pSymbol;

    // The Property Better Not Exist Yet (Assumes caller did a FindProperty before CreateProperty)
    Assert(_HrFindProperty(pSymbol, &pTemp) == MIME_E_NOT_FOUND);

    // MPF_HEADER
    if (ISFLAGSET(pSymbol->dwFlags, MPF_HEADER))
    {
        // Insert into the header table
        CHECKHR(hr = _HrAppendHeaderTable(pProperty));
    }

    // MPF_ADDRESS
    if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Insert into the header table
        CHECKHR(hr = _HrAppendAddressTable(pProperty));
    }

    // Stats
#ifdef DEBUG
    g_cHashInserts++;
    if (m_prgHashTable[pSymbol->wHashIndex])
        g_cHashCollides++;
#endif

    // Set Next Hash Item
    Assert(pSymbol->wHashIndex < CBUCKETS);
    pProperty->pNextHash = m_prgHashTable[pSymbol->wHashIndex];

    // New Properties are places as the head of the overflow chain
    m_prgHashTable[pSymbol->wHashIndex] = pProperty;

    // Insert into Known Property Index
    if (ISKNOWNPID(pSymbol->dwPropId))
    {
        Assert(m_prgIndex[pSymbol->dwPropId] == NULL);
        m_prgIndex[pSymbol->dwPropId] = pProperty;
    }

    // PRSTATE_PARENT
    FLAGSET(pProperty->dwState, PRSTATE_PARENT);

    // Return this prop
    *ppProperty = pProperty;

    // Count Properties
    m_cProps++;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pParent,
                    pAppend;

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // Does pTag already exist ?
    if (SUCCEEDED(_HrFindProperty(pSymbol, &pParent)))
    {
        // Better be a parent property
        Assert(ISFLAGSET(pParent->dwState, PRSTATE_PARENT));

        // Allocate an item...
        CHECKHR(hr = ObjectHeap_HrAllocProperty(&pAppend));

        // pSymbol From pTag
        pAppend->pSymbol = pParent->pSymbol;

        // If this is a header property, insert into the header table
        if (ISFLAGSET(pSymbol->dwFlags, MPF_HEADER))
        {
            // Insert into the header table
            CHECKHR(hr = _HrAppendHeaderTable(pAppend));
        }

        // MPF_ADDRESS
        if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Insert into the header table
            CHECKHR(hr = _HrAppendAddressTable(pAppend));
        }

        // Update pParent->pTailData
        if (NULL == pParent->pNextValue)
        {
            Assert(NULL == pParent->pTailValue);
            pParent->pNextValue = pAppend;
            pParent->pTailValue = pAppend;
        }
        else
        {
            Assert(pParent->pTailValue && pParent->pTailValue->pNextValue == NULL);
            pParent->pTailValue->pNextValue = pAppend;
            pParent->pTailValue = pAppend;
        }

        // Return this prop
        *ppProperty = pAppend;

        // Count Properties
        m_cProps++;
    }

    // Otherwise, create a new property
    else
    {
        // Create It
        CHECKHR(hr = _HrCreateProperty(pSymbol, ppProperty));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendAddressGroup(LPADDRESSGROUP pGroup, LPMIMEADDRESS *ppAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i=0;
    BOOL            fUsingEmpty=FALSE;
    LPMIMEADDRESS   pAddress;

    // Use Empty Cell
    if (m_rAdrTable.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rAdrTable.cAdrs; i++)
        {
            // Empty ?
            if (NULL == m_rAdrTable.prgpAdr[i])
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rAdrTable.cAdrs + 1 > m_rAdrTable.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rAdrTable.prgpAdr, sizeof(LPMIMEADDRESS) * (m_rAdrTable.cAlloc + 10)));

            // Increment alloc size
            m_rAdrTable.cAlloc += 10;
        }

        // Index to use
        i = m_rAdrTable.cAdrs;
    }

    // Allocate an address props structure
    CHECKHR(hr = ObjectHeap_HrAllocAddress(&pAddress));

    // Assign a Handle
    pAddress->hThis = HADDRESSMAKE(i);

    // Link the Address into the group
    _LinkAddress(pAddress, pGroup);

    // Put it into the Array
    m_rAdrTable.prgpAdr[i] = pAddress;

    // Return It
    *ppAddress = pAddress;

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rAdrTable.cAdrs++;
    else
        m_rAdrTable.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_LinkAddress
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_LinkAddress(LPMIMEADDRESS pAddress, LPADDRESSGROUP pGroup)
{
    // Validate Arg
    Assert(pAddress && pGroup && NULL == pAddress->pNext && NULL == pAddress->pPrev);

    // Put pGroup into pAddress
    pAddress->pGroup = pGroup;

    // Link into the list
    if (NULL == pGroup->pHead)
    {
        Assert(NULL == pGroup->pTail);
        pGroup->pHead = pAddress;
        pGroup->pTail = pAddress;
    }
    else
    {
        Assert(pGroup->pTail && pGroup->pTail->pNext == NULL);
        pGroup->pTail->pNext = pAddress;
        pAddress->pPrev = pGroup->pTail;
        pGroup->pTail = pAddress;
    }

    // Increment Count
    pGroup->cAdrs++;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendAddressTable
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendAddressTable(LPPROPERTY pProperty)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pProperty && NULL == pProperty->pGroup);

    // New Group
    CHECKALLOC(pProperty->pGroup = (LPADDRESSGROUP)g_pMalloc->Alloc(sizeof(ADDRESSGROUP)));

    // ZeroInit
    ZeroMemory(pProperty->pGroup, sizeof(ADDRESSGROUP));

    // Link this group
    if (NULL == m_rAdrTable.pHead)
    {
        Assert(m_rAdrTable.pTail == NULL);
        m_rAdrTable.pHead = pProperty;
        m_rAdrTable.pTail = pProperty;
    }
    else
    {
        Assert(m_rAdrTable.pTail && m_rAdrTable.pTail->pGroup && m_rAdrTable.pTail->pGroup->pNext == NULL);
        m_rAdrTable.pTail->pGroup->pNext = pProperty;
        pProperty->pGroup->pPrev = m_rAdrTable.pTail;
        m_rAdrTable.pTail = pProperty;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendHeaderTable
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendHeaderTable(LPPROPERTY pProperty)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               i=0;
    BOOL                fUsingEmpty=FALSE;

    // Invalid Arg
    Assert(pProperty && NULL == pProperty->hRow);

    // Use Empty Cell
    if (m_rHdrTable.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rHdrTable.cRows; i++)
        {
            // Empty ?
            if (NULL == m_rHdrTable.prgpRow)
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rHdrTable.cRows + 1 > m_rHdrTable.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rHdrTable.prgpRow, sizeof(LPPROPERTY) * (m_rHdrTable.cAlloc + 10)));

            // Increment alloc size
            m_rHdrTable.cAlloc += 10;
        }

        // Index to use
        i = m_rHdrTable.cRows;
    }

    // Save Property index table
    m_rHdrTable.prgpRow[i] = pProperty;

    // Set Handle
    pProperty->hRow = HROWMAKE(i);

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rHdrTable.cRows++;
    else
        m_rHdrTable.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsPropSet
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsPropSet(LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;

    // Invalid Arg
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    if (FAILED(g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol)))
        goto exit;

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
        goto exit;

    // Its Set
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurr;

    // Invalid Arg
    if (NULL == pszName || NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Find the Property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // PIM_CHARSET
    if (ISFLAGSET(pInfo->dwMask, PIM_CHARSET))
    {
        // Get Charset
        pInfo->hCharset = pProperty->pCharset ? pProperty->pCharset->hCharset : m_rOptions.pDefaultCharset->hCharset;
    }

    // PIM_ENCODINGTYPE
    if (ISFLAGSET(pInfo->dwMask, PIM_ENCODINGTYPE))
    {
        // Get Encoding
        pInfo->ietEncoding = pProperty->ietValue;
    }

    // PIM_ROWNUMBER
    if (ISFLAGSET(pInfo->dwMask, PIM_ROWNUMBER))
        pInfo->dwRowNumber = pProperty->dwRowNumber;

    // PIM_FLAGS
    if (ISFLAGSET(pInfo->dwMask, PIM_FLAGS))
        pInfo->dwFlags = pProperty->pSymbol->dwFlags;

    // PIM_PROPID
    if (ISFLAGSET(pInfo->dwMask, PIM_PROPID))
        pInfo->dwPropId = pProperty->pSymbol->dwPropId;

    // PIM_VALUES
    if (ISFLAGSET(pInfo->dwMask, PIM_VALUES))
    {
        // Let me count the ways
        for(pCurr=pProperty, pInfo->cValues=0; pCurr!=NULL; pCurr=pCurr->pNextValue)
            pInfo->cValues++;
    }

    // PIM_VTCURRENT
    if (ISFLAGSET(pInfo->dwMask, PIM_VTCURRENT))
        pInfo->vtCurrent = MimeVT_To_PropVT(&pProperty->rValue);

    // PIM_VTDEFAULT
    if (ISFLAGSET(pInfo->dwMask, PIM_VTDEFAULT))
        pInfo->vtDefault = pProperty->pSymbol->vtDefault;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurr;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == pszName || NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Find the Property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // Set All Values with the property information
    for(pCurr=pProperty; pCurr!=NULL; pCurr=pCurr->pNextValue)
    {
        // PIM_CHARSET
        if (ISFLAGSET(pInfo->dwMask, PIM_CHARSET))
        {
            // Open the Charset
            if (SUCCEEDED(g_pInternat->HrOpenCharset(pInfo->hCharset, &pCharset)))
                pProperty->pCharset = pCharset;
        }

        // PIM_ENCODED
        if (ISFLAGSET(pInfo->dwMask, PIM_ENCODINGTYPE))
        {
            // Change Encoding State of the mime Variant
            pProperty->ietValue = (IET_ENCODED == pInfo->ietEncoding) ? IET_ENCODED : IET_DECODED;
        }

        // PIM_ROWNUMBER
        if (ISFLAGSET(pInfo->dwMask, PIM_ROWNUMBER))
        {
            // Save the Row Number
            pCurr->dwRowNumber = pInfo->dwRowNumber;

            // Make a note that the use set this row number so the save order doesn't get hosed
            FLAGSET(pCurr->dwState, PRSTATE_USERSETROWNUM);
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         cProps=0,
                         cAlloc=0;
    LPENUMPROPERTY       prgProp=NULL;
    LPPROPERTY           pCurrProp;
    CMimeEnumProperties *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrProp=m_prgHashTable[i]; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextHash)
        {
            // Grow the array ?
            if (cProps + 1 > cAlloc)
            {
                // Realloc
                CHECKALLOC(prgProp = (LPENUMPROPERTY)g_pMalloc->Realloc((LPVOID)prgProp, sizeof(ENUMPROPERTY) * (cAlloc + 10)));

                // Increment cAlloc
                cAlloc += 10;
            }

            // hRow
            prgProp[cProps].hRow = pCurrProp->hRow;

            // dwPropId
            prgProp[cProps].dwPropId = pCurrProp->pSymbol->dwPropId;

            // Init Name to Null
            prgProp[cProps].pszName = NULL;

            // Name
            if (ISFLAGSET(dwFlags, EPF_NONAME) == FALSE)
            {
                // Return name
                CHECKALLOC(prgProp[cProps].pszName = PszDupA(pCurrProp->pSymbol->pszName));
            }

            // Increment iProp
            cProps++;
        }
    }

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumProperties);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, cProps, prgProp, FALSE));

    // Don't Free pEnumRow
    prgProp = NULL;
    cProps = 0;

    // Return it
    (*ppEnum) = (IMimeEnumProperties *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    g_pMoleAlloc->FreeEnumPropertyArray(cProps, prgProp, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::BindToObject
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::BindToObject(REFIID riid, void **ppvObject)
{
    return TrapError(QueryInterface(riid, ppvObject));
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrBuildAddressString
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrBuildAddressString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cAddrsWrote=0;
    LPSTREAM        pStream=NULL;
    CByteStream     cByteStream;
    LPPROPERTY      pCurrValue;
    MIMEVARIANT     rValue;
    ADDRESSFORMAT   format;
    LPINETCSETINFO  pCharsetSource=NULL;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // Decide on a format
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
        format = AFT_RFC822_TRANSMIT;
    else if (ISFLAGSET(dwFlags, PDF_ENCODED))
        format = AFT_RFC822_ENCODED;
    else
        format = AFT_DISPLAY_BOTH;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pProperty->pSymbol->pszName, pProperty->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // Save with no encoding
    if (ISFLAGSET(pProperty->dwState, PRSTATE_SAVENOENCODE))
    {
        // Better be groupdirty
        Assert(ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

        // Convert Data...
        rValue.type = MVT_STRINGA;

        // Destination is not encoded
        pCharsetSource = pProperty->pCharset ? pProperty->pCharset : m_rOptions.pDefaultCharset;

        // Convert It
        CHECKHR(hr = HrConvertVariant(pProperty, CVF_NOALLOC | PDF_ENCODED, &rValue));

        // Write it to the stream
        CHECKHR(hr = pStream->Write(rValue.rStringA.pszVal, rValue.rStringA.cchVal, NULL));
    }

    // Otherwise, normal save
    else
    {
        // Loop through parsed addresses...
        for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
        {
            // We should have an address
            Assert(pCurrValue->pGroup && ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS));

            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));

            // Tell each address group object to write its data to the stream
            if (pCurrValue->pGroup)
            {
                // Write the data
                CHECKHR(hr = _HrSaveAddressGroup(pCurrValue, pStream, &cAddrsWrote, format, VT_LPSTR));
            }

            // Set It Yet ?
            if (NULL == pCharsetSource)
            {
                pCharsetSource = pCurrValue->pCharset ? pCurrValue->pCharset : m_rOptions.pDefaultCharset;
            }

            // No Vectoring
            if (FALSE == ISFLAGSET(dwFlags, PDF_VECTOR))
                break;
        }
    }

    // Transmit
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
    {
        // Final CRLF if Transmit Format
        CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
    }

    // Final CRLF
    if (cAddrsWrote || ISFLAGSET(dwFlags, PDF_NAMEINDATA) || ISFLAGSET(dwFlags,PDF_HEADERFORMAT))
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            CODEPAGEID cpSource=CP_ACP;
            PROPSTRINGA rStringA;

            // Init
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Determine cpSoruce
            if (pCharsetSource)
            {
                // If Encoded, use internet codepage, otherwise, use Windows codepage
                cpSource = ISFLAGSET(dwFlags, PDF_ENCODED) ? pCharsetSource->cpiInternet : MimeOleGetWindowsCPEx(pCharsetSource);
            }

            // Convert to Unicode
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(cpSource, &rStringA, &pValue->rStringW));

        }
        else
            Assert(MVT_STREAM == pValue->type);
    }

    // No Data
    else
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

exit:
    // Cleanup
    MimeVariantFree(&rValue);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrBuildParameterString
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrBuildParameterString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    LPSTR           pszParamName;
    LPSTR           pszEscape=NULL;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;
    LPSTREAM        pStream=NULL;
    CByteStream     cByteStream;
    BOOL            fQuoted;
    ULONG           cWrote=0;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pProperty && pProperty->pNextValue == NULL && pValue);
    Assert(ISSTRINGA(&pProperty->rValue));

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init rValue
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pProperty->pSymbol->pszName, pProperty->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // Write First Prop
    CHECKHR(hr = pStream->Write(pProperty->rValue.rStringA.pszVal, pProperty->rValue.rStringA.cchVal, NULL));

    // We wrote one item
    cWrote = 1;

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);
    while(SUCCEEDED(hrFind) && pParameter)
    {
        // Transmit Format
        if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
        {
            // Write ';\r\n\t'
            CHECKHR(hr = pStream->Write(c_szParamFold, lstrlen(c_szParamFold), NULL));
        }

        // Otherwise
        else
        {
            // Write ';\r\n\t'
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }

        // Get Parameter Name
        pszParamName = PszScanToCharA((LPSTR)pParameter->pSymbol->pszName, ':');
        pszParamName++;
        pszParamName = PszScanToCharA(pszParamName, ':');
        pszParamName++;

        // Write the name
        CHECKHR(hr = pStream->Write(pszParamName, lstrlen(pszParamName), NULL));

        // Write the property...
        CHECKHR(hr = pStream->Write(c_szEqual, lstrlen(c_szEqual), NULL));

        // Convert Data...
        rValue.type = MVT_STRINGA;

        // Convert It
        CHECKHR(hr = HrConvertVariant(pParameter, CVF_NOALLOC | PDF_ENCODED, &rValue));

        // Quoted
        fQuoted = FALSE;
        if (lstrcmpi(pszParamName, (LPSTR)c_szBoundary) == 0 || lstrcmpi(pszParamName, (LPSTR)c_szFileName) == 0 ||
            lstrcmpi(pszParamName, (LPSTR)c_szName)     == 0 || lstrcmpi(pszParamName, (LPSTR)c_szID)       == 0 ||
            lstrcmpi(pszParamName, (LPSTR)c_szCharset)  == 0)
            fQuoted = TRUE;

        // Otherwise, check for must quote characters
        else
        {
            // Loop the string
            for (ULONG i=0; i<rValue.rStringA.cchVal; i++)
            {
                // Must quote character
                if (rValue.rStringA.pszVal[i] == ';'   ||
                    rValue.rStringA.pszVal[i] == '\"'  ||
                    rValue.rStringA.pszVal[i] == '/'   ||
                    rValue.rStringA.pszVal[i] == '\""' ||
                    rValue.rStringA.pszVal[i] == '\''  ||
                    rValue.rStringA.pszVal[i] == '=')
                {
                    fQuoted = TRUE;
                    break;
                }
            }
        }

        // Quoted
        if (fQuoted)
        {
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
            CHECKHR(hr = pStream->Write(rValue.rStringA.pszVal, rValue.rStringA.cchVal, NULL));
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }

        // Ohterwise, just write the data
        else
        {
            // Set pszValue
            LPSTR pszValue = rValue.rStringA.pszVal;
            ULONG cchValue = rValue.rStringA.cchVal;

            // Escape It
            if (MimeOleEscapeString(CP_ACP, pszValue, &pszEscape) == S_OK)
            {
                pszValue = pszEscape;
                cchValue = lstrlen(pszEscape);
            }

            // Write the property...
            CHECKHR(hr = pStream->Write(pszValue, cchValue, NULL));
        }

        // Count Props Wrote
        cWrote++;

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);

        // Cleanup
        MimeVariantFree(&rValue);
        SafeMemFree(pszEscape);
    }

    // Transmit
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
    {
        // Final CRLF if Transmit Format
        CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
    }

    // If We Wrote Stuff
    if (cWrote)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            PROPSTRINGA rStringA;

            // Init
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Convert to variant
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(CP_ACP, &rStringA, &pValue->rStringW));
        }

        else
            Assert(MVT_STREAM == pValue->type);
    }

exit:
    // Cleanup
    MimeVariantFree(&rValue);
    SafeMemFree(pszEscape);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetMultiValueProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetMultiValueProperty(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;
    LPPROPERTY      pCurrProp;
    CByteStream     cByteStream;
    ULONG           cLines;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I will read it as a stream
    rValue.type = MVT_STREAM;

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        rValue.pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        rValue.pStream = &cByteStream;

    // Count lines for rItem.hItem and mark iFirst and iLast
    for (cLines=0, pCurrProp=pProperty; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextValue, cLines++)
    {
        // Get the variant
        CHECKHR(hr = HrConvertVariant(pCurrProp, dwFlags | CVF_NOALLOC, &rValue));
        Assert(rValue.fCopy == FALSE);

        // Not Header Format, add CRLF
        if (FALSE == ISFLAGSET(dwFlags, PDF_HEADERFORMAT) && cLines > 0)
        {
            // CRLF
            CHECKHR(hr = rValue.pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
        }
    }

    // More than 1 line
    if (cLines > 0)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(rValue.pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            PROPSTRINGA rStringA;

            // ZeroMemory
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(rValue.pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Convert to Unicode
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(CP_ACP, &rStringA, &pValue->rStringW));

        }
        else
            Assert(MVT_STREAM == pValue->type);
    }

    // Otherwise, no data
    else
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrIsTriggerCaller
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrIsTriggerCaller(DWORD dwPropId, TRIGGERTYPE tyTrigger)
{
    // If there is 0 or 1 calls on the stack, there is no caller
    if (m_rTrigger.cCalls <= 1)
        return S_FALSE;

    // Readability
    LPTRIGGERCALL pCall = &m_rTrigger.rgStack[m_rTrigger.cCalls - 2];

    // Is the Previous entry on the stack equal to dwPropId tyTrigger
    return (dwPropId == pCall->pSymbol->dwPropId && tyTrigger == pCall->tyTrigger) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCallSymbolTrigger
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCallSymbolTrigger(LPPROPSYMBOL pSymbol, TRIGGERTYPE tyTrigger, DWORD dwFlags,
    LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    WORD        cCalls;

    // Validate Params
    Assert(pSymbol && ISTRIGGERED(pSymbol, tyTrigger));

    // Dispatch Stack Overflow - If this happens, there is a design problem
    Assert(m_rTrigger.cCalls + 1 < CTSTACKSIZE);

    // Note current number of calls
    cCalls = m_rTrigger.cCalls;

    // Put this call onto the stack
    m_rTrigger.rgStack[m_rTrigger.cCalls].pSymbol     = pSymbol;
    m_rTrigger.rgStack[m_rTrigger.cCalls].tyTrigger = tyTrigger;

    // Increment Call Stack Size
    m_rTrigger.cCalls++;

    // Property Dispatch
    hr = CALLTRIGGER(pSymbol, this, tyTrigger, dwFlags, pValue, NULL);

    // Increment Call Stack Size
    Assert(m_rTrigger.cCalls > 0);
    m_rTrigger.cCalls--;

    // Same Number of Calls in/out
    Assert(cCalls == m_rTrigger.cCalls);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetPropertyValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;

    // Delegate if MPF_ADDRESS
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Get Address Data
        CHECKHR(hr = _HrBuildAddressString(pProperty, dwFlags, pValue));
    }

    // Delegate if MPF_HASPARAMS
    else if (ISFLAGSET(dwFlags, PDF_ENCODED) && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Get Address Data
        CHECKHR(hr = _HrBuildParameterString(pProperty, dwFlags, pValue));
    }

    // Multivalue property
    else if (pProperty->pNextValue && ISFLAGSET(dwFlags, PDF_VECTOR))
    {
        // Translate pProperty->rVariant to pVariant
        CHECKHR(hr = _HrGetMultiValueProperty(pProperty, dwFlags, pValue));
    }

    // Otherwise, single value property
    else
    {
        // Translate pProperty->rVariant to pVariant
        CHECKHR(hr = HrConvertVariant(pProperty, dwFlags, pValue));
    }

    // Dispatch
    if (ISTRIGGERED(pProperty->pSymbol, IST_POSTGETPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pProperty->pSymbol, IST_POSTGETPROP, dwFlags, pValue));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags,
    DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522 /* = NULL */)
{
    // Invalid Arg
    Assert(pProperty && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pProperty->pSymbol, pProperty->pCharset,
                                    pProperty->ietValue, dwFlags, dwState, pSource, pDest, pfRfc1522);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pDest)
{
    // Invalid Arg
    Assert(pProperty && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pProperty->pSymbol, pProperty->pCharset,
                        pProperty->ietValue, dwFlags, pProperty->dwState, &pProperty->rValue, pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPSYMBOL pSymbol, LPINETCSETINFO pCharset,
    ENCODINGTYPE ietSource, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, BOOL *pfRfc1522 /* = NULL */)

{
    // Locals
    LPPROPERTY      pProperty;

    // Invalid Args
    Assert(pSymbol && pSource && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Charset Passed In
    if (NULL == pCharset && SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
        pCharset = pProperty->pCharset;

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pSymbol, pCharset, ietSource, dwFlags, dwState, pSource, pDest, pfRfc1522);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetPropertyValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue, BOOL fFromMovePropos)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPSTR           pszFree=NULL;

    // Adjust pValue if property can not be internationalized
    if (MVT_STRINGW == pValue->type && (!ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_INETCSET) || ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS)))
    {
        // Convert to ANSI
        CHECKHR(hr = g_pInternat->HrWideCharToMultiByte(CP_ACP, &pValue->rStringW, &rSource.rStringA));

        // Setup Source
        rSource.type = MVT_STRINGA;

        // Free This
        pszFree = rSource.rStringA.pszVal;

        // Change the Value
        pValue = &rSource;
    }

    // MPF_HASPARAMS
    if (ISFLAGSET(dwFlags, PDF_ENCODED) && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS) && !fFromMovePropos)
    {
        // Parse parameters into other properties
        CHECKHR(hr = _HrParseParameters(pProperty, dwFlags, pValue));
    }

    // Otherwise, just copy the data
    else
    {
        // Store the variant data
        CHECKHR(hr = _HrStoreVariantValue(pProperty, dwFlags, pValue));

        // If Encoded, check for rfc1522 character set
        if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_RFC1522) && ISFLAGSET(dwFlags, PDF_ENCODED) && MVT_STRINGA == pValue->type)
        {
            // Locals
            CHAR            szCharset[CCHMAX_CSET_NAME];
            LPINETCSETINFO  pCharset;

            // Scan for 1522 Encoding...
            if (SUCCEEDED(MimeOleRfc1522Decode(pValue->rStringA.pszVal, szCharset, sizeof(szCharset)-1, NULL)))
            {
                // Find the Charset
                if (SUCCEEDED(g_pInternat->HrOpenCharset(szCharset, &pCharset)))
                {
                    // Save Pointer to Charset
                    pProperty->pCharset = pCharset;
                }
            }
        }

        // MPF_ADDRESS
        if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Parse the address into the address group
            _FreeAddressChain(pProperty->pGroup);

            // Not Dirty
            pProperty->pGroup->fDirty = FALSE;

            // Reset the parsing flag
            FLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE);
        }
    }

    // Set some new state
    FLAGSET(pProperty->dwState, PRSTATE_HASDATA);

    // Dispatch
    if (ISTRIGGERED(pProperty->pSymbol, IST_POSTSETPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pProperty->pSymbol, IST_POSTSETPROP, dwFlags, &pProperty->rValue));
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseParameters(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cchName;
    CStringParser   cString;
    CHAR            chToken;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pParameter;

    // Invalid Arg
    Assert(pProperty && pValue && ISFLAGSET(dwFlags, PDF_ENCODED));

    // Define a Stack String to hold parameter names
    STACKSTRING_DEFINE(rName, 255);

    // Error
    if (!ISSTRINGA(pValue))
    {
        Assert(FALSE);
        hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
        goto exit;
    }

    // Init rValue
    rValue.type = MVT_STRINGA;

    // Lets delete currently linked parameters
    _DeleteLinkedParameters(pProperty);

    // Set the Members
    cString.Init(pValue->rStringA.pszVal, pValue->rStringA.cchVal, PSF_NOFRONTWS | PSF_NOTRAILWS | PSF_NOCOMMENTS);

    // Parse up to colon
    chToken = cString.ChParse(";");
    if (0 == cString.CchValue())
    {
        // Setup a variant
        rValue.rStringA.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_MIME_TEXT_PLAIN);

        // Store the variant data
        CHECKHR(hr = _HrStoreVariantValue(pProperty, PDF_ENCODED, &rValue));

        // Done
        goto exit;
    }

    // Setup a variant
    rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
    rValue.rStringA.cchVal = cString.CchValue();

    // Store the variant data
    CHECKHR(hr = _HrStoreVariantValue(pProperty, PDF_ENCODED, &rValue));

    // Done
    if (';' != chToken)
        goto exit;

    // Read all parameters
    while('\0' != chToken)
    {
        Assert(';' == chToken);
        // $$$ BUG $$$ - This fixes the bogus NDR messages returned from Netscape server.
        //               there message have a invalid Content-Type line:
        //               mulipart/alternative;; boundary="--=============12345678"
        //                                   ^^
        //               The double semi-colon is invalid, but I will handle it here since
        //               a parameter name can not begin with a semicolon.
        // Better be at a semicolon
        chToken = cString.ChSkip();
        if ('\0' == chToken)
            goto exit;

        // Parse parameter name
        chToken = cString.ChParse("=");
        if ('=' != chToken)
            goto exit;

        // Compute the length of the name
        cchName = pProperty->pSymbol->cchName + cString.CchValue() + 6;  // (YST) QFE bug

        // Grow the stack string to hold cchName
        STACKSTRING_SETSIZE(rName, cchName);

        // Make Parameter Name, set actual cchName
        cchName = wnsprintf(rName.pszVal, cchName, "par:%s:%s", pProperty->pSymbol->pszName, cString.PszValue());

        // Parse parameter value
        chToken = cString.ChParse("\";");

        // Quoted ?
        if ('\"' == chToken)
        {
            // Locals
            CHAR    ch;
            DWORD   dwFlags = PSF_DBCS | PSF_ESCAPED;

            // Lookup the property symbol to see if it exist
            if (FAILED(g_pSymCache->HrOpenSymbol(rName.pszVal, FALSE, &pParameter)))
                pParameter = NULL;

            // For "par:content-disposition:filename" property assume no escaped chars
            if (pParameter && (pParameter->dwPropId == PID_PAR_FILENAME))
                dwFlags &= ~PSF_ESCAPED;

            // Raid-48365: FE-J:OExpress: JIS file name of attachment is not decoded correctly.
            while(1)
            {
                // Parse parameter value
                ch = cString.ChParse('\"', '\"', dwFlags);
                if ('\0' == ch)
                    break;

                // Not a international parameter
                if (pParameter && !ISFLAGSET(pParameter->dwFlags, MPF_INETCSET))
                    break;

                // Skip White Space
                ch = cString.ChSkipWhite();
                if ('\0' == ch || ';' == ch)
                    break;

                // Put a quote back into the string
                CHECKHR(hr = cString.HrAppendValue('\"'));

                // Add PSF_NORESET flag
                FLAGSET(dwFlags, PSF_NORESET);
            }

            // If no value, were done
            if (0 == cString.CchValue())
                goto exit;
        }

        else
            Assert(';' == chToken || '\0' == chToken);

        // Setup Value
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
        rValue.rStringA.cchVal = cString.CchValue();

        // Set the property
        CHECKHR(hr = SetProp(rName.pszVal, PDF_ENCODED, &rValue));

        // If last token was a '"', then seek to semicolon
        if ('\"' == chToken)
        {
            // Parse parameter value
            chToken = cString.ChParse(";");
        }
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInternetAddress
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInternetAddress(LPPROPERTY pProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPMIMEADDRESS   pAddress;
    LPINETCSETINFO  pCharset=NULL;
    CAddressParser  cAdrParse;

    // Invalid Arg
    Assert(pProperty && pProperty->pSymbol && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS) && pProperty->pGroup);

    // Init
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));

    // If the property does not need PRSTATE_NEEDPARSE, return
    if (!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE))
        goto exit;

    // Setup rSource
    rSource.type = MVT_STRINGW;

    // Convert to multibyte
    CHECKHR(hr = HrConvertVariant(pProperty, CVF_NOALLOC, &rSource));

    // Figure out pCharset
    if (pProperty->pCharset)
        pCharset = pProperty->pCharset;
    else if (m_rOptions.pDefaultCharset)
        pCharset = m_rOptions.pDefaultCharset;
    else if (CIntlGlobals::GetDefHeadCset())
        pCharset = CIntlGlobals::GetDefHeadCset();

    // Initialize Parse Structure
    cAdrParse.Init(rSource.rStringW.pszVal, rSource.rStringW.cchVal);

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Append an Address
        CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

        // Set the Address Type
        pAddress->dwAdrType = pProperty->pSymbol->dwAdrType;

        // Store Friendly Name
        CHECKHR(hr = HrSetAddressTokenW(cAdrParse.PszFriendly(), cAdrParse.CchFriendly(), &pAddress->rFriendly));

        // Store Email
        CHECKHR(hr = HrSetAddressTokenW(cAdrParse.PszEmail(), cAdrParse.CchEmail(), &pAddress->rEmail));

        // Save the Address
        pAddress->pCharset = pCharset;
    }

    // No sync needed anymore
    FLAGCLEAR(pProperty->dwState, PRSTATE_NEEDPARSE);

exit:
    // Cleanup
    MimeVariantFree(&rSource);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrStoreVariantValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrStoreVariantValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSource=0;
    LPBYTE          pbSource=NULL;
    LPBYTE         *ppbDest=NULL;
    ULONG          *pcbDest=NULL;
    LPBYTE          pbNewBlob;
    ULONG           cbNewBlob;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Handle Data Type
    switch(pValue->type)
    {
    case MVT_STRINGA:
        // Invalid Arg
        if (ISVALIDSTRINGA(&pValue->rStringA) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set Byte Source
        pbSource = (LPBYTE)pValue->rStringA.pszVal;

        // Set Source Byte Count
        cbSource = pValue->rStringA.cchVal + 1;

        // Set Destination Byte Pointer
        ppbDest = (LPBYTE *)&(pProperty->rValue.rStringA.pszVal);

        // Save Length Now
        pProperty->rValue.rStringA.cchVal = pValue->rStringA.cchVal;
        break;

    case MVT_STRINGW:
        // Invalid Arg
        if (ISVALIDSTRINGW(&pValue->rStringW) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set Byte Source
        pbSource = (LPBYTE)pValue->rStringW.pszVal;

        // Set Source Byte Count
        cbSource = ((pValue->rStringW.cchVal + 1) * sizeof(WCHAR));

        // Set Destination Byte Pointer
        ppbDest = (LPBYTE *)&(pProperty->rValue.rStringW.pszVal);

        // Save Length Now
        pProperty->rValue.rStringW.cchVal = pValue->rStringW.cchVal;
        break;

    case MVT_VARIANT:
        pProperty->rValue.rVariant.vt = pValue->rVariant.vt;
        switch(pValue->rVariant.vt)
        {
        case VT_FILETIME:
            CopyMemory(&pProperty->rValue.rVariant.filetime, &pValue->rVariant.filetime, sizeof(FILETIME));
            pbSource = (LPBYTE)&pValue->rVariant.filetime;
            cbSource = sizeof(pValue->rVariant.filetime);
            break;

        case VT_I4:
            pProperty->rValue.rVariant.lVal = pValue->rVariant.lVal;
            pbSource = (LPBYTE)&pValue->rVariant.lVal;
            cbSource = sizeof(pValue->rVariant.lVal);
            break;

        case VT_UI4:
            pProperty->rValue.rVariant.ulVal = pValue->rVariant.ulVal;
            pbSource = (LPBYTE)&pValue->rVariant.ulVal;
            cbSource = sizeof(pValue->rVariant.ulVal);
            break;

        default:
            Assert(FALSE);
            hr = TrapError(MIME_E_INVALID_VARTYPE);
            goto exit;
        }
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Better have a source
    Assert(cbSource && cbSource);

    // Store the data
    if (cbSource > pProperty->cbAlloc)
    {
        // Fits into static buffer ?
        if (cbSource <= sizeof(pProperty->rgbScratch))
        {
            // If not reallocing...
            if (ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED))
            {
                Assert(pProperty->pbBlob);
                g_pMalloc->Free(pProperty->pbBlob);
                FLAGCLEAR(pProperty->dwState, PRSTATE_ALLOCATED);
            }

            // Use Scratch Buffer
            pProperty->pbBlob = pProperty->rgbScratch;
            pProperty->cbAlloc = sizeof(pProperty->rgbScratch);
        }

        // Was my current buffer allocated
        else
        {
            // If not reallocing...
            if (!ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED))
            {
                pProperty->pbBlob = NULL;
                pProperty->cbAlloc = 0;
            }
            else
                Assert(pProperty->cbAlloc > sizeof(pProperty->rgbScratch) && g_pMalloc->DidAlloc(pProperty->pbBlob) == 1);

            // Compute Size of new blob
            cbNewBlob = pProperty->cbAlloc + (cbSource - pProperty->cbAlloc);

            // Realloc New Blob
            CHECKALLOC(pbNewBlob = (LPBYTE)g_pMalloc->Realloc((LPVOID)pProperty->pbBlob, cbNewBlob));

            // We've allocated it
            FLAGSET(pProperty->dwState, PRSTATE_ALLOCATED);

            // Assume the new blob
            pProperty->pbBlob = pbNewBlob;
            pProperty->cbAlloc = cbNewBlob;
        }
    }

    // Copy the data
    CopyMemory(pProperty->pbBlob, pbSource, cbSource);

    // Set Size of Data in m_pbBlob
    pProperty->cbBlob = cbSource;

    // If there is a ppbDest assign to it
    if (ppbDest)
        *ppbDest = pProperty->pbBlob;

    // Save Encoding Type
    pProperty->ietValue = (ISFLAGSET(dwFlags, PDF_ENCODED)) ? IET_ENCODED : IET_DECODED;

    // PRSTATE_SAVENOENCODE
    if (ISFLAGSET(dwFlags, PDF_SAVENOENCODE))
        FLAGSET(pProperty->dwState, PRSTATE_SAVENOENCODE);

    // Save Type
    pProperty->rValue.type = pValue->type;

exit:
    // Failure
    if (FAILED(hr))
        ZeroMemory(&pProperty->rValue, sizeof(MIMEVARIANT));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPCSTR pszName, LPSTR *ppszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName && ppszData);

    // Init
    *ppszData = NULL;

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Init the variant
    rValue.type = MVT_STRINGA;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringA.pszVal);
    *ppszData = rValue.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPPROPSYMBOL pSymbol, LPSTR *ppszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && ppszData);

    // Init
    *ppszData = NULL;

    // Init the variant
    rValue.type = MVT_STRINGA;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringA.pszVal);
    *ppszData = rValue.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetPropW
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetPropW(LPPROPSYMBOL pSymbol, LPWSTR *ppwszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && ppwszData);

    // Init
    *ppwszData = NULL;

    // Init the variant
    rValue.type = MVT_STRINGW;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringW.pszVal);
    *ppwszData = rValue.rStringW.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invaid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Symbol Better have a supported variant type
    Assert(ISSUPPORTEDVT(pSymbol->vtDefault));

    // Set rValue Variant
    if (VT_EMPTY == pVariant->vt)
        rValue.rVariant.vt = pVariant->vt = pSymbol->vtDefault;
    else
        rValue.rVariant.vt = pVariant->vt;

    // Map to MIMEVARIANT
    if (VT_LPSTR == pVariant->vt || VT_EMPTY == pVariant->vt)
        rValue.type = MVT_STRINGA;
    else if (VT_LPWSTR == pVariant->vt)
        rValue.type = MVT_STRINGW;
    else
        rValue.type = MVT_VARIANT;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, dwFlags, &rValue));

    // Map to PROPVARIANT
    if (MVT_STRINGA == rValue.type)
        pVariant->pszVal = rValue.rStringA.pszVal;
    else if (MVT_STRINGW == rValue.type)
        pVariant->pwszVal = rValue.rStringW.pszVal;
    else
        CopyMemory(pVariant, &rValue.rVariant, sizeof(PROPVARIANT));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the property
    hr = _HrFindProperty(pSymbol, &pProperty);

    // Failure
    if (FAILED(hr))
    {
        // See if there is a default value for this property
        if (MIME_E_NOT_FOUND != hr)
        {
            hr = TrapError(hr);
            goto exit;
        }

        // Dispatch Default Request, otherwise, hr is still equal to MIME_E_NOT_FOUND....
        if (ISTRIGGERED(pSymbol, IST_GETDEFAULT))
        {
            // Property Dispatch
            CHECKHR(hr = _HrCallSymbolTrigger(pSymbol, IST_GETDEFAULT, dwFlags, pValue));
        }
    }

    // Otherwise, get the property data
    else
    {
        // Raid-62460: Dependency Hack to make sure the GetProp works the same when getting addresses
        // PDF_VECTOR is always supported by _HrBuildAddressString, which gets called by _HrGetPropertyValue
        if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
            FLAGSET(dwFlags, PDF_VECTOR);

        // Get the property value
        CHECKHR(hr = _HrGetPropertyValue(pProperty, dwFlags, pValue));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName && pValue);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, dwFlags, pValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, LPCSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pszName && pszData);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // Init the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszData;
    rValue.rStringA.cchVal = lstrlen(pszData);

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, 0, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPPROPSYMBOL pSymbol, LPCSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && pszData);

    // Init the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszData;
    rValue.rStringA.cchVal = lstrlen(pszData);

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, 0, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // MVT_STRINGW
    if (VT_LPSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Setup rValue
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = pVariant->pszVal;
        rValue.rStringA.cchVal = lstrlen(pVariant->pszVal);
    }

    // MVT_STRINGW
    else if (VT_LPWSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pwszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGW;
        rValue.rStringW.pszVal = pVariant->pwszVal;
        rValue.rStringW.cchVal = lstrlenW(pVariant->pwszVal);
    }

    // MVT_VARIANT
    else
    {
        rValue.type = MVT_VARIANT;
        CopyMemory(&rValue.rVariant, pVariant, sizeof(PROPVARIANT));
    }

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, dwFlags, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty=NULL;

    // Invalid Arg
    Assert(pSymbol && pValue);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read-Only
    if (ISFLAGSET(pSymbol->dwFlags, MPF_READONLY))
    {
        AssertSz(FALSE, "This property has the MPF_READONLY flag.");
        hr = TrapError(MIME_E_READ_ONLY);
        goto exit;
    }

    // Find the property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        // Create it
        CHECKHR(hr = _HrCreateProperty(pSymbol, &pProperty));
    }

    // This better be a root property
    Assert(ISFLAGSET(pProperty->dwState, PRSTATE_PARENT));

    // Remove multi-values
    if (pProperty->pNextValue)
    {
        // Free the chain
        _FreePropertyChain(pProperty->pNextValue);

        // No more pNextValue or pTailValue
        pProperty->pNextValue = pProperty->pTailValue = NULL;
    }

    // Store the data
    CHECKHR(hr = _HrSetPropertyValue(pProperty, dwFlags, pValue, FALSE));

    // Dirty
    if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
        FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Failure
    if (FAILED(hr) && pProperty)
    {
        // Delete the Property
        _UnlinkProperty(pProperty);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // MVT_STRINGW
    if (VT_LPSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = pVariant->pszVal;
        rValue.rStringA.cchVal = lstrlen(pVariant->pszVal);
    }

    // MVT_STRINGW
    else if (VT_LPWSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pwszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGW;
        rValue.rStringW.pszVal = pVariant->pwszVal;
        rValue.rStringW.cchVal = lstrlenW(pVariant->pwszVal);
    }

    // MVT_VARIANT
    else
    {
        rValue.type = MVT_VARIANT;
        CopyMemory(&rValue.rVariant, pVariant, sizeof(PROPVARIANT));
    }

    // Get Property by Symbol
    CHECKHR(hr = AppendProp(pSymbol, dwFlags, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::AppendProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty=NULL;
    BOOL        fAppended=FALSE;

    // Invalid Arg
    Assert(pSymbol && pValue);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read-Only
    if (ISFLAGSET(pSymbol->dwFlags, MPF_READONLY))
    {
        AssertSz(FALSE, "This property has the MPF_READONLY flag.");
        hr = TrapError(MIME_E_READ_ONLY);
        goto exit;
    }

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        // If not found... treat as basic set prop...
        CHECKHR(hr = SetProp(pSymbol, dwFlags, pValue));
    }

    // Otherwise, of not multiline, fail
    else
    {
        // Its appended
        fAppended = TRUE;

        // Append a property
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Store the data
        CHECKHR(hr = _HrSetPropertyValue(pProperty, dwFlags, pValue, FALSE));

        // I am now dirty
        if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
            FLAGSET(m_dwState, COSTATE_DIRTY);
    }

exit:
    // Failure
    if (FAILED(hr) && pProperty && fAppended)
    {
        // Delete the Property
        _UnlinkProperty(pProperty);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkProperty
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkProperty(LPPROPERTY pProperty, LPPROPERTY *ppNextHash)
{
    // Locals
    LPPROPERTY  pCurrHash;
    LPPROPERTY  pNextHash;
    LPPROPERTY  pPrevHash=NULL;
#ifdef DEBUG
    BOOL        fUnlinked=FALSE;
#endif

    // Invalid Arg
    Assert(pProperty && pProperty->pSymbol && ISFLAGSET(pProperty->dwState, PRSTATE_PARENT) && pProperty->pSymbol->wHashIndex < CBUCKETS);

    // Remove from array
    if (ISKNOWNPID(pProperty->pSymbol->dwPropId))
        m_prgIndex[pProperty->pSymbol->dwPropId] = NULL;

    // Include Parameters
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
        _DeleteLinkedParameters(pProperty);

    // Remove Property from the hash table
    for (pCurrHash=m_prgHashTable[pProperty->pSymbol->wHashIndex]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
    {
        // Is this pProp
        if (pCurrHash == pProperty)
        {
            // NextHash
            pNextHash = pCurrHash->pNextHash;

            // Set Previous
            if (pPrevHash)
                pPrevHash->pNextHash = pNextHash;
            else
                m_prgHashTable[pProperty->pSymbol->wHashIndex] = pNextHash;

            // Free pCurrHash
            _FreePropertyChain(pCurrHash);

            // Set this after I set pCurr in case *ppNextHash is &pProperty
            if (ppNextHash)
                *ppNextHash = pNextHash;

            // One less property
            m_cProps--;

#ifdef DEBUG
            fUnlinked = TRUE;
#endif
            // Done
            break;
        }

        // Set Previous
        pPrevHash = pCurrHash;
    }

    // We better have found it
    Assert(fUnlinked);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteProp(LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Delete by symbol
    CHECKHR(hr = DeleteProp(pSymbol));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteProp(LPPROPSYMBOL pSymbol)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    Assert(pSymbol);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // Delete Prop
    _UnlinkProperty(pProperty);

    // Cascade Delete Dispatch
    if (ISTRIGGERED(pSymbol, IST_DELETEPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pSymbol, IST_DELETEPROP, 0, NULL));
    }

    // Dirty
    if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
        FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_DeleteLinkedParameters
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_DeleteLinkedParameters(LPPROPERTY pProperty)
{
    // Locals
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;

    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Raid-13506 - Basically PID_ATT_FILENAME doesn't get removed when all other associated props are gone.
        if (ISTRIGGERED(pParameter->pSymbol, IST_DELETEPROP))
        {
            // Call the Trigger
            _HrCallSymbolTrigger(pParameter->pSymbol, IST_DELETEPROP, 0, NULL);
        }

        // Remove the parameter
        _UnlinkProperty(pParameter, &rFind.pProperty);

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FExcept
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FExcept(LPPROPSYMBOL pSymbol, ULONG cNames, LPCSTR *prgszName)
{
    // Verify the array
    for (ULONG i=0; i<cNames; i++)
    {
        // By PID
        if (ISPIDSTR(prgszName[i]))
        {
            // Compare by id
            if (pSymbol->dwPropId == STRTOPID(prgszName[i]))
                return TRUE;

            // Else if pSymbol is linked to prgszName[i]
            else if (pSymbol->pLink && pSymbol->pLink->dwPropId == STRTOPID(prgszName[i]))
                return TRUE;
        }

        // Otherwise, by name
        else
        {
            // Compare by name
            if (lstrcmpi(pSymbol->pszName, prgszName[i]) == 0)
                return TRUE;

            // Otherwise if pSymbol is linked to prgszName[i]
            else if (pSymbol->pLink && lstrcmpi(pSymbol->pLink->pszName, prgszName[i]) == 0)
                return TRUE;
        }
    }

    // Not Except
    return FALSE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteExcept
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteExcept(ULONG cNames, LPCSTR *prgszName)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;
    ULONG       i;

    // Invalid Arg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Delete Everything
    if (0 == cNames)
    {
        // Free the PropTable
        _FreeHashTableElements();
    }

    // Otherwise
    else
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Walk through the chain...
            pProperty = m_prgHashTable[i];
            while(pProperty)
            {
                // Loop through the tags
                if (!_FExcept(pProperty->pSymbol, cNames, prgszName))
                    _UnlinkProperty(pProperty, &pProperty);
                else
                    pProperty = pProperty->pNextHash;
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Get Property by Symbol
    CHECKHR(hr = QueryProp(pSymbol, pszCriteria, fSubString, fCaseSensitive));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryProp(LPPROPSYMBOL pSymbol, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty,
                    pCurrProp;
    LPCSTR          pszSearch;
    MIMEVARIANT     rValue;

    // Parameters
    if (NULL == pSymbol || NULL == pszCriteria)
        return TrapError(E_INVALIDARG);

    // Init
    STACKSTRING_DEFINE(rCritLower, 255);
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // Init pszsearch
    pszSearch = pszCriteria;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Need Lower Case...?
    if (TRUE == fSubString && FALSE == fCaseSensitive)
    {
        // Get Length
        ULONG cchCriteria = lstrlen(pszCriteria);

        // Get the length of pszCritieria
        STACKSTRING_SETSIZE(rCritLower, cchCriteria + 1);

        // Copy It
        CopyMemory(rCritLower.pszVal, pszCriteria, cchCriteria + 1);

        // Lower Case...
        CharLower(rCritLower.pszVal);

        // Set Search
        pszSearch = rCritLower.pszVal;
    }

    // Walk multiline properties...
    for (pCurrProp=pProperty; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextValue)
    {
        // Better have the same symbol
        Assert(pCurrProp->pSymbol == pSymbol);

        // If Address...
        if (ISFLAGSET(pCurrProp->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Better have an address group
            Assert(pCurrProp->pGroup);

            // Search the address group
            if (_HrQueryAddressGroup(pCurrProp, pszSearch, fSubString, fCaseSensitive) == S_OK)
                goto exit;
        }

        // Otherwise
        else
        {
            // Convert to a MVT_STRINGA
            rValue.type = MVT_STRINGA;

            // Convert to string
            CHECKHR(hr = HrConvertVariant(pCurrProp, CVF_NOALLOC, &rValue));

            // Query String
            if (MimeOleQueryString(rValue.rStringA.pszVal, pszSearch, fSubString, fCaseSensitive) == S_OK)
                goto exit;

            // Cleanup
            MimeVariantFree(&rValue);
        }
    }

    // Not Equal
    hr = S_FALSE;

exit:
    // Cleanup
    STACKSTRING_FREE(rCritLower);
    MimeVariantFree(&rValue);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetCharset
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetCharset(LPHCHARSET phCharset)
{
    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Charset...
    Assert(m_rOptions.pDefaultCharset);

    // Return
    *phCharset = m_rOptions.pDefaultCharset->hCharset;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetCharset
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;
    LPCODEPAGEINFO  pCodePage;
    MIMEVARIANT     rValue;
    LPINETCSETINFO  pCset;
    LPPROPERTY      pProperty;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IE v. 5.0 37562 multiple charsets are ignored on inbound message
    // if we are already tagged and called with CSET_APPLY_UNTAGGED then don't overwrite
    // the existing charset.
    if(CSET_APPLY_UNTAGGED == applytype && ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        goto exit;

    // Lookiup Charset Info
    CHECKHR(hr = g_pInternat->HrOpenCharset(hCharset, &pCharset));

#ifdef OLD // See attachemnt to bug 40626

    // RAID-22767 - FE-H : Athena Mail: Header should be encoded to the "EUC-KR" for the Korean
    if (SUCCEEDED(g_pInternat->HrFindCodePage(pCharset->cpiInternet, &pCodePage)) && pCodePage->dwMask & ILM_HEADERCSET)
    {
        // Map New Charset...
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pCodePage->szHeaderCset, &pCset)))
        {

            // Example: When hCharset == ISO-2022-KR, we map to EUC-KR == hHeaderCset, and we use that as
            //          the header of the message, but we set param charset=iso-2022-kr and encode the body
            //          using iso-2022-kr. This is why rCsetInfo contains iso-2022-kr and not euc-kr.
            pCharset = pCset;
        }
    }
#else // !OLD
    // We always use now WebCharSet (see attachment message to bug 40626
    if (SUCCEEDED(g_pInternat->HrFindCodePage(pCharset->cpiInternet, &pCodePage)) && pCodePage->dwMask & ILM_WEBCSET)
    {
        // Map New Charset...
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pCodePage->szWebCset, &pCset)))
            pCharset = pCset;
    }
#endif // OLD

    // Setup a variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = pCharset->szName;
    rValue.rStringA.cchVal = lstrlen(pCharset->szName);

    // Set the Charset Attribute
    SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, 0, &rValue)));

    // Return
    m_rOptions.pDefaultCharset = pCharset;

    // Remove any specific charset information on each property
    if (CSET_APPLY_ALL == applytype && m_cProps > 0)
    {
        // Locals
        LPPROPERTY      pCurrHash;
        LPPROPERTY      pCurrValue;

        // Loop through the item table
        for (ULONG i=0; i<CBUCKETS; i++)
        {
            // Walk the hash list
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Walk the multi-value chain
                for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
                {
                    // This will force it to use the default
                    pCurrValue->pCharset = NULL;
                }
            }
        }
    }

    // Raid-38725: FE: Selecting EUC does not immediately change the encoding of sender name in preview pane
    //
    // $$HACKHACK$$ - This block of code is a hack because it only works if an address group has been parsed
    //                and not modified. Only in this case, will the new charset be applied to the addresses.
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // If the property has been parsed into addresses
        if (!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE))
        {
            // We should have an address group
            Assert(pProperty->pGroup);

            // If we have an address group and its dirty
            if (pProperty->pGroup && FALSE == pProperty->pGroup->fDirty)
            {
                // Free the curent list of parsed addresses
                _FreeAddressChain(pProperty->pGroup);

                // Not Dirty
                pProperty->pGroup->fDirty = FALSE;

                // Reset the parsing flag
                FLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE);
            }
        }
    }

    // Tag It ?
    if (CSET_APPLY_TAG_ALL == applytype)
    {
        // Mark as being tagged
        FLAGSET(m_dwState, COSTATE_CSETTAGGED);
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    FINDPROPERTY    rFind;
    LPMIMEPARAMINFO prgParam=NULL;
    ULONG           cParams=0,
                    cAlloc=0;
    LPSTR           pszParamName;
    LPPROPERTY      pParameter;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pSymbol;

    // Parameters
    if (NULL == pszName || NULL == pcParams || NULL == pprgParam)
        return TrapError(E_INVALIDARG);

    // Init
    *pcParams = 0;
    *pprgParam = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find Symbol from pszName
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pSymbol->pszName;
    rFind.cchName = pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Grow my array
        if (cParams + 1 >= cAlloc)
        {
            // Realloc
            CHECKHR(hr = HrRealloc((LPVOID *)&prgParam, sizeof(MIMEPARAMINFO) * (cAlloc + 5)));

            // Inc cAlloc
            cAlloc+=5;
        }

        // Get Parameter Name
        pszParamName = PszScanToCharA((LPSTR)pParameter->pSymbol->pszName, ':');
        pszParamName++;
        pszParamName = PszScanToCharA(pszParamName, ':');
        pszParamName++;

        // Copy Name
        CHECKALLOC(prgParam[cParams].pszName = PszDupA(pszParamName));

        // Copy Data
        rValue.type = MVT_STRINGA;
        CHECKHR(hr = GetProp(pParameter->pSymbol, 0, &rValue));

        // Save this
        prgParam[cParams].pszData = rValue.rStringA.pszVal;

        // Increment cParams
        cParams++;

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

    // Return it
    *pcParams = cParams;
    *pprgParam = prgParam;

exit:
    // Failure...
    if (FAILED(hr) && prgParam)
        g_pMoleAlloc->FreeParamInfoArray(cParams, prgParam, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#ifndef WIN16

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrResolveURL
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrResolveURL(LPRESOLVEURLINFO pURL)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszTemp=NULL;
    LPSTR           pszBase=NULL;
    LPSTR           pszContentID=NULL;
    LPSTR           pszLocation=NULL;
    LPSTR           pszAbsURL1=NULL;
    LPSTR           pszAbsURL2=NULL;
    LPSTR           pszT=NULL;
    ULONG           cch;

    // Invalid Arg
    Assert(pURL);

    // Init Stack Strings
    STACKSTRING_DEFINE(rCleanCID, 255);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Content-Location
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTLOC, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszLocation, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszLocation, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Content-ID
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTID, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszContentID, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszContentID, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Content-Base
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTBASE, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszBase, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszBase, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Both Null, no match
    if (!pszLocation && !pszContentID)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // If URL is a CID
    if (TRUE == pURL->fIsCID)
    {
        // Locals
        ULONG cb;
        
        if(pszLocation)
        {
            // Match char for char
            if (MimeOleCompareUrl(pszLocation, TRUE, pURL->pszURL, FALSE) == S_OK)
                goto exit;            
        }

        if(pszContentID)
        {
            // Match char for char minus cid:
            if (MimeOleCompareUrlSimple(pURL->pszURL, pszContentID) == S_OK)
                goto exit;

            // Dup the string
            CHECKALLOC(pszT = PszDupA(pURL->pszURL));

            // Strip leading and trailing whitespace
            cb = lstrlen(pszT);
            UlStripWhitespace(pszT, TRUE, TRUE, &cb);

            // Get Stack Stream Read for
            STACKSTRING_SETSIZE(rCleanCID, cb + 4);

            // Format the string
            wnsprintf(rCleanCID.pszVal, (cb + 4), "<%s>", pszT);

            // Match char for char minus cid:
            if (MimeOleCompareUrlSimple(rCleanCID.pszVal, pszContentID) == S_OK)
                goto exit;
        }
    }

    // Otherwise, non-CID resolution
    else if (pszLocation)
    {
        // Raid-62579: Athena: Need to support MHTML content-base inheritance
        if (NULL == pszBase && pURL->pszInheritBase)
        {
            // Jimmy up a fake base
            pszBase = StrDupA(pURL->pszInheritBase);
        }

        // Part Has Base
        if (NULL != pszBase)
        {
            // Combine URLs
            CHECKHR(hr = MimeOleCombineURL(pszBase, lstrlen(pszBase), pszLocation, lstrlen(pszLocation), TRUE, &pszAbsURL1));

            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrlSimple(pURL->pszURL, pszAbsURL1) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrlSimple(pszAbsURL1, pszAbsURL2) == S_OK)
                    goto exit;
            }
        }

        // Part has no base
        else
        {
            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrl(pszLocation, TRUE, pURL->pszURL, FALSE) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrl(pszLocation, TRUE, pszAbsURL2, FALSE) == S_OK)
                    goto exit;
            }
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Cleanup
    STACKSTRING_FREE(rCleanCID);
    MemFree(pszBase);
    MemFree(pszContentID);
    MemFree(pszLocation);
    MemFree(pszAbsURL1);
    MemFree(pszAbsURL2);
    MemFree(pszT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentType
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT hr=S_OK;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && lstrcmpi(pszPriType, STR_CNT_TEXT) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Comparing pszPriType
        if (pszPriType && lstrcmpi(pszPriType, pCntType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Comparing pszSubType
        if (pszSubType && lstrcmpi(pszSubType, pSubType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentTypeW
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentTypeW(LPCWSTR pszPriType, LPCWSTR pszSubType)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszT1=NULL;
    LPWSTR      pszT2=NULL;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && StrCmpIW(pszPriType, L"text") != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && StrCmpIW(pszSubType, L"plain") != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Compare pszPriType
        if (pszPriType)
        {
            // To Unicode
            IF_NULLEXIT(pszT1 = PszToUnicode(CP_ACP, pCntType->rValue.rStringA.pszVal));

            // Compare
            if (StrCmpIW(pszPriType, pszT1) != 0)
            {
                hr = S_FALSE;
                goto exit;
            }
        }

        // Compare pszSubType
        if (pszSubType)
        {
            // To Unicode
            IF_NULLEXIT(pszT2 = PszToUnicode(CP_ACP, pSubType->rValue.rStringA.pszVal));

            // Comparing pszSubType
            if (StrCmpIW(pszSubType, pszT2) != 0)
            {
                hr = S_FALSE;
                goto exit;
            }
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    MemFree(pszT1);
    MemFree(pszT2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimePropertySet, (LPVOID *)ppPropertySet));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(LPCONTAINER *ppContainer)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCONTAINER         pContainer=NULL;

    // Invalid ARg
    if (NULL == ppContainer)
        return TrapError(E_INVALIDARG);

    // Init
    *ppContainer = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Create new container, NULL == no outer property set
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init that new container
    CHECKHR(hr = pContainer->InitNew());

    // Interate the Properties
    CHECKHR(hr = _HrClonePropertiesTo(pContainer));

    // If I have a stream, give it to the new table
    if (m_pStmLock)
    {
        // Just pass m_pStmLock into pTable
        pContainer->m_pStmLock = m_pStmLock;
        pContainer->m_pStmLock->AddRef();
        pContainer->m_cbStart = m_cbStart;
        pContainer->m_cbSize = m_cbSize;
    }

    // Give it my state
    pContainer->m_dwState = m_dwState;

    // Give it my options
    pContainer->m_rOptions.pDefaultCharset = m_rOptions.pDefaultCharset;
    pContainer->m_rOptions.cbMaxLine = m_rOptions.cbMaxLine;
    pContainer->m_rOptions.fAllow8bit = m_rOptions.fAllow8bit;

    // Return Clone
    (*ppContainer) = pContainer;
    (*ppContainer)->AddRef();

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrClonePropertiesTo
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrClonePropertiesTo(LPCONTAINER pContainer)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pCurrHash, pCurrValue, pDestProp;

    // Invalid Arg
    Assert(pContainer);

    // Loop through the item table
    for (ULONG i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
        {
            // Walk multiple Values
            for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
            {
                // Linked Attributes are Not Copied
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ATTRIBUTE) && NULL != pCurrValue->pSymbol->pLink)
                    continue;

                // Does the Property need to be parsed ?
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
                {
                    // Make sure the address is parsed
                    CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
                }

                // Insert Copy of pCurrValue into pContiner
                CHECKHR(hr = pContainer->HrInsertCopy(pCurrValue, FALSE));
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest, BOOL fFromMovePropos)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pCurrValue;

    // Walk multiple Values
    for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
    {
        // Does the Property need to be parsed ?
        if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Make sure the address is parsed
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
        }

        // Insert pProperty into pDest
        CHECKHR(hr = pDest->HrInsertCopy(pCurrValue, fFromMovePropos));
    }

    // If pCurrHash has Parameters, copy those over as well
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Copy Parameters
        CHECKHR(hr = _HrCopyParameters(pProperty, pDest));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;

    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Remove the parameter
        CHECKHR(hr = pDest->HrInsertCopy(pParameter, FALSE));

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrInsertCopy
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrInsertCopy(LPPROPERTY pSource, BOOL fFromMovePropos)
{
    // Locals
    HRESULT           hr=S_OK;
    LPPROPERTY        pDest;
    LPMIMEADDRESS    pAddress;
    LPMIMEADDRESS    pNew;

    // Invalid Arg
    Assert(pSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Append a new property to the
    CHECKHR(hr = _HrAppendProperty(pSource->pSymbol, &pDest));

    // If this is an address...
    if (ISFLAGSET(pSource->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Both Address Group Better Exist
        Assert(pSource->pGroup && pDest->pGroup && !ISFLAGSET(pSource->dwState, PRSTATE_NEEDPARSE));

        // Loop Infos...
        for (pAddress=pSource->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Append pDest->pGroup
            CHECKHR(hr = _HrAppendAddressGroup(pDest->pGroup, &pNew));

            // Copy Current to New
            CHECKHR(hr = HrMimeAddressCopy(pAddress, pNew));
        }
    }

    // Otheriwse, just set the variant data on pDest
    else
    {
        // Set It
        CHECKHR(hr = _HrSetPropertyValue(pDest, ((pSource->ietValue == IET_ENCODED) ? PDF_ENCODED : 0), &pSource->rValue, fFromMovePropos));
    }

    // Copy the State
    pDest->dwState = pSource->dwState;
    pDest->dwRowNumber = pSource->dwRowNumber;
    pDest->cboffStart = pSource->cboffStart;
    pDest->cboffColon = pSource->cboffColon;
    pDest->cboffEnd = pSource->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CopyProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty,
                    pCurrValue,
                    pCurrHash,
                    pNextHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Raid-62016: CDO: Bodypart promotion causes loss of charset
    // Delete All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);
                }
            }
        }
    }

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest, FALSE));
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest, FALSE));
                }
            }
        }
    }

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::MoveProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurrHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Raid-62016: CDO: Bodypart promotion causes loss of charset
    // Delete Properties in the Destination First
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);
            }
        }
    }

    // Otherwise, selective delete
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);
                }
            }
        }
    }

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            pCurrHash = m_prgHashTable[i];

            // Walk the Hash Chain
            while(pCurrHash)
            {
                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest, TRUE));

                // Delete pProperty
                _UnlinkProperty(pCurrHash, &pCurrHash);
            }
        }
    }

    // Otherwise, selective move
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest, FALSE));

                    // Delete pProperty
                    _UnlinkProperty(pProperty);
                }
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetOption(const TYPEDID oid, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        if (pVariant->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        if (m_rOptions.fNoDefCntType != (pVariant->boolVal ? TRUE : FALSE))
            m_rOptions.fNoDefCntType = pVariant->boolVal ? TRUE : FALSE;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bit != (pVariant->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.fAllow8bit = pVariant->boolVal ? TRUE : FALSE;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        if (pVariant->ulVal < MIN_CBMAX_HEADER_LINE || pVariant->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.cbMaxLine = pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pVariant->ulVal && SAVE_RFC1521 != pVariant->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetOption(const TYPEDID oid, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    pVariant->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        pVariant->ulVal = m_rOptions.ReloadType;
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        pVariant->boolVal = (VARIANT_BOOL) !!m_rOptions.fNoDefCntType;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        pVariant->boolVal = (VARIANT_BOOL) !!m_rOptions.fAllow8bit;
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        pVariant->ulVal = m_rOptions.cbMaxLine;
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        pVariant->ulVal = (ULONG)m_rOptions.savetype;
        break;

    // -----------------------------------------------------------------------
    default:
        pVariant->vt = VT_NULL;
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetMessageFlags
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetMessageFlags(BOOL fHideTnef)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPCSTR pszPriType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_PRITYPE], STR_CNT_TEXT);
    LPCSTR pszSubType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_SUBTYPE], STR_SUB_PLAIN);
    LPCSTR pszCntDisp = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDISP], STR_DIS_INLINE);

    // Mime
    if (m_prgIndex[PID_HDR_MIMEVER])
        FLAGSET(dwFlags, IMF_MIME);

    // VoiceMail
    if (S_OK == IsPropSet(STR_HDR_XVOICEMAIL))
        FLAGSET(dwFlags, IMF_VOICEMAIL);

    // IMF_NEWS
    if (m_prgIndex[PID_HDR_XNEWSRDR]  || m_prgIndex[PID_HDR_NEWSGROUPS] || m_prgIndex[PID_HDR_NEWSGROUP] || m_prgIndex[PID_HDR_PATH])
        FLAGSET(dwFlags, IMF_NEWS);

    // text
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
    {
        // There is text
        FLAGSET(dwFlags, IMF_TEXT);

        // text/plain
        if (lstrcmpi(pszSubType, STR_SUB_PLAIN) == 0)
            FLAGSET(dwFlags, IMF_PLAIN);

        // text/html
        else if (lstrcmpi(pszSubType, STR_SUB_HTML) == 0)
            FLAGSET(dwFlags, IMF_HTML);

        // text/enriched = text/html
        else if (lstrcmpi(pszSubType, STR_SUB_ENRICHED) == 0)
            FLAGSET(dwFlags, IMF_HTML);

        // text/v-card
        else if (lstrcmpi(pszSubType, STR_SUB_VCARD) == 0)
            FLAGSET(dwFlags, IMF_HASVCARD);
    }

    // multipart
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
    {
        // Multipart
        FLAGSET(dwFlags, IMF_MULTIPART);

        // multipart/related
        if (lstrcmpi(pszSubType, STR_SUB_RELATED) == 0)
            FLAGSET(dwFlags, IMF_MHTML);

        // multipart/signed
        else if (0 == lstrcmpi(pszSubType, STR_SUB_SIGNED))
            if (IsSMimeProtocol(this))
                FLAGSET(dwFlags, IMF_SIGNED | IMF_SECURE);
    }

    // message/partial
    else if (lstrcmpi(pszPriType, STR_CNT_MESSAGE) == 0 && lstrcmpi(pszSubType, STR_SUB_PARTIAL) == 0)
        FLAGSET(dwFlags, IMF_PARTIAL);

    // application
    else if (lstrcmpi(pszPriType, STR_CNT_APPLICATION) == 0)
    {
        // application/ms-tnef
        if (0 == lstrcmpi(pszSubType, STR_SUB_MSTNEF))
            FLAGSET(dwFlags, IMF_TNEF);

        // application/x-pkcs7-mime
        else if (0 == lstrcmpi(pszSubType, STR_SUB_XPKCS7MIME) ||
            0 == lstrcmpi(pszSubType, STR_SUB_PKCS7MIME))  // nonstandard
            FLAGSET(dwFlags, IMF_SECURE);
    }

    // Raid-37086 - Cset Tagged
    if (ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        FLAGSET(dwFlags, IMF_CSETTAGGED);

    // Attachment...
    if (!ISFLAGSET(dwFlags, IMF_MULTIPART) && (FALSE == fHideTnef || !ISFLAGSET(dwFlags, IMF_TNEF)))
    {
        // Marked as an attachment ?
        if (!ISFLAGSET(dwFlags, IMF_HASVCARD) && 
            !ISFLAGSET(dwFlags, IMF_SECURE) && 
            0 != lstrcmpi(pszSubType, STR_SUB_PKCS7SIG) &&
            0 != lstrcmpi(pszSubType, STR_SUB_XPKCS7SIG)) // Raid-1960
        {
            // Not Rendered Yet
            if (NULL == m_prgIndex[PID_ATT_RENDERED] || 0 == m_prgIndex[PID_ATT_RENDERED]->rValue.rVariant.ulVal)
            {
                // Marked as an Attachment
                if (lstrcmpi(pszCntDisp, STR_DIS_ATTACHMENT) == 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Type: xxx; name=xxx
                else if (NULL != m_prgIndex[PID_PAR_NAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Disposition: xxx; filename=xxx
                else if (NULL != m_prgIndex[PID_PAR_FILENAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Else if it is not marked as text
                else if (ISFLAGSET(dwFlags, IMF_TEXT) == FALSE)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // If not text/plain and not text/html
                else if (lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0 && lstrcmpi(pszSubType, STR_SUB_HTML) != 0 && lstrcmpi(pszSubType, STR_SUB_ENRICHED) != 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetEncodingType
// --------------------------------------------------------------------------------
ENCODINGTYPE CMimePropertyContainer::GetEncodingType(void)
{
    // Locals
    ENCODINGTYPE ietEncoding=IET_7BIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPPROPERTY pCntXfer = m_prgIndex[PID_HDR_CNTXFER];

    // Do we have data the I like ?
    if (pCntXfer && ISSTRINGA(&pCntXfer->rValue))
    {
        // Local
        CStringParser cString;

        // cString...
        cString.Init(pCntXfer->rValue.rStringA.pszVal, pCntXfer->rValue.rStringA.cchVal, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS);

        // Parse to end, remove white space and comments
        SideAssert('\0' == cString.ChParse(""));

        // Loop the table
        for (ULONG i=0; i<ARRAYSIZE(g_rgEncoding); i++)
        {
            // Match Encoding Strings
            if (lstrcmpi(g_rgEncoding[i].pszEncoding, cString.PszValue()) == 0)
            {
                ietEncoding = g_rgEncoding[i].ietEncoding;
                break;
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return ietEncoding;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetInlineSymbol
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szHeader[255];
    LPSTR       pszHeader=NULL;

    // Invalid Arg
    Assert(pszData && ppSymbol);

    // _HrParseInlineHeaderName
    CHECKHR(hr = _HrParseInlineHeaderName(pszData, szHeader, sizeof(szHeader), &pszHeader, pcboffColon));

    // Find Global Property
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, ppSymbol));

exit:
    // Cleanup
    if (pszHeader != szHeader)
        SafeMemFree(pszHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInlineHeaderName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch,
    LPSTR *ppszHeader, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=(LPSTR)pszData,
                pszStart;
    ULONG       i=0;

    // Invalid Arg
    Assert(pszData && pszScratch && ppszHeader && pcboffColon);

    // Lets Parse the name out and find the symbol
    while (*psz && (' ' == *psz || '\t' == *psz))
    {
        i++;
        psz++;
    }

    // Done
    if ('\0' == *psz)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Seek to the colon
    pszStart = psz;
    while (*psz && ':' != *psz)
    {
        i++;
        psz++;
    }

    // Set Colon Position
    (*pcboffColon) = i;

    // Done
    if ('\0' == *psz || 0 == i)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Copy the name
    if (i + 1 <= cchScratch)
        *ppszHeader = pszScratch;

    // Otherwise, allocate
    else
    {
        // Allocate space for the name
        *ppszHeader = PszAllocA(i + 1);
        if (NULL == *ppszHeader)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Copy the data
    CopyMemory(*ppszHeader, pszStart, i);

    // Null
    *((*ppszHeader) + i) = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindFirstRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Invalid Arg
    if (NULL == pFindHeader)
        return TrapError(E_INVALIDARG);

    // Init pFindHeader
    pFindHeader->dwReserved = 0;

    // FindNext
    return FindNextRow(pFindHeader, phRow);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindNextRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pFindHeader || NULL == phRow)
        return TrapError(E_INVALIDARG);

    // Init
    *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=pFindHeader->dwReserved; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pFindHeader->pszHeader || lstrcmpi(pRow->pSymbol->pszName, pFindHeader->pszHeader) == 0)
        {
            // Save Index of next item to search
            pFindHeader->dwReserved = i + 1;

            // Return the handle
            *phRow = pRow->hRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    pFindHeader->dwReserved = m_rHdrTable.cRows;
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CountRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountRows(LPCSTR pszHeader, ULONG *pcRows)
{
    // Locals
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Init
    *pcRows = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=0; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pszHeader || lstrcmpi(pRow->pSymbol->pszName, pszHeader) == 0)
            (*pcRows)++;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData,
    LPHHEADERROW phRow)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    ULONG           cboffColon;
    LPPROPERTY      pProperty;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Init
    if (phRow)
        *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a header, lookup the symbol
    if (pszHeader)
    {
        // HTF_NAMEINDATA better not be set
        Assert(!ISFLAGSET(dwFlags, HTF_NAMEINDATA));

        // Lookup the symbol
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, &pSymbol));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Set the Data on this row
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData, cchData));
    }

    // Otherwise...
    else if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // GetInlineSymbol
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Remove IHF_NAMELINE
        FLAGCLEAR(dwFlags, HTF_NAMEINDATA);

        // Set the Data on this row
        Assert(cboffColon + 1 < cchData);
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData + cboffColon + 1, cchData - cboffColon - 1));
    }

    // Otherwise, failed
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Return phRow
    if (phRow && pProperty)
        *phRow = pProperty->hRow;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteRow(HHEADERROW hRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Standard Delete Prop
    CHECKHR(hr = DeleteProp(pRow->pSymbol));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchData=0;
    LPPROPERTY  pRow;
    MIMEVARIANT rValue;
    DWORD       dwPropFlags;

    // Init
    if (ppszData)
        *ppszData = NULL;
    if (pcchData)
        *pcchData = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Compute dwPropFlags
    dwPropFlags = PDF_HEADERFORMAT | ((dwFlags & HTF_NAMEINDATA) ? PDF_NAMEINDATA : 0);

    // Speicify data type
    rValue.type = MVT_STRINGA;

    // Ask the value for the data
    CHECKHR(hr = _HrGetPropertyValue(pRow, dwPropFlags, &rValue));

    // Want Length
    cchData = rValue.rStringA.cchVal;

    // Want the data
    if (ppszData)
    {
        *ppszData = rValue.rStringA.pszVal;
        rValue.rStringA.pszVal = NULL;
    }

    // Else Free It
    else
        SafeMemFree(rValue.rStringA.pszVal);

    // Verify the NULL
    Assert(ppszData ? '\0' == *((*ppszData) + cchData) : TRUE);

    // Return Length ?
    if (pcchData)
        *pcchData = cchData;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    MIMEVARIANT     rValue;
    ULONG           cboffColon;
    LPPROPSYMBOL    pSymbol;
    LPSTR           psz=(LPSTR)pszData;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // If HTF_NAMEINDATA
    if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // Extract the name
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Symbol Must be the same
        if (pRow->pSymbol != pSymbol)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Adjust pszData
        Assert(cboffColon < cchData);
        psz = (LPSTR)(pszData + cboffColon + 1);
        cchData = cchData - cboffColon - 1;
        Assert(psz[cchData] == '\0');
    }

    // Setup the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = psz;
    rValue.rStringA.cchVal = cchData;

    // Tell value about the new row data
    CHECKHR(hr = _HrSetPropertyValue(pRow, 0, &rValue, FALSE));

    // Clear Position Information
    pRow->cboffStart = 0;
    pRow->cboffColon = 0;
    pRow->cboffEnd = 0;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pInfo->dwRowNumber = pRow->dwRowNumber;
    pInfo->cboffStart = pRow->cboffStart;
    pInfo->cboffColon = pRow->cboffColon;
    pInfo->cboffEnd = pRow->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowNumber
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pRow->dwRowNumber = dwRowNumber;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         iEnum=0,
                         cEnumCount;
    LPENUMHEADERROW      pEnumRow=NULL;
    LPPROPERTY           pRow;
    CMimeEnumHeaderRows *pEnum=NULL;
    LPROWINDEX           prgIndex=NULL;
    ULONG                cRows;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Lets Count the Rows
    CHECKHR(hr = CountRows(pszHeader, &cEnumCount));

    // Allocate pEnumRow
    CHECKALLOC(pEnumRow = (LPENUMHEADERROW)g_pMalloc->Alloc(cEnumCount * sizeof(ENUMHEADERROW)));

    // ZeroInit
    ZeroMemory(pEnumRow, cEnumCount * sizeof(ENUMHEADERROW));

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Is this a header the client wants
        if (NULL == pszHeader || lstrcmpi(pszHeader, pRow->pSymbol->pszName) == 0)
        {
            // Valide
            Assert(iEnum < cEnumCount);

            // Set the symbol on this enum row
            pEnumRow[iEnum].dwReserved = (DWORD_PTR)pRow->pSymbol;

            // Lets always give the handle
            pEnumRow[iEnum].hRow = pRow->hRow;

            // If Enumerating only handles...
            if (!ISFLAGSET(dwFlags, HTF_ENUMHANDLESONLY))
            {
                // Get the data for this enum row
                CHECKHR(hr = GetRowData(pRow->hRow, dwFlags, &pEnumRow[iEnum].pszData, &pEnumRow[iEnum].cchData));
            }

            // Increment iEnum
            iEnum++;
        }
    }

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, dwFlags, cEnumCount, pEnumRow, FALSE));

    // Don't Free pEnumRow
    pEnumRow = NULL;

    // Return it
    (*ppEnum) = (IMimeEnumHeaderRows *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeMemFree(prgIndex);
    if (pEnumRow)
        g_pMoleAlloc->FreeEnumHeaderRowArray(cEnumCount, pEnumRow, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream,
    ULONG *pcAddrsWrote, ADDRESSFORMAT format, VARTYPE vtFormat)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pStream && pcAddrsWrote);
    Assert(!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Multibyte
        if (VT_LPSTR == vtFormat)
        {
            // Tell the Address Info object to write its display information
            CHECKHR(hr = _HrSaveAddressA(pProperty, pAddress, pStream, pcAddrsWrote, format));
        }

        // Otherwise
        else
        {
            // Validate 
            Assert(VT_LPWSTR == vtFormat);

            // Tell the Address Info object to write its display information
            CHECKHR(hr = _HrSaveAddressW(pProperty, pAddress, pStream, pcAddrsWrote, format));
        }

        // Increment cAddresses Count
        (*pcAddrsWrote)++;
    }

exit:
    // Done
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  bIsInLineEncodedA
//
//  [PaulHi] 6/29/99
//  Helper function to determine if single byte string contains RFC1522 inline
//  encoding.  
//  Format is: "=?[charset]?[encoding]?[data]?=".
///////////////////////////////////////////////////////////////////////////////
BOOL bIsInLineEncodedA(LPCSTR pcszName)
{
    Assert(pcszName);

    int nState = 0; // 0-Begin,charset; 1-encoding; 2-data; 3-Ending

    while(*pcszName)
    {
        // Check for beginning delimiter.
        if ( (*pcszName == '=') && (*(pcszName+1) == '?') )
        {
            // Set/reset state
            nState = 1;
            pcszName += 1;  // Skip past.
        }
        else
        {
            switch (nState)
            {
            case 1:
            case 2:
                // Find encoding, data bodies.
                if (*pcszName == '?')
                {
                    ++nState;
                    ++pcszName; // Skip past body
                }
                break;

            case 3:
                // Find ending delimiter.
                if ( (*pcszName == '?') && (*(pcszName+1) == '=') )
                    return TRUE;
                break;
            }
        }

        if (*pcszName != '\0')
        {
            if (IsDBCSLeadByte(*pcszName))
                ++pcszName;
            ++pcszName;
        }
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressA
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressA(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszNameW=NULL;
    LPSTR           pszNameA=NULL;
    LPSTR           pszEmailA=NULL;
    BOOL            fWriteEmail=FALSE;
    LPWSTR          pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    BOOL            fRFC1522=FALSE;
    DWORD           dwFlags;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyW(pAddress->rFriendly.psz) && FIsEmptyW(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_szAddressFold, lstrlen(c_szAddressFold), NULL));
        }

        // AFT_RFC822_DECODED, AFT_RFC822_ENCODED
        else if (AFT_RFC822_DECODED == format ||  AFT_RFC822_ENCODED == format)
        {
            // ', '
            CHECKHR(hr = pStream->Write(c_szCommaSpace, lstrlen(c_szCommaSpace), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyW(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyW(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if ((AFT_RFC822_TRANSMIT == format || AFT_DISPLAY_BOTH == format) && fWriteEmail && StrStrW(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszNameA = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGA;
            rSource.type = MVT_STRINGW;

            // Init pszName
            pszNameW = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeStringW(pszNameW, &pszEscape) == S_OK)
            {
                // Escaped
                pszNameW = pszEscape;
                rSource.rStringW.pszVal = pszNameW;
                rSource.rStringW.cchVal = lstrlenW(pszNameW);
            }

            // Otherwise
            else
            {
                rSource.rStringW.pszVal = pAddress->rFriendly.psz;
                rSource.rStringW.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
                dwFlags = CVF_NOALLOC | PDF_ENCODED;
            else
                dwFlags = CVF_NOALLOC;

            // Convert to ansi
            if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, IET_DECODED, dwFlags, 0, &rSource, &rDest, &fRFC1522)))
            {
                // Set pszNameA
                pszNameA = rDest.rStringA.pszVal;
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszNameA)
    {
        // [PaulHi] 6/29/99  Raid 81539
        // Double quote all display names unless they are in-line encoded.
        BOOL    fInLineEncoded = bIsInLineEncodedA(pszNameA);
        // if (fRFC822 && !fRFC1522)

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }

        // Write display name
        CHECKHR(hr = pStream->Write(pszNameA, lstrlen(pszNameA), NULL));

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCSTR pszStart = pszNameA ? c_szEmailSpaceStart : c_szEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlen(pszStart), NULL));

        // Convert to ansi
        CHECKALLOC(pszEmailA = PszToANSI(CP_ACP, pAddress->rEmail.psz));

        // Write email
        CHECKHR(hr = pStream->Write(pszEmailA, lstrlen(pszEmailA), NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    SafeMemFree(pszEmailA);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  bIsInLineEncodedW
//
//  [PaulHi] 6/29/99
//  Helper function to determine if double byte string contains RFC1522 inline
//  encoding.
//  Format is: "=?[charset]?[encoding]?[data]?=".
///////////////////////////////////////////////////////////////////////////////
BOOL bIsInLineEncodedW(LPCWSTR pcwszName)
{
    Assert(pcwszName);

    int nState = 0;  // 0-Begin,charset; 1-encoding; 2-data; 3-Ending

    while(*pcwszName)
    {
        if ( (*pcwszName == L'=') && (*(pcwszName+1) == L'?') )
        {
            // Set/reset state.
            nState = 1;
            ++pcwszName; // Skip past
        }
        else
        {
            switch (nState)
            {
            case 1:
            case 2:
                // Find encoding, data bodies.
                if (*pcwszName == L'?')
                {
                    ++nState;
                    ++pcwszName; // Skip past body
                }
                break;

            case 3:
                // Find ending delimiter.
                if ( (*pcwszName == L'?') && (*(pcwszName+1) == L'=') )
                    return TRUE;
                break;
            }
        }

        if (*pcwszName != 0)
            ++pcwszName;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressW
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressW(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszNameW=NULL;
    BOOL            fWriteEmail=FALSE;
    LPWSTR          pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    BOOL            fRFC1522=FALSE;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyW(pAddress->rFriendly.psz) && FIsEmptyW(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_wszAddressFold, lstrlenW(c_wszAddressFold) * sizeof(WCHAR), NULL));
        }

        // AFT_RFC822_DECODED, AFT_RFC822_ENCODED
        else if (AFT_RFC822_DECODED == format ||  AFT_RFC822_ENCODED == format)
        {
            // ', '
            CHECKHR(hr = pStream->Write(c_wszCommaSpace, lstrlenW(c_wszCommaSpace) * sizeof(WCHAR), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_wszSemiColonSpace, lstrlenW(c_wszSemiColonSpace) * sizeof(WCHAR), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyW(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyW(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if ((AFT_RFC822_TRANSMIT == format || AFT_DISPLAY_BOTH == format) && fWriteEmail && StrStrW(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszNameW = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGW;
            rSource.type = MVT_STRINGW;

            // Init pszName
            pszNameW = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeStringW(pszNameW, &pszEscape) == S_OK)
            {
                // Escaped
                pszNameW = pszEscape;
                rSource.rStringW.pszVal = pszNameW;
                rSource.rStringW.cchVal = lstrlenW(pszNameW);
            }

            // Otherwise
            else
            {
                rSource.rStringW.pszVal = pAddress->rFriendly.psz;
                rSource.rStringW.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
            {
                // Convert to ansi
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, IET_DECODED, CVF_NOALLOC | PDF_ENCODED, 0, &rSource, &rDest, &fRFC1522)))
                {
                    // Set pszNameA
                    pszNameW = rDest.rStringW.pszVal;
                }
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszNameW)
    {
        // [PaulHi] 6/29/99  Raid 81539
        // Double quote all display names unless they are in-line encoded.
        BOOL    fInLineEncoded = bIsInLineEncodedW(pszNameW);
        // if (fRFC822 && !fRFC1522)

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR(hr = pStream->Write(c_wszDoubleQuote, lstrlenW(c_wszDoubleQuote) * sizeof(WCHAR), NULL));
        }

        // Write display name
        CHECKHR(hr = pStream->Write(pszNameW, lstrlenW(pszNameW) * sizeof(WCHAR), NULL));

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR (hr = pStream->Write(c_wszDoubleQuote, lstrlenW(c_wszDoubleQuote) * sizeof(WCHAR), NULL));
        }
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCWSTR pszStart = pszNameW ? c_wszEmailSpaceStart : c_wszEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlenW(pszStart) * sizeof(WCHAR), NULL));

        // Write email
        CHECKHR(hr = pStream->Write(pAddress->rEmail.psz, pAddress->rEmail.cch * sizeof(WCHAR), NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_wszEmailEnd, lstrlenW(c_wszEmailEnd) * sizeof(WCHAR), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria,
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pszCriteria);

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        if (_HrQueryAddress(pProperty, pAddress, pszCriteria, fSubString, fCaseSensitive) == S_OK)
            goto exit;
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszCriteria=NULL;

    // Invalid Arg
    Assert(pProperty && pAddress && pszCriteria);

    // Convert to Unicode
    CHECKALLOC(pwszCriteria = PszToUnicode(CP_ACP, pszCriteria));

    // Query Email Address First
    if (MimeOleQueryStringW(pAddress->rEmail.psz, pwszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Query Display Address First
    if (MimeOleQueryStringW(pAddress->rFriendly.psz, pwszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Not Found
    hr = S_FALSE;

exit:
    // Cleanup
    SafeMemFree(pwszCriteria);

    // Done
    return hr;
}


// ----------------------------------------------------------------------------
// CMimePropertyContainer::Append
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly,
    LPCSTR pszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(rProps));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = (LPSTR)pszFriendly;
    }

    // Set pszEmail
    if (pszEmail)
    {
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = (LPSTR)pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendW
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendW(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCWSTR pwszFriendly,
    LPCWSTR pwszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;
    LPSTR           pszFriendly = NULL,
                    pszEmail = NULL;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(rProps));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pwszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLYW);
        rProps.pszFriendlyW = (LPWSTR)pwszFriendly;

        IF_NULLEXIT(pszFriendly = PszToANSI(CP_ACP, pwszFriendly));
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = pszFriendly;
    }

    // Set pszEmail
    if (pwszEmail)
    {
        IF_NULLEXIT(pszEmail = PszToANSI(CP_ACP, pwszEmail));
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    MemFree(pszFriendly);
    MemFree(pszEmail);

    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Insert
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address and Address Type
    if (!ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) || (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail)))
        return TrapError(E_INVALIDARG);

    // Init
    if (phAddress)
        *phAddress = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

    // Open the group
    CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Append an Address to the group
    CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

    // The group is dirty
    Assert(pAddress->pGroup);
    pAddress->pGroup->fDirty = TRUE;

    // Set the Address Type
    pAddress->dwAdrType = pProps->dwAdrType;

    // Copy Address Props to Mime Address
    CHECKHR(hr = SetProps(pAddress->hThis, pProps));

    // Return the Handle
    if (phAddress)
        *phAddress = pAddress->hThis;

exit:
    // Failure
    if (FAILED(hr) && pAddress)
        Delete(pAddress->hThis);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_GetAddressCodePageId
// --------------------------------------------------------------------------------
CODEPAGEID CMimePropertyContainer::_GetAddressCodePageId(LPINETCSETINFO pCharset,
    ENCODINGTYPE ietEncoding)
{
    // Locals
    CODEPAGEID cpiCodePage=CP_ACP;

    // No Charset Yet
    if (NULL == pCharset)
    {
        // Try to use the default
        if (m_rOptions.pDefaultCharset)
            pCharset = m_rOptions.pDefaultCharset;

        // Use the global default
        else if (CIntlGlobals::GetDefHeadCset())
            pCharset = CIntlGlobals::GetDefHeadCset();
    }

    // If we have a charset, compute the friendly name codepage
    if (pCharset)
    {
        // Decoded
        if (IET_DECODED == ietEncoding)
        {
            // Get Windows
            cpiCodePage = (CP_UNICODE == pCharset->cpiWindows) ? CP_ACP : MimeOleGetWindowsCPEx(pCharset);
        }

        // Otherwise
        else
        {
            // Use Internet Codepage
            cpiCodePage = (CP_UNICODE == pCharset->cpiInternet) ? CP_ACP : pCharset->cpiInternet;
        }
    }

    // Done
    return(cpiCodePage);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset=NULL;
    LPWSTR          pszFriendlyW=NULL;
    LPWSTR          pszEmailW=NULL;
    ENCODINGTYPE    ietFriendly;

    // Set ietFriendly
    ietFriendly = (ISFLAGSET(pProps->dwProps, IAP_ENCODING)) ? pProps->ietFriendly : IET_DECODED;

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
        pAddress->dwAdrType = pProps->dwAdrType;

    // IAP_HCHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET) && pProps->hCharset)
    {
        // Resolve to pCharset
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pProps->hCharset, &pCharset)))
            pAddress->pCharset = pCharset;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
        pAddress->certstate = pProps->certstate;

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
        pAddress->dwCookie = pProps->dwCookie;

    // IAP_FRIENDLYW
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLYW) && pProps->pszFriendlyW)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pProps->pszFriendlyW, lstrlenW(pProps->pszFriendlyW), &pAddress->rFriendly));
    }

    // IAP_FRIENDLY
    else if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY) && pProps->pszFriendly)
    {
        // If the string is encoded, then we have to convert from cpiInternet to a Unicode
        if (IET_DECODED != ietFriendly)
        {
            // No Charset Yet
            if (NULL == pCharset)
            {
                // Try to use the default
                if (m_rOptions.pDefaultCharset)
                    pCharset = m_rOptions.pDefaultCharset;

                // Use the global default
                else if (CIntlGlobals::GetDefHeadCset())
                    pCharset = CIntlGlobals::GetDefHeadCset();
            }

            // If we have a charset
            if (pCharset)
            {
                // Locals
                RFC1522INFO Rfc1522Info={0};
                PROPVARIANT Decoded;

                // rfc1522 ?
                Rfc1522Info.fRfc1522Allowed = TRUE;

                // Init
                Decoded.vt = VT_LPWSTR;

                // Decode the header
                if (SUCCEEDED(g_pInternat->DecodeHeader(pCharset->hCharset, pProps->pszFriendly, &Decoded, &Rfc1522Info)))
                {
                    // Set
                    pszFriendlyW = Decoded.pwszVal;
                }
            }
        }

        // Otherwise, just convert to unicode
        else
        {
            // Convert To Unicode
            pszFriendlyW = PszToUnicode(_GetAddressCodePageId(pCharset, IET_DECODED), pProps->pszFriendly);
        }

        // If we haven't set pszFriendlyW, then just copy pszFriendly
        if (NULL == pszFriendlyW)
        {
            // Convert from CP_ACP to unicode
            CHECKALLOC(pszFriendlyW = PszToUnicode(CP_ACP, pProps->pszFriendly));
        }

        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pszFriendlyW, lstrlenW(pszFriendlyW), &pAddress->rFriendly));
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && pProps->pszEmail)
    {
        // Convert To Unicode
        CHECKALLOC(pszEmailW = PszToUnicode(CP_ACP, pProps->pszEmail));

        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pszEmailW, lstrlenW(pszEmailW), &pAddress->rEmail));
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT) && pProps->tbSigning.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbSigning.pBlobData);
        pAddress->tbSigning.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbSigning, &pAddress->tbSigning));
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT) && pProps->tbEncryption.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbEncryption.pBlobData);
        pAddress->tbEncryption.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbEncryption, &pAddress->tbEncryption));
    }

    // pAddress->pGroup is Dirty
    Assert(pAddress->pGroup);
    if (pAddress->pGroup)
        pAddress->pGroup->fDirty = TRUE;

exit:
    // Cleanup
    SafeMemFree(pszFriendlyW);
    SafeMemFree(pszEmailW);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_CHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET))
    {
        if (pAddress->pCharset && pAddress->pCharset->hCharset)
        {
            pProps->hCharset = pAddress->pCharset->hCharset;
        }
        else
        {
            pProps->hCharset = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_CHARSET);
        }
    }

    // IAP_HANDLE
    if (ISFLAGSET(pProps->dwProps, IAP_HANDLE))
    {
        Assert(pAddress->hThis);
        pProps->hAddress = pAddress->hThis;
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
    {
        Assert(pAddress->dwAdrType);
        pProps->dwAdrType = pAddress->dwAdrType;
    }

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
    {
        pProps->dwCookie = pAddress->dwCookie;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
    {
        pProps->certstate = pAddress->certstate;
    }

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
    {
        pProps->ietFriendly = IET_DECODED;
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY))
    {
        // Decode
        if (pAddress->rFriendly.psz)
        {
            // Compute the correct codepage...
            CHECKALLOC(pProps->pszFriendly = PszToANSI(_GetAddressCodePageId(pAddress->pCharset, IET_DECODED), pAddress->rFriendly.psz));
        }
        else
        {
            pProps->pszFriendly = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLY);
        }
    }

    // IAT_FRIENDLYW
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLYW))
    {
        // Get the email address
        if (pAddress->rFriendly.psz)
        {
            CHECKALLOC(pProps->pszFriendlyW = PszDupW(pAddress->rFriendly.psz));
        }
        else
        {
            pProps->pszFriendlyW = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLYW);
        }
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL))
    {
        // Get the email address
        if (pAddress->rEmail.psz)
        {
            CHECKALLOC(pProps->pszEmail = PszToANSI(CP_ACP, pAddress->rEmail.psz));
        }
        else
        {
            pProps->pszEmail = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_EMAIL);
        }
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT))
    {
        if (pAddress->tbSigning.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbSigning, &pProps->tbSigning));
        }
        else
        {
            pProps->tbSigning.pBlobData = NULL;
            pProps->tbSigning.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_SIGNING_PRINT);
        }
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT))
    {
        if (pAddress->tbEncryption.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbEncryption, &pProps->tbEncryption));
        }
        else
        {
            pProps->tbEncryption.pBlobData = NULL;
            pProps->tbEncryption.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_ENCRYPTION_PRINT);
        }
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::SetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Address Type
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) && pProps->dwAdrType != pAddress->dwAdrType)
    {
        // Unlink this address from this group
        _UnlinkAddress(pAddress);

        // Get Header
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

        // Open the group
        CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // LinkAddress
        _LinkAddress(pAddress, pProperty->pGroup);

        // Dirty
        pProperty->pGroup->fDirty = TRUE;
    }

    // Changing other properties
    CHECKHR(hr = _HrSetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Email Address to Null
    CHECKHR(hr = _HrGetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetSender
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSender(LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPERTY          pProperty;
    LPPROPERTY          pSender=NULL;
    HADDRESS            hAddress=NULL;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find first from
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_FROM))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Take the first address
            if (pProperty->pGroup->pHead)
                hAddress = pProperty->pGroup->pHead->hThis;

            // Done
            break;
        }

        // Look for Sender:
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_SENDER) && NULL == pSender)
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Sender Property
            pSender = pProperty;
        }
    }

    // Is there a sender group
    if (NULL == hAddress && NULL != pSender && NULL != pSender->pGroup->pHead)
        hAddress = pSender->pGroup->pHead->hThis;

    // No Address
    if (NULL == hAddress)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get Props
    CHECKHR(hr = GetProps(hAddress, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::CountTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountTypes(DWORD dwAdrTypes, ULONG *pcAdrs)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    if (NULL == pcAdrs)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcAdrs = 0;

    // Loop through groups
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Increment Count
            (*pcAdrs) += pProperty->pGroup->cAdrs;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               iAddress;
    LPPROPERTY          pProperty;
    LPMIMEADDRESS       pAddress;

    // Invalid Arg
    if (NULL == pList)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through groups
    CHECKHR(hr = CountTypes(dwAdrTypes, &pList->cAdrs));

    // Nothing..
    if (0 == pList->cAdrs)
        goto exit;

    // Allocate an array
    CHECKHR(hr = HrAlloc((LPVOID *)&pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS)));

    // Init
    ZeroMemory(pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS));

    // Fill with types...
    for (iAddress=0, pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Loop Infos...
        for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Verify Size...
            Assert(iAddress < pList->cAdrs);

            // Zeromemory
            ZeroMemory(&pList->prgAdr[iAddress], sizeof(ADDRESSPROPS));

            // Set Desired Props
            pList->prgAdr[iAddress].dwProps = dwProps;

            // Get the Address Props
            CHECKHR(hr = _HrGetAddressProps(&pList->prgAdr[iAddress], pAddress));

            // Increment piCurrent
            iAddress++;
        }
    }

exit:
    // Failure..
    if (FAILED(hr))
    {
        g_pMoleAlloc->FreeAddressList(pList);
        ZeroMemory(pList, sizeof(ADDRESSLIST));
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::EnumTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT                hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;
    ADDRESSLIST            rList;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init out param in case of error
    *ppEnum = NULL;

    // Init rList
    ZeroMemory(&rList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the address lsit
    CHECKHR(hr = GetTypes(dwAdrTypes, dwProps, &rList));

    // Create a new Enumerator
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit((IMimeAddressTable *)this, 0, &rList, FALSE));

    // Clear rList
    rList.cAdrs = 0;
    rList.prgAdr = NULL;

    // Return it
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    if (rList.cAdrs)
        g_pMoleAlloc->FreeAddressList(&rList);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Delete
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Delete(HADDRESS hAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref Address
    pAddress = HADDRESSGET(hAddress);

    // Unlink this address
    _UnlinkAddress(pAddress);

    // Unlink this address
    _FreeAddress(pAddress);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::DeleteTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteTypes(DWORD dwAdrTypes)
{
    // Locals
    LPPROPERTY      pProperty;
    BOOL            fFound;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // While there are address types
    while(dwAdrTypes)
    {
        // Reset fFound
        fFound = FALSE;

        // Search for first delete-able address type
        for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
        {
            // Not the type I want
            if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            {
                // We found a properyt
                fFound = TRUE;

                // Clear this address type ad being deleted
                FLAGCLEAR(dwAdrTypes, pProperty->pSymbol->dwAdrType);

                // Unlink this property
                _UnlinkProperty(pProperty);

                // Done
                break;
            }
        }

        // No Property Found
        if (FALSE == fFound)
            break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// GetFormatW
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetFormatW(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPWSTR *ppwszFormat)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     Variant;

    // Trace
    TraceCall("CMimePropertyContainer::GetFormatW");

    // Invalid Args
    if (NULL == ppwszFormat)
        return(TraceResult(E_INVALIDARG));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&Variant, sizeof(PROPVARIANT));

    // I want a unicode string
    Variant.vt = VT_LPWSTR;

    // Get the address format
    CHECKHR(hr = _GetFormatBase(dwAdrType, format, &Variant));

    // Return the String
    *ppwszFormat = Variant.pwszVal;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetFormat
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPSTR *ppszFormat)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     Variant;

    // Trace
    TraceCall("CMimePropertyContainer::GetFormat");

    // Invalid Args
    if (NULL == ppszFormat)
        return(TraceResult(E_INVALIDARG));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&Variant, sizeof(PROPVARIANT));

    // I want a unicode string
    Variant.vt = VT_LPSTR;

    // Get the address format
    CHECKHR(hr = _GetFormatBase(dwAdrType, format, &Variant));

    // Return the String
    *ppszFormat = Variant.pszVal;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}
// ----------------------------------------------------------------------------
// CMimePropertyContainer::_GetFormatBase
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_GetFormatBase(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT              hr=S_OK;
    CByteStream          cByteStream;
    ULONG                cAddrsWrote=0;
    LPPROPERTY           pProperty;

    // Validate
    Assert(pVariant && (VT_LPWSTR == pVariant->vt || VT_LPSTR == pVariant->vt));

    // Fill with types...
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrType, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Tell the group object to write its display address into pStream
        CHECKHR(hr = _HrSaveAddressGroup(pProperty, &cByteStream, &cAddrsWrote, format, pVariant->vt));
     }

    // Did we write any for this address tyep ?
    if (cAddrsWrote)
    {
        // Multibyte
        if (VT_LPSTR == pVariant->vt)
        {
            // Get Text
            CHECKHR(hr = cByteStream.HrAcquireStringA(NULL, &pVariant->pszVal, ACQ_DISPLACE));
        }

        // Otherwise, unicode
        else
        {
            // Validate
            Assert(VT_LPWSTR == pVariant->vt);

            // Get Text
            CHECKHR(hr = cByteStream.HrAcquireStringW(NULL, &pVariant->pwszVal, ACQ_DISPLACE));
        }
    }
    else
        hr = MIME_E_NO_DATA;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszRfc822Adr;
    rValue.rStringA.cchVal = lstrlen(pszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822W
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822W(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCWSTR pwszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pwszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGW;
    rValue.rStringW.pszVal = (LPWSTR)pwszRfc822Adr;
    rValue.rStringW.cchVal = lstrlenW(pwszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding,
    LPCSTR pszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    LPWSTR              pwszData=NULL;
    PROPVARIANT         rDecoded;
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;
    CODEPAGEID          cpiAddress=CP_ACP;
    INETCSETINFO        CsetInfo;

    // Invalid Arg
    if (NULL == pszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // LocalInit
    ZeroMemory(&rDecoded, sizeof(PROPVARIANT));

    // ZeroParse
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Get codepage
    cpiAddress = _GetAddressCodePageId(NULL, IET_DECODED);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Decode...
    if (IET_DECODED != ietEncoding)
    {
        // Setup rfc1522Info
        rRfc1522Info.fRfc1522Allowed = TRUE;
        rRfc1522Info.fAllow8bit = FALSE;
        rDecoded.vt = VT_LPWSTR;

        // Check for 1522 Encoding...
        if (SUCCEEDED(g_pInternat->DecodeHeader(NULL, pszRfc822Adr, &rDecoded, &rRfc1522Info)))
        {
            // Set the data
            pwszData = rDecoded.pwszVal;

            // Get the pCharset
            if (rRfc1522Info.hRfc1522Cset)
            {
                // Get the charset info
                if (SUCCEEDED(MimeOleGetCharsetInfo(rRfc1522Info.hRfc1522Cset, &CsetInfo)))
                {
                    // Set cpiAddress
                    cpiAddress = MimeOleGetWindowsCPEx(&CsetInfo);

                    // Can't be unicode
                    if (CP_UNICODE == cpiAddress)
                        cpiAddress = CP_ACP;
                }
            }
        }
    }

    // Otherwise, convert to unicode...
    else
    {
        // Convert
        CHECKALLOC(pwszData = PszToUnicode(cpiAddress, pszRfc822Adr));
    }

    // Initialize Parse Structure
    cAdrParse.Init(pwszData, lstrlenW(pwszData));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(*pAddress));

        // Copy the Friendly Name
        CHECKALLOC(pAddress->pszFriendly = PszToANSI(cpiAddress, cAdrParse.PszFriendly()));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszToANSI(CP_ACP, cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = IET_DECODED;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_pMoleAlloc->FreeAddressList(pList);

    // Cleanup
    MemFree(pwszData);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822W
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822W(DWORD dwAdrType, LPCWSTR pwszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    PROPVARIANT         rDecoded = {0};
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;

    // Invalid Arg
    if (NULL == pwszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // ZeroParse
    ZeroMemory(pList, sizeof(*pList));

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Initialize Parse Structure
    cAdrParse.Init(pwszRfc822Adr, lstrlenW(pwszRfc822Adr));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(*pAddress));
        
        IF_NULLEXIT(pAddress->pszFriendlyW = StrDupW(cAdrParse.PszFriendly()));
        
        IF_NULLEXIT(pAddress->pszFriendly = PszToANSI(CP_ACP, pAddress->pszFriendlyW));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszToANSI(CP_ACP, cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = IET_DECODED;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING | IAP_FRIENDLYW);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_pMoleAlloc->FreeAddressList(pList);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeAddressTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeAddressTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrGenerateFileName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGenerateFileName(LPCWSTR pszSuggest, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszDefExt=NULL;
    LPWSTR      pszData=NULL;
    LPWSTR      pszFree=NULL;
    LPCSTR      pszCntType=NULL;
    LPPROPERTY  pProperty;
    MIMEVARIANT rSource;

    // Compute Content Type
    pszCntType = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTTYPE], STR_MIME_TEXT_PLAIN);

    // No suggestion yet
    if (NULL == pszSuggest)
    {
        // Get as Unicode
        rSource.type = MVT_STRINGW;

        // Compute Subject as suggested base file name...
        if (SUCCEEDED(GetProp(SYM_HDR_SUBJECT, 0, &rSource)))
        {
            // Save as new suggest and free it later
            pszSuggest = pszFree = rSource.rStringW.pszVal;
        }

        // If still nothing, then get the content-description header
        if (NULL == pszSuggest)
        {
            // Get Content-Description as unicode
            if (SUCCEEDED(GetProp(SYM_HDR_CNTDESC, 0, &rSource)))
            {
                // Save as new suggest and free it later
                pszSuggest = pszFree = rSource.rStringW.pszVal;
            }
        }
    }

    // message/rfc822
    if (lstrcmpi(pszCntType, (LPSTR)STR_MIME_MSG_RFC822) == 0)
    {
        // If there is a news header, use c_szDotNws
        if (ISFLAGSET(m_dwState, COSTATE_RFC822NEWS))
            pszDefExt = (LPWSTR)c_wszDotNws;
        else
            pszDefExt = (LPWSTR)c_wszDotEml;

        // I will never lookup message/rfc822 extension
        pszCntType = NULL;
    }

    // message/disposition-notification
    else if (lstrcmpi(pszCntType, "message/disposition-notification") == 0)
        pszDefExt = (LPWSTR)c_wszDotTxt;

    // Still no default
    else if (StrCmpNI(pszCntType, STR_CNT_TEXT, lstrlen(STR_CNT_TEXT)) == 0)
        pszDefExt = (LPWSTR)c_wszDotTxt;

    // Generate a filename based on the content type...
    CHECKHR(hr = MimeOleGenerateFileNameW(pszCntType, pszSuggest, pszDefExt, &pszData));

    // Setup rSource
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));
    rSource.type = MVT_STRINGW;
    rSource.rStringW.pszVal = pszData;
    rSource.rStringW.cchVal = lstrlenW(pszData);

    // Return per user request
    CHECKHR(hr = HrConvertVariant(SYM_ATT_GENFNAME, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\cryptdbg.h ===
/*  CRYPTDBG.H
**
**
**
**
*/

#ifndef __CRYPTDBG_H
#define __CRYPTDBG_H

#ifdef DEBUG
BOOL InitDebugHelpers(HINSTANCE hLib);
void DisplayCert(PCCERT_CONTEXT pCert);
void DisplayCrl(PCCRL_CONTEXT pCrl);
void PrintError(LPCSTR pszMsg);

void SMDOUT(LPSTR szFmt, ...);
void CRDOUT(LPSTR szFmt, ...);
void CSSDOUT(LPSTR szFmt, ...);

#else // !DEBUG

#define SMDOUT      1 ? (void)0 : (void)
#define CRDOUT      1 ? (void)0 : (void)
#define CSSDOUT     1 ? (void)0 : (void)
#endif

#define CRYPT_LEVEL     (1024)
#define DOUTL_SMIME     CRYPT_LEVEL
#define DOUTL_CSS       4096

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enriched.h ===
// --------------------------------------------------------------------------------
// Enriched.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENRICHED_H
#define __ENRICHED_H

HRESULT MimeOleConvertEnrichedToHTML(IStream *pIn, IStream *pOut);
HRESULT MimeOleConvertEnrichedToHTMLEx(IMimeBody *pBody, ENCODINGTYPE ietEncoding, IStream **ppStream);

#endif // __ENRICHED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enumhead.cpp ===
// --------------------------------------------------------------------------------
// Enumhead.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "enumhead.h"
#include "olealloc.h"
#include "symcache.h"
#include "demand.h"

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::CMimeEnumHeaderRows
// ---------------------------------------------------------------------------
CMimeEnumHeaderRows::CMimeEnumHeaderRows(void)
{
    DllAddRef();
    m_cRef = 1;
    m_ulIndex = 0;
    m_cRows = 0;
    m_prgRow = NULL;
    m_dwFlags = 0;
    InitializeCriticalSection(&m_cs);
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::~CMimeEnumHeaderRows
// ---------------------------------------------------------------------------
CMimeEnumHeaderRows::~CMimeEnumHeaderRows(void)
{
    g_pMoleAlloc->FreeEnumHeaderRowArray(m_cRows, m_prgRow, TRUE);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeEnumHeaderRows *)this;
    else if (IID_IMimeEnumHeaderRows == riid)
        *ppv = (IMimeEnumHeaderRows *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumHeaderRows::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumHeaderRows::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Next
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Next(ULONG cWanted, LPENUMHEADERROW prgRow, ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFetch=0, 
                    ulIndex=0;
    LPPROPSYMBOL    pSymbol;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgRow || NULL == prgRow)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cRows - m_ulIndex);
    if (0 == cFetch)
        goto exit;

    // Init the array
    ZeroMemory(prgRow, sizeof(ENUMHEADERROW) * cWanted);

    // Copy cWanted
    for (ulIndex=0; ulIndex<cFetch; ulIndex++)
    {
        // Do Enumerating Only Handles
        if (!ISFLAGSET(m_dwFlags, HTF_ENUMHANDLESONLY))
        {
            // Cast symbol
            pSymbol = (LPPROPSYMBOL)m_prgRow[m_ulIndex].dwReserved;

            // Dup the Header Name
            CHECKALLOC(prgRow[ulIndex].pszHeader = PszDupA(pSymbol->pszName));

            // pszData
            if (m_prgRow[m_ulIndex].pszData)
                CHECKALLOC(prgRow[ulIndex].pszData = PszDupA(m_prgRow[m_ulIndex].pszData));

            // Size of Data
            prgRow[ulIndex].cchData = m_prgRow[m_ulIndex].cchData;    
        }

        // Handle
        prgRow[ulIndex].hRow = m_prgRow[m_ulIndex].hRow;

        // Goto Next
        m_ulIndex++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Failure
    if (FAILED(hr) && prgRow)
        g_pMoleAlloc->FreeEnumHeaderRowArray(cFetch, prgRow, FALSE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Skip
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_ulIndex + cSkip) >= m_cRows) || NULL == m_prgRow)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_ulIndex += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Reset
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Reset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset
    m_ulIndex = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Clone
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Clone(IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    CMimeEnumHeaderRows *pEnum=NULL;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows());

    // Init
    CHECKHR(hr = pEnum->HrInit(m_ulIndex, m_dwFlags, m_cRows, m_prgRow, TRUE));

    // Retrun
    (*ppEnum) = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Count
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Count(ULONG *pcRows)
{
    // check params
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set return
    *pcRows = m_cRows;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::HrInit
// ---------------------------------------------------------------------------
HRESULT CMimeEnumHeaderRows::HrInit(ULONG ulIndex, DWORD dwFlags, ULONG cRows, LPENUMHEADERROW prgRow, BOOL fDupArray)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save Lines
    m_ulIndex = ulIndex;
    m_cRows = cRows;
    m_dwFlags = dwFlags;

    // Are there lines ...
    if (m_cRows)
    {
        // Duplicate the Array
        if (fDupArray)
        {
            // Allocate memory
            CHECKALLOC(m_prgRow = (LPENUMHEADERROW)g_pMalloc->Alloc(m_cRows * sizeof(ENUMHEADERROW)));

            // ZeroInit
            ZeroMemory(m_prgRow, sizeof(ENUMHEADERROW) * m_cRows);

            // Loop
            for (i=0; i<m_cRows; i++)
            {
                // Take the symbol
                m_prgRow[i].dwReserved = prgRow[i].dwReserved;

                // Dup the Data
                if (prgRow[i].pszData)
                {
                    // Alloc Memory
                    CHECKALLOC(m_prgRow[i].pszData = (LPSTR)g_pMalloc->Alloc(prgRow[i].cchData + 1));

                    // Copy the String
                    CopyMemory(m_prgRow[i].pszData, prgRow[i].pszData, prgRow[i].cchData + 1);
                }

                // Save the Data Length
                m_prgRow[i].cchData = prgRow[i].cchData;

                // Save the Handle
                m_prgRow[i].hRow = prgRow[i].hRow;
            }
        }
        
        // Otherwise, just assume this array
        else
            m_prgRow = prgRow;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\cryptdbg.cpp ===
/*  CRYPTDBG.CPP
**
**
**
**  Owner:  t-erikne
**  Created: 8/26/96
**
*/

#include "pch.hxx"

#ifdef DEBUG

#include "capitype.h"
#include "cryptdbg.h"
#include <shlwapi.h>
#include <dllmain.h>    // DllAddRef, global critsec
#include <demand.h>

ASSERTDATA
static s_fInit = FALSE;
static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded);
static void PrintLastError(LPCSTR pszMsg);
static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry);

///////////////////////////////////////////////////////////////////////////
//
// DOUT stuff
//

void PrefDOUT(DWORD dwLevel, LPSTR szPref, LPSTR szFmt, va_list arglist);

void CSSDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_CSS, "CSS: ", szFmt, arglist);
    va_end(arglist);
}

void SMDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_SMIME, "SMIME: ", szFmt, arglist);
    va_end(arglist);
}

void CRDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_SMIME, "CRYPT: ", szFmt, arglist);
    va_end(arglist);
}

void PrefDOUT(DWORD dwLevel, LPSTR szPref, LPSTR szFmt, va_list arglist)
{
    char sz[MAX_PATH];

    StrCpyN(sz, szPref, ARRAYSIZE(sz));
    StrCatBuff(sz, szFmt, ARRAYSIZE(sz));
    vDOUTL(dwLevel, sz, arglist);
}


BOOL InitDebugHelpers(HINSTANCE hLib)
{
    s_fInit = TRUE;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    DOUTL(CRYPT_LEVEL,"%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    DOUTL(CRYPT_LEVEL,"%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Helpful util functions
//--------------------------------------------------------------------------

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult = FALSE;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    Assert(s_fInit);

    cbInfo = 0;

    if (pInfo = (PCERT_NAME_INFO) PVDecodeObject(pbEncoded, cbEncoded, (LPCSTR)X509_NAME, &cbInfo)) {
        for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
            for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
                LPSTR pszObjId = pAttr->pszObjId;
                if (pszObjId == NULL)
                    pszObjId = "<NULL OBJID>";
                if ((pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                    (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                    DOUTL(CRYPT_LEVEL,"  [%d,%d] %s ValueType: %d\n",
                        i, j, pszObjId, pAttr->dwValueType);
                } else
                    DOUTL(CRYPT_LEVEL,"  [%d,%d] %s %s\n",
                        i, j, pszObjId, pAttr->Value.pbData);
            }
        }

        fResult = TRUE;
    }

    SafeMemFree(pInfo);
    return fResult;
}

void DisplayCert(PCCERT_CONTEXT pCert)
{
    Assert(s_fInit);

    if (!pCert)
        {
        DOUTL(CRYPT_LEVEL, "No certificate.");
        return;
        }

    DOUTL(CRYPT_LEVEL,"Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData);
    DOUTL(CRYPT_LEVEL,"Issuer::\n");
    DecodeName(pCert->pCertInfo->Issuer.pbData,
        pCert->pCertInfo->Issuer.cbData);

    {
        DWORD cb;
        BYTE *pb;
        DOUTL(CRYPT_LEVEL,"SerialNumber::");
        for (cb = pCert->pCertInfo->SerialNumber.cbData,
             pb = pCert->pCertInfo->SerialNumber.pbData + (cb - 1);
                                                        cb > 0; cb--, pb++) {
            DOUTL(CRYPT_LEVEL," %02X", *pb);
        }
        DOUTL(CRYPT_LEVEL,"\n");
    }
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i;

    Assert(s_fInit);
    for (i = 0; i < cEntry; i++, pEntry++) {
        DWORD cb;
        BYTE *pb;
        DOUTL(CRYPT_LEVEL," [%d] SerialNumber::", i);
        for (cb = pEntry->SerialNumber.cbData,
             pb = pEntry->SerialNumber.pbData + (cb - 1); cb > 0; cb--, pb++) {
            DOUTL(CRYPT_LEVEL," %02X", *pb);
        }
        DOUTL(CRYPT_LEVEL,"\n");

    }
}

void DisplayCrl(PCCRL_CONTEXT pCrl)
{
    Assert(s_fInit);
    DOUTL(CRYPT_LEVEL,"Issuer::\n");
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
        pCrl->pCrlInfo->Issuer.cbData);

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        DOUTL(CRYPT_LEVEL,"Entries:: NONE\n");
    else {
        DOUTL(CRYPT_LEVEL,"Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry);
    }
}

#endif // debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enriched.cpp ===
// --------------------------------------------------------------------------------
// Enriched.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bookbody.h"
#include "internat.h"
#include "mimeapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Charcter Strings used in this code
// --------------------------------------------------------------------------------
static const CHAR c_szAmpersandLT[]          = "&lt;";
static const CHAR c_szAmpersandGT[]          = "&gt;";
static const CHAR c_szGreaterThan[]          = ">";
static const CHAR c_szLessThan[]             = "<";

// --------------------------------------------------------------------------------
// Number of characters in a globally defined string
// --------------------------------------------------------------------------------
#define CCHGLOBAL(_szGlobal)    (sizeof(_szGlobal) - 1)

// --------------------------------------------------------------------------------
// FReadChar
// --------------------------------------------------------------------------------
inline BOOL FReadChar(IStream *pIn, HRESULT *phr, CHAR *pch)
{
    ULONG cb;
    *phr = pIn->Read(pch, sizeof(CHAR), &cb);
    if (FAILED(*phr) || 0 == cb)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// MimeOleConvertEnrichedToHTMLEx
// --------------------------------------------------------------------------------
HRESULT MimeOleConvertEnrichedToHTMLEx(IMimeBody *pBody, ENCODINGTYPE ietEncoding, 
    IStream **ppStream)
{
    // Locals
    HRESULT             hr=S_OK;
    HCHARSET            hCharset;
    LPSTREAM            pStmEnriched=NULL;
    LPSTREAM            pStmHtml=NULL;
    LPMESSAGEBODY       pEnriched=NULL;

    // Invalid Args
    Assert(pBody && ppStream);

    // Get Data
    CHECKHR(hr = pBody->GetData(IET_DECODED, &pStmEnriched));

    // Get the Charset
    if (FAILED(pBody->GetCharset(&hCharset)))
        hCharset = CIntlGlobals::GetDefBodyCset() ? CIntlGlobals::GetDefBodyCset()->hCharset : NULL;

    // Create new virtual stream
    CHECKHR(hr = MimeOleCreateVirtualStream(&pStmHtml));

    // Make sure rewound
    CHECKHR(hr = HrRewindStream(pStmEnriched));

    // Convert
    CHECKHR(hr = MimeOleConvertEnrichedToHTML(MimeOleGetWindowsCP(hCharset), pStmEnriched, pStmHtml));

    // Make sure rewound
    CHECKHR(hr = HrRewindStream(pStmHtml));

    // Allocate pEnriched
    CHECKALLOC(pEnriched = new CMessageBody(NULL, NULL));

    // Init
    CHECKHR(hr = pEnriched->InitNew());

    // Put pstmHtml into pEnriched
    CHECKHR(hr = pEnriched->SetData(IET_DECODED, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, (LPVOID)pStmHtml));

    // Get and set the charset
    if (hCharset)
        pEnriched->SetCharset(hCharset, CSET_APPLY_ALL);

    // Get Data
    CHECKHR(hr = pEnriched->GetData(ietEncoding, ppStream));

exit:
    // Cleanup
    SafeRelease(pStmHtml);
    SafeRelease(pStmEnriched);
    SafeRelease(pEnriched);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleConvertEnrichedToHTML
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleConvertEnrichedToHTML(CODEPAGEID codepage, IStream *pIn, IStream *pOut)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        ch;
    INT         i;
    INT         paramct=0;
    INT         nofill=0;
    CHAR        token[62];
    LPSTR       p;
    BOOL        fDone;
    CHAR        szTemp[2];
    
    // Main loop
    while(FReadChar(pIn, &hr, &ch))
    {
        // LeadByte
        if (IsDBCSLeadByteEx(codepage, ch))
        {
            // Write This Character
            CHECKHR(hr = pOut->Write(&ch, 1, NULL));

            // Read Next
            if (!FReadChar(pIn, &hr, &ch))
                break;

            // Write This Character
            CHECKHR(hr = pOut->Write(&ch, 1, NULL));
        }

        // Token Start
        else if (ch == '<') 
        {
            // Read Next
            if (!FReadChar(pIn, &hr, &ch))
                break;

            // Escaped
            if (ch == '<') 
            {
                // Write
                CHECKHR(hr = pOut->Write(c_szAmpersandLT, CCHGLOBAL(c_szAmpersandLT), NULL));
            } 
            else 
            {
                // Backup One Character
                CHECKHR(hr = HrStreamSeekCur(pIn, -1));

                // Setup szTemp
                szTemp[1] = '\0';

                // Token Scanner
                for (fDone=FALSE, i=0, p=token;;i++) 
                {
                    // Read Next Char
                    if (!FReadChar(pIn, &hr, &ch))
                    {
                        fDone = TRUE;
                        break;
                    }

                    // Finished with bracketed toeksn
                    if (ch == '>')
                        break;

                    // Fill up the token buffer with lowercase chars
                    if (i < sizeof(token) - 1)
                    {
                        szTemp[0] = ch;
                        *p++ = IsUpper(szTemp) ? TOLOWERA(ch) : ch;
                    }
                }

                // Nul-term
                *p = '\0';

                // End of file
                if (fDone) 
                    break;

                // /param
                if (lstrcmpi(token, "/param") == 0) 
                {
                    paramct--;
                    CHECKHR(hr = pOut->Write(c_szGreaterThan, CCHGLOBAL(c_szGreaterThan), NULL));
                }
                else if (paramct > 0) 
                {
                    CHECKHR(hr = pOut->Write(c_szAmpersandLT, CCHGLOBAL(c_szAmpersandLT), NULL));
                    CHECKHR(hr = pOut->Write(token, lstrlen(token), NULL));
                    CHECKHR(hr = pOut->Write(c_szAmpersandGT, CCHGLOBAL(c_szAmpersandGT), NULL));
                }
                else 
                {
                    CHECKHR(hr = pOut->Write(c_szLessThan, CCHGLOBAL(c_szLessThan), NULL));
                    if (lstrcmpi(token, "nofill") == 0) 
                    {
                        nofill++;
                        CHECKHR(hr = pOut->Write("pre", 3, NULL));
                    }
                    else if (lstrcmpi(token, "/nofill") == 0) 
                    {
                        nofill--;
                        CHECKHR(hr = pOut->Write("/pre", 4, NULL));
                    }
                    else if (lstrcmpi(token, "bold") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("b", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/bold") == 0) 
                    {       
                        CHECKHR(hr = pOut->Write("/b", 2, NULL));
                    }
                    else if (lstrcmpi(token, "underline") == 0)
                    {
                        CHECKHR(hr = pOut->Write("u", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/underline") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("/u", 2, NULL));
                    }
                    else if (lstrcmpi(token, "italic") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("i", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/italic") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/i", 2, NULL));
                    }
                    else if (lstrcmpi(token, "fixed") == 0)
                    {
                        CHECKHR(hr = pOut->Write("tt", 2, NULL));
                    }
                    else if (lstrcmpi(token, "/fixed") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/tt", 3, NULL));
                    }
                    else if (lstrcmpi(token, "excerpt") == 0)
                    {
                        CHECKHR(hr = pOut->Write("blockquote", 10, NULL));
                    }
                    else if (lstrcmpi(token, "/excerpt") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/blockquote", 11, NULL));
                    }
                    else
                    {
                        CHECKHR(hr = pOut->Write("?", 1, NULL));
                        CHECKHR(hr = pOut->Write(token, lstrlen(token), NULL));
                        if (lstrcmpi(token, "param") == 0)
                        {
                            paramct++;
                            CHECKHR(hr = pOut->Write(" ", 1, NULL));
                            continue;
                        }
                    }

                    CHECKHR(hr = pOut->Write(c_szGreaterThan, CCHGLOBAL(c_szGreaterThan), NULL));
                }
            }
        }
        else if (ch == '>')
        {
            CHECKHR(hr = pOut->Write(c_szAmpersandGT, CCHGLOBAL(c_szAmpersandGT), NULL));
        }
        else if (ch == '&')
        {
            CHECKHR(hr = pOut->Write("&amp;", 5, NULL));
        }
        else 
        {
            if ((chCR == ch || ch == chLF) && nofill <= 0 && paramct <= 0) 
            {
                ULONG cCRLF=0;
                CHAR chTemp;

                while(1)
                {
                    if (!FReadChar(pIn, &hr, &chTemp))
                        break;

                    if (chCR == chTemp)
                        continue;

                    if (chLF != chTemp)
                    {
                        CHECKHR(hr = HrStreamSeekCur(pIn, -1));
                        break;
                    }

                    if (cCRLF > 0)
                    {
                        CHECKHR(hr = pOut->Write("<br>", 4, NULL));
                    }

                    cCRLF++;
                }

                if (1 == cCRLF)
                {
                    CHECKHR(hr = pOut->Write(" ", 1, NULL));
                }
            }

            // Write the Character
            else
            {
                CHECKHR(hr = pOut->Write(&ch, 1, NULL));
            }
        }
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enumhead.h ===
// --------------------------------------------------------------------------------
// Enumhead.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENUMHEAD_H
#define __ENUMHEAD_H

// --------------------------------------------------------------------------------
// CMimeEnumHeaderRows
// --------------------------------------------------------------------------------
class CMimeEnumHeaderRows : public IMimeEnumHeaderRows
{
public:
    // ---------------------------------------------------------------------------
    // Construction
    // ---------------------------------------------------------------------------
    CMimeEnumHeaderRows(void);
    ~CMimeEnumHeaderRows(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cRows, LPENUMHEADERROW prgRow, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cRows);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumHeaderRows **ppEnum);
    STDMETHODIMP Count(ULONG *pcRows);

    // ---------------------------------------------------------------------------
    // CMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    HRESULT HrInit(ULONG ulIndex, DWORD dwFlags, ULONG cRows, LPENUMHEADERROW prgRow, BOOL fDupArray);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;     // Reference count
    DWORD               m_dwFlags;  // Flags (HEADERFLAGS from mimeole.idl)
    ULONG               m_ulIndex;  // Current enum index
    ULONG               m_cRows;    // Number of lines in prgRow
    LPENUMHEADERROW     m_prgRow;   // Array of header lines being enumerated
    CRITICAL_SECTION    m_cs;       // Critical Section
};

#endif // __ENUMHEAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdystm.h ===
// --------------------------------------------------------------------------------
// Ibdystm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IBDYSTM_H
#define __IBDYSTM_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "mimeole.h"
#include "vstream.h"
#include "inetconv.h"

// --------------------------------------------------------------------------------
// Forwards
// --------------------------------------------------------------------------------
class CMimePropertySet;
class CInternetConverter;
class CMessageBody;
typedef CMessageBody *LPMESSAGEBODY;

// --------------------------------------------------------------------------------
// CBodyStream - {62A83704-52A2-11d0-8205-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CBodyStream, 0x62a83704, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// -----------------------------------------------------------------------------
// DOCCONVTYPE
// -----------------------------------------------------------------------------
typedef enum tagDOCCONVTYPE {
    DCT_NONE   = 1000,
    DCT_ENCODE = 1001,
    DCT_DECODE = 1002,
    DCT_DECENC = 1003
} DOCCONVTYPE;

// -----------------------------------------------------------------------------
// ENCODINGMAP
// -----------------------------------------------------------------------------
typedef struct tagENCODINGMAP {
    ENCODINGTYPE    ietEncoding;
    LPCSTR          pszName;
    BOOL            fValidBodyEncoding;      // Allowed to perform body encoding
} ENCODINGMAP, *LPENCODINGMAP;

BOOL FIsValidBodyEncoding(ENCODINGTYPE ietEncoding);

// -----------------------------------------------------------------------------
// Public
// -----------------------------------------------------------------------------
extern const ENCODINGMAP g_rgEncodingMap[IET_LAST];

// -----------------------------------------------------------------------------
// CONVERSIONMAP
// -----------------------------------------------------------------------------
typedef struct tagCONVERSIONMAP {
    DOCCONVTYPE rgDestType[IET_LAST];
} CONVERSIONMAP, *LPCONVERSIONMAP;

// -----------------------------------------------------------------------------
// Public
// -----------------------------------------------------------------------------
extern const CONVERSIONMAP g_rgConversionMap[IET_LAST];

// -----------------------------------------------------------------------------
// BODYSTREAMINIT
// -----------------------------------------------------------------------------
typedef struct tagBODYSTREAMINIT {
    LPINETCSETINFO      pCharset;            // Current character set
    BOOL                fRemoveNBSP;         // Conversion Flags
    ENCODINGTYPE        ietInternal;         // Internal Encoding Type   
    ENCODINGTYPE        ietExternal;         // External Encoding Type
    CODEPAGEID          cpiInternal;         // Internal Code Page Id
    CODEPAGEID          cpiExternal;         // Extneral Code Page Id
} BODYSTREAMINIT, *LPBODYSTREAMINIT;

// -----------------------------------------------------------------------------
// Wraps a ILockBytes object. CBodyStream is the interface that is 
// always returned by IMimeBody::GetData or QueryInterface(IID_IStream, ...)
// -----------------------------------------------------------------------------
class CBodyStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBodyStream(void);
    ~CBodyStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *) {
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CBodyStream
    // -------------------------------------------------------------------------
    HRESULT HrInitialize(LPBODYSTREAMINIT pInitInfo, LPMESSAGEBODY pBody);

private:
    // -------------------------------------------------------------------------
    // Utilities
    // -------------------------------------------------------------------------
    HRESULT HrConvertToOffset(ULARGE_INTEGER uliOffset);
    HRESULT HrConvertToEnd(void);
    HRESULT HrConvertData(LPBLOB pConvert);
    HRESULT HrConvertDataLast(void);

    // -------------------------------------------------------------------------
    // Initialization Helpers
    // -------------------------------------------------------------------------
    void GetEncodeWrapInfo(LPCONVINITINFO pInitInfo, LPMESSAGEBODY pBody);
    void GetCodePageInfo(LPCONVINITINFO pInitInfo, BOOL fIsText, CODEPAGEID cpiSource, CODEPAGEID cpiDest);
    void ComputeCodePageMapping(LPBODYSTREAMINIT pInitInfo);
    void GenerateDefaultMacBinaryHeader(LPMACBINARY pMacBinary);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;              // Reference count
    LPSTR               m_pszFileName;       // File Name of this body stream...
    DOCCONVTYPE         m_dctConvert;        // Body Conversion type
    ULARGE_INTEGER      m_uliIntOffset;      // 64bit Addressable internal lockbyte space
    ULARGE_INTEGER      m_uliIntSize;        // Size of data in m_pLockBytes
    LARGE_INTEGER       m_liLastWrite;       // Last location writen to in m_cVirtualStream
    ILockBytes         *m_pLockBytes;        // Lock bytes
    CVirtualStream      m_cVirtualStream;    // Full encode/encode
    CInternetConverter *m_pEncoder;          // Internet Encoder
    CInternetConverter *m_pDecoder;          // Internet Encoder
    CRITICAL_SECTION    m_cs;                // Critical Section for m_pStream
};

#endif // __IBDYSTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdystm.cpp ===
// --------------------------------------------------------------------------------
// Ibdystm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "ibdystm.h"
#include "dllmain.h"
#include "inetconv.h"
#include "internat.h"
#include "symcache.h"
#include "bookbody.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Encoding Type Names
// --------------------------------------------------------------------------------
const ENCODINGMAP g_rgEncodingMap[IET_LAST] = {
    { IET_BINARY,       STR_ENC_BINARY,     TRUE   },
    { IET_BASE64,       STR_ENC_BASE64,     TRUE   },
    { IET_UUENCODE,     STR_ENC_UUENCODE,   TRUE   },
    { IET_QP,           STR_ENC_QP,         TRUE   },
    { IET_7BIT,         STR_ENC_7BIT,       TRUE   },
    { IET_8BIT,         STR_ENC_8BIT,       TRUE   },
    { IET_INETCSET,     NULL,               FALSE  },
    { IET_UNICODE,      NULL,               FALSE  },
    { IET_RFC1522,      NULL,               FALSE  },
    { IET_ENCODED,      NULL,               FALSE  },
    { IET_CURRENT,      NULL,               FALSE  },
    { IET_UNKNOWN,      NULL,               FALSE  },
    { IET_BINHEX40,     STR_ENC_BINHEX40,   TRUE   }
};

// --------------------------------------------------------------------------------
// Document Covnert Map
// --------------------------------------------------------------------------------
const CONVERSIONMAP g_rgConversionMap[IET_LAST] = {
    { DCT_NONE,   DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_ENCODE }, // IET_BINARY
    { DCT_DECODE, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_BASE64
    { DCT_DECODE, DCT_DECENC, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_UUENCODE
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_QP
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_7BIT
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_8BIT
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_INETCSET
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_UNICODE
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_RFC1522
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_ENCODED
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_CURRENT 
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_UNKNOWN
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_BINHEX40
    // BINARY     BASE64      UUENCODE    QP          7BIT        8BIT        INETCSET   UNICODE    RFC1522   ENCODED   CURRENT   UNKNOWN   BINHEX40
};

// --------------------------------------------------------------------------------
// FIsValidBodyEncoding
// --------------------------------------------------------------------------------
BOOL FIsValidBodyEncoding(ENCODINGTYPE ietEncoding)
{
    // Try to find the correct body encoding
    for (ULONG i=0; i<IET_LAST; i++)
    {
        // Is this it?
        if (ietEncoding == g_rgEncodingMap[i].ietEncoding)
            return g_rgEncodingMap[i].fValidBodyEncoding;
    }

    // Failure
    return FALSE;
}

// --------------------------------------------------------------------------------
// CBodyStream::CBodyStream
// --------------------------------------------------------------------------------
CBodyStream::CBodyStream(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pszFileName = NULL;
    m_uliIntOffset.QuadPart = 0;
    m_uliIntSize.QuadPart = 0;
    m_liLastWrite.QuadPart = 0;
    m_pLockBytes = NULL;
    m_dctConvert = DCT_NONE;
    m_pEncoder = NULL;
    m_pDecoder = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyStream::~CBodyStream
// --------------------------------------------------------------------------------
CBodyStream::~CBodyStream(void)
{
    SafeMemFree(m_pszFileName);
    SafeRelease(m_pLockBytes);
    SafeRelease(m_pEncoder);
    SafeRelease(m_pDecoder);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CBodyStream::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else if (IID_CBodyStream == riid)
        *ppv = (CBodyStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyStream::AddRef(void)
{    
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBodyStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CBodyStream::GetEncodeWrapInfo
// --------------------------------------------------------------------------------
void CBodyStream::GetEncodeWrapInfo(LPCONVINITINFO pInitInfo, LPMESSAGEBODY pBody)
{
    // Locals
    PROPVARIANT     rOption;

    // Export 7bit or 8bit
    if (IET_7BIT != pInitInfo->ietEncoding && IET_8BIT != pInitInfo->ietEncoding)
        return;

    // OID_WRAP_BODY_TEXT
    if (FAILED(pBody->GetOption(OID_WRAP_BODY_TEXT, &rOption)) || FALSE == rOption.boolVal)
        return;

    // Get Wrapping Width
    if (FAILED(pBody->GetOption(OID_CBMAX_BODY_LINE, &rOption)))
        rOption.ulVal = DEF_CBMAX_BODY_LINE;

    // We are wrapping
    pInitInfo->dwFlags |= ICF_WRAPTEXT;

    // Max Line
    pInitInfo->cchMaxLine = rOption.ulVal;

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CBodyStream::GetCodePageInfo
// --------------------------------------------------------------------------------
void CBodyStream::GetCodePageInfo(LPCONVINITINFO pInitInfo, BOOL fDoCharset, CODEPAGEID cpiSource, CODEPAGEID cpiDest)
{
    // Decide if we should do a code page conversion
    if (TRUE == fDoCharset && cpiSource != cpiDest)
    {
        // No Conversions between 28591 and 1252
        if ((1252 == cpiSource || 28591 == cpiSource) && (1252 == cpiDest || 28591 == cpiDest))
        {
            // Do a code page conversion
            FLAGCLEAR(pInitInfo->dwFlags, ICF_CODEPAGE);
        }

        // Can the conversion between the internal and external code pages be performed ?
        else if (g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK)
        {
            // Do a code page conversion
            FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);
        }

        // Otherwise...
        else
        {
            // Time to Whine
            DOUTL(4, "MLANG.DLL Can't Convert CodePage %d to CodePage %d\n", cpiSource, cpiDest);

            // If cpiSource is unicode and cpiDest is not unicode, we need to set cpiDest to a legal multibyte code page
            if (CP_UNICODE == cpiSource && CP_UNICODE != cpiDest)
            {
                // Default to system acp
                cpiDest = GetACP();

                // We better be able to do this conversion...
                Assert(g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK);

                // Do the conversion...
                FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);

                // Whine some more
                DOUTL(4, "Modified: CODEPAGE(%d -> %d, 0x%0X -> 0x%0X)\n", cpiSource, cpiDest, cpiSource, cpiDest);
            }

            // multibyte to unicode
            else if (CP_UNICODE != cpiSource && CP_UNICODE == cpiDest)
            {
                // Default to system acp
                cpiSource = GetACP();

                // We better be able to do this conversion...
                Assert(g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK);

                // Do the conversion...
                FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);

                // Whine some more
                DOUTL(4, "Modified: CODEPAGE(%d -> %d, 0x%0X -> 0x%0X)\n", cpiSource, cpiDest, cpiSource, cpiDest);
            }
        }
    }

    // Set Source Code Page
    pInitInfo->cpiSource = cpiSource;

    // Set Destination Code Page
    pInitInfo->cpiDest = cpiDest;

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CBodyStream::ComputeCodePageMapping
// --------------------------------------------------------------------------------
void CBodyStream::ComputeCodePageMapping(LPBODYSTREAMINIT pInitInfo)
{
    // We should always have a charset...
    Assert(pInitInfo->pCharset && g_pInternat);

    // External is IET_UNICODE
    if (IET_UNICODE == pInitInfo->ietExternal)
    {
        pInitInfo->cpiExternal = CP_UNICODE;
        pInitInfo->ietExternal = IET_BINARY;
    }

    // External is in Windows CodePage
    else if (IET_BINARY == pInitInfo->ietExternal)
    {
        // RAID-32777: User does not want unicode, so make sure we return multibyte
        pInitInfo->cpiExternal = (CP_UNICODE == pInitInfo->pCharset->cpiWindows) ? GetACP() : pInitInfo->pCharset->cpiWindows;

        // Map outof autodetect
        if (CP_JAUTODETECT == pInitInfo->cpiExternal)
            pInitInfo->cpiExternal = 932;
    }

    // External is in Internet CodePage
    else
    {
        // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect
        pInitInfo->cpiExternal = (CP_JAUTODETECT == pInitInfo->pCharset->cpiInternet) ? 50220 : pInitInfo->pCharset->cpiInternet;

        // Better not be unicode - Removed because of Raid 40228
        /// Assert(CP_UNICODE != pInitInfo->cpiExternal);

        // Adjust ietExternal
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pInitInfo->ietExternal))
            pInitInfo->ietExternal = IET_BINARY;
    }

    // Internal is IET_UNICODE
    if (IET_UNICODE == pInitInfo->ietInternal)
    {
        pInitInfo->cpiInternal = CP_UNICODE;
        pInitInfo->ietInternal = IET_BINARY;
    }

    // Internal is in Windows CodePage
    else if (IET_BINARY == pInitInfo->ietInternal)
    {
        // The internal data is not unicode so make sure we don't say its unicode
        pInitInfo->cpiInternal = (CP_UNICODE == pInitInfo->pCharset->cpiWindows) ? GetACP() : pInitInfo->pCharset->cpiWindows;
    }

    // Internal is in Internet CodePage
    else
    {
        // Internet CodePage
        pInitInfo->cpiInternal = pInitInfo->pCharset->cpiInternet;

        // Adjust ietExternal
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pInitInfo->ietInternal))
            pInitInfo->ietInternal = IET_BINARY;
    }
}

// --------------------------------------------------------------------------------
// CBodyStream::GenerateDefaultMacBinaryHeader
// --------------------------------------------------------------------------------
void CBodyStream::GenerateDefaultMacBinaryHeader(LPMACBINARY pMacBinary)
{
    // ZeroInit
    ZeroMemory(pMacBinary, sizeof(MACBINARY));
}

// --------------------------------------------------------------------------------
// CBodyStream::HrInitialize
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrInitialize(LPBODYSTREAMINIT pInitInfo, LPMESSAGEBODY pBody)
{
    // Locals
    HRESULT         hr=S_OK;
    STATSTG         rStat;
    BOOL            fDoCharset=FALSE;
    BOOL            fIsText;
    CONVINITINFO    rEncodeInit;
    CONVINITINFO    rDecodeInit;
    PROPVARIANT     rVariant;

    // Parameters
    Assert(pBody);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Code Page Mappings
    ComputeCodePageMapping(pInitInfo);

    // Debug
    //DebugTrace("IBodyStream: ENCODING(%s -> %s) CODEPAGE(%d -> %d)\n", g_rgEncodingMap[pInitInfo->ietInternal].pszName,g_rgEncodingMap[pInitInfo->ietExternal].pszName, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

    // Initialize Convert Init Structs
    ZeroMemory(&rEncodeInit, sizeof(CONVINITINFO));
    rEncodeInit.fEncoder = TRUE;
    ZeroMemory(&rDecodeInit, sizeof(CONVINITINFO));
    rDecodeInit.fEncoder = FALSE;

    // Get the class id of this stream
    rVariant.vt = VT_LPSTR;
    if (SUCCEEDED(pBody->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant)))
        m_pszFileName = rVariant.pszVal;

    // Lets test my IBodyStream::Stat function
#ifdef DEBUG
    Stat(&rStat, STATFLAG_NONAME);
#endif

    // Get LockBytes from the body
    hr = pBody->HrGetLockBytes(&m_pLockBytes);
    if (FAILED(hr) && MIME_E_NO_DATA != hr)
    {
        TrapError(hr);
        goto exit;
    }

    // Else, ok
    hr = S_OK;

    // Otherwise, query the size
    if (m_pLockBytes)
    {
        // Get the size of the lockbytes object...
        CHECKHR(hr = m_pLockBytes->Stat(&rStat, STATFLAG_NONAME));

        m_uliIntSize.QuadPart = rStat.cbSize.QuadPart;
    }

    // Special Case for IET_CURRENT
    if (IET_CURRENT == pInitInfo->ietExternal)
    {
        // No Conversion
        m_dctConvert = DCT_NONE;

        // Done
        goto exit;
    }

    // Otheriwse, lookup conversion type
    Assert(FIsValidBodyEncoding(pInitInfo->ietInternal) && FIsValidBodyEncoding(pInitInfo->ietExternal));
    m_dctConvert = (DOCCONVTYPE)(g_rgConversionMap[pInitInfo->ietInternal].rgDestType[pInitInfo->ietExternal]);

    // If we have data...
    if (m_uliIntSize.QuadPart > 0)
    {
        // Is Text
        fIsText = (pBody->IsContentType(STR_CNT_TEXT, NULL) == S_OK) ? TRUE : FALSE;

        // Get the character set for this body...
        if (fIsText)
        {
            // Raid-6832: Mail : We fail to display Plain Text messages when they have a name parameter in the Content Type header
            // If multibyte to unicode or unicode to multibyte, then we must do a charset translation
            if ((CP_UNICODE == pInitInfo->cpiInternal && CP_UNICODE != pInitInfo->cpiExternal) ||
                (CP_UNICODE != pInitInfo->cpiInternal && CP_UNICODE == pInitInfo->cpiExternal))
                fDoCharset = TRUE;

            // If Tagged with a Character Set, then always apply charset dencode/encode
            else if (pBody->IsType(IBT_CSETTAGGED) == S_OK)
                fDoCharset = TRUE;

            // Otherwise, if its not an attachment, then always apply charset dencode/encode
            else if (pBody->IsType(IBT_AUTOATTACH) == S_OK || pBody->IsType(IBT_ATTACHMENT) == S_FALSE)
                fDoCharset = TRUE;
        }

        // If currently no conversion, see if we are translating between code pages
        if (fDoCharset && DCT_NONE == m_dctConvert && pInitInfo->cpiInternal != pInitInfo->cpiExternal)
            m_dctConvert = DCT_DECODE;

        // Encode
        if (DCT_ENCODE == m_dctConvert)
        {
            // Do Code Page Convsion
            GetCodePageInfo(&rEncodeInit, fDoCharset, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

            // Remove NBSPs
            if ((TRUE == fIsText) && (CP_UNICODE == pInitInfo->cpiInternal) && (TRUE == pInitInfo->fRemoveNBSP))
                rEncodeInit.dwFlags |= ICF_KILLNBSP;

            // Set Encoding Type
            rEncodeInit.ietEncoding = pInitInfo->ietExternal;

            // BinHex Encoding...
            if (IET_BINHEX40 == rEncodeInit.ietEncoding)
            {
                // Locals
                PROPVARIANT rOption;

                // Init rOption
                rOption.vt = VT_BLOB;
                rOption.blob.cbSize = sizeof(MACBINARY);
                rOption.blob.pBlobData = (LPBYTE)&rEncodeInit.rMacBinary;

                GenerateDefaultMacBinaryHeader(&rEncodeInit.rMacBinary);
            }

            // GetEncodeWrapInfo
            if (fIsText)
                GetEncodeWrapInfo(&rEncodeInit, pBody);

            // Create Internet Encoder
            CHECKHR(hr = HrCreateInternetConverter(&rEncodeInit, &m_pEncoder));
        }

        // Decode
        else if (DCT_DECODE == m_dctConvert)
        {
            // Do Code Page Convsion
            GetCodePageInfo(&rDecodeInit, fDoCharset, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

            // Remove NBSPs
            if ((TRUE == fIsText) && (CP_UNICODE == pInitInfo->cpiInternal) && (TRUE == pInitInfo->fRemoveNBSP))
                rDecodeInit.dwFlags |= ICF_KILLNBSP;

            // Set Encoding Type
            rDecodeInit.ietEncoding = pInitInfo->ietInternal;

            // BinHex Dencoding...
            if (IET_BINHEX40 == rDecodeInit.ietEncoding)
            {
                // Locals
                PROPVARIANT rOption;
            
                // OID_SHOW_MACBINARY
                if (SUCCEEDED(pBody->GetOption(OID_SHOW_MACBINARY, &rOption)))
                {
                    rDecodeInit.fShowMacBinary = rOption.boolVal;
                }
            }
            
            // Create Internet DeCoder
            CHECKHR(hr = HrCreateInternetConverter(&rDecodeInit, &m_pDecoder));
        }

        // Decode -> Encode
        else if (DCT_DECENC == m_dctConvert)
        {
            // Do Code Page Convsion
            if (pInitInfo->cpiInternal != pInitInfo->cpiExternal)
            {
                // Internal -> Unicode
                GetCodePageInfo(&rDecodeInit, fDoCharset, pInitInfo->cpiInternal, CP_UNICODE);

                // Unicode -> Extnernal
                GetCodePageInfo(&rEncodeInit, fDoCharset, CP_UNICODE, pInitInfo->cpiExternal);
            }

            // Set Encoding Type
            rDecodeInit.ietEncoding = pInitInfo->ietInternal;

            // Create Internet Decoder
            CHECKHR(hr = HrCreateInternetConverter(&rDecodeInit, &m_pDecoder));

            // Set Encoding Type
            rEncodeInit.ietEncoding = pInitInfo->ietExternal;

            // GetEncodeWrapInfo
            if (fIsText)
                GetEncodeWrapInfo(&rEncodeInit, pBody);

            // Create Internet Encoder
            CHECKHR(hr = HrCreateInternetConverter(&rEncodeInit, &m_pEncoder));
        }

        // No Conversion
        else
            Assert(DCT_NONE == m_dctConvert);
    }

    // Otherwise, handle zero length data
    else
    {
        // Converting to IET_UUENCODE
        if (IET_UUENCODE == pInitInfo->ietExternal)
        {
            // Save Size
            m_uliIntOffset.QuadPart = m_uliIntSize.QuadPart = lstrlen(c_szUUEncodeZeroLength);

            // Single byte
            CHECKHR(hr = m_cVirtualStream.Write(c_szUUEncodeZeroLength, lstrlen(c_szUUEncodeZeroLength), NULL));

            // Rewind that stream
            HrRewindStream(&m_cVirtualStream);

            // Change the DC type to any other type
            m_dctConvert = DCT_ENCODE;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertDataLast
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertDataLast(void)
{
    // Locals
    HRESULT hr=S_OK;
    HRESULT hrWarnings=S_OK;

    // Handle Conversion type
    switch(m_dctConvert)
    {
    // ----------------------------------------------------------------------------
    case DCT_ENCODE:
        // Encode
        CHECKHR(hr = m_pEncoder->HrInternetEncode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECODE:
        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pDecoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECENC:
        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrWriteConverted(m_pEncoder));

        // Convert
        CHECKHR(hr = m_pEncoder->HrInternetEncode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    default:
        AssertSz(FALSE, "I should be fired and shot if this line of code executes.");
        break;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertData
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertData(LPBLOB pConvert)
{
    // Locals
    HRESULT hr=S_OK;
    HRESULT hrWarnings=S_OK;

    // Handle Conversion type
    switch(m_dctConvert)
    {
    // ----------------------------------------------------------------------------
    case DCT_ENCODE:
        // Fill Buffer
        CHECKHR(hr = m_pEncoder->HrFillAppend(pConvert));

        // Encode
        CHECKHR(hr = m_pEncoder->HrInternetEncode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECODE:
        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrFillAppend(pConvert));

        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pDecoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECENC:
        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrFillAppend(pConvert));

        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrWriteConverted(m_pEncoder));

        // Convert
        CHECKHR(hr = m_pEncoder->HrInternetEncode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    default:
        AssertSz(FALSE, "I should be fired and shot if this line of code executes.");
        break;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertToOffset
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertToOffset(ULARGE_INTEGER uliOffset)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    BYTE            rgbBuffer[4096];
    ULONG           cbBuffer=0;
    ULONG           cb;
    ULARGE_INTEGER  uliCur, uliSize;
    LARGE_INTEGER   liStart;
    BLOB            rConvert;
    DWORD           dwSize = 0;

    // Big Problems...
    Assert(m_pLockBytes);

    // Fatal Error: This can happen if we are persisting an IMimeMessage back into its original source.
    if (NULL == m_pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Query Current position and uliSize
    m_cVirtualStream.QueryStat(&uliCur, &uliSize);
    liStart.QuadPart = uliCur.QuadPart;
    Assert(m_liLastWrite.QuadPart == liStart.QuadPart);

	dwSize = m_uliIntSize.LowPart - m_uliIntOffset.LowPart;

    // Convert until no more to read or virtual offset is correct
    while(dwSize)
    {
        // Done
        if (uliCur.QuadPart >= uliOffset.QuadPart)
            break;

        // Read a buffer
        Assert(m_uliIntOffset.QuadPart <= m_uliIntSize.QuadPart);
        CHECKHR(hr = m_pLockBytes->ReadAt(m_uliIntOffset, rgbBuffer, sizeof(rgbBuffer), &cbBuffer));

        // Done
        if (0 == cbBuffer)
            break;

        dwSize = dwSize - cbBuffer;

        // Last Buffer ?
        Assert(m_uliIntOffset.QuadPart + cbBuffer <= m_uliIntSize.QuadPart);

        // Setup Blob to Convert
        rConvert.cbSize = cbBuffer;
        rConvert.pBlobData = rgbBuffer;

        // Convert the buffer
        CHECKHR(hr = HrConvertData(&rConvert));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Increment internal offset...
        m_uliIntOffset.QuadPart += cbBuffer;

        // Get current virtual offset
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Save position as last write position...
        m_liLastWrite.QuadPart = uliCur.QuadPart;
    }

    // Done ?
    if (0 == cbBuffer || m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart)
    {
        // Well we don't need m_pLockBytes anymore, its all in m_cVirtualStream
        Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart);

        // Do the last one
        CHECKHR(hr = HrConvertDataLast());
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Get current virtual offset
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Save position as last write position...
        m_liLastWrite.QuadPart = uliCur.QuadPart;

        // Release objects
        SafeRelease(m_pLockBytes);
        SafeRelease(m_pEncoder);
        SafeRelease(m_pDecoder);
    }

    // Rewind virtual stream back to 
    CHECKHR(hr = m_cVirtualStream.Seek(liStart, STREAM_SEEK_SET, NULL));

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertToEnd
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertToEnd(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            rgbBuffer[4096];
    ULONG           cbRead;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Move virtual stream to last write position
    CHECKHR(hr = m_cVirtualStream.Seek(m_liLastWrite, STREAM_SEEK_SET, NULL));

    // Copy m_pLockBytes to pstmTemp
    while(1)
    {
        // Read
        CHECKHR(hr = Read(rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
        {
            // Well we don't need m_pLockBytes anymore, its all in m_cVirtualStream
            Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart);
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::Read
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CBodyStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CBodyStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    ULARGE_INTEGER  uliCur, 
                    uliSize;
    ULONG           cbRead=0,
                    cbLeft=0,
                    cbGet;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Convert Case
    if (DCT_NONE == m_dctConvert)
    {
        // Do I Have data
        if (m_pLockBytes)
        {
            // Read Buffer
            CHECKHR(hr = m_pLockBytes->ReadAt(m_uliIntOffset, pv, cb, &cbRead));

            // Done
            m_uliIntOffset.QuadPart += cbRead;
        }
    }

    // Otherwise
    else
    {
        // Read until we have cb
        cbLeft = cb;
        while(cbLeft)
        {
            // Query Current position and uliSize
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Convert more into the virtual stream
            if (uliCur.QuadPart == uliSize.QuadPart)
            {
                // Done
                if (m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart)
                    break;

                // Grow
                uliCur.QuadPart += g_dwSysPageSize;

                // Convert to offset...
                CHECKHR(hr = HrConvertToOffset(uliCur));
                if ( S_OK != hr )
                    hrWarnings = TrapError(hr);
            }

            // Compute amount that can be read from the current cache
            CHECKHR(hr = m_cVirtualStream.Read((LPVOID)((LPBYTE)pv + cbRead), cbLeft, &cbGet));

            // Increment cbRead
            cbRead+=cbGet;
            cbLeft-=cbGet;
        }
    }

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    ULARGE_INTEGER      uliNew;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Convert Case
    if (DCT_NONE == m_dctConvert)
    {
        // Seek the file pointer
        switch (dwOrigin)
        {
        // --------------------------------------------------------
   	    case STREAM_SEEK_SET:
            uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart < 0)
            {
                if ((DWORDLONG)(0 - dlibMove.QuadPart) > m_uliIntOffset.QuadPart)
                {
                    hr = TrapError(E_FAIL);
                    goto exit;
                }
            }
            uliNew.QuadPart = m_uliIntOffset.QuadPart + dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_END:
            if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > m_uliIntSize.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
            uliNew.QuadPart = m_uliIntSize.QuadPart - dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        default:
            hr = TrapError(STG_E_INVALIDFUNCTION);
            goto exit;
        }

        // New offset greater than size...
        m_uliIntOffset.QuadPart = min(uliNew.QuadPart, m_uliIntSize.QuadPart);

        // Return Position
        if (plibNewPosition)
            plibNewPosition->QuadPart = (LONGLONG)m_uliIntOffset.QuadPart;
    }

    // Otherwise
    else
    {
        // Locals
        ULARGE_INTEGER uliCur, uliSize;
        LARGE_INTEGER liNew;

        // Query Current position and uliSize
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Seek the file pointer
        switch (dwOrigin)
        {
        // --------------------------------------------------------
   	    case STREAM_SEEK_SET:
            // Assume new position
            uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart < 0)
            {
                if ((DWORDLONG)(0 - dlibMove.QuadPart) > uliCur.QuadPart)
                {
                    hr = TrapError(E_FAIL);
                    goto exit;
                }
            }
            uliNew.QuadPart = uliCur.QuadPart + dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_END:
            // Do I need to convert any more ?
            if (m_uliIntOffset.QuadPart < m_uliIntSize.QuadPart)
            {
                // Then Convert to the end
                CHECKHR(hr = HrConvertToEnd());

                // Better be done...
                Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart && NULL == m_pLockBytes);
            }

            // Query Current Position
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Can I really move there
            if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > uliSize.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Assume new position
            uliNew.QuadPart = uliSize.QuadPart - dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        default:
            hr = TrapError(STG_E_INVALIDFUNCTION);
            goto exit;
        }

        // New offset greater than size...
        if (uliNew.QuadPart > uliSize.QuadPart)
        {
            // Do I need to convert any more ?
            if (m_uliIntOffset.QuadPart < m_uliIntSize.QuadPart)
            {
                // Seek m_cVirtualStream to m_uliIntOffset
                CHECKHR(hr = m_cVirtualStream.Seek(m_liLastWrite, STREAM_SEEK_SET, NULL));

                // Convert to offset
                CHECKHR(hr = HrConvertToOffset(uliNew));
                if ( S_OK != hr )
                    hrWarnings = TrapError(hr);
            }

            // Query Current position and uliSize
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Reposition uliNew.QuadPart
            uliNew.QuadPart = (uliNew.QuadPart > uliSize.QuadPart) ? uliSize.QuadPart : uliNew.QuadPart;
        }

        // Otherwise, seek m_cVirtualStream to new location
        liNew.QuadPart = uliNew.QuadPart;
        CHECKHR(hr = m_cVirtualStream.Seek(liNew, STREAM_SEEK_SET, NULL));

        // Return Position
        if (plibNewPosition)
            plibNewPosition->QuadPart = (LONGLONG)uliNew.QuadPart;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::CopyTo(IStream *pstmDest, ULARGE_INTEGER cb, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten)
{
    return HrCopyStreamCB((IStream *)this, pstmDest, cb, puliRead, puliWritten);
}

// --------------------------------------------------------------------------------
// CBodyStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::Stat(STATSTG *pStat, DWORD grfStatFlag)
{
    // Locals
    HRESULT         hr=S_OK;
    LARGE_INTEGER   liSeek;
    ULARGE_INTEGER  uliCurrent;

    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pStat, sizeof(STATSTG));

    // Set Storage Type
    pStat->type = STGTY_STREAM;

    // Set the name ?
    if (m_pszFileName && !(grfStatFlag & STATFLAG_NONAME))
        pStat->pwcsName = PszToUnicode(CP_ACP, m_pszFileName);

    // Seek current position
    liSeek.QuadPart = 0;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_CUR, &uliCurrent));

    // Seek to the end
    liSeek.QuadPart = 0;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_END, &pStat->cbSize));

    // Seek back to current position
    liSeek.QuadPart = uliCurrent.QuadPart;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_SET, &uliCurrent));
    Assert(uliCurrent.QuadPart == (DWORDLONG)liSeek.QuadPart);

    // init clsid
    pStat->clsid = CLSID_NULL;

    // If we have a filename, get the class id...
    if (m_pszFileName)
    {
        // Locals
        CHAR szExt[MAX_PATH];

        // Split the filename
        if (SUCCEEDED(MimeOleGetFileExtension(m_pszFileName, szExt, ARRAYSIZE(szExt))))
            MimeOleGetExtClassId(szExt, &pStat->clsid);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enumprop.h ===
// --------------------------------------------------------------------------------
// Enumprop.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENUMPROP_H
#define __ENUMPROP_H

// --------------------------------------------------------------------------------
// CMimeEnumProperties
// --------------------------------------------------------------------------------
class CMimeEnumProperties : public IMimeEnumProperties
{
public:
    // ---------------------------------------------------------------------------
    // Construction
    // ---------------------------------------------------------------------------
    CMimeEnumProperties(void);
    ~CMimeEnumProperties(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cProps, LPENUMPROPERTY prgProp, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cProps);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumProperties **ppEnum);
    STDMETHODIMP Count(ULONG *pcProps);

    // ---------------------------------------------------------------------------
    // CMimeEnumProperties members
    // ---------------------------------------------------------------------------
    HRESULT HrInit(ULONG ulIndex, ULONG cProps, LPENUMPROPERTY prgProp, BOOL fDupArray);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;     // Reference count
    ULONG               m_ulIndex;  // Current enum index
    ULONG               m_cProps;   // Number of lines in prgRow
    LPENUMPROPERTY      m_prgProp;  // Array of header lines being enumerated
    CRITICAL_SECTION    m_cs;       // Critical Section

};

#endif // __ENUMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdylock.h ===
// --------------------------------------------------------------------------------
// Ibdylock.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IBDYLOCK_H
#define __IBDYLOCK_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef enum tagBINDNODESTATE BINDNODESTATE;

// --------------------------------------------------------------------------------
// CBodyLockBytes - {62A83703-52A2-11d0-8205-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CBodyLockBytes, 0x62a83703, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// BODYLOCK_xxx States
// --------------------------------------------------------------------------------
#define BODYLOCK_HANDSONSTORAGE     FLAG01

// -----------------------------------------------------------------------------
// Wraps a MIME stream object, and provides thread safe access to the 
// a shared stream. When this object wraps a message stream, it is owned by
// IMimeBody
// -----------------------------------------------------------------------------
class CBodyLockBytes : public ILockBytes
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBodyLockBytes(ILockBytes *pLockBytes, LPTREENODEINFO pNode);
    ~CBodyLockBytes(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // ILockBytes methods
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead);
#else
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead);
#endif // !WIN16
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP SetSize(ULARGE_INTEGER cb) {
        return E_NOTIMPL; }
    STDMETHODIMP Flush(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
#ifndef WIN16
    STDMETHODIMP WriteAt(ULARGE_INTEGER, void const *, ULONG, ULONG *) {
#else
    STDMETHODIMP WriteAt(ULARGE_INTEGER, void const HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }

    // -------------------------------------------------------------------------
    // CMimeLockBytes methods
    // -------------------------------------------------------------------------
    HRESULT HrHandsOffStorage(void);
    void OnDataAvailable(LPTREENODEINFO pNode);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;             // Reference count
    DWORD               m_dwState;          // State
    BINDNODESTATE       m_bindstate;        // Current bind state
    ULARGE_INTEGER      m_uliBodyStart;     // Offset to start of body in m_pLockBytes
    ULARGE_INTEGER      m_uliBodyEnd;       // Offset to end of body in m_pLockBytes
    ILockBytes         *m_pLockBytes;       // Actual lockbytes implementation (CMimeMessageTree or CStreamLockBytes)
    CRITICAL_SECTION    m_cs;               // Critical Section for m_pStream
};

#endif // __IBDYLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdylock.cpp ===
// --------------------------------------------------------------------------------
// Ibdylock.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifndef WIN16
#include "ibdylock.h"
#endif // !WIn16
#include "stmlock.h"
#include "booktree.h"
#ifdef WIN16
#include "ibdylock.h"
#endif // WIn16
#include "demand.h"

// --------------------------------------------------------------------------------
// CBodyLockBytes::CBodyLockBytes
// --------------------------------------------------------------------------------
CBodyLockBytes::CBodyLockBytes(ILockBytes *pLockBytes, LPTREENODEINFO pNode)
{
    // Invalid ARg
    Assert(pLockBytes && pNode);

    // Set Initialize Ref Count and State
    m_cRef = 1;
    m_dwState = 0;

    // AddRef the LockBytes
    m_pLockBytes = pLockBytes;
    m_pLockBytes->AddRef();

    // Save State
    FLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE);

    // Save the bind state
    m_bindstate = pNode->bindstate;

    // Save body start and body end..
    Assert(pNode->cbBodyStart <= pNode->cbBodyEnd);

    // Save Body Start
#ifdef MAC
    ULISet32(m_uliBodyStart, pNode->cbBodyStart);
    ULISet32(m_uliBodyEnd, pNode->cbBodyEnd);

    // This condition is here to insure that we don't have a problem...
    if (m_uliBodyStart.LowPart > m_uliBodyEnd.LowPart)
        m_uliBodyStart.LowPart = m_uliBodyEnd.LowPart;
#else   // !MAC
    m_uliBodyStart.QuadPart = pNode->cbBodyStart;
    m_uliBodyEnd.QuadPart = pNode->cbBodyEnd;

    // This condition is here to insure that we don't have a problem...
    if (m_uliBodyStart.QuadPart > m_uliBodyEnd.QuadPart)
        m_uliBodyStart.QuadPart = m_uliBodyEnd.QuadPart;
#endif  // MAC

    // Initialize the CriticalSection
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::~CBodyLockBytes
// --------------------------------------------------------------------------------
CBodyLockBytes::~CBodyLockBytes(void)
{
    SafeRelease(m_pLockBytes);
    Assert(!ISFLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE));
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyLockBytes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_ILockBytes == riid)
        *ppv = (ILockBytes *)this;
    else if (IID_CBodyLockBytes == riid)
        *ppv = (CBodyLockBytes *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyLockBytes::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyLockBytes::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::ReadAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CBodyLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CBodyLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbGet;
    ULONG           cbRead;
    ULARGE_INTEGER  uliActualOffset;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reading from ILockBytes...
    Assert(m_pLockBytes);

#ifdef MAC
    // Compute Actual offset
    AssertSz(m_uliBodyStart.HighPart >= 0, "How can the start be negative??");
    ULISet32(uliActualOffset, m_uliBodyStart.LowPart);

    AssertSz((uliActualOffset.LowPart + ulOffset.LowPart) >= uliActualOffset.LowPart,
                    "Oops! We don't handle backwards reads correctly!");

    uliActualOffset.LowPart += ulOffset.LowPart;

    // Compute amount to read
    cbGet = min(cb, m_uliBodyEnd.LowPart - uliActualOffset.LowPart);
#else   // !MAC
    // Compute Actual offset
    uliActualOffset.QuadPart = ulOffset.QuadPart + m_uliBodyStart.QuadPart;

    // Compute amount to read
    cbGet = (ULONG)min(cb, m_uliBodyEnd.QuadPart - uliActualOffset.QuadPart);
#endif  // MAC

    // Read a block of data...
    CHECKHR(hr = m_pLockBytes->ReadAt(uliActualOffset, pv, cbGet, &cbRead));

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

    // E_PENDING
    if (0 == cbRead && BINDSTATE_COMPLETE != m_bindstate)
    {
        hr = TrapError(E_PENDING);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(pstatstg, sizeof(STATSTG));

    // Reading from ILockBytes...
    pstatstg->type = STGTY_LOCKBYTES;

    // Set Size
#ifdef MAC
    AssertSz(0 == m_uliBodyEnd.HighPart, "We have too big of a file!");
    AssertSz(0 == m_uliBodyStart.HighPart, "We have too big of a file!");
    ULISet32(pstatstg->cbSize, (m_uliBodyEnd.LowPart - m_uliBodyStart.LowPart));
#else   // !MAC
    pstatstg->cbSize.QuadPart = m_uliBodyEnd.QuadPart - m_uliBodyStart.QuadPart;
#endif  // MAC

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::HrHandsOffStorage
// --------------------------------------------------------------------------------
HRESULT CBodyLockBytes::HrHandsOffStorage(void)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pstmTemp=NULL;
    ULARGE_INTEGER  uliCopy;
    BYTE            rgbBuffer[4096];
    ULONG           cbRead;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If I live in the tree, copy data to temporary location...
    if (ISFLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE) && BINDSTATE_COMPLETE == m_bindstate)
    {
        // If more than one reference count
        if (m_cRef > 1)
        {
            // Create Temp Stream
            CHECKHR(hr = CreateTempFileStream(&pstmTemp));

            // Set offset
#ifdef MAC
            ULISet32(uliCopy, 0);
#else   // !MAC
            uliCopy.QuadPart = 0;
#endif  // MAC

            // Copy m_pLockBytes to pstmTemp
            while(1)
            {
                // Read
                CHECKHR(hr = ReadAt(uliCopy, rgbBuffer, sizeof(rgbBuffer), &cbRead));

                // Done
                if (0 == cbRead)
                    break;

                // Write to stream
                CHECKHR(hr = pstmTemp->Write(rgbBuffer, cbRead, NULL));

                // Increment offset
#ifdef MAC
                uliCopy.LowPart += cbRead;
#else   // !MAC
                uliCopy.QuadPart += cbRead;
#endif  // MAC
            }

            // Kill offsets, but maintain bodyend for stat command and Size esitmates
#ifdef MAC
            AssertSz(0 == m_uliBodyEnd.HighPart, "We have too big of a file!");
            m_uliBodyEnd.LowPart -= m_uliBodyStart.LowPart;
            ULISet32(m_uliBodyStart, 0);
#else   // !MAC
            m_uliBodyEnd.QuadPart -= m_uliBodyStart.QuadPart;
            m_uliBodyStart.QuadPart = 0;
#endif  // MAC

            // Rewind and commit
            CHECKHR(hr = pstmTemp->Commit(STGC_DEFAULT));

            // Release current lockbytes
            SafeRelease(m_pLockBytes);

            // New CBodyLockBytes
            CHECKALLOC(m_pLockBytes = new CStreamLockBytes(pstmTemp));
        }

        // Remove lives in tree flag
        FLAGCLEAR(m_dwState, BODYLOCK_HANDSONSTORAGE);
    }

exit:
    // Cleanup
    SafeRelease(pstmTemp);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::OnDataAvailable
// --------------------------------------------------------------------------------
void CBodyLockBytes::OnDataAvailable(LPTREENODEINFO pNode)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Bind Complete
    m_bindstate = pNode->bindstate;

    // Save body start and body end..
#ifdef MAC
    Assert(m_uliBodyStart.LowPart <= pNode->cbBodyEnd);

    // Save start and End
    ULISet32(m_uliBodyEnd, pNode->cbBodyEnd);
#else   // !MAC
    Assert(m_uliBodyStart.QuadPart <= pNode->cbBodyEnd);

    // Save start and End
    m_uliBodyEnd.QuadPart = pNode->cbBodyEnd;
#endif  // MAC

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\enumprop.cpp ===
// --------------------------------------------------------------------------------
// EnumProp.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "enumprop.h"
#include "olealloc.h"
#include "demand.h"

// ---------------------------------------------------------------------------
// CMimeEnumProperties::CMimeEnumProperties
// ---------------------------------------------------------------------------
CMimeEnumProperties::CMimeEnumProperties(void)
{
    DllAddRef();
    m_cRef = 1;
    m_ulIndex = 0;
    m_cProps = 0;
    m_prgProp = NULL;
    InitializeCriticalSection(&m_cs);
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::~CMimeEnumProperties
// ---------------------------------------------------------------------------
CMimeEnumProperties::~CMimeEnumProperties(void)
{
    g_pMoleAlloc->FreeEnumPropertyArray(m_cProps, m_prgProp, TRUE);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeEnumProperties *)this;
    else if (IID_IMimeEnumProperties == riid)
        *ppv = (IMimeEnumProperties *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumProperties::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumProperties::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Next
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Next(ULONG cWanted, LPENUMPROPERTY prgProp, ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFetch=0, 
                    ulIndex=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgProp || NULL == prgProp)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cProps - m_ulIndex);
    if (0 == cFetch)
        goto exit;

    // Init the array
    ZeroMemory(prgProp, sizeof(ENUMPROPERTY) * cWanted);

    // Copy cWanted
    for (ulIndex=0; ulIndex<cFetch; ulIndex++)
    {
        // Set the information
        prgProp[ulIndex].hRow = m_prgProp[m_ulIndex].hRow;

        // Set dwPropId
        prgProp[ulIndex].dwPropId = m_prgProp[m_ulIndex].dwPropId;

        // Not NONAME
        if (m_prgProp[m_ulIndex].pszName)
        {
            // Dup It
            CHECKALLOC(prgProp[ulIndex].pszName = PszDupA(m_prgProp[m_ulIndex].pszName));
        }

        // Goto Next
        m_ulIndex++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Failure
    if (FAILED(hr) && prgProp)
        g_pMoleAlloc->FreeEnumPropertyArray(cFetch, prgProp, FALSE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Skip
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_ulIndex + cSkip) >= m_cProps) || NULL == m_prgProp)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_ulIndex += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Reset
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Reset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset
    m_ulIndex = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Clone
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Clone(IMimeEnumProperties **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    CMimeEnumProperties *pEnum=NULL;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumProperties());

    // Init
    CHECKHR(hr = pEnum->HrInit(m_ulIndex, m_cProps, m_prgProp, TRUE));

    // Retrun
    (*ppEnum) = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Count
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Count(ULONG *pcProps)
{
    // check params
    if (NULL == pcProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set return
    *pcProps = m_cProps;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::HrInit
// ---------------------------------------------------------------------------
HRESULT CMimeEnumProperties::HrInit(ULONG ulIndex, ULONG cProps, LPENUMPROPERTY prgProp, BOOL fDupArray)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save Lines
    m_ulIndex = ulIndex;
    m_cProps = cProps;

    // Are there lines ...
    if (m_cProps)
    {
        // Duplicate the Array
        if (fDupArray)
        {
            // Allocate memory
            CHECKALLOC(m_prgProp = (LPENUMPROPERTY)g_pMalloc->Alloc(m_cProps * sizeof(ENUMPROPERTY)));

            // ZeroInit
            ZeroMemory(m_prgProp, sizeof(ENUMPROPERTY) * m_cProps);

            // Loop
            for (i=0; i<m_cProps; i++)
            {
                // Set the information
                m_prgProp[i].hRow = prgProp[i].hRow;

                // Set dwPropId
                m_prgProp[i].dwPropId = prgProp[i].dwPropId;

                // Not NONAME
                if (prgProp[i].pszName)
                {
                    // Dup It
                    CHECKALLOC(m_prgProp[i].pszName = PszDupA(prgProp[i].pszName));
                }
            }
        }
        
        // Otherwise, just assume this array
        else
            m_prgProp = prgProp;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetconv.cpp ===
// --------------------------------------------------------------------------------
// Inetconv.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "inetconv.h"
#include "internat.h"
#ifndef MAC
#include <shlwapi.h>
#include <mlang.h>
#endif  // !MAC
#include "mimeapi.h"
#include "icoint.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// FGROWBUFFER
// --------------------------------------------------------------------------------
#define FGROWBUFFER(_pBuffer, _cb)       ((_pBuffer)->cb + _cb >= (_pBuffer)->cbAlloc)

// --------------------------------------------------------------------------------
// QP Encoder
// --------------------------------------------------------------------------------
const CHAR g_rgchHex[] = "0123456789ABCDEF";

// --------------------------------------------------------------------------------
// Base64 Decoding Table
// ---------------------
// Decodes one Base64 character into a numeric value
//  
// 0         1         2         3         4         5         6
// 0123456789012345678901234567890123456789012345678901234567890123
// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 
// --------------------------------------------------------------------------------
const char g_rgchDecodeBase64[256] = {
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x00
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x10    
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x20
    64, 64, 64, 62, 64, 64, 64, 63,
    52, 53, 54, 55, 56, 57, 58, 59,  // 0x30
    60, 61, 64, 64, 64,  0, 64, 64,
    64,  0,  1,  2,  3,  4,  5,  6,  // 0x40
     7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22,  // 0x50
    23, 24, 25, 64, 64, 64, 64, 64,
    64, 26, 27, 28, 29, 30, 31, 32,  // 0x60        
    33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48,  // 0x70
    49, 50, 51, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x80
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x90
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xA0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xB0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xC0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xD0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xE0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xF0
    64, 64, 64, 64, 64, 64, 64, 64,
};

// --------------------------------------------------------------------------------
// Base64 Encoder
// --------------------------------------------------------------------------------
extern const CHAR g_rgchEncodeBase64[] = 
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ ";

// --------------------------------------------------------------------------------
// BinHex Decoding Table
// ---------------------
// Decodes one BinHex character into a numeric value
//  
// 0         1         2         3         4         5         6
// 0123456789012345678901234567890123456789012345678901234567890123
// !"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr 
// --------------------------------------------------------------------------------
#undef BINHEX_INVALID
#undef BINHEX_REPEAT
#undef XXXX

const UCHAR BINHEX_INVALID = 0x40;
const UCHAR BINHEX_REPEAT = 0x90;
const UCHAR BINHEX_TERM = ':';
const UCHAR XXXX = BINHEX_INVALID;
const ULONG cbMinBinHexHeader = 22;
const WORD  wBinHexZero = 0;

const UCHAR g_rgchDecodeBinHex[256] = {
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x00
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x10
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,  // 0x20
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, XXXX, XXXX,
    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, XXXX,  // 0x30
    0x14, 0x15, 0x16, XXXX, XXXX, XXXX, XXXX, XXXX,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,  // 0x40
    0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, XXXX,
    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, XXXX,  // 0x50
    0x2C, 0x2D, 0x2E, 0x2F, XXXX, XXXX, XXXX, XXXX,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, XXXX,  // 0x60
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, XXXX, XXXX,
    0x3D, 0x3E, 0x3F, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x70
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x80
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x90
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xA0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xB0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xC0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xD0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xE0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xF0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
};

// --------------------------------------------------------------------------------
// HrCreateLineBreaker
// --------------------------------------------------------------------------------
HRESULT HrCreateLineBreaker(IMLangLineBreakConsole **ppLineBreak)
{
    // Locals
    HRESULT             hr=S_OK;
    PFNGETCLASSOBJECT   pfnDllGetClassObject=NULL;
    IClassFactory      *pFactory=NULL;

    // Invalid Args
    Assert(ppLineBreak);

    // Init
    *ppLineBreak = NULL;

    // Thread Safety
    EnterCriticalSection(&g_csMLANG);

    // If not loaded yet
    if (NULL == g_hinstMLANG)
    {
        // Load MLANG - This should be fast most of the time because MLANG is usually loaded
        g_hinstMLANG = LoadLibrary("MLANG.DLL");
        if (NULL == g_hinstMLANG)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Get DllClassObject
    pfnDllGetClassObject = (PFNGETCLASSOBJECT)GetProcAddress(g_hinstMLANG, "DllGetClassObject");
    if (NULL == pfnDllGetClassObject)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Get the MLANG Class Factory
    CHECKHR(hr = (*pfnDllGetClassObject)(CLSID_CMultiLanguage, IID_IClassFactory, (LPVOID *)&pFactory));

    // Finally, create the object that I actually wanted
    CHECKHR(hr = pFactory->CreateInstance(NULL, IID_IMLangLineBreakConsole, (LPVOID *)ppLineBreak)); 

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csMLANG);

    // Cleanup
    SafeRelease(pFactory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrCreateInternetConverter
// --------------------------------------------------------------------------------
HRESULT HrCreateInternetConverter(LPCONVINITINFO pInitInfo, CInternetConverter **ppConverter)
{
    // Allocate It
    *ppConverter = new CInternetConverter();
    if (NULL == *ppConverter)
        return TrapError(E_OUTOFMEMORY);

    // Initialize
    return TrapError((*ppConverter)->HrInit(pInitInfo));
}

// --------------------------------------------------------------------------------
// BinHexCalcCRC16
// --------------------------------------------------------------------------------
void BinHexCalcCRC16( LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC )
{
    LPBYTE  lpb;
    BYTE    b;
    WORD    uCRC;
    WORD    fWrap;
    ULONG   i;

    uCRC = *wCRC;

    for ( lpb = lpbBuff; lpb < lpbBuff + cBuff; lpb++ )
    {
        b = *lpb;

        for ( i = 0; i < 8; i++ )
        {
            fWrap = uCRC & 0x8000;
            uCRC = (uCRC << 1) | (b >> 7);

            if ( fWrap )
            {
                uCRC = uCRC ^ 0x1021;
            }

            b = b << 1;
        }
    }

    *wCRC = uCRC;
}

// --------------------------------------------------------------------------------
// HrCreateMacBinaryHeader
// --------------------------------------------------------------------------------
HRESULT HrCreateMacBinaryHeader(LPCONVERTBUFFER prBinHexHeader, LPCONVERTBUFFER prMacBinaryHeader)
{
    HRESULT hr = S_OK;
    LPMACBINARY pmacbin;
    LPBYTE pbBinHex;
#ifndef _MAC
    WORD wCRC = 0;
#endif  // _MAC
    
    if ((NULL == prBinHexHeader) || (NULL == prMacBinaryHeader))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    
    pmacbin = (LPMACBINARY)(prMacBinaryHeader->pb);
    pbBinHex = (LPBYTE)(prBinHexHeader->pb);
    
    // Zero it out first
    ZeroMemory(pmacbin, sizeof(MACBINARY));

    // Write in the filename length
    pmacbin->cchFileName = (BYTE)min(pbBinHex[0], sizeof(pmacbin->rgchFileName)-1);
    pbBinHex += 1;
    
    // Copy over the filename
    CopyMemory(pmacbin->rgchFileName, pbBinHex, pmacbin->cchFileName);
    pmacbin->rgchFileName[pmacbin->cchFileName] = '\0';
    pbBinHex += pmacbin->cchFileName + 1;

    // Copy over the type and creator
    CopyMemory(&(pmacbin->dwType), pbBinHex, sizeof(pmacbin->dwType));
    pbBinHex += 4;
    
    CopyMemory(&(pmacbin->dwCreator), pbBinHex, sizeof(pmacbin->dwCreator));
    pbBinHex += 4;
    
    // Copy over the finder flags
    pmacbin->bFinderFlags = *pbBinHex;
    pbBinHex++;

    pmacbin->bFinderFlags2 = *pbBinHex;
    pbBinHex++;

    // Copy over the data fork length
    CopyMemory(&(pmacbin->lcbDataFork), pbBinHex, sizeof(pmacbin->lcbDataFork));
    pbBinHex += 4;
    
    // Copy over the resource fork length
    CopyMemory(&(pmacbin->lcbResourceFork), pbBinHex, sizeof(pmacbin->lcbResourceFork));
    pbBinHex += 4;

    // Drop on the version stamps
    pmacbin->bVerMacBin2 = 129;
    pmacbin->bMinVerMacBin2 = 129;

    // Calculate the CRC
#ifdef _MAC
    BinHexCalcCRC16((LPBYTE) pmacbin, 124, &(pmacbin->wCRC));
    BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(pmacbin->wCRC));
#else   // !_MAC
    BinHexCalcCRC16((LPBYTE) pmacbin, 124, &(wCRC));
    BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(wCRC));
    
    // Need to keep it in Mac order
    pmacbin->wCRC = HIBYTE(wCRC);
    pmacbin->wCRC |= (LOBYTE(wCRC) << 8);
#endif  // _MAC

    prMacBinaryHeader->cb += sizeof(MACBINARY);
    
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
CInternetConverter::CInternetConverter(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_cbConvert = 0;
    m_ietEncoding = IET_BINARY;
    m_cpiSource = CP_ACP;
    m_cpiDest = CP_ACP;
    m_fLastBuffer = FALSE;
    m_fEncoder = FALSE;
    m_uchPrev = '\0';
    m_pAppend = NULL;
    m_pWrite = NULL;
    m_convtype = ICT_UNKNOWN;
    m_cchMaxLine = 0;
    m_pBinhexEncode = NULL;
    m_eBinHexStateDec = sSTARTING;
    m_fRepeating = FALSE;
    m_cAccum = 0;
    m_prBinhexOutput = &m_rOut;
    m_cbToProcess = 0;
    m_cbDataFork = 0;
    m_cbResourceFork = 0;
    m_wCRC = 0;
    m_wCRCForFork = 0;
    m_fDataForkOnly = FALSE;
    m_pLineBreak = NULL;
    ZeroMemory(&m_rIn, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rOut, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rCset, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));
}

// --------------------------------------------------------------------------------
// CInternetConverter::~CInternetConverter
// --------------------------------------------------------------------------------
CInternetConverter::~CInternetConverter(void)
{
    if (m_pBinhexEncode)
        delete m_pBinhexEncode;
    SafeMemFree(m_rIn.pb);
    SafeMemFree(m_rOut.pb);
    SafeMemFree(m_rCset.pb);
    SafeMemFree(m_rBinhexHeader.pb);
    SafeRelease(m_pLineBreak);
}

// --------------------------------------------------------------------------------
// CInternetConverter::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetConverter::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CInternetConverter::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetConverter::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CInternetConverter::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetConverter::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInit
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInit(LPCONVINITINFO pInitInfo)
{
    // Locals
    HRESULT hr=S_OK;

    // Save Flags
    m_dwFlags = pInitInfo->dwFlags;

    // Save Format
    m_ietEncoding = pInitInfo->ietEncoding;

    // Save Source Code Page
    m_cpiSource = pInitInfo->cpiSource;

    // Save Dest Code Page
    m_cpiDest = pInitInfo->cpiDest;

    // Are we an encoder..
    m_fEncoder = pInitInfo->fEncoder;

    // Save Wrap Info
    m_cchMaxLine = pInitInfo->cchMaxLine;

    // Save MacBinary state
    m_fDataForkOnly = !pInitInfo->fShowMacBinary;
    
    // InitConvertType
    CHECKHR(hr = HrInitConvertType(pInitInfo));

    // DoubleCheck
    Assert(m_pWrite && m_pAppend && ICT_UNKNOWN != m_convtype);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInitConvertType
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInitConvertType(LPCONVINITINFO pInitInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    CODEPAGEINFO    CodePage;
    CODEPAGEID      cpiLCID;

    // Time to compute m_pAppend and m_pDump...
    if (ICF_WRAPTEXT & m_dwFlags)
    {
        // Check Assumptions
        Assert((IET_7BIT == m_ietEncoding || IET_8BIT == m_ietEncoding) && TRUE == m_fEncoder);

        // Code Page Conversion...
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_WRAPTEXT_CODEPAGE;
        else
            m_convtype = ICT_WRAPTEXT;

        // Load MLANG
        CHECKHR(hr = HrCreateLineBreaker(&m_pLineBreak));

        // Set cpiLCID
        cpiLCID = m_cpiSource;

        // Unicode ?
        if (CP_UNICODE == m_cpiSource)
        {
            // Get Destination Code Page Info
            if (SUCCEEDED(g_pInternat->GetCodePageInfo(m_cpiDest, &CodePage)))
            {
                // Set cpiLCID
                cpiLCID = CodePage.cpiFamily;
            }
        }

        // Map m_cpiSource to lcid
        switch(cpiLCID)
        {
            case 874:   m_lcid = 0x041E; break;
            case 932:   m_lcid = 0x0411; break;
            case 936:   m_lcid = 0x0804; break;
            case 949:   m_lcid = 0x0412; break;
            case 950:   m_lcid = 0x0404; break;
            case 1250:  m_lcid = 0x040e; break;
            case 1251:	m_lcid = 0x0419; break;
            case 1252:	m_lcid = 0x0409; break;
            case 1253:	m_lcid = 0x0408; break;
            case 1254:	m_lcid = 0x041f; break;
            case 1255:	m_lcid = 0x040d; break;
            case 1256:	m_lcid = 0x0401; break;
            case 1257:	m_lcid = 0x0426; break;
            default: m_lcid = GetSystemDefaultLCID(); break;
        }
    }

    // Otherwise, if encoding
    else if (TRUE == m_fEncoder)
    {
        // If CodePage Conversion
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_CODEPAGE_ENCODE;
        else
            m_convtype = ICT_ENCODE;

        // Need binhex encoder
        if (IET_BINHEX40 == m_ietEncoding)
        {
            // Create me an encoder
            CHECKALLOC(m_pBinhexEncode = new CBinhexEncoder);

            // Initialize
            CHECKHR(hr = m_pBinhexEncode->HrConfig(0, 0, &pInitInfo->rMacBinary));
        }
    }

    // Otherwise, if not encoding
    else
    {
        // If CodePage Conversion
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_DECODE_CODEPAGE;
        else
            m_convtype = ICT_DECODE;
    }

    // Map Write and Append Buffers from Conversion Type
    switch(m_convtype)
    {
    // m_rIn --> m_rCset
    case ICT_WRAPTEXT_CODEPAGE:
    case ICT_DECODE_CODEPAGE:           
        m_pAppend = &m_rIn;
        m_pWrite  = &m_rCset;
        break;

    // m_rIn --> m_rOut
    case ICT_WRAPTEXT:
    case ICT_ENCODE:
    case ICT_DECODE:       
        m_pAppend = &m_rIn;
        m_pWrite  = &m_rOut;
        break;

    // m_rCset --> m_rOut
    case ICT_CODEPAGE_ENCODE:
        m_pAppend = &m_rCset;
        m_pWrite  = &m_rOut;
        break;

    // Error
    default:
        AssertSz(FALSE, "INVALID INETCONVTYPE");
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrConvBuffAppendBlock
// --------------------------------------------------------------------------------
inline HRESULT CInternetConverter::HrConvBuffAppendBlock(LPBYTE pb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;

    // Do I need to grow
    if (FGROWBUFFER(&m_rOut, cb))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(&m_rOut, cb));
    }

    // Copy the buffer
    CopyMemory(m_rOut.pb + m_rOut.cb, pb, cb);

    // Increment Size
    m_rOut.cb += cb;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::PszConvBuffGetNextLine
// --------------------------------------------------------------------------------
inline LPSTR CInternetConverter::PszConvBuffGetNextLine(ULONG *pcbLine, ULONG *pcbRead, BOOL *pfFound)
{
    // Locals
    UCHAR       uchThis, uchPrev;
    ULONG       cbLine=0;

    // Invalid Arg
    Assert(pcbLine && pcbRead && pfFound);

    // Init
    *pfFound = FALSE;

    // Read to next \n
    while(m_rIn.i + cbLine < m_rIn.cb)
    {
        // Get a character...
        uchThis = m_rIn.pb[m_rIn.i + cbLine];

        // Better not be null
        Assert(uchThis);

        // Increment Line Length
        cbLine++;

        // Done
        if (chLF == uchThis)
        {
            *pfFound = TRUE;
            break;
        }

        // Remember Previous Char
        uchPrev = uchThis;
    }

    // Set Next Line
    *pcbRead = cbLine;

    // Fixup cbLine
    if (chLF == uchThis)
        cbLine--;
    if (chCR == uchPrev)
        cbLine--;

    // Set Length
    *pcbLine = cbLine;

    // Done
    return (LPSTR)(m_rIn.pb + m_rIn.i);
}

// --------------------------------------------------------------------------------
// CInternetConverter::CopyMemoryRemoveNBSP
// --------------------------------------------------------------------------------
void CInternetConverter::CopyMemoryRemoveNBSP(LPBYTE pbDest, LPBYTE pbSource, ULONG cbSource)
{
    // Locals
    ULONG       iDest=0;
    ULONG       iSource=0;

    // Invalid ARg
    Assert(pbDest && pbSource && CP_UNICODE == m_cpiSource);

    // Do It
    while(1)
    {
        // If not a null lead, copy next two bytes...
        if (iSource + 1 < cbSource)
        {
            // Better not be 0x00A0 - insert space
            Assert(iSource % 2 == 0);
            if (0xA0 == pbSource[iSource] && 0x00 == pbSource[iSource + 1])
            {
                // 0x0020 = Space
                pbDest[iDest++] = 0x20;
                pbDest[iDest++] = 0x00;

                // Step Over this character...
                iSource+=2;
            }

            // Otherwise, copy the character
            else
            {
                // Copy This Char
                pbDest[iDest++] = pbSource[iSource++];

                // Copy Next Char
                if (iSource < cbSource)
                    pbDest[iDest++] = pbSource[iSource++];
            }
        }

        // Otherwise, just copy this once character and stop
        else
        {
            // Copy It
            if (iSource < cbSource)
                pbDest[iDest++] = pbSource[iSource++];

            // Done
            break;
        }
    }
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrFillAppend
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrFillAppend(LPBLOB pData)
{
    // Locals
    HRESULT hr=S_OK;

    // Invlaid ARg
    Assert(pData && m_pAppend);

    // Call Internal Function
    CHECKHR(hr = HrAppendBuffer(m_pAppend, pData, (m_dwFlags & ICF_KILLNBSP)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrAppendBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrAppendBuffer(LPCONVERTBUFFER pBuffer, LPBLOB pData, BOOL fKillNBSP)
{
    // Locals
    HRESULT hr=S_OK;

    // Collapse Current Buffer
    if (pBuffer->i != 0)
    {
        // Move Memory
        MoveMemory(pBuffer->pb, pBuffer->pb + pBuffer->i, pBuffer->cb - pBuffer->i);

        // Decrease Size
        pBuffer->cb -= pBuffer->i;

        // Reset Start
        pBuffer->i = 0;
    }

    // Enought Space ?
    // Do I need to grow
    if (FGROWBUFFER(pBuffer, pData->cbSize))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(pBuffer, pData->cbSize));
    }
    
    // Append the buffer...
    if (fKillNBSP)
        CopyMemoryRemoveNBSP(pBuffer->pb + pBuffer->cb, pData->pBlobData, pData->cbSize);

    // Otherwise, this is a simple copy
    else
        CopyMemory(pBuffer->pb + pBuffer->cb, pData->pBlobData, pData->cbSize);

    // Increment Amount of Data
    pBuffer->cb += pData->cbSize;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrGrowBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrGrowBuffer(LPCONVERTBUFFER pBuffer, ULONG cbAppend)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbGrow;

    // Better need a grow
    Assert(FGROWBUFFER(pBuffer, cbAppend));

    // Compute Grow By
    cbGrow = (cbAppend - (pBuffer->cbAlloc - pBuffer->cb)) + 256;

    // Realloc the buffer
    CHECKHR(hr = HrRealloc((LPVOID *)&pBuffer->pb, pBuffer->cbAlloc + cbGrow));

    // Adjust cbAlloc
    pBuffer->cbAlloc += cbGrow;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWriteConverted
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWriteConverted(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Anything to write
    if (m_pWrite->cb)
    {
        // Write the current block
        CHECKHR(hr = pStream->Write(m_pWrite->pb, m_pWrite->cb, NULL));

        // Nothing in m_rOut
        m_pWrite->cb = 0;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWriteConverted
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWriteConverted(CInternetConverter *pConverter)
{
    // Locals
    HRESULT     hr=S_OK;
    BLOB        rData;

    // Anything to write
    if (m_pWrite->cb)
    {
        // Setup Blob
        rData.pBlobData = m_pWrite->pb;
        rData.cbSize = m_pWrite->cb;

        // Write the current block
        CHECKHR(hr = pConverter->HrFillAppend(&rData));

        // Nothing in m_rOut
        m_pWrite->cb = 0;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInternetEncode
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInternetEncode(BOOL fLastBuffer)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;

    // We Better be an encoder
    Assert(m_fEncoder);

    // Set Last Buffer
    m_fLastBuffer = fLastBuffer;

    // Text Wrapping ?
    if (ICF_WRAPTEXT & m_dwFlags)
    {
        // Wrap It: m_rIn -> m_rOut
        if (CP_UNICODE == m_cpiSource)
            CHECKHR(hr = HrWrapInternetTextW());
        else
            CHECKHR(hr = HrWrapInternetTextA());

        // Character Set Encoding: m_rOut -> m_rCset
        if (ICF_CODEPAGE & m_dwFlags)
        {
            // Charset Encode
            CHECKHR(hr = HrCodePageFromOutToCset());
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }
    }

    // Otherwise
    else
    {
        // Character Set Encoding: m_rCset -> m_rIn
        if (ICF_CODEPAGE & m_dwFlags)
        {
            // Charset Encode
            CHECKHR(hr = HrCodePageFromCsetToIn());
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Handle Conversion type
        switch(m_ietEncoding)
        {
        // Binary
        case IET_BINARY:
        case IET_7BIT:
        case IET_8BIT:
            // Better be at zero
            Assert(m_rIn.i == 0);

            // Initialize Blob to copy
            rData.pBlobData = m_rIn.pb;
            rData.cbSize = m_rIn.cb;

            // Append to outbound buffer
            CHECKHR(hr = HrAppendBuffer(&m_rOut, &rData, FALSE));

            // Increment offset
            m_rIn.i = m_rIn.cb = 0;
            break;

        // Quoted-Printable
        case IET_QP:
            CHECKHR(hr = HrEncodeQP());
            break;

        // Bas 64
        case IET_BASE64:
            CHECKHR(hr = HrEncode64());
            break;

        // UUENCODE
        case IET_UUENCODE:
            CHECKHR(hr = HrEncodeUU());
            break;

        // BINHEX
        case IET_BINHEX40:
#ifdef NEVER
            CHECKHR(hr = HrEncodeBinhex());
#endif  // NEVER
            // IE v. 5.0:33596 HrEncodeBinhex returns E_FAIL if body size is too small
            // Binhex encoding doesn't currently work.  I believe that it should work (or almost work)
            // if the header CBinhexEncoder::m_lpmacbinHdr is initialized properly.  However, this
            // requires understanding the Mac file format and parsing the body stream contents into
            // data and resource forks.
            // - sethco 8/19/1998
            CHECKHR(hr = MIME_E_INVALID_ENCODINGTYPE);
            break;

        // Bummer
        default:
            AssertSz(FALSE, "MIME_E_INVALID_ENCODINGTYPE");
            break;
        }
    }

exit:
    // If Last Buffer, we better be done
    Assert(m_fLastBuffer ? m_rIn.i == m_rIn.cb : TRUE);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInternetDecode
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInternetDecode(BOOL fLastBuffer)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;

    // We Better not be an encoder
    Assert(!m_fEncoder);

    // Set Last Buffer
    m_fLastBuffer = fLastBuffer;

    // Handle Format
    switch(m_ietEncoding)
    {
    // Binary
    case IET_BINARY:
    case IET_7BIT:
    case IET_8BIT:
        // Better be at zero
        Assert(m_rIn.i == 0);

        // Initialize Blob to copy
        rData.pBlobData = m_rIn.pb;
        rData.cbSize = m_rIn.cb;

        // Append to outbound buffer
        CHECKHR(hr = HrAppendBuffer(&m_rOut, &rData, FALSE));

        // Increment offset
        m_rIn.i = m_rIn.cb = 0;
        break;

    // Quoted-Printable
    case IET_QP:
        CHECKHR(hr = HrDecodeQP());
        break;

    // Bas64
    case IET_BASE64:
        CHECKHR(hr = HrDecode64());
        break;

    // UUENCODE
    case IET_UUENCODE:
        CHECKHR(hr = HrDecodeUU());
        break;

    // BINHEX
    case IET_BINHEX40:
        CHECKHR(hr = HrDecodeBinHex());
        break;

    // Bummer
    default:
        AssertSz(FALSE, "MIME_E_INVALID_ENCODINGTYPE");
        break;
    }

    // Character Set Decoding ?
    if (ICF_CODEPAGE & m_dwFlags)
    {
        // Charset Decoder
        CHECKHR(hr = HrCodePageFromOutToCset());
        if ( S_OK != hr )
           hrWarnings = TrapError(hr);
    }

exit:
    // If Last Buffer, we better be done
    Assert(m_fLastBuffer ? m_rIn.i == m_rIn.cb : TRUE);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrCodePageFromOutToCset
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrCodePageFromOutToCset(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;
    BLOB        rDecoded={0};
    ULONG       cbRead;

    // Nothing to convert...
    if (0 == m_rOut.cb)
        return S_OK;

    // Setup Convert Blob
    rData.pBlobData = m_rOut.pb;
    rData.cbSize = m_rOut.cb;

    // Decode text from m_intformat
    hr = g_pInternat->ConvertBuffer(m_cpiSource, m_cpiDest, &rData, &rDecoded, &cbRead);
    if (SUCCEEDED(hr) )
    {
        // save HRESULT from charset conversion
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill m_rIn...
        CHECKHR(hr = HrAppendBuffer(&m_rCset, &rDecoded, FALSE));
    }

    // Otherwise, just put m_rCset as the inbound buffer
    else
    {
        // SBAILEY: Raid-74506: MIMEOLE: error decoding text body in q-p encoded iso-2022-jp message
        // CHECKHR(hr = HrAppendBuffer(&m_rCset, &rData, FALSE));
        hr = S_OK;

        // We read all of it
        cbRead = rData.cbSize;
    }

    // Adjust m_rOut if cbRead != m_rOut.cb
    if (cbRead != m_rOut.cb)
    {
        // Move Memory
        MoveMemory(m_rOut.pb, m_rOut.pb + cbRead, m_rOut.cb - cbRead);
    }

    // Decrease Size
    Assert(cbRead <= m_rOut.cb);
    m_rOut.cb -= cbRead;

exit:
    // Cleanup
    SafeMemFree(rDecoded.pBlobData);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrCodePageFromCsetToIn
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrCodePageFromCsetToIn(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;
    BLOB        rEncoded={0};
    ULONG       cbRead;

    // Check State
    Assert(m_rCset.i == 0);

    // Nothing to convert
    if (0 == m_rCset.cb)
        return S_OK;

    // Setup Convert Blob
    rData.pBlobData = m_rCset.pb;
    rData.cbSize = m_rCset.cb;

    // Decode text from m_intformat
    hr = g_pInternat->ConvertBuffer(m_cpiSource, m_cpiDest, &rData, &rEncoded, &cbRead);
    if (SUCCEEDED(hr) )
    {
        // save HRESULT from charset conversion
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill m_rIn...
        CHECKHR(hr = HrAppendBuffer(&m_rIn, &rEncoded, FALSE));
    }

    // Otherwise, just put m_rCset as the inbound buffer
    else
    {
        // SBAILEY: Raid-74506: MIMEOLE: error decoding text body in q-p encoded iso-2022-jp message
        // CHECKHR(hr = HrAppendBuffer(&m_rIn, &rData, FALSE));
        hr = S_OK;

        // Set Read
        cbRead = m_rCset.cb;
    }

    // Adjust m_rOut if cbRead != m_rOut.cb
    if (cbRead != m_rCset.cb)
    {
        // Move Memory
        MoveMemory(m_rCset.pb, m_rCset.pb + cbRead, m_rCset.cb - cbRead);
    }

    // Decrease Size
    Assert(cbRead <= m_rCset.cb);
    m_rCset.cb -= cbRead;
    m_rCset.i = 0;

exit:
    // Cleanup
    SafeMemFree(rEncoded.pBlobData);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncode64
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncode64(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;
    ULONG       i;
    UCHAR       uch[3];
    UCHAR      *pbuf;

    // Read lines and stuff dots
    while(1)
    {
        // Compute encode buffer length
        cbRead = min(CCHMAX_ENCODE64_IN, m_rIn.cb - m_rIn.i);

        // Should we encode this buffer ?
        if (0 == cbRead || (cbRead < CCHMAX_ENCODE64_IN && FALSE == m_fLastBuffer))
            goto exit;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODE64_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODE64_OUT));
        }

        // Set Buffer Pointer
        pbuf = (m_rIn.pb + m_rIn.i);

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            // Setup Buffer
            uch[0] = pbuf[i];
            uch[1] = (i+1 < cbRead) ? pbuf[i+1] : '\0';
            uch[2] = (i+2 < cbRead) ? pbuf[i+2] : '\0';

            // Encode first tow
            ConvBuffAppend(g_rgchEncodeBase64[(uch[0] >> 2) & 0x3F]);
            ConvBuffAppend(g_rgchEncodeBase64[(uch[0] << 4 | uch[1] >> 4) & 0x3F]);

            // Encode Next
            if (i+1 < cbRead)
                ConvBuffAppend(g_rgchEncodeBase64[(uch[1] << 2 | uch[2] >> 6) & 0x3F]);
            else
                ConvBuffAppend('=');

            // Encode Net
            if (i+2 < cbRead)
                ConvBuffAppend(g_rgchEncodeBase64[(uch[2] ) & 0x3F]);
            else
                ConvBuffAppend('=');
        }

        // Increment iIn
        m_rIn.i += cbRead;

        // Ends encoded line and writes to storage
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecode64
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecode64(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    ULONG       i;
    ULONG       cPad=0;
    ULONG       cbRead=0;
    ULONG       cbLine;
    BOOL        fFound;
    LPSTR       pszLine;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
            goto exit;

        // Do I need to grow - decoded line will always be smaller than cbLine
        if (FGROWBUFFER(&m_rOut, cbLine))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cbLine));
        }

        // Decodes characters in line buffer
        for (i=0; i<cbLine; i++)
        {
            // Gets 4 legal Base64 characters, ignores if illegal
            uchThis = pszLine[i];

            // Decode It
            m_uchConvert[m_cbConvert] = DECODE64(uchThis);

            // Test for valid non-pad
            if ((m_uchConvert[m_cbConvert] < 64) || ((uchThis == '=') && (m_cbConvert > 1)))
                m_cbConvert++;

            // Test for pad
            if ((uchThis == '=') && (m_cbConvert > 1))
                cPad++;

            // Outputs when 4 legal Base64 characters are in the buffer
            if (4 == m_cbConvert)
            {
                // Validate Buffer
                Assert(m_rOut.cb + 4 <= m_rOut.cbAlloc);

                // Convert
                if (cPad < 3)
                    ConvBuffAppend((m_uchConvert[0] << 2 | m_uchConvert[1] >> 4));
                if (cPad < 2)
                    ConvBuffAppend((m_uchConvert[1] << 4 | m_uchConvert[2] >> 2));
                if (cPad < 1)
                    ConvBuffAppend((m_uchConvert[2] << 6 | m_uchConvert[3]));

                // Reset
                m_cbConvert = 0;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeUU
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncodeUU(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead, i;
    UCHAR       buf[CCHMAX_ENCODEUU_IN];

    // Read lines and stuff dots
    while(1)
    {
        // Compute encode buffer length
        cbRead = min(CCHMAX_ENCODEUU_IN, m_rIn.cb - m_rIn.i);
        if (0 == cbRead || (cbRead < CCHMAX_ENCODEUU_IN && FALSE == m_fLastBuffer))
            goto exit;

        // Copy the bytes
        CopyMemory(buf, m_rIn.pb + m_rIn.i, cbRead);

        // Zero the Rest
        ZeroMemory(buf + cbRead, sizeof(buf) - cbRead);

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODEUU_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODEUU_OUT));
        }

        // Encode Line length
        ConvBuffAppend(UUENCODE((UCHAR)cbRead));

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            ConvBuffAppend(UUENCODE((buf[i] >> 2)));
            ConvBuffAppend(UUENCODE((buf[i] << 4) | (buf[i+1] >> 4)));
            ConvBuffAppend(UUENCODE((buf[i+1] << 2) | (buf[i+2] >> 6)));
            ConvBuffAppend(UUENCODE((buf[i+2])));
        }                                   

        // Increment i
        m_rIn.i += cbRead;

        // Ends encoded line and writes to storage
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

exit:
    // If last buffer and we can't read anymore
    if (TRUE == m_fLastBuffer && FALSE == FConvBuffCanRead(m_rIn))
    {
        // RAID-21179: ZeroLength uuencoded attachments m_rOut may not have been allocated
        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODEUU_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODEUU_OUT));
        }

        // Better have space
        Assert(m_rOut.cb + 3 < m_rOut.cbAlloc);

        // End
        ConvBuffAppend(UUENCODE(0));
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::FUUEncodeThrowAway
// --------------------------------------------------------------------------------
BOOL CInternetConverter::FUUEncodeThrowAway(LPSTR pszLine, ULONG cbLine, ULONG *pcbActual, ULONG *pcbLine)
{
    // Locals
    CHAR    ch;
    ULONG   cchOffset, cbEncoded, cbTolerance=0, cbExpected;

    // RAID-25953: "BEGIN --- CUT HERE --- Cut Here --- cut here ---" - WinVN post
    //             partial messages that have the following line at the beginning of
    //             each partial. B = 66 and the length of this line is 48, so the following
    //             code thinks that this line is a valid UUENCODED line, so, to fix this,
    //             we will throw out all lines that start with BEGIN since this is not valid
    //             to be in uuencode.
    if (StrCmpNI("BEGIN", pszLine, 5) == 0)
        return TRUE;

    // END Line
    else if (StrCmpNI("END", pszLine, 3) == 0)
        return TRUE;

    // Checks line length
    ch = *pszLine;
    *pcbLine = cbEncoded = UUDECODE(ch);

    // Comput tolerance and offset for non-conforming even line lengths
    cchOffset = (cbEncoded % 3);
    if (cchOffset != 0) 
    {
        cchOffset++;
        cbTolerance = 4 - cchOffset;
    }

    // Compute expected line length
    cbExpected = 4 * (cbEncoded / 3) + cchOffset; 

    // Always check for '-'
    if (cbLine < cbExpected)
        return TRUE;

    // Wack off trailing spaces
    while(pszLine[cbLine-1] == ' ' && cbLine > 0 && cbLine != cbExpected)
        --cbLine;

    // Checksum character and encoders which include the count char in the line count
    if (cbExpected != cbLine && cbExpected + cbTolerance != cbLine &&
        cbExpected + 1 != cbLine && cbExpected + cbTolerance + 1 != cbLine &&
        cbExpected - 1 != cbLine && cbExpected + cbTolerance - 1 != cbLine)
        return TRUE;

    // Set actual line length
    *pcbActual = cbLine;

    // Done
    return FALSE;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeUU
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeUU(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbLine;
    LPSTR       pszLine;
    ULONG       cbRead=0;
    ULONG       cbLineLength;
    BOOL        fFound;
    ULONG       cbConvert;
    ULONG       cbScan;
    ULONG       i;
    UCHAR       uchConvert[4];
    UCHAR       uchThis;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
            goto exit;

        // UUENCODE ThrowAway
        if (FUUEncodeThrowAway(pszLine, cbLine, &cbLine, &cbLineLength))
            continue;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, cbLineLength + 20))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cbLineLength + 20));
        }

        // Decodes 4 characters at a time
        for (cbConvert=0, cbScan=0, i=1; cbScan < cbLineLength; i++)
        {
            // Gets 4 characters, pads with blank if necessary
            uchThis = (i < cbLine) ? pszLine[i] : ' ';

            // Decode
            uchConvert[cbConvert++] = UUDECODE(uchThis);

            // Outputs decoded characters
            if (cbConvert == 4)
            {
                // Covnert
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[0] << 2) | (uchConvert[1] >> 4));
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[1] << 4) | (uchConvert[2] >> 2));
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[2] << 6) | (uchConvert[3]));

                // Reset
                cbConvert = 0;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeQP
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncodeQP(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    ULONG       cbLine=0;
    ULONG       iCurrent;
    LONG        iLastWhite=-1;
    LONG        iLineWhite=-1;
    UCHAR       szLine[CCHMAX_QPLINE+30];

    // Set iCurrent
    iCurrent = m_rIn.i;

    // Read lines and stuff dots
    while (iCurrent < m_rIn.cb)
    {
        // Gets the next character
        uchThis = m_rIn.pb[iCurrent];

        // End of line...
        if (chLF == uchThis || cbLine > CCHMAX_QPLINE)
        {
            // Soft Line break
            if (chLF != uchThis)
            {
                // Lets back track to last white
                if (iLastWhite != -1)
                {
                    cbLine = iLineWhite + 1;
                    iCurrent = iLastWhite + 1;
                }

                // Hex encode the 8bit octet
                Assert(cbLine + 3 <= sizeof(szLine));
                szLine[cbLine++] = '=';
                szLine[cbLine++] = chCR;
                szLine[cbLine++] = chLF;
            }

            // Otherwise, we may need to encode the last space
            else
            {
                // Encode Straggling '\n'
                if (chCR != m_uchPrev)
                {
                    Assert(cbLine + 4 <= sizeof(szLine));
                    szLine[cbLine++] = '=';
                    szLine[cbLine++] = g_rgchHex[uchThis >> 4];
                    szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
                    szLine[cbLine++] = '=';
                }

                // Detect preceding whitespace ...
                if (cbLine && (' ' == szLine[cbLine - 1] || '\t' == szLine[cbLine - 1]))
                {
                    // Hex encode the 8bit octet
                    UCHAR chWhite = szLine[cbLine - 1];
                    cbLine--;
                    Assert(cbLine + 3 <= sizeof(szLine));
                    szLine[cbLine++] = '=';
                    szLine[cbLine++] = g_rgchHex[chWhite >> 4];
                    szLine[cbLine++] = g_rgchHex[chWhite & 0x0F];
                }

                // Otherwise, hard line break
                Assert(cbLine + 2 <= sizeof(szLine));
                szLine[cbLine++] = chCR;
                szLine[cbLine++] = chLF;
                iCurrent++;
            }

            // Copy the line
            CHECKHR(hr = HrConvBuffAppendBlock(szLine, cbLine));

            // Reset
            iLastWhite = -1;
            iLineWhite = -1;
            cbLine = 0;
            *szLine = '\0';

            // We processed this buffer
            m_rIn.i = iCurrent;
        }

        // Encode empty '\r'
        else if (chCR == uchThis)
        {
            // Overflow detection
            if (iCurrent + 1 < m_rIn.cb && m_rIn.pb[iCurrent + 1] != chLF || iCurrent + 1 >= m_rIn.cb)
            {
                Assert(cbLine + 3 <= sizeof(szLine));
                szLine[cbLine++] = '=';
                szLine[cbLine++] = g_rgchHex[uchThis >> 4];
                szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
            }

            // Next Character
            iCurrent++;
        }

        // Rule #1: Replace 8-bit and equal signs
        else if (('\t' != uchThis) && (uchThis < 32 || uchThis == 61 || uchThis > 126 || '=' == uchThis))
        {
            // Hex encode the 8bit octet
            Assert(chLF != uchThis);
            Assert(cbLine + 3 <= sizeof(szLine));
            szLine[cbLine++] = '=';
            szLine[cbLine++] = g_rgchHex[uchThis >> 4];
            szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
            iCurrent++;
        }

        // Otherwise, write the character
        else
        {
            // Save position of last white space
            if (' ' == uchThis || '\t' == uchThis)
            {
                iLastWhite = iCurrent;
                iLineWhite = cbLine;
            }

            // Rule #2: Printable literals
            Assert(cbLine + 1 <= sizeof(szLine));
            szLine[cbLine++] = uchThis;
            iCurrent++;
        }

        // Save Previous Char
        m_uchPrev = uchThis;
    }

    // Last line
    if (cbLine && m_fLastBuffer)
    {
        // Append the Line
        CHECKHR(hr = HrConvBuffAppendBlock(szLine, cbLine));

        // Set i
        m_rIn.i = m_rIn.cb;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeQP
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeQP(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    UCHAR       uchNext1;
    UCHAR       uchNext2;
    UCHAR       uch1;
    UCHAR       uch2;

    // Read lines and stuff dots
    while (FConvBuffCanRead(m_rIn))
    {
        // bug #35230 - display trash in trident
		// Can I read 2 more characters
		if (FALSE == m_fLastBuffer && m_rIn.i + 2 >= m_rIn.cb)
			break;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, 3))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, 3));
        }

        // Gets the next character
        uchThis = m_rIn.pb[m_rIn.i];

        // Determine next couple of characers for end of line detection...
        uchNext1 = (m_rIn.i + 1 < m_rIn.cb) ? m_rIn.pb[m_rIn.i + 1] : '\0';
        uchNext2 = (m_rIn.i + 2 < m_rIn.cb) ? m_rIn.pb[m_rIn.i + 2] : '\0';

        // Dont break on \r\n
        if (chCR == uchNext1 && chLF == uchNext2 && m_rIn.i + 3 >= m_rIn.cb)
        {
            // If last buffer, then save characters
            if (m_fLastBuffer)
            {
                // If not a soft line break
                if ('=' != uchThis)
                {
                    ConvBuffAppend(uchThis);
                    ConvBuffAppend(chCR);
                    ConvBuffAppend(chLF);
                }

                // Done
                m_rIn.i += 3;
            }

            // Done
            goto exit;
        }

        // If not end of line...
        if ('=' == uchThis)
        {
            // Soft NL
            if (chCR == uchNext1 && chLF == uchNext2)
            {
                // Step over =\r\n
                m_rIn.i += 3;
            }

            // If not end of line...
            else if (m_rIn.i + 2 < m_rIn.cb)
            {
                // Step Over Equal Sign
                m_rIn.i++;

                // Convert Hex Characters
                uch1 = ChConvertFromHex(m_rIn.pb[m_rIn.i++]);
                uch2 = ChConvertFromHex(m_rIn.pb[m_rIn.i++]);

                // Store Hex characters 
                if (uch1 == 255 || uch2 == 255) 
                    ConvBuffAppend('=');
                else 
                    ConvBuffAppend((uch1 << 4) | uch2);
            }

            else
            {
                // Last Buffer ?
                ConvBuffAppend(uchThis);
                m_rIn.i++;
            }
        }

        // Otherwise store the character
        else if (chCR == uchThis && chLF == uchNext1)
        {
            // Stuff CRLF
            ConvBuffAppend(chCR);
            ConvBuffAppend(chLF);

            // Increment i
            m_rIn.i += 2;
        }

        // Otherwise, store the character
        else
        {
            ConvBuffAppend(uchThis);
            m_rIn.i++;
        }

        // Set Previous
        m_uchPrev = uchThis;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWrapInternetTextA
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWrapInternetTextA(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LONG        cchLine;
    LONG        cchSkip;

    // Read lines and stuff dots
    while(FConvBuffCanRead(m_rIn))
    {
        // Not enough to encode a full line and not the last buffer
        if ((FALSE == m_fLastBuffer) && ((LONG)(m_rIn.cb - m_rIn.i) < m_cchMaxLine))
            goto exit;

        // Call LineBreaker
        if (*((CHAR*)(m_rIn.pb + m_rIn.i)) == '\0')
        {
            // This is to prevent the endless loop in case of malformed data stream
            hr = TrapError(MIME_E_BAD_TEXT_DATA);
            goto exit;
        }
		
		CHECKHR(hr = m_pLineBreak->BreakLineA(m_lcid, m_cpiSource, (LPCSTR)(m_rIn.pb + m_rIn.i), (m_rIn.cb - m_rIn.i), m_cchMaxLine, &cchLine, &cchSkip));

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, cchLine + 5))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cchLine + 5));
        }
    
        // Have some data ?
        if (cchLine)
        {
            // Write the line
            CHECKHR(hr = HrConvBuffAppendBlock(m_rIn.pb + m_rIn.i, cchLine));
        }

        // Write CRLF
        Assert(m_rOut.cb + 2 < m_rOut.cbAlloc);
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);

        // Increment iText
        m_rIn.i += (cchLine + cchSkip);
    }

exit:
    // Done
    return hr;
}

HRESULT CInternetConverter::_GetEndOfURL(IN LPCWSTR pszLine, DWORD cchSize, DWORD * pdwMax)
{
    HRESULT hr = S_OK;
    DWORD cchCurrent = 0;

    for (cchCurrent = 0; cchCurrent < cchSize; cchCurrent++)
    {
        if ((L' ' == pszLine[cchCurrent]) ||
            (L'\r' == pszLine[cchCurrent]))
        {
            (*pdwMax) = (cchCurrent + 2);
            break;
        }
    }

    return hr;
}


HRESULT CInternetConverter::_FixLineBreakingProblems(
    IN LCID locale, IN const WCHAR* pszSrc, 
    IN long cchSrc, IN long cMaxColumns, 
    OUT long* pcchLine, OUT long* pcchSkip,
    BOOL * pfDoURLFix)
{
    HRESULT hr = S_OK;

    // There was a bug where a signature marker, which is '-- '
    // (dash, dash, space, end-of-line) would get stripped out.
    // This happens in ILineBreak::BreakLineW().  It will strip off
    // the extra space thinking it is just extra white space.
    if ((3 <= cchSrc) &&
        (m_rIn.cb >= 10) &&
        (2 <= *pcchLine) &&
        (1 <= *pcchSkip) && 
        (L'-' == pszSrc[*pcchLine - 2]) && 
        (L'-' == pszSrc[*pcchLine - 1]) && 
        (L' ' == pszSrc[*pcchLine - 0]))
    {
        (*pcchLine)++;
        (*pcchSkip)--;
//        DebugTrace("MimeOLE - Sig Delimiter: Preserved.\n");
    }

    // We do not want to wrap if that causes a break in URLs.
    // This is bad because when the receiver's newsgroup reader
    // turns the URL into a hyperlink, it will no longer point
    // to the right location because part of the URL is missing.
    // This happens often with urls that contain '=' or '/', like:
    // http://www.amazon.com/exec/obidos/ASIN/B0000633EM/qid=1027792220/sr=8-3/ref=sr_8_3/104-5930498-2421552
    // http://www.amazon.com/exec/obidos/tg/stores/detail/-/electronics/B0000633EM/reviews/ref=e_wlt1_de_a_er/104-5930498-2421552#
    if ((5 <= *pcchLine) &&
        (cchSrc > *pcchLine) &&    // Make sure this isn't the end of the line.
        (L' ' != pszSrc[*pcchLine]) &&
        (L'\r' != pszSrc[*pcchLine]))    // We worry if the char after this break isn't a space.
    {
        WCHAR szUrl[50];    // We only need the first part.
        WCHAR szScheme[30];
        DWORD cchScheme = ARRAYSIZE(szScheme);

        StrCpyNW(szUrl, pszSrc, (int) min(ARRAYSIZE(szUrl), *pcchLine));
        HRESULT hrUrlPart = UrlGetPartW(szUrl, szScheme, &cchScheme, URL_PART_SCHEME, 0);
        if ((S_OK == hrUrlPart) &&
            szScheme[0] &&
            (!StrCmpIW(szScheme, L"http") ||
             !StrCmpIW(szScheme, L"https") ||
             !StrCmpIW(szScheme, L"mailto") ||
             !StrCmpIW(szScheme, L"file") ||
             !StrCmpIW(szScheme, L"news") ||
             !StrCmpIW(szScheme, L"nntp") ||
             !StrCmpIW(szScheme, L"telnet") ||
             !StrCmpIW(szScheme, L"ftp")))
        {
            *pfDoURLFix = TRUE;
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWrapInternetTextW
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWrapInternetTextW(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LONG        cchLine;
    LONG        cchSkip;
    LPCWSTR     pszNext = NULL;
    BOOL        fFollowingURLFix = FALSE;

    // Invalid State
    Assert(m_pLineBreak);

    // Read lines and stuff dots
    while(FConvBuffCanRead(m_rIn))
    {
        DWORD cchCurrentLineLen = ((m_rIn.cb - m_rIn.i) / sizeof(WCHAR));

        pszNext = (LPCWSTR)(m_rIn.pb + m_rIn.i);

        // Not enough to encode a full line and not the last buffer
        if ((FALSE == m_fLastBuffer) && ((LONG)cchCurrentLineLen < m_cchMaxLine))
            goto exit;

        // Call LineBreaker
        if (pszNext[0] == L'\0')
        {
            // This is to prevent the endless loop in case of malformed data stream
            hr = TrapError(MIME_E_BAD_TEXT_DATA);
            goto exit;
        }

        DWORD cchMax = m_cchMaxLine;

        if (fFollowingURLFix)
        {
            _GetEndOfURL(pszNext, cchCurrentLineLen, &cchMax);
            fFollowingURLFix = FALSE;
        }

        CHECKHR(hr = m_pLineBreak->BreakLineW(m_lcid, pszNext, cchCurrentLineLen, cchMax, &cchLine, &cchSkip));

        BOOL fDoURLFix = FALSE;
        _FixLineBreakingProblems(m_lcid, pszNext, cchCurrentLineLen, m_cchMaxLine, &cchLine, &cchSkip, &fDoURLFix);

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, ((cchLine + 5) * sizeof(WCHAR))))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, ((cchLine + 5) * sizeof(WCHAR))));
        }

        // Have some data
        if (cchLine)
        {
            // Write the line
            CHECKHR(hr = HrConvBuffAppendBlock((BYTE *) pszNext, (cchLine * sizeof(WCHAR))));
        }

        // Write CRLF
        Assert(m_rOut.cb + (2 * sizeof(WCHAR)) < m_rOut.cbAlloc);
        if (!fDoURLFix)
        {
            ConvBuffAppendW(wchCR);
            ConvBuffAppendW(wchLF);
        }
        else
        {
            fFollowingURLFix = TRUE;
        }

        // Increment iText
        m_rIn.i += ((cchLine + cchSkip) * sizeof(WCHAR));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeDecodeBinhex
// --------------------------------------------------------------------------------
const CHAR szBINHEXSTART[] = "(This file must be converted with BinHex";
const ULONG cbBINHEXSTART = ARRAYSIZE(szBINHEXSTART)-1;
HRESULT CInternetConverter::HrEncodeBinhex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrError;
    ULONG       cbLeft;
    ULONG       cbRead;
    ULONG       cbMaxEncode;
    ULONG       cbWrite;

    // cbLeft
    cbLeft = m_rIn.cb - m_rIn.i;

    // cbMaxEncode - this should always insure enough room
    cbMaxEncode = cbLeft * 2;

    // Do I need to grow
    if (FGROWBUFFER(&m_rOut, cbMaxEncode))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(&m_rOut, cbMaxEncode));
    }

    // Set max amount to read
    cbRead = cbLeft;

    // Set max amount to write
    cbWrite = cbLeft;

    // We better want to read some
    Assert(cbRead && cbWrite);

    // Encode/Decode some data
    if (m_fEncoder)
    {
        // Encode
        if (ERROR_SUCCESS != m_pBinhexEncode->HrEmit(m_rIn.pb + m_rIn.i, &cbRead, m_rOut.pb + m_rOut.cb, &cbWrite))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Increment Amount Read
    m_rIn.i += cbRead;

    // Increment Amount Wrote
    m_rOut.cb += cbWrite;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrBinhexThrowAway
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrBinhexDecodeBuffAppend(UCHAR uchIn, ULONG cchIn, ULONG cchLeft, ULONG * pcbProduced)
{
    HRESULT hr = S_FALSE;
    ULONG   cbPad = 0;
    LPBYTE  pbBinHex = NULL;
    
    if (m_eBinHexStateDec == sHDRFILESIZE)
    {
        // First incoming character is always the size of the stream.
        Assert(cchIn == 1);
        if ((uchIn < 1) || (uchIn > 63))
        {
            hr = E_FAIL; // ERROR_INVALID_DATA
            m_eBinHexStateDec = sENDED;
            goto exit;
        }

        // Allocate the binhex header
        if (FGROWBUFFER(&m_rBinhexHeader, cbMinBinHexHeader + uchIn))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cbMinBinHexHeader + uchIn));
        }
        
        // Mark how many characters are left to process
        m_cbToProcess = cbMinBinHexHeader + uchIn;
        
        // Switch to filling the header sHEADER
        m_prBinhexOutput = &m_rBinhexHeader;
        m_eBinHexStateDec = sHEADER;
    }

    if (1 == cchIn)
    {
        m_prBinhexOutput->pb[m_prBinhexOutput->cb++] = uchIn;
    }
    else
    {
        // Check output buffer for space
        if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
        }

        // Fill output buffer
        FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn, uchIn);
        m_prBinhexOutput->cb += cchIn;
    }

    // Are we done processing this fork?
    if (m_cbToProcess <= (LONG) cchIn)
    {
        switch (m_eBinHexStateDec)
        {
        case sHEADER:
            // Verify that we have the correct CRC
            m_wCRC = 0;
            
            BinHexCalcCRC16((LPBYTE) m_rBinhexHeader.pb, cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 2, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            if ( HIBYTE( m_wCRC ) != m_rBinhexHeader.pb[cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 2] 
              || LOBYTE( m_wCRC ) != m_rBinhexHeader.pb[cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 1] )
            {
                hr = E_FAIL; // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            *pcbProduced = 0;
            
            // Switch to using the correct buffer
            m_prBinhexOutput = &m_rOut;
            cchIn -= m_cbToProcess;
            
            // Save off the size of the two forks
            pbBinHex = m_rBinhexHeader.pb + m_rBinhexHeader.pb[0] + cbMinBinHexHeader - 10;
            m_cbDataFork = NATIVE_LONG_FROM_BIG(pbBinHex);
            m_cbResourceFork =NATIVE_LONG_FROM_BIG(pbBinHex + 4);
            
            if (FALSE == m_fDataForkOnly)
            {
                // Copy extra data into new buffer
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn + sizeof(MACBINARY)))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn + sizeof(MACBINARY)));
                }

                // Write out the MacBinary header
                CHECKHR(hr = HrCreateMacBinaryHeader(&m_rBinhexHeader, m_prBinhexOutput));
            }
            
            if (m_cbDataFork > 0)
            {
                // Fill output buffer
                FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn, uchIn);
                m_prBinhexOutput->cb += cchIn;
                
                // delete binhex header buffer
                SafeMemFree(m_rBinhexHeader.pb);
                ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

                m_cbToProcess = m_cbDataFork;
                
                // Switch to doing the data fork.
                m_eBinHexStateDec = sDATA;
            }
            else
            {
                BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
                
                // Save off the CRC until we can get the CRC from the fork.
                m_wCRCForFork = m_wCRC;
                
                m_prBinhexOutput = &m_rBinhexHeader;
                
                // Remove the HEADER from the buffer
                FillMemory(m_prBinhexOutput->pb, cchIn, uchIn);
                m_prBinhexOutput->cb = cchIn;
                
                // Switch to filling the data CRC
                m_cbToProcess = 2;
                m_eBinHexStateDec = sDATACRC;
                
            }
            break;
            
        case sDATA:
            // Verify that we have the correct CRC
            BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn - *pcbProduced,
                                    m_cbToProcess + *pcbProduced, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            // Save off the CRC until we can get the CRC from the fork.
            m_wCRCForFork = m_wCRC;
            m_wCRC = 0;
            *pcbProduced = 0;
            cchIn -= m_cbToProcess;
            
            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(&m_rBinhexHeader, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_rBinhexHeader.pb + m_rBinhexHeader.cb),
                        (m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn);
            m_rBinhexHeader.cb += cchIn;
                
            // We only need to pad for a real Mac file...
            if (FALSE == m_fDataForkOnly)
            {
                // Check to see if the size of the fork is a multiple of 128?
                cbPad = 128 - (m_cbDataFork % 128);
                if (cbPad != 0)
                {
                    uchIn = '\0';
                    
                    // Check output buffer for space
                    if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cbPad - cchIn))
                    {
                        // Grow the buffer
                        CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cbPad - cchIn));
                    }

                    // Fill output buffer
                    FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn), cbPad, uchIn);
                    m_prBinhexOutput->cb += cbPad - cchIn;
                }
            }
            
            // Switch to filling the data fork CRC
            m_prBinhexOutput = &m_rBinhexHeader;
            m_cbToProcess = 2;
            m_eBinHexStateDec = sDATACRC;
            
            break;
            
        case sDATACRC:
            if ( HIBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[0] 
              || LOBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[1] )
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            cchIn -= m_cbToProcess;
            *pcbProduced = 0;

            if (m_cbResourceFork > 0)
            {
                m_prBinhexOutput = &m_rOut;
                
                // Switch to the proper buffer for CRC calculations
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
                }
                
                // Move any current bytes so we don't overwrite anything
                CopyMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb),
                            (m_rBinhexHeader.pb + m_rBinhexHeader.cb), cchIn);
                m_prBinhexOutput->cb += cchIn;
                    
                // delete binhex header buffer
                SafeMemFree(m_rBinhexHeader.pb);
                ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

                // Switch to filling the resource fork
                if (FALSE == m_fDataForkOnly)
                {
                    m_cbToProcess = m_cbResourceFork;
                    m_eBinHexStateDec = sRESOURCE;
                }
                else
                {
                    m_cbToProcess = 0x0;
                    m_eBinHexStateDec = sENDING;
                }
            }
            else
            {
                // Set the CRC for the data fork.
                BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
                
                // Save off the CRC until we can get the CRC from the fork.
                m_wCRCForFork = m_wCRC;
                
                // Remove the DATA CRC from the buffer
                MoveMemory(m_prBinhexOutput->pb, m_prBinhexOutput->pb + 2, m_prBinhexOutput->cb - 2);
                m_prBinhexOutput->cb -= 2;
                
                // Switch to filling the resource CRC
                m_cbToProcess = 2;
                m_eBinHexStateDec = sRESOURCECRC;
            }
            break;
            
        case sRESOURCE:
            // Verify that we have the correct CRC
            BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn - *pcbProduced,
                                    m_cbToProcess + *pcbProduced, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            // Save off the CRC until we can get the CRC from the fork.
            m_wCRCForFork = m_wCRC;
            m_wCRC = 0;
            *pcbProduced = 0;
            cchIn -= m_cbToProcess;

            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(&m_rBinhexHeader, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_rBinhexHeader.pb + m_rBinhexHeader.cb),
                        (m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn);
            m_rBinhexHeader.cb += cchIn;
                
            // Check to see if the size of the fork is a multiple of 128?
            cbPad = 128 - (m_cbResourceFork % 128);
            if (cbPad != 0)
            {
                uchIn = '\0';
                
                // Check output buffer for space
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cbPad - cchIn))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cbPad - cchIn));
                }

                // Fill output buffer
                FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn), cbPad, uchIn);
                m_prBinhexOutput->cb += cbPad - cchIn;
            }
            
            // Switch to filling the resource fork CRC
            m_prBinhexOutput = &m_rBinhexHeader;
            m_cbToProcess = 2;
            m_eBinHexStateDec = sRESOURCECRC;
            break;
            
        case sRESOURCECRC:
            if ( HIBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[0] 
              || LOBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[1] )
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            cchIn -= m_cbToProcess;
            m_prBinhexOutput = &m_rOut;
            *pcbProduced = 0;

            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb),
                        (m_rBinhexHeader.pb + m_rBinhexHeader.cb), cchIn);
            m_prBinhexOutput->cb += cchIn;
                
            // delete binhex header buffer
            SafeMemFree(m_rBinhexHeader.pb);
            ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

            // Switch to filling the resource fork
            m_cbToProcess = 0x0;
            m_eBinHexStateDec = sENDING;
            break;
            
        default:
            Assert(FALSE);
            break;
        }
    }

    m_cbToProcess -= cchIn;
    
    *pcbProduced += cchIn;
    
    hr = S_OK;
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrBinhexThrowAway
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrBinhexThrowAway(LPSTR pszLine, ULONG cbLine)
{
    HRESULT hr = S_FALSE;
    
    if (m_eBinHexStateDec == sSTARTING)
    {
        // Ingore all lines before we start that only have whitespace characters
        // or the start tag.
        hr = S_OK;
        
        for (LPSTR pszEnd = pszLine + cbLine; pszLine < pszEnd; pszLine++)
        {
            if (!FBINHEXRETURN(*pszLine))
            {
                // Need to ignore lines that start with the tag
                if (((ULONG)(pszEnd - pszLine) >= cbBINHEXSTART) && (StrCmpNI(szBINHEXSTART, pszLine, cbBINHEXSTART) == 0))
                {
                    m_eBinHexStateDec = sSTARTED;
                    break;
                }
                
                // We must have gotten bad data
                hr = E_FAIL;    // ERROR_INVALID_DATA
                m_eBinHexStateDec = sENDED;
                goto exit;
            }
        }
        
    }
    else if (m_eBinHexStateDec == sENDED)
    {
        // We can ignore any lines after we are done.
        hr = S_OK;
    }
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeBinHex
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeBinHex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbLine;
    LPSTR       pszLine;
    ULONG       cbRead=0;
    ULONG       cbLineLength;
    BOOL        fFound;
    ULONG       cbConvert;
    ULONG       cbScan;
    ULONG       i;
    UCHAR       uchConvert[4];
    UCHAR       uchThis;
    UCHAR       uchDecoded;
    UCHAR       cuchWrite;
    UCHAR       rgbShift[] = {0, 4, 2, 0};
    ULONG       cbProduced = 0;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
        {
            goto exit;
        }

        // UUENCODE ThrowAway
        hr = HrBinhexThrowAway(pszLine, cbLine);
        if (FAILED(hr))
        {
            goto exit;
        }
        else if (S_OK == hr)
        {
            continue;
        }

        hr = S_OK;

        // Do I need to grow
        if (FGROWBUFFER(m_prBinhexOutput, cbLine + 20))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cbLine + 20));
        }

        AssertSz((m_eBinHexStateDec != sSTARTING) && (m_eBinHexStateDec != sENDED),
                                "Why haven't we found the start of the stream yet??\n");
        
        // Decodes characters in line buffer
        for (i=0; i<cbLine; i++)
        {
            uchThis = pszLine[i];

            // Check for valid white space
            if (FBINHEXRETURN(uchThis))
                continue;
                
            // Check for start or end of stream
            if (BINHEX_TERM == uchThis)
            {
                if (m_eBinHexStateDec == sSTARTED)
                {
                    m_eBinHexStateDec = sHDRFILESIZE;
                    continue;
                }
                else if (m_eBinHexStateDec == sENDING)
                {
                    m_eBinHexStateDec = sENDED;
                    break;
                }
            }
            
            if (m_eBinHexStateDec == sENDING)
            {
                if (('!' == uchThis) || (TRUE == m_fDataForkOnly))
                {
                    continue;
                }
                else
                {
                    // ensure that we're not in an invalid state. If we made it to sENDING and we got
                    // valid CRCs and everything is hunky dory, just ignore the terminating stuff.
                    continue;
                }
            }
            
            // Decode It
            uchDecoded = DECODEBINHEX(uchThis);

            // Test for valid char
            if (uchDecoded == BINHEX_INVALID)
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }

            if ( m_cAccum == 0 )
            {
                m_ulAccum = uchDecoded;
                ++m_cAccum;
                continue;
            }
            else
            {
                m_ulAccum = ( m_ulAccum << 6 ) | uchDecoded;
                uchDecoded = (BYTE)(m_ulAccum >> rgbShift[m_cAccum]) & 0xff;
                m_cAccum++;
                m_cAccum %= sizeof(m_ulAccum);
            }

            // If we are repeating then fill the buffer with char
            if (m_fRepeating)
            {
                m_fRepeating = FALSE;
                
                // Check to see if it's just a literal 0x90
                if (0x00 == uchDecoded)
                {
                    // Just write out one BINHEX_REPEAT char
                    m_uchPrev = BINHEX_REPEAT;
                    cuchWrite = 1;
                }
                else
                {
                    cuchWrite = uchDecoded - 1;
                }
            }
            
            // Check for repeat character
            else if (BINHEX_REPEAT == uchDecoded)
            {
                m_fRepeating = TRUE;
                continue;
            }

            // Else it's just a normal character.
            else
            {
                m_uchPrev = uchDecoded;
                cuchWrite = 1;
            }

            CHECKHR(HrBinhexDecodeBuffAppend(m_uchPrev, cuchWrite, cbLine - i, &cbProduced));
        }

        BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cbProduced, cbProduced, &(m_wCRC));
        cbProduced = 0;
    }

    hr = S_OK;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetdate.cpp ===
// --------------------------------------------------------------------------------
// Inetdate.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "strconst.h"
#include "dllmain.h"

// ------------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------------
BOOL FFindMonth(LPCSTR pszMonth, LPSYSTEMTIME pst);
BOOL FFindDayOfWeek(LPCSTR pszDayOfWeek, LPSYSTEMTIME pst);
void ProcessTimeZoneInfo(LPCSTR pszTimeZone, ULONG cchTimeZone, LONG *pcHoursToAdd, LONG *pcMinutesToAdd);

// ------------------------------------------------------------------------------------------
// Date Conversion Data
// ------------------------------------------------------------------------------------------
#define CCHMIN_INTERNET_DATE    5

// ------------------------------------------------------------------------------------------
// Date Conversion States
// ------------------------------------------------------------------------------------------
#define IDF_MONTH       FLAG01
#define IDF_DAYOFWEEK   FLAG02
#define IDF_TIME        FLAG03
#define IDF_TIMEZONE    FLAG04
#define IDF_MACTIME     FLAG05
#define IDF_DAYOFMONTH  FLAG06
#define IDF_YEAR        FLAG07

static const char c_szTZ[] = "TZ";

// ------------------------------------------------------------------------------------------
// MimeOleInetDateToFileTime - Tue, 21 Jan 1997 18:25:40 GMT
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleInetDateToFileTime(LPCSTR pszDate, LPFILETIME pft)
{
    // Locals
    HRESULT         hr=S_OK;
    SYSTEMTIME      st={0};
    ULONG           cchToken;
    LPCSTR          pszToken;
    LONG            cHoursToAdd=0, cMinutesToAdd=0;
    DWORD           dwState=0;
    LONG            lUnitsToAdd = 0;
    CStringParser   cString;
    LARGE_INTEGER   liTime;
    BOOL            fRemovedDash = FALSE;
    LONGLONG        liHoursToAdd = 1i64, liMinutesToAdd = 1i64;

    // Check Params
    if (NULL == pszDate || NULL == pft)
        return TrapError(E_INVALIDARG);

    // Init the String Parser
    cString.Init(pszDate, lstrlen(pszDate), PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS | PSF_ESCAPED);

    // Init systime
    st.wMonth = st.wDay = 1;

    // SetTokens
    cString.SetTokens(c_szCommaSpaceDash);

    // While we have characters to process
    while(1)
    {
        // IMAP has non-standard date format that uses "-" delimiter instead of " ".
        // When we're pretty sure we don't need "-" anymore, jettison from token list
        // otherwise we will mess up timezone parsing (which can start with a "-")
        // NOTE that we assume that we NEVER have to stuff the dash back in. We only need
        // the dash for IMAP dates, and IMAP dates should ALWAYS come before the time.
        if (FALSE == fRemovedDash &&
            ((dwState & IDF_YEAR) || ((dwState & (IDF_TIME | IDF_TIMEZONE)) == IDF_TIME))) // In case NO DATE or time BEFORE date
        {
            cString.SetTokens(c_szCommaSpace); // Remove dash from token list
            fRemovedDash = TRUE;
        }

        // Scan to ", " or "-" in IMAP case
        cString.ChParse();

        // Get parsed Token
        cchToken = cString.CchValue();
        pszToken = cString.PszValue();

        // Done
        if (0 == cchToken)
            break;

        // If the Word is not a digit
        if (IsDigit((LPSTR)pszToken) == FALSE)
        {
            // We haven't found the month
            if (!(IDF_MONTH & dwState))
            {
                // Lookup the Month
                if (FFindMonth(pszToken, &st) == TRUE)
                {
                    dwState |= IDF_MONTH;
                    continue;
                }
            }

            // We haven't found the day of the week
            if (!(IDF_DAYOFWEEK & dwState))
            {
                // Lookup the Month
                if (FFindDayOfWeek(pszToken, &st) == TRUE)
                {
                    dwState |= IDF_DAYOFWEEK;
                    continue;
                }
            }

            // Time Zone
            if ((IDF_TIME & dwState) && !(IDF_TIMEZONE & dwState))
            {
                dwState |= IDF_TIMEZONE;
                ProcessTimeZoneInfo(pszToken, cchToken, &cHoursToAdd, &cMinutesToAdd);
            }

            // Support "AM" and "PM" from Mac Mail Gateway
            if (IDF_MACTIME & dwState)
            {
                // Token Length
                if (2 == cchToken)
                {
                    if (lstrcmpi("PM", pszToken) == 0)
                    {
                        if (st.wHour < 12)
                            st.wHour += 12;
                    }
                    else if (lstrcmpi("AM", pszToken) == 0)
                    {
                        if (st.wHour == 12)
                            st.wHour = 0;
                    }
                }
            }
        }

        else
        {
            // Does string have a colon in it
            LPSTR pszColon = PszScanToCharA((LPSTR)pszToken, ':');

            // Found colon and time has not been found
            if (!(IDF_TIME & dwState) && '\0' != *pszColon)
            {
                // Its a time stamp - TBD - DBCS this part - AWN 28 Mar 94
                if (7 == cchToken || 8 == cchToken)
                {
                    // Locals
                    CHAR szTemp[CCHMAX_INTERNET_DATE];

                    // Prefix with zero to make eight
                    if (cchToken == 7)
                        wnsprintfA(szTemp, ARRAYSIZE(szTemp), "0%s", pszToken);
                    else
                        StrCpyNA(szTemp, pszToken, ARRAYSIZE(szTemp));

                    // convert the time into system time
                    st.wHour   = (WORD) StrToInt(szTemp);
                    st.wMinute = (WORD) StrToInt(szTemp + 3);
                    st.wSecond = (WORD) StrToInt(szTemp + 6);

                    // Adjustments if needed
                    if (st.wHour < 0 || st.wHour > 24)
                        st.wHour = 0;
                    if (st.wMinute < 0 || st.wMinute > 59)
                        st.wMinute = 0;
                    if (st.wSecond < 0 || st.wSecond > 59)
                        st.wSecond = 0;

                    // We found the time
                    dwState |= IDF_TIME;
                }

                // This if process times of the time 12:01 AM or 01:45 PM
                else if (cchToken < 6 && lstrlen(pszColon) <= 3)
                {
                    // rgchWord is pointing to hour.
                    st.wHour = (WORD) StrToInt(pszToken);

                    // Step over colon
                    Assert(':' == *pszColon);
                    pszColon++;

                    // Get Minute
                    st.wMinute = (WORD) StrToInt(pszColon);
                    st.wSecond = 0;

                    // It should never happen, but do bounds check anyway.
                    if (st.wHour < 0 || st.wHour > 24)
                         st.wHour = 0;
                    if (st.wMinute < 0 || st.wMinute > 59)
                         st.wMinute = 0;

                    // Mac Time
                    dwState |= IDF_TIME;
                    dwState |= IDF_MACTIME;
                }
            }
            else
            {
                // Convert to int
                ULONG ulValue = StrToInt(pszToken);

                // Day of month
                if (!(IDF_DAYOFMONTH & dwState) && ulValue < 32)
                {
                    // Set Day of Month
                    st.wDay = (WORD)ulValue;

                    // Adjust
                    if (st.wDay < 1 || st.wDay > 31)
                         st.wDay = 1;

                    // Set State
                    dwState |= IDF_DAYOFMONTH;
                }

                // Year
                else if (!(IDF_YEAR & dwState))
                {
                    // 2-digit year
                    if (ulValue < 100) // 2-digit year
                    {
                        // Compute Current Year
                        ulValue += (((ulValue > g_ulY2kThreshold) ? g_ulUpperCentury - 1 : g_ulUpperCentury) * 100);
                    }

                    // Set Year
                    st.wYear = (WORD)ulValue;

                    // Set State
                    dwState |= IDF_YEAR;
                }
            }
        }
    }

    // Convert sys time to file time
    if (SystemTimeToFileTime(&st, pft) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_INET_DATE);
        goto exit;
    }

    // No time zone was found ?
    if (!ISFLAGSET(dwState, IDF_TIMEZONE))
    {
        // Get default time zone
        ProcessTimeZoneInfo(c_szTZ, lstrlen(c_szTZ), &cHoursToAdd, &cMinutesToAdd);
    }

    // Init
    liTime.LowPart  = pft->dwLowDateTime;
    liTime.HighPart = pft->dwHighDateTime;

    // Adjust the hour
    if (cHoursToAdd != 0)
    {
        lUnitsToAdd = cHoursToAdd * 3600;
        liHoursToAdd *= lUnitsToAdd;
        liHoursToAdd *= 10000000i64;
        liTime.QuadPart += liHoursToAdd;
    }

    // Adjust the minutes
    if (cMinutesToAdd != 0)
    {
        lUnitsToAdd = cMinutesToAdd * 60;
        liMinutesToAdd *= lUnitsToAdd;
        liMinutesToAdd *= 10000000i64;
        liTime.QuadPart += liMinutesToAdd;
    }

    // Assign the result to FILETIME
    pft->dwLowDateTime  = liTime.LowPart;
    pft->dwHighDateTime = liTime.HighPart;

exit:
    // Failure Defaults to current time...
    if (FAILED(hr))
    {
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, pft);
    }

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// FFindMonth
// ------------------------------------------------------------------------------------------
BOOL FFindMonth(LPCSTR pszMonth, LPSYSTEMTIME pst)
{
    // Locals
    ULONG ulIndex;

    // Index of Month, one-based
    if (FAILED(HrIndexOfMonth(pszMonth, &ulIndex)))
        return FALSE;

    // Set It
    pst->wMonth = (WORD)ulIndex;

    // Found It
    return TRUE;
}

// ------------------------------------------------------------------------------------------
// FFindDayOfWeek
// ------------------------------------------------------------------------------------------
BOOL FFindDayOfWeek(LPCSTR pszDayOfWeek, LPSYSTEMTIME pst)
{
    // Locals
    ULONG ulIndex;

    // Index of Day, 0 based
    if (FAILED(HrIndexOfWeek(pszDayOfWeek, &ulIndex)))
        return FALSE;

    // Set It
    pst->wDayOfWeek = (WORD)ulIndex;

    // Failure
    return TRUE;
}

// ------------------------------------------------------------------------------------------
// ProcessTimeZoneInfo
// ------------------------------------------------------------------------------------------
void ProcessTimeZoneInfo(LPCSTR pszTimeZone, ULONG cchTimeZone, LONG *pcHoursToAdd, LONG *pcMinutesToAdd)
{
    // Locals
    CHAR szTimeZone[CCHMAX_INTERNET_DATE];

    // Invalid Arg
    Assert(pszTimeZone && pcHoursToAdd && pcMinutesToAdd && cchTimeZone <= sizeof(szTimeZone));

    // Copy buffer so we can but nulls into it...
    CopyMemory(szTimeZone, pszTimeZone, (sizeof(szTimeZone) < cchTimeZone + 1)?sizeof(szTimeZone):cchTimeZone + 1);

    // Init
    *pcHoursToAdd = *pcMinutesToAdd = 0;

    // +hhmm or -hhmm
    if (('-' == *szTimeZone || '+' == *szTimeZone) && cchTimeZone <= 5)
    {
        // Take off
        cchTimeZone -= 1;

        // determine the hour/minute offset
        if (cchTimeZone == 4)
        {
            *pcMinutesToAdd = StrToInt(szTimeZone + 3);
            *(szTimeZone + 3) = 0x00;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        // 3
        else if (cchTimeZone == 3)
        {
            *pcMinutesToAdd = StrToInt(szTimeZone + 2);
            *(szTimeZone + 2) = 0x00;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        // 2
        else if (cchTimeZone == 2 || cchTimeZone == 1)
        {
            *pcMinutesToAdd = 0;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        if ('+' == *szTimeZone)
        {
            *pcHoursToAdd = -(*pcHoursToAdd);
            *pcMinutesToAdd = -(*pcMinutesToAdd);
        }
    }

    //  Xenix conversion:  TZ = current time zone or other unknown tz types.
    else if (lstrcmpi(szTimeZone, "TZ") == 0 || lstrcmpi(szTimeZone, "LOCAL") == 0 || lstrcmpi(szTimeZone, "UNDEFINED") == 0)
    {
        // Locals
        TIME_ZONE_INFORMATION tzi ;
        DWORD dwResult;
        LONG  cMinuteBias;

        // Get Current System Timezone Information
        dwResult = GetTimeZoneInformation (&tzi);
        AssertSz(dwResult != 0xFFFFFFFF, "GetTimeZoneInformation Failed.");

        // If that didn't fail
        if (dwResult != 0xFFFFFFFF)
        {
            // Locals
            cMinuteBias = tzi.Bias;

            // Modify Minute Bias
            if (dwResult == TIME_ZONE_ID_STANDARD)
                cMinuteBias += tzi.StandardBias;
            else if (dwResult == TIME_ZONE_ID_DAYLIGHT)
                cMinuteBias += tzi.DaylightBias ;

            // Adjust ToAdd Returs
            *pcHoursToAdd = cMinuteBias / 60;
            *pcMinutesToAdd = cMinuteBias % 60;
        }
    }

    // Loop through known time zone standards
    else
    {
        // Locals
        INETTIMEZONE rTimeZone;

        // Find time zone info
        if (FAILED(HrFindInetTimeZone(szTimeZone, &rTimeZone)))
            DebugTrace("Unrecognized zone info: [%s]\n", szTimeZone);
        else
        {
            *pcHoursToAdd = rTimeZone.cHourOffset;
            *pcMinutesToAdd = rTimeZone.cMinuteOffset;
        }
    }
}

// ------------------------------------------------------------------------------------------
// MimeOleFileTimeToInetDate
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFileTimeToInetDate(LPFILETIME pft, LPSTR pszDate, ULONG cchMax)
{
    // Locals
    SYSTEMTIME st;
    DWORD      dwTimeZoneId=TIME_ZONE_ID_UNKNOWN;
    CHAR       cDiff;
    LONG       ltzBias=0;
    LONG       ltzHour;
    LONG       ltzMinute;
    TIME_ZONE_INFORMATION tzi;

    // Invalid Arg
    if (NULL == pszDate)
        return TrapError(E_INVALIDARG);
    if (cchMax < CCHMAX_INTERNET_DATE)
        return TrapError(MIME_E_BUFFER_TOO_SMALL);

    // Verify lpst is set
    if (pft == NULL || (pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0))
    {
        GetLocalTime(&st);
    }
    else
    {
        FILETIME ftLocal;
        FileTimeToLocalFileTime(pft, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &st);
    }

    // Gets TIME_ZONE_INFORMATION
    dwTimeZoneId = GetTimeZoneInformation (&tzi);
    switch (dwTimeZoneId)
    {
    case TIME_ZONE_ID_STANDARD:
        ltzBias = tzi.Bias + tzi.StandardBias;
        break;

    case TIME_ZONE_ID_DAYLIGHT:
        ltzBias = tzi.Bias + tzi.DaylightBias;
        break;

    case TIME_ZONE_ID_UNKNOWN:
    default:
        ltzBias = tzi.Bias;
        break;
    }

    // Set Hour Minutes and time zone dif
    ltzHour = ltzBias / 60;
    ltzMinute = ltzBias % 60;
    cDiff = (ltzHour < 0) ? '+' : '-';

    // Constructs RFC 822 format: "ddd, dd mmm yyyy hh:mm:ss +/- hhmm\0"
    Assert(st.wMonth);
    wnsprintfA(pszDate, cchMax, "%3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",
                      PszDayFromIndex(st.wDayOfWeek),          // "ddd"
                      st.wDay,                                 // "dd"
                      PszMonthFromIndex(st.wMonth),            // "mmm"
                      st.wYear,                                // "yyyy"
                      st.wHour,                                // "hh"
                      st.wMinute,                              // "mm"
                      st.wSecond,                              // "ss"
                      cDiff,                                   // "+" / "-"
                      abs (ltzHour),                           // "hh"
                      abs (ltzMinute));                        // "mm"

    // Done
    return S_OK;
}


#ifdef WININET_DATE
// ------------------------------------------------------------------------------------------
// MimeOleInetDateToFileTime
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleInetDateToFileTime(LPCSTR pszDate, LPFILETIME pft)
{
    // Locals
    SYSTEMTIME st;

    // Check Params
    if (NULL == pszDate || NULL == pft)
        return TrapError(E_INVALIDARG);

    // Use wininet to convert date...
    if (InternetTimeToSystemTime(pszDate, &st, 0) == 0)
        return TrapError(E_FAIL);

    // Convert to file time
    SystemTimeToFileTime(&st, pft);

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleFileTimeToInetDate
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFileTimeToInetDate(LPFILETIME pft, LPSTR pszDate, ULONG cchMax)
{
    // Locals
    SYSTEMTIME st;

    // Invalid Arg
    if (NULL == pszDate)
        return TrapError(E_INVALIDARG);
    if (cchMax < CCHMAX_INTERNET_TIME)
        return TrapError(MIME_E_BUFFER_TOO_SMALL);

    // Verify lpst is set
    if (pft == NULL || (pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0))
        GetLocalTime(&st);
    else
        FileTimeToSystemTime(pft, &st);

    // Use wininet to convert date...
    if (InternetTimeFromSystemTime(&st, INTERNET_RFC1123_FORMAT, pszDate, cchMax) == 0)
        return TrapError(E_FAIL);

    // Done
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetstm.cpp ===
// --------------------------------------------------------------------------------
// InetStm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetstm.h"
#include "stmlock.h"
#include "shlwapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// INETSTMTRACING
// --------------------------------------------------------------------------------
//#define INETSTMTRACING 1
#ifdef INETSTMTRACING
#define INETSTMTRACE DebugTrace
#else
#define INETSTMTRACE
#endif

// --------------------------------------------------------------------------------
// CInternetStream::CInternetStream
// --------------------------------------------------------------------------------
CInternetStream::CInternetStream(void)
{
    m_cRef = 1;
    m_pStmLock = NULL;
    m_fFullyAvailable = TRUE;
    ULISet32(m_uliOffset, 0);
    ZeroMemory(&m_rLine, sizeof(INETSTREAMLINE));
    m_rLine.pb = m_rLine.rgbScratch;
    m_rLine.cbAlloc = sizeof(m_rLine.rgbScratch);
}

// --------------------------------------------------------------------------------
// CInternetStream::~CInternetStream
// --------------------------------------------------------------------------------
CInternetStream::~CInternetStream(void)
{
    // Do i need to free the line
    if (m_rLine.pb && m_rLine.pb != m_rLine.rgbScratch)
        g_pMalloc->Free(m_rLine.pb);

    // Reset the position of the stream to the real current offset
    if (m_pStmLock)
    {
        // Preserve the position of the stream
        SideAssert(SUCCEEDED(m_pStmLock->HrSetPosition(m_uliOffset)));

        // Release the LockBytes
        m_pStmLock->Release();
    }
}

// --------------------------------------------------------------------------------
// CInternetStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetStream::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CInternetStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetStream::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrInitNew
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrInitNew(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    CStreamLockBytes   *pStmLock=NULL;
    DWORD               cbOffset;

    // Invalid Arg
    Assert(pStream);

    // Wrap pStream in a pStmLock
    CHECKALLOC(pStmLock = new CStreamLockBytes(pStream));

    // Get Current Stream Position
    CHECKHR(hr = HrGetStreamPos(pStream, &cbOffset));

    // Create text stream object
    InitNew(cbOffset, pStmLock);

exit:
    // Cleanup
    SafeRelease(pStmLock);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::InitNew
// --------------------------------------------------------------------------------
void CInternetStream::InitNew(DWORD dwOffset, CStreamLockBytes *pStmLock)
{
    // Invalid Arg
    Assert(pStmLock);

    // Release Current
    SafeRelease(m_pStmLock);

    // Zero Current Buffer
    ZeroMemory(&m_rBuffer, sizeof(INETSTREAMBUFFER));

    // Reset m_rLine
    m_rLine.cb = 0;

    // Assume new StreamLockBytes
    m_pStmLock = pStmLock;
    m_pStmLock->AddRef();

    // Safe the Offset
    m_uliOffset.QuadPart = dwOffset;
}

// --------------------------------------------------------------------------------
// CInternetStream::GetLockBytes
// --------------------------------------------------------------------------------
void CInternetStream::GetLockBytes(CStreamLockBytes **ppStmLock)
{
    // Invalid Arg
    Assert(ppStmLock && m_pStmLock);

    // Return It
    (*ppStmLock) = m_pStmLock;
    (*ppStmLock)->AddRef();
}

// --------------------------------------------------------------------------------
// CInternetStream::HrGetSize
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrGetSize(DWORD *pcbSize)
{
    // Locals
    HRESULT     hr=S_OK;
    STATSTG     rStat;

    // Invalid Arg
    Assert(pcbSize && m_pStmLock);

    // Get the Stat
    CHECKHR(hr = m_pStmLock->Stat(&rStat, STATFLAG_NONAME));

    // Return Size
    *pcbSize = (DWORD)rStat.cbSize.QuadPart;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::Seek
// --------------------------------------------------------------------------------
void CInternetStream::Seek(DWORD dwOffset)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fResetCache=FALSE;
    DWORD       dw;

    // State Check
    Assert((m_rBuffer.cb == 0) || (m_uliOffset.QuadPart == m_rBuffer.uliOffset.QuadPart + m_rBuffer.i));

    // Already at the requested position
    if (dwOffset == m_uliOffset.QuadPart)
        goto exit;

    // Less than current position
    if (dwOffset < m_uliOffset.QuadPart)
    {
        // Compute Offset from current location
        dw = (DWORD)m_uliOffset.QuadPart - dwOffset;

        // Less than beginning
        if (dw > m_rBuffer.i)
            fResetCache = TRUE;
        else
        {
            Assert(dw <= m_rBuffer.i);
            m_rBuffer.i -= dw;
        }
    }

    // Else dwOffset > m_uliOffset.QuadPart
    else
    {
        // Compute Offset from current location
        dw = dwOffset - (DWORD)m_uliOffset.QuadPart;

        // Less than beginning
        if (m_rBuffer.i + dw > m_rBuffer.cb)
            fResetCache = TRUE;
        else
        {
            m_rBuffer.i += dw;
            Assert(m_rBuffer.i <= m_rBuffer.cb);
        }
    }

    // Reset the cache
    if (fResetCache)
    {
        // Empty current line and buffer
        *m_rLine.pb = *m_rBuffer.rgb = '\0';

        // No buffer
        m_rBuffer.uliOffset.QuadPart = m_rLine.cb = m_rBuffer.i = m_rBuffer.cb = 0;
    }

    // Save this position
    m_uliOffset.QuadPart = dwOffset;

exit:
    // Done
    return;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadToEnd
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadToEnd(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // While
    while(1)
    {
        // Validate
        Assert(m_rBuffer.i <= m_rBuffer.cb);

        // Increment Offset to end of current buffer
        m_uliOffset.QuadPart += (m_rBuffer.cb - m_rBuffer.i);

        // Set m_rBuffer.i to end of current buffer
        m_rBuffer.i = m_rBuffer.cb;
        
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // No more data
        if (0 == m_rBuffer.cb)
            break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::_HrGetNextBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetStream::_HrGetNextBuffer(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Validate
    Assert(m_rBuffer.i <= m_rBuffer.cb);

    // Do we need to read a new buffer
    if (m_rBuffer.i == m_rBuffer.cb)
    {
        // Read a block from the stream, this could return E_PENDING
        CHECKHR(hr = m_pStmLock->ReadAt(m_uliOffset, m_rBuffer.rgb, sizeof(m_rBuffer.rgb), &cbRead));

        // Raid 43408: Work around Urlmon IStream::Read returning S_FALSE when it should return E_PENDING
#ifdef DEBUG
        if (FALSE == m_fFullyAvailable && 0 == cbRead && S_FALSE == hr)
        {
            //AssertSz(FALSE, "Raid-43408 - Danpo Zhang is working on this bug, I hope.");
            //hr = E_PENDING;
            //goto exit;
        }
#endif

        // Save cbRead
        m_rBuffer.cb = cbRead;

        // Save the offset of the start of this buffer
        m_rBuffer.uliOffset.QuadPart = m_uliOffset.QuadPart;

        // Reset buffer index
        m_rBuffer.i = 0;
    }
    else
        Assert(m_uliOffset.QuadPart == m_rBuffer.uliOffset.QuadPart + m_rBuffer.i);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadLine
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadLine(LPPROPSTRINGA pLine)
{
    // Locals
    HRESULT  hr=S_OK;
    UCHAR    ch, 
             chEndOfLine;
    ULONG    cbRead, 
             iStart;
    BOOL     fEndOfLine=FALSE;

    // Init
    pLine->pszVal = NULL;
    pLine->cchVal = 0;

    // Reset the line
    if (m_rLine.fReset)
    {
        m_rLine.cb = 0;
        m_rLine.fReset = 0;
    }

    // Do the loop
    while(1)
    {
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // Nothing Read ?
        if (m_rBuffer.cb == 0)
            break;

        // Seek to first '\n'
        iStart = m_rBuffer.i;

        Assert(chLF<32);
        Assert(chCR<32);
        Assert(0<32);

        // For large messages, the while-loop below ends up being a big
        // percentage of the execution time for IMimeMessage::Load.  So,
        // we have carefully crafted our C++ code so that we get the
        // optimum code generation for this loop (at least, on Intel, with
        // VC 11.00.7071...)
        {
            register UCHAR *pCurr = m_rBuffer.rgb + m_rBuffer.i;
            register UCHAR *pEnd = m_rBuffer.rgb + m_rBuffer.cb;

            // We need to initialize this variable for two reasons:  First,
            // if we don't initialize it, then for some reason VC decides that
            // it doesn't want to enregister it.  And more importantly, if
            // we don't enter the while-loop at all, we need this variable
            // to be set this way...
            register UCHAR chPrev = m_rBuffer.chPrev;

            ch = m_rBuffer.chPrev;

            // While we have data
            while (pCurr < pEnd)
            {

                // Remember the previous character.
                chPrev = ch;

                // Get Character, and Increment
                ch = *pCurr;
                pCurr++;

                // The most common case - it's just a regular
                // character, and we haven't seen a carriage-return.
                // So jump back to the top of the loop and keep lookin'...
                if ((chCR != chPrev) && (ch >= 32))
                {
                    continue;
                }

                // The next most common case - we are at end-of-line because
                // of a line-feed.
                if (chLF == ch)
                {
                    chPrev = ch;
                    chEndOfLine = ch;
                    fEndOfLine = TRUE;
                    break;
                }

                // This case really only happens when we are getting malformed
                // e-mail - there are embedded carriage-returns, which are *not*
                // followed by line-feeds.  When we see those lonely CR's,
                // we make it look like we got a normal CR LF sequence.
                if (chCR == chPrev)
                {
                    chPrev = chLF;
                    pCurr--;
                    chEndOfLine = chCR;
                    fEndOfLine = TRUE;
                    break;
                }

                // Fairly rare case - these are malformed messages because they
                // have NULL's embedded in them.  We silently convert the
                // NULL's to dots.
                if ('\0' == ch)
                {
                    ch = '.';
                    *(pCurr-1) = ch;
                }
            }

            m_rBuffer.i = (ULONG) (pCurr - m_rBuffer.rgb);
            m_rBuffer.chPrev = chPrev;
        }

        // Number of bytes Read
        cbRead = (m_rBuffer.i - iStart);

        // Increment Position
        m_uliOffset.QuadPart += cbRead;

        // Do we need to realloc the line buffer ?
        if (m_rLine.cb + cbRead + 2 > m_rLine.cbAlloc)
        {
            // Fixup pszLine
            if (m_rLine.pb == m_rLine.rgbScratch)
            {
                // Null It
                m_rLine.pb = NULL;

                // Allocate it to m_rLine.cb
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rLine.pb, m_rLine.cb + 1));

                // Copy static buffer
                CopyMemory(m_rLine.pb, m_rLine.rgbScratch, m_rLine.cb);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rLine.cbAlloc = m_rLine.cb + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rLine.pb, m_rLine.cbAlloc));
        }

        // Copy the data
        CopyMemory(m_rLine.pb + m_rLine.cb, m_rBuffer.rgb + iStart, cbRead);

        // Update Counters and indexes
        m_rLine.cb += cbRead;

        // If End of line and last character was a '\r', append a '\n'
        if (TRUE == fEndOfLine)
        {
            // Better have something in the line
            Assert(m_rLine.cb);

            // If line ended with a '\r'
            if (chCR == chEndOfLine)
            {
                // Better have room for one more char
                Assert(m_rLine.cb + 1 < m_rLine.cbAlloc);

                // Append a '\n'
                m_rLine.pb[m_rLine.cb] = chLF;

                // Increment Length
                m_rLine.cb++;
            }

            // Otherwise...
            else
            {
                // Line better have ended with a \n
                Assert(chLF == chEndOfLine && chLF == m_rLine.pb[m_rLine.cb - 1]);

                // If Previous Character was not a \r 
                if (m_rLine.cb < 2 || chCR != m_rLine.pb[m_rLine.cb - 2])
                {
                    // Convert last char from \n to a \r
                    m_rLine.pb[m_rLine.cb - 1] = chCR;

                    // Better have room for one more char
                    Assert(m_rLine.cb + 1 < m_rLine.cbAlloc);

                    // Append a '\n'
                    m_rLine.pb[m_rLine.cb] = chLF;

                    // Increment Length
                    m_rLine.cb++;
                }
            }

            // Done
            break;
        }
    }

    // A little check
    Assert(fEndOfLine ? m_rLine.cb >= 2 && chLF == m_rLine.pb[m_rLine.cb-1] && chCR == m_rLine.pb[m_rLine.cb-2] : TRUE);

    // Null terminator
    m_rLine.pb[m_rLine.cb] = '\0';

    // Set return values
    pLine->pszVal = (LPSTR)m_rLine.pb;
    pLine->cchVal = m_rLine.cb;

    // Tracking
    INETSTMTRACE("CInternetStream: %s", (LPSTR)m_rLine.pb);

    // No Line
    m_rLine.fReset = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadHeaderLine
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadHeaderLine(LPPROPSTRINGA pLine, LONG *piColonPos)
{
    // Locals
    HRESULT   hr=S_OK;
    CHAR      ch;
    ULONG     cbRead=0, 
              iStart, 
              i;
    BOOL      fEndOfLine=FALSE;
    DWORD     cTrailingSpace=0;

    // Init
    *piColonPos = -1;
    pLine->pszVal = NULL;
    pLine->cchVal = 0;

    // Reset the line
    if (m_rLine.fReset)
    {
        m_rLine.cb = 0;
        m_rLine.fReset = 0;
    }

    // Do the loop
    while(1)
    {
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // Nothing Read ?
        if (m_rBuffer.cb == 0)
            break;

        // Reset fSeenN
        fEndOfLine = FALSE;

        // Initialize
        iStart = m_rBuffer.i;

        // Seek to first '\n'
        while (m_rBuffer.i < m_rBuffer.cb)
        {
            // Get Character
            ch = *(m_rBuffer.rgb + m_rBuffer.i);

            // Convert Nulls to '.'
            if ('\0' == ch)
            {
                ch = '.';
                *(m_rBuffer.rgb + m_rBuffer.i) = ch;
            }

            // Goto next character
            m_rBuffer.i++;

            // New Line
            if (chLF == ch)
            {
                m_rBuffer.chPrev = ch;
                fEndOfLine = TRUE;
                break;
            }

            // Otherwise, if previous character was a '\r', then end of line
            else if (chCR == m_rBuffer.chPrev)
            {
                AssertSz(m_rBuffer.i > 0, "This is an un-handled boundary condition");
                if (m_rBuffer.i > 0)
                    m_rBuffer.i--;
                m_rBuffer.chPrev = '\0';
                fEndOfLine = TRUE;
                break;
            }

            // Is Space
            if (' ' == ch || '\t' == ch)
                cTrailingSpace++;
            else
                cTrailingSpace = 0;

            // Save Previous Character
            m_rBuffer.chPrev = ch;
        }

        // Number of bytes Read
        cbRead = (m_rBuffer.i - iStart);

        // Increment Position
        m_uliOffset.QuadPart += cbRead;

        // Adjust cbRead to remove CRLF
        if (cbRead && chLF == m_rBuffer.rgb[iStart + cbRead - 1])
            cbRead--;
        if (cbRead && chCR == m_rBuffer.rgb[iStart + cbRead - 1])
            cbRead--;

        // Do we need to realloc the line buffer ?
        if (m_rLine.cb + cbRead + 3 > m_rLine.cbAlloc)
        {
            // Fixup pszLine
            if (m_rLine.pb == m_rLine.rgbScratch)
            {
                // Null It
                m_rLine.pb = NULL;

                // Allocate it to m_rLine.cb
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rLine.pb, m_rLine.cb + 3));

                // Copy static buffer
                CopyMemory(m_rLine.pb, m_rLine.rgbScratch, m_rLine.cb);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rLine.cbAlloc = m_rLine.cb + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rLine.pb, m_rLine.cbAlloc));
        }

        // Copy the data
        CopyMemory(m_rLine.pb + m_rLine.cb, m_rBuffer.rgb + iStart, cbRead);

        // Increment line byte count
        m_rLine.cb += cbRead;

        // If fSeenN, then check for continuation line (i.e. next character is ' ' or '\t'
        if (fEndOfLine)
        {
            // Get next buffer
            CHECKHR(hr = _HrGetNextBuffer());

            // Compare for continuation
            ch = m_rBuffer.rgb[m_rBuffer.i];

            // If line starts with a TAB or a space, this is a continuation line, keep reading
            if ((ch != ' ' && ch != '\t') || (0 == cbRead && 0 == m_rLine.cb))
            {
                // Done
                break;
            }

            // Otherwise, strip continuation...
            else
            {
                // Per RFC822, we should not step over a space
                if (ch == '\t')
                {
                    m_rBuffer.i++;
                    m_uliOffset.QuadPart++;
                }

                // No characters since last whitespace
                if (0 == cTrailingSpace)
                {
                    // Locals
                    DWORD cFrontSpace=0;

                    // Look ahead in the buffer a little
                    for (DWORD iLookAhead = m_rBuffer.i; iLookAhead < m_rBuffer.cb; iLookAhead++)
                    {
                        // Get Char
                        ch = m_rBuffer.rgb[iLookAhead];

                        // Break on non space
                        if (' ' != ch && '\t' != ch)
                            break;

                        // Count Front Space
                        cFrontSpace++;
                    }

                    // No Front Space ?
                    if (0 == cFrontSpace)
                    {
                        // Lets do this only fro Received: and for Date: since dates that get split don't get parsed correctly?
                        if ((m_rLine.cb >= 4 && 0 == StrCmpNI("Date", (LPCSTR)m_rLine.pb, 4)) || (m_rLine.cb >= 8 && 0 == StrCmpNI("Received", (LPCSTR)m_rLine.pb, 8)))
                        {
                            // Put a space in
                            *(m_rLine.pb + m_rLine.cb) = ' ';

                            // Increment line byte count
                            m_rLine.cb += 1;
                        }
                    }
                }

                // Get next buffer
                CHECKHR(hr = _HrGetNextBuffer());

                // If Next character is a \r or \n, then stop, NETSCAPE bug
                ch = m_rBuffer.rgb[m_rBuffer.i];
                if (chCR == ch || chLF == ch)
                    break;
            }

            // Reset
            cTrailingSpace = 0;
        }
    }

    // A little check
#ifndef _WIN64
    Assert(chLF != m_rLine.pb[m_rLine.cb-1] && chCR != m_rLine.pb[m_rLine.cb-1]);
#endif 

    // Null terminator
    *(m_rLine.pb + m_rLine.cb) = '\0';

    // Lets locate the colon
    for (i=0; i<m_rLine.cb; i++)
    {
        // Colon ?
        if (':' == m_rLine.pb[i])
        {
            *piColonPos = i;
            break;
        }
    }

    // Set return values
    pLine->pszVal = (LPSTR)m_rLine.pb;
    pLine->cchVal = m_rLine.cb;

    // Tracking
    INETSTMTRACE("CInternetStream: %s\n", (LPSTR)m_rLine.pb);

    // Reset the Line
    m_rLine.fReset = TRUE;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetprot.h ===
// --------------------------------------------------------------------------------
// Inetprot.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETPROP_H
#define __INETPROP_H

// --------------------------------------------------------------------------------
// INETPROT
// --------------------------------------------------------------------------------
#define INETPROT_SIZEISKNOWN    FLAG01      // Total size of the protocol data is known
#define INETPROT_DOWNLOADED     FLAG02      // The data is all present in pLockBytes

// --------------------------------------------------------------------------------
// PROTOCOLSOURCE
// --------------------------------------------------------------------------------
typedef struct tagPROTOCOLSOURCE {
    DWORD               dwFlags;            // INETPROT_xxx Flags
    ILockBytes         *pLockBytes;         // Lock Bytes
    ULARGE_INTEGER      cbSize;             // Total sizeof pLockBytes if INETPROT_TOTALSIZE
    ULARGE_INTEGER      offExternal;        // External UrlMon Offset
    ULARGE_INTEGER      offInternal;        // Internal MsgMon Offset
} PROTOCOLSOURCE, *LPPROTOCOLSOURCE;

// --------------------------------------------------------------------------------
// HrPluggableProtocolRead
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolRead(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in,out */    LPVOID              pv,
            /* in */        ULONG               cb, 
            /* out */       ULONG              *pcbRead);

// --------------------------------------------------------------------------------
// HrPluggableProtocolSeek
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolSeek(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in */        LARGE_INTEGER       dlibMove, 
            /* in */        DWORD               dwOrigin, 
            /* out */       ULARGE_INTEGER     *plibNew);

#endif // __INETPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetconv.h ===
// --------------------------------------------------------------------------------
// Inetconv.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETCONV_H
#define __INETCONV_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "binhex.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
#ifdef MAC
typedef PMAC_LineBreakConsole   LPLINEBREAKER;
#else   // !MAC
interface IMLangLineBreakConsole;
typedef IMLangLineBreakConsole *LPLINEBREAKER;
#endif  // !MAC

// --------------------------------------------------------------------------------
// Rfc1522.cpp Uses This Table for Base64 Encoding
// --------------------------------------------------------------------------------
extern const CHAR g_rgchDecodeBase64[256];
extern const CHAR g_rgchEncodeBase64[];
extern const CHAR g_rgchHex[];

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define CCHMAX_ENCODEUU_IN      45 
#define CCHMAX_ENCODEUU_OUT     70 
#define CCHMAX_QPLINE           72
#define CCHMAX_ENCODE64_IN      57
#define CCHMAX_ENCODE64_OUT     80
#define CCHMAX_DECODE64_OUT     60

// --------------------------------------------------------------------------------
// UU decoder
// --------------------------------------------------------------------------------
#define UUDECODE(c) (((c) == '`') ? '\0' : ((c) - ' ') & 0x3F)
#define UUENCODE(c) ((c) ? ((c) & 0x3F ) + ' ' : '`')

// --------------------------------------------------------------------------------
// Macros shared with Rfc1522.cpp
// --------------------------------------------------------------------------------
#define DECODE64(_ch) (g_rgchDecodeBase64[(unsigned)_ch])

// --------------------------------------------------------------------------------
// BinHex decoder
// --------------------------------------------------------------------------------
#define DECODEBINHEX(_ch) (g_rgchDecodeBinHex[(unsigned)_ch])
#define FBINHEXRETURN(_ch) (((_ch) == '\t') || ((_ch) == chCR) || ((_ch) == chLF) || ((_ch) == ' '))

// --------------------------------------------------------------------------------
// CConvertBuffer
// --------------------------------------------------------------------------------
typedef struct tagCONVERTBUFFER {
    LPBYTE              pb;                 // Pointer to static buffer (or allocated buffer)
    ULONG               cbAlloc;            // Size of pb
    ULONG               cb;                 // End of data window 
    ULONG               i;                  // Read read/write position (offset from iStart)
} CONVERTBUFFER, *LPCONVERTBUFFER;

// --------------------------------------------------------------------------------
// Converter Flags
// --------------------------------------------------------------------------------
#define ICF_CODEPAGE    FLAG01              // Code Page Conversion
#define ICF_WRAPTEXT    FLAG02              // Wrapping Text
#define ICF_KILLNBSP    FLAG03              // Removed NBSPs from Uncicode Source

// --------------------------------------------------------------------------------
// CONVINITINFO
// --------------------------------------------------------------------------------
typedef struct tagCONVINITINFO {
    DWORD               dwFlags;            // ICF Flags    
    ENCODINGTYPE        ietEncoding;        // Encoding Type
    CODEPAGEID          cpiSource;          // Source Code Page
    CODEPAGEID          cpiDest;            // Destination Code Page
    LONG                cchMaxLine;         // Maxline length for wrapping
    BOOL                fEncoder;           // Is this an encoder or decoder...
    BOOL                fShowMacBinary;     // Show we give back the data fork only?
    MACBINARY           rMacBinary;         // Macbinary Header
} CONVINITINFO, *LPCONVINITINFO;

// --------------------------------------------------------------------------------
// INETCONVTYPE
// --------------------------------------------------------------------------------
typedef enum tagINETCONVTYPE {              // Append       Write
    ICT_UNKNOWN           = 0,              // --------------------
    ICT_WRAPTEXT_CODEPAGE = 1000,           // m_rIn    --> m_rCset
    ICT_WRAPTEXT          = 1001,           // m_rIn    --> m_rOut
    ICT_CODEPAGE_ENCODE   = 1002,           // m_rCset  --> m_rOut
    ICT_ENCODE            = 1003,           // m_rIn    --> m_rOut
    ICT_DECODE_CODEPAGE   = 1004,           // m_rIn    --> m_rCset
    ICT_DECODE            = 1005,           // m_rIn    --> m_rOut
} INETCONVTYPE;

// --------------------------------------------------------------------------------
// BINHEXSTATEDEC
// --------------------------------------------------------------------------------
typedef enum tagBINHEXSTATEDEC
{
    sSTARTING, sSTARTED, sHDRFILESIZE, sHEADER, sDATA, sDATACRC, sRESOURCE, sRESOURCECRC, sENDING, sENDED
} BINHEXSTATEDEC;

// --------------------------------------------------------------------------------
// Stores the character in _uch in pCon
// --------------------------------------------------------------------------------
#define FConvBuffCanRead(_rCon) \
    (_rCon.i < _rCon.cb)

// --------------------------------------------------------------------------------
// ConvBuffAppend
// --------------------------------------------------------------------------------
#define ConvBuffAppend(_uch) \
    m_rOut.pb[m_rOut.cb++] = _uch

// --------------------------------------------------------------------------------
// ConvBuffAppendW
// --------------------------------------------------------------------------------
#define ConvBuffAppendW(_wch) \
    { \
        *((WCHAR *)&m_rOut.pb[m_rOut.cb]) = _wch; \
        m_rOut.cb += 2; \
    }

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
class CInternetConverter : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // CInternetConverter
    // ----------------------------------------------------------------------------
    CInternetConverter(void);
    ~CInternetConverter(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CInternetConverter Methods
    // ----------------------------------------------------------------------------
    HRESULT HrInit(LPCONVINITINFO pInitInfo);
    HRESULT HrInternetEncode(BOOL fLastBuffer);
    HRESULT HrInternetDecode(BOOL fLastBuffer);

    // ----------------------------------------------------------------------------
    // Methods used to set the current conversion buffer
    // ----------------------------------------------------------------------------
    HRESULT HrFillAppend(LPBLOB pData);
    HRESULT HrWriteConverted(IStream *pStream);
    HRESULT HrWriteConverted(CInternetConverter *pConverter);

private:
    // ----------------------------------------------------------------------------
    // Encoders/Decoders
    // ----------------------------------------------------------------------------
    HRESULT HrEncode64(void);
    HRESULT HrDecode64(void);
    HRESULT HrEncodeUU(void);
    HRESULT HrDecodeUU(void);
    HRESULT HrEncodeQP(void);
    HRESULT HrDecodeQP(void);
    HRESULT HrEncodeBinhex(void);
    HRESULT HrDecodeBinHex(void);


    // ----------------------------------------------------------------------------
    // HrWrapInternetText
    // ----------------------------------------------------------------------------
    HRESULT HrWrapInternetTextA(void);
    HRESULT HrWrapInternetTextW(void);

    HRESULT _FixLineBreakingProblems(IN LCID locale, IN const WCHAR* pszSrc, 
        IN long cchSrc, IN long cMaxColumns, 
        OUT long* pcchLine, OUT long* pcchSkip,
        BOOL * pfDoURLFix);
    HRESULT _GetEndOfURL(IN LPCWSTR pszLine, DWORD cchSize, DWORD * pdwMax);

    // ----------------------------------------------------------------------------
    // Character Set Encoders
    // ----------------------------------------------------------------------------
    HRESULT HrCodePageFromOutToCset(void); // Was HrDecodeCharset
    HRESULT HrCodePageFromCsetToIn(void);  // Was HrEncodeCharset

    // ----------------------------------------------------------------------------
    // Utilities
    // ----------------------------------------------------------------------------
    BOOL FUUEncodeThrowAway(LPSTR pszLine, ULONG cbLine, ULONG *pcbActual, ULONG *pcbLine);
    HRESULT HrBinhexThrowAway(LPSTR pszLine, ULONG cbLine);
    HRESULT HrAppendBuffer(LPCONVERTBUFFER pBuffer, LPBLOB pData, BOOL fKillNBSP);
    void CopyMemoryRemoveNBSP(LPBYTE pbDest, LPBYTE pbSource, ULONG cbSource);
    HRESULT HrInitConvertType(LPCONVINITINFO pInitInfo);
    HRESULT HrBinhexDecodeBuffAppend(UCHAR uchIn, ULONG cchIn, ULONG cchLeft, ULONG * cbProduced);

    // ----------------------------------------------------------------------------
    // Please Inline
    // ----------------------------------------------------------------------------
    inline HRESULT HrGrowBuffer(LPCONVERTBUFFER pBuffer, ULONG cbAppend);
    inline HRESULT HrConvBuffAppendBlock(LPBYTE pb, ULONG cb);
    inline LPSTR   PszConvBuffGetNextLine(ULONG *pcbLine, ULONG *pcbRead, BOOL *pfFound);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG               m_cRef;             // Reference Counting
    DWORD               m_dwFlags;          // ICF Flags
    ENCODINGTYPE        m_ietEncoding;      // Conversion Format
    CODEPAGEID          m_cpiSource;        // Source Code Page
    CODEPAGEID          m_cpiDest;          // Destination Code Page
    LONG                m_cchMaxLine;       // Maxline Length for wrapping
    BOOL                m_fEncoder;         // Encoder ?
    BOOL                m_fLastBuffer;      // There is no more data
    UCHAR               m_uchPrev;          // Used in qp 
    CONVERTBUFFER       m_rIn;              // Used for reading
    CONVERTBUFFER       m_rOut;             // Used for writing
    CONVERTBUFFER       m_rCset;            // Used for writing
    LPCONVERTBUFFER     m_pAppend;          // Buffer appended to in public HrFillAppend
    LPCONVERTBUFFER     m_pWrite;           // Buffer dumped when HrWriteConverted is called
    INETCONVTYPE        m_convtype;         // Conversion type
    LPLINEBREAKER       m_pLineBreak;       // Line Breaker Object
    LCID                m_lcid;             // Locale id used only for line wrapping
    ULONG               m_cbConvert;        // Base64 Convert Buffer Count
    UCHAR               m_uchConvert[4];    // Base64 Convert Buffer
    CBinhexEncoder     *m_pBinhexEncode;    // Binhex Encoder
    BINHEXSTATEDEC      m_eBinHexStateDec;  // Binhex Decoder state
    BOOL                m_fRepeating;       // Binhex repeating flag
    ULONG               m_ulAccum;          // Binhex accumulator
    ULONG               m_cAccum;           // BinHex accumulator count
    CONVERTBUFFER       m_rBinhexHeader;    // BinHex header buffer
    LPCONVERTBUFFER     m_prBinhexOutput;   // BinHex output buffer
    LONG                m_cbToProcess;      // BinHex section count
    ULONG               m_cbDataFork;       // BinHex data fork size
    ULONG               m_cbResourceFork;   // BinHex resource fork size
    WORD                m_wCRC;             // BinHex working CRC holder
    WORD                m_wCRCForFork;      // BinHex the CRC for the current fork
    BOOL                m_fDataForkOnly;    // BinHex give back only the data fork
};

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
HRESULT HrCreateInternetConverter(LPCONVINITINFO pInitInfo, CInternetConverter **ppConverter);

#endif __INETCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\internat.cpp ===
// --------------------------------------------------------------------------------
// Internat.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "internat.h"
#include "variantx.h"
#include "containx.h"
#include "symcache.h"
#include "icoint.h"
#include "mlang.h"
#include "demand.h"
#include "strconst.h"
#include "mimeapi.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "qstrcmpi.h"

// In rfc1522.cpp
BOOL FContainsExtended(LPPROPSTRINGA pStringA, ULONG *pcExtended);

// --------------------------------------------------------------------------------
// Global Default Charset - This is only used if mlang is not installed
// --------------------------------------------------------------------------------
INETCSETINFO CIntlGlobals::mg_rDefaultCharset = {
    "ISO-8859-1",
    NULL,
    1252,
    28591,
    0
};

// --------------------------------------------------------------------------------
// InitInternational
// --------------------------------------------------------------------------------
void InitInternational(void)
{

    // Allocate g_pInternat
    g_pInternat = new CMimeInternational;
    if (NULL == g_pInternat)
    {
        AssertSz(FALSE, "Unable to allocate g_pInternat.");
        return;
    }
    CIntlGlobals::Init();
}

// --------------------------------------------------------------------------------
// CMimeInternational::CMimeInternational
// --------------------------------------------------------------------------------
CMimeInternational::CMimeInternational(void)
{
    // Var Init
    m_cRef = 1;
    ZeroMemory(&m_cst, sizeof(CSTABLE));
    ZeroMemory(&m_cpt, sizeof(CPTABLE));

    // Init HCHARSET tagger, don't let it be zero
    m_wTag = LOWORD(GetTickCount());
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    m_dwConvState = 0 ; 
}
 
// --------------------------------------------------------------------------------
// CMimeInternational::~CMimeInternational
// --------------------------------------------------------------------------------
CMimeInternational::~CMimeInternational(void)
{
    // Clean up globals
    CIntlGlobals::Term();

    // Free data
    _FreeInetCsetTable();
    _FreeCodePageTable();
}

// --------------------------------------------------------------------------------
// CMimeInternational::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeInternational == riid)
        *ppv = (IMimeInternational *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeInternational::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeInternational::AddRef(void)
{
    // Raid 26762
    DllAddRef();
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeInternational::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeInternational::Release(void)
{
    // Raid 26762
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    else
        DllRelease();
    return (ULONG)cRef;
}

// -------------------------------------------------------------------------
// CMimeInternational::_FreeInetCsetTable
// -------------------------------------------------------------------------
void CMimeInternational::_FreeInetCsetTable(void)
{
    // Free Each Charset
    for (ULONG i=0; i<m_cst.cCharsets; i++)
        g_pMalloc->Free((LPVOID)m_cst.prgpCharset[i]);

    // Free the Array
    SafeMemFree(m_cst.prgpCharset);

    // Clear the Table
    ZeroMemory(&m_cst, sizeof(CSTABLE));
}

// -------------------------------------------------------------------------
// CMimeInternational::_FreeCodePageTable
// -------------------------------------------------------------------------
void CMimeInternational::_FreeCodePageTable(void)
{
    // Free Each Charset
    for (ULONG i=0; i<m_cpt.cPages; i++)
        g_pMalloc->Free((LPVOID)m_cpt.prgpPage[i]);

    // Free the Array
    SafeMemFree(m_cpt.prgpPage);

    // Clear the Table
    ZeroMemory(&m_cpt, sizeof(CPTABLE));
}

// -------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// -------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(LPCSTR pszCharset, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUpper,
                    lLower,
                    lMiddle,
                    nCompare;
    ULONG           i;
    BOOL            fExcLock;

    fExcLock = FALSE;

    // Invalid Arg
    Assert(pszCharset && ppCharset);

    // Init
    *ppCharset = NULL;

    // Thread Safety
    m_lock.ShareLock();

again:
    // Do we have anything yet
    if (m_cst.cCharsets > 0)
    {
        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_cst.cCharsets - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // Get string to compare against
            i = m_cst.prgpCharset[lMiddle]->dwReserved1;

            // Do compare
            nCompare = OEMstrcmpi(pszCharset, m_cst.prgpCharset[i]->szName);

            // If Equal, then were done
            if (nCompare == 0)
            {
                *ppCharset = m_cst.prgpCharset[i];
                goto exit;
            }

            // Compute upper and lower 
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }
    if(FALSE == fExcLock)
    {
        m_lock.ShareUnlock();       //Release the Sharelock before
        m_lock.ExclusiveLock();     //getting the exclusive lock
        fExcLock = TRUE; 
        //during the change of lock the value might have changed
        //check it again
        goto again;
    }
    // Not found, lets open the registry
    CHECKHR(hr = _HrReadCsetInfo(pszCharset, ppCharset));

exit:
    // Thread Safety
    if(TRUE==fExcLock)
        m_lock.ExclusiveUnlock();
    else
        m_lock.ShareUnlock();

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::_HrReadCsetInfo
// -------------------------------------------------------------------------
HRESULT CMimeInternational::_HrReadCsetInfo(LPCSTR pszCharset, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset=NULL;
    IMultiLanguage  *pMLang1 = NULL;
    IMultiLanguage2 *pMLang2 = NULL;
    MIMECSETINFO    mciInfo;
    BSTR            strCharset = NULL;
    int				iRes;
    
    // Invalid Arg
    Assert(pszCharset && ppCharset);
    
    // Init
    *ppCharset = NULL;
    
    // Try to create an IMultiLanguage2 interface
    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_MLANG2))
    {
        
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage2, (LPVOID *) &pMLang2);
        if (!SUCCEEDED(hr)) 
        {
            // Ok that failed, so lets try to create an IMultiLanaguage interface
            hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
            if (!SUCCEEDED(hr)) 
            {
                TrapError(hr);
                goto exit;
            }
        }
    }
    else
    {
        // Ok that failed, so lets try to create an IMultiLanaguage interface
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            goto exit;
        }
    }
    // MLANG wants the charset name as a BSTR, so we need to convert it from ANSI...
    strCharset = SysAllocStringLen(NULL,lstrlen(pszCharset));
    if (!strCharset) 
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    iRes = MultiByteToWideChar(CP_ACP,0,pszCharset,-1,strCharset,SysStringLen(strCharset)+1);
    if (iRes == 0) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr)) 
        {
            hr = E_FAIL;
        }
        TrapError(hr);
        goto exit;
    }
    
    // Use pMLang2
    if (pMLang2)
    {
        // Use mlang2
        hr = pMLang2->GetCharsetInfo(strCharset, &mciInfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;
            goto exit;
        }
    }
    
    else
    {
        // Now just call MLANG to get the info...
        hr = pMLang1->GetCharsetInfo(strCharset, &mciInfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;
            goto exit;
        }
    }
    
    // Add a new entry into the language table
    if (m_cst.cCharsets + 1 >= m_cst.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_cst.prgpCharset, sizeof(LPINETCSETINFO) * (m_cst.cAlloc +  5)));
        
        // Increment Alloc
        m_cst.cAlloc += 5;
    }
    
    // Allocate a Charset
    CHECKALLOC(pCharset = (LPINETCSETINFO)g_pMalloc->Alloc(sizeof(INETCSETINFO)));
    
    // Initialize
    ZeroMemory(pCharset, sizeof(INETCSETINFO));
    
    // Set Sort Index
    pCharset->dwReserved1 = m_cst.cCharsets;
    
    // Set HCharset
    pCharset->hCharset = HCSETMAKE(m_cst.cCharsets);
    
    // Read Data
    StrCpyN(pCharset->szName, pszCharset, ARRAYSIZE(pCharset->szName));
    pCharset->cpiInternet = mciInfo.uiInternetEncoding;
    pCharset->cpiWindows = mciInfo.uiCodePage;
    
    // Readability
    m_cst.prgpCharset[m_cst.cCharsets] = pCharset;
    
    // Return it
    *ppCharset = pCharset;
    
    // Don't Free It
    pCharset = NULL;
    
    // Increment Count
    m_cst.cCharsets++;
    
    // Let Sort the cset table
    _QuickSortCsetInfo(0, m_cst.cCharsets - 1);
    
exit:
    // Cleanup
    SafeRelease(pMLang1);
    SafeRelease(pMLang2);
    if (strCharset) 
    {
        SysFreeString(strCharset);
    }
    SafeMemFree(pCharset);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::_QuickSortCsetInfo
// --------------------------------------------------------------------------------
void CMimeInternational::_QuickSortCsetInfo(long left, long right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_cst.prgpCharset[(i + j) / 2]->dwReserved1;

    do  
    {
        while(OEMstrcmpi(m_cst.prgpCharset[m_cst.prgpCharset[i]->dwReserved1]->szName, m_cst.prgpCharset[k]->szName) < 0 && i < right)
            i++;
        while (OEMstrcmpi(m_cst.prgpCharset[m_cst.prgpCharset[j]->dwReserved1]->szName, m_cst.prgpCharset[k]->szName) > 0 && j > left)
            j--;

        if (i <= j)
        {
            temp = m_cst.prgpCharset[i]->dwReserved1;
            m_cst.prgpCharset[i]->dwReserved1 = m_cst.prgpCharset[j]->dwReserved1;
            m_cst.prgpCharset[j]->dwReserved1 = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QuickSortCsetInfo(left, j);
    if (i < right)
        _QuickSortCsetInfo(i, right);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(HCHARSET hCharset, LPINETCSETINFO *ppCharset)
{
    // Invalid Arg
    Assert(hCharset && ppCharset);

    // Init
    *ppCharset = NULL;

    // Invalid Handle
    if (HCSETVALID(hCharset) == FALSE)
        return TrapError(MIME_E_INVALID_HANDLE);

    // Deref
    *ppCharset = PCsetFromHCset(hCharset);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrFindCodePage
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrFindCodePage(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUpper,
                    lLower,
                    lMiddle,
                    nCompare;
    BOOL            fExcLock;

    fExcLock = FALSE;


    // Invalid Arg
    Assert(ppCodePage);

    // Init
    *ppCodePage = NULL;

    // Thread Safety
    m_lock.ShareLock();

again:
    // Do We have anything yet
    if (m_cpt.cPages > 0)
    {
        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_cpt.cPages - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // If Equal, then were done
            if (cpiCodePage == m_cpt.prgpPage[lMiddle]->cpiCodePage)
            {
                *ppCodePage = m_cpt.prgpPage[lMiddle];
                goto exit;
            }

            // Compute upper and lower 
            if (cpiCodePage > m_cpt.prgpPage[lMiddle]->cpiCodePage)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }
    if(FALSE == fExcLock)
    {
        m_lock.ShareUnlock();       //Release the Sharelock before
        m_lock.ExclusiveLock();     //getting the exclusive lock
        fExcLock = TRUE; 
        //during the change of lock the value might have changed
        //check it again
        goto again;
    }

    // Not found, lets open the registry
    CHECKHR(hr = _HrReadPageInfo(cpiCodePage, ppCodePage));

exit:
    // Thread Safety
    if(TRUE==fExcLock)
        m_lock.ExclusiveUnlock();
    else
        m_lock.ShareUnlock();

    // Done
    return hr;
}

HRESULT convert_mimecpinfo_element(LPCWSTR pszFrom,
                                   LPSTR pszTo,
                                   DWORD cchTo,
                                   DWORD& refdwFlags,
                                   DWORD dwFlag) {
    HRESULT hr = S_OK;
    int iRes;

    if (pszFrom[0]) {
        iRes = WideCharToMultiByte(CP_ACP,
                                   0,
                                   pszFrom,
                                   -1,
                                   pszTo,
                                   cchTo,
                                   NULL,
                                   NULL);
        if (iRes == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr)) {
                hr = E_FAIL;
            }
        } else {
            FLAGSET(refdwFlags,dwFlag);
        }
    }
    return (hr);
}


#define CONVERT_MIMECPINFO_ELEMENT(__FROM__,__TO__,__FLAG__) \
    hr = convert_mimecpinfo_element(cpinfo.__FROM__, \
                                    pCodePage->__TO__, \
                                    sizeof(pCodePage->__TO__)/sizeof(pCodePage->__TO__[0]), \
                                    pCodePage->dwMask, \
                                    __FLAG__); \
    if (!SUCCEEDED(hr)) { \
        TrapError(hr); \
        goto exit; \
    }

// -------------------------------------------------------------------------
// CMimeInternational::_HrReadPageInfo
// -------------------------------------------------------------------------
HRESULT CMimeInternational::_HrReadPageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pCodePage=NULL;
    MIMECPINFO		cpinfo;
    IMultiLanguage 	*pMLang1=NULL;
    IMultiLanguage2	*pMLang2=NULL;
    int				iRes;
    
    // Invalid Arg
    Assert(ppCodePage);
    
    // Init
    *ppCodePage = NULL;
    
    // Try to create an IMultiLanguage2 interface
    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_MLANG2))
    {
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage2, (LPVOID *) &pMLang2);
        if (!SUCCEEDED(hr)) 
        {
            // Ok that failed, so lets try to create an IMultiLanaguage interface
            hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
            if (!SUCCEEDED(hr)) 
            {
                TrapError(hr);
                goto exit;
            }
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            goto exit;
        }
    }
    
    // Use mlang2 ?
    if (pMLang2)
    {
        // use mlang2
        hr = pMLang2->GetCodePageInfo(cpiCodePage, MLGetUILanguage(), &cpinfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;	// tbd - MLang doesn't define good error codes, so...
            goto exit;
        }
    }
    
    // Otherwise use ie4 mlang
    else
    {
        // use mlang1
        hr = pMLang1->GetCodePageInfo(cpiCodePage, &cpinfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;	// tbd - MLang doesn't define good error codes, so...
            goto exit;
        }
    }
    
    
    // Add a new entry into the language table
    if (m_cpt.cPages + 1 >= m_cpt.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_cpt.prgpPage, sizeof(LPCODEPAGEINFO) * (m_cpt.cAlloc +  5)));
        
        // Increment Alloc
        m_cpt.cAlloc += 5;
    }
    
    // Allocate Code Page Structure
    CHECKALLOC(pCodePage = (LPCODEPAGEINFO)g_pMalloc->Alloc(sizeof(CODEPAGEINFO)));
    
    // Initialize
    ZeroMemory(pCodePage, sizeof(CODEPAGEINFO));
    
    // Set Sort Index
    pCodePage->dwReserved1 = m_cpt.cPages;
    
    // Set Charset
    pCodePage->cpiCodePage = cpiCodePage;
    
    // IsValidCodePage
    pCodePage->fIsValidCodePage = IsValidCodePage(cpiCodePage);
    
    // Default
    pCodePage->ulMaxCharSize = 1;
    
    // Raid 43508: GetCPInfo faults in Kernal when passed an invalid codepage on Win95
    // if (pCodePage->fIsValidCodePage  && GetCPInfo(pCodePage->cpiCodePage, &cpinfo))
    if (IsDBCSCodePage(cpiCodePage) || CP_UNICODE == cpiCodePage)
        pCodePage->ulMaxCharSize = 2;
    
    // c_szDescription
    CONVERT_MIMECPINFO_ELEMENT(wszDescription,szName,ILM_NAME)
        
        // c_szBodyCharset
        CONVERT_MIMECPINFO_ELEMENT(wszBodyCharset,szBodyCset,ILM_BODYCSET)
        
        // c_szHeaderCharset
        CONVERT_MIMECPINFO_ELEMENT(wszHeaderCharset,szHeaderCset,ILM_HEADERCSET)
        
        // c_szWebCharset
        CONVERT_MIMECPINFO_ELEMENT(wszWebCharset,szWebCset,ILM_WEBCSET)
        
        // c_szFixedWidthFont
        CONVERT_MIMECPINFO_ELEMENT(wszFixedWidthFont,szFixedFont,ILM_FIXEDFONT)
        
        // c_szProportionalFont
        CONVERT_MIMECPINFO_ELEMENT(wszProportionalFont,szVariableFont,ILM_VARIABLEFONT)
        
        // Set the Family CodePage
        pCodePage->cpiFamily = cpinfo.uiFamilyCodePage;
    
    // The family codepage is valid
    FLAGSET(pCodePage->dwMask,ILM_FAMILY);
    
    // See if this is an internet codepage
    if (cpinfo.uiFamilyCodePage != cpinfo.uiCodePage) 
        pCodePage->fInternetCP = TRUE;
    
    // c_szMailMimeEncoding
    // tbd - not supported by IMultiLanguage
    pCodePage->ietMailDefault = IET_BINARY;
    
    // c_szNewsMimeEncoding
    // tbd - not supported by IMultiLanguage
    pCodePage->ietNewsDefault = IET_BINARY;
    
    // Readability
    m_cpt.prgpPage[m_cpt.cPages] = pCodePage;
    
    // Return it
    *ppCodePage = pCodePage;
    
    // Don't Free It
    pCodePage = NULL;
    
    // Increment Count
    m_cpt.cPages++;
    
    // Let Sort the lang table
    _QuickSortPageInfo(0, m_cpt.cPages - 1);
    
exit:
    // Cleanup
    SafeRelease(pMLang1);
    SafeRelease(pMLang2);
    SafeMemFree(pCodePage);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::_QuickSortPageInfo
// --------------------------------------------------------------------------------
void CMimeInternational::_QuickSortPageInfo(long left, long right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_cpt.prgpPage[(i + j) / 2]->dwReserved1;

    do  
    {
        while(m_cpt.prgpPage[m_cpt.prgpPage[i]->dwReserved1]->cpiCodePage < m_cpt.prgpPage[k]->cpiCodePage && i < right)
            i++;
        while (m_cpt.prgpPage[m_cpt.prgpPage[j]->dwReserved1]->cpiCodePage > m_cpt.prgpPage[k]->cpiCodePage && j > left)
            j--;

        if (i <= j)
        {
            temp = m_cpt.prgpPage[i]->dwReserved1;
            m_cpt.prgpPage[i]->dwReserved1 = m_cpt.prgpPage[j]->dwReserved1;
            m_cpt.prgpPage[j]->dwReserved1 = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QuickSortPageInfo(left, j);
    if (i < right)
        _QuickSortPageInfo(i, right);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pCodePage;

    // Invalid Arg
    Assert(ppCharset);

    // Init
    *ppCharset = NULL;

    // Get the body charset
    CHECKHR(hr = HrFindCodePage(cpiCodePage, &pCodePage));

    // CHARSET_HEADER
    if (CHARSET_HEADER == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_HEADERCSET) || FIsEmptyA(pCodePage->szHeaderCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szHeaderCset, ppCharset));
    }

    // CHARSET_WEB
    else if (CHARSET_WEB == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_WEBCSET) || FIsEmptyA(pCodePage->szWebCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szWebCset, ppCharset));
    }

    // CHARSET_BODY
    else if (CHARSET_BODY == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_BODYCSET) || FIsEmptyA(pCodePage->szBodyCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szBodyCset, ppCharset));
    }

    // Error
    else
    {
        hr = TrapError(MIME_E_INVALID_CHARSET_TYPE);
        goto exit;
    }
   
exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCodePageCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Call Method
    CHECKHR(hr = HrOpenCharset(cpiCodePage, ctCsetType, &pCharset));

    // Return the Handle
    *phCharset = pCharset->hCharset;

exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::SetDefaultCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::SetDefaultCharset(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;
    LPINETCSETINFO  pDefHeadCset;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Bad Handle
    if (HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Get Charset Info
    pCharset = PCsetFromHCset(hCharset);

    // Get g_hSysBodyCset and g_hSysHeadCset
    if (FAILED(g_pInternat->HrOpenCharset(pCharset->cpiInternet, CHARSET_HEADER, &pDefHeadCset)))
        pDefHeadCset = pCharset;

    // Set Globals
    CIntlGlobals::SetDefBodyCset(pCharset);
    CIntlGlobals::SetDefHeadCset(pDefHeadCset);

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetDefaultCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetDefaultCharset(LPHCHARSET phCharset)
{
    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // NOT SET YET
    if (NULL == CIntlGlobals::GetDefBodyCset())
        return TrapError(E_FAIL);

    // Return g_hDefBodyCset
    *phCharset = CIntlGlobals::GetDefBodyCset()->hCharset;
   
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CMimeInternational::FindCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::FindCharset(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == pszCharset || NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Find CsetInfo
    CHECKHR(hr = HrOpenCharset(pszCharset, &pCharset));

    // Return Charset Handles
    *phCharset = pCharset->hCharset;

exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCharsetInfo
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo)
{
    // Invalid Arg
    if (NULL == hCharset || NULL == pCsetInfo)
        return TrapError(E_INVALIDARG);

    // Bad Handle
    if (HCSETVALID(hCharset) == FALSE)
        return TrapError(MIME_E_INVALID_HANDLE);

    // Copy the data
    CopyMemory(pCsetInfo, PCsetFromHCset(hCharset), sizeof(INETCSETINFO));

    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCodePageInfo
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pInfo;

    // Invalid Arg
    if (NULL == pCodePage)
        return TrapError(E_INVALIDARG);

    // Default the code page to CP_ACP if 0...
    if (CP_ACP == cpiCodePage)
        cpiCodePage = GetACP();

    // Get Language Info
    CHECKHR(hr = HrFindCodePage(cpiCodePage, &pInfo));

    // Copy the data
    CopyMemory(pCodePage, pInfo, sizeof(CODEPAGEINFO));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::CanConvertCodePages
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::CanConvertCodePages(CODEPAGEID cpiSource, CODEPAGEID cpiDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Can Encode
    if (S_OK != IsConvertINetStringAvailable(cpiSource, cpiDest))
    {
        hr = S_FALSE;
        goto exit;
    }

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    m_dwConvState = 0 ;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::ConvertBuffer
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::ConvertBuffer(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPBLOB pIn, LPBLOB pOut, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cbOut;
    INT             cbIn;

    // Invalid Arg
    if (NULL == pIn || NULL == pIn->pBlobData || NULL == pOut)
        return TrapError(E_INVALIDARG);

    // Init Out
    pOut->pBlobData = NULL;
    pOut->cbSize = 0;
    cbIn = pIn->cbSize;

    // Raid-63765: INETCOMM needs to call MLANG even if Src == Dst for charset set conversion
#if 0
    if (cpiSource == cpiDest)
    {
        // Allocated
        CHECKALLOC(pOut->pBlobData = (LPBYTE)g_pMalloc->Alloc(pIn->cbSize));

        // Copy Memory
        CopyMemory(pOut->pBlobData, pIn->pBlobData, pIn->cbSize);

        // Set Size
        pOut->cbSize = pIn->cbSize;

        // Set pcbRead
        if (pcbRead)
            *pcbRead = pIn->cbSize;

        // Done
        goto exit;
    }
#endif

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    // Check the size of the buffer
    ConvertINetString(&m_dwConvState, cpiSource, cpiDest, (LPCSTR)pIn->pBlobData, &cbIn, NULL, &cbOut);

    // If something to convert...
    if (0 == cbOut)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate the buffer
    CHECKHR(hr = HrAlloc((LPVOID *)&pOut->pBlobData, max(cbIn, cbOut) + 1));

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    // Do the actual convertion
    hr = ConvertINetString(&m_dwConvState, cpiSource, cpiDest, (LPCSTR)pIn->pBlobData, &cbIn, (LPSTR)pOut->pBlobData, (LPINT)&cbOut);

    if ( hr == S_FALSE )    // propagate the charset conflict return value
        hr = MIME_S_CHARSET_CONFLICT ; 

    // Set Out Size
    if (pcbRead)
        *pcbRead = cbIn;

    // Set Out Size
    pOut->cbSize = cbOut;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::ConvertString
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::ConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPPROPVARIANT pIn, LPPROPVARIANT pOut)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pIn || NULL == pOut)
        return TrapError(E_INVALIDARG);

    // VT_LPSTR
    if (VT_LPSTR == pIn->vt)
    {
        // Setup Source
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pIn->pszVal;
        rSource.rStringA.cchVal = lstrlen(pIn->pszVal);
    }

    // VT_LPWSTR
    else if (VT_LPWSTR == pIn->vt)
    {
        // Setup Source
        rSource.type = MVT_STRINGW;
        rSource.rStringW.pszVal = pIn->pwszVal;
        rSource.rStringW.cchVal = lstrlenW(pIn->pwszVal);
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // VT_LPSTR
    if (VT_LPSTR == pOut->vt)
        rDest.type = MVT_STRINGA;

    // VT_LPWSTR
    else if (VT_LPWSTR == pOut->vt)
        rDest.type = MVT_STRINGW;

    // CP_UNICODE
    else if (CP_UNICODE == cpiDest)
    {
        pOut->vt = VT_LPWSTR;
        rDest.type = MVT_STRINGW;
    }

    // Multibyte
    else
    {
        pOut->vt = VT_LPSTR;
        rDest.type = MVT_STRINGA;
    }

    // HrConvertString
    hr = HrConvertString(cpiSource, cpiDest, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // VT_LPSTR
    if (VT_LPSTR == pOut->vt)
    {
        // Set Dest
        Assert(ISSTRINGA(&rDest));
        pOut->pszVal = rDest.rStringA.pszVal;
    }

    // VT_LPWSTR
    else
    {
        // Set Dest
        Assert(ISSTRINGW(&rDest));
        pOut->pwszVal = rDest.rStringW.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrValidateCodepages
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrValidateCodepages(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest,
    LPBYTE *ppbSource, ULONG *pcbSource, CODEPAGEID *pcpiSource, CODEPAGEID *pcpiDest)
{
    // Locals
    HRESULT     hr=S_OK;
    CODEPAGEID  cpiSource=(*pcpiSource);
    CODEPAGEID  cpiDest=(*pcpiDest);
    LPBYTE      pbSource;
    ULONG       cbSource;

    // Invalid ARg
    Assert(pcpiSource && pcpiDest);

    // MVT_STRINGA
    if (MVT_STRINGA == pSource->type)
    {
        // E_INVALIDARG
        if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // cpiSource should not be unicode
        cpiSource = (CP_UNICODE == cpiSource) ? GetACP() : cpiSource;

        // Init Out
        cbSource = pSource->rStringA.cchVal;

        // Set Source
        pbSource = (LPBYTE)pSource->rStringA.pszVal;
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pSource->type)
    {
        // E_INVALIDARG
        if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // cpiSource should be Unicode
        cpiSource = CP_UNICODE;

        // Init Out
        cbSource = (pSource->rStringW.cchVal * sizeof(WCHAR));

        // Set Source
        pbSource = (LPBYTE)pSource->rStringW.pszVal;
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // cpiDest shoudl not be unicode
        cpiDest = (CP_UNICODE == cpiDest) ? GetACP() : ((CP_JAUTODETECT == cpiDest) ? 932 : cpiDest);
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // Destination is Unicode
        cpiDest = CP_UNICODE;
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Set Return Values
    if (pcpiSource)
        *pcpiSource = cpiSource;
    if (pcpiDest)
        *pcpiDest = cpiDest;
    if (ppbSource)
        *ppbSource = pbSource;
    if (pcbSource)
        *pcbSource = cbSource;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrConvertString
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cbNeeded=0;
    INT             cbDest;
    INT             cbSource;
    LPBYTE          pbSource;
    LPBYTE          pbDest=NULL;

    // Invalid Arg
    if (NULL == pSource || NULL == pDest)
        return TrapError(E_INVALIDARG);

    // Adjust the Codepages
    CHECKHR(hr = HrValidateCodepages(pSource, pDest, &pbSource, (ULONG *)&cbSource, &cpiSource, &cpiDest));

    // Raid-63765: INETCOMM needs to call MLANG even if Src == Dst for charset set conversion
#if 0
    if (cpiSource == cpiDest)
    {
        // Copy the variant
        CHECKHR(hr = HrMimeVariantCopy(0, pSource, pDest));

        // Done
        goto exit;
    }
#endif

    // Check the size of the buffer
    if (FAILED(ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pbSource, &cbSource, NULL, &cbNeeded)) || 
        (0 == cbNeeded && cbSource > 0))
    {
        hr = E_FAIL;
        goto exit;
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // Allocate the buffer
        CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(cbNeeded + sizeof(CHAR)));

        // Set Dest
        pbDest = (LPBYTE)pDest->rStringA.pszVal;
    }

    // Allocate unicode
    else 
    {
        // Allocate the buffer
        CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cbNeeded + sizeof(WCHAR)));

        // Set Dest
        pbDest = (LPBYTE)pDest->rStringW.pszVal;
    }

    // Set cbOut
    cbDest = cbNeeded;

    // Do the actual convertion
    if (FAILED(ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pbSource, &cbSource, (LPSTR)pbDest, &cbDest)))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Better not have grown
    Assert(cbDest <= cbNeeded);

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // Save Size
        pDest->rStringA.cchVal = cbDest;

        // Pound in a Null
        pDest->rStringA.pszVal[pDest->rStringA.cchVal] = '\0';

        // Validate the String
        Assert(ISSTRINGA(pDest));
    }

    // MVT_STRINGW
    else
    {
        // Save Size
        pDest->rStringW.cchVal = (cbDest / 2);

        // Pound in a Null
        pDest->rStringW.pszVal[pDest->rStringW.cchVal] = L'\0';

        // Validate the String
        Assert(ISSTRINGW(pDest));
    }

    // Success
    pbDest = NULL;

exit:
    // Cleanup
    SafeMemFree(pbDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrEncodeHeader
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrEncodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, 
    LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszNarrow=NULL;
    LPSTR           pszRfc1522=NULL;
    BOOL            fRfc1522Used=FALSE;
    BOOL            fRfc1522Tried=FALSE;
    MIMEVARIANT     rRedirected;

    // Invalid Arg
    Assert(pSource && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type));
    Assert(pDest && MVT_STRINGA == pDest->type);

    // ZeroInit
    ZeroMemory(&rRedirected, sizeof(MIMEVARIANT));

    // Default hCharset
    if (NULL == pCharset)
        pCharset = CIntlGlobals::GetDefHeadCset();

    // No Charset..
    if (NULL == pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Init
    if (pRfc1522Info)
        pRfc1522Info->fRfc1522Used = FALSE;

    // Raid-62535: MimeOle always 1521 encodes headers when header value is Unicode
    // If source is unicode and were not using a UTF character set to encode with, then convert to multibyte
    if (MVT_STRINGW == pSource->type && CP_UNICODE != pCharset->cpiWindows)
    {
        // Setup MimeVariant
        rRedirected.type = MVT_STRINGA;

        // Convert to pCharset->cpiWindows
        CHECKHR(hr = HrWideCharToMultiByte(pCharset->cpiWindows, &pSource->rStringW, &rRedirected.rStringA));

        // Reset pSource
        pSource = &rRedirected;
    }

    // Decode
    if ((65000 == pCharset->cpiInternet || 65001 == pCharset->cpiInternet) ||
        (NULL == pRfc1522Info || ((FALSE == pRfc1522Info->fAllow8bit) && (TRUE == pRfc1522Info->fRfc1522Allowed))))
    {
        // Locals
        CODEPAGEID cpiSource=pCharset->cpiWindows;
        CODEPAGEID cpiDest=pCharset->cpiInternet;

        // Adjust the Codepages
        CHECKHR(hr = HrValidateCodepages(pSource, pDest, NULL, NULL, &cpiSource, &cpiDest));

        // We Tried rfc1522
        fRfc1522Tried = TRUE;

        // 1522 Encode this dude
        if (SUCCEEDED(HrRfc1522Encode(pSource, pDest, cpiSource, cpiDest, pCharset->szName, &pszRfc1522)))
        {
            // We used Rfc1522
            fRfc1522Used = TRUE;

            // Return Information
            if (pRfc1522Info)
            {
                pRfc1522Info->fRfc1522Used = TRUE;
                pRfc1522Info->hRfc1522Cset = pCharset->hCharset;
            }

            // Setup rStringA
            pDest->rStringA.pszVal = pszRfc1522;
            pDest->rStringA.cchVal = lstrlen(pszRfc1522);
            pszRfc1522 = NULL;
        }
    }

    // If we didn't use RFC 1522, then do a convert string
    if (FALSE == fRfc1522Used)
    {
        // If UTF-7 or UTF-8 and source is ANSI with no 8bit, just dup it
        if (65000 == pCharset->cpiInternet || 65001 == pCharset->cpiInternet)
        {
            // Source is ansi
            if (MVT_STRINGA == pSource->type)
            {
                // Locals
                ULONG c;
                
                // No 8bit
                if (FALSE == FContainsExtended(&pSource->rStringA, &c))
                {
                    // Convert
                    hr = HrConvertString(pCharset->cpiWindows, pCharset->cpiWindows, pSource, pDest);

                    // Were Done
                    goto exit;
                }

                // We must not have tried 1522, because thats what we should have done
                Assert(fRfc1522Tried == FALSE);
            }
        }

        // Do the charset conversion
        hr = HrConvertString(pCharset->cpiWindows, pCharset->cpiInternet, pSource, pDest);
        if (FAILED(hr))
            goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszRfc1522);
    MimeVariantFree(&rRedirected);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrDecodeHeader
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrDecodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, 
    LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pRfc1522Charset=NULL;
    PROPSTRINGA     rTempA;
    LPSTR           pszRfc1522=NULL;
    LPSTR           pszNarrow=NULL;
    MIMEVARIANT     rSource;
    CHAR            szRfc1522Cset[CCHMAX_CSET_NAME];

    // Invalid Arg
    Assert(pSource && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type));
    Assert(pDest && (MVT_STRINGA == pDest->type || MVT_STRINGW == pDest->type));

    // Copy Source
    CopyMemory(&rSource, pSource, sizeof(MIMEVARIANT));

    // MVT_STRINGW
    if (MVT_STRINGW == pSource->type)
    {
        // Better be a valid string
        Assert(ISVALIDSTRINGW(&pSource->rStringW));

        // Conversion
        CHECKHR(hr = HrWideCharToMultiByte(CP_ACP, &pSource->rStringW, &rTempA));
        
        // Free This
        pszNarrow = rTempA.pszVal;

        // Update rSource
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = rTempA.pszVal;
        rSource.rStringA.cchVal = rTempA.cchVal;
    }

    // Decode
    if (NULL == pRfc1522Info || TRUE == pRfc1522Info->fRfc1522Allowed)
    {
        // Perform rfc1522 decode...
        if (SUCCEEDED(MimeOleRfc1522Decode(rSource.rStringA.pszVal, szRfc1522Cset, ARRAYSIZE(szRfc1522Cset), &pszRfc1522)))
        {
            // It was encoded...
            if (pRfc1522Info)
                pRfc1522Info->fRfc1522Used = TRUE;

            // Look up the charset
            if (SUCCEEDED(HrOpenCharset(szRfc1522Cset, &pRfc1522Charset)) && pRfc1522Info)
            {
                // Return in the Info Struct
                pRfc1522Info->hRfc1522Cset = pRfc1522Charset->hCharset;
            }

            // Reset Source
            rSource.rStringA.pszVal = pszRfc1522;
            rSource.rStringA.cchVal = lstrlen(pszRfc1522);

            // No pCharset
            if (NULL == pCharset)
                pCharset = pRfc1522Charset;
        }

        // No Rfc1522
        else if (pRfc1522Info)
        {
            pRfc1522Info->fRfc1522Used = FALSE;
            pRfc1522Info->hRfc1522Cset = NULL;
        }
    }

    // Charset is Still Null, use Default
    if (NULL == pCharset)
        pCharset = CIntlGlobals::GetDefHeadCset();

    // No Charset..
    if (NULL == pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Convert the String
    hr = HrConvertString(pCharset->cpiInternet, pCharset->cpiWindows, &rSource, pDest);
    if (FAILED(hr))
    {
        // If it was rfc1522 decoded, then return it and a warning
        if (pszRfc1522)
        {
            // pszRfc1522 should be in rSource
            Assert(rSource.rStringA.pszVal == pszRfc1522);

            // Return MVT_STRINGA
            if (MVT_STRINGA == pDest->type)
            {
                pDest->rStringA.pszVal = rSource.rStringA.pszVal;
                pDest->rStringA.cchVal = rSource.rStringA.cchVal;
                pszRfc1522 = NULL;
            }

            // MVT_STRINGW
            else
            {
                CHECKHR(hr = HrMultiByteToWideChar(CP_ACP, &rSource.rStringA, &pDest->rStringW));
                pszRfc1522 = NULL;
            }

            // This is not a failure, but just a warning
            hr = MIME_S_NO_CHARSET_CONVERT;
        }

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszNarrow);
    SafeMemFree(pszRfc1522);

    // Done
    return hr;
}



//---------------------------------------------------------------------------------
// Function: MLANG_ConvertInetReset
//
// Purpose:
//   This function is a wrapper function for MLANG.DLL's ConvertInetReset.
//
// Returns:
//   Same as for MLANG.DLL's ConvertInetReset.
//---------------------------------------------------------------------------------
HRESULT CMimeInternational::MLANG_ConvertInetReset(void)
{
    HRESULT hrResult;

    // a stub for now
    return S_OK;

} // MLANG_ConvertInetReset



//---------------------------------------------------------------------------------
// Function: MLANG_ConvertInetString
//
// Purpose:
//   This function is a wrapper function which passes its arguments through to
// MLANG's ConvertInetString.
//
// Arguments:
//   Same as for MLANG.DLL's ConvertInetString.
//
// Returns:
//   Same as for MLANG.DLL's ConvertInetString.
//---------------------------------------------------------------------------------
HRESULT CMimeInternational::MLANG_ConvertInetString(CODEPAGEID cpiSource,
                                                    CODEPAGEID cpiDest,
                                                    LPCSTR pSourceStr,
                                                    LPINT pnSizeOfSourceStr,
                                                    LPSTR pDestinationStr,
                                                    LPINT pnSizeOfDestBuffer)
{
    HRESULT hrResult;

    // Codify Assumptions
    Assert(sizeof(UCHAR) == sizeof(char));

    // Pass the arguments through
    return ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pSourceStr, pnSizeOfSourceStr, (LPSTR) pDestinationStr, pnSizeOfDestBuffer);
} // MLANG_ConvertInetString



// --------------------------------------------------------------------------------
// CMimeInternational::DecodeHeader ANSI -> (ANSI or UNICODE)
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::DecodeHeader(HCHARSET hCharset, LPCSTR pszData, 
    LPPROPVARIANT pDecoded, LPRFC1522INFO pRfc1522Info)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pszData || NULL == pDecoded || (VT_LPSTR != pDecoded->vt && VT_LPWSTR != pDecoded->vt))
        return TrapError(E_INVALIDARG);

    // Setup Source
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = (LPSTR)pszData;
    rSource.rStringA.cchVal = lstrlen(pszData);

    // Setup Destination
    rDest.type = (VT_LPSTR == pDecoded->vt) ? MVT_STRINGA : MVT_STRINGW;

    // Valid Charset
    if (hCharset && HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // HrDecodeHeader
    hr = HrDecodeHeader((NULL == hCharset) ? NULL : PCsetFromHCset(hCharset), pRfc1522Info, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // Put rDest into pDecoded
    if (MVT_STRINGA == rDest.type)
        pDecoded->pszVal = rDest.rStringA.pszVal;
    else
        pDecoded->pwszVal = rDest.rStringW.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::EncodeHeader
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::EncodeHeader(HCHARSET hCharset, LPPROPVARIANT pData, 
        LPSTR *ppszEncoded, LPRFC1522INFO pRfc1522Info)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pData || NULL == ppszEncoded || (VT_LPSTR != pData->vt && VT_LPWSTR != pData->vt))
        return TrapError(E_INVALIDARG);

    // Init
    *ppszEncoded = NULL;

    // VT_LPSTR
    if (VT_LPSTR == pData->vt)
    {
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pData->pszVal;
        rSource.rStringA.cchVal = lstrlen(pData->pszVal);
    }

    // VT_LPWSTR
    else
    {
        rSource.type = MVT_STRINGW;
        rSource.rStringW.pszVal = pData->pwszVal;
        rSource.rStringW.cchVal = lstrlenW(pData->pwszVal);
    }

    // Setup Destination
    rDest.type = MVT_STRINGA;

    // Valid Charset
    if (hCharset && HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // HrDecodeHeader
    hr = HrEncodeHeader((NULL == hCharset) ? NULL : PCsetFromHCset(hCharset), pRfc1522Info, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // Put rDest into pDecoded
    *ppszEncoded = rDest.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::Rfc1522Decode
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::Rfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded)
{
    return MimeOleRfc1522Decode(pszValue, pszCharset, cchmax, ppszDecoded);
}

// --------------------------------------------------------------------------------
// CMimeInternational::Rfc1522Encode
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::Rfc1522Encode(LPCSTR pszValue, HCHARSET hCharset, LPSTR *ppszEncoded)
{
    return MimeOleRfc1522Encode(pszValue, hCharset, ppszEncoded);
}

// --------------------------------------------------------------------------------
// CMimeInternational::FIsValidHandle
// --------------------------------------------------------------------------------
BOOL CMimeInternational::FIsValidHandle(HCHARSET hCharset)
{
    m_lock.ShareLock();
    BOOL f = HCSETVALID(hCharset);
    m_lock.ShareUnlock();
    return f;
}

// --------------------------------------------------------------------------------
// CMimeInternational::IsDBCSCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::IsDBCSCharset(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCsetInfo;

    // Invlaid Handle
    if (HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Get the charset info
    pCsetInfo = PCsetFromHCset(hCharset);

    // Special Cases
    if (pCsetInfo->cpiWindows == CP_JAUTODETECT  ||
        pCsetInfo->cpiWindows == CP_KAUTODETECT  ||
        pCsetInfo->cpiWindows == CP_ISO2022JPESC ||
        pCsetInfo->cpiWindows == CP_ISO2022JPSIO)
    {
        hr = S_OK;
        goto exit;
    }

    // Is Windows Code Page DBCS ?
    hr = (IsDBCSCodePage(pCsetInfo->cpiWindows) == TRUE) ? S_OK : S_FALSE;
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrEncodeProperty
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrEncodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    RFC1522INFO     rRfc1522Info;
    MIMEVARIANT     rSource;

    // Invalid Arg
    Assert(pConvert && pConvert->pSymbol && pConvert->pCharset && pConvert->pOptions && pSource && pDest);
    Assert(ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET));
    Assert(pConvert->ietSource == IET_ENCODED || pConvert->ietSource == IET_DECODED);

    // Init
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));

    // Setup Rfc1522 Info
    ZeroMemory(&rRfc1522Info, sizeof(RFC1522INFO));
    rRfc1522Info.fRfc1522Allowed = ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_RFC1522);
    rRfc1522Info.fAllow8bit = (SAVE_RFC1521 == pConvert->pOptions->savetype) ? pConvert->pOptions->fAllow8bit : TRUE;

    // If Property is Encoded, decode it first
    if (IET_ENCODED == pConvert->ietSource)
    {
        // Set rSource.type
        rSource.type = pDest->type;

        // Decode It
        hr = HrDecodeHeader(pConvert->pCharset, &rRfc1522Info, pSource, &rSource);
        if (FAILED(hr))
            goto exit;
    }

    // Otherwise, use pSource as rSource
    else
    {
        // Setup Source
        CopyMemory(&rSource, pSource, sizeof(MIMEVARIANT));
        rSource.fCopy = TRUE;
    }

    // HrEncodeHeader
    hr = HrEncodeHeader(pConvert->pCharset, &rRfc1522Info, &rSource, pDest);
    if (FAILED(hr))
        goto exit;

    // Set PRSTATE_RFC1511
    if (rRfc1522Info.fRfc1522Used)
        FLAGSET(pConvert->dwState, PRSTATE_RFC1522);

exit:
    // Cleanup
    MimeVariantFree(&rSource);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrDecodeProperty
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrDecodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest)
{
    // Locals
    RFC1522INFO     rRfc1522Info;

    // Invalid Arg
    Assert(pConvert && pConvert->pSymbol && pConvert->pCharset && pConvert->pOptions && pSource && pDest);
    Assert(ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET) && pConvert->ietSource == IET_ENCODED);

    // Setup Rfc1522 Info
    ZeroMemory(&rRfc1522Info, sizeof(RFC1522INFO));
    rRfc1522Info.fRfc1522Allowed = ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_RFC1522);
    rRfc1522Info.fAllow8bit = (SAVE_RFC1521 == pConvert->pOptions->savetype) ? pConvert->pOptions->fAllow8bit : TRUE;

    // HrDecodeHeader
    return HrDecodeHeader(pConvert->pCharset, &rRfc1522Info, pSource, pDest);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrWideCharToMultiByte
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrWideCharToMultiByte(CODEPAGEID cpiCodePage, LPCPROPSTRINGW pStringW, 
    LPPROPSTRINGA pStringA)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(ISVALIDSTRINGW(pStringW) && pStringA);

    // Adjust cpiCodePage
    if (CP_UNICODE == cpiCodePage)
        cpiCodePage = CP_ACP;

    // Init
    pStringA->pszVal = NULL;
    pStringA->cchVal = 0;

    // Determine how much space is needed for translated widechar
    pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, NULL, 0, NULL, NULL);
    if (pStringA->cchVal == 0 && pStringW->cchVal != 0)
    {
        DOUTL(4, "WideCharToMultiByte Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());

        // WideCharToMultiByte failed for some other reason than cpiCodePage being a bad codepage
        if (TRUE == IsValidCodePage(cpiCodePage))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Reset cpiCodePage to a valid codepage
        cpiCodePage = CP_ACP;

        // Use the system acp
        pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, NULL, 0, NULL, NULL);
        if (pStringA->cchVal == 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Allocate It
    CHECKALLOC(pStringA->pszVal = (LPSTR)g_pMalloc->Alloc((pStringA->cchVal + 1)));

    // Do the actual translation
    pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, pStringA->pszVal, pStringA->cchVal + 1, NULL, NULL);
    if (pStringA->cchVal == 0 && pStringW->cchVal != 0)
    {
        DOUTL(4, "WideCharToMultiByte Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Insert the Null
    pStringA->pszVal[pStringA->cchVal] = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrMultiByteToWideChar
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrMultiByteToWideChar(CODEPAGEID cpiCodePage, LPCPROPSTRINGA pStringA, 
    LPPROPSTRINGW pStringW)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    // Bad codepage is okay and will be dealt with below
    Assert(ISVALIDSTRINGA(pStringA) && pStringW);

    // Adjust cpiCodePage
    if (CP_UNICODE == cpiCodePage)
        cpiCodePage = CP_ACP;

    // Init
    pStringW->pszVal = NULL;
    pStringW->cchVal = 0;

    // Determine how much space is needed for translated widechar
    pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, NULL, 0);
    if (pStringW->cchVal == 0 && pStringA->cchVal != 0)
    {
        DOUTL(4, "MultiByteToWideChar Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());

        // MultiByteToWideChar failed for some other reason than cpiCodePage being a bad codepage
        if (TRUE == IsValidCodePage(cpiCodePage))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Reset cpiCodePage to a valid codepage
        cpiCodePage = CP_ACP;

        // Use the system acp
        pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, NULL, 0);
        if (pStringW->cchVal == 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

    }

    // Allocate It
    CHECKALLOC(pStringW->pszVal = (LPWSTR)g_pMalloc->Alloc((pStringW->cchVal + 1) * sizeof(WCHAR)));

    // Do the actual translation
    pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, pStringW->pszVal, pStringW->cchVal + 1);
    if (pStringW->cchVal == 0 && pStringA->cchVal != 0)
    {
        DOUTL(4, "MultiByteToWideChar Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Insert the Null
    pStringW->pszVal[pStringW->cchVal] = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------

void CIntlGlobals::Init()
{

    mg_bInit = FALSE;
    InitializeCriticalSection(&mg_cs);
    mg_pDefBodyCset = NULL;
    mg_pDefHeadCset = NULL;
}

void CIntlGlobals::Term()
{

    DeleteCriticalSection(&mg_cs);
}

void CIntlGlobals::DoInit()
{

    if (!mg_bInit)
    {
        EnterCriticalSection(&mg_cs);
        if (!mg_bInit)
        {
            // Locals
            CODEPAGEID  cpiSystem;

            // Get the system codepage
            cpiSystem = GetACP();

            // Get the default body charset
            if (FAILED(g_pInternat->HrOpenCharset(cpiSystem, CHARSET_BODY, &mg_pDefBodyCset)))
                mg_pDefBodyCset = &mg_rDefaultCharset;

            // Get the Default Header Charset
            if (FAILED(g_pInternat->HrOpenCharset(cpiSystem, CHARSET_HEADER, &mg_pDefHeadCset)))
                mg_pDefHeadCset = mg_pDefBodyCset;

            mg_bInit = TRUE;
        }
        LeaveCriticalSection(&mg_cs);
    }
}

LPINETCSETINFO CIntlGlobals::GetDefBodyCset()
{

    DoInit();
    Assert(mg_pDefBodyCset);
    return (mg_pDefBodyCset);
}

LPINETCSETINFO CIntlGlobals::GetDefHeadCset()
{

    DoInit();
    Assert(mg_pDefHeadCset);
    return (mg_pDefHeadCset);
}

LPINETCSETINFO CIntlGlobals::GetDefaultCharset()
{

    DoInit();
    return (&mg_rDefaultCharset);
}

void CIntlGlobals::SetDefBodyCset(LPINETCSETINFO pCharset)
{

    DoInit();
    mg_pDefBodyCset = pCharset;
}

void CIntlGlobals::SetDefHeadCset(LPINETCSETINFO pCharset)
{

    DoInit();
    mg_pDefHeadCset = pCharset;
}

BOOL CIntlGlobals::mg_bInit = FALSE;
LPINETCSETINFO CIntlGlobals::mg_pDefBodyCset = NULL;
LPINETCSETINFO CIntlGlobals::mg_pDefHeadCset = NULL;
CRITICAL_SECTION CIntlGlobals::mg_cs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetprot.cpp ===
// --------------------------------------------------------------------------------
// Inetprot.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetprot.h"
#include "icdebug.h"

// --------------------------------------------------------------------------------
// HrPluggableProtocolRead
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolRead(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in,out */    LPVOID              pv,
            /* in */        ULONG               cb, 
            /* out */       ULONG              *pcbRead)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pv && cbRead > 0)
        return TrapError(E_INVALIDARG);

    // Init
    if (pcbRead)
        *pcbRead = 0;

    // No Stream Yet
    Assert(pSource);
    if (NULL == pSource->pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Read from the external offset
    CHECKHR(hr = pSource->pLockBytes->ReadAt(pSource->offExternal, pv, cb, &cbRead));

    // Tracking
#ifdef MAC
    DOUTL(APP_DOUTL, "HrPluggableProtocolRead - Offset = %d, cbWanted = %d, cbRead = %d, fDownloaded = %d", (DWORD)pSource->offExternal.LowPart, cb, cbRead, ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED));

    // Increment External Offset
    Assert(0 == pSource->offExternal.HighPart);
    Assert(INT_MAX - cbRead >= pSource->offExternal.LowPart);
    pSource->offExternal.LowPart += cbRead;
#else   // !MAC
    DOUTL(APP_DOUTL, "HrPluggableProtocolRead - Offset = %d, cbWanted = %d, cbRead = %d, fDownloaded = %d", (DWORD)pSource->offExternal.QuadPart, cb, cbRead, ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED));

    // Increment External Offset
    pSource->offExternal.QuadPart += cbRead;
#endif  // MAC

    // Return Read Count
    if (pcbRead)
        *pcbRead = cbRead;

    // No Data Read
    if (0 == cbRead)
    {
        // Finished
        if (ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED))
            hr = S_FALSE;

        // Not all data could be read
        else
            hr = E_PENDING;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrPluggableProtocolSeek
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolSeek(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in */        LARGE_INTEGER       dlibMove, 
            /* in */        DWORD               dwOrigin, 
            /* out */       ULARGE_INTEGER     *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliNew;

    // Invalid Arg
    Assert(pSource);

    // Tracking
    DOUTL(APP_DOUTL, "HrPluggableProtocolSeek");

    // No Stream Yet
    if (NULL == pSource->pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Seek pSource->offExternal
    switch (dwOrigin)
    {
   	case STREAM_SEEK_SET:
#ifdef MAC
        Assert(0 == dlibMove.HighPart);
        ULISet32(uliNew, dlibMove.LowPart);
#else   // !MAC
        uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
#endif  // MAC
        break;

    case STREAM_SEEK_CUR:
#ifdef MAC
        if (dlibMove.LowPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.LowPart) > pSource->offExternal.LowPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        Assert(0 == pSource->offExternal.HighPart);
        uliNew = pSource->offExternal;
        Assert(INT_MAX - uliNew.LowPart >= dlibMove.LowPart);
        uliNew.LowPart += dlibMove.LowPart;
#else   // !MAC
        if (dlibMove.QuadPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.QuadPart) > pSource->offExternal.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        uliNew.QuadPart = pSource->offExternal.QuadPart + dlibMove.QuadPart;
#endif  // MAC
        break;

    case STREAM_SEEK_END:
#ifdef MAC
        if (dlibMove.LowPart < 0 || dlibMove.LowPart > pSource->offInternal.LowPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        Assert(0 == pSource->cbSize.HighPart);
        uliNew = pSource->cbSize;
        Assert(INT_MAX - uliNew.LowPart >= dlibMove.LowPart);
        uliNew.LowPart -= dlibMove.LowPart;
#else   // !MAC
        if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > pSource->offInternal.QuadPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        uliNew.QuadPart = pSource->cbSize.QuadPart - dlibMove.QuadPart;
#endif  // MAC
        break;

    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // New offset greater than size...
#ifdef MAC
    Assert(0 == pSource->offInternal.HighPart);
    Assert(0 == uliNew.HighPart);
    ULISet32(pSource->offExternal, min(uliNew.LowPart, pSource->offInternal.LowPart));

    // Return Position
    if (plibNew)
    {
        Assert(0 == pSource->offExternal.HighPart);
        LISet32(*plibNew, pSource->offExternal.LowPart);
    }
#else   // !MAC
    pSource->offExternal.QuadPart = min(uliNew.QuadPart, pSource->offInternal.QuadPart);

    // Return Position
    if (plibNew)
        plibNew->QuadPart = (LONGLONG)pSource->offExternal.QuadPart;
#endif  // MAC

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\inetstm.h ===
// --------------------------------------------------------------------------------
// InetStm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETTEXT_H
#define __INETTEXT_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "variantx.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CStreamLockBytes;

// --------------------------------------------------------------------------------
// INETSTREAMBUFFER
// --------------------------------------------------------------------------------
typedef struct tagINETSTREAMBUFFER {
    ULARGE_INTEGER      uliOffset;              // Global offset of the start of this cache
    BYTE                rgb[4096];              // Cached portion of m_pStmLock
    ULONG               cb;                     // How many valid bytes in rgbCache
    ULONG               i;                      // Current Read Offset into rgb
    CHAR                chPrev;                 // Previous character, could be in previous buffer
} INETSTREAMBUFFER, *LPINETSTREAMBUFFER;

// --------------------------------------------------------------------------------
// INETSTREAMLINE
// --------------------------------------------------------------------------------
typedef struct tagINETSTREAMLINE {
    BOOL                fReset;                 // Reset to 0 on next call to ReadLine
    BYTE                rgbScratch[1024];       // Cached portion of m_pStmLock
    LPBYTE              pb;                     // Actual line (could be allocated != rgb)
    ULONG               cb;                     // How many valid bytes in rgbCache
    ULONG               cbAlloc;                // Size of buffer pointed to by pb
} INETSTREAMLINE, *LPINETSTREAMLINE;

// --------------------------------------------------------------------------------
// CInternetStream
// --------------------------------------------------------------------------------
class CInternetStream : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CInternetStream(void);
    ~CInternetStream(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IInternetStream Members
    // ----------------------------------------------------------------------------
    HRESULT HrInitNew(IStream *pStream);
    HRESULT HrReadToEnd(void);
    HRESULT HrReadLine(LPPROPSTRINGA pLine);
    HRESULT HrReadHeaderLine(LPPROPSTRINGA pHeader, LONG *piColonPos);
    HRESULT HrGetSize(DWORD *pcbSize);
#ifdef MAC
    DWORD   DwGetOffset(void) { return m_uliOffset.LowPart; }
#else   // !MAC
    DWORD   DwGetOffset(void) { return (DWORD)m_uliOffset.QuadPart; }
#endif  // MAC
    void    InitNew(DWORD dwOffset, CStreamLockBytes *pStmLock);
    void    GetLockBytes(CStreamLockBytes **ppStmLock);
    void    Seek(DWORD dwOffset);
    void    SetFullyAvailable(BYTE fFullyAvailable) { m_fFullyAvailable = fFullyAvailable; }

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGetNextBuffer(void);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG               m_cRef;         // Reference Count
    BYTE                m_fFullyAvailable; // Is all the data available
    CStreamLockBytes   *m_pStmLock;     // Thread Safe Data Source
    ULARGE_INTEGER      m_uliOffset;    // Last Read Postion of m_pStmLock
    INETSTREAMBUFFER    m_rBuffer;      // Current Buffer
    INETSTREAMLINE      m_rLine;        // Current Line
};

#endif // __INETTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\internat.h ===
// --------------------------------------------------------------------------------
// Internat.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INTERNAT_H
#define __INTERNAT_H
#include  "exrwlck.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERT *LPVARIANTCONVERT;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef struct tagPROPSTRINGA *LPPROPSTRINGA;
typedef struct tagPROPSTRINGW *LPPROPSTRINGW;
typedef const struct tagPROPSTRINGA *LPCPROPSTRINGA;
typedef const struct tagPROPSTRINGW *LPCPROPSTRINGW;
typedef struct tagMIMEVARIANT *LPMIMEVARIANT;

// --------------------------------------------------------------------------------
// Extern Global
// --------------------------------------------------------------------------------
class CIntlGlobals {
    public:
        static void Init();
        static void Term();
        static LPINETCSETINFO GetDefBodyCset();
        static LPINETCSETINFO GetDefHeadCset();
        static LPINETCSETINFO GetDefaultCharset();
        static void SetDefBodyCset(LPINETCSETINFO pCharset);
        static void SetDefHeadCset(LPINETCSETINFO pCharset);
    private:
        static void DoInit();
        static BOOL mg_bInit;
        static CRITICAL_SECTION mg_cs;
        static LPINETCSETINFO mg_pDefBodyCset;
        static LPINETCSETINFO mg_pDefHeadCset;
        static INETCSETINFO mg_rDefaultCharset;
};

// --------------------------------------------------------------------------------
// IsDBCSCodePage
// --------------------------------------------------------------------------------
#define IsDBCSCodePage(_cpi) \
    (932 == _cpi || 936 == _cpi || 950 == _cpi || 949 == _cpi || 874 == _cpi || 10001 == _cpi)

// --------------------------------------------------------------------------------
// HCSET Handle Macros
// --------------------------------------------------------------------------------
#define HCSET_SIGN                 (WORD)40
#define HCSETMAKE(_index)          (HCHARSET)MAKELPARAM(m_wTag + HCSET_SIGN, _index)
#define HCSETINDEX(_hcset)         (ULONG)HIWORD(_hcset)
#define HCSETTICK(_hcset)          (WORD)LOWORD(_hcset)
#define HCSETVALID(_hcset)         ((WORD)(HCSETTICK(_hcset) - HCSET_SIGN) == m_wTag && HCSETINDEX(_hcset) < m_cst.cCharsets)
#define PCsetFromHCset(_hcset)     m_cst.prgpCharset[HCSETINDEX(_hcset)]

// --------------------------------------------------------------------------------
// CSTABLE - Character Set Table
// --------------------------------------------------------------------------------
typedef struct tagCSTABLE {
    ULONG               cCharsets;          // Number of items in prgpCset
    ULONG               cAlloc;             // Number of items allocated in prgCset    
    LPINETCSETINFO     *prgpCharset;        // Array of INETCSETINFO structs
} CSTABLE, *LPCSTABLE;

// --------------------------------------------------------------------------------
// CPTABLE - Code Page Table
// --------------------------------------------------------------------------------
typedef struct tagCPTABLE {
    ULONG               cPages;             // Number of items in prgpCset
    ULONG               cAlloc;             // Number of items allocated in prgCset    
    LPCODEPAGEINFO     *prgpPage;           // Array of INETCSETINFO structs
} CPTABLE, *LPCPTABLE;

// --------------------------------------------------------------------------------
// CMimeInternational
// --------------------------------------------------------------------------------
class CMimeInternational : public IMimeInternational
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeInternational(void);
    ~CMimeInternational(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IMimeInternational Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP GetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset);
    STDMETHODIMP SetDefaultCharset(HCHARSET hCharset);
    STDMETHODIMP GetDefaultCharset(LPHCHARSET phCharset);
    STDMETHODIMP FindCharset(LPCSTR pszCharset, LPHCHARSET phCharset);
    STDMETHODIMP GetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo);
    STDMETHODIMP GetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePageInfo);
    STDMETHODIMP ConvertBuffer(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPBLOB pIn, LPBLOB pOut, ULONG *pcbRead);
    STDMETHODIMP ConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPPROPVARIANT pIn, LPPROPVARIANT pOut);
    STDMETHODIMP MLANG_ConvertInetReset(void);
    STDMETHODIMP MLANG_ConvertInetString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPCSTR pSourceStr,
        LPINT pnSizeOfSourceStr, LPSTR pDestinationStr, LPINT pnSizeOfDestBuffer);

    STDMETHODIMP DecodeHeader(HCHARSET hCharset, LPCSTR pszData, LPPROPVARIANT pDecoded, LPRFC1522INFO pRfc1522Info);
    STDMETHODIMP EncodeHeader(HCHARSET hCharset, LPPROPVARIANT pData, LPSTR *ppszEncoded, LPRFC1522INFO pRfc1522Info);
    STDMETHODIMP Rfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded);
    STDMETHODIMP Rfc1522Encode(LPCSTR pszValue, HCHARSET hCharset, LPSTR *ppszEncoded);
    STDMETHODIMP CanConvertCodePages(CODEPAGEID cpiSource, CODEPAGEID cpiDest);

    // -------------------------------------------------------------------------
    // LPINETCSETINFO Based Methods
    // -------------------------------------------------------------------------
    HRESULT HrOpenCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPINETCSETINFO *ppCharset);
    HRESULT HrOpenCharset(LPCSTR pszCharset, LPINETCSETINFO *ppCharset);
    HRESULT HrOpenCharset(HCHARSET hCharset, LPINETCSETINFO *ppCharset);
    HRESULT HrFindCodePage(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage);
    HRESULT HrConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrDecodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrEncodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);

    // -------------------------------------------------------------------------
    // Helpers to do Header Properties
    // -------------------------------------------------------------------------
    HRESULT HrEncodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrDecodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrWideCharToMultiByte(CODEPAGEID cpiCodePage, LPCPROPSTRINGW pStringW, LPPROPSTRINGA pStringA);
    HRESULT HrMultiByteToWideChar(CODEPAGEID cpiCodePage, LPCPROPSTRINGA pStringA, LPPROPSTRINGW pStringW);
    HRESULT HrValidateCodepages(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, LPBYTE *ppbSource, ULONG *pcbSource, CODEPAGEID *pcpiSource, CODEPAGEID *pcpiDest);

    // -------------------------------------------------------------------------
    // CMimeInternational Methods
    // -------------------------------------------------------------------------
    BOOL    FIsValidHandle(HCHARSET hCharset);
    HRESULT IsDBCSCharset(HCHARSET hCharset);

private:
    // ----------------------------------------------------------------------------
    // Private Utils
    // ----------------------------------------------------------------------------
    void    _FreeInetCsetTable(void);
    void    _FreeCodePageTable(void);
    void    _QuickSortPageInfo(long left, long right);
    void    _QuickSortCsetInfo(long left, long right);
    HRESULT _HrReadPageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppLangInfo);
    HRESULT _HrReadCsetInfo(LPCSTR pszCharset, LPINETCSETINFO *ppCsetInfo);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                           m_cRef;             // Reference Counting
    WORD                           m_wTag;             // Used to create and verify hCharsets
    CSTABLE                        m_cst;              // Character Sets
    CPTABLE                        m_cpt;              // CodePages
    CExShareLockWithNestAllowed    m_lock;             // Thread Safety
    DWORD                          m_dwConvState;      // Used to save convert state from MLANG
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void InitInternational(void);
HRESULT HrRegisterMlangDll(void);

#endif // __INTERNAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mhtmlurl.h ===
// --------------------------------------------------------------------------------
// MHTMLURL.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __MHTMLURL_H
#define __MHTMLURL_H

#ifndef MAC
// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "privunk.h"
#include "inetprot.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CMessageTree;
typedef CMessageTree *LPMESSAGETREE;
class CMimeActiveUrlCache;
typedef class CActiveUrlRequest *LPURLREQUEST;

// --------------------------------------------------------------------------------
// Global Active Url Cache Object
// --------------------------------------------------------------------------------
extern CMimeActiveUrlCache *g_pUrlCache;

// --------------------------------------------------------------------------------
// REQSTATE_xxxx States
// --------------------------------------------------------------------------------
#define REQSTATE_RESULTREPORTED      0x00000001      // I have called ReportResult, don't call again
#define REQSTATE_DOWNLOADED          0x00000002      // The data is all present in pLockBytes
#define REQSTATE_BINDF_NEEDFILE      0x00000004      // Need to use a file

// --------------------------------------------------------------------------------
// CActiveUrlRequest
// --------------------------------------------------------------------------------
class CActiveUrlRequest : public CPrivateUnknown, 
                          public IOInetProtocol,
                          public IOInetProtocolInfo,
                          public IServiceProvider
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CActiveUrlRequest(IUnknown *pUnkOuter=NULL);
    virtual ~CActiveUrlRequest(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // ----------------------------------------------------------------------------
    // IOInetProtocol methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, IOInetBindInfo *pBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved);
    STDMETHODIMP Terminate(DWORD dwOptions);
    STDMETHODIMP Read(LPVOID pv,ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP LockRequest(DWORD dwOptions) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRequest(void) { return E_NOTIMPL; }
    STDMETHODIMP Suspend(void) { return E_NOTIMPL; }
    STDMETHODIMP Resume(void) { return E_NOTIMPL; }
    STDMETHODIMP Abort(HRESULT hrReason, DWORD dwOptions) { return E_NOTIMPL; }
    STDMETHODIMP Continue(PROTOCOLDATA *pStateInfo) { return E_NOTIMPL; }

    // ----------------------------------------------------------------------------
    // IServiceProvider methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void **ppvObj); /* IServiceProvider */

    // ----------------------------------------------------------------------------
    // IOInetProtocolInfo methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP ParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwCompareFlags) { return E_NOTIMPL; }
    STDMETHODIMP QueryInfo(LPCWSTR pwzUrl, QUERYOPTION OueryOption, DWORD dwQueryFlags, LPVOID pBuffer,DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved);

    // ----------------------------------------------------------------------------
    // Called from CMimeMessageTree during Binding
    // ----------------------------------------------------------------------------
    void OnFullyAvailable(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pWebBook, HBODY hBody);

    // Async Binding Methods
    void OnStartBinding(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pWebBook, HBODY hBody);
    void OnBindingDataAvailable(void);
    void OnBindingComplete(HRESULT hrResult);

    // ----------------------------------------------------------------------------
    // CActiveUrlRequest Members
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    void    _ReportResult(HRESULT hrResult);
    HRESULT _FillReturnString(LPCWSTR pszUrl, DWORD cchUrl, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult);
    HRESULT _HrStreamToNeedFile(void);
    HRESULT _HrReportData(void);
    HRESULT _HrInitializeNeedFile(LPMESSAGETREE pTree, HBODY hBody);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    IOInetProtocolSink *m_pProtSink;        // Protocol Sink from IOInetProtocol::Start
    IOInetBindInfo     *m_pBindInfo;        // BindInfo from IOInetProtocol::Start
    IStream            *m_pStream;          // The data source
    LPSTR               m_pszRootUrl;       // Root document Url
    LPSTR               m_pszBodyUrl;       // Body Url
    IUnknown           *m_pUnkKeepAlive;    // This protocol may activate an object
    LPURLREQUEST        m_pNext;            // Next Request
    LPURLREQUEST        m_pPrev;            // Prev Request
    DWORD               m_dwState;          // Keep track of some state
    HANDLE              m_hNeedFile;        // Need File
    DWORD               m_dwBSCF;           // Bind Status Callback Flags That I've Reported
    CRITICAL_SECTION    m_cs;               // Thread Safety

    // ----------------------------------------------------------------------------
    // Friend 
    // ----------------------------------------------------------------------------
    friend CMessageTree;             // Accesses, m_pszRootUrl, m_pNext, m_pPrev
};

// --------------------------------------------------------------------------------
// ACTIVEURL_xxx
// --------------------------------------------------------------------------------
#define ACTIVEURL_ISFAKEURL   0x00000001    // Specifies that the activeurl is a mid

// --------------------------------------------------------------------------------
// CActiveUrl
// --------------------------------------------------------------------------------
class CActiveUrl : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CActiveUrl(void);
    ~CActiveUrl(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // CActiveUrl Members
    // ---------------------------------------------------------------------------
    HRESULT Init(BINDF bindf, LPMESSAGETREE pWebBook);
    HRESULT IsActive(void);
    HRESULT CompareRootUrl(LPCSTR pszUrl);
    HRESULT BindToObject(REFIID riid, LPVOID *ppv);
    HRESULT CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, DWORD dwReserved, IMoniker **ppMoniker);
    void RevokeWebBook(LPMESSAGETREE pWebBook);
    CActiveUrl *PGetNext(void) { return m_pNext; }
    CActiveUrl *PGetPrev(void) { return m_pPrev; }
    void SetNext(CActiveUrl *pNext) { m_pNext = pNext; }
    void SetPrev(CActiveUrl *pPrev) { m_pPrev = pPrev; }
    void DontKeepAlive(void);

    // ---------------------------------------------------------------------------
    // CActiveUrl Inline Members
    // ---------------------------------------------------------------------------
    void SetFlag(DWORD dwFlags) {
        EnterCriticalSection(&m_cs);
        FLAGSET(m_dwFlags, dwFlags);
        LeaveCriticalSection(&m_cs);
    }

    BOOL FIsFlagSet(DWORD dwFlags) {
        EnterCriticalSection(&m_cs);
        BOOL f = ISFLAGSET(m_dwFlags, dwFlags);
        LeaveCriticalSection(&m_cs);
        return f;
    }

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                 m_cRef;         // Reference Count
    IUnknown            *m_pUnkAlive;    // Keep it alive
    IUnknown            *m_pUnkInner;    // The ActiveUrl's Inner Unknown
    LPMESSAGETREE        m_pWebBook;     // Pointer to the active Url
    CActiveUrl          *m_pNext;        // Next Active Url
    CActiveUrl          *m_pPrev;        // Prev Active Url
    DWORD                m_dwFlags;      // Flags
    CRITICAL_SECTION     m_cs;           // Thread Safety    
};
typedef CActiveUrl *LPACTIVEURL;

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache
// --------------------------------------------------------------------------------
class CMimeActiveUrlCache : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeActiveUrlCache(void);
    ~CMimeActiveUrlCache(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ObjectFromMoniker - Called from Trident
    // ---------------------------------------------------------------------------
    HRESULT ActiveObjectFromMoniker(
            /* in */        BINDF               bindf,
            /* in */        IMoniker            *pmkOriginal,
            /* in */        IBindCtx            *pBindCtx,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IMoniker            **ppmkNew);

    // ---------------------------------------------------------------------------
    // ObjectFromUrl - Called from CActiveUrlRequest::Start
    // ---------------------------------------------------------------------------
    HRESULT ActiveObjectFromUrl(
            /* in */        LPCSTR              pszRootUrl,
            /* in */        BOOL                fCreate,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IUnknown            **ppUnkKeepAlive);

    // ---------------------------------------------------------------------------
    // RegisterActiveObject - Called from CMimeMessageTree::CreateRootMoniker
    // ---------------------------------------------------------------------------
    HRESULT RegisterActiveObject(
            /* in */        LPCSTR              pszRootUrl,
            /* in */        LPMESSAGETREE       pWebBook);

    HRESULT RemoveUrl(LPACTIVEURL pActiveUrl);

private:
    // ---------------------------------------------------------------------------
    // Memory
    // ---------------------------------------------------------------------------
    void    _FreeActiveUrlList(BOOL fAll);
    void    _HandlePragmaNoCache(BINDF bindf, LPCSTR pszUrl);
    HRESULT _RegisterUrl(LPMESSAGETREE pWebBook, BINDF bindf, LPACTIVEURL *ppActiveUrl);
    HRESULT _ResolveUrl(LPCSTR pszUrl, LPACTIVEURL *ppActiveUrl);
    HRESULT _RemoveUrl(LPACTIVEURL pActiveUrl);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    ULONG               m_cActive;      // Number of active items
    LPACTIVEURL         m_pHead;        // Head Active Url
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

#endif	// !MAC

#endif // __MHTMLURL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mhtmlurl.cpp ===
// --------------------------------------------------------------------------------
// Mhtmlurl.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "mhtmlurl.h"
#include "icoint.h"
#include "dllmain.h"
#include "booktree.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <demand.h>
#include "icdebug.h"
#include "stmlock.h"
#include "strconst.h"
#include "mimeapi.h"

// --------------------------------------------------------------------------------
// TraceProtocol
// --------------------------------------------------------------------------------
#define TraceProtocol(_pszFunction) \
    DOUTL(APP_DOUTL, "%08x > 0x%08X CActiveUrlRequest::%s (RootUrl = '%s', BodyUrl = '%s')", GetCurrentThreadId(), this, _pszFunction, m_pszRootUrl ? m_pszRootUrl : "", m_pszBodyUrl ? m_pszBodyUrl : "")

// --------------------------------------------------------------------------------
// AcitveUrlRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeHtmlProtocol_CreateInstance(IUnknown *pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Set the mimeole compat mode
    MimeOleSetCompatMode(MIMEOLE_COMPAT_OE5);

    // Create me
    CActiveUrlRequest *pNew = new CActiveUrlRequest(pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::CActiveUrlRequest
// --------------------------------------------------------------------------------
CActiveUrlRequest::CActiveUrlRequest(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_pProtSink = NULL;
    m_pBindInfo = NULL;
    m_pszRootUrl = NULL;
    m_pszBodyUrl = NULL;
    m_pUnkKeepAlive = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_dwState = 0;
    m_pStream = NULL;
    m_hNeedFile = INVALID_HANDLE_VALUE;
    m_dwBSCF = 0;
    InitializeCriticalSection(&m_cs);
    TraceProtocol("CActiveUrlRequest");
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::~CActiveUrlRequest
// --------------------------------------------------------------------------------
CActiveUrlRequest::~CActiveUrlRequest(void)
{
    // Tracing
    TraceProtocol("~CActiveUrlRequest");

    // These should have been release in IOInetProtocl::Terminate
    Assert(NULL == m_pProtSink && NULL == m_pBindInfo && NULL == m_pUnkKeepAlive);

    // Release the protcol object just in case
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);
    SafeMemFree(m_pszRootUrl);
    SafeMemFree(m_pszBodyUrl);
    SafeRelease(m_pUnkKeepAlive);
    SafeRelease(m_pStream);

    // Close file...
    if (INVALID_HANDLE_VALUE != m_hNeedFile)
        CloseHandle(m_hNeedFile);

    // Kill the CS
    DeleteCriticalSection(&m_cs);

    // Release the Dll
    DllRelease();
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IOInetProtocol == riid)
        *ppv = (IOInetProtocol *)this;
    else if (IID_IOInetProtocolInfo == riid)
        *ppv = (IOInetProtocolInfo *)this;
    else if (IID_IOInetProtocolRoot == riid)
        *ppv = (IOInetProtocolRoot *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrInitializeNeedFile
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrInitializeNeedFile(LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szFilePath[MAX_PATH + MAX_PATH];
    ULONG       cch;
    LPSTR       pszFilePath=NULL;
    LPWSTR      pwszFile=NULL;

    // Invalid Args
    Assert(INVALID_HANDLE_VALUE == m_hNeedFile);

    // Don't need a file ?
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
        goto exit;

    // Set sizeof szFilePath
    cch = ARRAYSIZE(szFilePath);

    // If cid:
    if (!m_pszBodyUrl || StrCmpNIA(m_pszBodyUrl, "cid:", 4) == 0 || FAILED(PathCreateFromUrlA(m_pszBodyUrl, szFilePath, &cch, 0)))
    {
        // Create temp file (m_pszFileName could be null)
        CHECKHR(hr = CreateTempFile(NULL, NULL, &pszFilePath, &m_hNeedFile));
    }
    else
    {
        // Create temp file
        CHECKHR(hr = CreateTempFile(szFilePath, NULL, &pszFilePath, &m_hNeedFile));
    }

    // Convert To Unicode
    CHECKALLOC(pwszFile = PszToUnicode(CP_ACP, pszFilePath));

    // Enter global Critical Section
    DeleteTempFileOnShutdownEx(pszFilePath, NULL);

    // Don't Free this
    pszFilePath = NULL;

    // Report the File...
    SideAssert(SUCCEEDED(m_pProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, pwszFile)));

exit:
    // Cleanup
    SafeMemFree(pwszFile);
    SafeMemFree(pszFilePath);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnFullyAvailable
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnFullyAvailable(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Invalid Arg
    Assert(pszCntType && pStream);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && pStream && NULL == m_pStream);

    // Tracing
    TraceProtocol("OnFullyAvailable");

    // Feed the content-type to trident
    m_pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pszCntType);

    // GetNeedFile
    CHECKHR(hr = _HrInitializeNeedFile(pTree, hBody));

    // Create Stream Lock wrapper
    m_pStream = pStream;
    m_pStream->AddRef();

    // Rewind that bad boy
    CHECKHR(hr = HrRewindStream(m_pStream));

    // Were complete
    FLAGSET(m_dwState, REQSTATE_DOWNLOADED);

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_DATAFULLYAVAILABLE | BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION;

    // Go into report data loop
    CHECKHR(hr = _HrReportData());

    // First Report Data
    if (m_pProtSink)
        m_pProtSink->ReportResult(S_OK, 0, NULL);

    // We have reported the result
    FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnStartBinding
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnStartBinding(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && pStream && NULL == m_pStream);

    // Tracing
    TraceProtocol("OnBinding(pszCntType, pStream)");

    // Feed the content-type to trident
    m_pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pszCntType ? pszCntType : L"application/octet-stream");

    // GetNeedFile
    CHECKHR(hr = _HrInitializeNeedFile(pTree, hBody));

    // Create Stream Lock wrapper
    m_pStream = pStream;
    m_pStream->AddRef();

    // Rewind that bad boy
    CHECKHR(hr = HrRewindStream(m_pStream));

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION;

    // Go into report data loop, if not writing to needfile (needfile is processed only when all the data is available)
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Report me some data
        CHECKHR(hr = _HrReportData());
    }

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnBindingDataAvailable
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnBindingDataAvailable(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && m_pStream);

    // Tracing
    TraceProtocol("OnBindingDataAvailable");

    // Initialize bind status callback falgs
    FLAGSET(m_dwBSCF, BSCF_INTERMEDIATEDATANOTIFICATION);

    // Go into report data loop, if not writing to needfile (needfile is processed only when all the data is available)
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Report some data
        CHECKHR(hr = _HrReportData());
    }

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnBindingComplete
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnBindingComplete(HRESULT hrResult)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Were complete
    FLAGSET(m_dwState, INETPROT_DOWNLOADED);

    // Tracing
    TraceProtocol("OnBindingComplete");

    // No Sink ?
    if (NULL == m_pProtSink)
        return;

    // Failure
    if (FAILED(hrResult))
    {
        _ReportResult(hrResult);
        goto exit;
    }

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_DATAFULLYAVAILABLE | BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION;

    // Report last amount of data
    CHECKHR(hr = _HrReportData());

    // Tell sink to use the default protocol
    m_pProtSink->ReportResult(S_OK, 0, NULL);

    // We have reported the result
    FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_ReportResult
// --------------------------------------------------------------------------------
void CActiveUrlRequest::_ReportResult(HRESULT hrResult)
{
    // Locals
    LPWSTR pwszRedirUrl=NULL;

    // We should have a sink
    Assert(m_pProtSink);

    // No Sink ?
    if (m_pProtSink && !ISFLAGSET(m_dwState, REQSTATE_RESULTREPORTED))
    {
        // If Failure
        if (FAILED(hrResult))
        {
            // If we have a body Url
            if (m_pszBodyUrl)
                pwszRedirUrl = PszToUnicode(CP_ACP, m_pszBodyUrl);

            // Report Result,
            if (pwszRedirUrl)
            {
                TraceProtocol("_ReportResult(BINDSTATUS_REDIRECTING)");
                m_pProtSink->ReportResult(INET_E_REDIRECTING, 0, pwszRedirUrl);
            }
            else
            {
                TraceProtocol("_ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER)");
                m_pProtSink->ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER, 0, NULL);
            }
        }

        // Otherwise, report the result
        else
        {
            TraceProtocol("_ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER)");
            m_pProtSink->ReportResult(S_OK, 0, NULL);
        }

        // Cleanup
        SafeMemFree(pwszRedirUrl);

        // We have reported the result
        FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);
    }
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrReportData
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrReportData(void)
{
    // Locals
    HRESULT hr=S_OK;

    // We better have a data source
    Assert(m_pStream);

    // Tracing
    TraceProtocol("_HrReportData");

    // BINDF_NEEDFILE
    if (ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Dump to File
        CHECKHR(hr = _HrStreamToNeedFile());
    }
    else
    {
        // Report Data
        SideAssert(SUCCEEDED(m_pProtSink->ReportData(m_dwBSCF, 0, 0)));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrStreamToNeedFile
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrStreamToNeedFile(void) 
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbTotal=0;

    // We better have a needfile
    Assert(INVALID_HANDLE_VALUE != m_hNeedFile && ISFLAGSET(m_dwState, REQSTATE_DOWNLOADED));

    // Write the stream to a file
    hr = WriteStreamToFileHandle(m_pStream, m_hNeedFile, &cbTotal);
    if (FAILED(hr) && E_PENDING != hr)
    {
        TrapError(hr);
        goto exit;
    }

    // Close the 77file
    CloseHandle(m_hNeedFile);
    m_hNeedFile = INVALID_HANDLE_VALUE;

    // Rewind the stream incase urlmon trys to read from me as well
    HrRewindStream(m_pStream);

    // All the data is there
    SideAssert(SUCCEEDED(m_pProtSink->ReportData(m_dwBSCF, 0, 0)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Start
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, 
    IOInetBindInfo *pBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved)
{
    // Locals
    HRESULT              hr=S_OK;
    LPSTR                pszUrl=NULL;
    LPMESSAGETREE        pTree=NULL;
    DWORD                dwBindF;
    BINDINFO 	         rBindInfo;

    // Invalid Args
    if (NULL == pwszUrl || NULL == pProtSink || NULL == pBindInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(g_pUrlCache && m_pProtSink == NULL && m_pBindInfo == NULL);

    // BINDF_NEEDFILE
    ZeroMemory(&rBindInfo, sizeof(BINDINFO));
    rBindInfo.cbSize = sizeof(BINDINFO);
	if (SUCCEEDED(pBindInfo->GetBindInfo(&dwBindF, &rBindInfo)) && ISFLAGSET(dwBindF, BINDF_NEEDFILE))
    {
        // Set Flag
        FLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE);
    }

    // Assume the Sink
    m_pProtSink = pProtSink;
    m_pProtSink->AddRef();

    // Assume the BindInfo
    m_pBindInfo = pBindInfo;
    m_pBindInfo->AddRef();

    // Dup the Url
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Split the Url
    CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &m_pszRootUrl, &m_pszBodyUrl));

    // for security purposes, disallow navigate using the mhtml protocl in IE except with correct ext
    // wait to do this check until after we have a protocol sink to report the error and we've parsed
    // out the root url
    if (StrCmpNI(m_pszRootUrl, TEXT("mid:"), 4) && GetModuleHandle(TEXT("IEXPLORE.EXE")))
    {
        LPTSTR pszExt = PathFindExtension(m_pszRootUrl);
        if (!pszExt || (StrCmpI(pszExt, TEXT(".mht")) && StrCmpI(pszExt, TEXT(".mhtml"))))
        {
            hr = INET_E_SECURITY_PROBLEM;
            goto exit;
        }
    }

    // Tracing
    TraceProtocol("Start");

    // Try to resolve the root url
    CHECKHR(hr = g_pUrlCache->ActiveObjectFromUrl(m_pszRootUrl, TRUE, IID_CMessageTree, (LPVOID *)&pTree, &m_pUnkKeepAlive));

    // Ask the BindTree to Resolve this Url
    CHECKHR(hr = pTree->HrActiveUrlRequest(this));

exit:
    // Cleanup
    SafeMemFree(pszUrl);
    SafeRelease(pTree);

    // Failure
    //if (FAILED(hr))
    //    _ReportResult(E_FAIL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Terminate
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Terminate(DWORD dwOptions)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("Terminate");

    // Release Objects
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);
    SafeRelease(m_pUnkKeepAlive);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Read (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Read(LPVOID pv,ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Init
    if (pcbRead)
        *pcbRead = 0;

    // No Stream Yet
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Read from the external offset
    CHECKHR(hr = m_pStream->Read(pv, cb, &cbRead));

    // Done
    if (0 == cbRead)
    {
        // S_FALSE = Were Done, E_PENDING = more data is coming
        hr = (ISFLAGSET(m_dwState, INETPROT_DOWNLOADED)) ? S_FALSE : E_PENDING;
    }

    // Otherwise, set to ok
    else
        hr = S_OK;

    // Return pcbRead
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Seek (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("Seek");

    // No Stream Yet
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Call Utility Function
    CHECKHR(hr = m_pStream->Seek(dlibMove, dwOrigin, plibNew));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::QueryService
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::QueryService(REFGUID rsid, REFIID riid, void **ppvObject) /* IServiceProvider */
{
    // Locals
    HRESULT             hr=S_OK;
    IServiceProvider   *pSP=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("QueryService");

    // No Protocol Sink Yet ?
    if (NULL == m_pProtSink)
    {
        hr = TrapError(E_UNEXPECTED);
        goto exit;
    }

    // QI the Sink for the IServiceProvider
    CHECKHR(hr = m_pProtSink->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP));

    // Query Service the Service Provider
    CHECKHR(hr = pSP->QueryService(rsid, riid, ppvObject));

exit:
    // Cleanup
    SafeRelease(pSP);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_FillReturnString
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_FillReturnString(LPCWSTR pszUrl, DWORD cchUrl, LPWSTR pszResult, 
    DWORD cchResult, DWORD *pcchResult)
{
    // Locals
    HRESULT     hr=S_OK;

    // Want the Size
    if (pcchResult)
        *pcchResult = cchUrl;

    // No return value
    if (NULL == pszResult)
        goto exit;

    // Dest is big enought
    if (cchResult < cchUrl+1)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Copy to dest buffer
    CopyMemory((LPBYTE)pszResult, (LPBYTE)pszUrl, ((cchUrl + 1) * sizeof(WCHAR)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::ParseUrl
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::ParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, 
    DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchUrl;
    LPSTR       pszUrl=NULL;
    LPSTR       pszRootUrl=NULL;
    LPSTR       pszBodyUrl=NULL;
    LPWSTR      pwszBodyUrl=NULL;
    LPWSTR      pszRootUrlW=NULL;
    LPWSTR      pszSecurityUrlW=NULL;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pwzUrl)
        return TrapError(E_INVALIDARG);
   
    // Tracing
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::ParseUrl (pwzUrl = %ls)", GetCurrentThreadId(), this, pwzUrl);

    // Setup Variant
    ZeroMemory(&rVariant, sizeof(PROPVARIANT));

    // Only handle PARSE_CANONICALIZE
    if (PARSE_CANONICALIZE == ParseAction)
    {
        // Fill return value
        CHECKHR(hr = _FillReturnString(pwzUrl, lstrlenW(pwzUrl), pwzResult, cchResult, pcchResult));
    }

    // Strip MHTML: and return
#ifndef WIN16
    else if (StrCmpNIW(pwzUrl, L"mhtml:", 6) == 0)
#else
    else if (StrCmpNIW(pwzUrl, "mhtml:", 6) == 0)
#endif // !WIN16
    {
        // If Getting Friendly
        if (PARSE_FRIENDLY == ParseAction)
        {
            // To ANSI
            CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwzUrl));

            // Split It
            CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, &pszBodyUrl));

            // Convert To Unicode
            CHECKALLOC(pwszBodyUrl = PszToUnicode(CP_ACP, pszBodyUrl));

            // Fill return value
            CHECKHR(hr = _FillReturnString(pwszBodyUrl, lstrlenW(pwszBodyUrl), pwzResult, cchResult, pcchResult));
        }

        // If the content-location is available, use it as the security URL
        else if (PARSE_SECURITY_URL == ParseAction)
        {
            BOOL            fGotSecURL = FALSE;
            LPMESSAGETREE   pTree=NULL;
            HBODY           hBody;
            IInternetSecurityManager *pISM;
            DWORD           dwZone=URLZONE_UNTRUSTED;
    
            // Base to ANSI
            CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwzUrl));

            // UnEscape the Url
            CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

            // Split It
            CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, &pszBodyUrl));

            // RootUrl to UNICODE
            CHECKALLOC(pszRootUrlW = PszToUnicode(CP_ACP, pszRootUrl));

            // Check and see what ZONE the root url is running in
            if (CoInternetCreateSecurityManager(NULL, &pISM, 0)==S_OK)
            {
                pISM->MapUrlToZone(pszRootUrlW, &dwZone, 0);
                pISM->Release();
            }

            // default to the root-body part 
            pszSecurityUrlW = pszRootUrlW;

            // if the root url is in the local-machine, then respect the Content-Location header
            // as the source of the url, otherwise defer to the root url
            if ((dwZone == URLZONE_LOCAL_MACHINE) && 
                SUCCEEDED(g_pUrlCache->ActiveObjectFromUrl(pszRootUrl, FALSE, IID_CMessageTree, (LPVOID *)&pTree, NULL)))
            {
                if ( (pszBodyUrl != NULL && SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszBodyUrl, 0, &hBody))) ||
                      SUCCEEDED(pTree->GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBody)))
                {
                    // Locals
                    LPWSTR      pwszSecURL = NULL;
                    PSUACTION   psua = (dwParseFlags == PSU_SECURITY_URL_ONLY)? PSU_SECURITY_URL_ONLY: PSU_DEFAULT;

                    rVariant.vt = VT_LPWSTR; 

                    if (SUCCEEDED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)) && rVariant.pwszVal && *rVariant.pwszVal)
                    {
                        pszSecurityUrlW  = rVariant.pwszVal;
                    }
                    SafeMemFree(pwszSecURL);
                }
            }

            // Fill return value
            CHECKHR(hr = _FillReturnString(pszSecurityUrlW, lstrlenW(pszSecurityUrlW), pwzResult, cchResult, pcchResult));

            SafeRelease(pTree);
        }

        else if (PARSE_ENCODE == ParseAction)
        {
            hr = INET_E_DEFAULT_ACTION;
        }

        // Simply remove mhtml:
        else
        {
            // Fill return value
            CHECKHR(hr = _FillReturnString(pwzUrl + 6, lstrlenW(pwzUrl) - 6, pwzResult, cchResult, pcchResult));
        }
    }

    // INET_E_DEFAULT_ACTION
    else
    {
        hr = INET_E_DEFAULT_ACTION;
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszUrl);
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszRootUrlW);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pwszBodyUrl);
    SafeMemFree(rVariant.pwszVal);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::QueryInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::QueryInfo(LPCWSTR pwzUrl, QUERYOPTION OueryOption, 
    DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved)
{
    // QUERY_RECOMBINE
    if (QUERY_RECOMBINE == OueryOption)
    {
        // Sure
        if (cbBuffer < sizeof(DWORD))
            return S_FALSE;

        // True
        DWORD dw=TRUE;
        CopyMemory(pBuffer, &dw, sizeof(dw));
        *pcbBuf = sizeof(dw);

        // Done
        return S_OK;
    }

    // Failure
    return INET_E_QUERYOPTION_UNKNOWN;
}   

// --------------------------------------------------------------------------------
// CActiveUrlRequest::CombineUrl
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, 
    LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszBaseUrl=NULL;
    LPSTR           pszRootUrl=NULL;
    LPSTR           pszBodyUrl=NULL;
    LPSTR           pszRelativeUrl=NULL;
    LPSTR           pszNewUrl=NULL;
    LPSTR           pszDocUrl=NULL;
    LPSTR           pszPageUrl=NULL;
    LPWSTR          pwszBodyUrl=NULL;
    LPWSTR          pwszNewUrl=NULL;
    LPWSTR          pwszSource=NULL;
    BOOL            fCombine=FALSE;
    LPMESSAGETREE   pTree=NULL;
    ULONG           cchSource;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);
    HBODY           hBody;

    // Invalid Arg
    if (NULL == pwzRelativeUrl)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // DebugTraceing
#ifndef WIN16
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::CombineUrl - Base = %ls, Relative = %ls", GetCurrentThreadId(), this, pwzBaseUrl ? pwzBaseUrl : L"" , pwzRelativeUrl ? pwzRelativeUrl : L"");
#else
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::CombineUrl - Base = %ls, Relative = %ls", GetCurrentThreadId(), this, pwzBaseUrl ? pwzBaseUrl : "" , pwzRelativeUrl ? pwzRelativeUrl : "");
#endif // !WIN16

    // Raid-42722: MHTML: Bookmarks don't work
    if (L'#' == pwzRelativeUrl[0])
    {
        hr = E_FAIL;
        goto exit;
    }

    // Convert relative to ANSI
    CHECKALLOC(pszRelativeUrl = PszToANSI(CP_ACP, pwzRelativeUrl));

    // We should UnEscape only Url, but doesn't touch a query
    CHECKHR(hr = UrlUnescapeA(pszRelativeUrl, NULL, NULL, URL_UNESCAPE_INPLACE | URL_DONT_ESCAPE_EXTRA_INFO));

    // If the relative is already mhtml:, then retur that...
    if (StrCmpNI(pszRelativeUrl, c_szMHTMLColon, cchPrefix) == 0)
    {
        // Split It
        CHECKHR(hr = MimeOleParseMhtmlUrl(pszRelativeUrl, &pszRootUrl, &pszBodyUrl));

        // If no body url, then just return pszRelativeUrl
        if (NULL == pszBodyUrl)
        {
            // Set pwszSource
            pwszSource = (LPWSTR)(pwzRelativeUrl + cchPrefix);

            // Get Length
            cchSource = lstrlenW(pwzRelativeUrl) - cchPrefix;

            // Done
            goto set_return;
        }
    }

    // Otherwise, build a new url
    else
    {
        // Base to ANSI
        CHECKALLOC(pszBaseUrl = PszToANSI(CP_ACP, pwzBaseUrl));

        // UnEscape the Url
        CHECKHR(hr = UrlUnescapeA(pszBaseUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Split It
        CHECKHR(hr = MimeOleParseMhtmlUrl(pszBaseUrl, &pszRootUrl, &pszPageUrl));

        // Set pszBodyUrl
        pszBodyUrl = pszRelativeUrl;

        // Don't need pszRelativeUrl anymore
        pszRelativeUrl = NULL;
    }

    // Better have a root and a body url
    Assert(pszRootUrl && pszBodyUrl);

    // Try to resolve the root url
    if (SUCCEEDED(g_pUrlCache->ActiveObjectFromUrl(pszRootUrl, FALSE, IID_CMessageTree, (LPVOID *)&pTree, NULL)))
    {
        // If pszBodyUrl is in the WebBook or the bind is not finished...then do the url combine
        if (SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszBodyUrl, 0, NULL)) || pTree->IsState(TREESTATE_BINDDONE) == S_FALSE)
        {
            // Combine the Urls
            fCombine = TRUE;
        }
        // fCombine = TRUE;
    }

    // Should we combine
    if (fCombine)
    {
        // Allocate Some Memory
        DWORD cchSize = (cchPrefix + lstrlen(pszRootUrl) + lstrlen(pszBodyUrl) + 2);
        CHECKALLOC(pszNewUrl = PszAllocA(cchSize));

        // Format the string
        wnsprintfA(pszNewUrl, cchSize, "%s%s!%s", c_szMHTMLColon, pszRootUrl, pszBodyUrl);

        // Convert to unicode
        CHECKALLOC(pwszNewUrl = PszToUnicode(CP_ACP, pszNewUrl));

        // Get length
        cchSource = lstrlenW(pwszNewUrl);

        // Set Source
        pwszSource = pwszNewUrl;
    }

    // No Combine
    else
    {
        // If we have a WebBook
        if (pTree)
        {
            // If we don't have a page Url, then just call GetTextBody(html)
            if (NULL == pszPageUrl)
                MimeOleComputeContentBase(pTree, NULL, &pszDocUrl, NULL);

            // Otherwise, try to resolve the page url
            else if (SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszPageUrl, 0, &hBody)))
                pszDocUrl = MimeOleContentBaseFromBody(pTree, hBody);

            // If we have Url
            if (pszDocUrl)
            {
                // Unescape It
                CHECKHR(hr = UrlUnescapeA(pszDocUrl, NULL, NULL, URL_UNESCAPE_INPLACE));
            }

            // Otheriwse, if the WebBook was loaded by a moniker, then use pszRootUrl
            else if (pTree->IsState(TREESTATE_LOADEDBYMONIKER) == S_OK)
            {
                // pszRootUrl is the pszDocUrl
                CHECKALLOC(pszDocUrl = PszDupA(pszRootUrl));
            }
        }

        // If there is a pszDocUrl
        if (pszDocUrl)
        {
            // Lets Combine with this url
            CHECKHR(hr = MimeOleCombineURL(pszDocUrl, lstrlen(pszDocUrl), pszBodyUrl, lstrlen(pszBodyUrl), FALSE, &pszNewUrl));

            // Convert to unicode
            CHECKALLOC(pwszNewUrl = PszToUnicode(CP_ACP, pszNewUrl));

            // Get length
            cchSource = lstrlenW(pwszNewUrl);

            // Set Source
            pwszSource = pwszNewUrl;
        }
        else
        {
            // Need a wide body Url
            CHECKALLOC(pwszBodyUrl = PszToUnicode(CP_ACP, pszBodyUrl));

            // Get length
            cchSource = lstrlenW(pwszBodyUrl);

            // Set Source
            pwszSource = pwszBodyUrl;
        }
    }

set_return:
    // Set Dest Size
    if (pcchResult)
        *pcchResult = cchSource;

    // No return value
    if (NULL == pwzResult)
        goto exit;

    // Dest is big enought
    if (cchResult <= cchSource)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Copy to dest buffer
    CopyMemory((LPBYTE)pwzResult, (LPBYTE)pwszSource, ((cchSource + 1) * sizeof(WCHAR)));

exit:
    // Cleanup
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszRelativeUrl);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pszNewUrl);
    SafeMemFree(pwszNewUrl);
    SafeMemFree(pszBaseUrl);
    SafeMemFree(pszDocUrl);
    SafeMemFree(pwszBodyUrl);
    SafeMemFree(pszPageUrl);
    SafeRelease(pTree);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::CActiveUrl
// --------------------------------------------------------------------------------
CActiveUrl::CActiveUrl(void)
{
    m_cRef = 1;
    m_pUnkAlive = NULL;
    m_pUnkInner = NULL;
    m_pWebBook = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_dwFlags = 0;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::~CActiveUrl
// --------------------------------------------------------------------------------
CActiveUrl::~CActiveUrl(void)
{
    SafeRelease(m_pUnkAlive);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrl::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CActiveUrl::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CActiveUrl::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CActiveUrl::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CActiveUrl::Init
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::Init(BINDF bindf, LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better not have data
    Assert(NULL == m_pWebBook && NULL == m_pUnkInner);

    // No Message Object Passed in ?
    if (NULL == pTree)
    {
        // Allocate the Message Object
        CHECKALLOC(pTree = new CMessageTree);

        // Set pMessage
        m_pUnkAlive = pTree->GetInner();

        // Init
        CHECKHR(hr = pTree->InitNew());
    }

    // Set BINDF_PRAGMA_NO_CACHE
    if (ISFLAGSET(bindf, BINDF_RESYNCHRONIZE))
    {
        // Set State
        pTree->SetState(TREESTATE_RESYNCHRONIZE);
    }

    // Set pMessage
    m_pWebBook = pTree;

    // Get the Message Object's Inner Unknown
    m_pUnkInner = pTree->GetInner();

    // Register pActiveUrl as a handle in the message object
    m_pWebBook->SetActiveUrl(this);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::DontKeepAlive
// --------------------------------------------------------------------------------
void CActiveUrl::DontKeepAlive(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set pMessage
    if (m_pUnkAlive)
    {
        // Somebody should still have a refcount on this dude
        SideAssert(m_pUnkAlive->Release() > 0);

        // Null It
        m_pUnkAlive = NULL;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::IsActive
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::IsActive(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pWebBook ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::RevokeWebBook
// --------------------------------------------------------------------------------
void CActiveUrl::RevokeWebBook(LPMESSAGETREE pTree)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Arg
    Assert(NULL == pTree || m_pWebBook == pTree);

    // Revoke This from the message
    if (m_pWebBook)
        m_pWebBook->SetActiveUrl(NULL);

    // Null m_pWebBook
    m_pWebBook = NULL;
    m_pUnkInner = NULL;

    // Check Ref Count
    Assert(1 == m_cRef);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::CompareRootUrl
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::CompareRootUrl(LPCSTR pszUrl)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Compare Root Url
    HRESULT hr = m_pWebBook ? m_pWebBook->CompareRootUrl(pszUrl) : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::BindToObject
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::BindToObject(REFIID riid, LPVOID *ppv)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Compare Root Url
    HRESULT hr = m_pUnkInner ? m_pUnkInner->QueryInterface(riid, ppv) : TrapError(E_FAIL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::CreateWebPage
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, 
    DWORD dwReserved, IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Message
    if (NULL == m_pWebBook)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // CreateWebPage
    CHECKHR(hr = m_pWebBook->CreateWebPage(pStmRoot, pOptions, NULL, ppMoniker));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::CMimeActiveUrlCache
// --------------------------------------------------------------------------------
CMimeActiveUrlCache::CMimeActiveUrlCache(void)
{
    m_cRef = 1;
    m_cActive = 0;
    m_pHead = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::~CMimeActiveUrlCache
// --------------------------------------------------------------------------------
CMimeActiveUrlCache::~CMimeActiveUrlCache(void)
{
    _FreeActiveUrlList(TRUE);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_FreeActiveUrlList
// --------------------------------------------------------------------------------
void CMimeActiveUrlCache::_FreeActiveUrlList(BOOL fAll)
{
    // Locals
    LPACTIVEURL     pCurr;
    LPACTIVEURL     pNext;

    // Init
    pCurr = m_pHead;

    // All
    if (fAll)
    {
        // Loop and Free
        while(pCurr)
        {
            // Set Next
            pNext = pCurr->PGetNext();

            // Revoke the handle
            pCurr->RevokeWebBook(NULL);

            // Free the Active Url
            pCurr->Release();

            // Goto Next
            pCurr = pNext;
        }

        // No Active
        m_cActive = 0;
        m_pHead = NULL;
    }

    else
    {
        // Loop and Free
        while(pCurr)
        {
            // Set Next
            pNext = pCurr->PGetNext();

            // Revoke the handle
            if (pCurr->IsActive() == S_FALSE)
                _RemoveUrl(pCurr);

            // Goto Next
            pCurr = pNext;
        }
    }
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeActiveUrlCache::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeActiveUrlCache::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeActiveUrlCache::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_RegisterUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_RegisterUrl(LPMESSAGETREE pTree, BINDF bindf,
    LPACTIVEURL *ppActiveUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    LPACTIVEURL     pActiveUrl=NULL;

    // Invalid Arg
    Assert(ppActiveUrl);

    // Init
    *ppActiveUrl = NULL;

    // Allocate an ActiveUrl
    CHECKALLOC(pActiveUrl = new CActiveUrl);

    // Init the Active Url
    CHECKHR(hr = pActiveUrl->Init(bindf, pTree));

    // Link Into Chain
    if (NULL == m_pHead)
        m_pHead = pActiveUrl;
    else
    {
        pActiveUrl->SetNext(m_pHead);
        m_pHead->SetPrev(pActiveUrl);
        m_pHead = pActiveUrl;
    }

    // Increment Count
    m_cActive++;

    // Return It
    *ppActiveUrl = pActiveUrl;
    pActiveUrl = NULL;

exit:
    // Release the Active Url
    SafeRelease(pActiveUrl);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_ResolveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_ResolveUrl(LPCSTR pszUrl, LPACTIVEURL *ppActiveUrl)
{
    // Locals
    HRESULT     hr=S_OK;
    LPACTIVEURL pActiveUrl;

    // Invalid Arg
    Assert(pszUrl && ppActiveUrl);

    // Init
    *ppActiveUrl = NULL;

    // Should not have mhtml:
    Assert(StrCmpNI(pszUrl, "mhtml:", 6) != 0);

    // Walk the Table
    for (pActiveUrl=m_pHead; pActiveUrl!=NULL; pActiveUrl=pActiveUrl->PGetNext())
    {
        // Is this the Url
        if (pActiveUrl->CompareRootUrl(pszUrl) == S_OK)
        {
            // Return the Active Url
            *ppActiveUrl = pActiveUrl;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_RemoveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_RemoveUrl(LPACTIVEURL pActiveUrl)
{
    EnterCriticalSection(&m_cs);

    // Fixup Linked List
    LPACTIVEURL pNext = pActiveUrl->PGetNext();
    LPACTIVEURL pPrev = pActiveUrl->PGetPrev();

    // Fixup
    if (pPrev)
        pPrev->SetNext(pNext);
    if (pNext)
        pNext->SetPrev(pPrev);

    // Fixup m_pHead
    if (m_pHead == pActiveUrl)
        m_pHead = pNext;

    // Revoke the handle
    pActiveUrl->RevokeWebBook(NULL);

    // Release the ActiveUrl
    SideAssert(0 == pActiveUrl->Release());

    // One less active 
    m_cActive--;

    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::RemoveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::RemoveUrl(LPACTIVEURL pActiveUrl)
{
    return _RemoveUrl(pActiveUrl);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_HandlePragmaNoCache
// --------------------------------------------------------------------------------
void CMimeActiveUrlCache::_HandlePragmaNoCache(BINDF bindf, LPCSTR pszUrl)
{
    // Locals
    CActiveUrl *pActiveUrl;

    // Invalid Arg
    Assert(pszUrl);

    // BINDF_PRAGMA_NO_CACHE - Reload the WebBook from original source (can't do if activeurl has a fake url)
    if (ISFLAGSET((DWORD)bindf, BINDF_PRAGMA_NO_CACHE))
    {
        // Try to find the ActiveUrl associated with pszUrl
        if (SUCCEEDED(_ResolveUrl(pszUrl, &pActiveUrl)))
        {
            // If it is a fakeurl, then lets not unload it
            if (FALSE == pActiveUrl->FIsFlagSet(ACTIVEURL_ISFAKEURL))
            {
                // Kill it from the cache so that its not found and reloaded
                _RemoveUrl(pActiveUrl);
            }
        }
    }
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::ActiveObjectFromMoniker - Called from Trident
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::ActiveObjectFromMoniker(
        /* in */        BINDF               bindf,
        /* in */        IMoniker            *pmkOriginal,
        /* in */        IBindCtx            *pBindCtx,
        /* in */        REFIID              riid, 
        /* out */       LPVOID              *ppvObject,
        /* out */       IMoniker            **ppmkNew)
{
    // Locals
    HRESULT             hr=S_OK;
    LPWSTR              pwszUrl=NULL;
    LPSTR               pszUrl=NULL;
    LPSTR               pszRootUrl=NULL;
    IMoniker           *pMoniker=NULL;
    IPersistMoniker    *pPersist=NULL;
    LPACTIVEURL         pActiveUrl=NULL;
    BOOL                fAsync=FALSE;
    WEBPAGEOPTIONS      Options={0};

    // Invalid Arg
    if (NULL == pmkOriginal || NULL == ppvObject || NULL == ppmkNew)
        return TrapError(E_INVALIDARG);

    // Init
    *ppmkNew = NULL;
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the Url from the Moniker
    CHECKHR(hr = pmkOriginal->GetDisplayName(NULL, NULL, &pwszUrl));

    // Convert to ANSI
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Raid-2508: Comment tag ( <! comment> ) doesn't work in mhtml
    if (StrCmpNI(pszUrl, c_szMHTMLColon, lstrlen(c_szMHTMLColon)) != 0)
    {
        // Fixup
        ReplaceChars(pszUrl, '!', '_');
    }

    // Free pwszUrl
    SafeMemFree(pwszUrl);

    // This will fail if pszUrl is not an mhtml: url, if it succeeds it gives me the part Url
    if (SUCCEEDED(MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, NULL)))
    {
        // _HandlePragmaNoCache
        _HandlePragmaNoCache(bindf, pszRootUrl);

        // See if pszUrl - mhtml: is an active Url
        if (FAILED(_ResolveUrl(pszRootUrl, &pActiveUrl)))
        {
            // Register an ActiveUrl
            CHECKHR(hr = _RegisterUrl(NULL, bindf, &pActiveUrl));

            // Convert pszRootUrl to a wide
            CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszRootUrl));

            // Create an Actual Url Moniker
            CHECKHR(hr = CreateURLMoniker(NULL, pwszUrl, &pMoniker));

            // Get an IPersistMoniker
            CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

            // Load the message with pmkOriginal
            hr = pPersist->Load(FALSE, pMoniker, NULL, 0);
            if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
            {
                hr = TrapError(hr);
                goto exit;
            }

            // Otheriwse, good
            hr = S_OK;
        }

        // Return pmkOriginal
        (*ppmkNew) = pmkOriginal;
        (*ppmkNew)->AddRef();

        // QI for the requested object iid
        CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));
    }

    // Otherwise Simply see if this Url is Active
    else 
    {
        // _HandlePragmaNoCache
        _HandlePragmaNoCache(bindf, pszUrl);

        // Try to resolve this url
        if (FAILED(_ResolveUrl(pszUrl, &pActiveUrl)))
        {
            // Register an ActiveUrl
            CHECKHR(hr = _RegisterUrl(NULL, bindf, &pActiveUrl));

            // Get an IPersistMoniker
            CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

            // Load the message with pmkOriginal
            hr = pPersist->Load(FALSE, pmkOriginal, pBindCtx, 0);
            if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
            {
                hr = TrapError(hr);
                goto exit;
            }

            // Otheriwse, good
            hr = S_OK;
        }

        // Setup WebPage Options
        Options.cbSize = sizeof(WEBPAGEOPTIONS);
        Options.dwFlags = WPF_NOMETACHARSET | WPF_HTML | WPF_AUTOINLINE;
        
        // Create the root moniker
        CHECKHR(hr = pActiveUrl->CreateWebPage(NULL, &Options, 0, ppmkNew));

        // QI for the requested object iid
        CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));

        // Don't Keep Alive, assume ppvObject controls the lifetime, not pActiveUrl
        pActiveUrl->DontKeepAlive();
    }

exit:
    // Cleanup
    SafeRelease(pPersist);
    SafeRelease(pMoniker);
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszUrl);
    SafeMemFree(pwszUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Failed, return hr, otherwise, return MK_S_ASYNCHRONOUS if going async
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::ActiveObjectFromUrl - Called from CActiveUrlRequest::Start
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::ActiveObjectFromUrl(
        /* in */        LPCSTR              pszRootUrl,
        /* in */        BOOL                fCreate,
        /* in */        REFIID              riid, 
        /* out */       LPVOID              *ppvObject,
        /* out */       IUnknown            **ppUnkKeepAlive)
{
    // Locals
    HRESULT          hr=S_OK;
    LPWSTR           pwszUrl=NULL;
    LPACTIVEURL      pActiveUrl;
    IMoniker        *pMoniker=NULL;
    IPersistMoniker *pPersist=NULL;

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == ppvObject || (TRUE == fCreate && NULL == ppUnkKeepAlive))
        return TrapError(E_INVALIDARG);

    // Better not start with mhtml:
    Assert(StrCmpNI(pszRootUrl, "mhtml:", 6) != 0);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Try to resolve this url
    if (FAILED(_ResolveUrl(pszRootUrl, &pActiveUrl)))
    {
        // NoCreate ?
        if (FALSE == fCreate)
        {
            hr = TrapError(MIME_E_NOT_FOUND);
            goto exit;
        }

        // Register an ActiveUrl
        CHECKHR(hr = _RegisterUrl(NULL, (BINDF)0, &pActiveUrl));

        // Convert pszRootUrl to a wide
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszRootUrl));

        // Create an Actual Url Moniker
        CHECKHR(hr = CreateURLMoniker(NULL, pwszUrl, &pMoniker));

        // Get an IPersistMoniker
        CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

        // Load the message with pmkOriginal
        hr = pPersist->Load(FALSE, pMoniker, NULL, 0);
        if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
        {
            hr = TrapError(hr);
            goto exit;
        }

        // Return the IUnknown Keep Alive Object
        CHECKHR(hr = pActiveUrl->BindToObject(IID_IUnknown, (LPVOID *)ppUnkKeepAlive));

        // Don't Keep Alive, assume ppvObject controls the lifetime, not pActiveUrl
        pActiveUrl->DontKeepAlive();
    }

    // Return an Interface
    CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));

exit:
    // Cleanup
    SafeMemFree(pwszUrl);
    SafeRelease(pMoniker);
    SafeRelease(pPersist);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::RegisterActiveObject
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::RegisterActiveObject(
        /* in */        LPCSTR               pszRootUrl,
        /* in */        LPMESSAGETREE        pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCSTR          pszUrl;
    LPACTIVEURL     pActiveUrl;

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better start with mhtml:
    Assert(StrCmpNI(pszRootUrl, "mhtml:", 6) == 0);

    // Fixup pszUrl
    pszUrl = (pszRootUrl + 6);

    // Better not already be running
    if (SUCCEEDED(_ResolveUrl(pszUrl, &pActiveUrl)))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Register an ActiveUrl
    CHECKHR(hr = _RegisterUrl(pTree, (BINDF)0, &pActiveUrl));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\objheap.h ===
// --------------------------------------------------------------------------------
// Objheap.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __OBJHEAP_H
#define __OBJHEAP_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagPROPERTY *LPPROPERTY;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef struct tagMIMEADDRESS *LPMIMEADDRESS;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void    InitObjectHeaps(void);
void    FreeObjectHeaps(void);
HRESULT ObjectHeap_HrAllocProperty(LPPROPERTY *ppProperty);
HRESULT ObjectHeap_HrAllocAddress(LPMIMEADDRESS *ppAddress);
void    ObjectHeap_FreeProperty(LPPROPERTY pProperty);
void    ObjectHeap_FreeAddress(LPMIMEADDRESS pAddress);

#endif // __OBJHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mimeapi.h ===
// --------------------------------------------------------------------------------
// Mimeapi.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIMEAPI_H
#define __MIMEAPI_H

// Time to allow cert start times to be be early
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CMimePropertyContainer;
typedef CMimePropertyContainer *LPCONTAINER;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
int          CompareBlob(LPCBLOB pBlob1, LPCBLOB pBlob2);
HRESULT      HrCopyBlob(LPCBLOB pIn, LPBLOB pOut);
IMSGPRIORITY PriorityFromStringA(LPCSTR pszPriority);
IMSGPRIORITY PriorityFromStringW(LPCWSTR pwszPriority);
HRESULT      MimeOleCompareUrl(LPCSTR pszCurrentUrl, BOOL fUnEscapeCurrent, LPCSTR pszComareUrl, BOOL fUnEscapeCompare);
HRESULT      MimeOleCompareUrlSimple(LPCSTR pszUrl1, LPCSTR pszUrl2);
HRESULT      MimeOleWrapHeaderText(CODEPAGEID codepage, ULONG cchMaxLine, LPCSTR pszLine, ULONG cchLine, LPSTREAM pStream);
HRESULT      MimeOleRecurseSetProp(IMimeMessageTree *pTree, HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
HRESULT      HrRfc1522Encode(LPMIMEVARIANT pSource, LPMIMEVARIANT pEncoded, CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPCSTR pszCharset, LPSTR *ppszEncoded);
LPCSTR       PszDefaultSubType(LPCSTR pszPriType);
HRESULT      MimeOleGetSentTime(LPCONTAINER pContainer, DWORD dwFlags, LPMIMEVARIANT pValue);
CODEPAGEID   MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset);
CODEPAGEID   MimeOleGetWindowsCP(HCHARSET hCharset);
LPSTR        MimeOleContentBaseFromBody(IMimeMessageTree *pTree, HBODY hBody);
HRESULT      MimeOleComputeContentBase(IMimeMessage *pMessage, HBODY hRelated, LPSTR *ppszBase, BOOL *pfMultipartBase);
LONG         CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset);
MIMEOLEAPI   MimeOleEscapeStringW(LPCWSTR pszIn, LPWSTR *ppszOut);
HRESULT      MimeOleQueryStringW(LPCWSTR pszSearchMe, LPCWSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
MIMEOLEAPI   MimeOleGenerateFileNameW(LPCSTR pszContentType, LPCWSTR pszSuggest, LPCWSTR pszDefaultExt, LPWSTR *ppszFileName);

#endif // __MIMEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\mimeapi.cpp ===
// --------------------------------------------------------------------------------
// Mimeapi.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "olealloc.h"
#include "partial.h"
#include "smime.h"
#include "vstream.h"
#include "internat.h"
#include "stackstr.h"
#include "ixputil.h"
#include "webdocs.h"
#include "containx.h"
#include "inetstm.h"
#include "mhtmlurl.h"
#include "booktree.h"
#include "bookbody.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "mlang.h"
#include "strconst.h"
#include "symcache.h"
#include "mimeapi.h"
#include "hash.h"
#include "shared.h"
#include "demand.h"

// ------------------------------------------------------------------------------------------
// Special Partial Headers
// ------------------------------------------------------------------------------------------
static LPCSTR g_rgszPartialPids[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
        PIDTOSTR(PID_HDR_CNTXFER),
        PIDTOSTR(PID_HDR_CNTDESC),
        PIDTOSTR(PID_HDR_MESSAGEID),
        PIDTOSTR(PID_HDR_MIMEVER),
        PIDTOSTR(PID_HDR_CNTID),
        PIDTOSTR(PID_HDR_CNTDISP),
        STR_HDR_ENCRYPTED
};

// --------------------------------------------------------------------------------
// MimeGetAddressFormatW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeGetAddressFormatW(REFIID riid, LPVOID pvObject, DWORD dwAdrType,
    ADDRESSFORMAT format, LPWSTR *ppszFormat)
{
    // Locals
    HRESULT                 hr=S_OK;
    CMimePropertyContainer *pContainer=NULL;

    // Trace
    TraceCall("MimeGetAddressFormatW");

    // Invalid Args
    if (NULL == pvObject)
        return(TraceResult(E_INVALIDARG));

    // Is a messageW object ?
    if (IID_IMimeMessageW == riid)
    {
        // Get It
        CHECKHR(hr = ((IMimeMessageW *)pvObject)->GetAddressFormatW(dwAdrType, format, ppszFormat));
    }

    // Is a message object ?
    else if (IID_IMimeMessage == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeMessage *)pvObject)->BindToObject(HBODY_ROOT, IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimePropertySet
    else if (IID_IMimePropertySet == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimePropertySet *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimeAddressTable
    else if (IID_IMimeAddressTable == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeAddressTable *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimeHeaderTable
    else if (IID_IMimeHeaderTable == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeHeaderTable *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // Final
    else
    {
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCP
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetCompatMode(DWORD dwMode)
{
    // Add in the bit
    FLAGSET(g_dwCompatMode, dwMode);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCP
// --------------------------------------------------------------------------------
CODEPAGEID MimeOleGetWindowsCP(HCHARSET hCharset)
{
    // Locals
    INETCSETINFO rCharset;

    // Invalid Arg
    if (NULL == hCharset)
        return CP_ACP;

    // Loopup charset
    Assert(g_pInternat);
    if (FAILED(g_pInternat->GetCharsetInfo(hCharset, &rCharset)))
        return CP_ACP;

    // Return
    return MimeOleGetWindowsCPEx(&rCharset);

}

// --------------------------------------------------------------------------------
// MimeOleStripHeaders
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleStripHeaders(IMimeMessage *pMessage, HBODY hBody, LPCSTR pszNameDelete,
    LPCSTR pszHeaderAdd, IStream **ppStream)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimeHeaderTable   *pHdrTable=NULL;
    LPSTREAM            pStmSource=NULL;
    LPSTREAM            pStmDest=NULL;
    HHEADERROW          hRow;
    HEADERROWINFO       Info;
    DWORD               cbLastRead=0;
    FINDHEADER          Find={0};
    ULARGE_INTEGER      uliCopy;

    // Trace
    TraceCall("MimeOleStripHeaders");

    // Invalid Arg
    if (NULL == pMessage || NULL == hBody || NULL == pszNameDelete || NULL == ppStream)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *ppStream = NULL;

    // Get the message source, no commit
    IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStmSource, 0));

    // Get the Header Table for hBody
    IF_FAILEXIT(hr = pMessage->BindToObject(hBody, IID_IMimeHeaderTable, (LPVOID *)&pHdrTable));

    // Initialize the Find
    Find.pszHeader = pszNameDelete;

    // Find this row
    IF_FAILEXIT(hr = pHdrTable->FindFirstRow(&Find, &hRow));

    // Create a stream
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pStmDest));

    // Delete this row
    while(1)
    {
        // Get the row information
        IF_FAILEXIT(hr = pHdrTable->GetRowInfo(hRow, &Info));

        // Setup uliCopy
        uliCopy.QuadPart = Info.cboffStart - cbLastRead;

        // Seek
        IF_FAILEXIT(hr = HrStreamSeekSet(pStmSource, cbLastRead));

        // Write from cbLast to Info.cboffStart
        IF_FAILEXIT(hr = HrCopyStreamCB(pStmSource, pStmDest, uliCopy, NULL, NULL));

        // Set cbLast
        cbLastRead = Info.cboffEnd;

        // Find the next
        hr = pHdrTable->FindNextRow(&Find, &hRow);

        // Failure
        if (FAILED(hr))
        {
            // MIME_E_NOT_FOUND
            if (MIME_E_NOT_FOUND == hr)
            {
                hr = S_OK;
                break;
            }
            else
            {
                TraceResult(hr);
                goto exit;
            }
        }
    }

    // Add on pszHeaderAdd
    if (pszHeaderAdd)
    {
        // Write the Add Header
        IF_FAILEXIT(hr = pStmDest->Write(pszHeaderAdd, lstrlen(pszHeaderAdd), NULL));
    }

    // Write the Rest of pStmSource
    IF_FAILEXIT(hr = HrStreamSeekSet(pStmSource, cbLastRead));

    // Write the Rest
    IF_FAILEXIT(hr = HrCopyStream(pStmSource, pStmDest, NULL));

    // Commit
    IF_FAILEXIT(hr = pStmDest->Commit(STGC_DEFAULT));

    // Rewind It
    IF_FAILEXIT(hr = HrRewindStream(pStmDest));

    // Return pStmDest
    *ppStream = pStmDest;
    (*ppStream)->AddRef();

exit:
    // Cleanup
    SafeRelease(pStmSource);
    SafeRelease(pHdrTable);
    SafeRelease(pStmDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCPEx
// --------------------------------------------------------------------------------
CODEPAGEID MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset)
{
    // Invalid Arg
    if (NULL == pCharset)
        return CP_ACP;

    // Check for Auto-Detect
    if (CP_JAUTODETECT == pCharset->cpiWindows)
        return 932;
    else if (CP_ISO2022JPESC == pCharset->cpiWindows)
        return 932;
    else if (CP_ISO2022JPSIO == pCharset->cpiWindows)
        return 932;
    else if (CP_KAUTODETECT == pCharset->cpiWindows)
        return 949;
    else
        return pCharset->cpiWindows;
}

// --------------------------------------------------------------------------------
// MimeOleClearDirtyTree
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleClearDirtyTree(IMimeMessageTree *pITree)
{
    // Locals
    HRESULT          hr=S_OK;
    CMessageTree    *pTree=NULL;

    // Invalid Arg
    if (NULL == pITree)
        return TrapError(E_INVALIDARG);

    // I need a private IID_CMessageTree to do this
    CHECKHR(hr = pITree->QueryInterface(IID_CMessageTree, (LPVOID *)&pTree));

    // ClearDirty
    pTree->ClearDirty();

    // Validate
    Assert(pTree->IsDirty() == S_FALSE);

exit:
    // Cleanup
    SafeRelease(pTree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PszDefaultSubType
// --------------------------------------------------------------------------------
LPCSTR PszDefaultSubType(LPCSTR pszPriType)
{
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
        return STR_SUB_PLAIN;
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
        return STR_SUB_MIXED;
    else
        return STR_SUB_OCTETSTREAM;
}

// --------------------------------------------------------------------------------
// MimeOleContentTypeFromUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleContentTypeFromUrl(
                                     /* in */        LPCSTR              pszBase,
                                     /* in */        LPCSTR              pszUrl,
                                     /* out */       LPSTR              *ppszCntType)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszFree=NULL;
    LPSTR       pszCombined=NULL;
    LPWSTR      pwszUrl=NULL;
    LPWSTR      pwszCntType=NULL;

    // Invalid Arg
    if (NULL == pszUrl || NULL == ppszCntType)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszCntType = NULL;

    // Combine the URL
    if (pszBase)
    {
        // Allocate Base + URL
        DWORD cchSize = (lstrlen(pszUrl) + lstrlen(pszBase) + 1);
        CHECKALLOC(pszFree = (LPSTR)g_pMalloc->Alloc(cchSize));

        // Format It
        wnsprintfA(pszFree, cchSize, "%s%s", pszBase, pszUrl);

        // Set combined
        pszCombined = pszFree;

        // Convert to Unicode
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszCombined));
    }

    // To Unicode
    else
    {
        // Set combined
        pszCombined = (LPSTR)pszUrl;

        // Convert to Unicode
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszUrl));
    }

    // Get the Mime Content Type from the Url
    CHECKHR(hr = FindMimeFromData(NULL, pwszUrl, NULL, NULL, NULL, 0, &pwszCntType, 0));

    // Convert to ANSI
    CHECKALLOC(*ppszCntType = PszToANSI(CP_ACP, pwszCntType));

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pwszUrl);
    SafeMemFree(pwszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleObjectFromMoniker
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleObjectFromMoniker(
                                    /* in */        BINDF               bindf,
                                    /* in */        IMoniker           *pmkOriginal,
                                    /* in */        IBindCtx           *pBindCtx,
                                    /* in */        REFIID              riid,
                                    /* out */       LPVOID             *ppvObject,
                                    /* out */       IMoniker          **ppmkNew)
{
    Assert(g_pUrlCache);
    return TrapError(g_pUrlCache->ActiveObjectFromMoniker(bindf, pmkOriginal, pBindCtx, riid, ppvObject, ppmkNew));
}

// --------------------------------------------------------------------------------
// MimeOleObjectFromUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleObjectFromUrl(
                                /* in */        LPCSTR              pszUrl,
                                /* in */        BOOL                fCreate,
                                /* in */        REFIID              riid,
                                /* out */       LPVOID             *ppvObject,
                                /* out */       IUnknown          **ppUnkKeepAlive)
{
    Assert(g_pUrlCache);
    return TrapError(g_pUrlCache->ActiveObjectFromUrl(pszUrl, fCreate, riid, ppvObject, ppUnkKeepAlive));
}

// --------------------------------------------------------------------------------
// MimeOleCombineMhtmlUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCombineMhtmlUrl(
                                  /* in */        LPSTR              pszRootUrl,
                                  /* in */        LPSTR              pszBodyUrl,
                                  /* out */       LPSTR             *ppszUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == pszBodyUrl || NULL == ppszUrl)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszUrl = NULL;

    // Allocate memory: pszRootUrl + ! + pszBodyUrl
    DWORD cchSize = (cchPrefix + lstrlen(pszRootUrl) + lstrlen(pszBodyUrl) + 2);
    CHECKALLOC(*ppszUrl = (LPSTR)g_pMalloc->Alloc(cchSize));

    // Root must start with mhtml://pszRootUrl!pszBodyUrl
    if (StrCmpNI(pszRootUrl, c_szMHTMLColon, cchPrefix) != 0)
        wnsprintfA(*ppszUrl, cchSize, "%s%s!%s", c_szMHTMLColon, pszRootUrl, pszBodyUrl);
    else
        wnsprintfA(*ppszUrl, cchSize, "%s!%s", pszRootUrl, pszBodyUrl);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSplitMhtmlUrl - Returns E_INVLAIDARG if pszUrl does not start with mhtml:
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseMhtmlUrl(
                                /* in */        LPSTR               pszUrl,
                                /* out */       LPSTR              *ppszRootUrl,
                                /* out */       LPSTR              *ppszBodyUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    CStringParser   cString;
    CHAR            chToken;
    ULONG           cchUrl;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);

    // Invalid Arg
    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    // Init
    if (ppszRootUrl)
        *ppszRootUrl = NULL;
    if (ppszBodyUrl)
        *ppszBodyUrl = NULL;

    // No an mhtml Url ?
    if (StrCmpNI(pszUrl, c_szMHTMLColon, cchPrefix) != 0)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the length
    cchUrl = lstrlen(pszUrl);

    // Init the Parser
    cString.Init(pszUrl + cchPrefix, cchUrl - cchPrefix, PSF_NOFRONTWS | PSF_NOTRAILWS);

    // Skip Over any '/'
    cString.ChSkip("/");

    // Parse
    chToken = cString.ChParse("!");
    if (0 == cString.CchValue())
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Client Wants ppszRootUrl
    if (ppszRootUrl)
    {
        // Allocate length for root part
        CHECKALLOC(*ppszRootUrl = (LPSTR)g_pMalloc->Alloc(cString.CchValue() + 1));

        // Copy It
        CopyMemory((LPBYTE)*ppszRootUrl, (LPBYTE)cString.PszValue(), cString.CchValue() + 1);
    }

    // Client Wants ppszBodyUrl
    if (ppszBodyUrl)
    {
        // Parse to the end of the string
        chToken = cString.ChParse(NULL);
        Assert('\0' == chToken);

        // Is there data
        if (cString.CchValue() > 0)
        {
            // Allocate length for root part
            CHECKALLOC(*ppszBodyUrl = (LPSTR)g_pMalloc->Alloc(cString.CchValue() + 1));

            // Copy It
            CopyMemory((LPBYTE)*ppszBodyUrl, (LPBYTE)cString.PszValue(), cString.CchValue() + 1);
        }
    }

exit:
    // Failure
    if (FAILED(hr))
    {
        if (ppszRootUrl)
            SafeMemFree(*ppszRootUrl);
        if (ppszBodyUrl)
            SafeMemFree(*ppszBodyUrl);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCombineURL
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCombineURL(
         /* in */        LPCSTR              pszBase,
         /* in */        ULONG               cchBase,
         /* in */        LPCSTR              pszURL,
         /* in */        ULONG               cchURL,
         /* in */        BOOL                fUnEscape,
         /* out */       LPSTR               *ppszAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszBase=NULL;
    LPWSTR          pwszUrl=NULL;
    LPWSTR          pwszCombined=NULL;
    ULONG           cchCombined;
    ULONG           cchActual;
    WCHAR           wchCombined[255];
    LPSTR           pszT;
    CStringParser   cString;

    // Invalid Arg
    if (NULL == pszBase || '\0' != pszBase[cchBase] || NULL == pszURL || '\0' != pszURL[cchURL] || NULL == ppszAbsolute)
        return TrapError(E_INVALIDARG);

    // INit
    *ppszAbsolute = NULL;

    // Raid-2621: Mail : Can't display images when message is only in HTML and the Content Base is in the headers
    pszT = PszSkipWhiteA((LPSTR)pszBase);
    if (pszT && '\"' == *pszT)
    {
        // Init the String
        cString.Init(pszBase, cchBase, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_ESCAPED | PSF_DBCS);

        // Remove Quotes
        if ('\"' == cString.ChParse("\"") && '\"' == cString.ChParse("\""))
        {
            // Reset pszBase
            pszBase = cString.PszValue();
            cchBase = cString.CchValue();
        }
    }

    // Convert to Wide
    CHECKALLOC(pwszBase = PszToUnicode(CP_ACP, pszBase));
    CHECKALLOC(pwszUrl =  PszToUnicode(CP_ACP, pszURL));

    // Combine
    if (SUCCEEDED(CoInternetCombineUrl(pwszBase, pwszUrl, 0, wchCombined, ARRAYSIZE(wchCombined) - 1, &cchCombined, 0)))
    {
        // Convert to ANSI
        CHECKALLOC(*ppszAbsolute = PszToANSI(CP_ACP, wchCombined));
    }

    // Otherwise, allocate
    else
    {
        // Allocate
        CHECKALLOC(pwszCombined = PszAllocW(cchCombined));

        // Combine
        CHECKHR(hr = CoInternetCombineUrl(pwszBase, pwszUrl, 0, pwszCombined, cchCombined, &cchActual, 0));

        // Valid?
        Assert(cchCombined == cchActual);

        // Convert to ANSI
        CHECKALLOC(*ppszAbsolute = PszToANSI(CP_ACP, pwszCombined));
    }

    // Unescape
    if (fUnEscape)
    {
        // Do it
        CHECKHR(hr = UrlUnescapeA(*ppszAbsolute, NULL, NULL, URL_UNESCAPE_INPLACE));
    }

exit:
    // Cleanup
    SafeMemFree(pwszBase);
    SafeMemFree(pwszUrl);
    SafeMemFree(pwszCombined);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetSubjectFileName
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetSubjectFileName(IMimePropertySet *pPropertySet, ULONG *pulPart, ULONG *pulTotal,
                                     LPSTR pszFileName, ULONG cchMax)
{
    return E_FAIL;
#if 0
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rSubject;
    PARSESTRINGINFO rParse;
    PARSESTRINGINFO rTemp;
    CHAR            szScratch[255],
        szFileName[MAX_PATH];
    ULONG           i,
        iString;
    BOOL            fValid;

    // Invalid Arg
    if (NULL == pPropertySet || NULL == pszFileName || NULL == pulPart || NULL == pulTotal)
        return TrapError(E_INVALIDARG);

    // Zero the Structure
    ZeroMemory(&rParse, sizeof(PARSESTRINGINFO));

    // Init
    *pulPart = 0;
    *pulTotal = 0;
    *pszFileName = '\0';
    *szFileName = '\0';

    // Init
    rSubject.vt = VT_LPSTR;
    rSubject.pszVal = NULL;

    // Get the subject
    CHECKHR(hr = pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject));

    // Set the Members
    rParse.cpiCodePage = CP_ACP;
    rParse.pszString   = rSubject.pszVal;
    rParse.cchString   = lstrlen(rSubject.pszVal);
    rParse.pszScratch  = szScratch;
    rParse.pszValue    = szScratch;
    rParse.cchValMax   = sizeof(szScratch);
    rParse.dwFlags     = PARSTR_SKIP_FORWARD_WS | PARSTR_STRIP_TRAILING_WS | PARSTR_GROW_VALUE_ALLOWED;

    // Initialize My String Parser
    MimeOleSetParseTokens(&rParse, " ([");

    // Loop for a while
    while(1)
    {
        // Parse up to colon
        CHECKHR(hr = MimeOleParseString(&rParse));

        // Done
        if (rParse.fDone)
            break;

        // Space, just save the last value
        if (' ' == rParse.chToken)
        {
            // Less than MAX_PATH
            if (rParse.cchValue < MAX_PATH)
                StrCpyN(szFileName, rParse.pszValue, ARRAYSIZE(szFileName));
        }

        // Loop Next few characters (001\010)
        else
        {
            // Less than MAX_PATH
            if (rParse.cchValue && rParse.cchValue < MAX_PATH)
                StrCpyN(szFileName, rParse.pszValue, ARRAYSIZE(szFileName));

            // Save the Current State
            iString = rParse.iString;

            // Find the Ending Token
            if ('(' == rParse.chToken)
                MimeOleSetParseTokens(&rParse, ")");
            else
                MimeOleSetParseTokens(&rParse, "]");

            // Parse up to colon
            CHECKHR(hr = MimeOleParseString(&rParse));

            // Done
            if (rParse.fDone)
                break;

            // (000/000) All Numbers in rParse.pszValue are numbers
            for (fValid=TRUE, i=0; i<rParse.cchValue; i++)
            {
                // End of Part Number
                if ('/' == rParse.pszValue[i])
                {
                    rParse.pszValue[i] = '\0';
                    *pulPart = StrToInt(rParse.pszValue);
                    *pulTotal = StrToInt((rParse.pszValue + i + 1));
                }

                // Digit
                else if (IsDigit(rParse.pszValue) == FALSE)
                {
                    fValid = FALSE;
                    break;
                }
            }

            // Valid ?
            if (fValid)
            {
                // Dup It
                StrCpyN(pszFileName, szFileName, cchMax);

                // Done
                goto exit;
            }

            // Reset Parser
            rParse.iString = iString;

            // Initialize My String Parser
            MimeOleSetParseTokens(&rParse, " ([");
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Cleanup
    SafeMemFree(rSubject.pszVal);
    MimeOleFreeParseString(&rParse);

    // Done
    return hr;
#endif
}

// --------------------------------------------------------------------------------
// MimeOleCreateWebDocument
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateWebDocument(
                                    LPCSTR              pszBase,
                                    LPCSTR              pszURL,
                                    IMimeWebDocument  **ppDocument)
{
    // Locals
    HRESULT             hr=S_OK;
    CMimeWebDocument   *pDocument=NULL;

    // Invalid Arg
    if (NULL == pszURL || NULL == ppDocument)
        return TrapError(E_INVALIDARG);

    // Create a Web Document Object
    CHECKALLOC(pDocument = new CMimeWebDocument);

    // Initialize It
    CHECKHR(hr = pDocument->HrInitialize(pszBase, pszURL));

    // Return It
    *ppDocument = (IMimeWebDocument *)pDocument;
    (*ppDocument)->AddRef();

exit:
    // Cleanup
    SafeRelease(pDocument);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleComputeContentBase
// --------------------------------------------------------------------------------
HRESULT MimeOleComputeContentBase(IMimeMessage *pMessage, HBODY hRelated,
    LPSTR *ppszBase, BOOL *pfMultipartBase)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hBase=NULL;

    // Init
    if (pfMultipartBase)
        *pfMultipartBase = FALSE;

    // If no hRelated was passed in, lets try to find one
    if (NULL == hRelated)
    {
        // Find the related section
        if (FAILED(MimeOleGetRelatedSection(pMessage, FALSE, &hRelated, NULL)))
        {
            // Get the root body
            pMessage->GetBody(IBL_ROOT, NULL, &hRelated);
        }
    }

    // Get the text/html body
    if (FAILED(pMessage->GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBase)))
        hBase = hRelated;

    // No Base
    if (NULL == hBase)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Call utility function
    *ppszBase = MimeOleContentBaseFromBody(pMessage, hBase);

    // If that failed and we used the text body
    if (NULL == *ppszBase && hRelated && hBase != hRelated)
        *ppszBase = MimeOleContentBaseFromBody(pMessage, hRelated);

    // Did this come from the multipart related
    if (NULL != *ppszBase && hBase == hRelated && pfMultipartBase)
        *pfMultipartBase = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleContentBaseFromBody
// --------------------------------------------------------------------------------
LPSTR MimeOleContentBaseFromBody(IMimeMessageTree *pTree, HBODY hBody)
{
    // Locals
    PROPVARIANT rVariant;

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = NULL;

    // Get Content-Base first, and then try Content-Location
    if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTBASE), NOFLAGS, &rVariant)))
    {
        // Try Content-Location
        if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)))
            rVariant.pszVal = NULL;
    }

    // Return
    return rVariant.pszVal;
}

// --------------------------------------------------------------------------------
// MimeOleGetRelatedSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetRelatedSection(
                                    IMimeMessageTree   *pTree,
                                    boolean             fCreate,
                                    LPHBODY             phRelated,
                                    boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hRoot;
    FINDBODY    rFind;
    PROPVARIANT rVariant;

    // Invalid Args
    if (NULL == pTree || NULL == phRelated)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/related section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_RELATED;

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phRelated)))
    {
        // Is there another multipart/related section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hRoot)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // If no Create, fail
    if (FALSE == fCreate)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get the Root Body
    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)STR_MIME_MPART_RELATED;

    // If Root is empty
    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

        // Set phRelated
        *phRelated = hRoot;
    }

    // If root is non-multipart, convert it to multipart/related
    else if (pTree->IsContentType(hRoot, STR_CNT_MULTIPART, NULL) == S_FALSE)
    {
        // Conver this body to a multipart/related
        CHECKHR(hr = pTree->ToMultipart(hRoot, STR_SUB_RELATED, phRelated));
    }

    // Otherwise, if root is multipart/mixed
    else if (pTree->IsContentType(hRoot, NULL, STR_SUB_MIXED) == S_OK)
    {
        // Insert First Child of multipart/mixed as multipart/related
        CHECKHR(hr = pTree->InsertBody(IBL_FIRST, hRoot, phRelated));

        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(*phRelated, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Otherwise, if root is multipart/alternative
    else if (pTree->IsContentType(HBODY_ROOT, NULL, STR_SUB_ALTERNATIVE) == S_OK)
    {
        // Convert this body to a multipart/related (alternative becomes first child)
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));

        // Should I set multipart/related; start=multipart/alternative at this point ?
    }

    // Otherwise, for unknown multipart content types
    else
    {
        // Convert this body to a multipart/related
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetMixedSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetMixedSection(
                                  IMimeMessageTree   *pTree,
                                  boolean             fCreate,
                                  LPHBODY             phMixed,
                                  boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hTemp;
    HBODY       hRoot;
    FINDBODY    rFind;
    PROPVARIANT rVariant;

    // Invalid Args
    if (NULL == pTree || NULL == phMixed)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/mixed section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_MIXED;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phMixed)))
    {
        // Is there another multipart/mixed section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // If no Create, fail
    if (FALSE == fCreate)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get the Root Body
    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));

    // If Root is empty
    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Setup Variant
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)STR_MIME_MPART_MIXED;

        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

        // Set phRelated
        *phMixed = hRoot;
    }

    // Otherwise, convert it to a multipart
    else
    {
        // Conver this body to a multipart/mixed
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_MIXED, phMixed));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetAlternativeSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetAlternativeSection(
                                        IMimeMessageTree   *pTree,
                                        LPHBODY             phAlternative,
                                        boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hTemp;
    FINDBODY    rFind;

    // Invalid Args
    if (NULL == pTree || NULL == phAlternative)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/mixed section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_ALTERNATIVE;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phAlternative)))
    {
        // Is there another multipart/mixed section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // If no Create, fail
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGenerateCID
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateCID(LPSTR pszCID, ULONG cchMax, boolean fAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cch;
    FILETIME        ft;
    SYSTEMTIME      st;
    WORD            wCounter;

    // Invalid Arg
    if (NULL == pszCID)
        return TrapError(E_INVALIDARG);

    // Get Current Time
    GetSystemTime(&st);

    // Convert to FileTime
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    if (FALSE == fAbsolute)
        cch = wnsprintfA(pszCID, cchMax, "%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());
    else
        cch = wnsprintfA(pszCID, cchMax, "CID:%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());

    // Buffer Overwrite
    Assert(cch + 1 <= CCHMAX_CID);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGenerateMID
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateMID(LPSTR pszMID, ULONG cchMax, boolean fAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cch;
    FILETIME        ft;
    SYSTEMTIME      st;
    WORD            wCounter;

    // Invalid Arg
    if (NULL == pszMID || cchMax < CCHMAX_MID)
        return TrapError(E_INVALIDARG);

    // Get Current Time
    GetSystemTime(&st);

    // Convert to FileTime
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    if (FALSE == fAbsolute)
        cch = wnsprintfA(pszMID, cchMax, "<%04x%08.8lx$%08.8lx$%s@%s>", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());
    else
        cch = wnsprintfA(pszMID, cchMax, "MID:%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());

    // Buffer Overwrite
    Assert(cch + 1 <= CCHMAX_MID);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateByteStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateByteStream(
                                   IStream             **ppStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Alocate It
    CHECKALLOC((*ppStream) = new CByteStream);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGetPropertySchema
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropertySchema(
                                    IMimePropertySchema **ppSchema)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == ppSchema)
        return TrapError(E_INVALIDARG);

    // Out of memory
    if (NULL == g_pSymCache)
        return TrapError(E_OUTOFMEMORY);

    // Create me
    *ppSchema = (IMimePropertySchema *)g_pSymCache;

    // Add Ref
    (*ppSchema)->AddRef();

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateHeaderTable
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateHeaderTable(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCONTAINER     pContainer=NULL;

    // check params
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Create a new Container Object
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init
    CHECKHR(hr = pContainer->InitNew());

    // Bind to Header table
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Failure
    SafeRelease(pContainer);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateVirtualStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateVirtualStream(IStream **ppStream)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Allocate Virtual Stream
    *ppStream = new CVirtualStream;
    if (NULL == *ppStream)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleOpenFileStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleOpenFileStream(LPCSTR pszFilePath, DWORD dwCreationDistribution, DWORD dwAccess, IStream **ppstmFile)
{
    // Invalid Arg
    if (NULL == pszFilePath || NULL == ppstmFile)
        return TrapError(E_INVALIDARG);

    // Call Internal Tool
    return OpenFileStream((LPSTR)pszFilePath, dwCreationDistribution, dwAccess, ppstmFile);
}

// ------------------------------------------------------------------------------------------
// MimeOleIsEnrichedStream, text must start with <x-rich>
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleIsEnrichedStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszT;
    BYTE        rgbBuffer[30 + 1];
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Rewind the stream
    CHECKHR(hr = HrRewindStream(pStream));

    // Read the first four bytes
    CHECKHR(hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer) - 1, &cbRead));

    // Less than four bytes read ?
    if (cbRead < (ULONG)lstrlen(c_szXRich))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Stick in a null
    rgbBuffer[cbRead] = '\0';

    // Skip White Space
    pszT = (LPSTR)rgbBuffer;

    // Skip White
    pszT = PszSkipWhiteA(pszT);
    if ('\0' == *pszT)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Compare
    if (StrCmpNI(pszT, c_szXRich, lstrlen(c_szXRich)) != 0)
    {
        hr = S_FALSE;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleIsTnefStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleIsTnefStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    BYTE        rgbSignature[4];
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Read the first four bytes
    CHECKHR(hr = pStream->Read(rgbSignature, sizeof(rgbSignature), &cbRead));

    // Less than four bytes read ?
    if (cbRead < 4)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Compare bytes
    if (rgbSignature[0] != 0x78 && rgbSignature[1] != 0x9f &&
        rgbSignature[2] != 0x3e && rgbSignature[3] != 0x22)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Its TNEF
    hr = S_OK;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGenerateFileName
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateFileName(LPCSTR pszContentType, LPCSTR pszSuggest, LPCSTR pszDefaultExt, LPSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszExt=NULL,
                    pszName=NULL;
    CHAR            szName[10];
    LPCSTR          pszExtension=NULL,
                    pszPrefix=NULL;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszFileName = NULL;

    // Find a filename extension
    if (pszContentType)
    {
        // Get the content type...
        if (SUCCEEDED(MimeOleGetContentTypeExt(pszContentType, &pszExt)))
            pszExtension = (LPCSTR)pszExt;
    }

    // Extension is still null
    if (NULL == pszExtension)
    {
        // Use default extension...
        if (pszDefaultExt)
            pszExtension = pszDefaultExt;

        // Otherwise, internal default
        else
            pszExtension = c_szDotDat;
    }

    // We Should have an extension
    Assert(pszExtension);

    // Suggested file name ?
    if (pszSuggest)
    {
        // Dup It
        pszName = PszDupA(pszSuggest);
        if (NULL == pszName)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Dupit and remove illegal filename characters...
        CleanupFileNameInPlaceA(CP_ACP, pszName);

        // Set Prefix
        pszPrefix = (LPCSTR)pszName;
    }

    // Otherwise, build a filename...
    else
    {
        // Locals
        CHAR szNumber[30];

        // Get a number...
        wnsprintfA(szNumber, ARRAYSIZE(szNumber), "%05d", DwCounterNext());

        // Allocate pszName
        wnsprintfA(szName, ARRAYSIZE(szName), "ATT%s", szNumber);

        // Set Prefix
        pszPrefix = (LPCSTR)szName;
    }

    // Build Final FileNmae= pszPrefix + pszExtension + dot + null
    DWORD cchSize = (lstrlen(pszPrefix) + lstrlen(pszExtension) + 2);
    *ppszFileName = PszAllocA(cchSize);
    if (NULL == *ppszFileName)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Build filename
    wnsprintfA(*ppszFileName, cchSize, "%s%s", pszPrefix, pszExtension);

exit:
    // Failure
    if (FAILED(hr) && E_OUTOFMEMORY != hr)
    {
        // Assume Success
        hr = S_OK;

        // Use default Attachment name
        *ppszFileName = PszDupA(c_szDefaultAttach);

        // Memory Failure
        if (NULL == *ppszFileName)
            hr = TrapError(E_OUTOFMEMORY);
    }

    // Cleanup
    SafeMemFree(pszExt);
    SafeMemFree(pszName);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// MimeOleGenerateFileNameW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateFileNameW(LPCSTR pszContentType, LPCWSTR pszSuggest, 
    LPCWSTR pszDefaultExt, LPWSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszExtA=NULL;
    LPWSTR          pszExtW=NULL;
    LPWSTR          pszName=NULL;
    WCHAR           szName[10];
    LPWSTR          pszExtension=NULL;
    LPWSTR          pszPrefix=NULL;
    int             cch = 0;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszFileName = NULL;

    // Find a filename extension
    if (pszContentType)
    {
        // Get the content type...
        if (SUCCEEDED(MimeOleGetContentTypeExt(pszContentType, &pszExtA)))
        {
            // I'm going to convert to unicode because I assume extensions are usascii
            IF_NULLEXIT(pszExtW = PszToUnicode(CP_ACP, pszExtA));

            // Save as the extension
            pszExtension = pszExtW;
        }
    }

    // Extension is still null
    if (NULL == pszExtension)
    {
        // Use default extension...
        if (pszDefaultExt)
            pszExtension = (LPWSTR)pszDefaultExt;

        // Otherwise, internal default
        else
            pszExtension = (LPWSTR)c_wszDotDat;
    }

    // We Should have an extension
    Assert(pszExtension);

    // Suggested file name ?
    if (pszSuggest)
    {
        // Dup It
        IF_NULLEXIT(pszName = PszDupW(pszSuggest));

        // Dupit and remove illegal filename characters...
        CleanupFileNameInPlaceW(pszName);

        // Set Prefix
        pszPrefix = pszName;
    }

    // Otherwise, build a filename...
    else
    {
        // Locals
        WCHAR szNumber[30];

        // Get a number...
        wnsprintfW(szNumber, ARRAYSIZE(szNumber), L"%05d", DwCounterNext());

        // Allocate pszName
        wnsprintfW(szName, ARRAYSIZE(szName), L"ATT%s", szNumber);

        // Set Prefix
        pszPrefix = szName;
    }

    // Build Final FileNmae= pszPrefix + pszExtension + dot + null
    cch = lstrlenW(pszPrefix) + lstrlenW(pszExtension) + 2;
    IF_NULLEXIT(*ppszFileName = PszAllocW(cch));

    // Build filename
    wnsprintfW(*ppszFileName, cch, L"%s%s", pszPrefix, pszExtension);

exit:
    // Failure
    if (FAILED(hr) && E_OUTOFMEMORY != hr)
    {
        // Assume Success
        hr = S_OK;

        // Use default Attachment name
        *ppszFileName = PszDupW(c_wszDefaultAttach);

        // Memory Failure
        if (NULL == *ppszFileName)
            hr = TrapError(E_OUTOFMEMORY);
    }

    // Cleanup
    SafeMemFree(pszExtA);
    SafeMemFree(pszExtW);
    SafeMemFree(pszName);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CreateMimeSecurity
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateSecurity(IMimeSecurity **ppSecurity)
{
    // check params
    if (NULL == ppSecurity)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppSecurity = (IMimeSecurity *) new CSMime;
    if (NULL == *ppSecurity)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessageParts
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessageParts(IMimeMessageParts **ppParts)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeMessageParts *pParts=NULL;

    // check params
    if (NULL == ppParts)
        return TrapError(E_INVALIDARG);

    // Init
    *ppParts = NULL;

    // Allocate Message Parts
    pParts = new CMimeMessageParts;
    if (NULL == pParts)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Success
    *ppParts = pParts;
    (*ppParts)->AddRef();

exit:
    // Done
    SafeRelease(pParts);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGetAllocator
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetAllocator(IMimeAllocator **ppMalloc)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == ppMalloc)
        return TrapError(E_INVALIDARG);

    // Allocate MimeOleMalloc
    *ppMalloc = new CMimeAllocator;
    if (NULL == *ppMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessage
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateHashTable(DWORD dwSize, BOOL fDupeKeys, IHashTable **ppHashTable)
{
    // Locals
    HRESULT               hr=S_OK;
    IHashTable            *pHash;

    // check params
    if (NULL == ppHashTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppHashTable = NULL;

    // Allocate MimeMessage
    CHECKALLOC(pHash = new CHash(NULL));

    // Init New
    CHECKHR(hr = pHash->Init(dwSize, fDupeKeys));

    // Success
    *ppHashTable = pHash;
    (*ppHashTable)->AddRef();

exit:
    // Done
    SafeRelease(pHash);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessage
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessage(IUnknown *pUnkOuter, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT               hr=S_OK;
    LPMESSAGETREE         pTree=NULL;

    // check params
    if (NULL == ppMessage)
        return TrapError(E_INVALIDARG);

    // Init
    *ppMessage = NULL;

    // Allocate MimeMessage
    CHECKALLOC(pTree = new CMessageTree(pUnkOuter));

    // Init New
    CHECKHR(hr = pTree->InitNew());

    // Success
    *ppMessage = pTree;
    (*ppMessage)->AddRef();

exit:
    // Done
    SafeRelease(pTree);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessageTree
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessageTree(IUnknown *pUnkOuter, IMimeMessageTree **ppMessageTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGETREE   pTree=NULL;

    // check params
    if (NULL == ppMessageTree)
        return TrapError(E_INVALIDARG);

    // INit
    *ppMessageTree = NULL;

    // Allocate MimeMessageTree
    CHECKALLOC(pTree = new CMessageTree(pUnkOuter));

    // Init New
    CHECKHR(hr = pTree->InitNew());

    // Success
    *ppMessageTree = pTree;
    (*ppMessageTree)->AddRef();

exit:
    // Done
    SafeRelease(pTree);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreatePropertySet
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreatePropertySet(IUnknown *pUnkOuter, IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMESSAGEBODY       pBody=NULL;

    // check params
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Allocate MimePropertySet
    CHECKALLOC(pBody = new CMessageBody(NULL, pUnkOuter));

    // Init New
    CHECKHR(hr = pBody->InitNew());

    // Success
    *ppPropertySet = (IMimePropertySet *)pBody;
    (*ppPropertySet)->AddRef();

exit:
    // Done
    SafeRelease(pBody);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleMergePartialHeaders
// -------------------------------
// Rules
// -----
// (1) All of the header fields from the initial enclosing entity
//     (part one), except those that start with "Content-" and the
//     specific header fields "Message-ID", "Encrypted", and "MIME-
//     Version", must be copied, in order, to the new message.
//
// (2) Only those header fields in the enclosed message which start
//     with "Content-" and "Message-ID", "Encrypted", and "MIME-Version"
//     must be appended, in order, to the header fields of the new
//     message.  Any header fields in the enclosed message which do not
//     start with "Content-" (except for "Message-ID", "Encrypted", and
//     "MIME-Version") will be ignored.
//
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleMergePartialHeaders(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT              hr = S_OK;
    LPCONTAINER          pc1=NULL;
    LPCONTAINER          pc2=NULL;
    ULONG                i;
    ULONG                cboffStart;
    CInternetStream      cInternet;
    LONG                 iColon;
    PROPSTRINGA          rHeader;
    PROPVARIANT          rOption;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create text stream object
    CHECKHR(hr = cInternet.HrInitNew(pstmIn));

    // Create Property Sets
    CHECKALLOC(pc1 = new CMimePropertyContainer);
    CHECKALLOC(pc2 = new CMimePropertyContainer);

    // Init
    CHECKHR(hr = pc1->InitNew());
    CHECKHR(hr = pc2->InitNew());

    // Load the first header
    CHECKHR(hr = pc1->Load(&cInternet));

    // RAID-18376: POPDOG adds extra lines after the header, so I must read the blank lines
    // until I hit the next header, then backup.
    while(1)
    {
        // Get current position
        cboffStart = cInternet.DwGetOffset();

        // Read a line
        CHECKHR(hr = cInternet.HrReadHeaderLine(&rHeader, &iColon));

        // If line is not empty, assume its the start of the next header...
        if ('\0' != *rHeader.pszVal)
        {
            // Line better have a length
            Assert(rHeader.cchVal);

            // Reset position back to cboffStart
            cInternet.Seek(cboffStart);

            // Done
            break;
        }
    }

    // Load the second header
    CHECKHR(hr = pc2->Load(&cInternet));

    // Delete Props From Header 1
    for (i=0; i<ARRAYSIZE(g_rgszPartialPids); i++)
        pc1->DeleteProp(g_rgszPartialPids[i]);

    // Delete Except from header 2
    pc2->DeleteExcept(ARRAYSIZE(g_rgszPartialPids), g_rgszPartialPids);

    // Save as Mime
    rOption.vt = VT_UI4;
    rOption.ulVal = SAVE_RFC1521;

    // Store Some Options
    pc1->SetOption(OID_SAVE_FORMAT, &rOption);
    pc2->SetOption(OID_SAVE_FORMAT, &rOption);

    // Don't default to text/plain if Content-Type is not yet set...
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pc1->SetOption(OID_NO_DEFAULT_CNTTYPE, &rOption);
    pc2->SetOption(OID_NO_DEFAULT_CNTTYPE, &rOption);

    // Save Header 1
    CHECKHR(hr = pc1->Save(pstmOut, TRUE));
    CHECKHR(hr = pc2->Save(pstmOut, TRUE));

exit:
    // Cleanup
    SafeRelease(pc1);
    SafeRelease(pc2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleParseRfc822Address
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseRfc822Address(
                                     DWORD               dwAdrType,
                                     ENCODINGTYPE        ietEncoding,
                                     LPCSTR              pszRfc822Adr,
                                     LPADDRESSLIST       pList)
{
    // Locals
    CMimePropertyContainer cContainer;

    // Parse the address
    return cContainer.ParseRfc822(dwAdrType, ietEncoding, pszRfc822Adr, pList);
}

// --------------------------------------------------------------------------------
// MimeOleParseRfc822Address
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseRfc822AddressW(
                                     DWORD               dwAdrType,
                                     LPCWSTR             pwszRfc822Adr,
                                     LPADDRESSLIST       pList)
{
    // Locals
    CMimePropertyContainer cContainer;

    // Parse the address
    return cContainer.ParseRfc822W(dwAdrType, pwszRfc822Adr, pList);
}

// --------------------------------------------------------------------------------
// MimeOleGetInternat
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetInternat(IMimeInternational **ppInternat)
{
    // check params
    if (NULL == ppInternat)
        return TrapError(E_INVALIDARG);

    // Out of memory
    if (NULL == g_pInternat)
        return TrapError(E_OUTOFMEMORY);

    // Assume Global
    *ppInternat = (IMimeInternational *)g_pInternat;

    // Set database
    (*ppInternat)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MimeOleSplitContentType
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSplitContentType(LPWSTR pszFull, LPWSTR *ppszCntType, LPWSTR *ppszSubType)
{
    // Locals
    HRESULT         hr = E_FAIL;
    LPWSTR           pszFreeMe = NULL,
                    psz = NULL,
                    pszStart;

    // check params
    if (NULL == pszFull)
        return TrapError(E_INVALIDARG);

    // Lets dup pszFull to make sure we have read access
    psz = pszFreeMe = PszDupW(pszFull);
    if (NULL == psz)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find '/'
    pszStart = psz;
    while(*psz && *psz != L'/')
        psz++;

    // If not found, return
    if (L'\0' == *psz)
        goto exit;

    // Otherwise stuff a null
    *psz = L'\0';

    // Dup
    *ppszCntType = PszDupW(pszStart);
    if (NULL == *ppszCntType)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Step over
    *psz = L'/';
    psz++;

    // If not found, return
    if (L'\0' == *psz)
        goto exit;

    // Save position
    pszStart = psz;
    while(*psz && L';' != *psz)
        psz++;

    // Save character...
    *psz = L'\0';

    // Dup as sub type
    *ppszSubType = PszDupW(pszStart);
    if (NULL == *ppszSubType)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Success
    hr = S_OK;

exit:
    // If failed
    if (FAILED(hr))
    {
        SafeMemFree((*ppszCntType));
        SafeMemFree((*ppszSubType));
    }

    // Cleanup
    SafeMemFree(pszFreeMe);

    // Done
    return hr;
}     

// --------------------------------------------------------------------------------
// MimeEscapeString - quotes '"' and '\'
//
// Returns S_OK if *ppszOut was allocated and set to the escaped string
// Retruns S_FALSE if *ppszOut is NULL - pszIn did not require escaping
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEscapeString(CODEPAGEID cpiCodePage, LPCSTR pszIn, LPSTR *ppszOut)
{
    // Locals
    HRESULT hr=S_FALSE;
    LPSTR   pszOut,
        psz;
    ULONG   cb,
        c;

    // check parameters
    if (NULL == pszIn || NULL == ppszOut)
        return TrapError(E_INVALIDARG);

    // $$ INFO $$ This is basically as fast as doing an lstrlen
    // I've decided to first detect if we need to escape
    c = 0;
    cb = 0;
    psz = (LPSTR)pszIn;
    while (*psz)
    {
        // If DBCS Lead-Byte, then skip
        if (IsDBCSLeadByteEx(cpiCodePage, *psz))
        {
            cb  += 2;
            psz += 2;
        }

        // Otherwise, text for escaped character
        else
        {
            // Count the number of character to escape
            if ('\"' == *psz || '\\' == *psz || '(' == *psz || ')' == *psz)
                c++;

            // Step one more character
            psz++;
            cb++;
        }
    }

    // No escape needed
    if (0 == c)
        goto exit;

    // Adjust number of bytes to allocate
    cb += (c + 1);

    // worst case - escape every character, so use double original strlen
    CHECKHR(hr = HrAlloc((LPVOID *)ppszOut, cb));

    // Start copy
    psz = (LPSTR)pszIn;
    pszOut = *ppszOut;
    while (*psz)
    {
        // If DBCS Lead-Byte, then skip
        if (IsDBCSLeadByteEx(cpiCodePage, *psz))
        {
            *pszOut++ = *psz++;
            *pszOut++ = *psz++;
        }

        // Otherwise, non-DBCS
        else
        {
            // Do escape
            if ('\"' == *psz || '\\' == *psz || '(' == *psz || ')' == *psz)
                *pszOut++ = '\\';

            // Regular char
            *pszOut++ = *psz++;
        }
    }

    // Null term
    *pszOut = '\0';

exit:
    // Done
    return hr;
}

MIMEOLEAPI MimeOleUnEscapeStringInPlace(LPSTR pszIn)
{
    HRESULT hr = S_OK;
    ULONG   cchOffset = 0;
    ULONG   i = 0;

    IF_TRUEEXIT((pszIn == NULL), E_INVALIDARG);

    for(;;i++)
    {
        if((pszIn[i + cchOffset] == '\\') &&
           (pszIn[i + cchOffset + 1] == '\\' ||
            pszIn[i + cchOffset + 1] == '\"' ||
            pszIn[i + cchOffset + 1] == '('  ||
            pszIn[i + cchOffset + 1] == ')'))
            cchOffset++;

        pszIn[i] = pszIn[i + cchOffset];
        if(pszIn[i] == 0)
            break;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// MimeEscapeString - quotes '"' and '\'
//
// Returns S_OK if *ppszOut was allocated and set to the escaped string
// Retruns S_FALSE if *ppszOut is NULL - pszIn did not require escaping
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEscapeStringW(LPCWSTR pszIn, LPWSTR *ppszOut)
{
    // Locals
    HRESULT hr=S_FALSE;
    LPWSTR  pszOut;
    LPWSTR  psz;
    ULONG   cch;
    ULONG   cchExtra;

    // check parameters
    if (NULL == pszIn || NULL == ppszOut)
        return TrapError(E_INVALIDARG);

    // $$ INFO $$ This is basically as fast as doing an lstrlen
    // I've decided to first detect if we need to escape
    cchExtra = 0;
    cch = 0;
    psz = (LPWSTR)pszIn;
    while (*psz)
    {
        // Count the number of character to escape
        if (L'\"' == *psz || L'\\' == *psz || L'(' == *psz || L')' == *psz)
            cchExtra++;

        // Step one more character
        psz++;
        cch++;
    }

    // No escape needed
    if (0 == cchExtra)
        goto exit;

    // Adjust number of bytes to allocate
    cch += (cchExtra + 1);

    // worst case - escape every character, so use double original strlen
    CHECKHR(hr = HrAlloc((LPVOID *)ppszOut, cch * sizeof(WCHAR)));

    // Start copy
    psz = (LPWSTR)pszIn;
    pszOut = *ppszOut;
    while (*psz)
    {
        // Do escape
        if (L'\"' == *psz || L'\\' == *psz || L'(' == *psz || L')' == *psz)
            *pszOut++ = L'\\';

        // Regular char
        *pszOut++ = *psz++;
    }

    // Null term
    *pszOut = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetFileExtension
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetFileExtension(LPCSTR pszFilePath, LPSTR pszExt, ULONG cchMax)
{
    // Locals
    CHAR        *pszExtT;

    // Invalid Arg
    if (NULL == pszFilePath || NULL == pszExt || cchMax < _MAX_EXT)
        return TrapError(E_INVALIDARG);

    // Locate the extension of the file
    pszExtT = PathFindExtension(pszFilePath);
    StrCpyN(pszExt, pszExtT, cchMax);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MimeOleGetExtClassId
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetExtClassId(LPCSTR pszExtension, LPCLSID pclsid)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cb;
    LPSTR           pszCLSID=NULL;
    HKEY            hkeyExt=NULL;
    HKEY            hkeyCLSID=NULL;
    LPSTR           pszData=NULL;
    LPWSTR          pwszCLSID=NULL;

    // check params
    if (NULL == pszExtension || NULL == pclsid)
        return TrapError(E_INVALIDARG);

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Query Value
    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Allocate Size
    cb += 1;
    CHECKHR(hr = HrAlloc((LPVOID *)&pszData, cb));

    // Get the data
    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, (LPBYTE)pszData, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Close this regkey
    RegCloseKey(hkeyExt);
    hkeyExt = NULL;

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszData, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(hkeyExt, c_szCLSID, 0, KEY_READ, &hkeyCLSID) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Get the data
    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Add One
    cb += 1;
    CHECKHR(hr = HrAlloc((LPVOID *)&pszCLSID, cb));

    // Get the data
    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, (LPBYTE)pszCLSID, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // ToUnicode
    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, pszCLSID));

    // Convert to class id
    CHECKHR(hr = CLSIDFromString(pwszCLSID, pclsid));

exit:
    // Close Reg Keys
    if (hkeyExt)
        RegCloseKey(hkeyExt);
    if (hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    SafeMemFree(pszData);
    SafeMemFree(pwszCLSID);
    SafeMemFree(pszCLSID);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetExtContentType
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetExtContentType(LPCSTR pszExtension, LPSTR *ppszContentType)
{
    LPWSTR  pwszExt,
            pwszContType = NULL;
    HRESULT hr = S_OK;
    
    if (NULL == pszExtension || NULL == ppszContentType || '.' != *pszExtension)
        return TrapError(E_INVALIDARG);

    IF_NULLEXIT(pwszExt = PszToUnicode(CP_ACP, pszExtension));

    IF_FAILEXIT(hr = MimeOleGetExtContentTypeW(pwszExt, &pwszContType));

    IF_NULLEXIT(*ppszContentType = PszToANSI(CP_ACP, pwszContType));

exit:
    MemFree(pwszExt);
    MemFree(pwszContType);

    return hr;
}

MIMEOLEAPI MimeOleGetExtContentTypeW(LPCWSTR pszExtension, LPWSTR *ppszContentType)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    HKEY            hkeyExt=NULL;
    LPWSTR          pszFull=NULL;
    ULONG           cb;

    // check params
    if (NULL == pszExtension || NULL == ppszContentType || '.' != *pszExtension)
        return TrapError(E_INVALIDARG);

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyExWrapW(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) == ERROR_SUCCESS)
    {
        // Query Value
        if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, NULL, &cb) == ERROR_SUCCESS)
        {
            // Add One
            cb += 1;

            // Allocate Size
            pszFull = PszAllocW(cb);
            if (NULL == pszFull)
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            // Get the data
            if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, (LPBYTE)pszFull, &cb) == ERROR_SUCCESS)
            {
                // Set It
                *ppszContentType = pszFull;
                pszFull = NULL;
                goto exit;
            }
        }
    }

    // Not found
    hr = MIME_E_NOT_FOUND;

exit:
    // Close Reg Keys
    if (hkeyExt)
        RegCloseKey(hkeyExt);

    // Cleanup
    MemFree(pszFull);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetFileInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetFileInfo(
                              LPSTR    pszFilePath,   LPSTR   *ppszCntType,
                              LPSTR   *ppszSubType,   LPSTR   *ppszCntDesc,
                              LPSTR   *ppszFileName,  LPSTR   *ppszExtension)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszFilePath,
            pwszCntType = NULL,
            pwszSubType = NULL,
            pwszCntDesc = NULL,
            pwszFileName = NULL,
            pwszExtension = NULL;
    LPSTR   pszCntType = NULL,
            pszSubType = NULL,
            pszCntDesc = NULL,
            pszFileName = NULL,
            pszExtension = NULL;

    // check params
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, pszFilePath));

    // Only pass in parameters for items that 
    IF_FAILEXIT(hr = MimeOleGetFileInfoW(pwszFilePath,
        ppszCntType     ? &pwszCntType      : NULL,
        ppszSubType     ? &pwszSubType      : NULL,
        ppszCntDesc     ? &pwszCntDesc      : NULL,
        ppszFileName    ? &pwszFileName     : NULL,
        ppszExtension   ? &pwszExtension    : NULL));

    if (ppszCntType)
    {
        Assert(pwszCntType);
        IF_NULLEXIT(pszCntType = PszToANSI(CP_ACP, pwszCntType));
    }
    if (ppszSubType)
    {
        Assert(pwszSubType);
        IF_NULLEXIT(pszSubType = PszToANSI(CP_ACP, pwszSubType));
    }
    if (ppszCntDesc)
    {
        Assert(pwszCntDesc);
        IF_NULLEXIT(pszCntDesc = PszToANSI(CP_ACP, pwszCntDesc));
    }
    if (ppszFileName)
    {
        Assert(pwszFileName);
        IF_NULLEXIT(pszFileName = PszToANSI(CP_ACP, pwszFileName));
    }
    if (ppszExtension)
    {
        Assert(pwszExtension);
        IF_NULLEXIT(pszExtension = PszToANSI(CP_ACP, pwszExtension));
    }

    if (ppszCntType)
        *ppszCntType = pszCntType;

    if (ppszSubType)
        *ppszSubType = pszSubType;

    if (ppszCntDesc)
        *ppszCntDesc = pszCntDesc;

    if (ppszFileName)
        *ppszFileName = pszFileName;

    if (ppszExtension)
        *ppszExtension = pszExtension;


exit:
    MemFree(pwszCntType);
    MemFree(pwszSubType);
    MemFree(pwszCntDesc);
    MemFree(pwszFileName);
    MemFree(pwszExtension);
    MemFree(pwszFilePath);

    if (FAILED(hr))
    {
        MemFree(pszCntType);
        MemFree(pszSubType);
        MemFree(pszCntDesc);
        MemFree(pszFileName);
        MemFree(pszExtension);
    }

    return hr;     
}

MIMEOLEAPI MimeOleGetFileInfoW(
                              LPWSTR    pszFilePath,  LPWSTR   *ppszCntType,
                              LPWSTR   *ppszSubType,  LPWSTR   *ppszCntDesc,
                              LPWSTR   *ppszFileName, LPWSTR   *ppszExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    SHFILEINFOW     rShFileInfo;
    LPWSTR          pszFull=NULL,
                    pszExt,
                    pszFname;

    // check params
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    // Init
    if (ppszCntType)
        *ppszCntType = NULL;
    if (ppszSubType)
        *ppszSubType = NULL;
    if (ppszCntDesc)
        *ppszCntDesc = NULL;
    if (ppszFileName)
        *ppszFileName = NULL;
    if (ppszExtension)
        *ppszExtension = NULL;

    // Locate the extension of the file
    pszFname = PathFindFileNameW(pszFilePath);
    pszExt = PathFindExtensionW(pszFilePath);

    // Did the user want the actual filename...
    if (ppszFileName)
    {
        // Allocate
        *ppszFileName = PszDupW(pszFname);
        if (NULL == *ppszFileName)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Empty extension
    if (FIsEmptyW(pszExt))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // User wanted the extension
    if (ppszExtension)
    {
        // Allocate
        *ppszExtension = PszDupW(pszExt);
        if (NULL == *ppszExtension)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // User wanted ppszCntDesc
    if (ppszCntDesc)
    {
        // Lets try to get the extension file information first
        if (SHGetFileInfoWrapW(pszExt, FILE_ATTRIBUTE_NORMAL, &rShFileInfo, sizeof(rShFileInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME | SHGFI_TYPENAME))
        {
            // Set lppszCntDesc + ( )
            DWORD cchSize = (lstrlenW(rShFileInfo.szDisplayName) + lstrlenW(rShFileInfo.szTypeName) + 5);
            *ppszCntDesc = PszAllocW(cchSize);
            if (NULL == *ppszCntDesc)
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            // Format the string
            wnsprintfW(*ppszCntDesc, cchSize, L"%s, (%s)", rShFileInfo.szDisplayName, rShFileInfo.szTypeName);
        }
    }

    // Content type
    if (ppszCntType && ppszSubType)
    {
        // Lookup content type
        if (SUCCEEDED(MimeOleGetExtContentTypeW(pszExt, &pszFull)))
        {
            // Split content type
            CHECKHR(hr = MimeOleSplitContentType(pszFull, ppszCntType, ppszSubType));
        }
    }

exit:
    // Set defaults if something was not found...
    if (ppszCntType && NULL == *ppszCntType)
        *ppszCntType = PszDupW((LPWSTR)STR_CNT_APPLICATIONW);
    if (ppszSubType && NULL == *ppszSubType)
        *ppszSubType = PszDupW((LPWSTR)STR_SUB_OCTETSTREAMW);
    if (ppszCntDesc && NULL == *ppszCntDesc)
        *ppszCntDesc = PszDupW((LPWSTR)c_szEmptyW);

    // Cleanup
    SafeMemFree(pszFull);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetContentTypeExt
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetContentTypeExt(LPCSTR pszContentType, LPSTR *ppszExtension)
{
    // Locals
    HRESULT   hr=S_OK;
    HKEY      hDatabase=NULL;
    HKEY      hContentType=NULL;
    ULONG     cb;

    // check params
    if (NULL == pszContentType || NULL == ppszExtension)
        return TrapError(E_INVALIDARG);

    // Open Content-Type --> file extension MIME Database registry key
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szMDBContentType, 0, KEY_READ, &hDatabase) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Open Content Type
    if (RegOpenKeyEx(hDatabase, pszContentType, 0, KEY_READ, &hContentType) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Query for size
    if (RegQueryValueEx(hContentType, c_szExtension, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Allocate It
    *ppszExtension = PszAllocA(cb + 1);
    if (NULL == *ppszExtension)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Query for extension
    cb = cb + 1;
    if (RegQueryValueEx(hContentType, c_szExtension, 0, NULL, (LPBYTE)*ppszExtension, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }


exit:
    // Cleanup
    if (hContentType)
        RegCloseKey(hContentType);
    if (hDatabase)
        RegCloseKey(hDatabase);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleFindCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFindCharset(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->FindCharset(pszCharset, phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleGetCharsetInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo)
{
    Assert(g_pInternat);
    return g_pInternat->GetCharsetInfo(hCharset, pCsetInfo);
}

// --------------------------------------------------------------------------------
// MimeOleGetCodePageInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePageInfo)
{
    Assert(g_pInternat);
    return g_pInternat->GetCodePageInfo(cpiCodePage, pCodePageInfo);
}

// --------------------------------------------------------------------------------
// MimeOleGetDefaultCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetDefaultCharset(LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->GetDefaultCharset(phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleSetDefaultCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetDefaultCharset(HCHARSET hCharset)
{
    Assert(g_pInternat);
    return g_pInternat->SetDefaultCharset(hCharset);
}

// --------------------------------------------------------------------------------
// MimeOleGetCodePageCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->GetCodePageCharset(cpiCodePage, ctCsetType, phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleEncodeHeader
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeHeader(
                               HCHARSET            hCharset,
                               LPPROPVARIANT       pData,
                               LPSTR              *ppszEncoded,
                               LPRFC1522INFO       pRfc1522Info)
{
    Assert(g_pInternat);
    return g_pInternat->EncodeHeader(hCharset, pData, ppszEncoded, pRfc1522Info);
}

// --------------------------------------------------------------------------------
// MimeOleDecodeHeader
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeHeader(
                               HCHARSET            hCharset,
                               LPCSTR              pszData,
                               LPPROPVARIANT       pDecoded,
                               LPRFC1522INFO       pRfc1522Info)
{
    Assert(g_pInternat);
    return g_pInternat->DecodeHeader(hCharset, pszData, pDecoded, pRfc1522Info);
}

// --------------------------------------------------------------------------------
// MimeOleVariantFree
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleVariantFree(LPPROPVARIANT pProp)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(pProp);

    // Handle Variant Type...
    switch(pProp->vt)
    {
    case VT_NULL:
    case VT_EMPTY:
    case VT_ILLEGAL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_CF:
    case VT_CLSID:
    case VT_LPWSTR:
    case VT_LPSTR:
        if ((LPVOID)pProp->pszVal != NULL)
            MemFree((LPVOID)pProp->pszVal);
        break;

    case VT_BLOB:
        if (pProp->blob.pBlobData)
            MemFree(pProp->blob.pBlobData);
        break;

    case VT_STREAM:
        if (pProp->pStream)
            pProp->pStream->Release();
        break;

    case VT_STORAGE:
        if (pProp->pStorage)
            pProp->pStorage->Release();
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_INVALIDARG);
        break;
    }

    // Init
    MimeOleVariantInit(pProp);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleVariantCopy
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleVariantCopy(LPPROPVARIANT pDest, LPPROPVARIANT pSource)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Invalid Arg
    Assert(pSource && pDest);

    // Handle Variant Type...
    switch(pSource->vt)
    {
    case VT_UI1:
        pDest->bVal = pSource->bVal;
        break;

    case VT_I2:
        pDest->iVal= pSource->iVal;
        break;

    case VT_UI2:
        pDest->uiVal = pSource->uiVal;
        break;

    case VT_I4:
        pDest->lVal = pSource->lVal;
        break;

    case VT_UI4:
        pDest->ulVal = pSource->ulVal;
        break;

    case VT_I8:
        pDest->hVal.QuadPart = pSource->hVal.QuadPart;
        break;

    case VT_UI8:
        pDest->uhVal.QuadPart = pSource->uhVal.QuadPart;
        break;

    case VT_R4:
        pDest->fltVal = pSource->fltVal;
        break;

    case VT_R8:
        pDest->dblVal = pSource->dblVal;
        break;

    case VT_CY:
        CopyMemory(&pDest->cyVal, &pSource->cyVal, sizeof(CY));
        break;

    case VT_DATE:
        pDest->date = pSource->date;
        break;

    case VT_BOOL:
        pDest->boolVal = pSource->boolVal;
        break;

    case VT_ERROR:
        pDest->scode = pSource->scode;
        break;

    case VT_FILETIME:
        CopyMemory(&pDest->filetime, &pSource->filetime, sizeof(FILETIME));
        break;

    case VT_CF:
        // Invalid Arg
        if (NULL == pSource->pclipdata)
            return TrapError(E_INVALIDARG);

        // Duplicate the clipboard format
        CHECKALLOC(pDest->pclipdata = (CLIPDATA *)g_pMalloc->Alloc(sizeof(CLIPDATA)));

        // Copy the data
        CopyMemory(pDest->pclipdata, pSource->pclipdata, sizeof(CLIPDATA));
        break;

    case VT_CLSID:
        // Invalid Arg
        if (NULL == pDest->puuid)
            return TrapError(E_INVALIDARG);

        // Duplicate the CLSID
        CHECKALLOC(pDest->puuid = (CLSID *)g_pMalloc->Alloc(sizeof(CLSID)));

        // Copy
        CopyMemory(pDest->puuid, pSource->puuid, sizeof(CLSID));
        break;

    case VT_LPWSTR:
        // Invalid Arg
        if (NULL == pSource->pwszVal)
            return TrapError(E_INVALIDARG);

        // Get Size
        cb = (lstrlenW(pSource->pwszVal) + 1) * sizeof(WCHAR);

        // Dup the unicode String
        CHECKALLOC(pDest->pwszVal = (LPWSTR)g_pMalloc->Alloc(cb));

        // Copy the data
        CopyMemory(pDest->pwszVal, pSource->pwszVal, cb);
        break;

    case VT_LPSTR:
        // Invalid Arg
        if (NULL == pSource->pszVal)
            return TrapError(E_INVALIDARG);

        // Get Size
        cb = lstrlen(pSource->pszVal) + 1;

        // Dup the unicode String
        CHECKALLOC(pDest->pszVal = (LPSTR)g_pMalloc->Alloc(cb));

        // Copy the data
        CopyMemory(pDest->pszVal, pSource->pszVal, cb);
        break;

    case VT_BLOB:
        // Invalid Arg
        if (NULL == pSource->blob.pBlobData)
            return TrapError(E_INVALIDARG);

        // Duplicate the blob
        CHECKALLOC(pDest->blob.pBlobData = (LPBYTE)g_pMalloc->Alloc(pSource->blob.cbSize));

        // Copy the data
        CopyMemory(pDest->blob.pBlobData, pSource->blob.pBlobData, pSource->blob.cbSize);
        break;

    case VT_STREAM:
        // Invalid Arg
        if (NULL == pSource->pStream)
            return TrapError(E_INVALIDARG);

        // Assume the new stream
        pDest->pStream = pSource->pStream;
        pDest->pStream->AddRef();
        break;

    case VT_STORAGE:
        // Invalid Arg
        if (NULL == pSource->pStorage)
            return TrapError(E_INVALIDARG);

        // Assume the new storage
        pDest->pStorage = pSource->pStorage;
        pDest->pStorage->AddRef();
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Success, return vt
    pDest->vt = pSource->vt;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleRecurseSetProp
// --------------------------------------------------------------------------------
HRESULT MimeOleRecurseSetProp(IMimeMessageTree *pTree, HBODY hBody, LPCSTR pszName,
    DWORD dwFlags, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrFind;
    HBODY       hChild;

    // Invalid Arg
    Assert(pTree && hBody && pValue);

    // multipart/alternative
    if (pTree->IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Get First Child
        hrFind = pTree->GetBody(IBL_FIRST, hBody, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Go down to the child
            CHECKHR(hr = MimeOleRecurseSetProp(pTree, hChild, pszName, dwFlags, pValue));

            // Next Child
            hrFind = pTree->GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Otherwise
    else
    {
        // Go down to the child
        CHECKHR(hr = pTree->SetBodyProp(hBody, pszName, dwFlags, pValue));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropA(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPSTR              *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;

    // Call Method
    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetPropA(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPCSTR              pszData)
{
    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)pszData;

    // Call Method
    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));
}


// --------------------------------------------------------------------------------
// MimeOleGetPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropW(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPWSTR             *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;

    // Call Method
    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pwszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetPropW(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPWSTR              pszData)
{
    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = (LPWSTR)pszData;

    // Call Method
    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));
}

// --------------------------------------------------------------------------------
// MimeOleGetBodyPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetBodyPropA(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPSTR              *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;

    // Call Method
    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetBodyPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetBodyPropA(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPCSTR              pszData)
{
    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)pszData;

    // Call Method
    return TrapError(pTree->SetBodyProp(hBody, pszName, dwFlags, &rVariant));
}

// --------------------------------------------------------------------------------
// MimeOleGetBodyPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetBodyPropW(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPWSTR             *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;

    // Call Method
    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pwszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetBodyPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetBodyPropW(
        IMimeMessageTree   *pTree,
        HBODY               hBody,
        LPCSTR              pszName,
        DWORD               dwFlags,
        LPCWSTR             pszData)
{
    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = (LPWSTR)pszData;

    // Call Method
    return TrapError(pTree->SetBodyProp(hBody, pszName, dwFlags, &rVariant));
}


// --------------------------------------------------------------------------------
// MimeOleQueryString
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleQueryString(
        LPCSTR              pszSearchMe,
        LPCSTR              pszCriteria,
        boolean             fSubString,
        boolean             fCaseSensitive)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszDataLower=NULL;

    // Invalid Arg
    Assert(pszSearchMe && pszCriteria);

    // Init
    STACKSTRING_DEFINE(rDataLower, 255);

    // No SubString Search
    if (FALSE == fSubString)
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (lstrcmp(pszSearchMe, pszCriteria) == 0)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (lstrcmpi(pszSearchMe, pszCriteria) == 0)
            goto exit;
    }

    // Otheriwse, comparing substring
    else
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrStr(pszSearchMe, pszCriteria) != NULL)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else
        {
            // Get the Length
            ULONG cchSearchMe = lstrlen(pszSearchMe);

            // Set size the stack string
            STACKSTRING_SETSIZE(rDataLower, cchSearchMe + 1);

            // Copy the data
            CopyMemory(rDataLower.pszVal, pszSearchMe, cchSearchMe + 1);

            // Lower Case Compare
            CharLower(rDataLower.pszVal);

            // Compare Strings...
            if (StrStr(rDataLower.pszVal, pszCriteria) != NULL)
                goto exit;
        }
    }

    // No Match
    hr = S_FALSE;

exit:
    // Cleanup
    STACKSTRING_FREE(rDataLower);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleQueryStringW
// --------------------------------------------------------------------------------
HRESULT MimeOleQueryStringW(LPCWSTR pszSearchMe, LPCWSTR pszCriteria,
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(pszSearchMe && pszCriteria);

    // No SubString Search
    if (FALSE == fSubString)
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrCmpW(pszSearchMe, pszCriteria) == 0)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (StrCmpIW(pszSearchMe, pszCriteria) == 0)
            goto exit;
    }

    // Otheriwse, comparing substring
    else
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrStrW(pszSearchMe, pszCriteria) != NULL)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (StrStrIW(pszSearchMe, pszCriteria) != NULL)
            goto exit;
    }

    // No Match
    hr = S_FALSE;

exit:
    // Done
    return hr;
}


#define FILETIME_SECOND    10000000     // 100ns intervals per second
LONG CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset) {
    LONG lRet;
    FILETIME ftNow;
    __int64  i64Offset;
#ifdef WIN32
    union {
        FILETIME ftDelta;
        __int64 i64Delta;
    };
#else
    // FILETIME ftDelta;
    // __int64  i64Delta;
    //
    // WIN32 specific.  I've commented this for WIN32 so that it will produce a compilation
    // error on non Win32 platforms.  The following code is specific to i386 since it relies on
    // __int64 being stored low dword first.
    //
    // I would have used right shift by 32 but it is not in iert.lib  Maybe you unix and mac folks
    // can get it in there.  On the other hand, maybe you won't need to.
#endif

    lRet = CertVerifyTimeValidity(pTimeToVerify, pCertInfo);

    if (lRet < 0) {
        if (! pTimeToVerify) {
            // Get the current time in filetime format so we can add the offset
            GetSystemTimeAsFileTime(&ftNow);
            pTimeToVerify = &ftNow;
        }

        i64Delta = pTimeToVerify->dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += pTimeToVerify->dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= ulOffset;
        i64Delta += i64Offset;

        // ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        // ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

        lRet = CertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

    return(lRet);
}


/*  GetCertsFromThumbprints:
**
**  Purpose:
**      Given a set of thumbprints, return an equivalent set of certificates.
**  Takes:
**      IN rgThumbprint - array of thumbprints to lookup
**      INOUT pResults  - the hr array contains error info for each cert
**                          lookup.  The pCert array has the certs.
**                          cEntries must be set on IN
**                          arrays must be alloc'd on IN
**      IN rghCertStore - set of stores to search
**      IN cCertStore   - size of rghCertStore
**  Returns:
**      MIME_S_SECURITY_ERROROCCURED if any of the lookups fail
**      (CERTIFICATE_NOT_PRESENT in the cs array for such cases)
**      MIME_S_SECURITY_NOOP if you call it with 0 in cEntries
**      E_INVALIDARG if any of the parameters are null
**      S_OK implies that all certs were found
**  Note:
**      only indexes with non-null thumbprints are considered
*/
MIMEOLEAPI  MimeOleGetCertsFromThumbprints(
                                           THUMBBLOB *const            rgThumbprint,
                                           X509CERTRESULT *const       pResults,
                                           const HCERTSTORE *const     rghCertStore,
                                           const DWORD                 cCertStore)
{
    HRESULT     hr;
    ULONG       iEntry, iStore;

    if (!(rgThumbprint &&
        pResults && pResults->rgpCert && pResults->rgcs &&
        rghCertStore && cCertStore))
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }
    if (0 == pResults->cEntries)
    {
        hr = MIME_S_SECURITY_NOOP;
        goto exit;
    }

    hr = S_OK;
    for (iEntry = 0; iEntry < pResults->cEntries; iEntry++)
    {
        if (rgThumbprint[iEntry].pBlobData)
        {
            for (iStore = 0; iStore < cCertStore; iStore++)
            {
                // We have a thumbprint, so do lookup
                pResults->rgpCert[iEntry] = CertFindCertificateInStore(rghCertStore[iStore],
                    X509_ASN_ENCODING,
                    0,                  //dwFindFlags
                    CERT_FIND_HASH,
                    (void *)(CRYPT_DIGEST_BLOB *)&(rgThumbprint[iEntry]),
                    NULL);
                if (pResults->rgpCert[iEntry])
                    {
                    break;
                    }
            }

            if (!pResults->rgpCert[iEntry])
            {
                DOUTL(1024, "CRYPT: Cert lookup failed.  #%d", iEntry);
                pResults->rgcs[iEntry] = CERTIFICATE_NOT_PRESENT;
                hr = MIME_S_SECURITY_ERROROCCURED;
            }
            else
            {
                // Validity check

                if (0 != CertVerifyTimeValidityWithDelta(NULL,
                  PCCERT_CONTEXT(pResults->rgpCert[iEntry])->pCertInfo,
                  TIME_DELTA_SECONDS))
                {
                    pResults->rgcs[iEntry] = CERTIFICATE_EXPIRED;
                }
                else
                {
                    pResults->rgcs[iEntry] = CERTIFICATE_OK;
                }
            }
        }
        else
        {
            CRDOUT("For want of a thumbprint... #%d", iEntry);
            pResults->rgpCert[iEntry] = NULL;
            pResults->rgcs[iEntry] = CERTIFICATE_NOPRINT;
            hr = MIME_S_SECURITY_ERROROCCURED;
        }
    }
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleMapSpecialCodePage
// --------------------------------------------------------------------------------
HRESULT MimeOleMapSpecialCodePage(CODEPAGEID cpIn, BOOL fRead, CODEPAGEID *pcpOut)
{
    // Locals
    DWORD           i;
    INETCSETINFO    CsetInfo;

    // Trace
    TraceCall("MimeOleMapSpecialCodePage");

    // Invalid Args
    if (NULL == pcpOut)
        return(TraceResult(E_INVALIDARG));

    // Initialize
    *pcpOut = cpIn;

    // Walk through the non-standard codepages list
    for (i=0; OENonStdCPs[i].Codepage != 0; i++)
    {
        // Is this it?
        if (OENonStdCPs[i].Codepage == cpIn)
        {
            // Read ?
            if (fRead && OENonStdCPs[i].cpRead)
                *pcpOut = OENonStdCPs[i].cpRead;

            // Send ?
            else if (OENonStdCPs[i].cpSend)
                *pcpOut = OENonStdCPs[i].cpSend;

            // Done
            break;
        }
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// MimeOleMapCodePageToCharset
// --------------------------------------------------------------------------------
HRESULT MimeOleMapCodePageToCharset(CODEPAGEID cpIn, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszCharset;
    CODEPAGEINFO    CodePage;

    // Trace
    TraceCall("MimeOleMapCodePageToCharset");

    // Invalid Args
    if (NULL == phCharset)
        return(TraceResult(E_INVALIDARG));

    // Get codepage info
    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(cpIn, &CodePage));

    // Default to using the body charset
    pszCharset = CodePage.szBodyCset;

    // Use WebCharset if body charset starts with '_' and the codepage is not 949
    if (*CodePage.szBodyCset != '_' && 949 != CodePage.cpiCodePage)
        pszCharset = CodePage.szWebCset;

    // Find the Charset
    IF_FAILEXIT(hr = MimeOleFindCharset(pszCharset, phCharset));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MimeOleSplitMessage
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSplitMessage(IMimeMessage *pMessage, ULONG cbMaxPart, IMimeMessageParts **ppParts)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cbMessage,
                        cbHeader,
                        cParts,
                        iPart,
                        cbActual,
                        cbRead=0,
                        cAttach,
                        i,
                        cbSubjectAddOn,
                        cbSubjectNew;
    LPHBODY             prghAttach=NULL;
    IStream            *pstmMsg=NULL,
                        *pstmPart=NULL;
    ULARGE_INTEGER      ulicbHeader;
    IMimePropertySet   *pRootProps=NULL;
    CMimeMessageParts  *pParts=NULL;
    IMimeMessage       *pmsgPart=NULL;
    FILETIME            ft;
    SYSTEMTIME          st;
    CHAR                szMimeId[CCHMAX_MID],
                        szNumber[30],
                        szFormat[50];
    MIMESAVETYPE        savetype;
    BODYOFFSETS         rOffsets;
    IMimeBody          *pRootBody=NULL;
    LPSTR               pszSubjectAddOn=NULL,
                        pszSubjectNew=NULL;
    PROPVARIANT         rVariant,
                        rSubject,
                        rFileName;
    float               dParts;
    HCHARSET            hCharset=NULL;
    INETCSETINFO        CsetInfo;

    // Invalid Arg
    if (NULL == ppParts)
        return TrapError(E_INVALIDARG);

    // Initialize Variants
    MimeOleVariantInit(&rSubject);
    MimeOleVariantInit(&rFileName);

    // Init
    *ppParts = NULL;

    // Get Option
    rVariant.vt = VT_UI4;
    pMessage->GetOption(OID_SAVE_FORMAT, &rVariant);
    savetype = (MIMESAVETYPE)rVariant.ulVal;

    // Raid-73119: OE : Kor: the charset for the message sent in broken apart is shown as "_autodetect_kr"
    if (SUCCEEDED(pMessage->GetCharset(&hCharset)))
    {
        // Get the charset info for the HCHARSET
        if (SUCCEEDED(MimeOleGetCharsetInfo(hCharset, &CsetInfo)))
        {
            // Map the codepage
            CODEPAGEID cpActual;
            
            // Map the codepage to the correct codepage..
            if (SUCCEEDED(MimeOleMapSpecialCodePage(CsetInfo.cpiInternet, FALSE, &cpActual)))
            {
                // If Different
                if (cpActual != CsetInfo.cpiInternet)
                {
                    // Map the codepage to a character set
                    MimeOleMapCodePageToCharset(cpActual, &hCharset);

                    // Reset the character set....
                    SideAssert(SUCCEEDED(pMessage->SetCharset(hCharset, CSET_APPLY_TAG_ALL)));
                }
            }
        }
    }

    // Get Message Source
    CHECKHR(hr = pMessage->GetMessageSource(&pstmMsg, COMMIT_ONLYIFDIRTY));

    // Create Parts Object
    CHECKALLOC(pParts = new CMimeMessageParts);

    // Rewind the stream
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Get Stream Size
    CHECKHR(hr = HrSafeGetStreamSize(pstmMsg, &cbMessage));

    // Is this size larger than the max part size
    if (cbMessage <= cbMaxPart)
    {
        // Add Single Parts to parts object
        CHECKHR(hr = pParts->AddPart(pMessage));

        // Done
        goto exit;
    }

    // Get the root body
    CHECKHR(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody));

    // Get Root body offset info
    CHECKHR(hr = pRootBody->GetOffsets(&rOffsets));

    // If the header is bigger than the max message size, we have a problem
    cbHeader = (ULONG)rOffsets.cbBodyStart - rOffsets.cbHeaderStart;
    if (cbHeader >= cbMessage || cbHeader + 256 >= cbMaxPart)
    {
        AssertSz(FALSE, "SplitMessage: The header is bigger than the max message size");
        hr = TrapError(MIME_E_MAX_SIZE_TOO_SMALL);
        goto exit;
    }

    // Get a copy of the root header
    CHECKHR(hr = pRootBody->Clone(&pRootProps));

    // Lets cleanup this header...
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTTYPE));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTDISP));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTDESC));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTID));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTLOC));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_MIMEVER));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTXFER));
    pRootProps->DeleteProp("Disposition-Notification-To");
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_MESSAGEID));

    // Compute the number of parts as a float
    dParts = (float)((float)cbMessage / (float)(cbMaxPart - cbHeader));

    // If dParts is not an integer, round up.
    cParts = (dParts - ((ULONG)dParts)) ? ((ULONG)dParts) + 1 : ((ULONG)dParts);

    // Set Max Parts in parts object
    CHECKHR(hr = pParts->SetMaxParts(cParts));

    // If MIME, create id
    if (SAVE_RFC1521 == savetype)
    {
        // Create Mime Id
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        wnsprintfA(szMimeId, ARRAYSIZE(szMimeId), "%08.8lX.%08.8lX@%s", ft.dwHighDateTime, ft.dwLowDateTime, (LPSTR)SzGetLocalHostName());

        // total=X
        wnsprintfA(szNumber, ARRAYSIZE(szNumber), "%d", cParts);

        // number=x
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = szNumber;
        CHECKHR(hr = pRootProps->SetProp(STR_PAR_TOTAL, 0, &rVariant));

        // id=XXXX
        rVariant.pszVal = szMimeId;
        CHECKHR(hr = pRootProps->SetProp(STR_PAR_ID, 0, &rVariant));

        // MIME Version
        rVariant.pszVal = (LPSTR)c_szMimeVersion;
        CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_MIMEVER), 0, &rVariant));
    }

    // Otherwise, seek pstmMsg to end of header
    else
    {
        // Get Stream Position
        CHECKHR(hr = HrStreamSeekSet(pstmMsg, rOffsets.cbBodyStart));

        // Reduce the message size
        cbMessage -= rOffsets.cbBodyStart;
    }

    // Init the variant
    rSubject.vt = VT_LPSTR;

    // Get Subject
    if (FAILED(pRootBody->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject)))
        rSubject.pszVal = NULL;

    // Enumerate bodies and get the first file name and use it in the new subject...
    if (SUCCEEDED(pMessage->GetAttachments(&cAttach, &prghAttach)))
    {
        // Init the variant
        rFileName.vt = VT_LPSTR;

        // Loop Attached
        for (i=0; i<cAttach; i++)
        {
            // Get File Name...
            if (SUCCEEDED(pMessage->GetBodyProp(prghAttach[i], PIDTOSTR(PID_ATT_FILENAME), 0, &rFileName)))
                break;
        }
    }

    // Format Number
    wnsprintfA(szNumber, ARRAYSIZE(szNumber), "%d", cParts);

    // Have a file name
    if (rFileName.pszVal)
    {
        // Make Format String...
        wnsprintfA(szFormat, ARRAYSIZE(szFormat), "%%s [%%0%dd/%d]", lstrlen(szNumber), cParts);

        // Size of subject add on string
        cbSubjectAddOn = lstrlen(rFileName.pszVal) + lstrlen(szFormat) + lstrlen(szNumber) + 1;
    }

    // Otherwise, no filename
    else
    {
        // Make Format String...
        wnsprintfA(szFormat, ARRAYSIZE(szFormat), "[%%0%dd/%d]", lstrlen(szNumber), cParts);

        // Size of subject add on string
        cbSubjectAddOn = lstrlen(szFormat) + lstrlen(szNumber) + 1;
    }

    // Allocate Subject Add On
    DWORD cchSize = (cbSubjectAddOn / sizeof(pszSubjectAddOn[0]));
    CHECKALLOC(pszSubjectAddOn = PszAllocA(cchSize));

    // Allocate new subject
    if (rSubject.pszVal)
        cbSubjectNew = cbSubjectAddOn + lstrlen(rSubject.pszVal) + 5;
    else
        cbSubjectNew = cbSubjectAddOn + 5;

    // Allocate Subject New
    CHECKALLOC(pszSubjectNew = PszAllocA(cbSubjectNew));

    // Loop throught the number of parts
    for (iPart=0; iPart<cParts; iPart++)
    {
        // Create a new stream...
        CHECKHR(hr = CreateTempFileStream(&pstmPart));

        // If MIME, I can do the partial stuff for them
        if (SAVE_RFC1521 == savetype)
        {
            // Content-Type: message/partial; number=X; total=X; id=XXXXXX
            rVariant.vt = VT_LPSTR;
            rVariant.pszVal = (LPSTR)STR_MIME_MSG_PART;
            CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

            // number=X
            wnsprintfA(szNumber, ARRAYSIZE(szNumber), "%d", iPart+1);
            rVariant.pszVal = szNumber;
            CHECKHR(hr = pRootProps->SetProp(STR_PAR_NUMBER, 0, &rVariant));
        }

        // Build Subject AddOn
        if (rFileName.pszVal)
            wnsprintfA(pszSubjectAddOn, cchSize, szFormat, rFileName.pszVal, iPart + 1);
        else
            wnsprintfA(pszSubjectAddOn, cchSize, szFormat, iPart + 1);

        // Build New Subject
        if (rSubject.pszVal)
            wnsprintfA(pszSubjectNew, cbSubjectNew, "%s %s", rSubject.pszVal, pszSubjectAddOn);
        else
            wnsprintfA(pszSubjectNew, cbSubjectNew, "%s", pszSubjectAddOn);

        // Set New Subject
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszSubjectNew;
        CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant));

        // Save Root Header
        CHECKHR(hr = pRootProps->Save(pstmPart, TRUE));

        // Emit Line Break
        CHECKHR(hr = pstmPart->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Copy bytes from lpstmMsg to pstmPart
        CHECKHR(hr = HrCopyStreamCBEndOnCRLF(pstmMsg, pstmPart, cbMaxPart - cbHeader, &cbActual));

        // Increment read
        cbRead += cbActual;

        // If cbActual is less than cbMaxMsgSize-cbHeader, better be the last part
#ifdef DEBUG
        if (iPart + 1 < cParts && cbActual < (cbMaxPart - cbHeader))
            AssertSz (FALSE, "One more partial message is going to be produced than needed. This should be harmless.");
#endif

        // Commit pstmPart
        CHECKHR(hr = pstmPart->Commit(STGC_DEFAULT));

        // Rewind it
        CHECKHR(hr = HrRewindStream(pstmPart));

        // Create Message Part...
        CHECKHR(hr = MimeOleCreateMessage(NULL, &pmsgPart));

        // Make the message build itself
        CHECKHR (hr = pmsgPart->Load(pstmPart));

        // We need another message and stream
        CHECKHR (hr = pParts->AddPart(pmsgPart));

        // Cleanup
        SafeRelease(pmsgPart);
        SafeRelease(pstmPart);
    }

    // Lets hope we read everything...
    AssertSz(cbRead == cbMessage, "Please let sbailey know if these fails.");

exit:
    // Succeeded
    if (SUCCEEDED(hr))
    {
        // Returns Parts Object
        (*ppParts) = pParts;
        (*ppParts)->AddRef();
    }

    // Cleanup
    SafeRelease(pRootBody);
    SafeRelease(pstmMsg);
    SafeRelease(pParts);
    SafeRelease(pRootProps);
    SafeRelease(pmsgPart);
    SafeRelease(pstmPart);
    SafeMemFree(pszSubjectAddOn);
    SafeMemFree(pszSubjectNew);
    SafeMemFree(prghAttach);
    MimeOleVariantFree(&rSubject);
    MimeOleVariantFree(&rFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CompareBlob
// --------------------------------------------------------------------------------
int CompareBlob(LPCBLOB pBlob1, LPCBLOB pBlob2)
{
    // Locals
    register int ret = 0;

    Assert(pBlob1 && pBlob2);

    if (pBlob1->cbSize != pBlob2->cbSize)
        ret = pBlob1->cbSize - pBlob2->cbSize;
    else
        ret = memcmp(pBlob1->pBlobData, pBlob2->pBlobData, pBlob2->cbSize);

    return ret;
}

// --------------------------------------------------------------------------------
// HrCopyBlob
// --------------------------------------------------------------------------------
HRESULT HrCopyBlob(LPCBLOB pIn, LPBLOB pOut)
{
    // Locals
    HRESULT hr;
    ULONG cb = 0;

    Assert(pIn && pOut);
    if (pIn->cbSize == 0)
    {
        pOut->cbSize = 0;
        pOut->pBlobData = NULL;
        return S_OK;
    }

    // Dup It...
    cb  = pIn->cbSize;
#ifdef _WIN64
    cb = LcbAlignLcb(cb);
#endif //_WIN64

    if (SUCCEEDED(hr = HrAlloc((LPVOID *)&pOut->pBlobData, cb)))
    {
        // Copy Memory
        CopyMemory(pOut->pBlobData, pIn->pBlobData, pIn->cbSize);

        // Set Size
        pOut->cbSize = pIn->cbSize;
    }
    else
    {
        pOut->cbSize = 0;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PriorityFromStringA
// --------------------------------------------------------------------------------
IMSGPRIORITY PriorityFromStringA(LPCSTR pszPriority)
{
    // Locals
    IMSGPRIORITY priority=IMSG_PRI_NORMAL;
    DWORD        dwPriority;

    // If IsDigit...
    if (IsDigit((LPSTR)pszPriority))
    {
        // Convert
        dwPriority = (DWORD)StrToInt(pszPriority);

        // Map to pri type
        if (dwPriority <= 2)
            priority = IMSG_PRI_HIGH;
        else if (dwPriority > 3)
            priority = IMSG_PRI_LOW;
    }

    // Otheriwse, map from high, normal and low...
    else
    {
        // High, Highest, Low, Lowest
        if (lstrcmpi(pszPriority, STR_PRI_MS_HIGH) == 0)
            priority = IMSG_PRI_HIGH;
        else if (lstrcmpi(pszPriority, STR_PRI_MS_LOW) == 0)
            priority = IMSG_PRI_LOW;
        else if (lstrcmpi(pszPriority, STR_PRI_HIGHEST) == 0)
            priority = IMSG_PRI_HIGH;
        else if (lstrcmpi(pszPriority, STR_PRI_LOWEST) == 0)
            priority = IMSG_PRI_LOW;
    }

    // Done
    return priority;
}

// --------------------------------------------------------------------------------
// PriorityFromStringW
// --------------------------------------------------------------------------------
IMSGPRIORITY PriorityFromStringW(LPCWSTR pwszPriority)
{
    // Locals
    HRESULT      hr=S_OK;
    LPSTR        pszPriority=NULL;
    IMSGPRIORITY priority=IMSG_PRI_NORMAL;

    // Convert to ANSI
    CHECKALLOC(pszPriority = PszToANSI(CP_ACP, pwszPriority));

    // Normal Conversion
    priority = PriorityFromStringA(pszPriority);

exit:
    // Done
    return priority;
}

// --------------------------------------------------------------------------------
// MimeOleCompareUrlSimple
// --------------------------------------------------------------------------------
HRESULT MimeOleCompareUrlSimple(LPCSTR pszUrl1, LPCSTR pszUrl2)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        chUrl1;
    CHAR        chUrl2;

    // Skip leading white space
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Start the loop
    while(*pszUrl1 && *pszUrl2)
    {
        // Case Insensitive
        chUrl1 = TOUPPERA(*pszUrl1);
        chUrl2 = TOUPPERA(*pszUrl2);

        // Not Equal
        if (chUrl1 != chUrl2)
        {
            hr = S_FALSE;
            break;
        }

        // Next
        pszUrl1++;
        pszUrl2++;
    }

    // Skip over trailing whitespace
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // No substrings
    if ('\0' != *pszUrl1 || '\0' != *pszUrl2)
        hr = S_FALSE;

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCompareUrl
// --------------------------------------------------------------------------------
HRESULT MimeOleCompareUrl(LPCSTR pszCurrentUrl, BOOL fUnEscapeCurrent, LPCSTR pszCompareUrl, BOOL fUnEscapeCompare)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszUrl1=(LPSTR)pszCurrentUrl;
    LPSTR       pszUrl2=(LPSTR)pszCompareUrl;
    CHAR        chPrev='\0';
    CHAR        chUrl1;
    CHAR        chUrl2;
    ULONG       cb;

    // Stack Strings
    STACKSTRING_DEFINE(rCurrentUrl, 255);
    STACKSTRING_DEFINE(rCompareUrl, 255);

    // fUnEscapeCurrent
    if (fUnEscapeCurrent)
    {
        // Get Size
        cb = lstrlen(pszCurrentUrl) + 1;

        // Set Size
        STACKSTRING_SETSIZE(rCurrentUrl, cb);

        // Copy
        CopyMemory(rCurrentUrl.pszVal, pszCurrentUrl, cb);

        // Dupe It
        CHECKHR(hr = UrlUnescapeA(rCurrentUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Adjust pszUrl1
        pszUrl1 = rCurrentUrl.pszVal;
    }

    // fUnEscapeCurrent
    if (fUnEscapeCompare)
    {
        // Get Size
        cb = lstrlen(pszCompareUrl) + 1;

        // Set Size
        STACKSTRING_SETSIZE(rCompareUrl, cb);

        // Copy
        CopyMemory(rCompareUrl.pszVal, pszCompareUrl, cb);

        // Dupe It
        CHECKHR(hr = UrlUnescapeA(rCompareUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Adjust pszUrl2
        pszUrl2 = rCompareUrl.pszVal;
    }

    // Skip leading white space
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Start the loop
    while(*pszUrl1 && *pszUrl2)
    {
        // Case Insensitive
        chUrl1 = TOUPPERA(*pszUrl1);
        chUrl2 = TOUPPERA(*pszUrl2);

        // Special case search for '/'
        if (':' == chPrev && '/' == chUrl2 && '/' != *(pszUrl2 + 1) && '/' == chUrl1 && '/' == *(pszUrl1 + 1))
        {
            // Next
            pszUrl1++;

            // Done
            if ('\0' == *pszUrl1)
            {
                hr = S_FALSE;
                break;
            }

            // Rset chUrl1
            chUrl1 = TOUPPERA(*pszUrl1);
        }

        // Not Equal
        if (chUrl1 != chUrl2)
        {
            hr = S_FALSE;
            break;
        }

        // Save Prev
        chPrev = *pszUrl1;

        // Next
        pszUrl1++;
        pszUrl2++;
    }

    // Skip over trailing whitespace
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Raid 63823: Mail : Content-Location Href's inside the message do not work if there is a Start Parameter in headers
    // Skim over remaining '/' in both urls
    while (*pszUrl1 && '/' == *pszUrl1)
        pszUrl1++;
    while (*pszUrl2 && '/' == *pszUrl2)
        pszUrl2++;

    // No substrings
    if ('\0' != *pszUrl1 || '\0' != *pszUrl2)
        hr = S_FALSE;

    // file://d:\test\foo.mhtml == d:\test\foo.mhtml
    if (S_FALSE == hr && StrCmpNI(pszCurrentUrl, "file:", 5) == 0)
    {
        // Skip over file:
        LPSTR pszRetryUrl = (LPSTR)(pszCurrentUrl + 5);

        // Skip over forward slashes
        while(*pszRetryUrl && '/' == *pszRetryUrl)
            pszRetryUrl++;

        // Compare Again
        hr = MimeOleCompareUrl(pszRetryUrl, fUnEscapeCurrent, pszCompareUrl, fUnEscapeCompare);
    }


exit:
    // Cleanup
    STACKSTRING_FREE(rCurrentUrl);
    STACKSTRING_FREE(rCompareUrl);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleWrapHeaderText
// --------------------------------------------------------------------------------
HRESULT MimeOleWrapHeaderText(CODEPAGEID codepage, ULONG cchMaxLine, LPCSTR pszLine,
    ULONG cchLine, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchIndex=0;
    ULONG       cchWrite;

    // Invalid Arg
    Assert(pszLine && pszLine[cchLine] == '\0' && pStream && cchMaxLine >= 2);

    // Start Writing
    while(1)
    {
        // Validate
        Assert(cchIndex <= cchLine);

        // Compute cchWrite
        cchWrite = min(cchLine - cchIndex, cchMaxLine - 2);

        // Done
        if (0 == cchWrite)
        {
            // Final Line Wrap
            CHECKHR(hr = pStream->Write(c_szCRLF, 2, NULL));

            // Done
            break;
        }

        // Write the line
        CHECKHR(hr = pStream->Write(pszLine + cchIndex, cchWrite, NULL));

        // If there is still more text
        if (cchIndex + cchWrite < cchLine)
        {
            // Write '\r\n\t'
            CHECKHR(hr = pStream->Write(c_szCRLFTab, 3, NULL));
        }

        // Increment iText
        cchIndex += cchWrite;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCreateBody
// --------------------------------------------------------------------------------
HRESULT MimeOleCreateBody(IMimeBody **ppBody)
{
    HRESULT             hr;
    CMessageBody *pNew;

    pNew = new CMessageBody(NULL, NULL);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    hr = pNew->QueryInterface(IID_IMimeBody, (LPVOID *)ppBody);

    pNew->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetSentTime
// --------------------------------------------------------------------------------
HRESULT MimeOleGetSentTime(LPCONTAINER pContainer, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT hr=S_OK;

    // Get the data: header field
    if (FAILED(pContainer->GetProp(SYM_HDR_DATE, dwFlags, pValue)))
    {
        // Locals
        SYSTEMTIME  st;
        MIMEVARIANT rValue;

        // Setup rValue
        rValue.type = MVT_VARIANT;
        rValue.rVariant.vt = VT_FILETIME;

        // Get current systemtime
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &rValue.rVariant.filetime);

        // If the Conversion Fails, get the current time
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_SENTTIME, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\objheap.cpp ===
// --------------------------------------------------------------------------------
// Objheap.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "objheap.h"
#include "dllmain.h"
#include "containx.h"

#include "stddef.h"
#include "objpool.h"

// --------------------------------------------------------------------------------
// Object Heap Limits
// --------------------------------------------------------------------------------
#define COBJHEAPMAX_BODY    100
#define COBJHEAPMAX_ADDR    100
#define COBJHEAPMAX_PROP    200

// --------------------------------------------------------------------------------
// Object Heap Definitions
// --------------------------------------------------------------------------------

class CPropAlloc : public CAllocObjWithIMalloc<PROPERTY,offsetof(PROPERTY,pNextValue)>
{
    public:
        static void CleanObject(PROPERTY *pProperty) {
            // Free name ?
            if (ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED) && pProperty->pbBlob)
            {
                Assert(pProperty->pbBlob != pProperty->rgbScratch);
                g_pMalloc->Free(pProperty->pbBlob);
                pProperty->pbBlob = NULL;
            }

            // Release Address Group
            SafeMemFree(pProperty->pGroup);
            CAllocObjWithIMalloc<PROPERTY,offsetof(PROPERTY,pNextValue)>::CleanObject(pProperty);
        };
};
class CAddrAlloc : public CAllocObjWithIMalloc<MIMEADDRESS,offsetof(MIMEADDRESS,pNext)>
{
    public:
        static void CleanObject(MIMEADDRESS *pAddress) {

            MimeAddressFree(pAddress);

            // We don't actually need to do this - since the base object's
            // CleanObject() just does a memset(), and the MimeAddressFree()
            // method above also does a memset().  So we'll just comment it
            // out, and save outselves the bandwidth on the memory bus...
            // CAllocObjWithIMalloc<MIMEADDRESS,g_pMalloc>::CleanObject(pAddress);

        };
};

static CAutoObjPoolMulti<PROPERTY,offsetof(PROPERTY,pNextValue),CPropAlloc> g_PropPool;
static CAutoObjPool<MIMEADDRESS,offsetof(MIMEADDRESS,pNext),CAddrAlloc> g_AddrPool;

// ---------------------------------------------------------------------------
// InitObjectHeaps
// ---------------------------------------------------------------------------
void InitObjectHeaps(void)
{
    g_PropPool.Init(COBJHEAPMAX_PROP);
    g_AddrPool.Init(COBJHEAPMAX_ADDR);
}

// ---------------------------------------------------------------------------
// FreeObjectHeaps
// ---------------------------------------------------------------------------
void FreeObjectHeaps(void)
{
    g_AddrPool.Term();
    g_PropPool.Term();
}

// ---------------------------------------------------------------------------
// ObjectHeap_HrAllocProperty
// ---------------------------------------------------------------------------
HRESULT ObjectHeap_HrAllocProperty(LPPROPERTY *ppProperty)
{
    *ppProperty = g_PropPool.GetFromPool();
    if (NULL == *ppProperty)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// --------------------------------------------------------------------------------
// ObjectHeap_HrAllocAddress
// --------------------------------------------------------------------------------
HRESULT ObjectHeap_HrAllocAddress(LPMIMEADDRESS *ppAddress)
{
    *ppAddress = g_AddrPool.GetFromPool();
    if (NULL == *ppAddress)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// ---------------------------------------------------------------------------
// ObjectHeap_FreeProperty
// ---------------------------------------------------------------------------
void ObjectHeap_FreeProperty(LPPROPERTY pProperty)
{
    g_PropPool.AddToPool(pProperty);
}

// ---------------------------------------------------------------------------
// ObjectHeap_FreeAddress
// ---------------------------------------------------------------------------
void ObjectHeap_FreeAddress(LPMIMEADDRESS pAddress)
{
    g_AddrPool.AddToPool(pAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeole\partial.cpp ===
// --------------------------------------------------------------------------------
// Partial.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "partial.h"
#include "vstream.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Releases an array