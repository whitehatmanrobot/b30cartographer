 Miniport %p, Disabling wake-up on the miniport\n", Miniport));

        WakeEnable = 0;
    
        ndisQuerySetMiniportDeviceState(Miniport,
                                        WakeEnable,
                                        OID_PNP_ENABLE_WAKE_UP,
                                        TRUE);
    }

    //
    //  Save the device state that we should go to.
    //
    *pDeviceState = NewDeviceState;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("ndisMPowerPolicy: Miniport %p, SystemState 0x%x, DeviceState 0x%x\n", Miniport, SystemState, *pDeviceState));

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\minint.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS miniport wrapper functions

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MININT

/////////////////////////////////////////////////////////////////////
//
//  HALT / CLOSE CODE
//
/////////////////////////////////////////////////////////////////////

BOOLEAN
FASTCALL
ndisMKillOpen(
    IN  PNDIS_OPEN_BLOCK        Open
    )

/*++

Routine Description:

    Closes an open. Used when NdisCloseAdapter is called.

Arguments:

    Open - The open to be closed.

Return Value:

    TRUE if the open finished, FALSE if it pended.

Comments:
    called at passive level -without- miniport's lock held.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_OPEN_BLOCK        tmpOpen;
    ULONG                   newWakeUpEnable;
    BOOLEAN                 rc = TRUE;
    NDIS_STATUS             Status;
    UINT                    OpenRef;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMKillOpen: Open %p\n", Open));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    //
    // Find the Miniport open block
    //
    for (tmpOpen = Miniport->OpenQueue;
         tmpOpen != NULL;
         tmpOpen = tmpOpen->MiniportNextOpen)
    {
        if (tmpOpen == Open)
        {
            break;
        }
    }
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    do
    {
        ASSERT(tmpOpen != NULL);
        if (tmpOpen == NULL)
            break;
            
        //
        // See if this open is already closing.
        //
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            break;
        }

        //
        // Indicate to others that this open is closing.
        //
        OPEN_SET_FLAG(Open, fMINIPORT_OPEN_CLOSING);
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        BLOCK_LOCK_MINIPORT_DPC_L(Miniport);


        //
        // Remove us from the filter package
        //
        switch (Miniport->MediaType)
        {
            //1 what should we do with the return status from ??DeleteFilterOpenAdapter
#if ARCNET
            case NdisMediumArcnet878_2:
                if (!OPEN_TEST_FLAG(Open,
                                        fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                {
                    Status = ArcDeleteFilterOpenAdapter(Miniport->ArcDB,
                                                        Open->FilterHandle,
                                                        NULL);
                    break;
                }

                //
                //  If we're using encapsulation then we
                //  didn't open an arcnet filter but rather
                //  an ethernet filter.                         
                //
#endif
            case NdisMedium802_3:
                Status = EthDeleteFilterOpenAdapter(Miniport->EthDB,
                                                    Open->FilterHandle);
                break;

            case NdisMedium802_5:
                Status = TrDeleteFilterOpenAdapter(Miniport->TrDB,
                                                   Open->FilterHandle);
                break;

            case NdisMediumFddi:
                Status = FddiDeleteFilterOpenAdapter(Miniport->FddiDB,
                                                     Open->FilterHandle);
                break;

            default:
                Status = nullDeleteFilterOpenAdapter(Miniport->NullDB,
                                                     Open->FilterHandle);
                break;
        }

        //
        //  Fix up flags that are dependant on all opens.
        //

        //
        // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
        //
        newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);

        for (tmpOpen = Miniport->OpenQueue;
             tmpOpen != NULL;
             tmpOpen = tmpOpen->MiniportNextOpen)
        {
            //
            //  We don't want to include the open that is closing.
            //
            if (tmpOpen != Open)
            {
                newWakeUpEnable |= tmpOpen->WakeUpEnable;
            }
        }

        //
        //  Reset the filter settings. Just to be sure that we remove the
        //  opens settings at the adapter.
        //
        switch (Miniport->MediaType)
        {
            case NdisMedium802_3:
            case NdisMedium802_5:
            case NdisMediumFddi:
#if ARCNET
            case NdisMediumArcnet878_2:
#endif
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
                {
                    ndisMRestoreFilterSettings(Miniport, Open, FALSE);
                }
                
                break;
        }

        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("!=0 Open 0x%x References 0x%x\n", Open, Open->References));

        if (Status != NDIS_STATUS_CLOSING_INDICATING)
        {
            //
            // Otherwise the close action routine will fix this up.
            //
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

            M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);
        }
        else
        {
            OpenRef = (UINT)-1;
        }

        rc = FALSE;
        
        if (OpenRef != 0)
        {
            ndisMDoRequests(Miniport);
            UNLOCK_MINIPORT_L(Miniport);
        }
        else
        {
            UNLOCK_MINIPORT_L(Miniport);
            ndisMFinishClose(Open);
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMKillOpen: Open %p, rc %ld\n", Open, rc));

    KeLowerIrql(OldIrql);
    
    PnPDereferencePackage();

    return rc;
}

VOID
FASTCALL
ndisMFinishClose(
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    Finishes off a close adapter call. it is called when the ref count on the open
    drops to zero.

    CALLED WITH LOCK HELD!!

Arguments:

    Miniport - The mini-port the open is queued on.

    Open - The open to close

Return Value:

    None.

Comments:
    Called at DPC with Miniport's SpinLock held


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMFinishClose: MOpen %p\n", Open));

    ASSERT(OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING));

    MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);
    

    //
    // free any memory allocated to Vcs
    //
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        ndisMCoFreeResources(Open);
    }

    ndisDeQueueOpenOnProtocol(Open, Open->ProtocolHandle);

    if (Open->Flags & fMINIPORT_OPEN_PMODE)
    {
        Miniport->PmodeOpens --;
        Open->Flags &= ~fMINIPORT_OPEN_PMODE;
        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
        ndisUpdateCheckForLoopbackFlag(Miniport);            
    }
    
    ndisDeQueueOpenOnMiniport(Open, Miniport);
    
    Open->QC.Status = NDIS_STATUS_SUCCESS;
    
    INITIALIZE_WORK_ITEM(&Open->QC.WorkItem,
                         ndisMQueuedFinishClose,
                         Open);
    QUEUE_WORK_ITEM(&Open->QC.WorkItem, DelayedWorkQueue);
    
    MINIPORT_DECREMENT_REF(Miniport);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMFinishClose: Mopen %p\n", Open));
}


VOID
ndisMQueuedFinishClose(
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    Finishes off a close adapter call.

Arguments:

    Miniport - The mini-port the open is queued on.

    Open - The open to close

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PKEVENT                 pAllOpensClosedEvent;
    KIRQL                   OldIrql;
    BOOLEAN                 FreeOpen;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMQueuedFinishClose: Open %p, Miniport %p\n", Open, Miniport));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);

    (Open->ProtocolHandle->ProtocolCharacteristics.CloseAdapterCompleteHandler) (
            Open->ProtocolBindingContext,
            NDIS_STATUS_SUCCESS);

    MINIPORT_DECREMENT_REF(Miniport);

    if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING))
    {
        //
        // need to send a WMI event now.
        //
        ndisNotifyWmiBindUnbind(Miniport, Open->ProtocolHandle, FALSE);
    }
    
    ndisDereferenceProtocol(Open->ProtocolHandle, FALSE);
    if (Open->CloseCompleteEvent != NULL)
    {
        SET_EVENT(Open->CloseCompleteEvent);
    }


    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if ((Miniport->AllOpensClosedEvent != NULL) &&
        (Miniport->OpenQueue == NULL))
    {
        pAllOpensClosedEvent = Miniport->AllOpensClosedEvent;
        Miniport->AllOpensClosedEvent = NULL;
        SET_EVENT(pAllOpensClosedEvent);
    }
    

    ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
    
    if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_DONT_FREE))
    {
        //
        // there is an unbind attempt in progress
        // do not free the Open block and let unbind know that
        // you've seen its message
        //
        OPEN_SET_FLAG(Open, fMINIPORT_OPEN_CLOSE_COMPLETE);
        FreeOpen = FALSE;
    }
    else
    {
        FreeOpen = TRUE;
    }
      
    
    RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (FreeOpen)
    {
        ndisRemoveOpenFromGlobalList(Open);
        FREE_POOL(Open);
    }
        
    //
    // finaly decrement the ref count we added for miniport
    //
    MINIPORT_DECREMENT_REF(Miniport);

    //
    // decrement the ref count for PnP package that we added when noticed
    // close is going to pend.
    //
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMQueuedFinishClose: Open %p, Miniport %p\n", Open, Miniport));
}


VOID
FASTCALL
ndisDeQueueOpenOnMiniport(
    IN  PNDIS_OPEN_BLOCK            OpenP,
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )

/*++

Routine Description:


Arguments:


Return Value:

Note: Called with Miniport lock held.


--*/
{    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisDeQueueOpenOnMiniport: MOpen %p, Miniport %p\n", OpenP, Miniport));

    //
    // we can not reference the package here because this routine can
    // be called at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    //
    // Find the open on the queue, and remove it.
    //

    if (Miniport->OpenQueue == OpenP)
    {
        Miniport->OpenQueue = OpenP->MiniportNextOpen;
        Miniport->NumOpens--;
    }
    else
    {
        PNDIS_OPEN_BLOCK PP = Miniport->OpenQueue;

        while ((PP != NULL) && (PP->MiniportNextOpen != OpenP))
        {
            PP = PP->MiniportNextOpen;
        }
        if (PP == NULL)
        {
#if TRACK_MOPEN_REFCOUNTS
            DbgPrint("Ndis:ndisDeQueueOpenOnMiniport Open %p is -not- on Miniport %p\n", OpenP, Miniport);
            DbgBreakPoint();
#endif
        }
        else
        {
            PP->MiniportNextOpen = PP->MiniportNextOpen->MiniportNextOpen;
            Miniport->NumOpens--;
        }
    }
    ndisUpdateCheckForLoopbackFlag(Miniport);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisDeQueueOpenOnMiniport: MOpen %p, Miniport %p\n", OpenP, Miniport));
}


BOOLEAN
FASTCALL
ndisQueueMiniportOnDriver(
    IN PNDIS_MINIPORT_BLOCK     Miniport,
    IN PNDIS_M_DRIVER_BLOCK     MiniBlock
    )

/*++

Routine Description:

    Adds an mini-port to a list of mini-port for a driver.

Arguments:

    Miniport - The mini-port block to queue.
    MiniBlock - The driver block to queue it to.

Return Value:

    FALSE if the driver is closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisQueueMiniportOnDriver: Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));

    PnPReferencePackage();

    do
    {
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);


        //
        // Make sure the driver is not closing.
        //
        //1 do we need to do this?
        if (MiniBlock->Ref.Closing)
        {
            RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
            rc = FALSE;
            break;
        }

        //
        // Add this adapter at the head of the queue
        //
        Miniport->NextMiniport = MiniBlock->MiniportQueue;
        MiniBlock->MiniportQueue = Miniport;
        
        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
    } while (FALSE);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisQueueMiniportOnDriver: Miniport %p, MiniBlock %p, rc %ld\n", Miniport, MiniBlock, rc));
        
    return rc;
}


VOID FASTCALL
FASTCALL
ndisDeQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock
    )

/*++

Routine Description:

    Removes an mini-port from a list of mini-port for a driver.

Arguments:

    Miniport - The mini-port block to dequeue.
    MiniBlock - The driver block to dequeue it from.

Return Value:

    None.

--*/

{
    PNDIS_MINIPORT_BLOCK *ppQ;
    KIRQL   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisDeQueueMiniportOnDriver, Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    //
    // Find the driver on the queue, and remove it.
    //
    for (ppQ = &MiniBlock->MiniportQueue;
         *ppQ != NULL;
         ppQ = &(*ppQ)->NextMiniport)
    {
        if (*ppQ == Miniport)
        {
            *ppQ = Miniport->NextMiniport;
            break;
        }
    }

    ASSERT(*ppQ == Miniport->NextMiniport);

    //
    // the same miniport can be queued on the driver again without all the fields
    // getting re-initialized so zero out the linkage
    //
    Miniport->NextMiniport = NULL;

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisDeQueueMiniportOnDriver: Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));
}


VOID
FASTCALL
ndisDereferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  BOOLEAN                 fGlobalLockHeld
    )
/*++

Routine Description:

    Removes a reference from the mini-port driver, deleting it if the count goes to 0.

Arguments:

    Miniport - The mini-port block to dereference.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql = PASSIVE_LEVEL;

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("==>ndisDereferenceDriver: MiniBlock %p\n", MiniBlock));
        
    
    if (ndisDereferenceRef(&(MiniBlock)->Ref))
    {
        PNDIS_M_DRIVER_BLOCK            *ppMB;
        PNDIS_PENDING_IM_INSTANCE       ImInstance, NextImInstance;
    
        //
        // Remove it from the global list.
        //
        ASSERT (IsListEmpty(&MiniBlock->DeviceList));

        if (!fGlobalLockHeld)
        {
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
        }

        for (ppMB = &ndisMiniDriverList; *ppMB != NULL; ppMB = &(*ppMB)->NextDriver)
        {
            if (*ppMB == MiniBlock)
            {
                *ppMB = MiniBlock->NextDriver;
                DEREF_NDIS_DRIVER_OBJECT();
                break;
            }
        }

        if (!fGlobalLockHeld)
        {
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        }

        //
        // Free the wrapper handle allocated during NdisInitializeWrapper
        //
        if (MiniBlock->NdisDriverInfo != NULL)
        {
            FREE_POOL(MiniBlock->NdisDriverInfo);
            MiniBlock->NdisDriverInfo = NULL;
        }

        //
        // Free any queued device-instance blocks
        //
        for (ImInstance = MiniBlock->PendingDeviceList;
             ImInstance != NULL;
             ImInstance = NextImInstance)
        {
            NextImInstance = ImInstance->Next;
            FREE_POOL(ImInstance);
        }

        //
        // set the event holding unload to go through
        //
        SET_EVENT(&MiniBlock->MiniportsRemovedEvent);
    }

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
                ("<==ndisDereferenceDriver: MiniBlock %p\n", MiniBlock));
}

#if DBG

BOOLEAN
FASTCALL
ndisReferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    BOOLEAN rc;

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("==>ndisReferenceMiniport: Miniport %p\n", Miniport));

    rc = ndisReferenceULongRef(&(Miniport->Ref));

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("    ndisReferenceMiniport: Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("<==ndisReferenceMiniport: Miniport %p\n", Miniport));

    return(rc);
}

VOID
FASTCALL
ndisReferenceMiniportNoCheck(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    KIRQL   OldIrql;

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("==>ndisReferenceMiniportNoCheck: Miniport %p\n", Miniport));

    ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);

    Miniport->Ref.ReferenceCount++;

    RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("    ndisReferenceMiniportNoCheck: Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("<==ndisReferenceMiniportNoCheck: Miniport %p\n", Miniport));
}

#endif

#ifdef TRACK_MINIPORT_REFCOUNTS
BOOLEAN
ndisReferenceMiniportAndLog(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module
    )
{
    BOOLEAN rc;
    rc = ndisReferenceMiniport(Miniport);
    M_LOG_MINIPORT_INCREMENT_REF(Miniport, Line, Module);
    return rc;
}

VOID
ndisReferenceMiniportAndLogNoCheck(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module
    )
{
    ndisReferenceMiniportNoCheck(Miniport);
    M_LOG_MINIPORT_INCREMENT_REF(Miniport, Line, Module);
}

BOOLEAN
ndisReferenceMiniportAndLogCreate(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module,
    IN  PIRP                    Irp
    )
{
    BOOLEAN rc;

    UNREFERENCED_PARAMETER(Irp);
    
    rc = ndisReferenceMiniport(Miniport);
    M_LOG_MINIPORT_INCREMENT_REF_CREATE(Miniport, Line, Module);
    return rc;
}
#endif

VOID
FASTCALL
ndisDereferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Removes a reference from the mini-port driver, deleting it if the count goes to 0.

Arguments:

    Miniport - The mini-port block to dereference.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY      Link;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;
    UINT                    c;
    PKEVENT                 RemoveReadyEvent = NULL;
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
    BOOLEAN                 fTimerCancelled;
#endif
    BOOLEAN                 rc;
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("==>ndisDereferenceMiniport: Miniport %p\n", Miniport));
        
    rc = ndisDereferenceULongRef(&(Miniport)->Ref);
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("ndisDereferenceMiniport:Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));
    
    if (rc)
    {
        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("ndisDereferenceMiniport:Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));

        RemoveReadyEvent = Miniport->RemoveReadyEvent;
        
        if (ndisIsMiniportStarted(Miniport) && (Miniport->Ref.ReferenceCount == 0))
        {
            //1 is the Miniport->Ref protected so it does not go back up?
            ASSERT (Miniport->Interrupt == NULL);

            if (Miniport->EthDB)
            {
                EthDeleteFilter(Miniport->EthDB);
                Miniport->EthDB = NULL;
            }

            if (Miniport->TrDB)
            {
                TrDeleteFilter(Miniport->TrDB);
                Miniport->TrDB = NULL;
            }

            if (Miniport->FddiDB)
            {
                FddiDeleteFilter(Miniport->FddiDB);
                Miniport->FddiDB = NULL;
            }

#if ARCNET
            if (Miniport->ArcDB)
            {
                ArcDeleteFilter(Miniport->ArcDB);
                Miniport->ArcDB = NULL;
            }
#endif

            if (Miniport->AllocatedResources)
            {
                FREE_POOL(Miniport->AllocatedResources);
            }
            Miniport->AllocatedResources = NULL;
            
            //
            //  Free the work items that are currently on the work queue that are
            //  allocated outside of the miniport block
            //
            for (c = NUMBER_OF_SINGLE_WORK_ITEMS; c < NUMBER_OF_WORK_ITEM_TYPES; c++)
            {
                //
                //  Free all work items on the current queue.
                //
                //1 This should not happen.
                //1 should add ASSERT(Miniport->WorkQueue[c].Next == NULL);
                while (Miniport->WorkQueue[c].Next != NULL)
                {
                    Link = PopEntryList(&Miniport->WorkQueue[c]);
                    WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);
                    FREE_POOL(WorkItem);
                }
            }
        
            if (Miniport->OidList != NULL)
            {
                FREE_POOL(Miniport->OidList);
                Miniport->OidList = NULL;
            }

            //
            //  Did we set a timer for the link change power down?
            //

            //1 get rid of this code when we get rid of the code that sets the timer
            
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                
                NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
                if (!fTimerCancelled)
                {
                    NdisStallExecution(Miniport->MediaDisconnectTimeOut * 1000000);
                }
            }
#endif

#if ARCNET
            //
            //  Is there an arcnet lookahead buffer allocated?
            //
            if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
                (Miniport->ArcBuf != NULL))
            {
                if (Miniport->ArcBuf->ArcnetLookaheadBuffer != NULL)
                {
                    FREE_POOL(Miniport->ArcBuf->ArcnetLookaheadBuffer);
                }

                if (Miniport->ArcBuf->ArcnetBuffers[0].Buffer)
                {
                    FREE_POOL(Miniport->ArcBuf->ArcnetBuffers[0].Buffer);
                    Miniport->ArcBuf->ArcnetBuffers[0].Buffer = NULL;
                }
                
                FREE_POOL(Miniport->ArcBuf);
                Miniport->ArcBuf = NULL;
            }
#endif
            
            //
            //  Free the map of custom GUIDs to OIDs.
            //
            if (NULL != Miniport->pNdisGuidMap)
            {
                FREE_POOL(Miniport->pNdisGuidMap);
                Miniport->pNdisGuidMap = NULL;
            }
            
            if (Miniport->FakeMac != NULL)
            {
                FREE_POOL(Miniport->FakeMac);
                Miniport->FakeMac = NULL;
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                CoDereferencePackage();
            }

            //
            // This will take care of freeing DMA resources
            // in case they were not freed during the halt
            // because the halt was the result of the adapter
            // going to D3.
            //
            if ((Miniport->DmaAdapterRefCount == 1) &&
                (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST)))
            {
                Miniport->DmaResourcesReleasedEvent = NULL;
                ndisDereferenceDmaAdapter(Miniport);
                MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SG_LIST);
            }
                
            ndisDeQueueMiniportOnDriver(Miniport, Miniport->DriverHandle);
            NdisMDeregisterAdapterShutdownHandler(Miniport);
            IoUnregisterShutdownNotification(Miniport->DeviceObject);

            if (Miniport->SymbolicLinkName.Buffer != NULL)
            {
                RtlFreeUnicodeString(&Miniport->SymbolicLinkName);
                Miniport->SymbolicLinkName.Buffer = NULL;
            }

            ndisDereferenceDriver(Miniport->DriverHandle, FALSE);
            
            MiniportDereferencePackage();
        }
        
        if (RemoveReadyEvent)
        {
            SET_EVENT(RemoveReadyEvent);
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("<==ndisDereferenceMiniport: Miniport %p\n", Miniport));
}


VOID
FASTCALL
ndisMCommonHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This is common code for halting a miniport.  There are two different paths
    that will call this routine: 1) from a normal unload. 2) from an adapter
    being transitioned to a low power state.

Arguments:

Return Value:

--*/
{
    KIRQL           OldIrql;
    BOOLEAN         Canceled;
    PNDIS_AF_LIST   MiniportAfList, pNext;
    KEVENT          RequestsCompletedEvent;
    FILTER_PACKET_INDICATION_HANDLER PacketIndicateHandler = ndisMDummyIndicatePacket;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMCommonHaltMiniport: Miniport %p\n", Miniport));

    PnPReferencePackage();
    
    //
    // wait for outstanding resets to complete
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_REJECT_REQUESTS);
    
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->ResetCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->ResetCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->ResetCompletedEvent = NULL;

    //
    // if we have an outstanding queued workitem to initialize the bindings
    // wait for it to fire
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM))
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->QueuedBindingCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->QueuedBindingCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->QueuedBindingCompletedEvent = NULL;

    //1 check for the return code
    IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
    
    //
    //  Deregister with WMI
    //
    //1 check for the return code
    IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_DEREGISTER);


    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER))
    {
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_CANCEL_WAKE_UP_TIMER);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        NdisCancelTimer(&Miniport->WakeUpDpcTimer, &Canceled);
        
        if (!Canceled)
        {
            INITIALIZE_EVENT(&RequestsCompletedEvent);
            Miniport->WakeUpTimerEvent = &RequestsCompletedEvent;
        }

        if (Miniport->WakeUpTimerEvent)
        {
            WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
        }
        
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    Miniport->WakeUpTimerEvent = NULL;

    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    if (Miniport->PendingRequest != NULL)
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->AllRequestsCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->AllRequestsCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->AllRequestsCompletedEvent = NULL;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
    {
        PacketIndicateHandler = Miniport->PacketIndicateHandler;
        Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        while (Miniport->IndicatedPacketsCount != 0)
        {
            NdisMSleep(1000);
        }
    }
    
    (Miniport->DriverHandle->MiniportCharacteristics.HaltHandler)(Miniport->MiniportAdapterContext);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
    {
        Miniport->PacketIndicateHandler = PacketIndicateHandler;
    }
    
    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_HALTING);


    //
    // if the halt is the result of adapter going to D3,
    // then do not free DMA resources because we may still have
    // sends in progress.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
    {

        //
        // if the adapter uses SG DMA, we have to dereference the DMA adapter
        // to get it freed
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
        {
            ndisDereferenceDmaAdapter(Miniport);
        }

        INITIALIZE_EVENT(&RequestsCompletedEvent);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        Miniport->DmaResourcesReleasedEvent = &RequestsCompletedEvent;
        
        if (Miniport->SystemAdapterObject != NULL)
        {
            LARGE_INTEGER TimeoutValue;

            TimeoutValue.QuadPart = Int32x32To64(30000, -10000); // Make it 30 second

            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            
            if (WAIT_FOR_OBJECT(&RequestsCompletedEvent, &TimeoutValue) != STATUS_SUCCESS)
            {
                //1 bugcheck here
#if DBG
                ASSERTMSG("Ndis: Miniport is going away without releasing all resources.\n", (Miniport->DmaAdapterRefCount == 0));
#endif
            }
            
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }

        Miniport->DmaResourcesReleasedEvent = NULL;
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SG_LIST);
    }
    
    ASSERT(Miniport->TimerQueue == NULL);
    ASSERT (Miniport->Interrupt == NULL);
    ASSERT(Miniport->MapRegisters == NULL);

    //
    // check for memory leak
    //
    if (Miniport == ndisMiniportTrackAlloc)
    {
        ASSERT(IsListEmpty(&ndisMiniportTrackAllocList));
        ndisMiniportTrackAlloc = NULL;
    }

    //
    // zero out statistics
    //
    ZeroMemory(&Miniport->NdisStats, sizeof(Miniport->NdisStats));
    
    if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
    {
        if (Miniport->Interrupt != NULL)
        {
            BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
            KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                        8,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Miniport->Interrupt,
                        0);
        }
        else
        {
            BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
            KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                        9,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Miniport->TimerQueue,
                        0);
        }
    }

    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);

    ndisMAbortPackets(Miniport, NULL, NULL);

    //
    //  Dequeue any request work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    ndisMAbortRequests(Miniport);

    //
    // Free up any AFs registered by this miniport
    //
    for (MiniportAfList = Miniport->CallMgrAfList, Miniport->CallMgrAfList = NULL;
         MiniportAfList != NULL;
         MiniportAfList = pNext)
    {
        pNext = MiniportAfList->NextAf;
        FREE_POOL(MiniportAfList);
    }

    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMCommonHaltMiniport: Miniport %p\n", Miniport));
}


VOID
FASTCALL
ndisMHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Does all the clean up for a mini-port.

Arguments:

    Miniport - pointer to the mini-port to halt

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMHaltMiniport: Miniport %p\n", Miniport));

    do
    {
        //
        // If the Miniport is already closing, return.
        //
        if (!ndisCloseULongRef(&Miniport->Ref))
        {
            break;
        }
        
        //
        // if the miniport is not already halted becuase of a PM event
        // halt it here
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
        {
            //
            //  Common halt code.
            //
            ndisMCommonHaltMiniport(Miniport);

            //
            // If a shutdown handler was registered then deregister it.
            //
            NdisMDeregisterAdapterShutdownHandler(Miniport);
        }
        
        MINIPORT_DECREMENT_REF(Miniport);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMHaltMiniport: Miniport %p\n", Miniport));
}

VOID
ndisMUnload(
    IN  PDRIVER_OBJECT          DriverObject
    )
/*++

Routine Description:

    This routine is called when a driver is supposed to unload.

Arguments:

    DriverObject - the driver object for the mac that is to unload.

Return Value:

    None.

--*/
{
    PNDIS_M_DRIVER_BLOCK MiniBlock, IoMiniBlock;
#if TRACK_UNLOAD
    PNDIS_M_DRIVER_BLOCK    Tmp;
    PNDIS_MINIPORT_BLOCK    Miniport, NextMiniport;
#endif
    KIRQL                OldIrql;
    
#if TRACK_UNLOAD
    DbgPrint("ndisMUnload: DriverObject %p\n", DriverObject);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMUnload: DriverObject %p\n", DriverObject));

    PnPReferencePackage();
    
    do
    {
        //
        // Search for the driver
        //

        IoMiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
                                                                     
        if (IoMiniBlock && !(IoMiniBlock->Flags & fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD))
        {
            IoMiniBlock->Flags |= fMINIBLOCK_IO_UNLOAD;
        }

        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        MiniBlock = ndisMiniDriverList;

        while (MiniBlock != (PNDIS_M_DRIVER_BLOCK)NULL)
        {
            if (MiniBlock->NdisDriverInfo->DriverObject == DriverObject)
            {
                break;
            }

            MiniBlock = MiniBlock->NextDriver;
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

#if TRACK_UNLOAD
        DbgPrint("ndisMUnload: MiniBlock %p\n", MiniBlock);
#endif

        if (MiniBlock == (PNDIS_M_DRIVER_BLOCK)NULL)
        {
            //
            // It is already gone.  Just return.
            //
            break;
        }
        
        ASSERT(MiniBlock == IoMiniBlock);
        
        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("  ndisMUnload: MiniBlock %p\n", MiniBlock));

        MiniBlock->Flags |= fMINIBLOCK_UNLOADING;

        //
        // Now remove the last reference (this will remove it from the list)
        //
        // ASSERT(MiniBlock->Ref.ReferenceCount == 1);

        //
        // If this is an intermediate driver and wants to be called to do unload handling, allow him
        //
        if (MiniBlock->UnloadHandler != NULL)
        {
            (*MiniBlock->UnloadHandler)(DriverObject);
        }

        if (MiniBlock->AssociatedProtocol != NULL)
        {
            MiniBlock->AssociatedProtocol->AssociatedMiniDriver = NULL;
            MiniBlock->AssociatedProtocol = NULL;
        }
        
        ndisDereferenceDriver(MiniBlock, FALSE);

        //
        // Wait for all adapters to be gonzo.
        //
        //1 this should be replaced by an ASSERT and bugcheck
        WAIT_FOR_OBJECT(&MiniBlock->MiniportsRemovedEvent, NULL);
        RESET_EVENT(&MiniBlock->MiniportsRemovedEvent);

#if TRACK_UNLOAD
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        for (Tmp = ndisMiniDriverList; Tmp != NULL; Tmp = Tmp->NextDriver)
        {
            ASSERT (Tmp != MiniBlock);
            if (Tmp == MiniBlock)
            {
                DbgPrint("NdisMUnload: MiniBlock %p is getting unloaded but it is still on ndisMiniDriverList\n",
                            MiniBlock);
                            

                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0xA,
                            (ULONG_PTR)MiniBlock,
                            (ULONG_PTR)DriverObject,
                            (ULONG_PTR)MiniBlock->Ref.ReferenceCount);

            }
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
#endif

    //
    // check to make sure that the driver has freed all the memory it allocated
    //
    if (MiniBlock == ndisDriverTrackAlloc)
    {
        ASSERT(IsListEmpty(&ndisDriverTrackAllocList));
        ndisDriverTrackAlloc = NULL;
    }

    } while (FALSE);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMUnload: DriverObject %p, MiniBlock %p\n", DriverObject, MiniBlock));
}


/////////////////////////////////////////////////////////////////////
//
//  PLUG-N-PLAY CODE
//
/////////////////////////////////////////////////////////////////////


NDIS_STATUS
FASTCALL
ndisCloseMiniportBindings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Unbind all protocols from this miniport and finally unload it.

Arguments:

    Miniport - The Miniport to unload.

Return Value:

    None.

--*/
{
    KIRQL                   OldIrql;
    PNDIS_OPEN_BLOCK        Open, TmpOpen;
    KEVENT                  CloseCompleteEvent;
    KEVENT                  AllOpensClosedEvent;
    PKEVENT                 pAllOpensClosedEvent;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisCloseMiniportBindings, Miniport %p\n", Miniport));

    PnPReferencePackage();

    //
    // if we have an outstanding queued workitem to initialize the bindings
    // wait for it to fire
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM))
    {
        INITIALIZE_EVENT(&AllOpensClosedEvent);
        Miniport->QueuedBindingCompletedEvent = &AllOpensClosedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->QueuedBindingCompletedEvent)
        WAIT_FOR_OBJECT(&AllOpensClosedEvent, NULL);
    
    Miniport->QueuedBindingCompletedEvent = NULL;
    
    INITIALIZE_EVENT(&AllOpensClosedEvent);
    INITIALIZE_EVENT(&CloseCompleteEvent);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if ((Miniport->OpenQueue != NULL) && (Miniport->AllOpensClosedEvent == NULL))
    {
        Miniport->AllOpensClosedEvent = &AllOpensClosedEvent;
    }

    pAllOpensClosedEvent = Miniport->AllOpensClosedEvent;
    
        
    next:

    //
    // Walk the list of open bindings on this miniport and ask the protocols to
    // unbind from them.
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_PROCESSING)))
        {
            OPEN_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
            if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING))
            {
                OPEN_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_DONT_FREE);
                Open->CloseCompleteEvent = &CloseCompleteEvent;
                RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                break;
            }
#if DBG         
            else
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("ndisCloseMiniportBindings: Open %p is already Closing, Flags %lx\n", 
                    Open, Open->Flags));

            }
#endif
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }

    
    if (Open != NULL)
    {
        PNDIS_PROTOCOL_BLOCK    Protocol = Open->ProtocolHandle;
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        ndisUnbindProtocol(Open, Protocol, Miniport, FALSE);
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        goto next;
    }

    //
    // if we reached the end of the list but there are still some opens
    // that are not marked for closing (can happen if we skip an open only because of
    // processign flag being set) release the spinlocks, give whoever set the
    // processing flag time to release the open. then go back and try again
    // ultimately, all opens should either be marked for Unbinding or be gone
    // by themselves
    //

    for (TmpOpen = Miniport->OpenQueue;
         TmpOpen != NULL;
         TmpOpen = TmpOpen->MiniportNextOpen)
    {
        if (!MINIPORT_TEST_FLAG(TmpOpen, fMINIPORT_OPEN_UNBINDING))
            break;
    }

    if (TmpOpen != NULL)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        
        NDIS_INTERNAL_STALL(50);
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        goto next;
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (pAllOpensClosedEvent)
    {
        WAIT_FOR_OBJECT(pAllOpensClosedEvent, NULL);
    }
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisCloseMiniportBindings, Miniport %p\n", Miniport));
            
    PnPDereferencePackage();

    return NDIS_STATUS_SUCCESS;
}

VOID
NdisMSetPeriodicTimer(
    IN PNDIS_MINIPORT_TIMER     Timer,
    IN UINT                     MillisecondsPeriod
    )
/*++

Routine Description:

    Sets up a periodic timer.

Arguments:

    Timer - The timer to Set.

    MillisecondsPeriod - The timer will fire once every so often.

Return Value:

--*/
{
    LARGE_INTEGER FireUpTime;

    FireUpTime.QuadPart = Int32x32To64((LONG)MillisecondsPeriod, -10000);

    if ((Timer->Dpc.DeferredRoutine != ndisMWakeUpDpc) &&
        (Timer->Dpc.DeferredRoutine != ndisMWakeUpDpcX) &&
        (Timer->Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING))
    {
        KIRQL   OldIrql;
        PNDIS_MINIPORT_TIMER    pTimer;

        ACQUIRE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, &OldIrql);
        
        //
        // check to see if the timer is already set
        //
        for (pTimer = Timer->Miniport->TimerQueue;
             pTimer != NULL;
             pTimer = pTimer->NextTimer)
        {
            if (pTimer == Timer)
                break;
        }
        
        if (pTimer == NULL)
        {
            Timer->NextTimer = Timer->Miniport->TimerQueue;
            Timer->Miniport->TimerQueue = Timer;
        }
        
        RELEASE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, OldIrql);
    }

    //
    // Set the timer
    //
    SET_PERIODIC_TIMER(&Timer->Timer, FireUpTime, MillisecondsPeriod, &Timer->Dpc);
}


VOID
NdisMSleep(
    IN  ULONG                   MicrosecondsToSleep
    )
/*++

    Routine Description:

    Blocks the caller for specified duration of time. Callable at Irql < DISPATCH_LEVEL.

    Arguments:

    MicrosecondsToSleep - The caller will be blocked for this much time.

    Return Value:

    NONE

--*/
{
    KTIMER          SleepTimer;
    LARGE_INTEGER   TimerValue;

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    INITIALIZE_TIMER_EX(&SleepTimer, SynchronizationTimer);
    //1 check for invalid value 0xffffffff or some other upper boundary.
    TimerValue.QuadPart = Int32x32To64(MicrosecondsToSleep, -10);
    SET_TIMER(&SleepTimer, TimerValue, NULL);

    WAIT_FOR_OBJECT(&SleepTimer, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndisnt.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndisnt.h

Abstract:

    Windows NT Specific macros

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Nov-95  Jameel Hyder    Split up from a monolithic file
--*/

#define Increment(a,b) InterlockedIncrement(a)
#define Decrement(a,b) InterlockedDecrement(a)

#define CURRENT_THREAD                          PsGetCurrentThread()
#define CURRENT_PROCESSOR                       KeGetCurrentProcessorNumber()

#define CopyMemory(Destination,Source,Length)   RtlCopyMemory(Destination,Source,Length)
#define MoveMemory(Destination,Source,Length)   RtlMoveMemory(Destination,Source,Length)
#define ZeroMemory(Destination,Length)          RtlZeroMemory(Destination,Length)

#define INITIALIZE_SPIN_LOCK(_L_)               KeInitializeSpinLock(_L_)
#define ACQUIRE_SPIN_LOCK(_SpinLock, _pOldIrql) ExAcquireSpinLock(_SpinLock, _pOldIrql)
#define RELEASE_SPIN_LOCK(_SpinLock, _OldIrql)  ExReleaseSpinLock(_SpinLock, _OldIrql)

#define ACQUIRE_SPIN_LOCK_DPC(_SpinLock)                                    \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExAcquireSpinLockAtDpcLevel(_SpinLock);                             \
    }

#define RELEASE_SPIN_LOCK_DPC(_SpinLock)                                    \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExReleaseSpinLockFromDpcLevel(_SpinLock);                           \
    }


#define NDIS_ACQUIRE_SPIN_LOCK(_SpinLock, _pOldIrql) ExAcquireSpinLock(&(_SpinLock)->SpinLock, _pOldIrql)
#define NDIS_RELEASE_SPIN_LOCK(_SpinLock, _OldIrql)  ExReleaseSpinLock(&(_SpinLock)->SpinLock, _OldIrql)


#define NDIS_ACQUIRE_SPIN_LOCK_DPC(_SpinLock)                               \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);                \
    }

#define NDIS_RELEASE_SPIN_LOCK_DPC(_SpinLock)                               \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock);              \
    }



#define SET_LOCK_DBG(_M)                                                    \
    {                                                                       \
        (_M)->LockDbg = (MODULE_NUMBER + __LINE__);                         \
    }

#define SET_LOCK_DBGX(_M)                                                   \
    {                                                                       \
        (_M)->LockDbgX = (MODULE_NUMBER + __LINE__);                        \
        (_M)->LockThread = CURRENT_THREAD;                                  \
    }

#define CLEAR_LOCK_DBG(_M)                                                  \
    {                                                                       \
        (_M)->LockDbg = 0;                                                  \
    }

#define CLEAR_LOCK_DBGX(_M)                                                 \
    {                                                                       \
        (_M)->LockDbgX = 0;                                                 \
        (_M)->LockThread = NULL;                                            \
    }

#define NDIS_ACQUIRE_COMMON_SPIN_LOCK(_M, _pS, _pIrql, _pT)                 \
{                                                                           \
    ExAcquireSpinLock(_pS, _pIrql);                                         \
    ASSERT((_pT) == NULL);                                                  \
    (_pT) = CURRENT_THREAD;                                                 \
    SET_LOCK_DBG(_M);                                                       \
}

#define NDIS_RELEASE_COMMON_SPIN_LOCK(_M, _pS, _Irql, _pT)                  \
{                                                                           \
    ASSERT(_pT ==  CURRENT_THREAD);                                         \
    _pT =  NULL;                                                            \
    CLEAR_LOCK_DBG(_M);                                                     \
    ExReleaseSpinLock(_pS, _Irql);                                          \
}

#define NDIS_ACQUIRE_COMMON_SPIN_LOCK_DPC(_M, _pS, _pT)                     \
{                                                                           \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                           \
                                                                            \
    ExAcquireSpinLockAtDpcLevel(_pS);                                       \
    ASSERT((_pT) == NULL);                                                  \
    (_pT) = CURRENT_THREAD;                                                 \
    SET_LOCK_DBG(_M);                                                       \
}

#define NDIS_RELEASE_COMMON_SPIN_LOCK_DPC(_M, _pS, _pT)                     \
{                                                                           \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                           \
                                                                            \
    ASSERT(_pT ==  CURRENT_THREAD);                                         \
    _pT =  NULL;                                                            \
    ExReleaseSpinLockFromDpcLevel(_pS);                                     \
    CLEAR_LOCK_DBG(_M);                                                     \
}

#define NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(_M, _pIrql)                         \
    NDIS_ACQUIRE_COMMON_SPIN_LOCK((_M), &(_M)->Lock, (_pIrql), (_M)->MiniportThread)

#define NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _Irql)                          \
    NDIS_RELEASE_COMMON_SPIN_LOCK((_M), &(_M)->Lock, (_Irql), (_M)->MiniportThread)

#define NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M)                             \
    NDIS_ACQUIRE_COMMON_SPIN_LOCK_DPC((_M), &(_M)->Lock, (_M)->MiniportThread)

#define NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M)                             \
    NDIS_RELEASE_COMMON_SPIN_LOCK_DPC(_M, &(_M)->Lock, (_M)->MiniportThread)

//
// Some macros for platform independence
//
#define NDIS_INTERNAL_STALL(_N_)                                            \
    {                                                                       \
        volatile UINT   _cnt;                                               \
        for (_cnt = 0; _cnt < _N_; _cnt++)                                  \
            NOTHING;                                                        \
    }

#define LOCK_MINIPORT(_M, _L)                                               \
    {                                                                       \
        (_L) = 0;                                                           \
        if ((_M)->LockAcquired == 0)                                        \
        {                                                                   \
            (_M)->LockAcquired = 0x01;                                      \
            SET_LOCK_DBGX(_M);                                              \
            (_L) = 0x01;                                                    \
        }                                                                   \
    }

#define BLOCK_LOCK_MINIPORT_DPC_L(_M)                                       \
    {                                                                       \
        do                                                                  \
        {                                                                   \
            if ((_M)->LockAcquired == 0)                                    \
            {                                                               \
                (_M)->LockAcquired = 0x01;                                  \
                SET_LOCK_DBGX(_M);                                          \
                break;                                                      \
            }                                                               \
            else                                                            \
            {                                                               \
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M);                    \
                NDIS_INTERNAL_STALL(50);                                    \
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                    \
            }                                                               \
        } while (TRUE);                                                     \
    }

#define BLOCK_LOCK_MINIPORT_LOCKED(_M, _I)                                  \
    {                                                                       \
        do                                                                  \
        {                                                                   \
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(_M, &(_I));                     \
            if ((_M)->LockAcquired == 0)                                    \
            {                                                               \
                (_M)->LockAcquired = 0x01;                                  \
                SET_LOCK_DBGX(_M);                                          \
                break;                                                      \
            }                                                               \
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _I);                        \
            NDIS_INTERNAL_STALL(50);                                        \
        } while (TRUE);                                                     \
    }
    
#define UNLOCK_MINIPORT(_M, _L)                                             \
{                                                                           \
    if (_L)                                                                 \
    {                                                                       \
        UNLOCK_MINIPORT_L(_M);                                              \
    }                                                                       \
}


#define UNLOCK_MINIPORT_L(_M)                                               \
{                                                                           \
    ASSERT(MINIPORT_LOCK_ACQUIRED(_M));                                     \
    (_M)->LockAcquired = 0;                                                 \
    CLEAR_LOCK_DBGX(_M);                                                    \
}


#define UNLOCK_MINIPORT_U(_M, _I)                                           \
{                                                                           \
    ASSERT(MINIPORT_LOCK_ACQUIRED(_M));                                     \
    (_M)->LockAcquired = 0;                                                 \
    CLEAR_LOCK_DBGX(_M);                                                    \
                                                                            \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _I);                                \
}

#if TRACK_MEMORY

#define ALLOC_FROM_POOL(_Size_, _Tag_)      AllocateM(_Size_,               \
                                                 (MODULE_NUMBER + __LINE__),\
                                                 _Tag_)
#define FREE_POOL(_P_)                      FreeM(_P_)

#else

#define ALLOC_FROM_POOL(_Size_, _Tag_)      ExAllocatePoolWithTag(NonPagedPool, \
                                                                  _Size_,   \
                                                                  _Tag_)
#define FREE_POOL(_P_)                      ExFreePool(_P_)

#endif

#define INITIALIZE_WORK_ITEM(_W, _R, _C)    ExInitializeWorkItem(_W, _R, _C)

#define XQUEUE_WORK_ITEM(_W, _Q)            ExQueueWorkItem(_W, _Q)
#define QUEUE_WORK_ITEM(_W, _Q)             KeInsertQueue(&ndisWorkerQueue, &(_W)->List)

#define CURRENT_IRQL                        KeGetCurrentIrql()
#define RAISE_IRQL_TO_DISPATCH(_pIrql_)     KeRaiseIrql(DISPATCH_LEVEL, _pIrql_)

#define LOWER_IRQL(_OldIrql_, _CurIrql_)                \
{                                                       \
    if (_OldIrql_ != _CurIrql_) KeLowerIrql(_OldIrql_); \
}

#define CURRENT_PROCESSOR                   KeGetCurrentProcessorNumber()

#define INITIALIZE_TIMER(_Timer_)           KeInitializeTimer(_Timer_)
#define INITIALIZE_TIMER_EX(_Timer_,_Type_) KeInitializeTimerEx(_Timer_, _Type_)
#define CANCEL_TIMER(_Timer_)               KeCancelTimer(_Timer_)
#define SET_TIMER(_Timer_, _Time_, _Dpc_)   KeSetTimer(_Timer_, _Time_, _Dpc_)
#define SET_PERIODIC_TIMER(_Timer_, _DueTime_, _PeriodicTime_, _Dpc_)   \
                                            KeSetTimerEx(_Timer_, _DueTime_, _PeriodicTime_, _Dpc_)

#define INITIALIZE_EVENT(_pEvent_)          KeInitializeEvent(_pEvent_, NotificationEvent, FALSE)
#define SET_EVENT(_pEvent_)                 KeSetEvent(_pEvent_, 0, FALSE)
#define RESET_EVENT(_pEvent_)               KeResetEvent(_pEvent_)

#define INITIALIZE_MUTEX(_M_)               KeInitializeMutex(_M_, 0xFFFF)
#define RELEASE_MUTEX(_M_)                  KeReleaseMutex(_M_, FALSE)

#define WAIT_FOR_OBJECT(_O_, _TO_)          KeWaitForSingleObject(_O_,      \
                                                                  Executive,\
                                                                  KernelMode,\
                                                                  FALSE,    \
                                                                  _TO_)     \

#define GET_CURRENT_TICK_IN_SECONDS(_pCurrTick)                             \
    {                                                                       \
        LARGE_INTEGER       _CurrentTick;                                   \
                                                                            \
        KeQueryTickCount(&_CurrentTick);                                    \
        /* Convert to seconds */                                            \
        _CurrentTick.QuadPart = (_CurrentTick.QuadPart*ndisTimeIncrement)/(10*1000*1000);\
        *(_pCurrTick) = _CurrentTick.LowPart;                               \
    }

#define GET_CURRENT_TICK(_pCurrTick)            KeQueryTickCount(_pCurrTick)

#if NOISY_WAIT

#define WAIT_FOR_OBJECT_MSG(_O_, _MSG, _STR)                                \
    {                                                                       \
        NTSTATUS        Status;                                             \
        LARGE_INTEGER   Time;                                               \
                                                                            \
        /* Block 5 seconds */                                               \
        Time.QuadPart = Int32x32To64(5000, -10000);                         \
        do                                                                  \
        {                                                                   \
            Status = KeWaitForSingleObject(_O_,                             \
                                           Executive,                       \
                                           KernelMode,                      \
                                           FALSE,                           \
                                           &Time);                          \
            if (NT_SUCCESS(Status))                                 \
            {                                                               \
                break;                                                      \
            }                                                               \
            DbgPrint(_MSG, _STR);                                           \
        } while (TRUE);                                                     \
    }


#define WAIT_FOR_PROTOCOL(_pProt, _O)                                       \
    {                                                                       \
        WAIT_FOR_OBJECT_MSG(_O,                                             \
                            "NDIS: Waiting for protocol %Z\n",              \
                            &(_pProt)->ProtocolCharacteristics.Name);       \
    }

#define WAIT_FOR_PROTO_MUTEX(_pProt)                                        \
    {                                                                       \
        WAIT_FOR_OBJECT_MSG(&(_pProt)->Mutex,                               \
                            "NDIS: Waiting for protocol %Z\n",              \
                            &(_pProt)->ProtocolCharacteristics.Name);       \
        (_pProt)->MutexOwner = (MODULE_NUMBER + __LINE__);\
    }

#else

#define WAIT_FOR_PROTOCOL(_pProt, _O)                                       \
    {                                                                       \
        WAIT_FOR_OBJECT(_O, NULL);                                          \
    }

#define WAIT_FOR_PROTO_MUTEX(_pProt)                                        \
    {                                                                       \
        WAIT_FOR_OBJECT(&(_pProt)->Mutex, NULL);                            \
        (_pProt)->MutexOwner = (MODULE_NUMBER + __LINE__);                  \
    }

#endif

#define RELEASE_PROT_MUTEX(_pProt)                                          \
    {                                                                       \
            (_pProt)->MutexOwner = 0;                                       \
            RELEASE_MUTEX(&(_pProt)->Mutex);                                \
    }

#define WAIT_FOR_PNP_MUTEX()                                                \
    {                                                                       \
        WAIT_FOR_OBJECT(&ndisPnPMutex, NULL);                               \
        ndisPnPMutexOwner = (MODULE_NUMBER + __LINE__);                     \
    }

#define RELEASE_PNP_MUTEX()                                                 \
    {                                                                       \
        ndisPnPMutexOwner = 0;                                              \
        RELEASE_MUTEX(&ndisPnPMutex);                                       \
    }

#define QUEUE_DPC(_pDpc_)                   KeInsertQueueDpc(_pDpc_, NULL, NULL)
#define INITIALIZE_DPC(_pDpc_, _R_, _C_)    KeInitializeDpc(_pDpc_, _R_, _C_)
#define SET_DPC_IMPORTANCE(_pDpc_)          KeSetImportanceDpc(_pDpc_, LowImportance)
#define SET_PROCESSOR_DPC(_pDpc_, _R_)      if (!ndisSkipProcessorAffinity) \
                                                KeSetTargetProcessorDpc(_pDpc_, _R_)
#define SYNC_WITH_ISR(_O_, _F_, _C_)        KeSynchronizeExecution(_O_,     \
                                            (PKSYNCHRONIZE_ROUTINE)(_F_),   \
                                            _C_)

#define MDL_ADDRESS(_MDL_)                  MmGetSystemAddressForMdl(_MDL_) // Don't use
#define MDL_ADDRESS_SAFE(_MDL_, _PRIORITY_) MmGetSystemAddressForMdlSafe(_MDL_, _PRIORITY_)
#define MDL_SIZE(_MDL_)                     MmGetMdlByteCount(_MDL_)
#define MDL_OFFSET(_MDL_)                   MmGetMdlByteOffset(_MDL_)
#define MDL_VA(_MDL_)                       MmGetMdlVirtualAddress(_MDL_)

#define max(_a, _b)                         (((_a) > (_b)) ? (_a) : (_b))
#define min(_a, _b)                         (((_a) < (_b)) ? (_a) : (_b))
#define NDIS_EQUAL_UNICODE_STRING(s1, s2)   (((s1)->Length == (s2)->Length) &&  \
                                             RtlEqualMemory((s1)->Buffer, (s2)->Buffer, (s1)->Length))

#define NDIS_PARTIAL_MATCH_UNICODE_STRING(s1, s2) \
                                            (((s1)->Length != (s2)->Length) &&  \
                                             RtlEqualMemory((s1)->Buffer, (s2)->Buffer, min((s1)->Length, (s2)->Length)))

#define CHAR_TO_INT(_s, _b, _p)             RtlCharToInteger(_s, _b, _p)


#define BAD_MINIPORT(_M, _S)                DbgPrint(" ***NDIS*** : Miniport %Z - %s\n", (_M)->pAdapterInstanceName, _S)

#define REF_NDIS_DRIVER_OBJECT()            ObfReferenceObject(ndisDriverObject)
#define DEREF_NDIS_DRIVER_OBJECT()          ObfDereferenceObject(ndisDriverObject)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndis.c ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

    ndis.c

Abstract:

    NDIS wrapper functions

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    10-Jul-1995  JameelH Make NDIS.SYS a device-driver and add PnP support

--*/

#include <precomp.h>
#pragma hdrstop

// #include "ndis.tmh"

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS

#define NDIS_DEVICE_NAME    L"\\Device\\Ndis"
#define NDIS_SYMBOLIC_NAME  L"\\Global??\\NDIS"
#define     GET_TEXT_1(_T)      #_T
#define     GET_TEXT(_T)        GET_TEXT_1(_T)

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:

    NDIS wrapper driver entry point.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Pointer to the registry section where the parameters reside.

Return Value:

    Return value from IoCreateDevice

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    UNICODE_STRING      DeviceName;
    UINT                i;
    OBJECT_ATTRIBUTES   ObjectAttr;
    UNICODE_STRING      CallbackObjectName;
    NTSTATUS            NtStatus;
    SYSTEM_BATTERY_STATE ndisSystemBatteryState;
    HANDLE              ThreadHandle;
    BOOLEAN             fDerefCallbackObject = FALSE, fDeregisterCallback = FALSE;

    UNREFERENCED_PARAMETER(RegistryPath);

    
//    WPP_INIT_TRACING(DriverObject, RegistryPath);

//    LOG_INFO("==>Ndis: DriverEntry");
    
    NdisInitializeString(&ndisBuildDate, (PUCHAR)__DATE__);
    NdisInitializeString(&ndisBuildTime, (PUCHAR)__TIME__);
    NdisInitializeString(&ndisBuiltBy, (PUCHAR)GET_TEXT(BUILT_BY));
        
    ndisDriverObject = DriverObject;
    
    //
    //  Create the device object.
    //
    RtlInitUnicodeString(&DeviceName, NDIS_DEVICE_NAME);

    //1  in Longhorn, number of processors may vary during a session
    ndisNumberOfProcessors = KeNumberProcessors;

    Status = IoCreateDevice(DriverObject,               // DriverObject
                            0,                          // DeviceExtension
                            &DeviceName,                // DeviceName
                            FILE_DEVICE_NETWORK,        // DeviceType
                            FILE_DEVICE_SECURE_OPEN,    // DeviceCharacteristics
                            FALSE,                      // Exclusive
                            &ndisDeviceObject);         // DeviceObject
        
    if (NT_SUCCESS(Status))
    {
        UNICODE_STRING  SymbolicLinkName;
    
        // Create a symbolic link to this device
        RtlInitUnicodeString(&SymbolicLinkName, NDIS_SYMBOLIC_NAME);
        Status = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);

        ndisDeviceObject->Flags |= DO_DIRECT_IO;
    
        // Initialize the driver object for this file system driver.
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverObject->MajorFunction[i] = ndisDispatchRequest;
        }

        //
        // create a security descriptor for NDIS device object
        //
        Status = ndisCreateSecurityDescriptor(ndisDeviceObject, 
                                              &ndisSecurityDescriptor,
                                              TRUE,
                                              TRUE);

        //1 check for status
        Status = CreateDeviceDriverSecurityDescriptor(DriverObject, TRUE, NULL);
        Status = CreateDeviceDriverSecurityDescriptor(DriverObject->DeviceObject, TRUE, NULL);
        Status = CreateDeviceDriverSecurityDescriptor(ndisDeviceObject, TRUE, NULL);



        //
        // disable for now
        //
#if NDIS_UNLOAD        
        DriverObject->DriverUnload = ndisUnload;
#else
        DriverObject->DriverUnload = NULL;
#endif

        INITIALIZE_SPIN_LOCK(&ndisGlobalLock);
        INITIALIZE_SPIN_LOCK(&ndisMiniDriverListLock);
        INITIALIZE_SPIN_LOCK(&ndisProtocolListLock);
        INITIALIZE_SPIN_LOCK(&ndisMiniportListLock);
        INITIALIZE_SPIN_LOCK(&ndisGlobalPacketPoolListLock);
        INITIALIZE_SPIN_LOCK(&ndisGlobalOpenListLock);

        ndisDmaAlignment = HalGetDmaAlignmentRequirement();
        if (sizeof(ULONG) > ndisDmaAlignment)
        {
            ndisDmaAlignment = sizeof(ULONG);
        }
        ndisTimeIncrement = KeQueryTimeIncrement();
    
        //
        // Get handles for all conditionally lockable sections
        //
        for (i = 0; i < MAX_PKG; i++)
        {
            ndisInitializePackage(&ndisPkgs[i]);
        }

        ExInitializeResourceLite(&SharedMemoryResource);
    
        ndisReadRegistry();
        //
        // don't let use set this bit through registry
        //
        ndisFlags &= ~NDIS_GFLAG_TRACK_MEM_ALLOCATION;
        
        Status = STATUS_SUCCESS;
        ndisSystemProcess = NtCurrentProcess();

        //
        // Now create a worker thread for use by NDIS
        // This is so that when we queue PnP events upto transports
        // and they need worker threads as well ...
        //
        KeInitializeQueue(&ndisWorkerQueue, 0);
        Status = PsCreateSystemThread(&ThreadHandle,
                                      THREAD_ALL_ACCESS,
                                      NULL,
                                      NtCurrentProcess(),
                                      NULL,
                                      ndisWorkerThread,
                                      NULL);

        
        if (!NT_SUCCESS(Status))
        {
            //1 do more error processing here
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DriverEntry: Cannot create worker thread, Status %lx\n", Status));
        }
        else
        {
            NtClose(ThreadHandle);
        }
        
    }
    KeQuerySystemTime(&KeBootTime);

    ConvertSecondsToTicks(POOL_AGING_TIME, &PoolAgingTicks);

    //
    // verifir intialization. in case ndis tester wants to verify
    // the drivers by intercepting ndis entry points, ndis should
    // not verify the calls
    //
    if (!(ndisFlags & NDIS_GFLAG_DONT_VERIFY))
        ndisVerifierInitialization();
    
#if DBG
    if (ndisDebugBreakPoint)
    {
        DbgPrint("Ndis: DriverEntry\n");
        DbgBreakPoint();
    }
#endif

#ifdef TRACK_MOPEN_REFCOUNTS
    NdisZeroMemory (&ndisLogfile, sizeof(UINT) * NDIS_LOGFILE_SIZE);
#endif

#ifdef TRACK_MINIPORT_REFCOUNTS
    NdisZeroMemory (&ndisMiniportLogfile, sizeof(UINT) * NDIS_MINIPORT_LOGFILE_SIZE);
#endif

#ifdef NDIS_LOG_ABORTED_REQUESTS
    for (i = 0; i < 16; i++)
    {
        NdisZeroMemory (&ndisAbortedRequests[i], sizeof (NDIS_REQUEST));
    }
#endif

    //
    // create a callback options for those kernel mode components that like
    // to hear about Bind/Unbind events
    //

    RtlInitUnicodeString(&CallbackObjectName, NDIS_BIND_UNBIND_CALLBACK_NAME);

    InitializeObjectAttributes(&ObjectAttr,
                               &CallbackObjectName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
                               
    NtStatus = ExCreateCallback(&ndisBindUnbindCallbackObject,
                              &ObjectAttr,
                              TRUE,             // create
                              TRUE);            // allow multiple callback registeration

    
    if (!NT_SUCCESS(NtStatus))
    {

        DbgPrint("Ndis: failed to create a Callback object. Status %lx\n", NtStatus);
    }
    
#if 0
    else
    {

        //
        // for test purpose
        //
        ndisBindUnbindCallbackRegisterationHandle = ExRegisterCallback(ndisBindUnbindCallbackObject,
                                                             ndisBindUnbindCallback,
                                                             (PVOID)NULL);


        if (ndisBindUnbindCallbackRegisterationHandle == NULL)
        {
            DbgPrint("Ndis: failed to register a BindUnbind callback routine\n");
        }
    }
#endif

    //
    // register a notification callback for power state changes
    //

    RtlInitUnicodeString(&CallbackObjectName, L"\\CallBack\\PowerState");

    InitializeObjectAttributes(&ObjectAttr,
                               &CallbackObjectName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
                                   
    NtStatus = ExCreateCallback(&ndisPowerStateCallbackObject,
                                &ObjectAttr,
                                FALSE,
                                TRUE);
                                
    if (!NT_SUCCESS(Status))
    {

        DbgPrint("Ndis: failed to create a Callback object. Status %lx\n", NtStatus);
    }
    else
    {
        fDerefCallbackObject = TRUE;
        ndisPowerStateCallbackHandle = ExRegisterCallback(ndisPowerStateCallbackObject,
                                                          (PCALLBACK_FUNCTION)&ndisPowerStateCallback,
                                                          (PVOID)NULL);

        if (ndisPowerStateCallbackHandle == NULL)
        {
            DbgPrint("Ndis: failed to register a power state Callback routine\n");
        }
        else
        {
            fDeregisterCallback = TRUE;
        }

        RtlZeroMemory(&ndisSystemBatteryState, sizeof(SYSTEM_BATTERY_STATE));
        //
        // get the current power source
        //
        NtStatus = ZwPowerInformation(SystemBatteryState,
                                      NULL,
                                      0,
                                      &ndisSystemBatteryState,
                                      sizeof(SYSTEM_BATTERY_STATE));

        if (NT_SUCCESS(NtStatus))
        {
            ndisAcOnLine = (ndisSystemBatteryState.AcOnLine == TRUE) ? 1 : 0;
        }
           
        fDerefCallbackObject = FALSE;
        fDeregisterCallback = FALSE;    
    }

    InitializeListHead(&ndisGlobalPacketPoolList);
    
    if (fDeregisterCallback)
    {
        ExUnregisterCallback(ndisPowerStateCallbackHandle);
    }

    if (fDerefCallbackObject)
    {
        ObDereferenceObject(ndisPowerStateCallbackObject);

    }

    INITIALIZE_MUTEX(&ndisPnPMutex);

    
    //
    // create an ACL for all users
    //
    AllUsersAclRead = ndisCreateAcl(TRUE,       // Admins
                                TRUE,           //LocalSystem
                                TRUE,           //LocalService
                                TRUE,           //NetworkService
                                TRUE,           //NetConfigOps
                                TRUE,           //Users
                                GENERIC_READ | WMIGUID_QUERY
                                );

    ASSERT(AllUsersAclRead != NULL);
    
    AllUsersAclWrite = ndisCreateAcl(TRUE,      // Admins
                                TRUE,           //LocalSystem
                                TRUE,           //LocalService
                                TRUE,           //NetworkService
                                TRUE,           //NetConfigOps
                                TRUE,           //Users
                                GENERIC_WRITE | WMIGUID_SET
                                );

    ASSERT(AllUsersAclWrite != NULL);

    AllUsersAclReadWrite = ndisCreateAcl(TRUE,  // Admins
                                TRUE,           //LocalSystem
                                TRUE,           //LocalService
                                TRUE,           //NetworkService
                                TRUE,           //NetConfigOps
                                TRUE,           //Users
                                GENERIC_READ | GENERIC_WRITE | WMIGUID_QUERY | WMIGUID_SET
                                );
    ASSERT(AllUsersAclReadWrite != NULL);

    AllUsersAclNotification = ndisCreateAcl(TRUE,  // Admins
                                TRUE,           //LocalSystem
                                TRUE,           //LocalService
                                TRUE,           //NetworkService
                                TRUE,           //NetConfigOps
                                TRUE,           //Users
                                SYNCHRONIZE | WMIGUID_NOTIFICATION
                                );
                                

    ASSERT(AllUsersAclNotification != NULL);


    //
    // create an ACL for admin types
    //
    AdminsAcl = ndisCreateAcl(TRUE,         // Admins
                              TRUE,         //LocalSystem
                              TRUE,         //LocalService
                              TRUE,         //NetworkService
                              TRUE,         //NetConfigOps
                              FALSE,        //Users
                              GENERIC_READ | GENERIC_WRITE | WMIGUID_QUERY | WMIGUID_SET
                              );

    ASSERT(AdminsAcl != NULL);

    //
    // Create an SD for All Users
    //
    Status = ndisCreateGenericSD(AllUsersAclRead, AllUsersReadSecurityDescriptor);
    ASSERT(NT_SUCCESS(Status));

    Status = ndisCreateGenericSD(AllUsersAclWrite, AllUsersWriteSecurityDescriptor);
    ASSERT(NT_SUCCESS(Status));

    Status = ndisCreateGenericSD(AllUsersAclReadWrite, AllUsersReadWriteSecurityDescriptor);
    ASSERT(NT_SUCCESS(Status));

    Status = ndisCreateGenericSD(AllUsersAclNotification, AllUsersNotificationSecurityDescriptor);
    ASSERT(NT_SUCCESS(Status));

    Status = ndisCreateGenericSD(AdminsAcl, AdminsSecurityDescriptor);
    ASSERT(NT_SUCCESS(Status));

/*

    //
    // set the security descriptor for all known guids
    //
    for (i = 0; i < sizeof(ndisSupportedGuids)/sizeof(NDIS_GUID); i++)
    {
        Status = ndisSetWmiSecurity(&ndisSupportedGuids[i]);
        if (NT_SUCCESS(Status))
        {
            DbgPrint("Successfully added ndisSupportedGuids[%ld].\n", i);
        }
        else
        {
            DbgPrint("setting security failed for %ld\n.", i);
        }
    }
    for (i = 0; i < sizeof(ndisCoSupportedGuids)/sizeof(NDIS_GUID); i++)
    {
        Status = ndisSetWmiSecurity(&ndisCoSupportedGuids[i]);
        if (NT_SUCCESS(Status))
        {
            DbgPrint("Successfully added ndisCoSupportedGuids[%ld].\n", i);
        }
        else
        {
            DbgPrint("setting security failed for ndisCoSupportedGuids[%ld].\n", i);
        }
    }
    for (i = 0; i < sizeof(ndisMediaSupportedGuids)/sizeof(NDIS_GUID); i++)
    {
        Status = ndisSetWmiSecurity(&ndisMediaSupportedGuids[i]);
        if (NT_SUCCESS(Status))
        {
            DbgPrint("Successfully added ndisMediaSupportedGuids[%ld].\n", i);
        }
        else
        {
            DbgPrint("setting security failed for ndisMediaSupportedGuids[%ld].\n", i);
        }
    }
    for (i = 0; i < sizeof(ndisStatusSupportedGuids)/sizeof(NDIS_GUID); i++)
    {
        Status = ndisSetWmiSecurity(&ndisStatusSupportedGuids[i]);
        if (NT_SUCCESS(Status))
        {
            DbgPrint("Successfully added ndisStatusSupportedGuids[%ld].\n", i);
        }
        else
        {
            DbgPrint("setting security failed for ndisStatusSupportedGuids[%ld].\n", i);
        }
    }

*/
    
    return Status;
}


#if NDIS_UNLOAD
VOID
ndisUnload(
    IN  PDRIVER_OBJECT      DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the Appletalk driver.

    NOTE: Unload will not be called until all the handles have been
          closed successfully. We just shutdown all the ports, and do
          misc. cleanup.


Arguments:

    DriverObject - Pointer to driver object for this driver.

Return Value:

    None.

--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  SymbolicLinkName;
    UINT            i;

    NdisFreeString(ndisBuildDate);
    NdisFreeString(ndisBuildTime);
    NdisFreeString(ndisBuiltBy);

    if (ndisPowerStateCallbackHandle)
    {
        ExUnregisterCallback(ndisPowerStateCallbackHandle);
    }

    if (ndisPowerStateCallbackObject)
    {
        ObDereferenceObject(ndisPowerStateCallbackObject);
    }

    ExDeleteResourceLite(&SharedMemoryResource);


    //
    // Tell the ndisWorkerThread to quit
    //
    INITIALIZE_WORK_ITEM(&ndisPoisonPill, NULL, &ndisPoisonPill);
    QUEUE_WORK_ITEM(&ndisPoisonPill, CriticalWorkQueue);
    WAIT_FOR_OBJECT(ndisThreadObject, 0);
    ObDereferenceObject(ndisThreadObject);

    RtlInitUnicodeString(&SymbolicLinkName, NDIS_SYMBOLIC_NAME);
    Status = IoDeleteSymbolicLink(&SymbolicLinkName);
    ASSERT(NT_SUCCESS(Status));
    IoDeleteDevice(ndisDeviceObject);

    //
    // ASSERT that all the packages are unlocked
    //
    for (i = 0; i < MAX_PKG; i++)
    {
        ASSERT(ndisPkgs[i].ReferenceCount == 0);
    }
}
#endif

VOID
ndisReadRegistry(
    VOID
    )
{
    RTL_QUERY_REGISTRY_TABLE    QueryTable[8];
    UCHAR                       c;
    ULONG                       DefaultZero = 0;

    //
    //  First we need to initialize the processor information incase
    //  the registry is empty.
    //
    for (c = 0; (c < NDIS_MAX_CPU_COUNT) && (c < ndisNumberOfProcessors) ; c++)
    {
        ndisValidProcessors[c] = c;
    }

    ndisCurrentProcessor = ndisMaximumProcessor = c - 1;

    //
    // 1) Switch to the MediaTypes key below the service (NDIS) key
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = L"MediaTypes";

    //
    // Setup to enumerate the values in the registry section (shown above).
    // For each such value, we'll add it to the ndisMediumArray
    //
    QueryTable[1].QueryRoutine = ndisAddMediaTypeToArray;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = (PVOID)&DefaultZero;
    QueryTable[1].DefaultLength = 0;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[1].Name = NULL;

    //
    // Query terminator
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    //
    // The rest of the work is done in the callback routine ndisAddMediaTypeToArray.
    //
    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"NDIS",
                           QueryTable,
                           (PVOID)NULL,   // no context needed
                           NULL);
    //
    //  Switch to the parameters key below the service (NDIS) key and
    //  read the parameters.
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = L"Parameters";

    //
    //  Read in the processor affinity mask.
    //
    QueryTable[1].QueryRoutine = ndisReadProcessorAffinityMask;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[1].DefaultData = (PVOID)&DefaultZero;
    QueryTable[1].DefaultLength = 0;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].Name = L"ProcessorAffinityMask";

    QueryTable[2].QueryRoutine = ndisReadRegParameters;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[2].DefaultData = (PVOID)&ndisFlags;
    QueryTable[2].DefaultLength = 0;
    QueryTable[2].DefaultType = REG_DWORD;
    QueryTable[2].Name = L"Flags";
    QueryTable[2].EntryContext = (PVOID)&ndisFlags;

    
    //1 check for an upper bound on # of stack locations.
    QueryTable[3].QueryRoutine = ndisReadRegParameters;
    QueryTable[3].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[3].DefaultData = (PVOID)&ndisPacketStackSize;
    QueryTable[3].DefaultLength = 0;
    QueryTable[3].DefaultType = REG_DWORD;
    QueryTable[3].Name = L"PacketStackSize";
    QueryTable[3].EntryContext = (PVOID)&ndisPacketStackSize;

    //
    // Query terminator
    //
    QueryTable[4].QueryRoutine = NULL;
    QueryTable[4].Flags = 0;
    QueryTable[4].Name = NULL;

#if DBG
#ifdef NDIS_TRACE
    ndisDebugBreakPoint = 1;
    ndisDebugLevel = 0;
    ndisDebugSystems = 0x3003;
#else
    QueryTable[4].QueryRoutine = ndisReadRegParameters;
    QueryTable[4].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[4].Name = L"DebugBreakPoint";
    QueryTable[4].DefaultData = (PVOID)&ndisDebugBreakPoint;
    QueryTable[4].DefaultLength = 0;
    QueryTable[4].EntryContext = (PVOID)&ndisDebugBreakPoint;
    QueryTable[4].DefaultType = REG_DWORD;
    
    QueryTable[5].QueryRoutine = ndisReadRegParameters;
    QueryTable[5].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[5].Name = L"DebugLevel";
    QueryTable[5].DefaultData = (PVOID)&ndisDebugLevel;
    QueryTable[5].DefaultLength = 0;
    QueryTable[5].EntryContext = (PVOID)&ndisDebugLevel;
    QueryTable[5].DefaultType = REG_DWORD;
    
    QueryTable[6].QueryRoutine = ndisReadRegParameters;
    QueryTable[6].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[6].Name = L"DebugSystems";
    QueryTable[6].DefaultData = (PVOID)&ndisDebugSystems;
    QueryTable[6].DefaultLength = 0;
    QueryTable[6].EntryContext = (PVOID)&ndisDebugSystems;
    QueryTable[6].DefaultType = REG_DWORD;

    //
    // Query terminator
    //
    QueryTable[7].QueryRoutine = NULL;
    QueryTable[7].Flags = 0;
    QueryTable[7].Name = NULL;
#endif
#endif

    //
    // The rest of the work is done in the callback routines
    //
    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"NDIS",
                           QueryTable,
                           (PVOID)NULL,   // no context needed
                           NULL);

    //
    // Make sure ndisPacketStackSize isn't zero
    //
    if (ndisPacketStackSize == 0)
        ndisPacketStackSize = 1;
}

NTSTATUS
ndisReadRegParameters(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++


Arguments:

    ValueName - The name of the value

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Unused.

    EntryContext - A pointer to the pointer that holds the copied data.

Return Value:

    STATUS_SUCCESS

--*/
{
    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Context);

    if ((ValueType != REG_DWORD) || (ValueData == NULL))
        return STATUS_UNSUCCESSFUL;

    *((PULONG)EntryContext) = *((PULONG)ValueData);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ndisReadProcessorAffinityMask(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(EntryContext);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(ValueName);

    //
    //  If we have valid data then build our array of valid processors
    //  to use.... Treat the special case of 0 or default -1 to signify 
    //  that DPC affinity will follow interrupt affinity
    //
    if ((REG_DWORD == ValueType) && (ValueData != NULL))
    {
        if ((*(PULONG)ValueData == 0) ||
            (*(PULONG)ValueData == 0xFFFFFFFF))
        {
            ndisSkipProcessorAffinity = TRUE;
        }
        
        else
        {
            ULONG   ProcessorAffinity;
            UCHAR   c1, c2;
    
            //
            //  Save the processor affinity.
            //
            ProcessorAffinity = *(PULONG)ValueData;
    
            //
            //  Fill in the valid processor array.
            //
            for (c1 = c2 = 0;
                 (c1 <= ndisMaximumProcessor) && (ProcessorAffinity != 0);
                 c1++)
            {
                if (ProcessorAffinity & 1)
                {
                    ndisValidProcessors[c2++] = c1;
                }
                ProcessorAffinity >>= 1;
            }
    
            ndisCurrentProcessor = ndisMaximumProcessor = c2 - 1;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ndisAddMediaTypeToArray(
    IN PWSTR        ValueName,
    IN ULONG        ValueType,
    IN PVOID        ValueData,
    IN ULONG        ValueLength,
    IN PVOID        Context,
    IN PVOID        EntryContext
    )
{
#if DBG
    NDIS_STRING Str;

    RtlInitUnicodeString(&Str, ValueName);
#else
    UNREFERENCED_PARAMETER(ValueName);
#endif
    UNREFERENCED_PARAMETER(EntryContext);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(ValueLength);

    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("ExperimentalMediaType %Z - %x\n", &Str, *(PULONG)ValueData));

    //
    // Ignore all values that we already know about. These should not be in the
    // registry anyway, but just in case somebody is messing with it.
    //
    if ((ValueType == REG_DWORD) && (ValueData != NULL) && (*(PULONG)ValueData > NdisMediumIrda))
    {
        NDIS_MEDIUM *pTemp;
        ULONG       size;

        //
        // See if we have enough space to add this value. If not allocate space for the
        // new array, copy the old one into this (and free the old if not static).
        //
        ASSERT (ndisMediumArraySize <= ndisMediumArrayMaxSize);

        //
        // Check for duplicates. If so drop it
        //
        for (pTemp = ndisMediumArray, size = ndisMediumArraySize;
             size > 0; pTemp ++, size -= sizeof(NDIS_MEDIUM))
        {
            if (*(NDIS_MEDIUM *)ValueData == *pTemp)
            {
                //
                // Duplicate.
                //
                return STATUS_SUCCESS;
            }
        }

        if (ndisMediumArraySize == ndisMediumArrayMaxSize)
        {
            //
            // We do not have any space in the array. Need to re-alloc. Be generous.
            //
            pTemp = (NDIS_MEDIUM *)ALLOC_FROM_POOL(ndisMediumArraySize + EXPERIMENTAL_SIZE*sizeof(NDIS_MEDIUM),
                                                   NDIS_TAG_MEDIA_TYPE_ARRAY);
            if (pTemp != NULL)
            {
                CopyMemory(pTemp, ndisMediumArray, ndisMediumArraySize);
                if (ndisMediumArray != ndisMediumBuffer)
                {
                    FREE_POOL(ndisMediumArray);
                }
                ndisMediumArray = pTemp;
            }
        }
        if (ndisMediumArraySize < ndisMediumArrayMaxSize)
        {
            ndisMediumArray[ndisMediumArraySize/sizeof(NDIS_MEDIUM)] = *(NDIS_MEDIUM *)ValueData;
            ndisMediumArraySize += sizeof(NDIS_MEDIUM);
        }
    }

    return STATUS_SUCCESS;
}


VOID
ndisWorkerThread(
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOLEAN             FirstThread = (Context == NULL);
    PLIST_ENTRY         pList;
    HANDLE              ThreadHandle;
    PWORK_QUEUE_ITEM    pWI;
    NTSTATUS            Status;
    
    if (FirstThread)
    {
        ndisThreadObject = PsGetCurrentThread();
        ObReferenceObject(ndisThreadObject);
        
        do
        {
            //
            // Block here waiting for work-items to do
            //
            pList = KeRemoveQueue(&ndisWorkerQueue, KernelMode, NULL);
    
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("ndisWorkerThread: WorkItem %p\n", pList));
    
            pWI = CONTAINING_RECORD(pList, WORK_QUEUE_ITEM, List);
    
#if NDIS_UNLOAD        
            //
            // Unload asking us to quit, comply.
            //
            if (pWI == &ndisPoisonPill)
            {
                break;
            }
#endif

            Status = PsCreateSystemThread(&ThreadHandle,
                                          THREAD_ALL_ACCESS,
                                          NULL,
                                          NtCurrentProcess(),
                                          NULL,
                                          ndisWorkerThread,
                                          pWI);
            if (NT_SUCCESS(Status))
            {
                NtClose(ThreadHandle);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                        ("ndisWorkerThread: Failed to create a thread, using EX worker thread\n"));
                XQUEUE_WORK_ITEM(pWI, CriticalWorkQueue);
                ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
            }
        } while (TRUE);
    }
    else
    {
        //
        // Not the main thread, just do the thing and die.
        //
        LastWorkerThreadWI = *((PWORK_QUEUE_ITEM)Context);
        pWI = (PWORK_QUEUE_ITEM)Context;

        (*pWI->WorkerRoutine)(pWI->Parameter);
        ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    }
}

NTSTATUS
ndisDispatchRequest(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Description:

    Dispatcher for Irps intended for the NDIS Device.

Arguments:


Return Value:


--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  pIrpSp;
    PNDIS_DEVICE_OBJECT_OPEN_CONTEXT OpenContext = NULL;
    NTSTATUS            SecurityStatus;
    static LONG         OpenCount = 0;

    UNREFERENCED_PARAMETER(pDeviceObject);

    PAGED_CODE( );

#if defined(_WIN64)    
    if (IoIs32bitProcess(pIrp))
    {
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    PnPReferencePackage();

    switch (pIrpSp->MajorFunction)
    {
      case IRP_MJ_CREATE:

        OpenContext = (PNDIS_DEVICE_OBJECT_OPEN_CONTEXT)ALLOC_FROM_POOL(sizeof(NDIS_DEVICE_OBJECT_OPEN_CONTEXT),
                                                               NDIS_TAG_OPEN_CONTEXT);

        if (OpenContext == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        ZeroMemory(OpenContext, sizeof(NDIS_DEVICE_OBJECT_OPEN_CONTEXT));

        OpenContext->AdminAccessAllowed = ndisCheckAccess(pIrp, 
                                                          pIrpSp, 
                                                          &SecurityStatus, 
                                                          ndisSecurityDescriptor);
        //
        // save the caller's access right
        //
        pIrpSp->FileObject->FsContext = OpenContext;
        Increment(&OpenCount, &Lock);        
        break;

      case IRP_MJ_CLEANUP:
        OpenContext = pIrpSp->FileObject->FsContext;
        ASSERT(OpenContext != NULL);
        pIrpSp->FileObject->FsContext = NULL;
        FREE_POOL(OpenContext);
        Decrement(&OpenCount, &Lock);
        break;

      case IRP_MJ_CLOSE:
        break;

      case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        break;

      case IRP_MJ_DEVICE_CONTROL:
        Status =  ndisHandlePnPRequest(pIrp);
        break;

      default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);
    ASSERT (Status != STATUS_PENDING);

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    PnPDereferencePackage();

    return Status;
}

NTSTATUS
ndispConvOffsetToPointer(
    IN     PVOID      MasterBuffer,
    IN     ULONG      MasterLength,
    IN OUT PULONG_PTR Offset,
    IN     ULONG      Length,
    IN     ULONG      Alignment
    )

/*++

Routine Description:

    This function validates a buffer within an IOCTL and converts a buffer
    offset to a pointer.

Argumens:

    MasterBuffer - Pointer to the start of the IOCTL buffer

    MasterLength - Length of the IOCTL buffer

    Offset - Offset of the data buffer within the IOCTL buffer

    Length - Length of the data buffer within the IOCTL buffer

    Alignment - Required alignment of the type within the data buffer

Return Value:

    The function status is the final status of the operation.

--*/

{
    ULONG_PTR masterStart;
    ULONG_PTR masterEnd;
    ULONG_PTR bufStart;
    ULONG_PTR bufEnd;

    if (Length == 0)
    {

        //
        // Nothing to do.
        //

        return STATUS_SUCCESS;
    }

    masterStart = (ULONG_PTR)MasterBuffer;
    masterEnd = masterStart + MasterLength;
    bufStart = masterStart + *Offset;
    bufEnd = bufStart + Length;

    //
    // Ensure that neither of the buffers wrap
    //

    if (masterEnd < masterStart || bufEnd < bufStart)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ensure that buf is wholly contained within master
    //

    if (bufStart < masterStart || bufEnd > masterEnd)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure that buf is properly aligned
    //

    if ((bufStart & (Alignment - 1)) != 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Everything looks good, perform the conversion
    //

    *Offset += masterStart;
    return STATUS_SUCCESS;
}

NTSTATUS
ndispConvVar(
    IN     PVOID MasterBuffer,
    IN     ULONG MasterLength,
    IN OUT PNDIS_VAR_DATA_DESC Var
    )

/*++

Routine Description:

    This function validates an NDIS_VAR_DATA_DESC buffer within an IOCTL
    and converts its data offset to a pointer.

Argumens:

    MasterBuffer - Pointer to the start of the IOCTL buffer

    MasterLength - Length of the IOCTL buffer

    Var - Pointer to an NDIS_VAR_DATA_DESC structure.

Return Value:

    The function status is the final status of the operation.

--*/

{
    return ndispConvOffsetToPointer( MasterBuffer,
                                     MasterLength,
                                     &Var->Offset,
                                     Var->Length,
                                     sizeof(WCHAR) );
}

NTSTATUS
FASTCALL
ndisHandlePnPRequest(
    IN  PIRP        pIrp
    )
/*++

Routine Description:

    Handler for PnP ioctls.

Arguments:

Return Value:

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PNDIS_DEVICE_OBJECT_OPEN_CONTEXT OpenContext;
    PNDIS_PNP_OPERATION PnPOp;
    PNDIS_ENUM_INTF     EnumIntf;
    PIO_STACK_LOCATION  pIrpSp;
    UNICODE_STRING      Device;
    ULONG               Method;
    PVOID               pBuf;
    UINT                iBufLen, oBufLen;
    UINT                OutputLength = 0;
    BOOLEAN             AdminAccessAllowed = FALSE;

    PAGED_CODE( );

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);


    OpenContext = pIrpSp->FileObject->FsContext;
    if (OpenContext == NULL)
    {
        return STATUS_NO_SUCH_FILE;
    }
    AdminAccessAllowed = OpenContext->AdminAccessAllowed;

    Method = pIrpSp->Parameters.DeviceIoControl.IoControlCode & 3;

    // Ensure that the method is buffered - we always use that.
    if (Method == METHOD_BUFFERED)
    {
        // Get the output buffer and its length. Input and Output buffers are
        // both pointed to by the SystemBuffer
        iBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
        oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        pBuf = pIrp->AssociatedIrp.SystemBuffer;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_NDIS_ADD_TDI_DEVICE:
        if (!AdminAccessAllowed)
        {
            return STATUS_ACCESS_DENIED;
            
        }
        //
        // Validate the DeviceName
        //
        Status = STATUS_INVALID_PARAMETER;
        if ((iBufLen > 0) && ((iBufLen % sizeof(WCHAR)) == 0))
        {
            ((PWCHAR)pBuf)[iBufLen/sizeof(WCHAR) - 1] = 0;
            RtlInitUnicodeString(&Device, pBuf);
            Status = ndisHandleLegacyTransport(&Device);
        }
        break;
    
      case IOCTL_NDIS_DO_PNP_OPERATION:
        if (!AdminAccessAllowed)
        {
            return STATUS_ACCESS_DENIED;
            
        }
        Status = STATUS_BUFFER_TOO_SMALL;
        PnPOp = (PNDIS_PNP_OPERATION)pBuf;
        
        //
        // check to make sure the input buffer is big enough to
        // have all the information that NDIS_PNP_OPERATION structure
        // claims to contain.
        //
        if ((iBufLen < sizeof(NDIS_PNP_OPERATION)) ||
            (iBufLen < (sizeof(NDIS_PNP_OPERATION) +
                        PnPOp->LowerComponent.MaximumLength +
                        PnPOp->UpperComponent.MaximumLength +
                        PnPOp->ReConfigBufferSize +
                        PnPOp->BindList.MaximumLength
                        )))
        {
            break;
        }

        //
        // Convert the four buffer offsets within NDIS_PNP_OPERATION
        // to pointers.
        //

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->LowerComponent );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->UpperComponent );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->BindList );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvOffsetToPointer( PnPOp,
                                        iBufLen,
                                        &PnPOp->ReConfigBufferOff,
                                        PnPOp->ReConfigBufferSize,
                                        sizeof(ULONG_PTR) );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndisHandleUModePnPOp(PnPOp);

        break;

      case IOCTL_NDIS_ENUMERATE_INTERFACES:
        if (oBufLen >= sizeof(NDIS_ENUM_INTF))
        {
            EnumIntf = (PNDIS_ENUM_INTF)pBuf;
            Status = ndisEnumerateInterfaces(pBuf, oBufLen, &OutputLength);
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }        
        pIrp->IoStatus.Information = OutputLength;

        break;
        
      case IOCTL_NDIS_GET_VERSION:
        if (oBufLen < sizeof(UINT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            *((PUINT)pBuf) = NdisGetVersion();
            OutputLength = sizeof(UINT);
            if (oBufLen >= 2 * sizeof(UINT))
            {
                *((PUINT)pBuf + 1) = (UINT)ndisChecked;
                OutputLength += sizeof(UINT);
            }
            Status = STATUS_SUCCESS; 
        }
        pIrp->IoStatus.Information = OutputLength;
        break;

      default:
        break;
    }

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

    return Status;
}


NTSTATUS
FASTCALL
ndisHandleUModePnPOp(
    IN  PNDIS_PNP_OPERATION         PnPOp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        Status;
    PUNICODE_STRING Protocol, Device, BindList;

    WAIT_FOR_OBJECT(&ndisPnPMutex, NULL);
    ndisPnPMutexOwner = MODULE_NUMBER + __LINE__;
    
    //
    // Upcase the protocol and device names
    //
    Protocol = (PUNICODE_STRING)&PnPOp->UpperComponent;
    Device = (PUNICODE_STRING)&PnPOp->LowerComponent;
    BindList = (PUNICODE_STRING)&PnPOp->BindList;

    if (PnPOp->Operation == BIND)
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("BIND  (%s) %Z to %Z\n",  (PnPOp->Layer == NDIS) ? "NDIS" : "TDI ", Protocol, Device));
    }
    else if (PnPOp->Operation == UNBIND)
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("UNBIND(%s) %Z to %Z\n",  (PnPOp->Layer == NDIS) ? "NDIS" : "TDI ", Protocol, Device));
    }
    switch (PnPOp->Layer)
    {
      case TDI:
        //
        // Call into the TDI handler to do this
        //
        if (ndisTdiPnPHandler != NULL)
        {
            Status = (*ndisTdiPnPHandler)(Protocol,
                                          Device,
                                          BindList,
                                          PnPOp->ReConfigBufferPtr,
                                          PnPOp->ReConfigBufferSize,
                                          PnPOp->Operation);
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

      case NDIS:
        switch (PnPOp->Operation)
        {
          case BIND:
            Status = ndisHandleProtocolBindNotification(Device, Protocol);
            break;

          case UNBIND:
            Status = ndisHandleProtocolUnbindNotification(Device, Protocol);
            break;

          case RECONFIGURE:
          case BIND_LIST:
            //1 for BIND_LIST, validate the buffer to have the correct format
            Status = ndisHandleProtocolReconfigNotification(Device,
                                                            Protocol,
                                                            PnPOp->ReConfigBufferPtr,
                                                            PnPOp->ReConfigBufferSize,
                                                            PnPOp->Operation);
            break;

          case UNLOAD:
            Status = ndisHandleProtocolUnloadNotification(Protocol);
            break;

          //1 check to see when this is called
          case REMOVE_DEVICE:
            Status = ndisHandleOrphanDevice(Device);
            break;
            
          default:
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        break;


      default:
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    ndisPnPMutexOwner = 0;
    RELEASE_MUTEX(&ndisPnPMutex);

    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolBindNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:
    Given a erotocol's name and an adapter's name, this routine creates a binding between
    a protocol and an adapter (assuming protocol has a BindAdapterHandler)

Arguments:
    DeviceName: Adapter device name i.e. \Device\{GUID}
    ProtocolName Protocols name i.e. TCPIP

Return Value:
    STATUS_SUCCESS if we could call BindAdapterHandler
    STATUS_UNSUCCESSFUL otherwise

Note
    This routine does not return the status of attempted bind, rather if it -could- attempt to bind!
    
--*/
{
    //1 check to see if this routine should return back the status of attempted bind
    NTSTATUS                Status = STATUS_SUCCESS;
    PNDIS_PROTOCOL_BLOCK    Protocol = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolBindNotification\n"));

    do
    {
        ndisReferenceMiniportByName(DeviceName, &Miniport);

        if (Miniport == NULL)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
        }
        
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            Protocol = NULL;
            Status = STATUS_SUCCESS;
            break;
        }

        //
        // Bind this protocols
        //
        ndisCheckAdapterBindings(Miniport, Protocol);
    } while (FALSE);

    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol, FALSE);
    }

    if (Miniport != NULL)
    {
        MINIPORT_DECREMENT_REF(Miniport);
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolBindNotification\n"));
            
    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolUnbindNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                Status;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_PROTOCOL_BLOCK    Protocol = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    //1 change the name of fPartial variable. what this does is to keep track
    //1 of whether or not we are running our partial search for the first
    //1 time or not.
    BOOLEAN                 fPartial = FALSE;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolUnbindNotification\n"));

    do
    {
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("ndisHandleProtocolUnbindNotification: ndisReferenceProtocolByName failed %lx\n", Status));
            Status = STATUS_SUCCESS;
            Protocol = NULL;
            break;
        }

        //1 add comments what this loop does
        do
        {
            //1 add comments what this call does
            Open = ndisMapOpenByName(DeviceName, Protocol, TRUE);

            if (Open == NULL)
            {
                // 
                // There is no -active- binding between this adapter and protocol.
                // This would normally be an error but we need one special case for
                // TCP/IP Arp modules. We can unbind notifications for TCP/IP which
                // are actually destined for the ARP module.
                // We also know that either TCP/IP or ONE and ONLY ONE arp module can be
                // bound to an adapter. Make use of that knowledge.
                //
                ndisDereferenceProtocol(Protocol, FALSE);
                if (!fPartial)
                {
                    fPartial = TRUE;
                    Protocol = NULL;
                }
                Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, TRUE);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
            }
        } while (Open == NULL);
        
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisHandleProtocolUnbindNotification: Open %p\n", Open));

        if (Open != NULL)
        {
        
            Miniport = Open->MiniportHandle;
            
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            ndisMDereferenceOpen(Open);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            
            Status = ndisUnbindProtocol(Open, Protocol, Miniport, TRUE);
            
            if (Status != NDIS_STATUS_SUCCESS)
            {
                PNDIS_OPEN_BLOCK    tmpOpen;
                
                //
                // check to see if the open is still there and if it is
                // clear the UNBIND flag. Note that we were the one
                // setting the flag, so we can clear it ourselves
                //
                ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
                for (tmpOpen = Protocol->OpenQueue;
                     tmpOpen != NULL;
                     tmpOpen = tmpOpen->ProtocolNextOpen)
                {
                    if(tmpOpen == Open)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
                        OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                                  fMINIPORT_OPEN_DONT_FREE |
                                                  fMINIPORT_OPEN_PROCESSING);
                        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                        break;
                    }
                }
                RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
            }
        }

    } while (FALSE);

    if (Miniport != NULL)
    {
        MINIPORT_DECREMENT_REF(Miniport);
    }

    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol, FALSE);
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolUnbindNotification: Protocol %p, Status %lx\n", Protocol, Status));

    return Status;
}


NTSTATUS
ndisHandleProtocolReconfigNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName,
    IN  PVOID                           ReConfigBuffer,
    IN  UINT                            ReConfigBufferSize,
    IN  UINT                            Operation
    )
/*++

Routine Description:

    This routine will notify protocols of a change in their configuration -or-
    their bind list.
    This routine can also be called to notify protocols of a change in bind list

Arguments:
    DeviceName:        Adapter's name (if specified). if NULL, it means the change is global and not bind specific
    ProtocolName:       Protocol's name
    ReConfigBuffer: information buffer
    ReConfigBufferSize: Information buffer size
    Operation:      RECONFIGURE or BIND_LIST

Return Value:

--*/
{
    NTSTATUS                    Status;
    KIRQL                       OldIrql;
    PNDIS_PROTOCOL_BLOCK        Protocol = NULL;
    PNDIS_MINIPORT_BLOCK        Miniport = NULL;
    PNDIS_OPEN_BLOCK            Open = NULL;
    NET_PNP_EVENT               NetPnpEvent;
    PNDIS_PNP_EVENT_RESERVED    EventReserved;
    KEVENT                      Event;
    BOOLEAN                     fPartial = FALSE;
    BOOLEAN                     DeRefOpen = FALSE;
    BOOLEAN                     DeRefMiniport = FALSE;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolReconfigNotification\n"));

    do
    {
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            Protocol = NULL;
            break;
        }

        //
        // We can be passed a NULL device-name which implies global reconfig and we call
        // the protocol's event handler with a NULL BindingContext
        //
        if (DeviceName->Length != 0)
        {
            ASSERT(Operation == RECONFIGURE);
            
            do
            {
                WAIT_FOR_PROTO_MUTEX(Protocol);
                Open = ndisMapOpenByName(DeviceName, Protocol, FALSE);
    
                if (Open == NULL)
                {
                    RELEASE_PROT_MUTEX(Protocol);

                    // 
                    // There is no -active- binding between this adapter and protocol.
                    // This would normally be an error but we need one special case for
                    // TCP/IP Arp modules. We can unbind notifications for TCP/IP which
                    // are actually destined for the ARP module.
                    // We also know that either TCP/IP or ONE and ONLY ONE arp module can be
                    // bound to an adapter. Make use of that knowledge.
                    //
                    ndisDereferenceProtocol(Protocol, FALSE);
                    if (!fPartial)
                    {
                        fPartial = TRUE;
                        Protocol = NULL;
                    }
                    Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, TRUE);
                    if (!NT_SUCCESS(Status))
                    {
                        break;
                    }
                }
                else
                {
                    DeRefOpen = TRUE;
                    DeRefMiniport = TRUE;
                    Miniport = Open->MiniportHandle;
                }
            } while (Open == NULL);

            if (Open == NULL)
            {
                //
                // if Open == NULL we are not holding the protocol mutex
                //
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }
            else if (Protocol->ProtocolCharacteristics.PnPEventHandler == NULL)
            {
                //
                // Open is not NULL, we -are- holding the protocol mutex. release
                // it before breaking out
                //
                RELEASE_PROT_MUTEX(Protocol);
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }
        else
        {
            //
            // the device is NULL, just grab the protocol mutex
            //
            if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
            {
                WAIT_FOR_PROTO_MUTEX(Protocol);
            }
            else
            {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        //
        // Setup the PnPEvent buffer
        //
        NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
        Status = STATUS_SUCCESS;
        switch (Operation)
        {
          case RECONFIGURE:
            NetPnpEvent.NetEvent = NetEventReconfigure;
            break;
            
          case BIND_LIST:
            NetPnpEvent.NetEvent = NetEventBindList;
            break;
            
          default:
            ASSERT(FALSE);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        if (Status == STATUS_INVALID_DEVICE_REQUEST)
        {
            break;
        }
            
        NetPnpEvent.Buffer = ReConfigBuffer;
        NetPnpEvent.BufferLength = ReConfigBufferSize;

        //
        //  Get a pointer to the NDIS reserved are in the PnP event.
        //
        EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent);
        INITIALIZE_EVENT(&Event);
        EventReserved->pEvent = &Event;

        //
        // Notify the protocol now
        //
        Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                        (Open != NULL) ? Open->ProtocolBindingContext : NULL,
                        &NetPnpEvent);
    
        if (Status == NDIS_STATUS_PENDING)
        {
            //
            //  Wait for completion.
            //
            WAIT_FOR_PROTOCOL(Protocol, &Event);
    
            //
            //  Get the completion status.
            //
            Status = EventReserved->Status;
        }

        //
        // IPX may return NDIS_STATUS_NOT_ACCEPTED to ask NDIS to 
        // Unbind/Bind the adapter. In this case, Open cannot be NULL.
        // 
        if (Status != NDIS_STATUS_NOT_ACCEPTED)
        {
            if (Open)
            {
                ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
                OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
                RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
            }
            RELEASE_PROT_MUTEX(Protocol);
            break;
            
        }
        
        RELEASE_PROT_MUTEX(Protocol);
        
        ASSERT(DeRefOpen);
        //
        // Ndis need to Unbind/Bind the adapter for the protocol(Especially for IPX)
        //
        ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
        
        //
        // If the open has gotten a unbind anyway, just return success and don't 
        // need to unbind/bind.
        // 
        if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
        {
            RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        //
        // Going to Unbind the adaper
        // 
        OPEN_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_DONT_FREE);
        
        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
        
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        ndisMDereferenceOpen(Open);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        
        DeRefOpen = FALSE;
            
        Status = ndisUnbindProtocol(Open, Protocol, Miniport, FALSE);

        //
        // If cannot unbind the adapter
        //
        if (Status != NDIS_STATUS_SUCCESS)
        {
            PNDIS_OPEN_BLOCK    tmpOpen;
            //
            // check to see if the open is still there and if it is
            // clear the UNBIND flag. Note that we were the one
            // setting the flag, so we can clear it ourselves
            //  
            ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
            for (tmpOpen = Protocol->OpenQueue;
                    tmpOpen != NULL;
                    tmpOpen = tmpOpen->ProtocolNextOpen)
            {
                if(tmpOpen == Open)
                {
                    ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
                    OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING |
                                          fMINIPORT_OPEN_DONT_FREE |
                                          fMINIPORT_OPEN_PROCESSING);
                    RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                    break;
                }
            }
            RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
            break;
        }
        //
        // Then bind the adapter again.
        // 
        ndisCheckAdapterBindings(Miniport, Protocol);

    } while (FALSE);


    if (DeRefOpen)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        ndisMDereferenceOpen(Open);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol, FALSE);
    }

    if (DeRefMiniport)
    {
        MINIPORT_DECREMENT_REF(Miniport);
    }

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolReconfigNotification\n"));
            
    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolUnloadNotification(
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                    Status;
    PNDIS_PROTOCOL_BLOCK        Protocol = NULL;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolUnloadNotification\n"));

    //
    // Map ProtocolName to the Protocol block
    //
    Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);

    if (NT_SUCCESS(Status))
    {
        ndisDereferenceProtocol(Protocol, FALSE);

        if (Protocol->ProtocolCharacteristics.UnloadHandler != NULL)
        {
            //1 investigate if this can be called with open bindings 
            (Protocol->ProtocolCharacteristics.UnloadHandler)();
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolUnloadNotification\n"));
            
    return Status;
}


//1 when do we hit this?
NTSTATUS
FASTCALL
ndisHandleOrphanDevice(
    IN  PUNICODE_STRING                 pDevice
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    BOOLEAN                 fFound = FALSE;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    UNICODE_STRING          UpcaseDevice;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisHandleOrphanDevice\n"));
            
    UpcaseDevice.Length = pDevice->Length;
    UpcaseDevice.MaximumLength = pDevice->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlUpcaseUnicodeString(&UpcaseDevice, pDevice, FALSE);
    ASSERT (NT_SUCCESS(Status));

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
    
    for (MiniBlock = ndisMiniDriverList;
         (MiniBlock != NULL) && !fFound;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    
        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->MiniportName))
            {
                fFound = TRUE;
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_ORPHANED);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                break;
            }
        }
    
        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    FREE_POOL(UpcaseDevice.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisHandleOrphanDevice\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FASTCALL
ndisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF                 EnumIntf,
    IN  UINT                            BufferLength,
    IN  PUINT                           OutputLength
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_INTERFACE         Interface;
    UINT                    SpaceLeft;
    UINT                    SpaceNeeded;
    PUCHAR                  pBuf;
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   OldIrql;

    do
    {
        *OutputLength = 0;
        if (BufferLength < sizeof(NDIS_ENUM_INTF))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        
        SpaceLeft = BufferLength - sizeof(NDIS_ENUM_INTF);

        NdisZeroMemory(EnumIntf, BufferLength);
        
        Interface = &EnumIntf->Interface[0];
        pBuf = (PUCHAR)EnumIntf + BufferLength;

        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        for (MiniBlock = ndisMiniDriverList;
             MiniBlock != NULL;
             MiniBlock = MiniBlock->NextDriver)
        {
            ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

            for (Miniport = MiniBlock->MiniportQueue;
                 Miniport != NULL;
                 Miniport = Miniport->NextMiniport)
            {
                if (Miniport->PnPDeviceState != NdisPnPDeviceStarted)
                {
                    continue;
                }

                EnumIntf->AvailableInterfaces ++;
                SpaceNeeded = sizeof(NDIS_INTERFACE) +
                                Miniport->MiniportName.Length +
                                Miniport->pAdapterInstanceName->Length;
                EnumIntf->BytesNeeded += SpaceNeeded;
                if (SpaceLeft >= SpaceNeeded)
                {
                    EnumIntf->TotalInterfaces ++;
                    SpaceLeft -= SpaceNeeded;

                    pBuf -= Miniport->MiniportName.Length;
                    Interface->DeviceName.Buffer = (PWSTR)pBuf;
                    Interface->DeviceName.MaximumLength = 
                    Interface->DeviceName.Length = Miniport->MiniportName.Length;
                    CopyMemory(pBuf, Miniport->MiniportName.Buffer, Interface->DeviceName.Length);
                    POINTER_TO_OFFSET(Interface->DeviceName.Buffer, EnumIntf);

                    pBuf -= Miniport->pAdapterInstanceName->Length;
                    Interface->DeviceDescription.Buffer = (PWSTR)pBuf;
                    Interface->DeviceDescription.MaximumLength = 
                    Interface->DeviceDescription.Length = Miniport->pAdapterInstanceName->Length;
                    CopyMemory(pBuf, Miniport->pAdapterInstanceName->Buffer, Interface->DeviceDescription.Length);
                    
                    POINTER_TO_OFFSET(Interface->DeviceDescription.Buffer, EnumIntf);
                    Interface ++;
                }
#if 0
                else
                {
                    //
                    // we should report the cases that buffer was too small
                    //
                    //1 for .NET leave the behavior as before (return success)
                    //1 because some apps do not handle this properly
                    Status = STATUS_BUFFER_TOO_SMALL;
                    break;
                }
#endif
            }

            RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
            
            if (Status != STATUS_SUCCESS)
            {
                //
                // if we failed, get out
                //
                break;
            }
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

        //
        // since we zero'ed out the entire output buffer and started 
        // writing to it from the end, this should be the original output buffer
        // length
        //
        *OutputLength = BufferLength;
    }while (FALSE);
        
    return Status;
}


NTSTATUS
ndisUnbindProtocol(
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  BOOLEAN                 Notify
    )
/*+++

Routine Description:

Arguments:
    
Return Value:
    None

---*/
{
    NDIS_STATUS             Status = STATUS_SUCCESS;
    NDIS_BIND_CONTEXT       UnbindContext;
    PKEVENT                 CloseCompleteEvent = NULL;
    PNDIS_OPEN_BLOCK        TmpOpen = NULL;
    KIRQL                   OldIrql;
    BOOLEAN                 fDerefProtocol = FALSE;
    BOOLEAN                 FreeOpen = FALSE;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisUnbindProtocol: Open %p, Notify %d\n", Open, Notify));


    PnPReferencePackage();
    
    //
    // if this is called outside the context of the protocol deregistering, increment 
    // the ref count to make sure the protocol deregisteration does not go through
    // otherwise make note of the fact that we could not increment the ref count and avoid
    // deref at the end
    //
    
    if (ndisReferenceProtocol(Protocol))
    {
        fDerefProtocol = TRUE;
    }

    WAIT_FOR_PROTO_MUTEX(Protocol);
    
    do
    {
        //
        // make sure the open didn't go away while we were waiting for
        // protocol mutex.
        //

        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
        for (TmpOpen = Protocol->OpenQueue; 
             TmpOpen != NULL; 
             TmpOpen = TmpOpen->ProtocolNextOpen)
        {
            if (TmpOpen == Open)
                break;
        }
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        
        if (TmpOpen == NULL)
        {
            //
            // open went away while we were trying to get the protocol mutex
            // return right away
            //

            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisUnbindProtocol: Open %p, Flags %lx was closed while we were waiting for the protocol mutex.\n", Open, Open->Flags));
            break;
        }
        
        ASSERT(OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING));
        CloseCompleteEvent = Open->CloseCompleteEvent;
        
        //
        //  wait for all AF notifications to go through
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            KEVENT      AfNotifyCompleteEvent;

            INITIALIZE_EVENT(&AfNotifyCompleteEvent);

            //1 check to see if we need to    get the Open Spinlock here
            Open->AfNotifyCompleteEvent = &AfNotifyCompleteEvent;
            
            if (Open->PendingAfNotifications != 0)
            {                
                WAIT_FOR_OBJECT(Open->AfNotifyCompleteEvent , 0);
            }
            
            Open->AfNotifyCompleteEvent = NULL;
            
        }

        //
        // Do a query-remove here first
        //
        if (Notify && (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL))
        {
            NET_PNP_EVENT               NetPnpEvent;
            PNDIS_PNP_EVENT_RESERVED    EventReserved;
            KEVENT                      Event;
    
            RtlZeroMemory(&NetPnpEvent, sizeof(NET_PNP_EVENT));
            INITIALIZE_EVENT(&Event);
            EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent);
            NetPnpEvent.NetEvent = NetEventQueryRemoveDevice;
            NetPnpEvent.Buffer = NULL;
            NetPnpEvent.BufferLength = 0;
            EventReserved->pEvent = &Event;
    
            //
            //  Indicate the event to the protocol.
            //
            Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                                        Open->ProtocolBindingContext,
                                        &NetPnpEvent);

            if (NDIS_STATUS_PENDING == Status)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
    
                //
                //  Get the completion status.
                //
                Status = EventReserved->Status;
            }
    
            //
            //  Is the status OK?
            //
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        if (CloseCompleteEvent != NULL)
        {
            INITIALIZE_EVENT(CloseCompleteEvent);
        }

        //
        // Protocol ok with remove so now do it.
        //
        INITIALIZE_EVENT(&UnbindContext.Event);

        Status = NDIS_STATUS_SUCCESS;

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        (*Protocol->ProtocolCharacteristics.UnbindAdapterHandler)(
                &Status,
                Open->ProtocolBindingContext,
                &UnbindContext);

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        if (Status == NDIS_STATUS_PENDING)
        {
            WAIT_FOR_PROTOCOL(Protocol, &UnbindContext.Event);
            Status = UnbindContext.BindStatus;
        }

        ASSERT(Status == NDIS_STATUS_SUCCESS);

        ndisNotifyWmiBindUnbind(Miniport, Protocol, FALSE);
           
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        
        if (CloseCompleteEvent != NULL)
        {
            //
            // make sure the open is gone
            //
            WAIT_FOR_PROTOCOL(Protocol, CloseCompleteEvent);
        }
        
    } while (FALSE);

    RELEASE_PROT_MUTEX(Protocol);

    if (TmpOpen != NULL)
    {
        ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
        //
        // did the close routine get our message not to free the open structure?
        //
        if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSE_COMPLETE))
        {
            //
            // we have to get rid of open ourselves
            // 
            FreeOpen = TRUE;
        }
        else
        {
            //
            // for some reason, unbind did not go through or close is
            // still in progress
            //
            OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                  fMINIPORT_OPEN_DONT_FREE |
                                  fMINIPORT_OPEN_PROCESSING);
            FreeOpen = FALSE;
        }
        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
    }

    PnPDereferencePackage();

    if (FreeOpen)
    {
        ndisRemoveOpenFromGlobalList(Open);
        FREE_POOL(Open);
    }

    if (fDerefProtocol)
    {
        ndisDereferenceProtocol(Protocol, FALSE);
    }
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisUnbindProtocol: Open %p, Notify %d, Status %lx\n", Open, Notify, Status));

    return(Status);
}

VOID
ndisReferenceMiniportByName(
    IN  PUNICODE_STRING             DeviceName,
    OUT PNDIS_MINIPORT_BLOCK    *   pMiniport
    )
{
    KIRQL                   OldIrql;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    UNICODE_STRING          UpcaseDevice;
    UINT                    Depth = 1;

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
            ("==>ndisReferenceMiniportByName\n"));
            
    *pMiniport = NULL;

    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    do
    {
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
    
        for (MiniBlock = ndisMiniDriverList;
             MiniBlock != NULL;
             MiniBlock = MiniBlock->NextDriver)
        {
            ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    
            for (Miniport = MiniBlock->MiniportQueue;
                 Miniport != NULL;
                 Miniport = Miniport->NextMiniport)
            {
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_ORPHANED) &&
                    (Miniport->BindPaths != NULL) &&
                    (Miniport->BindPaths->Number >= Depth) &&
                     NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->BindPaths->Paths[0]))
                {
                    if (*pMiniport != NULL)
                    {
                        MINIPORT_DECREMENT_REF(*pMiniport);
                        *pMiniport = NULL;
                    }
                    Depth = Miniport->BindPaths->Number;
                    if (MINIPORT_INCREMENT_REF(Miniport))
                    {
                        *pMiniport = Miniport;
                    }
                    break;
                }
            }
    
            RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
        }
    
    } while (FALSE);

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    FREE_POOL(UpcaseDevice.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
            ("<==ndisReferenceMiniportByName\n"));
}

PNDIS_OPEN_BLOCK
FASTCALL
ndisMapOpenByName(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  BOOLEAN                         fUnbinding
    )
/*
Routine Description:
    ndisMapOpenByName searches a protocol's open queue and tries to find an 
    open block that its RootDevice name matches Devicename passed to this function.
    if the Open is found, miniport for that open is referenced. if we are -not-
    trying to unbind the open, we will reference it.
    
Arguments:
    DeviceName: RootDevice name of the open.
    Protocol: protocol block to search.
    fUnbinding: whether we are searching for the open so we can close it. if that is
    the case, then some additional checks will be perfomred and the some flags on open
    will be set.
    
Return Value:
    Open block or NULL.

*/
{
    UNICODE_STRING          UpcaseDevice;
    PNDIS_OPEN_BLOCK        Open, tmpOpen;
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;
    BOOLEAN                 DeRefOpen = FALSE;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisReferenceOpenByName, DeviceName %p, Protocol %p, fUnbinding %d\n",
                DeviceName, Protocol, fUnbinding));
            
    Open = NULL;
    
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);
    
    
    if (UpcaseDevice.Buffer == NULL)
    {
        DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("<==ndisReferenceOpenByName: failed to allocate memory.\n"));
        return NULL;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    //
    // Now walk the open list and get to the open representing the DeviceName
    //
    for (Open = Protocol->OpenQueue;
         Open != NULL;
         Open = Open->ProtocolNextOpen)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, Open->RootDeviceName))
        {            
            tmpOpen = Open;
            ACQUIRE_SPIN_LOCK_DPC(&tmpOpen->SpinLock);
            
            if (fUnbinding)
            {
                
                if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING   | 
                                         fMINIPORT_OPEN_CLOSING     |
                                         fMINIPORT_OPEN_PROCESSING))
                {
                    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                            ("ndisReferenceOpenByName: Open %p is already getting unbind\n", Open));
                    Open = NULL;
                }
                else
                {
                    
                    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
                    OPEN_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                            fMINIPORT_OPEN_DONT_FREE |
                                            fMINIPORT_OPEN_PROCESSING);
                }
            }
            else
            {
                if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_PROCESSING))
                {
                    Open = NULL;
                }
                else
                {
                    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
                    OPEN_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
                }
            }
            RELEASE_SPIN_LOCK_DPC(&tmpOpen->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    if (Open != NULL)
    {

        Miniport = Open->MiniportHandle;
        if (!MINIPORT_INCREMENT_REF(Miniport))
        {
            if (fUnbinding)
            {
                OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING  |
                                      fMINIPORT_OPEN_PROCESSING |
                                      fMINIPORT_OPEN_DONT_FREE);
            }
            else
            {
                OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING); 
            }

            DeRefOpen = TRUE;
        }
        else
        {
            DeRefOpen = FALSE;
        }
    }

    FREE_POOL(UpcaseDevice.Buffer);
    
    if (DeRefOpen)
    {
        Miniport = Open->MiniportHandle;
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        ndisMDereferenceOpen(Open);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        Open = NULL;
    }
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisReferenceOpenByName: Open %p\n", Open ));
            
    return(Open);
}

NTSTATUS
FASTCALL
ndisHandleLegacyTransport(
    IN  PUNICODE_STRING             pDevice
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    RTL_QUERY_REGISTRY_TABLE    LinkQueryTable[3];
    PWSTR                       Export = NULL;
    HANDLE                      TdiHandle;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleLegacyTransport\n"));

    if (ndisTdiRegisterCallback == NULL)
    {
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==ndisHandleLegacyTransport\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up LinkQueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below the xports registry key
    //

    LinkQueryTable[0].QueryRoutine = NULL;
    LinkQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    LinkQueryTable[0].Name = L"Linkage";

    //
    // 2) Call ndisReadParameter for "Export" (as a single multi-string),
    // which will allocate storage and save the data in Export.
    //

    LinkQueryTable[1].QueryRoutine = ndisReadParameter;
    LinkQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    LinkQueryTable[1].Name = L"Export";
    LinkQueryTable[1].EntryContext = (PVOID)&Export;
    LinkQueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Stop
    //

    LinkQueryTable[2].QueryRoutine = NULL;
    LinkQueryTable[2].Flags = 0;
    LinkQueryTable[2].Name = NULL;

    do
    {
        UNICODE_STRING  Us;
        PWSTR           CurExport;

        //1 Context parameter probably should be use to verify data type
        Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                        pDevice->Buffer,
                                        LinkQueryTable,
                                        (PVOID)NULL,      // no context needed
                                        NULL);


        if (!NT_SUCCESS(Status))
        {
            //
            // Do not complain about TDI drivers which do not
            // have any linkages
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        //
        // Walk the list of exports and call TdiRegisterDevice for each
        //
        for (CurExport = Export;
             *CurExport != 0;
             CurExport = (PWCHAR)((PUCHAR)CurExport + Us.MaximumLength))
        {
            RtlInitUnicodeString (&Us, CurExport);

            Status = (*ndisTdiRegisterCallback)(&Us, &TdiHandle);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }
    } while (FALSE);

    if (Export != NULL)
        FREE_POOL(Export);

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleLegacyTransport\n"));
            
    return(Status);
}


VOID
FASTCALL
ndisInitializeBinding(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
{
    PUNICODE_STRING         ExportName;
    NDIS_BIND_CONTEXT       BindContext;
    PDEVICE_OBJECT          PhysicalDeviceObject;
    NDIS_STATUS             BindStatus;
    UNICODE_STRING          ProtocolSection;
    UNICODE_STRING          DerivedBaseName, Parms;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisInitializeBinding\n"));

    //
    // Call the protocol to bind to the Miniport
    //
    WAIT_FOR_PROTO_MUTEX(Protocol);

    do
    {
        //
        // once we grabbed the protocol mutex, check again to see if 
        // the adapter is still there
        //
        if (!ndisIsMiniportStarted(Miniport) ||

            ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
             (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
             (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved)))
        {
            break;
        }

        if (TRUE == ndisProtocolAlreadyBound(Protocol, Miniport))
        {
            //
            // these two are already bound. just return
            //
            break;
        }
        
        ExportName = &Miniport->BindPaths->Paths[0];
        Protocol->BindDeviceName = &Miniport->MiniportName;
        Protocol->RootDeviceName = ExportName;
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

        if (ndisReferenceProtocol(Protocol) == FALSE)
        {
            break;
        }

        RtlInitUnicodeString(&Parms, L"\\Parameters\\Adapters\\");

        DerivedBaseName = *ExportName;
        DerivedBaseName.Length -= ndisDeviceStr.Length;
        DerivedBaseName.MaximumLength -= ndisDeviceStr.Length;
        (PUCHAR)(DerivedBaseName.Buffer) += ndisDeviceStr.Length;

        ProtocolSection.MaximumLength = Protocol->ProtocolCharacteristics.Name.Length +         // "tcpip"
                                                 Parms.Length +                                 // "\Parameters\Adapters\"
                                                 ExportName->Length - ndisDeviceStr.Length +    // "{GUID}"
                                                 sizeof(WCHAR);
        ProtocolSection.Length = 0;
        ProtocolSection.Buffer = (PWSTR)ALLOC_FROM_POOL(ProtocolSection.MaximumLength,
                                                        NDIS_TAG_DEFAULT);
        if (ProtocolSection.Buffer != NULL)
        {
            ZeroMemory(ProtocolSection.Buffer, ProtocolSection.MaximumLength);
            RtlCopyUnicodeString(&ProtocolSection,
                                 &Protocol->ProtocolCharacteristics.Name);
            RtlAppendUnicodeStringToString(&ProtocolSection,
                                           &Parms);
            RtlAppendUnicodeStringToString(&ProtocolSection,
                                           &DerivedBaseName);
        }
        else
        {
            ndisDereferenceProtocol(Protocol, FALSE);
            break;
        }


        BindContext.Next = NULL;
        BindContext.Protocol = Protocol;
        BindContext.Miniport = Miniport;
        BindContext.ProtocolSection = ProtocolSection;
        BindContext.DeviceName = ExportName;
        INITIALIZE_EVENT(&BindContext.Event);

        if (!Protocol->Ref.Closing)
        {
            BindStatus = NDIS_STATUS_SUCCESS;
            Protocol->BindingAdapter = Miniport;
            (*Protocol->ProtocolCharacteristics.BindAdapterHandler)(&BindStatus,
                                                                    &BindContext,
                                                                    ExportName,
                                                                    &ProtocolSection,
                                                                    (PVOID)PhysicalDeviceObject);
                                                                    
            if (BindStatus == NDIS_STATUS_PENDING)
            {
                WAIT_FOR_PROTOCOL(Protocol, &BindContext.Event);
                BindStatus = BindContext.BindStatus;
            }

            Protocol->BindingAdapter = NULL;
            if (BindStatus == NDIS_STATUS_SUCCESS)
            {
                ndisNotifyWmiBindUnbind(Miniport, Protocol, TRUE);
            }

#if DBG
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("  ndisInitializeBinding\n"));
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("    Protocol: "));
            DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    &Protocol->ProtocolCharacteristics.Name);
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("\n    Adapter: "));

            if (Miniport->pAdapterInstanceName)
            {
                DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                        Miniport->pAdapterInstanceName);
            }
            else
            {
                DBGPRINT_UNICODE(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        &Miniport->BaseName);
            }
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("\n    Result: %lx\n", BindStatus));
#endif
        }

        FREE_POOL(ProtocolSection.Buffer);
        
        Protocol->BindDeviceName = NULL;
        ndisDereferenceProtocol(Protocol, FALSE);
        
    } while (FALSE);
    
    RELEASE_PROT_MUTEX(Protocol);

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisInitializeBinding\n"));
}


VOID
NdisCompleteBindAdapter(
    IN  NDIS_HANDLE         BindAdapterContext,
    IN  NDIS_STATUS         Status,
    IN  NDIS_STATUS         OpenStatus
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_BIND_CONTEXT  pContext = (PNDIS_BIND_CONTEXT)BindAdapterContext;
    UNREFERENCED_PARAMETER(OpenStatus);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisCompleteBindAdapter\n"));

    pContext->BindStatus = Status;
    SET_EVENT(&pContext->Event);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCompleteBindAdapter\n"));
}

VOID
NdisCompleteUnbindAdapter(
    IN  NDIS_HANDLE         UnbindAdapterContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_BIND_CONTEXT  pContext = (PNDIS_BIND_CONTEXT)UnbindAdapterContext;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisCompleteUnbindAdapter\n"));

    pContext->BindStatus = Status;
    SET_EVENT(&pContext->Event);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCompleteUnbindAdapter\n"));
}

VOID
NdisRegisterTdiCallBack(
    IN  TDI_REGISTER_CALLBACK   RegisterCallback,
    IN  TDI_PNP_HANDLER         PnPHandler
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>NdisRegisterTdiCallBack\n"));

    if (ndisTdiRegisterCallback == NULL)
    {
        ndisTdiRegisterCallback = RegisterCallback;
    }

    if (ndisTdiPnPHandler == NULL)
    {
        ndisTdiPnPHandler = PnPHandler;
    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==NdisRegisterTdiCallBack\n"));
}

VOID
NdisDeregisterTdiCallBack(
    VOID
    )

{
    ndisTdiRegisterCallback = NULL;
    ndisTdiPnPHandler = NULL;
}

VOID
ndisFindRootDevice(
    IN  PNDIS_STRING                    DeviceName,
    IN  BOOLEAN                         fTester,
    OUT PNDIS_STRING *                  pBindDevice,
    OUT PNDIS_STRING *                  pRootDevice,
    OUT PNDIS_MINIPORT_BLOCK *          pAdapter
    )
/*++

Routine Description:

    Find the Miniport which is the highest level filter given the target root name.
Arguments:
    
Return Value:
    
--*/
{
    KIRQL                   OldIrql;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_STRING            RootDevice = NULL, BindDevice = NULL;
    NDIS_STRING             UpcaseDevice;
    PWSTR                   pwch;
    UINT                    Depth = 1;
    BOOLEAN                 Found = FALSE;

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisFindRootDevice\n"));
            
    *pBindDevice = NULL;
    *pRootDevice = NULL;
    *pAdapter = NULL;
    
    //
    // First we need to upcase the device-name before checking
    //
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if ((pwch = UpcaseDevice.Buffer) == NULL)
    {
        return;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);
    BindDevice = &UpcaseDevice;

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (fTester)
            {
                if (NDIS_EQUAL_UNICODE_STRING(BindDevice, &Miniport->MiniportName))
                {
                    BindDevice = &Miniport->MiniportName;
                    RootDevice = &Miniport->MiniportName;
                    *pAdapter = Miniport;
                    Found = TRUE;
                    break;
                }
            }
            else if ((Miniport->BindPaths->Number >= Depth) &&
                     NDIS_EQUAL_UNICODE_STRING(BindDevice, &Miniport->BindPaths->Paths[0]))
            {
                RootDevice = &Miniport->BindPaths->Paths[0];
                BindDevice = &Miniport->MiniportName;
                *pAdapter = Miniport;
                Depth = Miniport->BindPaths->Number;
                Found = TRUE;
            }
        }

        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        if (fTester && Found)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
    PnPDereferencePackage();

    FREE_POOL(pwch);

    if (Found)
    {
        *pBindDevice = BindDevice;
        *pRootDevice = RootDevice;
    }

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisFindRootDevice\n"));
}


VOID
ndisNotifyWmiBindUnbind(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_PROTOCOL_BLOCK                Protocol,
    BOOLEAN                             fBind
    )
/*++

Routine Description:

    Notify WMI that either a bind or an unbind has occured.

Arguments:
    
Return Value:
    
--*/
{
    PWNODE_SINGLE_INSTANCE  wnode;
    PUCHAR                  ptmp;
    NTSTATUS                NtStatus;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyWmiBindUnbind: Miniport %p, Protocol %p, fBind %lx\n", Miniport, Protocol, fBind));

    ndisSetupWmiNode(Miniport,
                     Miniport->pAdapterInstanceName,
                     Miniport->BindPaths->Paths[0].Length + sizeof(WCHAR) +
                     Protocol->ProtocolCharacteristics.Name.Length + sizeof(WCHAR),
                     fBind ? (PVOID)&GUID_NDIS_NOTIFY_BIND : (PVOID)&GUID_NDIS_NOTIFY_UNBIND,
                     &wnode);

    if (wnode != NULL)
    {
        //
        //  Save the number of elements in the first ULONG.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

        //
        //  Copy the data which is the protocol name + the miniport name in the data field
        //  Protocol<NULL>MiniportName<NULL>
        //
        RtlCopyMemory(ptmp,
                      Protocol->ProtocolCharacteristics.Name.Buffer,
                      Protocol->ProtocolCharacteristics.Name.Length);
    
        RtlCopyMemory(ptmp + Protocol->ProtocolCharacteristics.Name.Length + sizeof(WCHAR),
                      Miniport->BindPaths->Paths[0].Buffer,
                      Miniport->BindPaths->Paths[0].Length);

        //
        // notify kernel mode components who have registered for Ndis BindUnbind event
        //
        if (ndisBindUnbindCallbackObject != NULL)
        {
            ExNotifyCallback(ndisBindUnbindCallbackObject,
                             (PVOID)wnode,
                              NULL);
        }
        
        //
        //  Indicate the event to WMI. WMI will take care of freeing
        //  the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("IoWMIWriteEvent failed %lx\n", NtStatus));
    
            FREE_POOL(wnode);
        }
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisNotifyWmiBindUnbind: Miniport %p, Protocol %p, fBind %lx\n", Miniport, Protocol, fBind));

    return;
}



VOID
ndisNotifyDevicePowerStateChange(
    PNDIS_MINIPORT_BLOCK                Miniport,
    NDIS_DEVICE_POWER_STATE             PowerState
    )
/*++

Routine Description:

    Notify WMI that that the power state of a NIC is changed.

Arguments:
    
Return Value:
    
--*/
{
    PWNODE_SINGLE_INSTANCE  wnode;
    PUCHAR                  ptmp;
    NTSTATUS                NtStatus;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyDevicePowerStateChange: Miniport %p, PowerState %lx\n", Miniport, PowerState));

    ndisSetupWmiNode(Miniport,
                     Miniport->pAdapterInstanceName,
                     Miniport->MiniportName.Length + sizeof(WCHAR),
                     (PowerState == NdisDeviceStateD0) ? (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON : (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
                     &wnode);

    if (wnode != NULL)
    {
        //
        //  Save the number of elements in the first ULONG.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
    
        RtlCopyMemory(ptmp,
                      Miniport->MiniportName.Buffer,
                      Miniport->MiniportName.Length);
        
        //
        //  Indicate the event to WMI. WMI will take care of freeing
        //  the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("IoWMIWriteEvent failed %lx\n", NtStatus));
    
            FREE_POOL(wnode);
        }
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisNotifyDevicePowerStateChange: Miniport %p, PowerState %lx\n", Miniport, PowerState));

    return;
}

BOOLEAN
NdisMatchPdoWithPacket(
    IN  PNDIS_PACKET        Packet,
    IN  PVOID               Pdo
    )
{
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
    Miniport = NSR->Miniport;

    return (Pdo == Miniport->PhysicalDeviceObject);
}

VOID
ndisPowerStateCallback(
    PVOID   CallBackContext,
    PVOID   Argument1,
    PVOID   Argument2
    )
{
    ULONG   Action = (ULONG)((ULONG_PTR)Argument1);
    ULONG   State = (ULONG)((ULONG_PTR)Argument2);
    NDIS_POWER_PROFILE  PowerProfile;

    UNREFERENCED_PARAMETER(CallBackContext);
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisPowerStateCallback: Action %lx, State %lx\n", Action, State));

    if (Action == PO_CB_AC_STATUS)
    {
        ndisAcOnLine = State;
        PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? NdisPowerProfileAcOnLine : NdisPowerProfileBattery;

        ndisNotifyMiniports((PNDIS_MINIPORT_BLOCK)NULL,
                            NdisDevicePnPEventPowerProfileChanged,
                            &PowerProfile,
                            sizeof(NDIS_POWER_PROFILE));
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPowerStateCallback: Action %lx, State %lx\n", Action, State));

}

VOID
ndisNotifyMiniports(
    IN  PNDIS_MINIPORT_BLOCK    Miniport OPTIONAL,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    )
{
    PNDIS_M_DRIVER_BLOCK    MiniBlock, NextMiniBlock;
    PNDIS_MINIPORT_BLOCK    CurMiniport;
    KIRQL                   OldIrql;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyMiniportsPowerProfileChange: Miniport %p, Event %lx, Buffer %p\n", 
                                            Miniport,
                                            DevicePnPEvent,
                                            Buffer));
    PnPReferencePackage();
    
    do
    {
        if (Miniport)
        {
            if(Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL)
            {
                //
                // if Miniport has been specified, the caller is responsible to make sure it is valid and appropriate
                // to call the miniport
                //
                Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(Miniport->MiniportAdapterContext,
                                                                                      DevicePnPEvent,
                                                                                      Buffer,
                                                                                      Length);
            }
            
            break;
        }

        //
        // notification is for all the miniports
        //
        
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        for (MiniBlock = ndisMiniDriverList;
             MiniBlock != NULL;
             MiniBlock = NextMiniBlock)
        {

            if (ndisReferenceDriver(MiniBlock))
            {
                RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

                while ((CurMiniport = ndisReferenceNextUnprocessedMiniport(MiniBlock)) != NULL)
                {
                    if (CurMiniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL)
                    {
                        CurMiniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(CurMiniport->MiniportAdapterContext,
                                                                                                  NdisDevicePnPEventPowerProfileChanged,
                                                                                                  Buffer,
                                                                                                  Length);
                    }
                }

                ndisUnprocessAllMiniports(MiniBlock);
                
                ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
                NextMiniBlock = MiniBlock->NextDriver;
                ndisDereferenceDriver(MiniBlock, TRUE);
                
            }
            else
            {
                NextMiniBlock = MiniBlock->NextDriver;
            }
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        
    } while (FALSE);

    PnPDereferencePackage();
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==>ndisNotifyMiniportsPowerProfileChange: Miniport %p\n", Miniport));

    return;
}

PNDIS_MINIPORT_BLOCK
ndisReferenceNextUnprocessedMiniport(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReferenceNextUnprocessedMiniport: MiniBlock %p\n", MiniBlock));

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    for (Miniport = MiniBlock->MiniportQueue;
         Miniport != NULL;
         Miniport = Miniport->NextMiniport)
    {
        if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_DEREGISTERED_INTERRUPT | 
                                           fMINIPORT_RESET_IN_PROGRESS | 
                                           fMINIPORT_PM_HALTING)) &&
            !MINIPORT_PNP_TEST_FLAG(Miniport, (fMINIPORT_REMOVE_IN_PROGRESS |
                                               fMINIPORT_DEVICE_FAILED |
                                               fMINIPORT_PM_HALTED |
                                               fMINIPORT_HALTING |
                                               fMINIPORT_SHUTTING_DOWN |
                                               fMINIPORT_PROCESSING)) &&
            (Miniport->PnPDeviceState == NdisPnPDeviceStarted) &&
            (Miniport->CurrentDevicePowerState == PowerDeviceD0) &&
            MINIPORT_INCREMENT_REF(Miniport))
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PROCESSING);
            break;
        }
    }

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReferenceNextUnprocessedMiniport: MiniBlock %p\n", MiniBlock));
        
    return(Miniport);
}


VOID
ndisUnprocessAllMiniports(
    IN  PNDIS_M_DRIVER_BLOCK        MiniBlock
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisUnprocessAllMiniports: MiniBlock %p\n", MiniBlock));

    while (TRUE)
    {
        
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        //
        // find the first miniport that is being proccessed. clear the flag, dereference the
        // miniport and go through the whole process again.
        //

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PROCESSING))
            {
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PROCESSING);
                break;
            }
        }
        
        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

        if (Miniport == NULL)
            break;

        //
        // dereferencing the miniport could make it to go away
        //
        MINIPORT_DECREMENT_REF(Miniport);

    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisUnprocessAllMiniports: MiniBlock %p\n", MiniBlock));
}

//1 add function header

PVOID
NdisGetRoutineAddress(
    IN PNDIS_STRING  NdisRoutineName
    )
{
    PVOID       Address;
    ANSI_STRING AnsiString;
    NTSTATUS    Status;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    Status = RtlUnicodeStringToAnsiString(&AnsiString,
                                          (PUNICODE_STRING)NdisRoutineName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        return NULL;
    }


    Address = FindExportedRoutineByName(ndisDriverObject->DriverStart, &AnsiString);
    
    RtlFreeAnsiString (&AnsiString);

    return Address;
}

PVOID
FindExportedRoutineByName (
    IN PVOID DllBase,
    IN PANSI_STRING AnsiImageRoutineName
    )

/*++

Routine Description:

    This function searches the argument module looking for the requested
    exported function name.

Arguments:

    DllBase - Supplies the base address of the requested module.

    AnsiImageRoutineName - Supplies the ANSI routine name being searched for.

Return Value:

    The virtual address of the requested routine or NULL if not found.

--*/

{
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    ULONG High;
    ULONG Low;
    ULONG Middle;
    LONG Result;
    ULONG ExportSize;
    PVOID FunctionAddress;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;

    PAGED_CODE();

    FunctionAddress = NULL;

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                                DllBase,
                                TRUE,
                                IMAGE_DIRECTORY_ENTRY_EXPORT,
                                &ExportSize
                                );

    if (ExportDirectory == NULL) {
        return NULL;
    }

    //
    // Initialize the pointer to the array of RVA-based ansi export strings.
    //

    NameTableBase = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNames);

    //
    // Initialize the pointer to the array of USHORT ordinal numbers.
    //

    NameOrdinalTableBase = (PUSHORT)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

    //
    // Lookup the desired name in the name table using a binary search.
    //

    Low = 0;
    High = ExportDirectory->NumberOfNames - 1;

    //
    // Initializing Middle is not needed for correctness, but without it
    // the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    Middle = 0;

    while (High >= Low && (LONG)High >= 0) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;

        //1 investigate using strncmp
        Result = strcmp (AnsiImageRoutineName->Buffer,
                         (PCHAR)DllBase + NameTableBase[Middle]);

        if (Result < 0) {
            High = Middle - 1;
        }
        else if (Result > 0) {
            Low = Middle + 1;
        }
        else {
            break;
        }
    }

    //
    // If the high index is less than the low index, then a matching
    // table entry was not found. Otherwise, get the ordinal number
    // from the ordinal table.
    //

    if ((LONG)High < (LONG)Low) {
        return NULL;
    }

    OrdinalNumber = NameOrdinalTableBase[Middle];

    //
    // If the OrdinalNumber is not within the Export Address Table,
    // then this image does not implement the function.  Return not found.
    //

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
        return NULL;
    }

    //
    // Index into the array of RVA export addresses by ordinal number.
    //

    Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);

    FunctionAddress = (PVOID)((PCHAR)DllBase + Addr[OrdinalNumber]);

    //
    // Forwarders are not used by the kernel and HAL to each other.
    //

    if ((ULONG_PTR)FunctionAddress > (ULONG_PTR)ExportDirectory &&
        (ULONG_PTR)FunctionAddress < ((ULONG_PTR)ExportDirectory + ExportSize)) {
        FunctionAddress = NULL;
    }

    return FunctionAddress;
}

UINT
NdisGetVersion(
    VOID
    )
{
    return ((NDIS_MAJOR_VERSION << 16) | NDIS_MINOR_VERSION);
}

#if 0
VOID
ndisBindUnbindCallback(
    PVOID   CallBackContext,
    PVOID   Argument1,
    PVOID   Argument2
    )

{
    PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE)Argument1;
    PUCHAR                  ptmp;
    UNICODE_STRING          ProtocolName, MiniportName;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisBindUnbindCallback\n"));

    if (wnode != NULL)
    {
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

        RtlInitUnicodeString(&ProtocolName, (PWCHAR)ptmp);
        ptmp += ProtocolName.Length + sizeof(WCHAR);
        RtlInitUnicodeString(&MiniportName, (PWCHAR)ptmp);
        
        ndisDbgPrintUnicodeString(&ProtocolName);
        DbgPrint("\n");
        ndisDbgPrintUnicodeString(&MiniportName);
        DbgPrint("\n");
    
  
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisBindUnbindCallback\n"));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndispnp.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Ndispnp.c

Abstract:

Author:

    Kyle Brandon    (KyleB)     
    Alireza Dabagh  (AliD)

Environment:

    Kernel mode

Revision History:

    12/20/96    KyleB           Added support for IRP_MN_QUERY_CAPABILITIES.

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS_PNP

VOID
NdisCompletePnPEvent(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
/*++

Routine Description:

    This routine is called by a transport when it wants to complete a PnP/PM
    event indication on a given binding.

Arguments:

    Status              -   Status of the PnP/PM event indication.
    NdisBindingHandle   -   Binding that the event was for.
    NetPnPEvent         -   Structure describing the PnP/PM event.

Return Value:

    None.

--*/
{
    PNDIS_PNP_EVENT_RESERVED    EventReserved;

#if !DBG
    UNREFERENCED_PARAMETER(NdisBindingHandle);
#endif
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>NdisCompletePnPEvent: Open %p\n", NdisBindingHandle));
        
    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    //  Get a pointer to the NDIS reserved area in the event.
    //
    EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(NetPnPEvent);

    //
    //  Save the status with the net event.
    //
    EventReserved->Status = Status;

    //
    //  Signal the event.
    //
    SET_EVENT(EventReserved->pEvent);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==NdisCompletePnPEvent: Open %p\n", NdisBindingHandle));
}

NTSTATUS
ndisMIrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine will get called after the next device object in the stack
    processes the IRP_MN_QUERY_CAPABILITIES IRP this needs to be merged with
    the miniport's capabilites and completed.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);
    
    SET_EVENT(Context);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisPassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    )
/*++

Routine Description:

    This routine will simply pass the IRP down to the next device object to
    process.

Arguments:
    pIrp                -   Pointer to the IRP to process.
    pNextDeviceObject   -   Pointer to the next device object that wants
                            the IRP.

Return Value:

--*/
{
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    //  Initialize the event structure.
    //
    INITIALIZE_EVENT(&Event);

    //
    //  Set the completion routine so that we can process the IRP when
    //  our PDO is done.
    //
    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)ndisMIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    //  Pass the IRP down to the PDO.
    //
    Status = IoCallDriver(pNextDeviceObject, pIrp);
    if (Status == STATUS_PENDING)
    {
        //
        //  Wait for completion.
        //
        WAIT_FOR_OBJECT(&Event, NULL);

        Status = pIrp->IoStatus.Status;
    }

    return(Status);
}

NDIS_STATUS
ndisPnPNotifyAllTransports(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NET_PNP_EVENT_CODE      PnpEvent,
    IN  PVOID                   Buffer,
    IN  ULONG                   BufferLength
    )
/*++

Routine Description:

    This routine will notify the transports bound to the miniport about
    the PnP event.  When all of the bound transports have completed the
    PnP event it will then call the completion routine.

Arguments:

    Miniport    -   Pointer to the miniport block.
    PnpEvent    -   PnP event to notify the transports of.

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK            Open = NULL;
    NET_PNP_EVENT               NetPnpEvent;
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPNotifyAllTransports: Miniport %p\n", Miniport));

    PnPReferencePackage();

    //
    //  Initialize the PnP event structure.
    //
    NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));

    NetPnpEvent.NetEvent = PnpEvent;
    NetPnpEvent.Buffer = Buffer;
    NetPnpEvent.BufferLength = BufferLength;

    //
    //  Indicate this event to the opens.
    //
    do
    {
        Open = ndisReferenceNextUnprocessedOpen(Miniport);

        if (Open == NULL)
            break;

        NdisStatus = ndisPnPNotifyBinding(Open, &NetPnpEvent);

        //
        //  Is the status OK?
        //
        if (NdisStatus != NDIS_STATUS_SUCCESS) 

        { 

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPNotifyAllTransports: Transport "));
            DBGPRINT_UNICODE(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    &Open->ProtocolHandle->ProtocolCharacteristics.Name);
            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (" failed the pnp event: %lx for Miniport %p with Status %lx\n", PnpEvent, Miniport, NdisStatus));
            
            if ((PnpEvent == NetEventQueryPower) || 
                (PnpEvent == NetEventQueryRemoveDevice) ||
                ((PnpEvent == NetEventSetPower) && (*((PDEVICE_POWER_STATE)Buffer) > PowerDeviceD0)))
            
            {
                break;
            }
            else
            {
                NdisStatus = NDIS_STATUS_SUCCESS;
            }
        }
    } while (TRUE);

    //
    // check for any open that we skipped because they were in the 
    // process of being closed
    //
next:
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_UNBINDING)))
        {
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            break;
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    if (Open != NULL)
    {
        NdisMSleep(50000); // Sleep to yield the CPU to other worker threads
        goto next;
    }


    ndisUnprocessAllOpens(Miniport);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPNotifyAllTransports: Miniport %p\n", Miniport));

    return(NdisStatus);
}


/*
PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
    
Routine Description:

    This routine is used during PnP notification to protocols. it walks through
    the Open queue on the miniport and finds the first Open that is not being unbound
    and it has not been already notified of the PnP even. it then sets the
    fMINIPORT_OPEN_PROCESSING flag so we do not try to unbind the open and 
    fMINIPORT_OPEN_NOTIFY_PROCESSING flag so we know which opens to "unprocess"
    when we are done

Arguments:

    Miniport: the Miniport block whose open blocks we are going to process.

Return Value:

    the first unprocessed open or null.

*/

PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReferenceNextUnprocessedOpen: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | 
                                   fMINIPORT_OPEN_PROCESSING |
                                   fMINIPORT_OPEN_UNBINDING)))
        {
            //
            // this will stop Ndis to Unbind this open for the time being
            //
            OPEN_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING | 
                                    fMINIPORT_OPEN_NOTIFY_PROCESSING);
            
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            break;
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReferenceNextUnprocessedOpen: Miniport %p\n", Miniport));
        
    return(Open);
}

/*
VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )
    
Routine Description:

    Clears the fMINIPORT_OPEN_PROCESSING flag on all the open blocks that have been 
    processed during a PnP Notification.

Arguments:
    Miniport: the Miniport block whose open blocks we are going to unprocess.

Return Value:
    None

*/

VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )
{
    PNDIS_OPEN_BLOCK        Open, NextOpen;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisUnprocessAllOpens: Miniport %p\n", Miniport));
        
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = NextOpen)
    {
        NextOpen = Open->MiniportNextOpen;
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);

        if (OPEN_TEST_FLAGS(Open, fMINIPORT_OPEN_NOTIFY_PROCESSING | 
                                  fMINIPORT_OPEN_PROCESSING))
        {
            OPEN_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING | 
                                  fMINIPORT_OPEN_NOTIFY_PROCESSING);
        }

        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
        Open = NextOpen;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisUnprocessAllOpens: Miniport %p\n", Miniport));
}


NDIS_STATUS
FASTCALL
ndisPnPNotifyBinding(
    IN  PNDIS_OPEN_BLOCK    Open,
    IN  PNET_PNP_EVENT      NetPnpEvent
    )
{
    PNDIS_PROTOCOL_BLOCK        Protocol;
    NDIS_HANDLE                 ProtocolBindingContext;
    KEVENT                      Event;
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
    PNDIS_PNP_EVENT_RESERVED    EventReserved;
    DEVICE_POWER_STATE          DeviceState;
    KIRQL                       OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPNotifyBinding: Open %p\n", Open));
    
    do
    {
        Protocol = Open->ProtocolHandle;
        ProtocolBindingContext = Open->ProtocolBindingContext;

        //
        //  Does the transport have a PnP Event handler?
        //
        if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
        {
            //
            //  Get a pointer to the NDIS reserved in PnP event.
            //
            EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(NetPnpEvent);
    
            //
            //  Initialize and save the local event with the PnP event.
            //
            INITIALIZE_EVENT(&Event);
            EventReserved->pEvent = &Event;
  
            //
            //  Indicate the event to the protocol.
            //
            NdisStatus = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                            ProtocolBindingContext,
                            NetPnpEvent);
    
            if (NDIS_STATUS_PENDING == NdisStatus)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
    
                //
                //  Get the completion status.
                //
                NdisStatus = EventReserved->Status;
            }
     
            if ((NetPnpEvent->NetEvent == NetEventQueryPower) &&
                (NDIS_STATUS_SUCCESS != NdisStatus) &&
                (NDIS_STATUS_NOT_SUPPORTED != NdisStatus))
            {
                DbgPrint("***NDIS***: Protocol %Z failed QueryPower %lx\n",
                        &Protocol->ProtocolCharacteristics.Name, NdisStatus);
            }
#if DBG
            if ((NetPnpEvent->NetEvent == NetEventSetPower) &&
                (*((PDEVICE_POWER_STATE)NetPnpEvent->Buffer) > PowerDeviceD0) &&
                (OPEN_TEST_FLAG(Open->MiniportHandle, fMINIPORT_RESET_IN_PROGRESS)) &&
                (Open->MiniportHandle->ResetOpen == Open))
            {
                DbgPrint("ndisPnPNotifyBinding: Protocol %p returned from SetPower with outstanding Reset.\n", Protocol);
                DbgBreakPoint();
            }
                
#endif
            
        }
        else 
        {
            if ((NetPnpEvent->NetEvent == NetEventQueryRemoveDevice) ||
                (NetPnpEvent->NetEvent == NetEventQueryPower) ||
                (NetPnpEvent->NetEvent == NetEventCancelRemoveDevice)
                )
            {
                //
                // since protocol at least has an UnbindHandler, we can unbind
                // it from the adapter if necessary
                //
                NdisStatus = NDIS_STATUS_SUCCESS;
                break;
            }
        }
        
        //
        // if the protocol does not have a PnPEventHandler or 
        // we tried to suspend a protocol and protocol returned NDIS_STATUS_NOT_SUPPORTED,
        // unbind the protocol
        //
        if ((NdisStatus == NDIS_STATUS_NOT_SUPPORTED) &&
            (NetPnpEvent->NetEvent == NetEventSetPower))
        {
            DeviceState = *((PDEVICE_POWER_STATE)NetPnpEvent->Buffer);
            
            switch (DeviceState)
            {
                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
                    if (!OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_UNBINDING | 
                                               fMINIPORT_OPEN_CLOSING)))
                    {
                        OPEN_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                                fMINIPORT_OPEN_DONT_FREE);
                        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
                        ndisUnbindProtocol(Open, Protocol, Open->MiniportHandle, FALSE);
                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
                    }
                    
                    NdisStatus = NDIS_STATUS_SUCCESS;
                    break;
                    
                default:
                    break;
            }
        }
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPNotifyBinding: Open %p\n", Open));
        
    return NdisStatus;
}



NTSTATUS
ndisPnPDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handler for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status = STATUS_SUCCESS;
    PDEVICE_OBJECT          NextDeviceObject = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    KEVENT                  RemoveReadyEvent;
    ULONG                   PnPDeviceState;
    PNDIS_MINIPORT_BLOCK*   ppMB;
    KIRQL                   OldIrql;
    BOOLEAN                 fSendIrpDown = TRUE;
    BOOLEAN                 fCompleteIrp = TRUE;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisPnPDispatch: DeviceObject %p, Irp %p\n", DeviceObject, Irp));
    
    PnPReferencePackage();

    //
    //  Get a pointer to the miniport block
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    ASSERT(Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE);
    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: DeviceObject %p, Irp %p, Device extension is not a miniport.\n", 
                                DeviceObject, Irp));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        fSendIrpDown = FALSE;       
        goto Done;
    }

    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = Miniport->NextDeviceObject;

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("ndisPnPDispatch: Miniport %p, IrpSp->MinorFunction: %lx\n", Miniport, IrpSp->MinorFunction));

    switch(IrpSp->MinorFunction)
    {
        //
        // for Memphis the following IRPs are handled by handling the corresponding
        // Config Manager message:
        //
        // IRP_MN_START_DEVICE                  CONFIG_START
        // IRP_MN_QUERY_REMOVE_DEVICE           CONFIG_TEST/CONFIG_TEST_CAN_REMOVE
        // IRP_MN_CANCEL_REMOVE_DEVICE          CONFIG_TEST_FAILED/CONFIG_TEST_CAN_REMOVE
        // IRP_MN_REMOVE_DEVICE                 CONFIG_REMOVE
        // IRP_MN_QUERY_STOP_DEVICE             CONFIG_TEST/CONFIG_TEST_CAN_STOP
        // IRP_MN_CANCEL_STOP_DEVICE            CONFIG_TEST_FAILED/CONFIG_TEST_CAN_STOP
        // IRP_MN_STOP_DEVICE                   CONFIG_STOP
        // IRP_MN_SURPRISE_REMOVAL
        //
        case IRP_MN_START_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_START_DEVICE\n", Miniport));

            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_RECEIVED_START);
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                if (Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
                {
                    NDIS_HANDLE DeviceContext;

                    //
                    // for layered miniport drivers, have to check to see
                    // if we got InitializeDeviceInstance
                    //
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
                    if (ndisIMCheckDeviceInstance(Miniport->DriverHandle,
                                                  &Miniport->MiniportName,
                                                  &DeviceContext))
                    {
                        WAIT_FOR_OBJECT(&Miniport->DriverHandle->IMStartRemoveMutex, NULL);
                        Status = ndisIMInitializeDeviceInstance(Miniport, DeviceContext, TRUE);
                        RELEASE_MUTEX(&Miniport->DriverHandle->IMStartRemoveMutex);
                        
                    }
                }
                else
                {
                    Status = ndisPnPStartDevice(DeviceObject, Irp);
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
                            !ndisMediaTypeCl[Miniport->MediaType] &&
                            (Miniport->MediaType != NdisMediumWan))
                        {
                            UNICODE_STRING  NDProxy;

                            RtlInitUnicodeString(&NDProxy, NDIS_PROXY_SERVICE);
                            ZwLoadDriver(&NDProxy);
                        }
                        if (ndisProtocolList != NULL)
                        {
                            ndisQueueBindWorkitem(Miniport);
                        }
                    }
                    else
                    {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }                   
            }

            Irp->IoStatus.Status = Status;
            fSendIrpDown = FALSE;   // we already did send the IRP down
            break;
        
        case IRP_MN_QUERY_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_REMOVE_DEVICE\n", Miniport));

            Miniport->OldPnPDeviceState = Miniport->PnPDeviceState;
            Miniport->PnPDeviceState = NdisPnPDeviceQueryRemoved;
            
            Status = ndisPnPQueryRemoveDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = Status;
            //
            // if we failed query_remove, no point sending this irp down
            //
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
        
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_CANCEL_REMOVE_DEVICE\n", Miniport));

            Status = ndisPnPCancelRemoveDevice(DeviceObject,Irp);

            if (NT_SUCCESS(Status))
            {
                Miniport->PnPDeviceState = Miniport->OldPnPDeviceState;
            }
            
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_REMOVE_DEVICE\n", Miniport));
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            PnPDeviceState = Miniport->PnPDeviceState;
            
            if (PnPDeviceState != NdisPnPDeviceSurpriseRemoved)
            {
                Miniport->PnPDeviceState = NdisPnPDeviceRemoved;
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);

                //
                // initialize an event and signal when all the wotrkitems have fired.
                //
                if (MINIPORT_INCREMENT_REF(Miniport))
                {
                    INITIALIZE_EVENT(&RemoveReadyEvent);
                    Miniport->RemoveReadyEvent = &RemoveReadyEvent;
                }
                else
                {
                    Miniport->RemoveReadyEvent = NULL;
                }
                
                Status = ndisPnPRemoveDevice(DeviceObject, Irp);

                if (Miniport->RemoveReadyEvent != NULL)
                {
                    MINIPORT_DECREMENT_REF(Miniport);
                    WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
                }

                ASSERT(Miniport->Ref.ReferenceCount == 0);

                Irp->IoStatus.Status = Status;
            }
            else
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);

            if (Miniport->pAdapterInstanceName != NULL)
            {
                FREE_POOL(Miniport->pAdapterInstanceName);
                Miniport->pAdapterInstanceName = NULL;
            }

            if (Miniport->SecurityDescriptor)
            {
                FREE_POOL(Miniport->SecurityDescriptor);
                Miniport->SecurityDescriptor = NULL;
            }
            //
            // remove miniport from global miniport list
            //
            ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
            for (ppMB = &ndisMiniportList; *ppMB != NULL; ppMB = &(*ppMB)->NextGlobalMiniport)
            {
                if (*ppMB == Miniport)
                {
                    *ppMB = Miniport->NextGlobalMiniport;
                    break;
                }
            }
            RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);

            if (Miniport->BindPaths != NULL)
            {
                FREE_POOL(Miniport->BindPaths);
            }

            if (Miniport->BusInterface != NULL)
            {
                FREE_POOL(Miniport->BusInterface);
            }

            ASSERT(Miniport->SystemAdapterObject == NULL);

            IoDetachDevice(Miniport->NextDeviceObject);
            IoDeleteDevice(Miniport->DeviceObject);
            
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
            break;
            
        case IRP_MN_SURPRISE_REMOVAL:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_SURPRISE_REMOVAL\n", Miniport));
                
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            //
            // let the miniport know the hardware is gone asap
            //
            if (ndisIsMiniportStarted(Miniport) &&
                (Miniport->PnPDeviceState == NdisPnPDeviceStarted) &&
                (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED)) &&
                (Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL))
            {
                Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(Miniport->MiniportAdapterContext,
                                                                                      NdisDevicePnPEventSurpriseRemoved,
                                                                                      NULL,
                                                                                      0);
            }           

            Miniport->PnPDeviceState = NdisPnPDeviceSurpriseRemoved;
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);


            //
            // initialize an event and signal when all the wotrkitems have fired.
            //
            if (MINIPORT_INCREMENT_REF(Miniport))
            {
                INITIALIZE_EVENT(&RemoveReadyEvent);
                Miniport->RemoveReadyEvent = &RemoveReadyEvent;
            }
            else
            {
                Miniport->RemoveReadyEvent = NULL;
            }
            
            Status = ndisPnPRemoveDevice(DeviceObject, Irp);

            if (Miniport->RemoveReadyEvent != NULL)
            {
                MINIPORT_DECREMENT_REF(Miniport);
                WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
            }           

            ASSERT(Miniport->Ref.ReferenceCount == 0);

            Irp->IoStatus.Status = Status;

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
                
            break;
        
        case IRP_MN_QUERY_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_STOP_DEVICE\n", Miniport));

            Miniport->OldPnPDeviceState = Miniport->PnPDeviceState;
            Miniport->PnPDeviceState = NdisPnPDeviceQueryStopped;
            
            Status = ndisPnPQueryStopDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Adapter %p, IRP_MN_CANCEL_STOP_DEVICE\n", Miniport));

            Status = ndisPnPCancelStopDevice(DeviceObject,Irp);
            
            if (NT_SUCCESS(Status))
            {
                Miniport->PnPDeviceState = Miniport->OldPnPDeviceState;
            }
            
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisPnPDispatch: Miniport %p, IRP_MN_STOP_DEVICE\n", Miniport));

            Miniport->PnPDeviceState = NdisPnPDeviceStopped;
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);
            
            //
            // initialize an event and signal when
            // all the wotrkitems have fired.
            //
            if (MINIPORT_INCREMENT_REF(Miniport))
            {
                INITIALIZE_EVENT(&RemoveReadyEvent);
                Miniport->RemoveReadyEvent = &RemoveReadyEvent;
                Miniport->PnPDeviceState = NdisPnPDeviceStopped;
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            }
            else
            {
                Miniport->RemoveReadyEvent = NULL;
            }
            
            Status = ndisPnPStopDevice(DeviceObject, Irp);
            
            if (Miniport->RemoveReadyEvent != NULL)
            {
                MINIPORT_DECREMENT_REF(Miniport);
                WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
            }

            ASSERT(Miniport->Ref.ReferenceCount == 0);
    
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;


        case IRP_MN_QUERY_CAPABILITIES:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport, IRP_MN_QUERY_CAPABILITIES\n", Miniport));

            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM) ||
                (Miniport->MiniportAttributes & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK))
            {
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            }
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status) && 
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM) &&
                !(Miniport->MiniportAttributes & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK))
            {
                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisPnPDispatch: Miniport %p, Clearing the SupriseRemovalOk bit.\n", Miniport));

                //
                //  Modify the capabilities so that the device is not suprise removable.
                //                                                
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 0;
            }

            fSendIrpDown = FALSE;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:

            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
            {
                Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
            }
            
            //
            //  Check to see if a power up failed. 
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED))
            {
                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_PNP_DEVICE_STATE device failed\n", Miniport));

                //
                //  Mark the device as having failed so that pnp will remove it.
                //
                Irp->IoStatus.Information |= PNP_DEVICE_FAILED;
            }
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE ;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_ID:
        default:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, MinorFunction 0x%x\n", Miniport, IrpSp->MinorFunction));

            //
            //  We don't handle the irp so pass it down.
            //
            fSendIrpDown = TRUE;
            break;          
    }

Done:
    //
    //  First check to see if we need to send the irp down.
    //  If we don't pass the irp on then check to see if we need to complete it.
    //
    if (fSendIrpDown && NextDeviceObject)
    {
        IoSkipCurrentIrpStackLocation(Irp);
        Status = IoCallDriver(NextDeviceObject, Irp);
    }
    else if (fCompleteIrp)
    {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPnPDispatch: Miniport %p\n", Miniport));

    return(Status);
}

NDIS_STATUS
NdisIMNotifyPnPEvent(
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NET_PNP_EVENT_CODE      NetEvent = NetPnPEvent->NetEvent;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>NdisIMNotifyPnPEvent: Miniport %p, NetEvent %lx\n", Miniport, NetEvent));

    switch (NetEvent)
    {
      case NetEventQueryPower:
      case NetEventQueryRemoveDevice:
      case NetEventCancelRemoveDevice:
      case NetEventPnPCapabilities:
        //
        // indicate up to the protocols
        //
        Status = ndisPnPNotifyAllTransports(
                            Miniport,
                            NetPnPEvent->NetEvent,
                            NetPnPEvent->Buffer,
                            NetPnPEvent->BufferLength);
                            
        break;
      
      case NetEventSetPower:
      case NetEventReconfigure:
      case NetEventBindList:
      case NetEventBindsComplete:
      default:
        //
        // ignore
        //
        break;
    }

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==NdisIMNotifyPnPEvent: Miniport %p, NetEvent %lx, Status %lx\n", Miniport, NetEvent, Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndistags.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndistags.h

Abstract:

    List of pool tags used by the NDIS Wraper.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Mar-96  Jameel Hyder    Initial version
--*/

#ifndef _NDISTAGS_
#define _NDISTAGS_

#define NDIS_TAG_DEFAULT                    '  DN'
#define NDIS_TAG_WORK_ITEM                  'iwDN'
#define NDIS_TAG_NAME_BUF                   'naDN'
#define NDIS_TAG_CO                         'ocDN'
#define NDIS_TAG_DMA                        'bdDN'
#define NDIS_TAG_ALLOC_MEM                  'maDN'
#define NDIS_TAG_ALLOC_MEM_VERIFY_ON        'mvDN'
#define NDIS_TAG_SLOT_INFO                  'isDN'
#define NDIS_TAG_PKT_POOL                   'ppDN'
#define NDIS_TAG_RSRC_LIST                  'lrDN'
#define NDIS_TAG_LOOP_PKT                   'plDN'
#define NDIS_TAG_Q_REQ                      'qrDN'
#define NDIS_TAG_PROT_BLK                   'bpDN'
#define NDIS_TAG_OPEN_BLK                   'boDN'
#define NDIS_TAG_M_OPEN_BLK                 'omDN'
#define NDIS_TAG_DFRD_TMR                   'tdDN'
#define NDIS_TAG_LA_BUF                     'blDN'
#define NDIS_TAG_MAP_REG                    'rmDN'
#define NDIS_TAG_MINI_BLOCK                 'bmDN'
#define NDIS_TAG_DBG                        ' dDN'
#define NDIS_TAG_DBG_S                      'sdDN'
#define NDIS_TAG_DBG_L                      'ldDN'
#define NDIS_TAG_DBG_P                      'pdDN'
#define NDIS_TAG_DBG_LOG                    'lDDN'
#define NDIS_TAG_FILTER                     'fpDN'
#define NDIS_TAG_STRING                     'tsDN'
#define NDIS_TAG_PKT_PATTERN                'kpDN'
#define NDIS_TAG_FILTER_ADDR                'afDN'
#define NDIS_TAG_WMI_REG_INFO               '0wDN'
#define NDIS_TAG_WMI_GUID_TO_OID            '1wDN'
#define NDIS_TAG_WMI_OID_SUPPORTED_LIST     '2wDN'
#define NDIS_TAG_WMI_EVENT_ITEM             '3wDN'
#define NDIS_TAG_REGISTRY_PATH              'prDN'
#define NDIS_TAG_OID_ARRAY                  'aoDN'
#define NDIS_TAG_SHARED_MEMORY              'hsDN'
#define NDIS_TAG_ARC_BUFFER                 'baDN'
#define NDIS_TAG_ARC_DATA                   'daDN'
#define NDIS_TAG_ARC_PACKET                 'paDN'
#define NDIS_TAG_ARC_BINDING_INFO           'iaDN'
#define NDIS_TAG_FILE_NAME                  'nfDN'
#define NDIS_TAG_FILE_IMAGE                 'ifDN'
#define NDIS_TAG_FILE_DESCRIPTOR            'dfDN'
#define NDIS_TAG_WRAPPER_HANDLE             'hwDN'
#define NDIS_TAG_ALLOC_SHARED_MEM_ASYNC     'saDN'
#define NDIS_TAG_FREE_SHARED_MEM_ASYNC      'sfDN'
#define NDIS_TAG_ALLOCATED_RESOURCES        'raDN'
#define NDIS_TAG_BUS_INTERFACE              'ibDN'
#define NDIS_TAG_CONFIG_HANLDE              'hcDN'
#define NDIS_TAG_PARAMETER_NODE             'npDN'
#define NDIS_TAG_REG_READ_DATA_BUFFER       'drDN'
#define NDIS_TAG_IM_DEVICE_INSTANCE         'idDN'
#define NDIS_TAG_CANCEL_DEVICE_NAME         'ncDN'
#define NDIS_TAG_OPEN_CONTEXT               'coDN'
#define NDIS_TAG_ARC_SEND_BUFFERS           'faDN'
#define NDIS_TAG_MEDIA_TYPE_ARRAY           'tmDN'
#define NDIS_TAG_PROTOCOL_CONFIGURATION     'cpDN'
#define NDIS_TAG_DOUBLE_BUFFER_PKT          'gsDN'
#define NDIS_TAG_FAKE_MAC                   'mfDN'
#define NDIS_TAG_NET_CFG_OPS_ID             'scDN'
#define NDIS_TAG_NET_CFG_OPS_ACL            'acDN'
#define NDIS_TAG_NET_CFG_SEC_DESC           'dsDN'
#define NDIS_TAG_NET_CFG_DACL               'adDN'
#define NDIS_TAG_SECURITY                   'esDN'

#endif	// _NDISTAGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndissd.c ===
#include "precomp.h"

typedef ULONG SECURITY_INFORMATION;

NTSTATUS
AddNetConfigOpsAce(IN PACL Dacl,
                  OUT PACL * DeviceAcl
                  )
/*++

Routine Description:

    This routine builds an ACL which adds the Network Configuration Operators group
    to the principals allowed to control the driver.

Arguments:

    Dacl - Existing DACL.
    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID NetConfigOpsSid = NULL;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl = NULL;
    ULONG SidSize;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    PISID ISid;
    PACCESS_ALLOWED_ACE AceTemp;
    int i;
    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    SidSize = RtlLengthRequiredSid(2);
    NetConfigOpsSid = (PSID)(ExAllocatePoolWithTag(PagedPool,SidSize, NDIS_TAG_NET_CFG_OPS_ID));

    if (NULL == NetConfigOpsSid) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    Status = RtlInitializeSid(NetConfigOpsSid, &sidAuth, 2);
    if (Status != STATUS_SUCCESS) {
		goto clean_up;
    }

    ISid = (PISID)(NetConfigOpsSid);
    ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

    AclLength = Dacl->AclSize;
    
    AclLength += sizeof(ACL) + FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart);
    AclLength += RtlLengthSid(NetConfigOpsSid);

    NewAcl = ExAllocatePoolWithTag(
                            PagedPool,
                            AclLength,
                            NDIS_TAG_NET_CFG_OPS_ACL
                            );

    if (NewAcl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto clean_up;
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION2);

    if (!NT_SUCCESS(Status)) {
        goto clean_up;
    }

    for (i = 0; i < Dacl->AceCount; i++) {
        Status = RtlGetAce(Dacl, i, &AceTemp);

        if (NT_SUCCESS(Status)) {

            Status = RtlAddAccessAllowedAce(NewAcl,
                                            ACL_REVISION2,
                                            AceTemp->Mask,
                                            &AceTemp->SidStart);
        }

        if (!NT_SUCCESS(Status)) {
            goto clean_up;
        }
    }


    // Add Net Config Operators Ace
    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    NetConfigOpsSid);

    if (!NT_SUCCESS(Status)) {
		goto clean_up;
    }

    *DeviceAcl = NewAcl;

clean_up:
	if (NetConfigOpsSid) {
		ExFreePool(NetConfigOpsSid);
	}
	if (!NT_SUCCESS(Status) && NewAcl) {
		ExFreePool(NewAcl);
	}

    return (Status);
}


NTSTATUS
CreateDeviceDriverSecurityDescriptor(
    IN  PVOID           DeviceOrDriverObject,
    IN  BOOLEAN         AddNetConfigOps,
    IN  PACL            AclToAdd OPTIONAL
    )

/*++

Routine Description:

    Creates the SD responsible for giving access to different users.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS status;
    BOOLEAN memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR sdSecurityDescriptor = NULL;
    PACL paclDacl = NULL;
    BOOLEAN bHasDacl;
    BOOLEAN bDaclDefaulted;
    PACL NewAcl = NULL;
    
    //
    // Get a pointer to the security descriptor from the driver/device object.
    //

    status = ObGetObjectSecurity(
                                 DeviceOrDriverObject,
                                 &sdSecurityDescriptor,
                                 &memoryAllocated
                                 );

    if (!NT_SUCCESS(status)) 
    {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                 "TCP: Unable to get security descriptor, error: %x\n",
                 status
                ));
        ASSERT(memoryAllocated == FALSE);
        return (status);
    }

    status = RtlGetDaclSecurityDescriptor(sdSecurityDescriptor, 
                                          &bHasDacl, 
                                          &paclDacl, 
                                          &bDaclDefaulted);

    if (NT_SUCCESS(status))
    {
        if (bHasDacl)
        {
            if (AddNetConfigOps && paclDacl)
            {
                status = AddNetConfigOpsAce(paclDacl, &NewAcl);
            }
            else if (AclToAdd)
            {
                NewAcl = AclToAdd;
            }
            else
            {
                return STATUS_UNSUCCESSFUL;
            }

            ASSERT(NT_SUCCESS(status));
            
            if (NT_SUCCESS(status))
            {
                PSECURITY_DESCRIPTOR sdSecDesc = NULL;
                ULONG ulSecDescSize = 0;
                PACL daclAbs = NULL;
                ULONG ulDacl = 0;
                PACL saclAbs = NULL;
                ULONG ulSacl = 0;
                PSID Owner = NULL;
                ULONG ulOwnerSize = 0;
                PSID PrimaryGroup = NULL;
                ULONG ulPrimaryGroupSize = 0;
                BOOLEAN bOwnerDefault;
                BOOLEAN bGroupDefault;
                BOOLEAN HasSacl = FALSE;
                BOOLEAN SaclDefaulted = FALSE;
                SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | 
                                               GROUP_SECURITY_INFORMATION | 
                                               DACL_SECURITY_INFORMATION;

                ulSecDescSize = sizeof(SECURITY_DESCRIPTOR) + NewAcl->AclSize;
                sdSecDesc = ExAllocatePoolWithTag(PagedPool, 
                                                  ulSecDescSize, 
                                                  NDIS_TAG_NET_CFG_SEC_DESC);

                if (sdSecDesc)
                {
                    ulDacl = NewAcl->AclSize;
                    daclAbs = ExAllocatePoolWithTag(PagedPool, 
                                                    ulDacl, 
                                                    NDIS_TAG_NET_CFG_DACL);

                    if (daclAbs)
                    {
                        status = RtlGetOwnerSecurityDescriptor(sdSecurityDescriptor, 
                                                               &Owner, 
                                                               &bOwnerDefault);

                        if (NT_SUCCESS(status))
                        {
                            ulOwnerSize = RtlLengthSid(Owner);

                            status = RtlGetGroupSecurityDescriptor(sdSecurityDescriptor, 
                                                                   &PrimaryGroup, 
                                                                   &bGroupDefault);

                            if (NT_SUCCESS(status))
                            {
                                status = RtlGetSaclSecurityDescriptor(sdSecurityDescriptor, 
                                                                      &HasSacl, 
                                                                      &saclAbs, 
                                                                      &SaclDefaulted);

                                if (NT_SUCCESS(status))
                                {
                                    if (HasSacl) 
                                    {
                                        ulSacl = saclAbs->AclSize;
                                        secInfo |= SACL_SECURITY_INFORMATION;
                                    }

                                    ulPrimaryGroupSize= RtlLengthSid(PrimaryGroup);

                                    status = RtlSelfRelativeToAbsoluteSD(sdSecurityDescriptor, 
                                                                         sdSecDesc, 
                                                                         &ulSecDescSize, 
                                                                         daclAbs,
                                                                         &ulDacl, 
                                                                         saclAbs, 
                                                                         &ulSacl, 
                                                                         Owner, 
                                                                         &ulOwnerSize, 
                                                                         PrimaryGroup, 
                                                                         &ulPrimaryGroupSize);

                                    if (NT_SUCCESS(status))
                                    {
                                        status = RtlSetDaclSecurityDescriptor(sdSecDesc, TRUE, NewAcl, FALSE);

                                        if (NT_SUCCESS(status))
                                        {
                                            status = ObSetSecurityObjectByPointer(DeviceOrDriverObject, secInfo, sdSecDesc);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (sdSecDesc)
                    {
                        // Since this is a Self-Relative security descriptor, freeing it also frees
                        //  Owner and PrimaryGroup.
                        ExFreePool(sdSecDesc);
                    }

                    if (daclAbs)
                    {
                        ExFreePool(daclAbs);
                    }
                }

                if ((AclToAdd == NULL) && NewAcl)
                {
                    ExFreePool(NewAcl);
                }
            }
        }
        else
        {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"NDIS: No Dacl: %x\n", status));
        }
    }

    ObReleaseObjectSecurity(
                            sdSecurityDescriptor,
                            memoryAllocated
                            );

    return (status);
}

NTSTATUS
ndisBuildDeviceAcl(
    OUT PACL        *DeviceAcl,
    IN  BOOLEAN     AddNetConfigOps,
    IN  BOOLEAN     AddNetworkService
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators,  LocalSystem,
    and NetworkService principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS            Status;
    PGENERIC_MAPPING    GenericMapping;
    ULONG               AclLength;
    ACCESS_MASK         AccessMask = GENERIC_ALL;
    PACL                NewAcl;
    PSID                NetConfigOpsSid = NULL;
    ULONG               NetConfigOpsSidSize;
    SID_IDENTIFIER_AUTHORITY NetConfigOpsSidAuth = SECURITY_NT_AUTHORITY;
    PISID               ISid;


    do
    {
        //
        // Enable access to all the globally defined SIDs
        //

        GenericMapping = IoGetFileObjectGenericMapping();

        RtlMapGenericMask(&AccessMask, GenericMapping );

        
        AclLength = sizeof(ACL)                                 +
                    FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                    RtlLengthSid(SeExports->SeAliasAdminsSid);


        if (AddNetworkService)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeNetworkServiceSid);
        
        }


        if (AddNetConfigOps)
        {
            NetConfigOpsSidSize = RtlLengthRequiredSid(2);
            NetConfigOpsSid = (PSID)ALLOC_FROM_POOL(NetConfigOpsSidSize, NDIS_TAG_NET_CFG_OPS_ID);

            if (NULL == NetConfigOpsSid)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            Status = RtlInitializeSid(NetConfigOpsSid, &NetConfigOpsSidAuth, 2);
            if (Status != STATUS_SUCCESS)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ISid = (PISID)(NetConfigOpsSid);
            ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
            ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

            AclLength += RtlLengthSid(NetConfigOpsSid) + FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart);
        }        


        NewAcl = ALLOC_FROM_POOL(AclLength, NDIS_TAG_SECURITY);

        if (NewAcl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ZeroMemory(NewAcl, AclLength);
        
        Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION );

        if (!NT_SUCCESS(Status)) 
        {
            FREE_POOL(NewAcl);
            break;
        }

        Status = RtlAddAccessAllowedAce (
                     NewAcl,
                     ACL_REVISION2,
                     AccessMask,
                     SeExports->SeAliasAdminsSid
                     );

        ASSERT(NT_SUCCESS(Status));
        
        if (AddNetworkService)
        {
            Status = RtlAddAccessAllowedAce(
                                        NewAcl,
                                        ACL_REVISION2,
                                        AccessMask,
                                        SeExports->SeNetworkServiceSid
                                        );
            ASSERT(NT_SUCCESS(Status));
        }
        
        if (AddNetConfigOps)
        {
            // Add Net Config Operators Ace
            Status = RtlAddAccessAllowedAce(NewAcl,
                                            ACL_REVISION2,
                                            AccessMask,
                                            NetConfigOpsSid);
            ASSERT(NT_SUCCESS(Status));
        }

        *DeviceAcl = NewAcl;

        Status = STATUS_SUCCESS;
        
    }while (FALSE);

	if (NetConfigOpsSid)
	{
		ExFreePool(NetConfigOpsSid);
	}

    return(Status);

}


NTSTATUS
ndisCreateSecurityDescriptor(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PSECURITY_DESCRIPTOR *  pSecurityDescriptor,
    IN  BOOLEAN                 AddNetConfigOps,
    IN  BOOLEAN                 AddNetworkService
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to certain priviliged accounts. This descriptor is used
    to access check processes that open a handle to miniport device
    objects.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  devAcl = NULL;
    NTSTATUS              Status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  CurSecurityDescriptor;
    PSECURITY_DESCRIPTOR  NewSecurityDescriptor;
    ULONG                 CurSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR)buffer;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;
    BOOLEAN               bReleaseObjectSecurity = FALSE;


    do
    {

        *pSecurityDescriptor = NULL;
        
        //
        // Get a pointer to the security descriptor from the device object.
        //
        Status = ObGetObjectSecurity(
                     DeviceObject,
                     &CurSecurityDescriptor,
                     &memoryAllocated
                     );

        if (!NT_SUCCESS(Status))
        {
            ASSERT(memoryAllocated == FALSE);
            break;
        }
        bReleaseObjectSecurity = TRUE;

        //
        // Build a local security descriptor with an ACL giving only
        // certain priviliged accounts.
        //
        Status = ndisBuildDeviceAcl(&devAcl, AddNetConfigOps, AddNetworkService);

        if (!NT_SUCCESS(Status))
        {
            break;
        }
        //1  why (VOID)?
        (VOID)RtlCreateSecurityDescriptor(
                    localSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

        (VOID)RtlSetDaclSecurityDescriptor(
                    localSecurityDescriptor,
                    TRUE,
                    devAcl,
                    FALSE
                    );

        //
        // Make a copy of the security descriptor. This copy will be the raw descriptor.
        //
        CurSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                          CurSecurityDescriptor
                                          );

        NewSecurityDescriptor = ALLOC_FROM_POOL(CurSecurityDescriptorLength, NDIS_TAG_SECURITY);

        if (NewSecurityDescriptor == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlMoveMemory(
            NewSecurityDescriptor,
            CurSecurityDescriptor,
            CurSecurityDescriptorLength
            );

        *pSecurityDescriptor = NewSecurityDescriptor;

        //
        // Now apply the local descriptor to the raw descriptor.
        //
        Status = SeSetSecurityDescriptorInfo(
                     NULL,
                     &securityInformation,
                     localSecurityDescriptor,
                     pSecurityDescriptor,
                     NonPagedPool,
                     IoGetFileObjectGenericMapping()
                     );

        if (!NT_SUCCESS(Status))
        {
            ASSERT(*pSecurityDescriptor == NewSecurityDescriptor);
            FREE_POOL(*pSecurityDescriptor);
            *pSecurityDescriptor = NULL;
            break;
        }

        if (*pSecurityDescriptor != NewSecurityDescriptor)
        {
            ExFreePool(NewSecurityDescriptor);
        }
        
        Status = STATUS_SUCCESS;
    }while (FALSE);


    if (bReleaseObjectSecurity)
    {
        ObReleaseObjectSecurity(
            CurSecurityDescriptor,
            memoryAllocated
            );
    }
    
    if (devAcl!=NULL)
    {
        FREE_POOL(devAcl);
    }

    return(Status);
}

BOOLEAN
ndisCheckAccess (
    PIRP                    Irp,
    PIO_STACK_LOCATION      IrpSp,
    PNTSTATUS               Status,
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    )
/*++

Routine Description:

    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the creator has admin or local system privilige
    FALSE    - the creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );


    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                        SecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        AccessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}


NTSTATUS
ndisCreateGenericSD(
    PACL            Acl,
    PCHAR           AccessSecurityDescriptor
    )

/*++

Routine Description:

    Creates the SD responsible for giving access to different users.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PSECURITY_DESCRIPTOR    AccessSd;
    NTSTATUS                Status;

    if (Acl == NULL)
        return STATUS_UNSUCCESSFUL;
    
    do
    {
        AccessSd = AccessSecurityDescriptor;
        
        Status = RtlCreateSecurityDescriptor(
                     AccessSd,
                     SECURITY_DESCRIPTOR_REVISION1
                     );

        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlCreateSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }
        
        Status = RtlSetDaclSecurityDescriptor(
                     AccessSd,
                     TRUE,                       // DaclPresent
                     Acl,
                     FALSE                       // DaclDefaulted
                     );
        
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetDaclSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

        Status = RtlSetOwnerSecurityDescriptor(AccessSd,
                                               SeExports->SeAliasAdminsSid,
                                               FALSE);
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetOwnerSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

        Status = RtlSetGroupSecurityDescriptor(AccessSd,
                                               SeExports->SeAliasAdminsSid,
                                               FALSE);

        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetGroupSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

    }while (FALSE);

    return (Status);
}

PACL
ndisCreateAcl(
    BOOLEAN     Admins,
    BOOLEAN     LocalSystem,
    BOOLEAN     LocalService,
    BOOLEAN     NetworkService,
    BOOLEAN     NetConfigOps,
    BOOLEAN     Users,
    ACCESS_MASK AccessMask
    )
{
    PACL    AccessDacl = NULL, pAcl = NULL;
    ULONG   AclLength = 0;
    PSID    NetConfigOpsSid = NULL;
    ULONG   NetConfigOpsSidSize;
    SID_IDENTIFIER_AUTHORITY NetConfigOpsSidAuth = SECURITY_NT_AUTHORITY;
    PISID               ISid;
    NTSTATUS            Status;
    

    do
    {
        if (Admins)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeAliasAdminsSid);

        }

        if (LocalSystem)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeLocalSystemSid);

        }
        
        if (LocalService)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeLocalServiceSid);

        }
        
        if (NetworkService)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeNetworkServiceSid);

        }

        if (NetConfigOps)
        {
            NetConfigOpsSidSize = RtlLengthRequiredSid(2);
            NetConfigOpsSid = (PSID)ALLOC_FROM_POOL(NetConfigOpsSidSize, NDIS_TAG_NET_CFG_OPS_ID);

            if (NULL == NetConfigOpsSid)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            Status = RtlInitializeSid(NetConfigOpsSid, &NetConfigOpsSidAuth, 2);
            if (Status != STATUS_SUCCESS)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ISid = (PISID)(NetConfigOpsSid);
            ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
            ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) + 
                         RtlLengthSid(NetConfigOpsSid);

        }

        if (Users)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeAliasUsersSid);

        }

        AccessDacl = (PACL)ExAllocatePoolWithTag(PagedPool,
                                                 AclLength,
                                                 NDIS_TAG_SECURITY);
        
        if (AccessDacl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = RtlCreateAcl(AccessDacl,
                              AclLength,
                              ACL_REVISION2);
        
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlCreateAcl failed, Status %lx.\n", Status);
            break;
        }


        if (Admins)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeAliasAdminsSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }
        }

        if (LocalSystem)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeLocalSystemSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }
        }
        
        if (LocalService)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeLocalServiceSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }

        }
        
        if (NetworkService)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeNetworkServiceSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }
        }

        if (NetConfigOps)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        NetConfigOpsSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }

        }

        if (Users)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        AccessMask,
                                        SeExports->SeAliasUsersSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }            
        }
        
        pAcl = AccessDacl;
        
    }while (FALSE);

    if (pAcl == NULL)
    {
        if (AccessDacl)
            FREE_POOL(AccessDacl);
    }
    
    return pAcl;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndiswmi.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndiswmi.c

Abstract:

    This module contains the routines necessary to process IRPs sent under the
    IRP_MJ_SYSTEM_CONTROL major code.

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#define MODULE_NUMBER MODULE_WMI

#define MOF_RESOURCE_NAME   L"NdisMofResource"

NTSTATUS
ndisWmiFindInstanceName(
    IN  PNDIS_CO_VC_PTR_BLOCK   *ppVcBlock,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWSTR                   pInstanceName,
    IN  USHORT                  cbInstanceName
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PLIST_ENTRY             Link;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;
    UNICODE_STRING          usTemp;

    *ppVcBlock = NULL;
    

    usTemp.Buffer = pInstanceName;
    usTemp.Length = usTemp.MaximumLength = cbInstanceName;

    //
    //  See if this is a VC instance ?
    //
    if (pInstanceName[VC_ID_INDEX] == VC_IDENTIFIER)
    {

        //
        //  The request is for some VC. Go through the Miniport's list of WMI enabled VCs.
        //
        Link = Miniport->WmiEnabledVcs.Flink;
        while (Link != &Miniport->WmiEnabledVcs)
        {
            //
            //  Get a pointer to the VC.
            //
            pVcBlock = CONTAINING_RECORD(Link, NDIS_CO_VC_PTR_BLOCK, WmiLink);

            //
            //  Check the name with the one in the wnode.
            //
            if (RtlEqualUnicodeString(&pVcBlock->VcInstanceName, &usTemp, TRUE))
            {
                //
                //  This is our baby. Slap a reference on it and get out.
                //  
                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisWmiFindInstanceName: Unable to reference the VC\n"));

                    //
                    //  VC is closing, can't query this one.
                    //
                    Status = NDIS_STATUS_FAILURE;
                }

                break;
            }

            //
            //  Initialize this so that we know when we've found the VC in the outer loop.
            //
            pVcBlock = NULL;
            Link = Link->Flink;
        }

        //
        //  If we didn't find the VC then return FAILURE.
        //
        if (Link == &Miniport->WmiEnabledVcs)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWmiFindInstanceName: Could not verify the instance name passed in\n"));

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }

        //
        //  If we found the VC then save it before leaving.
        //  
        if (NT_SUCCESS(Status))
        {
            *ppVcBlock = pVcBlock;
        }
    }
    else
    {

        //
        //  The name belongs to a miniport, check to see if it is for this one.
        //

        if (!RtlEqualUnicodeString(Miniport->pAdapterInstanceName, &usTemp, TRUE))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiFindInstanceName: Invalid instance name\n"));

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
    }

    return(Status);
}

BOOLEAN
ndisWmiGuidIsAdapterSpecific(
    IN  LPGUID  guid
    )
{
    BOOLEAN fAdapterOnly = FALSE;

    if (NdisEqualMemory(guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
    {
        fAdapterOnly = TRUE;
    }

    return(fAdapterOnly);
}

NDIS_STATUS
ndisQuerySetMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock,
    IN  BOOLEAN                 fSet,
    IN  PNDIS_REQUEST           pRequest,
    IN  PLARGE_INTEGER          pTime       OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN                 fQuery = !fSet;
    UINT                    Count;
    NDIS_STATUS             NdisStatus;
    PNDIS_COREQ_RESERVED    CoReqRsvd;

    PnPReferencePackage();

#define MAX_WAIT_COUNT  5000
#define WAIT_TIME       1000

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | fMINIPORT_PM_HALTED))
    {
        PnPDereferencePackage();
        return (fQuery ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS);
    }

    //
    //  Initialize the co-request reserved information.
    //
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(pRequest);

    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Open = NULL;

    //
    // preserve the mandatory setting on request
    //
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Flags &= REQST_MANDATORY;
    
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Flags |= REQST_SIGNAL_EVENT;
    INITIALIZE_EVENT(&CoReqRsvd->Event);

    //
    // If the miniport is being reset, then wait for the reset to complete before going any further.
    // Make sure we do not wait indefinitely either
    //
    for (Count = 0; Count < MAX_WAIT_COUNT; Count ++)
    {
        if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_RESET_REQUESTED)))
        {
            break;
        }
        NdisMSleep(WAIT_TIME);  // 1 msec
    }

    if (Count == MAX_WAIT_COUNT)
    {
        PnPDereferencePackage();
        return(NDIS_STATUS_RESET_IN_PROGRESS);
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        NDIS_HANDLE MiniportVcContext = NULL;

        do
        {
            if (NULL != pVcBlock)
            {
                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    NdisStatus = NDIS_STATUS_CLOSING;
                    break;
                }
                else
                {
                    MiniportVcContext = pVcBlock->MiniportContext;
                }
            }
                        
            NdisStatus = Miniport->DriverHandle->MiniportCharacteristics.CoRequestHandler(
                            Miniport->MiniportAdapterContext,
                            MiniportVcContext,
                            pRequest);
    
            if (NDIS_STATUS_PENDING == NdisStatus)
            {
                WAIT_FOR_OBJECT(&CoReqRsvd->Event, pTime);
    
                //
                //  Get the status that the miniport returned.
                //
                NdisStatus = CoReqRsvd->Status;
            }

            if (NULL != pVcBlock)
            {
                ndisDereferenceVcPtr(pVcBlock);
            }
        } while (FALSE);
    }
    else
    {
        if ((fSet && (Miniport->DriverHandle->MiniportCharacteristics.SetInformationHandler != NULL)) ||
            (fQuery && (Miniport->DriverHandle->MiniportCharacteristics.QueryInformationHandler != NULL)))
        {
            BOOLEAN LocalLock;
            KIRQL   OldIrql;

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
            ndisMQueueRequest(Miniport, pRequest);
    
            LOCK_MINIPORT(Miniport, LocalLock);

            if (LocalLock || MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                ndisMDoRequests(Miniport);
            }
            else
            {
                //
                //  Queue the miniport request and wait for it to complete.
                //
                NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
            }
            UNLOCK_MINIPORT(Miniport, LocalLock);
    
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
            if (NT_SUCCESS(WAIT_FOR_OBJECT(&CoReqRsvd->Event, pTime)))
            {
                //
                //  Get the status that the miniport returned.
                //
                NdisStatus = CoReqRsvd->Status;
            }
            else
            {
                NdisStatus = -1;    // Special error-code to return time-out
            }
        }
        else
        {
            //
            //  If there isn't a proper handler then this is not a valid request.
            //  
            NdisStatus = STATUS_INVALID_PARAMETER;
        }
    }

    PnPDereferencePackage();

    return(NdisStatus);
}

NDIS_STATUS
ndisQueryCustomGuids(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request,
    OUT PNDIS_GUID      *       ppGuidToOid,
    OUT PUSHORT                 pcGuidToOid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT          BytesNeeded;
    NDIS_STATUS     Status;
    USHORT          c, cCustomGuids = 0;
    PNDIS_GUID      pGuidToOid = NULL;
    SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | 
                                   GROUP_SECURITY_INFORMATION | 
                                   DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR    SecurityDescriptorToSet;
    PVOID                   pGuidObject;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
            ("==>ndisQueryCustomGuids\n"));

    *ppGuidToOid = NULL;
    *pcGuidToOid = 0;

    do
    {
        //
        //  Determine the size needed for the custom GUID to OID map.
        //
#if (OID_GEN_CO_SUPPORTED_GUIDS != OID_GEN_SUPPORTED_GUIDS)
#error (OID_GEN_CO_SUPPORTED_GUIDS == OID_GEN_SUPPORTED_GUIDS)
#endif

        INIT_INTERNAL_REQUEST(Request, OID_GEN_SUPPORTED_GUIDS, NdisRequestQueryInformation, NULL, 0);
        Status = ndisQuerySetMiniport(Miniport, NULL, FALSE, Request, NULL);

        BytesNeeded = (USHORT)Request->DATA.QUERY_INFORMATION.BytesNeeded;
    
        //
        //  If the miniport has custom GUIDs then make sure it returned a valid
        //  length for the BytesNeeded.
        //
        if (((NDIS_STATUS_INVALID_LENGTH == Status) ||
             (NDIS_STATUS_BUFFER_TOO_SHORT == Status)) && (0 != BytesNeeded))
        {
            //
            //  Bytes needed should contain the amount of space needed.
            //
            cCustomGuids = (BytesNeeded / sizeof(NDIS_GUID));
        }

        //
        //  If there are no custom GUIDs to support then get out.
        //
        if (cCustomGuids == 0)
        {   
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQueryCustomGuids: Miniport does not support custom GUIDS\n"));

            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }


        //
        //  Allocate a buffer to hold the GUID to OID mapping
        //  for the custom GUIDs.
        //
        pGuidToOid = ALLOC_FROM_POOL(BytesNeeded, NDIS_TAG_WMI_GUID_TO_OID);
        if (NULL == pGuidToOid)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryCustomGuids: Unable to allocate memory for the GUID to OID map\n"));

            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Query the list of GUIDs
        //
        //
        //  Store the buffer with the request.
        //
        Request->DATA.QUERY_INFORMATION.InformationBuffer = pGuidToOid;
        Request->DATA.QUERY_INFORMATION.InformationBufferLength = BytesNeeded;

        //
        //  Query for the list of custom GUIDs and OIDs.
        //
        Status = ndisQuerySetMiniport(Miniport, NULL, FALSE, Request, NULL);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryCustomGuids: Unable to get the list of supported Co GUIDs\n"));

            break;
        }

        //
        //  Go through this list and mark the guids as co.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            for (c = 0; c < cCustomGuids; c++)
            {
                //1 is this right? is every private guid on a coNDIS miniport
                //1 is a CO_NDIS guid (associated with a VC)?
                NDIS_GUID_SET_FLAG(&pGuidToOid[c], fNDIS_GUID_CO_NDIS);
            }
        }


        //
        // go through all the custom guids and set the security attributes
        //
        for (c = 0; c < cCustomGuids; c++)
        {
            //
            // 
            if ((pGuidToOid[c].Flags & (fNDIS_GUID_ALLOW_READ | fNDIS_GUID_ALLOW_WRITE)) == 
                                      (fNDIS_GUID_ALLOW_READ | fNDIS_GUID_ALLOW_WRITE))
            {
                //
                // everyone
                //
                SecurityDescriptorToSet = AllUsersReadWriteSecurityDescriptor;
            }
            else if (pGuidToOid[c].Flags & fNDIS_GUID_ALLOW_READ)
            {
                SecurityDescriptorToSet = AllUsersReadSecurityDescriptor;
            }
            else if (pGuidToOid[c].Flags & fNDIS_GUID_ALLOW_WRITE)
            {
                SecurityDescriptorToSet = AllUsersWriteSecurityDescriptor;
            }
            else
            {
                //
                // admin, local system, etc. only
                //
                SecurityDescriptorToSet = AdminsSecurityDescriptor;
            }

            Status = IoWMIOpenBlock(&pGuidToOid[c].Guid,
                                    WRITE_DAC,
                                    &pGuidObject);
            
            if (NT_SUCCESS(Status))
            {
                Status = ObSetSecurityObjectByPointer(pGuidObject, 
                                                      secInfo, 
                                                      SecurityDescriptorToSet);
                ObDereferenceObject(pGuidObject);
                
            }

        }

    } while (FALSE);

    if (NDIS_STATUS_SUCCESS == Status)
    {
        *ppGuidToOid = pGuidToOid;
        *pcGuidToOid = cCustomGuids;
    }
    else
    {
        if (NULL != pGuidToOid)
        {
            FREE_POOL(pGuidToOid);
        }
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
            ("<==ndisQueryCustomGuids\n"));

    return(Status);
}

USHORT
ndisWmiMapOids(
    IN  OUT PNDIS_GUID  pDst,
    IN  IN  USHORT      cDst,
    IN      PNDIS_OID   pOidList,
    IN      USHORT      cOidList,
    IN      PNDIS_GUID  ndisSupportedList,
    IN      ULONG       cSupportedList
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT      c1, c2, ctmp = cDst;

    for (c1 = 0; c1 < cSupportedList; c1++)
    {
        for (c2 = 0; c2 < cOidList; c2++)
        {
            if (ndisSupportedList[c1].Oid == pOidList[c2])
            {
                if (NULL != pDst)
                {
                    //
                    //  Copy the guid into the destination buffer.
                    //
                    NdisMoveMemory(&pDst[ctmp], &ndisSupportedList[c1], sizeof(NDIS_GUID));
                }

                ctmp++;
                break;
            }
        }
    }

    return ctmp;
}

NDIS_STATUS
ndisQuerySupportedGuidToOidList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will query the miniport and determine the mapping of
    supported GUIDs and their corresponding OIDs. This will include any
    custom OIDs that the driver supports.

Arguments:

Return Value:

--*/
{
    ULONG           BytesNeeded;
    NDIS_STATUS     NdisStatus;
    USHORT          cOidList = 0;
    PNDIS_OID       pOidList = NULL;
    USHORT          cCustomGuids = 0;
    PNDIS_GUID      pCustomGuids = NULL;
    USHORT          cGuidToOidMap = 0;
    PNDIS_GUID      pGuidToOidMap = NULL;
    USHORT          c1, c2;
    NDIS_REQUEST    Request;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQuerySupportedGuidToOidList\n"));
    do
    {
#if (OID_GEN_SUPPORTED_LIST != OID_GEN_CO_SUPPORTED_LIST)
#error (OID_GEN_SUPPORTED_LIST != OID_GEN_CO_SUPPORTED_LIST)
#endif

        //
        //  Determine the amount of buffer space needed for the supported list.
        //
        INIT_INTERNAL_REQUEST(&Request, OID_GEN_SUPPORTED_LIST, NdisRequestQueryInformation, NULL, 0);
        NdisStatus = ndisQuerySetMiniport(Miniport, NULL, FALSE, &Request, NULL);
        BytesNeeded = Request.DATA.QUERY_INFORMATION.BytesNeeded;
    
        //
        //  The driver should have returned invalid length and the
        //  length needed in BytesNeeded.
        //
        if (((NDIS_STATUS_INVALID_LENGTH != NdisStatus) && (NDIS_STATUS_BUFFER_TOO_SHORT != NdisStatus)) ||
            (0 == BytesNeeded))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQuerySupportedGuidToOidList: Failed to get the size of the supported OID list.\n"));
    
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
    
        //
        //  Determine the number of Oids supported.
        //
        cOidList = (USHORT)(BytesNeeded/sizeof(NDIS_OID));

        //
        //  Allocate a buffer to hold the supported list of OIDs.
        //
        pOidList = ALLOC_FROM_POOL(BytesNeeded, NDIS_TAG_WMI_OID_SUPPORTED_LIST);
        if (NULL == pOidList)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQuerySupportedGuidToOidList: Failed to allocate memory for the OID list.\n"));

            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        Request.DATA.QUERY_INFORMATION.InformationBuffer = pOidList;
        Request.DATA.QUERY_INFORMATION.InformationBufferLength = BytesNeeded;

        //
        //  Now query the supported list of OIDs into the buffer.
        //
        NdisStatus = ndisQuerySetMiniport(Miniport, NULL, FALSE, &Request, NULL);
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                    ("ndisQuerySupportedGuidToOidList: Failed to read in the supported OID list.\n"));
            break;
        }
    
        //
        //  Determine the number of [Co]NDIS OIDs that NDIS will handle on behalf of the miniport
        //
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisSupportedGuids,
                                       sizeof(ndisSupportedGuids)/sizeof(NDIS_GUID));
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisCoSupportedGuids,
                                       sizeof(ndisCoSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Determine the number of media specific OIDs that NDIS will handle on
        //  behalf of the miniport
        //
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisMediaSupportedGuids,
                                       sizeof(ndisMediaSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Determine the number of custom GUIDs supported.
        //
        NdisStatus = ndisQueryCustomGuids(Miniport, &Request, &pCustomGuids, &cCustomGuids);
        if (NDIS_STATUS_SUCCESS == NdisStatus)
        {
            cGuidToOidMap += cCustomGuids;
        }

        //
        //  Add to the guid count the number of status indications we are
        //  registering.
        //
        cGuidToOidMap += (sizeof(ndisStatusSupportedGuids) / sizeof(NDIS_GUID));

        //
        //  Add the number of GUIDs that ndis will handle.
        //  Add any guids that are not supported with an OID. These will be handled
        //  entirely by ndis.
        //
        for (c1 = 0; c1 < sizeof(ndisSupportedGuids) / sizeof(NDIS_GUID); c1++)
        {
            if (NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_NDIS_ONLY))
            {
                //
                //  Check to see if the miniport is CoNDIS
                //  
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ||
                    !NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_CO_NDIS))
                {
                    cGuidToOidMap++;
                }
            }
        }

        //
        //  Allocate space for the GUID to OID map.
        //
        pGuidToOidMap = ALLOC_FROM_POOL(cGuidToOidMap * sizeof(NDIS_GUID), NDIS_TAG_WMI_GUID_TO_OID);
        if (NULL == pGuidToOidMap)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pGuidToOidMap, cGuidToOidMap * sizeof(NDIS_GUID));

        //
        //  Add the GUIDs that NDIS will handle
        //
        for (c1 = 0, c2 = 0;
             c1 < sizeof(ndisSupportedGuids) / sizeof(NDIS_GUID);
             c1++)
        {
            if (NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_NDIS_ONLY))
            {
                //
                //  Check to see if the miniport is CoNDIS
                //  
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ||
                    !NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_CO_NDIS))
                {
                    NdisMoveMemory(&pGuidToOidMap[c2], &ndisSupportedGuids[c1], sizeof(NDIS_GUID));
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
                    {
                        //
                        //  we need to mark this for the enumerate guids.
                        //
                        pGuidToOidMap[c2].Flags |= fNDIS_GUID_CO_NDIS;
                    }
                    c2++;
                }
            }
        }

        //
        //  Save the current number of GUIDs in the map in c1
        //
        c1 = c2;

        //
        //  Find the PNDIS_GUIDs that are appropriate for the miniport.
        //
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisSupportedGuids,
                            sizeof(ndisSupportedGuids)/sizeof(NDIS_GUID));
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisCoSupportedGuids,
                            sizeof(ndisCoSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Check for media specific OIDs that ndis can support.
        //
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisMediaSupportedGuids,
                            sizeof(ndisMediaSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Add the status indications to the map of supported guids.
        //
        NdisMoveMemory(&pGuidToOidMap[c1], ndisStatusSupportedGuids, sizeof(ndisStatusSupportedGuids));

        c1 += (sizeof(ndisStatusSupportedGuids) / sizeof(NDIS_GUID));

        //
        //  Save the GUID to OID mapping with the miniport.
        //
        Miniport->pNdisGuidMap = pGuidToOidMap;
        Miniport->cNdisGuidMap = cGuidToOidMap;

        //
        //  Now copy over the custom GUID information if any.
        //
        if (NULL != pCustomGuids)
        {
            NdisMoveMemory(&pGuidToOidMap[c1],
                           pCustomGuids,
                           cCustomGuids * sizeof(NDIS_GUID));

            Miniport->pCustomGuidMap = &pGuidToOidMap[c1];
            Miniport->cCustomGuidMap = cCustomGuids;
        }
        else
        {
            //
            //  Make sure these are initialized if they are not supported.
            //
            Miniport->pCustomGuidMap = NULL;
            Miniport->cCustomGuidMap = 0;
        }

        //
        //  We've succeeded.
        //
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  Free up the buffer that contains the custom GUIDs.
    //
    if (NULL != pCustomGuids)
    {
        FREE_POOL(pCustomGuids);
    }

    //
    //  Free up the list of supported driver OIDs.
    //
    if (NULL != pOidList)
    {
        FREE_POOL(pOidList);
    }

    //
    //  If there was an error and we allocated the GUID to OID map then
    //  free it up also.
    //
    if (NDIS_STATUS_SUCCESS != NdisStatus)
    {
        if (NULL != pGuidToOidMap)
        {
            FREE_POOL(pGuidToOidMap);
        }
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQuerySupportedGuidToOidList\n"));

    return(NdisStatus);
}


NTSTATUS
ndisWmiRegister(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  ULONG_PTR               RegistrationType,
    IN  PWMIREGINFO             wmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWMIREGINFO     pwri;
    ULONG           CustomSizeNeeded = 0;
    ULONG           CustomBufferSize;
    ULONG           CommonSizeNeeded;
    ULONG           cCommonGuids;
    PUNICODE_STRING pMiniportRegistryPath = NULL;
    PNDIS_GUID      pndisguid;
    PWMIREGGUID     pwrg;
    PUCHAR          ptmp;
    NTSTATUS        Status;
    UINT            c;
    NDIS_STATUS     NdisStatus;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiRegister\n"));

    //
    //  Initialize the return size.
    //
    *pReturnSize = 0;

    do
    {
        //
        //  Is this a register request?
        //
        if (WMIREGISTER == RegistrationType)
        {
            //
            //  Get the supported list of OIDs
            //
            if (Miniport->pNdisGuidMap == NULL)
            {
                NdisStatus = ndisQuerySupportedGuidToOidList(Miniport);
                
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisWmiRegister: Unable to get the supported GUID to OID map\n"));

                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            //
            //  Determine the amount of space needed for the Custom GUIDs
            //
            if (Miniport->cCustomGuidMap != 0)
            {
                //
                //  Get a pointer to the registry path of the driver.
                //
                pMiniportRegistryPath = &Miniport->DriverHandle->NdisDriverInfo->ServiceRegPath;

                CustomSizeNeeded = sizeof(WMIREGINFO) +
                                    (Miniport->cCustomGuidMap * sizeof(WMIREGGUID)) +
                                    (sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR) + sizeof(USHORT)) +
                                    (pMiniportRegistryPath->Length + sizeof(USHORT));
            }

            //
            //  Determine how much memory we need to allocate.
            //
            cCommonGuids = Miniport->cNdisGuidMap - Miniport->cCustomGuidMap;

            CommonSizeNeeded = sizeof(WMIREGINFO) + (cCommonGuids * sizeof(WMIREGGUID));
            CustomBufferSize = CustomSizeNeeded;
            CustomSizeNeeded = (CustomSizeNeeded + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID) - 1);

            //
            // CustomBufferSize represents the number of bytes required to store the
            // custom WMI registration info.  CustomSizeNeeded is this value rounded
            // up so that the adjacent WMI registration info is properly aligned.
            //

            //
            //  We need to give this above information back to WMI.
            //

            if (wmiRegInfoSize < (CustomSizeNeeded + CommonSizeNeeded))
            {
                ASSERT(wmiRegInfoSize >= 4);

                *((PULONG)wmiRegInfo) = (CustomSizeNeeded + CommonSizeNeeded);
                *pReturnSize = sizeof(ULONG);
                Status = STATUS_BUFFER_TOO_SMALL;

                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                    ("ndisWmiRegister: Insufficient buffer space for WMI registration information.\n"));

                break;
            }

            //
            //  Get a pointer to the buffer passed in.
            //
            pwri = wmiRegInfo;

            *pReturnSize = CustomSizeNeeded + CommonSizeNeeded;

            NdisZeroMemory(pwri, CustomSizeNeeded + CommonSizeNeeded);

            //
            //  do we need to initialize a WMIREGINFO struct for custom GUIDs?
            //
            if ((0 != CustomSizeNeeded) && pMiniportRegistryPath)
            {
                //
                //  Initialize the WMIREGINFO struct for the miniport's
                //  custom GUIDs.
                //
                pwri->BufferSize = CustomBufferSize;
                pwri->NextWmiRegInfo = CustomSizeNeeded;
                pwri->GuidCount = Miniport->cCustomGuidMap;

                for (c = 0, pndisguid = Miniport->pCustomGuidMap, pwrg = pwri->WmiRegGuid;
                     (c < Miniport->cCustomGuidMap);
                     c++, pndisguid++, pwrg++)
                {
                    CopyMemory(&pwrg->Guid, &pndisguid->Guid, sizeof(GUID));
                }

                //
                //  Fill in the registry path.
                //
                ptmp = (PUCHAR)pwrg;
                pwri->RegistryPath = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
                *((PUSHORT)ptmp) = pMiniportRegistryPath->Length;
                ptmp += sizeof(USHORT);
                CopyMemory(ptmp, pMiniportRegistryPath->Buffer, pMiniportRegistryPath->Length);

                //
                //  Get a pointer to the destination for the MOF name.
                //
                ptmp += pMiniportRegistryPath->Length;

                //
                //  Save the offset to the mof resource.
                //
                pwri->MofResourceName = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
                *((PUSHORT)ptmp) = sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR);
                ptmp += sizeof(USHORT);

                //
                //  Copy the mof name into the wri buffer.
                //
                CopyMemory(ptmp, MOF_RESOURCE_NAME, sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR));

                //
                //  Go on to the next WMIREGINFO struct for the common GUIDs.
                //

                pwri = (PWMIREGINFO)((PCHAR)pwri + pwri->NextWmiRegInfo);
            }

            //
            //  Initialize the pwri struct for the common Oids.
            //
            pwri->BufferSize = CommonSizeNeeded;
            pwri->NextWmiRegInfo = 0;
            pwri->GuidCount = cCommonGuids;

            //
            //  Go through the GUIDs that we support.
            //
            for (c = 0, pndisguid = Miniport->pNdisGuidMap, pwrg = pwri->WmiRegGuid;
                 (c < cCommonGuids);
                 c++, pndisguid++, pwrg++)
            {
                if (NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)) ||
                    NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)) ||
                    NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
                {
                    {
                        (ULONG_PTR)pwrg->InstanceInfo = (ULONG_PTR)(Miniport->PhysicalDeviceObject);
                        pwrg->Flags = WMIREG_FLAG_INSTANCE_PDO;
                        pwrg->InstanceCount = 1;
                    }
                    
                }
                CopyMemory(&pwrg->Guid, &pndisguid->Guid, sizeof(GUID));
            }

            pwri->RegistryPath = 0;
            pwri->MofResourceName = 0;
            Status = STATUS_SUCCESS;
        }
        else
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWmiRegister: Unsupported registration type\n"));

            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiRegister\n"));

    return(Status);
}

NTSTATUS
ndisWmiGetGuid(
    OUT PNDIS_GUID              *ppNdisGuid,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  LPGUID                  guid,
    IN  NDIS_STATUS             status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT        c;
    PNDIS_GUID  pNdisGuid;
    NDIS_STATUS RetStatus = NDIS_STATUS_FAILURE;

    *ppNdisGuid = NULL;
     
    //
    //  Search the custom GUIDs
    //
    if (NULL != Miniport->pNdisGuidMap)
    {
        for (c = 0, pNdisGuid = Miniport->pNdisGuidMap;
             (c < Miniport->cNdisGuidMap);
             c++, pNdisGuid++)
        {
            //
            //  Make sure that we have a supported GUID and the GUID maps
            //  to an OID.
            //
            if (NULL != guid)
            {
                //
                //  We are to look for a guid to oid mapping.
                //
                if (NdisEqualMemory(&pNdisGuid->Guid, guid, sizeof(GUID)))
                {
                    //
                    //  We found the GUID, save the OID that we will need to
                    //  send to the miniport.
                    //
                    RetStatus = NDIS_STATUS_SUCCESS;
                    *ppNdisGuid = pNdisGuid;
    
                    break;
                }
            }
            else
            {
                //
                //  We need to find the guid for the status indication
                //
                if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS) &&
                    (pNdisGuid->Status == status))
                {
                    RetStatus = NDIS_STATUS_SUCCESS;
                    *ppNdisGuid = pNdisGuid;

                    break;
                }
            }
        }
    }

    return(RetStatus);
}

NTSTATUS
ndisQueryGuidDataSize(
    OUT PULONG                  pBytesNeeded,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock    OPTIONAL,
    IN  LPGUID                  guid
    )
/*++

Routine Description:

    This routine will determine the amount of buffer space needed for
    the GUID's data.

Arguments:

                                    
    pBytesNeeded    -   Pointer to storage for the size needed.
    Miniport        -   Pointer to the miniport block.
    guid            -   GUID to query.

Return Value:

--*/
{
    NTSTATUS        NtStatus;
    NDIS_STATUS     Status;
    PNDIS_GUID      pNdisGuid = NULL;
    NDIS_REQUEST    Request;
    ULONG           GuidDataSize;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQueryGuidDataSize\n"));

    do
    {
        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, guid, 0);
        if (pNdisGuid == NULL)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidDataSize: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;

            break;
        }

        //
        //  Check for an ndis only guid
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            NtStatus = STATUS_SUCCESS;

            //
            //  The following GUIDs all return the same data.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)))
            {
                //
                //  Length of string and the string data.
                //
                *pBytesNeeded = Miniport->MiniportName.Length + sizeof(USHORT);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if ((NULL != pVcBlock) && NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_VC, sizeof(GUID)))
            {
                //
                //  There is not data for this VC. It's simply used to enumerate VCs on a miniport.
                //
                *pBytesNeeded = 0;
            }
            else
            {
                //
                //  Unknown guid is being queried...
                //
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        //
        //  Is this a GUID to OID mapping?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Do we need to query the OID for the size of the data?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY) ||
            NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING) ||
            NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING) ||
            (pNdisGuid->Size == (ULONG)-1))
        {
            //
            //  Query the miniport for the current size of the variable length block.
            //
            INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestQueryStatistics, NULL, 0);
            Status = ndisQuerySetMiniport(Miniport,
                                          pVcBlock,
                                          FALSE,
                                          &Request,
                                          NULL);

            //
            //  Make sure that the miniport failed the above request with
            //  the correct error code and that the BytesNeeded is valid.
            //
            if ((NDIS_STATUS_INVALID_LENGTH != Status) &&
                (NDIS_STATUS_BUFFER_TOO_SHORT != Status) &&
                (NDIS_STATUS_SUCCESS != Status))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisQueryGuidDataSize: Failed to query driver OID: 0x%x\n", Status));

                MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
                break;
            }

            GuidDataSize = Request.DATA.QUERY_INFORMATION.BytesNeeded;
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
            {
                //
                //  The size returned is the number of ansi characters. Convert this
                //  to the unicode string size needed
                //
                GuidDataSize = GuidDataSize * sizeof(WCHAR);
                GuidDataSize += sizeof(USHORT);
            }
            else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
            {
                //
                //  string data has a USHORT for the size.
                //
                GuidDataSize += sizeof(USHORT);
            }
            else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  The data is going to have a ULONG of size information at the
                //  start of the buffer.
                //
                GuidDataSize += sizeof(ULONG);
            }
        }
        else
        {
            GuidDataSize = pNdisGuid->Size;
        }

        //
        //  Return the bytes needed.
        //
        *pBytesNeeded = GuidDataSize;

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQueryGuidDataSize\n"));

    return(NtStatus);
}

NTSTATUS
ndisQueryGuidData(
    IN  PUCHAR                  Buffer,
    IN  ULONG                   BufferLength,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock,
    IN  LPGUID                  guid,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        NtStatus;
    NDIS_STATUS     Status;
    PNDIS_GUID      pNdisGuid = NULL;
    NDIS_REQUEST    Request;
    ANSI_STRING     strAnsi = {0};
    UNICODE_STRING  strUnicode = {0};
    ULONG           QuerySize;
    PUCHAR          QueryBuffer;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQueryGuidData\n"));

    UNREFERENCED_PARAMETER(Irp);
    
    do
    {
        //
        //  If the buffer length is equal to 0 then there is no data to query.
        //
        if (0 == BufferLength)
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        ZeroMemory(Buffer, BufferLength);

        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        //1 check to see if we need to do this.
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, guid, 0);
        if (pNdisGuid == NULL)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidData: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this an NDIS supported GUID?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            NtStatus = STATUS_SUCCESS;

            //
            //  The following GUIDs all return the same data.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)))
            {
                *(PUSHORT)Buffer = Miniport->MiniportName.Length;

                NdisMoveMemory(Buffer + sizeof(USHORT),
                               Miniport->MiniportName.Buffer,
                               Miniport->MiniportName.Length);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) && 
                    (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND)))
                {
                    *((PBOOLEAN)Buffer) = MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking))
                {
                    *((PBOOLEAN)Buffer) = MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                //
                // let the user see this only if we can do wake on magic packet
                //
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking) &&
                    (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                    !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                    
                {
                    *((PBOOLEAN)Buffer) = (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH) ? 
                                            TRUE:
                                            FALSE;
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if ((NULL != pVcBlock) && NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_VC, sizeof(GUID)))
            {
                //
                //  There is no data for this VC.
                //
                break;
            }
            else
            {   
                //
                //  Unknown guid is being queried...
                //
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        //
        //  Is this a GUID to OID mapping?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        //  Determine the query size. This will depend upon the type of
        //  data.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            //
            //  The query size is at least the BufferLength minus the ULONG
            //  used for the count. The query buffer will start after the
            //  ULONG of count informaiton in the buffer.
            //
            //1 add check for QuerySize > 0
            QuerySize = BufferLength - sizeof(ULONG);
            QueryBuffer = Buffer + sizeof(ULONG);
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING) ||
                 NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
        {
            //
            //  The query size is at least the BufferLength minus the ULONG
            //  used for the count. The query buffer will start after the
            //  ULONG of count informaiton in the buffer.
            //
            //1 add check for QuerySize > 0
            QuerySize = BufferLength - sizeof(USHORT);
            QueryBuffer = Buffer + sizeof(USHORT);

            //
            //  Is this a query for an ANSI string?
            //
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
            {
                //
                //  The BufferLength is the number of WCHARS not counting a terminating
                //  NULL.
                //
                //1 check this to make sure we have room for null
                QuerySize = (QuerySize / sizeof(WCHAR)) + 1;
            }
        }
        else
        {
            QuerySize = BufferLength;
            QueryBuffer = Buffer;
        }

        //
        //  Query the driver for the actual data.
        //
        INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestQueryStatistics, QueryBuffer, QuerySize);
        Status = ndisQuerySetMiniport(Miniport,
                                      pVcBlock,
                                      FALSE,
                                      &Request,
                                      NULL);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidData: Failed to query the value for driver OID: 0x%x\n", Status));

            MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            break;
        }

        //
        //  If this is an array or string we need to fill in the
        //  count/number.
        //
        NtStatus = STATUS_SUCCESS;
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            //
            //  Determine the number of elements.
            //
            *(PULONG)Buffer = QuerySize / pNdisGuid->Size;
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
        {
            //
            //  The BytesNeeded contains the number of bytes in the string.
            //
            *(PUSHORT)Buffer = (USHORT)QuerySize;
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
        {
            //
            //  The buffer contains the ASCII string, build an
            //  ANSI string from this.
            //
            //1 make sure this is null terminated.
            RtlInitAnsiString(&strAnsi, (PCSZ)QueryBuffer);

            //
            //  Convert the ansi string to unicode.
            //
            NtStatus = RtlAnsiStringToUnicodeString(&strUnicode, &strAnsi, TRUE);
            ASSERT(NT_SUCCESS(NtStatus));
            if (NT_SUCCESS(NtStatus))
            {
                //
                //  Save the length with the string.
                //
                *(PUSHORT)Buffer = strUnicode.Length;
    
                //
                //  Copy the string to the wnode buffer.
                //
                NdisMoveMemory(QueryBuffer, strUnicode.Buffer, strUnicode.Length);
    
                //
                //  Free the buffer allocated for the unicode string.
                //
                RtlFreeUnicodeString(&strUnicode);
            }
        }

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQueryGuidData\n"));

    return(NtStatus);
}

NTSTATUS
ndisWmiQueryAllData(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  LPGUID                  guid,
    IN  PWNODE_ALL_DATA         wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    ULONG                   wnodeSize = ALIGN_8_TYPE(WNODE_ALL_DATA);
    ULONG                   InstanceNameOffsetsSize, InstanceNameSize;
    ULONG                   wnodeTotalSize;
    ULONG                   BytesNeeded;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiQueryAllData\n"));

    do
    {
        *pReturnSize = 0;

        if (BufferSize < sizeof(WNODE_TOO_SMALL))
        {
            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, sizeof(WNODE_TOO_SMALL), &NtStatus, pReturnSize);
            break;
        }

        //
        //  If the guid is only relavent to the adapter then answer it here.
        //  Is this GUID meant for "adapters" only, i.e. not vc's.
        //
        if (ndisWmiGuidIsAdapterSpecific(guid) ||
            !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            ULONG   dataSize;
            PUCHAR  pucTmp;

            //
            //  Determine the buffer size needed for the GUID data.
            //
            NtStatus = ndisQueryGuidDataSize(&BytesNeeded, Miniport, NULL, guid);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Unable to determine GUID data size\n"));

                break;
            }

            //
            //  Determine the size of the WNODE that is needed.
            //
            dataSize = ALIGN_UP(BytesNeeded, ULONG);
            InstanceNameOffsetsSize = sizeof(ULONG);
            InstanceNameSize = sizeof(USHORT) + Miniport->pAdapterInstanceName->Length; // comes at the end, no need to pad
            
            wnodeTotalSize = wnodeSize + dataSize + InstanceNameOffsetsSize + InstanceNameSize;
            
            if (BufferSize < wnodeTotalSize)
            {
                WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                break;
            }

            //
            //  Initialize the wnode.
            //
            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
    
            wnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
            wnode->WnodeHeader.BufferSize = wnodeTotalSize;

            wnode->InstanceCount = 1;
            wnode->DataBlockOffset = wnodeSize;
            wnode->OffsetInstanceNameOffsets = wnodeSize + dataSize;
            wnode->FixedInstanceSize = BytesNeeded;

            //
            //  Fill in the data block.
            //
            NtStatus = ndisQueryGuidData((PUCHAR)wnode + wnodeSize,
                                          BytesNeeded,
                                          Miniport,
                                          NULL,
                                          guid,
                                          Irp);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Failed to get the GUID data.\n"));
                break;
            }

            *(PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets) = wnodeSize + dataSize + InstanceNameOffsetsSize;
            
            //
            //  Get the pointer to where we store the instance name.
            //
            pucTmp = (PUCHAR)((PUCHAR)wnode + wnodeSize + dataSize + InstanceNameOffsetsSize);

            *((PUSHORT)pucTmp) = Miniport->pAdapterInstanceName->Length;
            NdisMoveMemory(pucTmp + sizeof(USHORT),
                           Miniport->pAdapterInstanceName->Buffer,
                           Miniport->pAdapterInstanceName->Length);
            
            NtStatus = STATUS_SUCCESS;
            *pReturnSize = wnode->WnodeHeader.BufferSize;
        }
        else
        {
            ULONG                           cRoughInstanceCount = Miniport->VcCount + 1;
            UINT                            cInstanceCount = 0;
            PUCHAR                          pBuffer;
            PLIST_ENTRY                     Link;
            PNDIS_CO_VC_PTR_BLOCK           pVcBlock = NULL;
            POFFSETINSTANCEDATAANDLENGTH    poidl;
            PULONG                          pInstanceNameOffsets;
            ULONG                           OffsetToInstanceInfo;
            BOOLEAN                         OutOfSpace = FALSE;

            //
            //  Initialize common wnode information.
            //
            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            //
            //  Setup the OFFSETINSTANCEDATAANDLENGTH array.
            //
            poidl = wnode->OffsetInstanceDataAndLength;
            wnode->OffsetInstanceNameOffsets = wnodeSize + ALIGN_UP((sizeof(OFFSETINSTANCEDATAANDLENGTH) * cRoughInstanceCount), ULONG);

            //
            //  Get a pointer to the array of offsets to the instance names.
            //
            pInstanceNameOffsets = (PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets);

            //
            //  Get the offset from the wnode where will will start copying the instance
            //  data into.
            //
            OffsetToInstanceInfo = ALIGN_8_LENGTH(wnode->OffsetInstanceNameOffsets + sizeof(ULONG) * cRoughInstanceCount);

            //
            //  Get a pointer to start placing the data.
            //
            pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

            //
            //  Check to make sure we have at least this much buffer space in the wnode.
            //
            wnodeTotalSize = OffsetToInstanceInfo;

            //
            //  Start with the miniport.
            //
            NtStatus = ndisQueryGuidDataSize(&BytesNeeded, Miniport, NULL, guid);
            if (NT_SUCCESS(NtStatus))
            {
                //
                //  Make sure we have enough buffer space for the instance name and
                //  the data. If not we still continue since we need to find the total
                //  size
                //
                wnodeTotalSize += ALIGN_8_LENGTH(Miniport->pAdapterInstanceName->Length + sizeof(USHORT)) + 
                                  ALIGN_8_LENGTH(BytesNeeded);

                if (BufferSize >= wnodeTotalSize)
                {
                    ///
                    //
                    //  The instance info contains the instance name followed by the
                    //  data for the item.
                    //
                    ///
    
                    //
                    //  Add the offset to the instance name to the table.
                    //
                    pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
    
                    //
                    //  Copy the instance name into the wnode buffer.
                    //
                    *((PUSHORT)pBuffer) = Miniport->pAdapterInstanceName->Length;
    
                    NdisMoveMemory(pBuffer + sizeof(USHORT),
                                   Miniport->pAdapterInstanceName->Buffer,
                                   Miniport->pAdapterInstanceName->Length);
    
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += ALIGN_8_LENGTH(sizeof(USHORT) + Miniport->pAdapterInstanceName->Length);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
    
                    //
                    //  Query the data for the miniport.
                    //
                    NtStatus = ndisQueryGuidData(pBuffer, BytesNeeded, Miniport, NULL, guid, Irp);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("ndisWmiQueryAllData: Failed to get the GUID data.\n"));
                        break;
                    }
    
    
                    //
                    //  Save the length of the data item for this instance.
                    //
                    poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                    poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
        
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += ALIGN_8_LENGTH(BytesNeeded);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                }

                //
                //  Increment the current instance count.
                //
                cInstanceCount++;
            }
            else
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Unable to determine GUID data size\n"));

                break;
            }


            //
            //  Only the miniport?
            //
            if (cInstanceCount == cRoughInstanceCount)
            {
                if (BufferSize >= wnodeTotalSize)
                {
                    wnode->WnodeHeader.BufferSize = wnodeTotalSize;
                    wnode->InstanceCount = cInstanceCount;
                    *pReturnSize = wnode->WnodeHeader.BufferSize;
                    NtStatus = STATUS_SUCCESS;
                }
                else
                {
                    WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                }
                break;
            }

            //
            //  First search the inactive vc list.
            //
            Link = Miniport->WmiEnabledVcs.Flink;
            while (Link != &Miniport->WmiEnabledVcs)
            {
                //
                //  We only have room for so many VCs.
                //
                if (cInstanceCount >= cRoughInstanceCount)
                {
                    break;
                }

                //
                //  Get a pointer to the VC.
                //
                pVcBlock = CONTAINING_RECORD(Link, NDIS_CO_VC_PTR_BLOCK, WmiLink);

                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    Link = Link->Flink;

                    //
                    //  This VC is cleaning up.
                    //
                    continue;
                }

                //
                //  If there is an instance name associated with the VC then we need to query it.
                //
                if (NULL != pVcBlock->VcInstanceName.Buffer)
                {
                    //
                    //  Start with the miniport.
                    //
                    NtStatus = ndisQueryGuidDataSize(&BytesNeeded,
                                                     Miniport,
                                                     pVcBlock,
                                                     guid);
                    if (NT_SUCCESS(NtStatus))
                    {
                        //
                        //  Make sure we have enough buffer space for the instance name and
                        //  the data.
                        //
                        wnodeTotalSize += ALIGN_8_LENGTH(pVcBlock->VcInstanceName.Length + sizeof(USHORT)) +
                                          ALIGN_8_LENGTH(BytesNeeded);
                                          
                        if (BufferSize < wnodeTotalSize)
                        {
                            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                            OutOfSpace = TRUE;
                            ndisDereferenceVcPtr(pVcBlock);
                            Link = Link->Flink;
                            continue;
                        }

                        //
                        //  The instance info contains the instance name followed by the
                        //  data for the item.
                        //
        
                        //
                        //  Add the offset to the instance name to the table.
                        //
                        pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
        
                        //
                        //  Copy the instance name into the wnode buffer.
                        //
                        *((PUSHORT)pBuffer) = pVcBlock->VcInstanceName.Length;
        
                        NdisMoveMemory(pBuffer + sizeof(USHORT),
                                       pVcBlock->VcInstanceName.Buffer,
                                       pVcBlock->VcInstanceName.Length);
        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN_8_LENGTH(sizeof(USHORT) + pVcBlock->VcInstanceName.Length);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
        
                        //
                        //  Query the data for the miniport.
                        //
                        NtStatus = ndisQueryGuidData(pBuffer,
                                                     BytesNeeded,
                                                     Miniport,
                                                     pVcBlock,
                                                     guid,
                                                     Irp);
                        if (!NT_SUCCESS(NtStatus))
                        {
                            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                                ("ndisWmiQueryAllData: Failed to query GUID data\n"));
                            ndisDereferenceVcPtr(pVcBlock);
                            break;
                        }
        
                        //
                        //  Save the length of the data item for this instance.
                        //
                        poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                        poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
            
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN_8_LENGTH(BytesNeeded);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
        
                        //
                        //  Increment the current instance count.
                        //
                        cInstanceCount++;
                    }
                }

                ndisDereferenceVcPtr(pVcBlock);
                Link = Link->Flink;
            }

            if (!OutOfSpace)
            {
                wnode->WnodeHeader.BufferSize = wnodeTotalSize;
                wnode->InstanceCount = cInstanceCount;
    
                //
                //  Set the status to success.
                //
                NtStatus = STATUS_SUCCESS;
                *pReturnSize = wnode->WnodeHeader.BufferSize;
            }
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiQueryAllData\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiQuerySingleInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_INSTANCE  wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    ULONG                   BytesNeeded;
    ULONG                   wnodeSize;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiQuerySingleInstance\n"));

    do
    {
        *pReturnSize = 0;

        if (wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            //
            // This is a static instance name
            //
            pVcBlock = NULL;
        }
        else
        {
            //
            //  Determine if this is for a VC or a miniport...
            //
            
            cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
            pInstanceName = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));
 
            //
            //  This routine will determine if the wnode's instance name is a miniport or VC.
            //  If it's a VC then it will find which one.
            //  
            NtStatus = ndisWmiFindInstanceName(&pVcBlock, Miniport, pInstanceName, cbInstanceName);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQuerySingleInstance: Unable to find the instance name\n"));

                pVcBlock = NULL;
                break;
            }
        }

        //
        //  Determine the buffer size needed for the GUID data.
        //
        NtStatus = ndisQueryGuidDataSize(&BytesNeeded,
                                         Miniport,
                                         pVcBlock,
                                         &wnode->WnodeHeader.Guid);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiQuerySingleInstance: Unable to determine GUID data size\n"));
            break;
        }

        //
        //  Determine the size of the wnode.
        //
        wnodeSize = wnode->DataBlockOffset + BytesNeeded;
        if (BufferSize < wnodeSize)
        {
            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &NtStatus, pReturnSize);
            break;
        }

        //
        //  Initialize the wnode.
        //
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
        wnode->WnodeHeader.BufferSize = wnodeSize;
        wnode->SizeDataBlock = BytesNeeded;

        //
        //  Validate the guid and get the data for it.
        //
        NtStatus = ndisQueryGuidData((PUCHAR)wnode + wnode->DataBlockOffset,
                                     BytesNeeded,
                                     Miniport,
                                     pVcBlock,
                                     &wnode->WnodeHeader.Guid,
                                     Irp);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiQuerySingleInstance: Failed to get the GUID data.\n"));
            break;
        }

        *pReturnSize = wnodeSize;
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this was a VC then we need to dereference it.
    //
    if (NULL != pVcBlock)
    {
        ndisDereferenceVcPtr(pVcBlock);
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiQuerySingleInstance\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiChangeSingleInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_INSTANCE  wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDIS_GUID              pNdisGuid = NULL;
    PUCHAR                  pGuidData;
    ULONG                   GuidDataSize;
    NDIS_REQUEST            Request;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;

    UNREFERENCED_PARAMETER(BufferSize);
    UNREFERENCED_PARAMETER(pReturnSize);
    UNREFERENCED_PARAMETER(Irp);
    
    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiChangeSingleInstance\n"));

    do
    {
        if (wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            //
            // This is a static instance name
            //
            pVcBlock = NULL;
        }
        else
        {
            //
            //  Determine if this is for a VC or a miniport...
            //
            cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
            pInstanceName = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));

            //
            //  This routine will determine if the wnode's instance name is a miniport or VC.
            //  If it's a VC then it will find which one.
            //  
            NtStatus = ndisWmiFindInstanceName(&pVcBlock, Miniport, pInstanceName, cbInstanceName);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiChangeSingleInstance: Unable to find the instance name\n"));

                pVcBlock = NULL;

                break;
            }
        }

        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid,
                                  Miniport,
                                  &wnode->WnodeHeader.Guid,
                                  0);
        if (pNdisGuid == NULL)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this guid settable?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NOT_SETTABLE))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid is not settable!\n"));

            NtStatus = STATUS_NOT_SUPPORTED;
            break;
        }

        //
        //  Get a pointer to the GUID data and size.
        //
        GuidDataSize = wnode->SizeDataBlock;
        pGuidData = (PUCHAR)wnode + wnode->DataBlockOffset;

        if (GuidDataSize == 0)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid has not data to set!\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this an internal ndis guid?  
        //
        if ((NULL == pVcBlock) && NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            PBOOLEAN    pBoolean = (PBOOLEAN)pGuidData;

            NtStatus = STATUS_SUCCESS;

            //
            // for PM set guids, we should update registry for future boots
            //
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) && 
                    (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND)))

                {
                    if (*pBoolean)
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
                        //
                        // enabling power management also enables wake on link change
                        // assuming the adapter supports it
                        //
                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp != NdisDeviceStateUnspecified) &&
                            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
                        {
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_LINK_CHANGE;
                        }
#endif

                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_PM;
                    }
                    else
                    {
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
                        //
                        // disabling power management also disables wake on link and magic packet
                        //
                        Miniport->WakeUpEnable &= ~NDIS_PNP_WAKE_UP_LINK_CHANGE;
#endif

                        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
                        Miniport->PnPCapabilities |= (NDIS_DEVICE_DISABLE_PM | 
                                                      NDIS_DEVICE_DISABLE_WAKE_UP);
                    }
                    
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking))
                {
                    if (*pBoolean)
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_WAKE_UP;
                        //
                        // enableing Wake on Lan enables wake on Magic Packet method
                        // assuming the miniport supports it and it is not disabled in the registry
                        //
                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                            !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                        {
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                        }
                        
                    }
                    else
                    {
                        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                        //
                        // disabling Wake On Lan also disables wake on Magic Packet method
                        //
                        Miniport->WakeUpEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                        Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_UP;
                    }
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                //
                // let the user set this only if we can do wake on magic packet
                //
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking) &&
                    (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                            !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                {
                    if (*pBoolean)
                    {
                        //
                        // user does -not- want to wake on pattern match
                        //
                        Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH;
                    }
                    else
                    {
                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH;
                    }
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }               
            }
            else
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiChangeSingleInstance: Invalid NDIS internal GUID!\n"));

                NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            if (NT_SUCCESS(NtStatus))
            {
                if (MINIPORT_PNP_TEST_FLAGS(Miniport, fMINIPORT_DEVICE_POWER_ENABLE | 
                                                      fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
                {
                    //
                    // power management and wol has been enabled by the user
                    // check to see what we should tell protocols about the new 
                    // WOL capabilities of the device
                    // NOTE: set NDIS_DEVICE_WAKE_UP_ENABLE only if pattern match is enabled
                    //
                    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
                        Miniport->PMCapabilities.Flags &= ~(NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                            NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE);
                    else
                        //
                        // user did not disable wake on pattern match, for protocol's purpose
                        // wol is enabled
                        //
                        Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                          NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE;
                        
                    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
                        Miniport->PMCapabilities.Flags &= ~NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                    else
                        //
                        // user did not disable wake on magic packet, do -not- set the NDIS_DEVICE_WAKE_UP_ENABLE
                        // bit becasue wake on pattern match may not be enabled
                        //
                        Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                }
                else
                    Miniport->PMCapabilities.Flags &= ~(NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                        NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE |
                                                        NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE);
                    
                ndisWritePnPCapabilities(Miniport, Miniport->PnPCapabilities);
                ndisPnPNotifyAllTransports(Miniport,
                                           NetEventPnPCapabilities,
                                           &Miniport->PMCapabilities.Flags,
                                           sizeof(ULONG));

            }
            
            break;
        }

        //
        //  Make sure it's not a stauts indication.
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid does not translate to an OID\n"));

            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Attempt to set the miniport with the information.
        //
        INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestSetInformation, pGuidData, GuidDataSize);
        Status = ndisQuerySetMiniport(Miniport,
                                      pVcBlock,
                                      TRUE,
                                      &Request,
                                      NULL);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Failed to set the new information on the miniport\n"));

            MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);

            break;
        }

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this was a VC then we need to dereference it.
    //
    if (NULL != pVcBlock)
    {
        ndisDereferenceVcPtr(pVcBlock);
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiChangeSingleInstance\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiChangeSingleItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_ITEM      wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    UNREFERENCED_PARAMETER(Miniport);
    UNREFERENCED_PARAMETER(wnode);
    UNREFERENCED_PARAMETER(BufferSize);
    UNREFERENCED_PARAMETER(pReturnSize);
    UNREFERENCED_PARAMETER(Irp);
    
    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiChangeSingleItem\n"));

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiChangeSingleItem: Not Supported\n"));

    return(STATUS_NOT_SUPPORTED);
}


NTSTATUS
FASTCALL
ndisWmiEnableEvents(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  LPGUID                      Guid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PNDIS_GUID  pNdisGuid = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiEnableEvents\n"));

    do
    {

        //
        //  Get a pointer to the Guid/Status to enable.
        //
        Status = ndisWmiGetGuid(&pNdisGuid, Miniport, Guid, 0);

        if (pNdisGuid == NULL)
        {        
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiEnableEvents: Cannot find the guid to enable an event\n"));
    
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_BIND, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_UNBIND, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_REMOVAL, sizeof(GUID)))
        {
            NDIS_GUID_SET_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
            Status = STATUS_SUCCESS;
            break;
        }

        //
        //  Is this GUID an event indication?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS))
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Mark the guid as enabled
        //
        NDIS_GUID_SET_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
        Status = STATUS_SUCCESS;
    
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiEnableEvents\n"));

    return(Status);
}

NTSTATUS
FASTCALL
ndisWmiDisableEvents(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  LPGUID                      Guid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PNDIS_GUID  pNdisGuid = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiDisableEvents\n"));

    do
    {
        //
        //  Get a pointer to the Guid/Status to enable.
        //
        Status = ndisWmiGetGuid(&pNdisGuid, Miniport, Guid, 0);
        if (pNdisGuid == NULL)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiDisableEvents: Cannot find the guid to enable an event\n"));
    
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this GUID an event indication?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS))
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Mark the guid as enabled
        //
        NDIS_GUID_CLEAR_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
    
        Status = STATUS_SUCCESS;

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiDisableEvents\n"));

    return(Status);
}

NTSTATUS
ndisWMIDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            pirp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    PVOID                   DataPath = pirpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pirpSp->Parameters.WMI.BufferSize;
    PVOID                   Buffer = pirpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status;
    ULONG                   ReturnSize = 0;
    PNDIS_MINIPORT_BLOCK    Miniport;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWMIDispatch\n"));

    //
    //  Get a pointer to miniport block
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
//1 why do we do this?    
    try
    {
        if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
        {
            //
            // This is not a miniport. Likely a device created by the driver. Try dispatching to it.
            //
            return(ndisDummyIrpHandler(DeviceObject, pirp));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_ACCESS_VIOLATION);
    }

    //
    //  If the provider ID is not us then pass it down the stack.
    //
    if (pirpSp->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject)
    {
        IoSkipCurrentIrpStackLocation(pirp);
        Status = IoCallDriver(Miniport->NextDeviceObject, pirp);

        return(Status);
    }

    switch (pirpSp->MinorFunction)
    {
        case IRP_MN_REGINFO:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_REGINFO\n"));

            Status = ndisWmiRegister(Miniport,
                                     (ULONG_PTR)DataPath,
                                     Buffer,
                                     BufferSize,
                                     &ReturnSize);
            break;

        case IRP_MN_QUERY_ALL_DATA:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_QUERY_ALL_DATA\n"));

            Status = ndisWmiQueryAllData(Miniport,
                                         (LPGUID)DataPath,
                                         (PWNODE_ALL_DATA)Buffer,
                                         BufferSize,
                                         &ReturnSize,
                                         pirp);
            break;

        case IRP_MN_QUERY_SINGLE_INSTANCE:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_QUERY_SINGLE_INSTANCE\n"));

            Status = ndisWmiQuerySingleInstance(Miniport,
                                                Buffer,
                                                BufferSize,
                                                &ReturnSize,
                                                pirp);
            break;

        case IRP_MN_CHANGE_SINGLE_INSTANCE:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_CHANGE_SINGLE_INSTANCE\n"));

            Status = ndisWmiChangeSingleInstance(Miniport,
                                                 Buffer,
                                                 BufferSize,
                                                 &ReturnSize,
                                                 pirp);
            break;

        case IRP_MN_CHANGE_SINGLE_ITEM:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_CHANGE_SINGLE_ITEM\n"));

            Status = ndisWmiChangeSingleItem(Miniport,
                                             Buffer,
                                             BufferSize,
                                             &ReturnSize,
                                             pirp);
            break;

        case IRP_MN_ENABLE_EVENTS:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_ENABLE_EVENTS\n"));

            Status = ndisWmiEnableEvents(Miniport, (LPGUID)DataPath);   
            break;

        case IRP_MN_DISABLE_EVENTS:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_DISABLE_EVENTS\n"));

            Status = ndisWmiDisableEvents(Miniport, (LPGUID)DataPath);  
            break;

        case IRP_MN_ENABLE_COLLECTION:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_ENABLE_COLLECTION\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;

        case IRP_MN_DISABLE_COLLECTION:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_DISABLE_COLLECTION\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;

        default:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: Invalid minor function (0x%x)\n", pirpSp->MinorFunction));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    pirp->IoStatus.Status = Status;
    ASSERT(ReturnSize <= BufferSize);

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        pirp->IoStatus.Information = ReturnSize;
    }
    else
    {
        pirp->IoStatus.Information = NT_SUCCESS(Status) ? ReturnSize : 0;
    }
    
    IoCompleteRequest(pirp, IO_NO_INCREMENT);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWMIDispatch\n"));

    return(Status);
}


VOID
ndisSetupWmiNode(
    IN      PNDIS_MINIPORT_BLOCK        Miniport,
    IN      PUNICODE_STRING             InstanceName,
    IN      ULONG                       DataBlockSize,
    IN      PVOID                       pGuid,
    IN OUT  PWNODE_SINGLE_INSTANCE *    pwnode
    )
    
{
/*
    sets up a wmi node
    the caller will fill in the data block after the call returns
*/

    PWNODE_SINGLE_INSTANCE  wnode;
    ULONG                   wnodeSize;
    ULONG                   wnodeInstanceNameSize;
    PUCHAR                  ptmp;

    UNREFERENCED_PARAMETER(Miniport);
    
    //
    //  Determine the amount of wnode information we need.
    //
    wnodeSize = ALIGN_8_TYPE(WNODE_SINGLE_INSTANCE);
    wnodeInstanceNameSize = ALIGN_8_LENGTH(InstanceName->Length + sizeof(USHORT));              

    wnode = ALLOC_FROM_POOL(wnodeSize + wnodeInstanceNameSize + DataBlockSize,
                            NDIS_TAG_WMI_EVENT_ITEM);
    if (NULL != wnode)
    {
        NdisZeroMemory(wnode, wnodeSize + wnodeInstanceNameSize + DataBlockSize);
        wnode->WnodeHeader.BufferSize = wnodeSize + DataBlockSize + wnodeInstanceNameSize;
        wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(Miniport->DeviceObject);
        wnode->WnodeHeader.Version = 1;
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

        RtlCopyMemory(&wnode->WnodeHeader.Guid, pGuid, sizeof(GUID));
        wnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE;

        wnode->OffsetInstanceName = wnodeSize;
        wnode->DataBlockOffset = wnodeSize + wnodeInstanceNameSize;
        wnode->SizeDataBlock = DataBlockSize;

        //
        //  Get a pointer to the start of the instance name.
        //
        ptmp = (PUCHAR)wnode + wnodeSize;

        //
        //  Copy in the instance name.
        //
        *((PUSHORT)ptmp) = InstanceName->Length;
        RtlCopyMemory(ptmp + sizeof(USHORT),
                      InstanceName->Buffer,
                      InstanceName->Length);

    }
    
    *pwnode = wnode;

}

/*
NTSTATUS
ndisSetWmiSecurity(
    IN PNDIS_GUID              NdisGuid
    )
{
    SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | 
                                   GROUP_SECURITY_INFORMATION | 
                                   DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR    SecurityDescriptorToSet;
    PVOID                   pGuidObject;
    NTSTATUS                Status;

    
    if ((NdisGuid->Flags & (fNDIS_GUID_ALLOW_READ | fNDIS_GUID_ALLOW_WRITE)) == 
                              (fNDIS_GUID_ALLOW_READ | fNDIS_GUID_ALLOW_WRITE))
    {
        //
        // everyone
        //
        SecurityDescriptorToSet = AllUsersReadWriteSecurityDescriptor;
    }
    else if (NdisGuid->Flags & fNDIS_GUID_ALLOW_READ)
    {
        SecurityDescriptorToSet = AllUsersReadSecurityDescriptor;
    }
    else if (NdisGuid->Flags & fNDIS_GUID_ALLOW_WRITE)
    {
        SecurityDescriptorToSet = AllUsersWriteSecurityDescriptor;
    }
    else if (NdisGuid->Flags & fNDIS_GUID_TO_STATUS)
    {
        SecurityDescriptorToSet = AllUsersNotificationSecurityDescriptor;
    }
    else
    {
        //
        // admin, local system, etc. only
        //
        SecurityDescriptorToSet = AdminsSecurityDescriptor;
    }

    Status = IoWMIOpenBlock(&NdisGuid->Guid,
                            WRITE_DAC,
                            &pGuidObject);


        
    if (NT_SUCCESS(Status))
    {
        Status = ObSetSecurityObjectByPointer(pGuidObject, 
                                              secInfo, 
                                              SecurityDescriptorToSet);
        ObDereferenceObject(pGuidObject);
        
    }
    else
    {
        ASSERT(FALSE);
    }

    return Status;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\pragma.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    pragma.h

Abstract:

    Pragma definitions for pageable/init/section-pageable NDIS Wrapper routines.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Feb-96  Jameel Hyder    Moved from individual source files
--*/

#ifndef _PRAGMA_
#define _PRAGMA_

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, ndisReadRegistry)
#pragma alloc_text(INIT, ndisAddMediaTypeToArray)
#pragma alloc_text(INIT, ndisReadProcessorAffinityMask)
                                                
//
// These are normally paged out and only get locked down during PnP/Power operations
//
#pragma alloc_text(PAGENPNP, ndisWorkerThread)
#pragma alloc_text(PAGENPNP, ndisDispatchRequest)
#pragma alloc_text(PAGENPNP, ndisHandlePnPRequest)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolBindNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolUnbindNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolReconfigNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolUnloadNotification)
#pragma alloc_text(PAGENPNP, ndisNotifyWmiBindUnbind)
#pragma alloc_text(PAGENPNP, ndisHandleOrphanDevice)
#pragma alloc_text(PAGENPNP, ndisReferenceMiniportByName)
#pragma alloc_text(PAGENPNP, ndisHandleLegacyTransport)
#pragma alloc_text(PAGENPNP, ndisHandleUModePnPOp)
#pragma alloc_text(PAGENPNP, ndisEnumerateInterfaces)
#pragma alloc_text(PAGENPNP, ndisUnbindProtocol)
// #pragma alloc_text(PAGENPNP, NdisCompleteBindAdapter)
#pragma alloc_text(PAGENPNP, NdisCompleteUnbindAdapter)
#pragma alloc_text(PAGENPNP, NdisRegisterTdiCallBack)
#pragma alloc_text(PAGENPNP, ndisInitializePackage)
#pragma alloc_text(PAGENPNP, NdisOpenFile)
#pragma alloc_text(PAGENPNP, NdisCloseFile)
#pragma alloc_text(PAGENPNP, NdisQueryMapRegisterCount)
#pragma alloc_text(PAGENPNP, ndisVerifierQueryMapRegisterCount)
#pragma alloc_text(PAGENPNP, ndisCreateAdapterInstanceName)
#pragma alloc_text(PAGENPNP, ndisPnPCancelStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPQueryStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPCancelRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisPnPQueryRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisPnPRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisQueryReferenceBusInterface)
#pragma alloc_text(PAGENPNP, ndisPnPAddDevice)
#pragma alloc_text(PAGENPNP, ndisPnPStartDevice)
#pragma alloc_text(PAGENPNP, ndisAddDevice)
#pragma alloc_text(PAGENPNP, ndisSetDeviceNames)
#pragma alloc_text(PAGENPNP, ndisPnPDispatch)
#pragma alloc_text(PAGENPNP, ndisReinitializeMiniportBlock)
#pragma alloc_text(PAGENPNP, ndisQueryPowerCapabilities)
#pragma alloc_text(PAGENPNP, ndisQueryPower)
#pragma alloc_text(PAGENPNP, ndisSetPower)
#pragma alloc_text(PAGENPNP, ndisPowerDispatch)
#pragma alloc_text(PAGENPNP, ndisDevicePowerOn)
#pragma alloc_text(PAGENPNP, ndisDevicePowerDown)
#pragma alloc_text(PAGENPNP, ndisWMIDispatch)
#pragma alloc_text(PAGENPNP, ndisWmiChangeSingleItem)
#pragma alloc_text(PAGENPNP, ndisWmiChangeSingleInstance)
#pragma alloc_text(PAGENPNP, ndisWmiQuerySingleInstance)
#pragma alloc_text(PAGENPNP, ndisWmiFindInstanceName)
#pragma alloc_text(PAGENPNP, ndisWmiQueryAllData)
#pragma alloc_text(PAGENPNP, ndisWmiGuidIsAdapterSpecific)
#pragma alloc_text(PAGENPNP, ndisQueryGuidData)
#pragma alloc_text(PAGENPNP, ndisQueryGuidDataSize)
#pragma alloc_text(PAGENPNP, ndisWmiRegister)
#pragma alloc_text(PAGENPNP, ndisQuerySupportedGuidToOidList)
#pragma alloc_text(PAGENPNP, ndisWmiMapOids)
#pragma alloc_text(PAGENPNP, ndisQueryCustomGuids)
#pragma alloc_text(PAGENPNP, ndisPnPNotifyAllTransports)
#pragma alloc_text(PAGENPNP, ndisPnPNotifyBinding)
#pragma alloc_text(PAGENPNP, ndisInitializeRef)
#pragma alloc_text(PAGENPNP, ndisMQueuedFreeSharedHandler)
#pragma alloc_text(PAGENPNP, ndisReferenceProtocolByName)
#pragma alloc_text(PAGENPNP, ndisMPowerPolicy)
#pragma alloc_text(PAGENPNP, ndisQuerySetMiniportDeviceState)
#pragma alloc_text(PAGENPNP, ndisMediaDisconnectWorker)
#pragma alloc_text(PAGENPNP, ndisWmiEnableEvents)
#pragma alloc_text(PAGENPNP, ndisWmiDisableEvents)
#pragma alloc_text(PAGENPNP, ndisDummyIrpHandler)
#pragma alloc_text(PAGENPNP, ndisDeviceControlIrpHandler)
#pragma alloc_text(PAGENPNP, ndisQueryStatisticsOids)
#pragma alloc_text(PAGENPNP, ndisQueryDeviceOid)
#pragma alloc_text(PAGENPNP, ndisValidOid)
#pragma alloc_text(PAGENPNP, ndisSplitStatisticsOids)
//
// These are normally paged out and only get locked down during driver initialization
//
#pragma alloc_text(PAGENPNP, NdisRegisterProtocol)
#pragma alloc_text(PAGENPNP, NdisDeregisterProtocol)
#pragma alloc_text(PAGENPNP, NdisOpenAdapter)
#pragma alloc_text(PAGENPNP, ndisMOpenAdapter)
#pragma alloc_text(PAGENPNP, ndisMFinishQueuedPendingOpen)
#pragma alloc_text(PAGENPNP, ndisQueueOpenOnMiniport)
#pragma alloc_text(PAGENPNP, ndisQueueOpenOnProtocol)
#pragma alloc_text(PAGENPNP, NdisCloseAdapter)
#pragma alloc_text(PAGENPNP, ndisMKillOpen)
#pragma alloc_text(PAGENPNP, ndisMFinishClose)
#pragma alloc_text(PAGENPNP, ndisMQueuedFinishClose)
#pragma alloc_text(PAGENPNP, ndisInitializeBinding)
#pragma alloc_text(PAGENPNP, ndisDeQueueOpenOnMiniport)
#pragma alloc_text(PAGENPNP, ndisDeQueueOpenOnProtocol)
#pragma alloc_text(PAGENPNP, NdisMRegisterMiniport)
#pragma alloc_text(PAGENPNP, ndisRegisterMiniportDriver)
#pragma alloc_text(PAGENPNP, NdisIMAssociateMiniport)
#pragma alloc_text(PAGENPNP, NdisIMRegisterLayeredMiniport)
#pragma alloc_text(PAGENPNP, NdisIMDeregisterLayeredMiniport)
#pragma alloc_text(PAGENPNP, NdisMDeregisterInterrupt)
#pragma alloc_text(PAGENPNP, NdisMDeregisterInterruptEx)
#pragma alloc_text(PAGENPNP, ndisMDeregisterInterruptCommon)
#pragma alloc_text(PAGENPNP, NdisMDeregisterIoPortRange)
#pragma alloc_text(PAGENPNP, NdisMUnmapIoSpace)
#pragma alloc_text(PAGENPNP, NdisMDeregisterDmaChannel)
#pragma alloc_text(PAGENPNP, NdisMFreeMapRegisters)
#pragma alloc_text(PAGENPNP, NdisMDeregisterAdapterShutdownHandler)
#pragma alloc_text(PAGENPNP, ndisInitializeAdapter)
#pragma alloc_text(PAGENPNP, ndisInitializeConfiguration)
#pragma alloc_text(PAGENPNP, ndisMInitializeAdapter)
#pragma alloc_text(PAGENPNP, ndisTranslateResources)
#pragma alloc_text(PAGENPNP, ndisCheckAdapterBindings)
#pragma alloc_text(PAGENPNP, NdisIMDeInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisIMInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisProtocolAlreadyBound)
#pragma alloc_text(PAGENPNP, NdisOpenConfiguration)
#pragma alloc_text(PAGENPNP, NdisOpenConfigurationKeyByName)
#pragma alloc_text(PAGENPNP, NdisOpenConfigurationKeyByIndex)
#pragma alloc_text(PAGENPNP, NdisReadConfiguration)
#pragma alloc_text(PAGENPNP, NdisWriteConfiguration)
#pragma alloc_text(PAGENPNP, NdisCloseConfiguration)
#pragma alloc_text(PAGENPNP, NdisReadNetworkAddress)
#pragma alloc_text(PAGENPNP, NdisConvertStringToAtmAddress)
#pragma alloc_text(PAGENPNP, ndisReadParameter)
#pragma alloc_text(PAGENPNP, ndisSaveParameters)
#pragma alloc_text(PAGENPNP, ndisCheckPortUsage)
#pragma alloc_text(PAGENPNP, ndisImmediateReadWritePort)
#pragma alloc_text(PAGENPNP, ndisImmediateReadWriteSharedMemory)
#pragma alloc_text(PAGENPNP, ndisStartMapping)
#pragma alloc_text(PAGENPNP, ndisEndMapping)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUchar)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUshort)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUlong)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUchar)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUshort)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUlong)
#pragma alloc_text(PAGENPNP, ndisCheckMemoryUsage)
#pragma alloc_text(PAGENPNP, NdisImmediateReadSharedMemory)
#pragma alloc_text(PAGENPNP, NdisImmediateWriteSharedMemory)
#pragma alloc_text(PAGENPNP, NdisInitializeWrapper)
#pragma alloc_text(PAGENPNP, NdisTerminateWrapper)
#pragma alloc_text(PAGENPNP, NdisMQueryAdapterResources)
#pragma alloc_text(PAGENPNP, NdisAllocateDmaChannel)
#pragma alloc_text(PAGENPNP, NdisMAllocateMapRegisters)
#pragma alloc_text(PAGENPNP, NdisMInitializeScatterGatherDma)
#pragma alloc_text(PAGENPNP, NdisMQueryAdapterInstanceName)
#pragma alloc_text(PAGENPNP, NdisMSetAttributes)
#pragma alloc_text(PAGENPNP, NdisMSetAttributesEx)
#pragma alloc_text(PAGENPNP, NdisReadEisaSlotInformationEx)
#pragma alloc_text(PAGENPNP, NdisReadEisaSlotInformation)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPciSlotInformation)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePciSlotInformation)
#pragma alloc_text(PAGENPNP, ndisQueryBusInterface)
#pragma alloc_text(PAGENPNP, NdisMRegisterDevice)
#pragma alloc_text(PAGENPNP, NdisMRegisterUnloadHandler)
#pragma alloc_text(PAGENPNP, NdisMAllocateSharedMemory)
#pragma alloc_text(PAGENPNP, NdisMRegisterInterrupt)
#pragma alloc_text(PAGENPNP, NdisMRegisterInterruptEx)
#pragma alloc_text(PAGENPNP, ndisMRegisterInterruptCommon)
#pragma alloc_text(PAGENPNP, NdisMPciAssignResources)
#pragma alloc_text(PAGENPNP, NdisMRegisterAdapterShutdownHandler)
#pragma alloc_text(PAGENPNP, NdisMRegisterIoPortRange)
#pragma alloc_text(PAGENPNP, NdisMMapIoSpace)
#pragma alloc_text(PAGENPNP, NdisMRegisterDmaChannel)
#pragma alloc_text(PAGENPNP, ndisMAdjustFilters)
#pragma alloc_text(PAGENPNP, ndisMDoMiniportOp)
#pragma alloc_text(PAGENPNP, ndisPmInitializeMiniport)
#pragma alloc_text(PAGENPNP, ndisCheckProtocolBindings)
#pragma alloc_text(PAGENPNP, NdisIMGetDeviceContext)
#pragma alloc_text(PAGENPNP, NdisIMGetBindingContext)
#pragma alloc_text(PAGENPNP, NdisMapFile)
#pragma alloc_text(PAGENPNP, NdisUnmapFile)
#pragma alloc_text(PAGENPNP, NdisMSleep)
#pragma alloc_text(PAGENPNP, ndisMUnload)
#pragma alloc_text(PAGENPNP, NdisIMNotifyPnPEvent)
#if ARCNET
#pragma alloc_text(PAGENPNP, ArcCreateFilter)
#pragma alloc_text(PAGENPNP, ArcDeleteFilter)
#endif
#pragma alloc_text(PAGENPNP, EthCreateFilter)
#pragma alloc_text(PAGENPNP, EthDeleteFilter)
#pragma alloc_text(PAGENPNP, TrCreateFilter)
#pragma alloc_text(PAGENPNP, TrDeleteFilter)
#pragma alloc_text(PAGENPNP, FddiCreateFilter)
#pragma alloc_text(PAGENPNP, FddiDeleteFilter)
#pragma alloc_text(PAGENPNP, NdisCmRegisterAddressFamily)
#pragma alloc_text(PAGENPNP, NdisMCmRegisterAddressFamily)
#pragma alloc_text(PAGENPNP, NdisClOpenAddressFamily)
#pragma alloc_text(PAGENPNP, ndisWorkItemHandler)
#pragma alloc_text(PAGENPNP, ndisQuerySetMiniport)
#pragma alloc_text(PAGENPNP, ndisCreateNotifyQueue)
#pragma alloc_text(PAGENPNP, ndisNotifyAfRegistration)
#pragma alloc_text(PAGENPNP, NdisMGetDeviceProperty)
#pragma alloc_text(PAGENPNP, ndisMHaltMiniport)
#pragma alloc_text(PAGENPNP, ndisMCommonHaltMiniport)
#pragma alloc_text(PAGENPNP, ndisMShutdownMiniport)
#pragma alloc_text(PAGENPNP, ndisCloseMiniportBindings)
#pragma alloc_text(PAGENPNP, ndisFindRootDevice)
#pragma alloc_text(PAGENPNP, ndisFindMiniportOnGlobalList)
#pragma alloc_text(PAGENPNP, ndisDeQueueMiniportOnDriver)
#pragma alloc_text(PAGENPNP, ndisQueueMiniportOnDriver)
#pragma alloc_text(PAGENPNP, ndisCloseAllBindingsOnProtocol)
#pragma alloc_text(PAGENPNP, ndisPmHaltMiniport)
#pragma alloc_text(PAGENPNP, NdisIMInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, NdisIMInitializeDeviceInstanceEx)
#pragma alloc_text(PAGENPNP, NdisIMCancelInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisIMCheckDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisNotifyMiniports)
#pragma alloc_text(PAGENPNP, ndisReferenceNextUnprocessedMiniport)
#pragma alloc_text(PAGENPNP, ndisUnprocessAllMiniports)
#pragma alloc_text(PAGENPNP, ndisQueueBindWorkitem)
#pragma alloc_text(PAGENPNP, ndisQueuedCheckAdapterBindings)
#pragma alloc_text(PAGENPNP, NdisMGetDmaAlignment)
//
// These are normally paged out and only get locked when a miniport loads
//
#pragma alloc_text(PAGENDSM, NdisMReadDmaCounter)
#pragma alloc_text(PAGENDSM, NdisMSetTimer)
#pragma alloc_text(PAGENDSM, NdisMCancelTimer)
#pragma alloc_text(PAGENDSM, NdisMSynchronizeWithInterrupt)
#pragma alloc_text(PAGENDSM, ndisMIsr)
#pragma alloc_text(PAGENDSM, ndisMDpc)
#pragma alloc_text(PAGENDSM, ndisMDpcX)
#pragma alloc_text(PAGENDSM, ndisMWakeUpDpc)
#pragma alloc_text(PAGENDSM, ndisMWakeUpDpcX)
#pragma alloc_text(PAGENDSM, ndisMPollMediaState)
#pragma alloc_text(PAGENDSM, ndisMTimerDpc)
#pragma alloc_text(PAGENDSM, ndisMTimerDpcX)
#pragma alloc_text(PAGENDSM, ndisMDeferredDpc)
#pragma alloc_text(PAGENDSM, ndisMDeQueueWorkItem)
#pragma alloc_text(PAGENDSM, ndisMQueueWorkItem)
#pragma alloc_text(PAGENDSM, ndisMQueueNewWorkItem)
#pragma alloc_text(PAGENDSM, ndisMProcessDeferred)
#pragma alloc_text(PAGENDSM, ndisMProcessResetRequested)
#pragma alloc_text(PAGENDSM, NdisMIndicateStatus)
#pragma alloc_text(PAGENDSM, NdisMIndicateStatusComplete)
#pragma alloc_text(PAGENDSM, NdisMWanIndicateReceive)
#pragma alloc_text(PAGENDSM, NdisMWanIndicateReceiveComplete)
#pragma alloc_text(PAGENDSM, ndisMIndicatePacket)
#pragma alloc_text(PAGENDSM, ndisMAbortPackets)
#pragma alloc_text(PAGENDSM, ndisMAbortRequests)
#pragma alloc_text(PAGENDSM, NdisMResetComplete)
#pragma alloc_text(PAGENDSM, ndisMResetCompleteStage1)
#pragma alloc_text(PAGENDSM, ndisMResetCompleteStage2)
#pragma alloc_text(PAGENDSM, ndisMediaDisconnectTimeout)
#pragma alloc_text(PAGENDSM, ndisDereferenceMiniport)
#pragma alloc_text(PAGENDSM, NdisMQueryInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMSyncQueryInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMRequestSetInformationPost)
#pragma alloc_text(PAGENDSM, ndisMSyncSetInformationComplete)
#pragma alloc_text(PAGENDSM, NdisMSetInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMSetPacketFilter)
#pragma alloc_text(PAGENDSM, ndisMSetProtocolOptions)
#pragma alloc_text(PAGENDSM, ndisMSetCurrentLookahead)
#pragma alloc_text(PAGENDSM, ndisMSetMulticastList)
#pragma alloc_text(PAGENDSM, ndisMSetAddWakeUpPattern)
#pragma alloc_text(PAGENDSM, ndisMSetRemoveWakeUpPattern)
#pragma alloc_text(PAGENDSM, ndisMSetEnableWakeUp)
#pragma alloc_text(PAGENDSM, ndisMSetInformation)
#pragma alloc_text(PAGENDSM, ndisMQueryCurrentPacketFilter)
#pragma alloc_text(PAGENDSM, ndisMQueryMediaSupported)
#pragma alloc_text(PAGENDSM, ndisMQueryEthernetMulticastList)
#pragma alloc_text(PAGENDSM, ndisMQueryMaximumFrameSize)
#pragma alloc_text(PAGENDSM, ndisMQueryMaximumTotalSize)
#pragma alloc_text(PAGENDSM, ndisMQueryNetworkAddress)
#pragma alloc_text(PAGENDSM, ndisMQueryEnableWakeUp)
#pragma alloc_text(PAGENDSM, ndisMQueryWakeUpPatternList)
#pragma alloc_text(PAGENDSM, ndisMQueryInformation)
#pragma alloc_text(PAGENDSM, ndisMRundownRequests)
#pragma alloc_text(PAGENDSM, ndisMDoRequests)
#pragma alloc_text(PAGENDSM, ndisMAllocateRequest)
#pragma alloc_text(PAGENDSM, ndisMQueueRequest)
#pragma alloc_text(PAGENDSM, ndisMRestoreFilterSettings)
#pragma alloc_text(PAGENDSM, ndisMDispatchRequest)
#pragma alloc_text(PAGENDSM, ndisMChangeClass)
#pragma alloc_text(PAGENDSM, ndisMCopyFromPacketToBuffer)
#pragma alloc_text(PAGENDSM, NdisMSendResourcesAvailable)
#pragma alloc_text(PAGENDSM, NdisMStartBufferPhysicalMapping)
#pragma alloc_text(PAGENDSM, NdisMCompleteBufferPhysicalMapping)
#pragma alloc_text(PAGENDSM, ndisMQueryWakeUpPatternList)
#pragma alloc_text(PAGENDSM, ndisMediaDisconnectComplete)
#pragma alloc_text(PAGENDSM, ndisMAllocSGList)
#pragma alloc_text(PAGENDSM, ndisMFreeSGList)
#pragma alloc_text(PAGENDSM, ndisMProcessSGList)
#pragma alloc_text(PAGENDSM, NdisIMSwitchToMiniport)
#pragma alloc_text(PAGENDSM, NdisIMRevertBack)
#pragma alloc_text(PAGENDSM, NdisIMQueueMiniportCallback)
#pragma alloc_text(PAGENDSM, NdisIMCopySendPerPacketInfo)
#pragma alloc_text(PAGENDSM, NdisIMCopySendCompletePerPacketInfo)
#pragma alloc_text(PAGENDSM, ndisMRestoreOpenHandlers)
#pragma alloc_text(PAGENDSM, ndisMSwapOpenHandlers)
#pragma alloc_text(PAGENDSM, NdisMCreateLog)
#pragma alloc_text(PAGENDSM, NdisMCloseLog)
#pragma alloc_text(PAGENDSM, NdisMWriteLogData)
#pragma alloc_text(PAGENDSM, NdisMFlushLog)
#pragma alloc_text(PAGENDSM, NdisMSetPeriodicTimer)
#pragma alloc_text(PAGENDSM, ndisMQueuedAllocateSharedHandler)
#pragma alloc_text(PAGENDSM, ndisMGetLogData)
#pragma alloc_text(PAGENDSM, NdisMSetMiniportSecondary)
#pragma alloc_text(PAGENDSM, NdisMPromoteMiniport)
#pragma alloc_text(PAGENDSM, NdisMRemoveMiniport)
#pragma alloc_text(PAGENDSM, XRemoveAndFreeBinding)
#pragma alloc_text(PAGENDSM, XRemoveBindingFromLists)
#pragma alloc_text(PAGENDSM, XFilterLockHandler)
#pragma alloc_text(PAGENDSM, XUndoFilterAdjust)
#pragma alloc_text(PAGENDSM, XFilterAdjust)
#pragma alloc_text(PAGENDSM, XNoteFilterOpenAdapter)
#pragma alloc_text(PAGENDSM, ndisMNotifyMachineName)
#pragma alloc_text(PAGENDSM, NdisMFreeSharedMemory)
#pragma alloc_text(PAGENDSM, ndisGetSetBusConfigSpace)
#pragma alloc_text(PAGENDSM, ndisSetupWmiNode)
#pragma alloc_text(PAGENDSM, ndisMSetIndicatePacketHandler)

//
// These are normally paged out and only get locked down when a CO-NDIS miniport loads
//
#pragma alloc_text(PAGENDCO, NdisCmOpenAddressFamilyComplete)
#pragma alloc_text(PAGENDCO, NdisCmCloseAddressFamilyComplete)
#pragma alloc_text(PAGENDCO, NdisClCloseAddressFamily)
#pragma alloc_text(PAGENDCO, NdisClRegisterSap)
#pragma alloc_text(PAGENDCO, NdisCmRegisterSapComplete)
#pragma alloc_text(PAGENDCO, NdisClDeregisterSap)
#pragma alloc_text(PAGENDCO, NdisCmDeregisterSapComplete)
#pragma alloc_text(PAGENDCO, NdisClMakeCall)
#pragma alloc_text(PAGENDCO, NdisCmMakeCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCall)
#pragma alloc_text(PAGENDCO, NdisClIncomingCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchCallConnected)
#pragma alloc_text(PAGENDCO, NdisClModifyCallQoS)
#pragma alloc_text(PAGENDCO, NdisCmModifyCallQoSComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCallQoSChange)
#pragma alloc_text(PAGENDCO, NdisClCloseCall)
#pragma alloc_text(PAGENDCO, NdisCmCloseCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCloseCall)
#pragma alloc_text(PAGENDCO, NdisClAddParty)
#pragma alloc_text(PAGENDCO, NdisCmAddPartyComplete)
#pragma alloc_text(PAGENDCO, NdisClDropParty)
#pragma alloc_text(PAGENDCO, NdisCmDropPartyComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingDropParty)
#pragma alloc_text(PAGENDCO, NdisCoCreateVc)
#pragma alloc_text(PAGENDCO, NdisCoDeleteVc)
#pragma alloc_text(PAGENDCO, NdisMCmDeleteVc)
#pragma alloc_text(PAGENDCO, NdisCmActivateVc)
#pragma alloc_text(PAGENDCO, NdisMCoActivateVcComplete)
#pragma alloc_text(PAGENDCO, NdisCmDeactivateVc)
#pragma alloc_text(PAGENDCO, NdisMCoDeactivateVcComplete)
#pragma alloc_text(PAGENDCO, NdisMCmRequest)
#pragma alloc_text(PAGENDCO, NdisCoRequest)
#pragma alloc_text(PAGENDCO, NdisCoRequestComplete)
#pragma alloc_text(PAGENDCO, NdisMCoRequestComplete)
#pragma alloc_text(PAGENDCO, NdisMCoIndicateReceivePacket)
#pragma alloc_text(PAGENDCO, NdisMCoReceiveComplete)
#pragma alloc_text(PAGENDCO, NdisCoSendPackets)
#pragma alloc_text(PAGENDCO, NdisMCoSendComplete)
#pragma alloc_text(PAGENDCO, NdisMCoIndicateStatus)
#pragma alloc_text(PAGENDCO, NdisMCmCreateVc)
#pragma alloc_text(PAGENDCO, NdisMCmActivateVc)
#pragma alloc_text(PAGENDCO, NdisMCmDeactivateVc)
#pragma alloc_text(PAGENDCO, ndisReferenceAf)
#pragma alloc_text(PAGENDCO, ndisDereferenceAf)
#pragma alloc_text(PAGENDCO, ndisReferenceSap)
#pragma alloc_text(PAGENDCO, ndisDereferenceSap)
#pragma alloc_text(PAGENDCO, ndisReferenceVcPtr)
#pragma alloc_text(PAGENDCO, ndisDereferenceVcPtr)
#pragma alloc_text(PAGENDCO, ndisMRejectSend)
#pragma alloc_text(PAGENDCO, ndisMRejectSendPackets)
#pragma alloc_text(PAGENDCO, NdisCoAssignInstanceName)
#pragma alloc_text(PAGENDCO, ndisUnicodeStringToPointer)
#pragma alloc_text(PAGENDCO, NdisClGetProtocolVcContextFromTapiCallId)
#pragma alloc_text(PAGENDCO, NdisCoGetTapiCallId)
#pragma alloc_text(PAGENDCO, ndisMCoFreeResources)


//
// These are normally paged out and only get locked down when a protocol loads
//
#pragma alloc_text(PAGENDSP, NdisSend)
#pragma alloc_text(PAGENDSP, ndisMSend)
#pragma alloc_text(PAGENDSP, NdisSendPackets)
#pragma alloc_text(PAGENDSP, ndisMSendPackets)
#pragma alloc_text(PAGENDSP, ndisMSendPacketsX)
#pragma alloc_text(PAGENDSP, ndisMIsLoopbackPacket)
#pragma alloc_text(PAGENDSP, ndisMLoopbackPacketX)
#pragma alloc_text(PAGENDSP, ndisMWanSend)
#pragma alloc_text(PAGENDSP, ndisMStartSendPackets)
#pragma alloc_text(PAGENDSP, ndisMStartSends)
#pragma alloc_text(PAGENDSP, NdisMSendComplete)
#pragma alloc_text(PAGENDSP, ndisMSendCompleteX)
#pragma alloc_text(PAGENDSP, NdisMWanSendComplete)
#pragma alloc_text(PAGENDSP, NdisRequest)
#pragma alloc_text(PAGENDSP, NdisReset)
#pragma alloc_text(PAGENDSP, ndisMRequest)
#pragma alloc_text(PAGENDSP, ndisMRequestX)
#pragma alloc_text(PAGENDSP, NdisTransferData)
#pragma alloc_text(PAGENDSP, NdisSetProtocolFilter)
#pragma alloc_text(PAGENDSP, NdisGetDriverHandle)
#pragma alloc_text(PAGENDSP, NdisReEnumerateProtocolBindings)
#pragma alloc_text(PAGENDSP, ndisDereferenceProtocol)
#pragma alloc_text(PAGENDSP, NdisOpenProtocolConfiguration)
#pragma alloc_text(PAGENDSP, NdisWriteEventLogEntry)
#pragma alloc_text(PAGENDSP, NdisQueryAdapterInstanceName)
#pragma alloc_text(PAGENDSP, NdisQueryBindInstanceName)
#pragma alloc_text(PAGENDSP, NdisSetPacketPoolProtocolId)
#pragma alloc_text(PAGENDSP, NdisCompletePnPEvent)
#pragma alloc_text(PAGENDSP, NdisReturnPackets)
#pragma alloc_text(PAGENDSP, NdisGetReceivedPacket)
#pragma alloc_text(PAGENDSP, ndisMDeferredReturnPackets)
#pragma alloc_text(PAGENDSP, NdisMTransferDataComplete)
#pragma alloc_text(PAGENDSP, ndisMTransferData)
#pragma alloc_text(PAGENDSP, ndisMReset)
#pragma alloc_text(PAGENDSP, ndisMFakeWanSend)
#pragma alloc_text(PAGENDSP, ndisMFakeSend)
#pragma alloc_text(PAGENDSP, ndisMFakeSendPackets)
#pragma alloc_text(PAGENDSP, ndisMFakeReset)
#pragma alloc_text(PAGENDSP, ndisMFakeRequest)
#pragma alloc_text(PAGENDSP, ndisMSendPacketsSG)
#pragma alloc_text(PAGENDSP, ndisMStartSendPacketsSG)
#pragma alloc_text(PAGENDSP, ndisMStartSendsSG)
#pragma alloc_text(PAGENDSP, ndisMSendSG)
#pragma alloc_text(PAGENDSP, ndisMSendCompleteSG)

//
// These are normally paged out and only get locked down when a ethernet filter is created
//
#pragma alloc_text(PAGENDSE, EthDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSE, ethCompleteChangeFilterAddresses)
#pragma alloc_text(PAGENDSE, EthChangeFilterAddresses)
#pragma alloc_text(PAGENDSE, EthNumberOfOpenFilterAddresses)
#pragma alloc_text(PAGENDSE, EthQueryOpenFilterAddresses)
#pragma alloc_text(PAGENDSE, EthQueryGlobalFilterAddresses)
#pragma alloc_text(PAGENDSE, EthFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSE, EthFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSE, ethFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDSE, ethFindMulticast)
#pragma alloc_text(PAGENDSE, EthShouldAddressLoopBack)

//
// These are normally paged out and only get locked down when a token-ring filter is created
//
#pragma alloc_text(PAGENDST, TrDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDST, trUndoChangeFunctionalAddress)
#pragma alloc_text(PAGENDST, TrChangeFunctionalAddress)
#pragma alloc_text(PAGENDST, trUndoChangeGroupAddress)
#pragma alloc_text(PAGENDST, trCompleteChangeGroupAddress)
#pragma alloc_text(PAGENDST, TrChangeGroupAddress)
#pragma alloc_text(PAGENDST, TrFilterDprIndicateReceive)
#pragma alloc_text(PAGENDST, trFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDST, TrFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDST, TrShouldAddressLoopBack)
#pragma alloc_text(PAGENDST, ndisMSetFunctionalAddress)
#pragma alloc_text(PAGENDST, ndisMSetGroupAddress)

//
// These are normally paged out and only get locked down when a fddi filter is created
//
#pragma alloc_text(PAGENDSF, FddiDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSF, fddiCompleteChangeFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiChangeFilterLongAddresses)
#pragma alloc_text(PAGENDSF, fddiCompleteChangeFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiChangeFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiNumberOfOpenFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiNumberOfOpenFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryOpenFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryOpenFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryGlobalFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryGlobalFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSF, fddiFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDSF, FddiFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSF, fddiFindMulticastLongAddress)
#pragma alloc_text(PAGENDSF, fddiFindMulticastShortAddress)
#pragma alloc_text(PAGENDSF, FddiShouldAddressLoopBack)
#pragma alloc_text(PAGENDSF, ndisMSetFddiMulticastList)
#pragma alloc_text(PAGENDSF, ndisMQueryLongMulticastList)
#pragma alloc_text(PAGENDSF, ndisMQueryShortMulticastList)

#if ARCNET

//
// These are normally paged out and only get locked down when arcnet filter is created
//
#pragma alloc_text(PAGENDSA, ArcAllocateBuffers)
#pragma alloc_text(PAGENDSA, ArcAllocatePackets)
#pragma alloc_text(PAGENDSA, ArcDiscardPacketBuffers)
#pragma alloc_text(PAGENDSA, ArcDestroyPacket)
#pragma alloc_text(PAGENDSA, ArcConvertToNdisPacket)
#pragma alloc_text(PAGENDSA, ArcFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSA, ArcNoteFilterOpenAdapter)
#pragma alloc_text(PAGENDSA, ArcDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSA, ArcFilterAdjust)
#pragma alloc_text(PAGENDSA, ArcFilterDoIndication)
#pragma alloc_text(PAGENDSA, ArcFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSA, ArcConvertOidListToEthernet)
#pragma alloc_text(PAGENDSA, ndisMArcTransferData)
#pragma alloc_text(PAGENDSA, ndisMArcIndicateEthEncapsulatedReceive)
#pragma alloc_text(PAGENDSA, ndisMBuildArcnetHeader)
#pragma alloc_text(PAGENDSA, ndisMFreeArcnetHeader)
#pragma alloc_text(PAGENDSA, ndisMArcnetSendLoopback)
#pragma alloc_text(PAGENDSA, arcUndoFilterAdjust)

#endif

#if 0
//
// These routines belong in the .text object. List here for reference only
//
#pragma alloc_text(text, NDIS_BUFFER_TO_SPAN_PAGES)
#pragma alloc_text(text, NdisQueryBuffer)
#pragma alloc_text(text, NdisQueryBufferSafe)
#pragma alloc_text(text, NdisQueryBufferOffset)
#pragma alloc_text(text, NdisCopyBuffer)
#pragma alloc_text(text, NdisAllocateBuffer)
#pragma alloc_text(text, NdisAdjustBufferLength)
#pragma alloc_text(text, NdisUnchainBufferAtFront)
#pragma alloc_text(text, NdisUnchainBufferAtBack)
#pragma alloc_text(text, NdisCopyFromPacketToPacket)
#pragma alloc_text(text, NdisCopyFromPacketToPacketSafe)
#pragma alloc_text(text, NdisAllocateMemory)
#pragma alloc_text(text, NdisAllocateMemoryWithTag)
#pragma alloc_text(text, NdisAllocatePacketPool)
#pragma alloc_text(text, NdisAllocatePacketPoolEx)
#pragma alloc_text(text, NdisFreeMemory)
#pragma alloc_text(text, ndisAllocationExecutionRoutine)
#pragma alloc_text(text, NdisAllocateBufferPool)
#pragma alloc_text(text, NdisSystemProcessorCount)
#pragma alloc_text(text, NdisSetTimer)
#pragma alloc_text(text, NdisInitializeTimer)
#pragma alloc_text(text, NdisReadPciSlotInformation)
#pragma alloc_text(text, NdisWritePciSlotInformation)
#pragma alloc_text(text, NdisReadPcmciaAttributeMemory)
#pragma alloc_text(text, NdisWritePcmciaAttributeMemory)
#pragma alloc_text(text, ndisReferencePackage)
#pragma alloc_text(text, ndisDereferencePackage)
#pragma alloc_text(text, NdisAllocatePacket)
#pragma alloc_text(text, NdisFreePacketPool)
#pragma alloc_text(text, ndisFreePacketPool)
#pragma alloc_text(text, ndisVerifierFreePacketPool)
#pragma alloc_text(text, NdisFreePacket)
#pragma alloc_text(text, NdisPacketPoolUsage)
#pragma alloc_text(text, NdisUpdateSharedMemory)
#pragma alloc_text(text, NdisGetSystemUpTime)
#pragma alloc_text(text, NdisGetCurrentProcessorCpuUsage)
#pragma alloc_text(text, NdisGetCurrentProcessorCounts)
#pragma alloc_text(text, NdisGetCurrentSystemTime)
#pragma alloc_text(text, NdisInitializeEvent)
#pragma alloc_text(text, NdisSetEvent)
#pragma alloc_text(text, NdisResetEvent)
#pragma alloc_text(text, NdisWaitEvent)
#pragma alloc_text(text, NdisScheduleWorkItem)
#pragma alloc_text(text, NdisInitializeString)
#pragma alloc_text(text, NdisSetupDmaTransfer)
#pragma alloc_text(text, NdisCompleteDmaTransfer)
#pragma alloc_text(text, NdisMAllocateSharedMemoryAsync)
#pragma alloc_text(text, ndisBugcheckHandler)
#pragma alloc_text(text, NdisCancelTimer)
#pragma alloc_text(text, ndisCompletionRoutine)
#pragma alloc_text(text, ndisMSendX)
#pragma alloc_text(text, NdisAllocateSpinLock)
#pragma alloc_text(text, NdisFreeSpinLock)
#pragma alloc_text(text, NdisFreeSpinLock)
#pragma alloc_text(text, NdisAcquireSpinLock)
#pragma alloc_text(text, NdisReleaseSpinLock)
#pragma alloc_text(text, NdisDprAcquireSpinLock)
#pragma alloc_text(text, NdisDprReleaseSpinLock)
#pragma alloc_text(text, NdisFreeBuffer)
#pragma alloc_text(text, NdisFreeBufferPool)
#pragma alloc_text(text, NdisGetFirstBufferFromPacket)
#pragma alloc_text(text, NdisBufferLength)
#pragma alloc_text(text, NdisBufferVirtualAddress)
#pragma alloc_text(text, NdisGetBufferPhysicalArraySize)
#pragma alloc_text(text, NdisAnsiStringToUnicodeString)
#pragma alloc_text(text, NdisUnicodeStringToAnsiString)
#pragma alloc_text(text, NdisCompareAnsiString)
#pragma alloc_text(text, NdisCompareUnicodeString)
#pragma alloc_text(text, NdisUpcaseUnicodeString)
#pragma alloc_text(text, ndisDmaExecutionRoutine)
#pragma alloc_text(text, NdisWriteErrorLogEntry)
#pragma alloc_text(text, ndisReferenceRef)
#pragma alloc_text(text, ndisDereferenceRef)
#pragma alloc_text(text, ndisCloseRef)
#pragma alloc_text(text, ndisCloseULongRef)
#pragma alloc_text(text, ndisCancelLogIrp)
#pragma alloc_text(text, ndisMIrpCompletion)
#pragma alloc_text(text, ndisPassIrpDownTheStack)
#pragma alloc_text(text, ndisWaitWakeComplete)
#pragma alloc_text(text, ndisQueryPowerComplete)
#pragma alloc_text(text, ndisRequestedDevicePowerIrpComplete)
#pragma alloc_text(text, ndisSetDevicePowerOnComplete)
#pragma alloc_text(text, ndisSetDevicePowerDownComplete)
#pragma alloc_text(text, ndisWmiGetGuid)
#pragma alloc_text(text, ndisDereferenceDriver)
#pragma alloc_text(text, NdisGetSharedDataAlignment)
#endif  // if 0

#endif  // ALLOC_PRAGMA

#endif  // _PRAGMA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndis_co.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndis_co.c

Abstract:

    CO-NDIS miniport wrapper functions

Author:

    Jameel Hyder (JameelH) 01-Feb-96

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#include <atm.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS_CO

/*
    Connection-oriented section of NDIS exposes the following objects and apis to
    manipulate these objects.

    AF      Address Family
    SAP     Service Access Point
    VC      Virtual Circuit
    Party   A node in a point-multipoint VC

    There is a notion of a call-manager and a client on a per-binding basis. The
    call manager acts as a helper dll for NDIS wrapper to manage the aforementioned
    objects.

    The concept of AF makes possible the existence of multiple call-managers. An
    example of this is the UNI call-manager and a SPANS call-manager for the ATM
    media.

    SAPs provides a way for incoming calls to be routed to the right entity. A
    protocol can register for more than one SAPs. Its upto the call-manager to
    allow/dis-allow multiple protocol modules to register the same SAP.

    VCs are created either by a protocol module requesting to make an outbound call
    or by the call-manager dispatching an incoming call. VCs can either be point-point
    or point-multi-point. Leaf nodes can be added to VCs at any time provided the first
    leaf was created appropriately.

    References:

    An AF association results in the reference of file-object for the call-manager.

    A SAP registration results in the reference of the AF.

    A send or receive does not reference a VC. This is because miniports are required to
    pend DeactivateVc calls till all I/O completes. So when it calls NdisMCoDeactivateVcComplete
    no other packets will be indicated up and there are no sends outstanding.
*/

NDIS_STATUS
NdisCmRegisterAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS  CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    )
/*++

Routine Description:
    This is a call from the call-manager to register the address family
    supported by this call-manager.

Arguments:
    NdisBindingHandle       - Pointer to the call-managers NDIS_OPEN_BLOCK.
    AddressFamily           - The address family being registered.
    CmCharacteristics       - Call-Manager characteristics
    SizeOfCmCharacteristics - Size of Call-Manager characteristics

Return Value:
    NDIS_STATUS_SUCCESS if the address family registration is successfully.
    NDIS_STATUS_FAILURE if the caller is not a call-manager or this address
                        family is already registered for this miniport.

--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;
    PNDIS_AF_LIST               AfList;
    PNDIS_PROTOCOL_BLOCK        Protocol;
    PNDIS_OPEN_BLOCK            CallMgrOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_AF_NOTIFY             AfNotify = NULL;
    BOOLEAN                     fDerefCallMgrOpen = FALSE;


    CallMgrOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = CallMgrOpen->MiniportHandle;
    Protocol = CallMgrOpen->ProtocolHandle;

    PnPReferencePackage();

    //
    // Make sure that the miniport is a CoNdis miniport and
    // there is no other module registering the same address family.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    do
    {
        CallMgrOpen->Flags |= fMINIPORT_OPEN_CALL_MANAGER;
        
        //
        // Make sure the binding is not closing down
        //
        ACQUIRE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
        if (MINIPORT_TEST_FLAG(CallMgrOpen, fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_UNBINDING))
        {
            RELEASE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
            Status = NDIS_STATUS_CLOSING;
            break;
        }
        else
        {
            //
            // Reference the client open
            //
            M_OPEN_INCREMENT_REF_INTERLOCKED(CallMgrOpen);
            fDerefCallMgrOpen = TRUE;
            RELEASE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
        }

        //
        // Make sure that the miniport is a CoNdis miniport and
        // protocol is also a NDIS 5.0 or later protocol.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //1 replace with a better check
        if (Protocol->ProtocolCharacteristics.MajorNdisVersion < 5)
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        //
        // Make sure that the call-manager characteristics are 5.0 or later
        //
        if ((SizeOfCmCharacteristics < sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS)) ||
            (CmCharacteristics->MajorVersion < 5))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //
        // Search registered call-managers for this miniport and make sure there is no
        // clash. A call-manager can only register one address family per-open. This
        // is due to the way we cache handlers. Can be over-come if the handlers are
        // identical for each address-family - but decided not to since it is un-interesting.
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (NdisEqualMemory(&AfList->AddressFamily, AddressFamily, sizeof(CO_ADDRESS_FAMILY)))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }

        if (AfList == NULL)
        {
            //
            // No other entity has claimed this address family.
            // Allocate an AfList and a notify structure
            //
            AfList = (PNDIS_AF_LIST)ALLOC_FROM_POOL(sizeof(NDIS_AF_LIST), NDIS_TAG_CO);
            if (AfList == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            Status = ndisCreateNotifyQueue(Miniport, NULL, AddressFamily, &AfNotify);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                FREE_POOL(AfList);
                break;
            }

            AfList->AddressFamily = *AddressFamily;
            CopyMemory(&AfList->CmChars,
                       CmCharacteristics,
                       sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

            //
            // link it in the miniport list
            //
            AfList->Open = CallMgrOpen;
            AfList->NextAf = Miniport->CallMgrAfList;
            Miniport->CallMgrAfList = AfList;

            //
            // Finally cache some handlers in the open-block
            //
            CallMgrOpen->CoCreateVcHandler = CmCharacteristics->CmCreateVcHandler;
            CallMgrOpen->CoDeleteVcHandler = CmCharacteristics->CmDeleteVcHandler;
            (CM_ACTIVATE_VC_COMPLETE_HANDLER)CallMgrOpen->CmActivateVcCompleteHandler = CmCharacteristics->CmActivateVcCompleteHandler;
            (CM_DEACTIVATE_VC_COMPLETE_HANDLER)CallMgrOpen->CmDeactivateVcCompleteHandler = CmCharacteristics->CmDeactivateVcCompleteHandler;
            (CO_REQUEST_COMPLETE_HANDLER)CallMgrOpen->CoRequestCompleteHandler = CmCharacteristics->CmRequestCompleteHandler;

            if (AfNotify != NULL)
            {
                //
                // Notify existing clients of this registration
                //
                QUEUE_WORK_ITEM(&AfNotify->WorkItem, DelayedWorkQueue);
            }
        }
    } while (FALSE);

    if (fDerefCallMgrOpen)
    {
        ndisMDereferenceOpen(CallMgrOpen);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    return(Status);
}


NDIS_STATUS
NdisMCmRegisterAddressFamily(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    )
/*++

Routine Description:
    This is a call from the miniport supported call-manager to register the address family
    supported by this call-manager.

Arguments:
    MiniportAdapterHandle   - Pointer to the miniports NDIS_MINIPORT_BLOCK.
    AddressFamily           - The address family being registered.
    CmCharacteristics       - Call-Manager characteristics
    SizeOfCmCharacteristics - Size of Call-Manager characteristics

Return Value:
    NDIS_STATUS_SUCCESS if the address family registration is successfully.
    NDIS_STATUS_FAILURE if the caller is not a call-manager or this address
                        family is already registered for this miniport.

--*/
{
    PNDIS_MINIPORT_BLOCK        Miniport;
    NDIS_STATUS                 Status = NDIS_STATUS_CLOSING;
    PNDIS_AF_LIST               AfList;
    KIRQL                       OldIrql;

    PnPReferencePackage();

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    //
    // Make sure that the miniport is a CoNdis miniport and
    // there is no other module registering the same address family.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    do
    {
        //
        // Make sure that the miniport is a CoNdis miniport
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the call-manager characteristics are 5.0 or later
        //
        if ((CmCharacteristics->MajorVersion < 5) ||
            (SizeOfCmCharacteristics < sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS)))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Search registered call-managers for this miniport and make sure there is no
        // clash. A call-manager can only register one address family per-open. This
        // is due to the way we cache handlers. Can be over-come if the handlers are
        // identical for each address-family - but decided not to since it is un-interesting.
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (NdisEqualMemory(&AfList->AddressFamily, AddressFamily, sizeof(CO_ADDRESS_FAMILY)))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }

        if ((AfList == NULL) && MINIPORT_INCREMENT_REF(Miniport))
        {
            //
            // No other entity has claimed this address family.
            // Allocate an AfList and a notify structure
            //
            AfList = (PNDIS_AF_LIST)ALLOC_FROM_POOL(sizeof(NDIS_AF_LIST), NDIS_TAG_CO);
            if (AfList == NULL)
            {
                MINIPORT_DECREMENT_REF(Miniport);
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            AfList->AddressFamily = *AddressFamily;
            CopyMemory(&AfList->CmChars,
                       CmCharacteristics,
                       sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

            //
            // link it in the miniport list
            //
            AfList->Open = NULL;
            AfList->NextAf = Miniport->CallMgrAfList;
            Miniport->CallMgrAfList = AfList;

            MINIPORT_DECREMENT_REF(Miniport);
            Status = NDIS_STATUS_SUCCESS;
        }
    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    return Status;
}


NDIS_STATUS
ndisCreateNotifyQueue(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open            OPTIONAL,
    IN  PCO_ADDRESS_FAMILY              AddressFamily   OPTIONAL,
    IN  PNDIS_AF_NOTIFY         *       AfNotify
    )
/*++

Routine Description:

    Collect a set of address-family notifications that can then be passed on to ndisNotifyAfRegistration.
    If the Open is NULL, this implies that an AddressFamily is being registered and must be notified to
    all protocols on this miniport. If the AddressFamily is NULL (and the Open is specified) then all
    registered AddressFamilies on this miniport must be indicated to the Open.

Arguments:

    Miniport    -   Miniport of interest
    Open        -   Optional - see comments above
    AddressFamily - Optional - see comments above
    AfNotify    -   Place holder for the list of notifications

Return Value:
    NDIS_STATUS_SUCCESS     - No errors, AfNotify can be NULL
    NDIS_STATUS_RESOURCES   - Failed to allocate memory

Note: Called at DPC with Miniport lock held.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PNDIS_AF_NOTIFY     AfN;
    PNDIS_OPEN_BLOCK    tOpen;
    PNDIS_AF_LIST       AfList;
    ULONG               Ref;
    BOOLEAN             fDereferenceAfNotification = FALSE;

    ASSERT(ARGUMENT_PRESENT(Open) ^ ARGUMENT_PRESENT(AddressFamily));

    *AfNotify = NULL;
    if (ARGUMENT_PRESENT(Open))
    {
        
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        
        ASSERT(Open->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL);

        do
        {

            if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
            {
                //
                // this open is going away.
                //
                break;
            }


            for (AfList = Miniport->CallMgrAfList;
                 AfList != NULL;
                 AfList = AfList->NextAf)
            {

                OPEN_INCREMENT_AF_NOTIFICATION(Open);
        
                // DbgPrint("ndisCreateNotifyQueue: Open %p, AFNotifyRef %lx\n", Open, Open->PendingAfNotifications);
     
                AfN = (PNDIS_AF_NOTIFY)ALLOC_FROM_POOL(sizeof(NDIS_AF_NOTIFY), NDIS_TAG_CO);
                if (AfN == NULL)
                {
                    //
                    // undo all the AfNs we allocated so far
                    //
                    while(*AfNotify != NULL)
                    {
                        AfN = *AfNotify;
                        *AfNotify = AfN->Next;
                        FREE_POOL(AfN);
                        //
                        // this will not take the AfNotification ref to zero
                        // because we ref'ed once before the current failed
                        // allocation. set a flag to do the last deref later because
                        // we can not call ndisDereferenceAfNotification with the
                        // Open->SpinLock held.
                        //
                        OPEN_DECREMENT_AF_NOTIFICATION(Open, Ref);
                    }

                    Status = NDIS_STATUS_RESOURCES;
                    fDereferenceAfNotification = TRUE;
                    break;
                }
                
                AfN->Miniport = Miniport;
                AfN->Open = Open;
                M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
                AfN->AddressFamily = AfList->AddressFamily;
                //1 in practice, only the workitem on the head AfN needs to 
                //1 be initialized.
                INITIALIZE_WORK_ITEM(&AfN->WorkItem, ndisNotifyAfRegistration, AfN);
                AfN->Next = *AfNotify;
                *AfNotify = AfN;
            }

        }while (FALSE);
             
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
        
        if (fDereferenceAfNotification)
        {
            //
            // undo the ref for the failed allocation
            //
            ndisDereferenceAfNotification(Open);
        }
    }
    else
    {
        for (tOpen = Miniport->OpenQueue;
             tOpen != NULL;
             tOpen = tOpen->MiniportNextOpen)
        {
            if (tOpen->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL)
            {
                ACQUIRE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                if (MINIPORT_TEST_FLAG(tOpen, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
                {
                    //
                    // this open is going away. skip it.
                    //
                    RELEASE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                    continue;

                }
                else
                {
                    OPEN_INCREMENT_AF_NOTIFICATION(tOpen);
                    //DbgPrint("ndisCreateNotifyQueue: tOpen %p, AFNotifyRef %lx\n", tOpen, tOpen->PendingAfNotifications);
                    RELEASE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                }
                
                AfN = (PNDIS_AF_NOTIFY)ALLOC_FROM_POOL(sizeof(NDIS_AF_NOTIFY), NDIS_TAG_CO);
                if (AfN == NULL)
                {
                    //
                    // undo all the AfNs we allocated so far
                    //
                    while(*AfNotify != NULL)
                    {
                        AfN = *AfNotify;
                        *AfNotify = AfN->Next;
                        FREE_POOL(AfN);
                        //
                        // this will not take the AfNotification ref to zero
                        // because we ref'ed once before the current failed
                        // allocation.
                        //
                        OPEN_DECREMENT_AF_NOTIFICATION(tOpen, Ref);
                    }
                    
                    Status = NDIS_STATUS_RESOURCES;
                    ndisDereferenceAfNotification(tOpen);
                    break;
                }
                
                AfN->Miniport = Miniport;
                AfN->Open = tOpen;
                
                M_OPEN_INCREMENT_REF_INTERLOCKED(tOpen);
                AfN->AddressFamily = *AddressFamily;
                //1 in practice, only the workitem on the head AfN needs to 
                //1 be initialized.
                INITIALIZE_WORK_ITEM(&AfN->WorkItem, ndisNotifyAfRegistration, AfN);
                AfN->Next = *AfNotify;
                *AfNotify = AfN;
            }
        }
    }

    return Status;
}


VOID
ndisNotifyAfRegistration(
    IN  PNDIS_AF_NOTIFY         AfNotify
    )
/*++

Routine Description:

    Notify protocols that care that a new address family has been registered.

Arguments:
    AfNotify    - Structure that holds context information.

Return Value:
    None.

--*/
{
    KIRQL                   OldIrql;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_PROTOCOL_BLOCK    Protocol;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_AF_NOTIFY         Af, AfNext;

    Miniport = AfNotify->Miniport;

    PnPReferencePackage();


    for (Af = AfNotify; Af != NULL; Af = AfNext)
    {
        AfNext = Af->Next;
    
        Open = Af->Open;
        Protocol = Open->ProtocolHandle;
        
        if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
        {
            (*Protocol->ProtocolCharacteristics.CoAfRegisterNotifyHandler)(
                                Open->ProtocolBindingContext,
                                &Af->AddressFamily);
        }
        
        FREE_POOL(Af);

        ndisDereferenceAfNotification(Open);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        ndisMDereferenceOpen(Open);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }


    PnPDereferencePackage();
}


NDIS_STATUS
NdisClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ClientAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    )
/*++

Routine Description:
    This is a call from a NDIS 5.0 or later protocol to open a particular
    address familty - in essence getting a handle to the call-manager.

Arguments:
    NdisBindingHandle   - Pointer to the protocol's NDIS_OPEN_BLOCK.
    PCO_ADDRESS_FAMILY  - The address family being opned.
    ClientAfContext     - Protocol context associated with this handle.
    ClCharacteristics   - Client Characteristics associated with this AF
    SizeOfClCharacteristics - size of client Characteristics
    NdisAfHandle        - Handle returned by NDIS for this address family.

Return Value:
    NDIS_STATUS_SUCCESS if the address family open is successfully.
    NDIS_STATUS_PENDING if the call-manager pends this call. The caller will get
                        called at the completion handler when done.
    NDIS_STATUS_FAILURE if the caller is not a NDIS 5.0 prototcol or this address
                        family is not registered for this miniport.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_AF_LIST               AfList;
    PNDIS_OPEN_BLOCK            CallMgrOpen = NULL, ClientOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_PROTOCOL_BLOCK        Protocol;
    KIRQL                       OldIrql;
    NTSTATUS                    Status;
    BOOLEAN                     fDerefClientOpen = FALSE, fDerefCallMgrOpen = FALSE, fDerefMiniport = FALSE;

    *NdisAfHandle = NULL;
    ClientOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = ClientOpen->MiniportHandle;
    Protocol = ClientOpen->ProtocolHandle;

    PnPReferencePackage();

    do
    {
        ClientOpen->Flags |= fMINIPORT_OPEN_CLIENT;

        //
        // Make sure the binding is not closing down
        //
        //1 Open is not protected adequately.

        ACQUIRE_SPIN_LOCK(&ClientOpen->SpinLock, &OldIrql);
        if (MINIPORT_TEST_FLAG(ClientOpen, fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_UNBINDING))
        {
            RELEASE_SPIN_LOCK(&ClientOpen->SpinLock, OldIrql);
            Status = NDIS_STATUS_CLOSING;
            break;
        }
        else
        {
            //
            // Reference the client open
            //
            M_OPEN_INCREMENT_REF_INTERLOCKED(ClientOpen);
            InterlockedIncrement(&ClientOpen->AfReferences);
            fDerefClientOpen = TRUE;
            RELEASE_SPIN_LOCK(&ClientOpen->SpinLock, OldIrql);
        }

        //
        // Make sure that the miniport is a CoNdis miniport and
        // protocol is also a NDIS 5.0 or later protocol.
        //
        //1 do we need the first check if we do the second one.
        if ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion < 5) ||
            (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO)))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        if (Protocol->ProtocolCharacteristics.MajorNdisVersion < 5)
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        //
        // Make sure that the client characteristics are 5.0 or later
        //
        if ((SizeOfClCharacteristics < sizeof(NDIS_CLIENT_CHARACTERISTICS)) ||
            (ClCharacteristics->MajorVersion < 5))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        //
        // Search the miniport block for a registered call-manager for this address family
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (AfList->AddressFamily.AddressFamily == AddressFamily->AddressFamily)
            {
                CallMgrOpen = AfList->Open;
                break;
            }
        }

        if (AfList == NULL)
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (CallMgrOpen != NULL)
        {
            //
            // If we found a matching call manager, make sure that the callmgr
            // is not currently closing.
            //
            ACQUIRE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
            if (MINIPORT_TEST_FLAG(CallMgrOpen, fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_UNBINDING))
            {
                RELEASE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                Status = NDIS_STATUS_CLOSING;
                break;
            }
            else
            {
                M_OPEN_INCREMENT_REF_INTERLOCKED(CallMgrOpen);
                InterlockedIncrement(&CallMgrOpen->AfReferences);
                fDerefCallMgrOpen = TRUE;
                RELEASE_SPIN_LOCK_DPC(&CallMgrOpen->SpinLock);
            }
            
        }
        else 
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            else            
            {
                MINIPORT_INCREMENT_REF_NO_CHECK(Miniport);
                fDerefMiniport = TRUE;
            }            
        }


        //
        // Allocate memory for the AF block.
        //
        pAf = ALLOC_FROM_POOL(sizeof(NDIS_CO_AF_BLOCK), NDIS_TAG_CO);
        if (pAf == NULL)
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pAf->References = 1;
        pAf->Flags = (AfList->Open == NULL) ? AF_COMBO : 0;
        pAf->Miniport = Miniport;

        pAf->ClientOpen = ClientOpen;
        pAf->CallMgrOpen = CallMgrOpen = AfList->Open;
        pAf->ClientContext = ClientAfContext;

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        INITIALIZE_SPIN_LOCK(&pAf->Lock);

        //
        // Cache in call-manager entry points
        //
        pAf->CallMgrEntries = &AfList->CmChars;

        //
        // And also Cache in client entry points
        //
        CopyMemory(&pAf->ClientEntries,
                   ClCharacteristics,
                   sizeof(NDIS_CLIENT_CHARACTERISTICS));


        //
        // Cache some handlers in the open-block
        //
        ClientOpen->CoCreateVcHandler = ClCharacteristics->ClCreateVcHandler;
        ClientOpen->CoDeleteVcHandler = ClCharacteristics->ClDeleteVcHandler;
        ClientOpen->CoRequestCompleteHandler = ClCharacteristics->ClRequestCompleteHandler;

        //
        // Now call the CallMgr's OpenAfHandler
        //
        Status = (*AfList->CmChars.CmOpenAfHandler)((CallMgrOpen != NULL) ?
                                                        CallMgrOpen->ProtocolBindingContext :
                                                        Miniport->MiniportAdapterContext,
                                                    AddressFamily,
                                                    pAf,
                                                    &pAf->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmOpenAddressFamilyComplete(Status,
                                            pAf,
                                            pAf->CallMgrContext);
            Status = NDIS_STATUS_PENDING;
        }

        fDerefClientOpen = fDerefCallMgrOpen = fDerefMiniport = FALSE;
        

    } while (FALSE);

    if(fDerefClientOpen)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        InterlockedDecrement(&ClientOpen->AfReferences);
        ndisMDereferenceOpen(ClientOpen);        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    if(CallMgrOpen && fDerefCallMgrOpen)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        InterlockedDecrement(&CallMgrOpen->AfReferences);
        ndisMDereferenceOpen(CallMgrOpen);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    if(fDerefMiniport)
    {
        MINIPORT_DECREMENT_REF(Miniport);        
    }

    PnPDereferencePackage();
        
    return Status;
}


VOID
NdisCmOpenAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             CallMgrAfContext
    )
/*++

Routine Description:

    Completion routine for the OpenAddressFamily call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock
    CallMgrAfContext    -   Call manager's context used in other calls into the call manager.

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_OPEN_BLOCK            ClientOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    ASSERT(Status != NDIS_STATUS_PENDING);

    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    ClientOpen = pAf->ClientOpen;
    Miniport = pAf->Miniport;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    pAf->CallMgrContext = CallMgrAfContext;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // OpenAfHandler failed
        //
        if (pAf->CallMgrOpen != NULL)
        {
            InterlockedDecrement(&pAf->CallMgrOpen->AfReferences);
            ndisMDereferenceOpen(pAf->CallMgrOpen);
        }
        else
        {
            MINIPORT_DECREMENT_REF(Miniport);
        }

        InterlockedDecrement(&ClientOpen->AfReferences);
        ndisMDereferenceOpen(ClientOpen);
    }
    else
    {
        //
        // queue this CallMgr open onto the miniport open
        //
        //1 fix the above comment. it is queued on the open between client and
        //1 miniport

        //1 what is protecting the AF list  (NextAf field) on client open?
        //1 miniport's spinlock?
        pAf->NextAf = ClientOpen->NextAf;
        ClientOpen->NextAf = pAf;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    //
    // Finally call the client's completion handler
    //
    (*pAf->ClientEntries.ClOpenAfCompleteHandler)(Status,
                                                  pAf->ClientContext,
                                                  (Status == NDIS_STATUS_SUCCESS) ? pAf : NULL);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        FREE_POOL(pAf);
    }

}


NDIS_STATUS
NdisClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    )
/*++

Routine Description:

    This call closes the Af object which essentially tears down the client-callmanager
    'binding'. Causes all open Vcs to be closed and saps to be de-registered "by the call
    manager".

Arguments:

    NdisAfHandle - Pointer to the Af.

Return Value:

    Status from Call Manager.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;

    //
    // Mark the address family as closing and call the call-manager to process.
    //
    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);
    if (pAf->Flags & AF_CLOSING)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    pAf->Flags |= AF_CLOSING;
    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Status = (*pAf->CallMgrEntries->CmCloseAfHandler)(pAf->CallMgrContext);
        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmCloseAddressFamilyComplete(Status, pAf);
            Status = NDIS_STATUS_PENDING;
        }
    }

    return Status;
}


VOID
NdisCmCloseAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle
    )
/*++

Routine Description:

    Completion routine for the CloseAddressFamily call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    PNDIS_CO_AF_BLOCK *         ppAf;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    Miniport = pAf->Miniport;

    //
    // NOTE: Memphis closes the adapters synchronously. so we have to deref
    // the open -before- calling ClCloseAfCompleteHandler because
    // ClCloseAfCompleteHandler will try to close the adapter and CloseAdapter
    // will pend forever since the ref count never goes to zero
    //
    
    //
    // Complete the call to the client
    //
    (*pAf->ClientEntries.ClCloseAfCompleteHandler)(Status,
                                                   pAf->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Miniport = pAf->Miniport;

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        if (pAf->CallMgrOpen != NULL)
        {
            InterlockedDecrement(&pAf->CallMgrOpen->AfReferences);
            ndisMDereferenceOpen(pAf->CallMgrOpen);
        }
        else
        {
            MINIPORT_DECREMENT_REF_NO_CLEAN_UP(Miniport);
        }

        //1 again, looks like the AF list on client's open is protected
        //1 by miniport's spinlock.
        //
        //  Unlink from list of open AFs for this client.
        //
        for (ppAf = &pAf->ClientOpen->NextAf;
             *ppAf != NULL;
             ppAf = &((*ppAf)->NextAf))
        {
            if (*ppAf == pAf)
            {
                *ppAf = pAf->NextAf;
                break;
            }
        }

        InterlockedDecrement(&pAf->ClientOpen->AfReferences);
        ndisMDereferenceOpen(pAf->ClientOpen);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    }

    //
    // Finally dereference the AF Block, if the call-manager successfully closed it.
    //
    //1 we should not let CallManager to fail this call.
    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pAf);
    }
}


BOOLEAN
FASTCALL
ndisReferenceAf(
    IN  PNDIS_CO_AF_BLOCK   pAf
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);

    if ((pAf->Flags & AF_CLOSING) == 0)
    {
        pAf->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceAf(
    IN  PNDIS_CO_AF_BLOCK   pAf
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Done = FALSE;

    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);

    ASSERT(pAf->References > 0);
    pAf->References --;
    if (pAf->References == 0)
    {
        ASSERT(pAf->Flags & AF_CLOSING);
        Done = TRUE;
    }

    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    if (Done)
        FREE_POOL(pAf);
}


NDIS_STATUS
NdisClRegisterSap(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 Sap,
    OUT PNDIS_HANDLE            NdisSapHandle
    )
/*++

Routine Description:
    This is a call from a NDIS 5.0 or later protocol to register its SAP
    with the call manager.

Arguments:
    NdisAfHandle        - Pointer to NDIS handle for this AF.
    ProtocolSapContext  - Protocol context associated with this SAP.
    Sap                 - The SAP being registered.
    NdisSapHandle       - Handle returned by NDIS for this SAP.

Return Value:
    NDIS_STATUS_SUCCESS if the SAP was registered successfully.
    NDIS_STATUS_PENDING if the call-manager pends this call. The caller will get
    called at its ClRegisterSapCompleteHandler
    
    NDIS_STATUS_FAILURE if the SAP could not be registered
--*/
{
    NDIS_STATUS                 Status;
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    PNDIS_CO_SAP_BLOCK          pSap;

    *NdisSapHandle = NULL;
    do
    {
        //
        // Reference the Af for this SAP
        //
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pSap = (PNDIS_CO_SAP_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_CO_SAP_BLOCK), NDIS_TAG_CO);
        if (pSap == NULL)
        {
            *NdisSapHandle = NULL;
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pSap->Flags = 0;
        pSap->References = 1;
        INITIALIZE_SPIN_LOCK(&pSap->Lock);
        pSap->AfBlock = pAf;
        pSap->Sap = Sap;
        pSap->ClientContext = ProtocolSapContext;
        Status = (*pAf->CallMgrEntries->CmRegisterSapHandler)(pAf->CallMgrContext,
                                                              Sap,
                                                              pSap,
                                                              &pSap->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmRegisterSapComplete(Status, pSap, pSap->CallMgrContext);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    return Status;
}


VOID
NdisCmRegisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             CallMgrSapContext
    )
/*++

Routine Description:
    Completion routine for the registerSap call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock
    CallMgrAfContext    -   Call manager's context used in other calls into the call manager.

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    PNDIS_CO_AF_BLOCK   pAf;

    ASSERT(Status != NDIS_STATUS_PENDING);

    pAf = pSap->AfBlock;
    pSap->CallMgrContext = CallMgrSapContext;

    //
    // Call the clients completion handler
    //
    (*pAf->ClientEntries.ClRegisterSapCompleteHandler)(Status,
                                                       pSap->ClientContext,
                                                       pSap->Sap,
                                                       pSap);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pSap->AfBlock);
        FREE_POOL(pSap);
    }
}


NDIS_STATUS
NdisClDeregisterSap(
    IN  NDIS_HANDLE             NdisSapHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    NDIS_STATUS         Status;
    KIRQL               OldIrql;
    BOOLEAN             fAlreadyClosing;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    fAlreadyClosing = FALSE;
    if (pSap->Flags & SAP_CLOSING)
    {
        fAlreadyClosing = TRUE;
    }
    pSap->Flags |= SAP_CLOSING;

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    if (fAlreadyClosing)
    {
        return NDIS_STATUS_FAILURE;
    }

    //
    // Notify the call-manager that this sap is being de-registered
    //
    Status = (*pSap->AfBlock->CallMgrEntries->CmDeregisterSapHandler)(pSap->CallMgrContext);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmDeregisterSapComplete(Status, pSap);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


VOID
NdisCmDeregisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Complete the call to the client and deref the sap
    //
    (*pSap->AfBlock->ClientEntries.ClDeregisterSapCompleteHandler)(Status,
                                                                   pSap->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pSap->AfBlock);
        ndisDereferenceSap(pSap);
    }
}


BOOLEAN
FASTCALL
ndisReferenceSap(
    IN  PNDIS_CO_SAP_BLOCK  pSap
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    if ((pSap->Flags & SAP_CLOSING) == 0)
    {
        pSap->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceSap(
    IN  PNDIS_CO_SAP_BLOCK  pSap
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Done = FALSE;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    ASSERT(pSap->References > 0);
    pSap->References --;
    if (pSap->References == 0)
    {
        ASSERT(pSap->Flags & SAP_CLOSING);
        Done = TRUE;
    }

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    if (Done)
        FREE_POOL(pSap);
}


NDIS_STATUS
NdisCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT  PNDIS_HANDLE        NdisVcHandle
    )
/*++

Routine Description:
    This is a call from either the call-manager or from the client to create a vc.
    The vc would then be owned by call-manager (signalling vc) or the client.
    This is a synchronous call to all parties and simply creates an end-point over
    which either incoming calls can be dispatched or out-going calls can be made.

    Combined Miniport/Call Manager drivers call NdisMCmCreateVc instead of NdisCoCreateVc.

Arguments:
    NdisBindingHandle   - Pointer to the caller's NDIS_OPEN_BLOCK.
    NdisAfHandle        - Pointer to the AF Block. Not specified for call-manager's private vcs.
    NdisVcHandle        - Where the handle to this Vc will be returned. If this is non-NULL,
                          then we assume a valid Vc and return a new handle to it (this would be
                          a call from the NDIS Proxy to create a second handle to an existing Vc).

Return Value:
    NDIS_STATUS_SUCCESS if all the components succeed.
    ErrorCode           to signify why the call failed.

--*/
{
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;          // VcPtr is returned in NdisVcHandle
    PNDIS_CO_VC_PTR_BLOCK   ExistingVcPtr;  // Passed in optionally by caller
    PNDIS_CO_VC_BLOCK       VcBlock;        // Created if ExistingVcPtr is NULL
    KIRQL                   OldIrql;
    BOOLEAN                 bCallerIsProxy;
    BOOLEAN                 bCallerIsClient;
    BOOLEAN                 bVcToComboMiniport; // VC being created to Integrated MCM

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("=>NdisCoCreateVc\n"));

    //
    //  Get the caller's open for the miniport.
    //
    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = Open->MiniportHandle;

    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

    //
    //  Is this VC being created to an integrated call manager + miniport driver?
    //
    bVcToComboMiniport = ((pAf) && ((pAf->Flags & AF_COMBO) != 0));

    //
    //  The caller is either a Client or a Call manager.
    //
    bCallerIsClient = ((pAf != NULL) && (Open == pAf->ClientOpen));

    //
    //  The caller could be a Proxy protocol.
    //
    bCallerIsProxy = ((Open->ProtocolHandle->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_PROXY) != 0);

    //
    //  A proxy protocol could pass in its handle to an existing VC, in order
    //  to "duplicate" it to another client.
    //
    ExistingVcPtr = *NdisVcHandle;


    //
    //  Initialize.
    //
    VcPtr = NULL;
    VcBlock = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        //
        //  Only a proxy protocol can pass in an existing VC pointer.
        //
        if (ExistingVcPtr && !bCallerIsProxy)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Allocate context for this VC creation: a VC Pointer Block.
        //  We return a pointer to this as the NdisVcHandle for the caller.
        //
        VcPtr = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_PTR_BLOCK), NDIS_TAG_CO);
        if (VcPtr == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize the VC Ptr
        //
        NdisZeroMemory(VcPtr, sizeof(NDIS_CO_VC_PTR_BLOCK));
        INITIALIZE_SPIN_LOCK(&VcPtr->Lock);
        InitializeListHead(&VcPtr->CallMgrLink);
        InitializeListHead(&VcPtr->ClientLink);
        InitializeListHead(&VcPtr->VcLink);


        if (ExistingVcPtr == NULL)
        {
            //
            //  New VC being created. Allocate and prepare the base VC block.
            //
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCoCreateVc: passed in ptr == NULL\n"));
            
            VcBlock = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_BLOCK), NDIS_TAG_CO);
            if (VcBlock == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                FREE_POOL(VcPtr);
                VcPtr = NULL;
                break;
            }

            //
            //  Initialize the VC block
            //
            NdisZeroMemory(VcBlock, sizeof(NDIS_CO_VC_BLOCK));
            INITIALIZE_SPIN_LOCK(&VcBlock->Lock);

            //
            //  Stick the Miniport in the VC for use in NdisM functions
            //
            VcBlock->Miniport = Miniport;

            if (!bVcToComboMiniport)
            {
                //
                //  Call the miniport to get its context for this VC.
                //
                Status = (*Open->MiniportCoCreateVcHandler)(Miniport->MiniportAdapterContext,
                                                            VcPtr,
                                                            &VcPtr->MiniportContext);

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    FREE_POOL(VcBlock);
                    break;
                }
            }
        }
        else
        {
            //
            //  A VC Pointer was passed in.
            //

            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCoCreateVc: NdisVcHandle is not NULL!\n"));

            //
            //  Get the Vc from the passed-in VcPtr.
            //
            VcBlock = ExistingVcPtr->VcBlock;

            //
            // Copy the Miniport Context into the new VC ptr.
            //
            VcPtr->MiniportContext = ExistingVcPtr->MiniportContext;
        }

        //
        //  Cache some miniport handlers in the new VC pointer Block
        //
        VcPtr->WCoSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CoSendPacketsHandler;

        if (!bVcToComboMiniport)
        {
            //
            //  For an MCM driver, CreateVc and DeleteVc go only to the Call Manager
            //  section.
            //
            VcPtr->WCoDeleteVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeleteVcHandler;
        }

        VcPtr->WCoActivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoActivateVcHandler;
        VcPtr->WCoDeactivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeactivateVcHandler;

        //
        //  Set up some reverse pointers in the new VC Pointer Block
        //
        VcPtr->Miniport = Miniport;
        VcPtr->VcBlock = VcBlock;
        VcPtr->AfBlock = pAf;

        VcPtr->References = 1;
        VcPtr->pVcFlags = &VcBlock->Flags;

        if (ARGUMENT_PRESENT(NdisAfHandle))
        {
            //
            //  This VC is associated with an AF block, meaning that it is
            //  a normal Client-CM-Miniport VC.
            //
            VcPtr->ClientOpen = pAf->ClientOpen;
            VcPtr->CallMgrOpen = pAf->CallMgrOpen;

            //
            //  Cache non-data path client handlers in new VcPtr.
            //
            VcPtr->ClModifyCallQoSCompleteHandler = pAf->ClientEntries.ClModifyCallQoSCompleteHandler;
            VcPtr->ClIncomingCallQoSChangeHandler = pAf->ClientEntries.ClIncomingCallQoSChangeHandler;
            VcPtr->ClCallConnectedHandler = pAf->ClientEntries.ClCallConnectedHandler;
    
            VcPtr->CmActivateVcCompleteHandler = pAf->CallMgrEntries->CmActivateVcCompleteHandler;
            VcPtr->CmDeactivateVcCompleteHandler = pAf->CallMgrEntries->CmDeactivateVcCompleteHandler;
            VcPtr->CmModifyCallQoSHandler = pAf->CallMgrEntries->CmModifyCallQoSHandler;

            //
            //  Mark this VC if the proxy is handing it off to a proxied client.
            //
            if (ExistingVcPtr != NULL)
            {
                VcBlock->Flags |= VC_HANDOFF_IN_PROGRESS;
            }

            //
            //  Update data path handlers based on who is calling this, and for
            //  what purpose.
            //

            if (!bCallerIsProxy)
            {
                VcBlock->ClientOpen = pAf->ClientOpen;
                VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;

                VcPtr->OwnsVcBlock = TRUE;

                if (bCallerIsClient)
                {
                    //
                    //  Client-created VC, for an outgoing call.
                    //
                    VcBlock->pClientVcPtr = VcPtr;
                }
                else
                {
                    //
                    //  Call Manager-created VC, for an incoming call.
                    //
                    VcBlock->pProxyVcPtr = VcPtr;
                }
            }
            else
            {
                //
                //  The caller is a proxy.
                //
                if (bCallerIsClient)
                {
                    //
                    //  CreateVc from a proxy client to a real Call manager.
                    //
                    if (ExistingVcPtr == NULL)
                    {
                        //
                        //  Proxy client creating a new VC, e.g. for a TAPI outgoing call.
                        //
                        VcBlock->ClientOpen = pAf->ClientOpen;
                        VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                        VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
                    }
                    else
                    {
                        //
                        //  Proxy client creating a VC on behalf of a CreateVc called
                        //  by a proxied client. The data handlers belong to the
                        //  proxied client, but deletion of this VC does not.
                        //
                        VcBlock->pClientVcPtr = ExistingVcPtr;
                        ExistingVcPtr->OwnsVcBlock = FALSE;  // Real (Proxied) Client doesn't own it
                    }

                    VcBlock->pProxyVcPtr = VcPtr;
                    VcPtr->OwnsVcBlock = TRUE; //  Proxy client owns it
                }
                else
                {
                    //
                    //  CreateVc from a proxy Call manager to a proxied client.
                    //
                    VcBlock->ClientOpen = pAf->ClientOpen;
                    VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                    VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
                    VcBlock->pClientVcPtr = VcPtr;
    
                    if (ExistingVcPtr != NULL)
                    {
                        //
                        //  Proxy CM forwarding a call to a proxied client.
                        //
                        VcBlock->pProxyVcPtr = ExistingVcPtr;
                        ExistingVcPtr->OwnsVcBlock = TRUE;
                    }
                    else
                    {
                        //
                        //  Proxy CM creating a fresh VC to a proxied client.
                        //  No well-known examples of this case, here for completeness.
                        //
                        VcPtr->OwnsVcBlock = TRUE;
                    }
                }
            }

            //
            // Determine who the caller is and initialize the other. NOTE: As soon as the Proxy Create handler
            // is called, this function can get re-entered. Lock down the VcPtr.
            //
            //1 how can we re-enter this function?
            ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

            if (Open == pAf->ClientOpen)
            {
                VcPtr->ClientContext = ProtocolVcContext;

                //
                // Call-up to the call-manager now to get its context
                //
                Status = (*pAf->CallMgrEntries->CmCreateVcHandler)(pAf->CallMgrContext,
                                                                   VcPtr,
                                                                   &VcPtr->CallMgrContext);
                if (bVcToComboMiniport)
                {
                    //
                    //  Need the MiniportContext field filled in for NdisCoSendPackets
                    //
                    VcPtr->MiniportContext = VcPtr->CallMgrContext;
                }
            }
            else
            {
                ASSERT(pAf->CallMgrOpen == Open);

                VcPtr->CallMgrContext = ProtocolVcContext;

                //
                // Call-up to the client now to get its context
                //
                Status = (*pAf->ClientOpen->CoCreateVcHandler)(pAf->ClientContext,
                                                               VcPtr,
                                                               &VcPtr->ClientContext);
            }

            //
            // Set up Client Context in VC if non-proxy, so the miniport passes the right client
            // context (client's handle to the VcPtr) when indicating packets. If the passd-in handle
            // is NULL, it's simple -- move the context. If it's not NULL, AND this is a Proxy call mgr,
            // move it so data goes to the new client and not to the Proxy.
            //
            if ((Status == NDIS_STATUS_SUCCESS) &&
                ((ExistingVcPtr == NULL) || (bCallerIsProxy && !bCallerIsClient)))
            {
                VcBlock->ClientContext = VcPtr->ClientContext;
            }

            if (ExistingVcPtr != NULL)
            {
                VcBlock->Flags &= ~VC_HANDOFF_IN_PROGRESS;
            }

            RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                //  Link this VC Pointer in the client's and call manager's
                //  Open blocks. Also remember the DeleteVc handler of the
                //  non-creator of this VC pointer, to be called when this
                //  VC pointer is deleted.
                //
                if (bCallerIsClient)
                {
                    //
                    //  Link into Client's Open block.
                    //
                    ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                                &VcPtr->ClientLink,
                                                &Open->SpinLock);

                    VcPtr->DeleteVcContext = VcPtr->CallMgrContext;
                    VcPtr->CoDeleteVcHandler = pAf->CallMgrEntries->CmDeleteVcHandler;

                    if (!bVcToComboMiniport)
                    {
                        //
                        //  Link into CM's Open block.
                        //
                        ExInterlockedInsertHeadList(&pAf->CallMgrOpen->InactiveVcHead,
                                                    &VcPtr->CallMgrLink,
                                                    &pAf->CallMgrOpen->SpinLock);
                    }
                }
                else
                {
                    //
                    //  Caller is a Call Manager.
                    //
                    VcPtr->DeleteVcContext = VcPtr->ClientContext;
                    VcPtr->CoDeleteVcHandler = pAf->ClientOpen->CoDeleteVcHandler;

                    ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                                &VcPtr->CallMgrLink,
                                                &Open->SpinLock);
                    ExInterlockedInsertHeadList(&pAf->ClientOpen->InactiveVcHead,
                                                &VcPtr->ClientLink,
                                                &pAf->ClientOpen->SpinLock);
                }
            }
            else
            {
                //
                //  The target protocol (Client or CM) failed CreateVc.
                //  Tell the miniport about it.
                //
                NDIS_STATUS Sts;

                if ((ExistingVcPtr == NULL) && 
                     !bVcToComboMiniport &&
                     (VcPtr->WCoDeleteVcHandler != NULL))
                {
                    Sts = (*VcPtr->WCoDeleteVcHandler)(VcPtr->MiniportContext);
                }

                if (ExistingVcPtr == NULL)
                {
                    FREE_POOL(VcBlock);
                }

                FREE_POOL(VcPtr);
                VcPtr = NULL;
            }
        }
        else
        {
            //
            // No AF handle present. This is a call-manager only VC and so the call-manager
            // is the client and there is no call-manager associated with it. This VC cannot
            // be used with a ClMakeCall or CmDispatchIncomingCall. Set the client values to the
            // call-manager
            //
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                    ("NdisCoCreateVc: signaling vc\n"));
    
            VcPtr->ClientOpen = Open;
            VcPtr->ClientContext = ProtocolVcContext;
    
            VcBlock->pClientVcPtr = VcPtr;
            VcPtr->OwnsVcBlock = TRUE; // CM owns the VC block
    
            VcBlock->ClientContext = VcPtr->ClientContext;
            VcBlock->ClientOpen = Open;
            VcBlock->CoSendCompleteHandler = Open->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
            VcBlock->CoReceivePacketHandler = Open->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
    
            //
            // Do set the following call-manager entries since this VC will need to be
            // activated. Also set the call-managers context for the same reasons.
            //
            VcPtr->CmActivateVcCompleteHandler = Open->CmActivateVcCompleteHandler;
            VcPtr->CmDeactivateVcCompleteHandler = Open->CmDeactivateVcCompleteHandler;
            VcPtr->CallMgrContext = ProtocolVcContext;
    
            //
            // Link this in the open_block
            //
            ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                        &VcPtr->ClientLink,
                                        &Open->SpinLock);
        }
    }  while (FALSE);

    if (NDIS_STATUS_SUCCESS == Status)
    {
        LARGE_INTEGER   Increment = {0, 1};

        //
        //  Assign this VC an ID and update the miniports count.
        //
        VcPtr->VcIndex = ExInterlockedAddLargeInteger(&Miniport->VcIndex, Increment, &ndisGlobalLock);
    }

    *NdisVcHandle = VcPtr;
    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("<=NdisCoCreateVc: VcPtr %x, Status %x\n", VcPtr, Status));

    return Status;
}


NDIS_STATUS
NdisCoDeleteVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Synchronous call from either the call-manager or the client to delete a VC. Only inactive
    VCs can be deleted. Active Vcs or partially active Vcs cannot be.

Arguments:

    NdisVcHandle    The Vc to delete

Return Value:

    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_NOT_ACCEPTED    If Vc is active
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCoDeleteVc VcPtr %x/%x, Ref %d VcBlock %x, Flags %x\n",
             VcPtr, VcPtr->CallFlags, VcPtr->References, VcPtr->VcBlock, *VcPtr->pVcFlags));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if (*VcPtr->pVcFlags & (VC_ACTIVE | VC_ACTIVATE_PENDING))
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & (VC_DEACTIVATE_PENDING))
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        //
        // Take this VcPtr out of the VC's list
        //
        // If the VC isn't already closing mark it as closing.
        //
        // We call the miniport's delete handler if the VC block's Proxy ptr points
        // to this VC ptr. (This indicates that the VC block is owned/created by the
        // CM/Proxy, not the CL).
        //
        // NOTE: We don't delete the VC until all these pointers
        // have gone since the Proxy may wish to redirect the VC to another protocol.
        // However, in general the Proxy would follow a call to DeleteVc for the Client ptr
        // with one for the Proxy.
        // (Note the MP context refers to the VC, not the VcPtr).
        //
        VcPtr->CallFlags |= VC_PTR_BLOCK_CLOSING;

        //1 in what case the first can be true and the second false?
        if (VcPtr->OwnsVcBlock &&
            (VcPtr->WCoDeleteVcHandler != NULL))
        {
            *VcPtr->pVcFlags |= VC_DELETE_PENDING;
        }

        //
        //  If this VC is responding to WMI then get rid of it.
        //
        if (NULL != VcPtr->VcInstanceName.Buffer)
        {
            //
            //  Notify the removal of this VC.
            //
            PWNODE_SINGLE_INSTANCE  wnode;
            NTSTATUS                NtStatus;

            ndisSetupWmiNode(VcPtr->Miniport,
                             &VcPtr->VcInstanceName,
                             0,
                             (PVOID)&GUID_NDIS_NOTIFY_VC_REMOVAL,
                             &wnode);

            if (wnode != NULL)
            {
        
                //
                //  Indicate the event to WMI. WMI will take care of freeing
                //  the WMI struct back to pool.
                //
                NtStatus = IoWMIWriteEvent(wnode);
                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("IoWMIWriteEvent failed %lx\n", NtStatus));
            
                    FREE_POOL(wnode);
                }
            }

            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->Miniport->VcCountLock);

            //
            //  Remove the VC from the list of WMI enabled VCs
            //
            RemoveEntryList(&VcPtr->WmiLink);
    
            //
            //  Decrement the number of VC's that have names assigned to them.
            //
            VcPtr->Miniport->VcCount--;

            //
            //  Free the VC's name buffer.
            //
            FREE_POOL(VcPtr->VcInstanceName.Buffer);

            VcPtr->VcInstanceName.Buffer = NULL;
            VcPtr->VcInstanceName.Length = VcPtr->VcInstanceName.MaximumLength = 0;
    
            RELEASE_SPIN_LOCK_DPC(&VcPtr->Miniport->VcCountLock);
        }

        //
        // Next the non-creator's delete handler, if any
        //
        if (VcPtr->CoDeleteVcHandler != NULL)
        {
            Status = (*VcPtr->CoDeleteVcHandler)(VcPtr->DeleteVcContext);
            ASSERT(Status == NDIS_STATUS_SUCCESS);
        }

        //
        // Now de-link the VcPtr from the client and the call-manager
        //
        ACQUIRE_SPIN_LOCK_DPC(&VcPtr->ClientOpen->SpinLock);
        RemoveEntryList(&VcPtr->ClientLink);
        RELEASE_SPIN_LOCK_DPC(&VcPtr->ClientOpen->SpinLock);

        if (VcPtr->CallMgrOpen != NULL)
        {
            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->CallMgrOpen->SpinLock);
            RemoveEntryList(&VcPtr->CallMgrLink);
            RELEASE_SPIN_LOCK_DPC(&VcPtr->CallMgrOpen->SpinLock);
        }

        Status = NDIS_STATUS_SUCCESS;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(VcPtr);
    }

    return Status;
}


NDIS_STATUS
NdisMCmCreateVc(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             MiniportVcContext,
    OUT PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    This is a call by the miniport (with a resident CM) to create a Vc for an incoming call.

Arguments:
    MiniportAdapterHandle - Miniport's adapter context
    NdisAfHandle        - Pointer to the AF Block.
    MiniportVcContext   - Miniport's context to associate with this vc.
    NdisVcHandle        - Where the handle to this Vc will be returned.

Return Value:
    NDIS_STATUS_SUCCESS if all the components succeed.
    ErrorCode           to signify why the call failed.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_CO_VC_BLOCK       VcBlock;
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    NDIS_STATUS             Status;

    ASSERT(ARGUMENT_PRESENT(NdisAfHandle));
    if (NdisAfHandle == NULL)
    {
        return NDIS_STATUS_FAILURE;
    }
    
    *NdisVcHandle = NULL;

    //
    // Allocate the memory for NDIS_VC_BLOCK
    //
    VcBlock = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_BLOCK), NDIS_TAG_CO);
    if (VcBlock == NULL)
        return NDIS_STATUS_RESOURCES;

    //
    // Initialize the VC block
    //
    NdisZeroMemory(VcBlock, sizeof(NDIS_CO_VC_BLOCK));
    INITIALIZE_SPIN_LOCK(&VcBlock->Lock);

    //
    // Allocate the memory for NDIS_VC_PTR_BLOCK
    //
    VcPtr = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_PTR_BLOCK), NDIS_TAG_CO);
    if (VcPtr == NULL)
    {
        FREE_POOL(VcBlock);
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Initialize the VC Pointer block
    //
    NdisZeroMemory(VcPtr, sizeof(NDIS_CO_VC_PTR_BLOCK));
    INITIALIZE_SPIN_LOCK(&VcPtr->Lock);

    //
    // Cache some miniport handlers
    //
    VcPtr->Miniport = Miniport;
    VcPtr->WCoSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CoSendPacketsHandler;
    VcPtr->WCoDeleteVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeleteVcHandler;
    VcPtr->WCoActivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoActivateVcHandler;
    VcPtr->WCoDeactivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeactivateVcHandler;

    VcBlock->Miniport = Miniport;
    VcBlock->MiniportContext = MiniportVcContext;

    VcPtr->MiniportContext = MiniportVcContext;

    //
    // Set up the VcBlock in the new VcPtr
    //
    VcPtr->VcBlock = VcBlock;

    // VcPtrs to preempt potential for unsynched state when Protocols, Miniports and
    // Miniport-exported Call Managers refer to VCs/VcPtrs as appropriate...similar
    // for References, which is accessed from Vc directly in IndicateReceivePacket.
    //
    VcPtr->pVcFlags = &VcBlock->Flags;

    //
    // We have only one reference for vc on creation.
    //
    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    VcPtr->AfBlock = pAf;
    VcPtr->References = 1;

    VcPtr->ClientOpen = pAf->ClientOpen;
    VcPtr->CallMgrOpen = NULL;
    VcBlock->ClientOpen = pAf->ClientOpen;

    VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
    VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
    VcPtr->ClModifyCallQoSCompleteHandler = pAf->ClientEntries.ClModifyCallQoSCompleteHandler;
    VcPtr->ClIncomingCallQoSChangeHandler = pAf->ClientEntries.ClIncomingCallQoSChangeHandler;
    VcPtr->ClCallConnectedHandler = pAf->ClientEntries.ClCallConnectedHandler;

    VcPtr->CmActivateVcCompleteHandler = pAf->CallMgrEntries->CmActivateVcCompleteHandler;
    VcPtr->CmDeactivateVcCompleteHandler = pAf->CallMgrEntries->CmDeactivateVcCompleteHandler;
    VcPtr->CmModifyCallQoSHandler = pAf->CallMgrEntries->CmModifyCallQoSHandler;

    VcPtr->CallMgrContext = MiniportVcContext;
    VcBlock->CallMgrContext = MiniportVcContext;

    //
    // Call-up to the client now to get its context
    //
    Status = (*pAf->ClientOpen->CoCreateVcHandler)(pAf->ClientContext,
                                                   VcPtr,
                                                   &VcPtr->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Setup the client context in the VC block. This may be overwritten by the
        // new client context in a subsequent call to CoCreateVc by the proxy.
        // Link this in the open_block
        //
        VcBlock->ClientContext = VcPtr->ClientContext;
        VcPtr->DeleteVcContext = VcPtr->ClientContext;
        VcPtr->CoDeleteVcHandler = pAf->ClientOpen->CoDeleteVcHandler;
        ExInterlockedInsertHeadList(&pAf->ClientOpen->InactiveVcHead,
                                    &VcPtr->ClientLink,
                                    &pAf->ClientOpen->SpinLock);
        VcBlock->pClientVcPtr = VcPtr;
    }
    else
    {
        FREE_POOL(VcBlock);
        FREE_POOL(VcPtr);
        VcPtr = NULL;
    }

    *NdisVcHandle = VcPtr;
    return Status;
}


NDIS_STATUS
NdisMCmDeleteVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    This is a called by the miniport (with a resident CM) to delete a Vc created by it. Identical to
    NdisMCoDeleteVc but a seperate api for completeness.

Arguments:

    NdisVcHandle    The Vc to delete

Return Value:

    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_NOT_ACCEPTED    If Vc is active
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;

    if (VcBlock->pProxyVcPtr != NULL)
    {
        return (NdisCoDeleteVc ((PNDIS_HANDLE)VcBlock->pProxyVcPtr));
    }
    else
    {
        ASSERT(VcBlock->pClientVcPtr != NULL);
        return (NdisCoDeleteVc((PNDIS_HANDLE)VcBlock->pClientVcPtr));
    }
}


NDIS_STATUS
NdisCmActivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
/*++

Routine Description:

    Called by the call-manager to set the Vc parameters on the Vc. The wrapper
    saved the media id (e.g. Vpi/Vci for atm) in the Vc so that a p-mode protocol can
    get this info as well on receives.

Arguments:

    NdisVcHandle    The Vc to set parameters on.
    MediaParameters The parameters to set.

Return Value:

    NDIS_STATUS_PENDING         If the miniport pends the call.
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = (PNDIS_CO_VC_BLOCK)VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmActivateVC: VcPtr is 0x%x; VC is 0x%x; MiniportContext is 0x%x\n", VcPtr,
            VcPtr->VcBlock, VcPtr->MiniportContext));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    //
    // Make sure the Vc does not have an activation/de-activation pending
    // Not that it is ok for the Vc to be already active - then it is a re-activation.
    //
    if (*VcPtr->pVcFlags & VC_ACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & VC_DEACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        *VcPtr->pVcFlags |= VC_ACTIVATE_PENDING;

        //
        // Save the media id for the Vc
        //
        Status = NDIS_STATUS_SUCCESS;
        ASSERT(CallParameters->MediaParameters->MediaSpecific.Length >= sizeof(ULONGLONG));
        VcBlock->VcId = *(UNALIGNED ULONGLONG *)(&CallParameters->MediaParameters->MediaSpecific.Parameters);
    }

    //
    // Set up CM Context and ActivateComplete handler in VC before
    // calling miniports activate func
    //
    VcBlock->CmActivateVcCompleteHandler = VcPtr->CmActivateVcCompleteHandler;
    VcBlock->CallMgrContext = VcPtr->CallMgrContext;

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Now call down to the miniport to activate it. MiniportContext contains
        // Miniport's handle for underlying VC (not VcPtr).
        //
        Status = (*VcPtr->WCoActivateVcHandler)(VcPtr->MiniportContext, CallParameters);
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoActivateVcComplete(Status, VcPtr, CallParameters);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NDIS_STATUS
NdisMCmActivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:
    Called by the miniport resident call-manager to set the Vc parameters on the Vc.

Arguments:

    NdisVcHandle    The Vc to set parameters on.
    MediaParameters The parameters to set.

Return Value:

    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    VcBlock->Flags |= VC_ACTIVE;
    VcBlock->VcId = *(UNALIGNED ULONGLONG *)(&CallParameters->MediaParameters->MediaSpecific.Parameters);

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    return Status;
}


VOID
NdisMCoActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Called by the mini-port to complete a pending activation call.
    Also called by CmActivateVc when the miniport doesn't pend the CreateVc call.
    Note that in the second case, we've copied the flags/context/CM function into the
    VC from the VC Ptr.

Arguments:

    Status          Status of activation.
    NdisVcHandle    The Vc in question.

Return Value:

    NONE
    The call-manager's completion routine is called.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    ASSERT(VcBlock->Flags & VC_ACTIVATE_PENDING);

    VcBlock->Flags &= ~VC_ACTIVATE_PENDING;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcBlock->Flags |= VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    //
    // Complete the call to the call-manager
    //
    (*VcBlock->CmActivateVcCompleteHandler)(Status, VcBlock->CallMgrContext, CallParameters);
}


NDIS_STATUS
NdisCmDeactivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the call-manager to de-activate a Vc.

Arguments:

    NdisVcHandle    The Vc to de-activate the Vc.

Return Value:

    NDIS_STATUS_PENDING         If the miniport pends the call.
    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if ((*VcPtr->pVcFlags & (VC_ACTIVE | VC_ACTIVATE_PENDING)) == 0)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & VC_DEACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        *VcPtr->pVcFlags |= VC_DEACTIVATE_PENDING;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    //
    // Set up flags, CM Context and DeactivateComplete handler in VC before
    // calling mimiports deactivate func
    //
    VcBlock->CmDeactivateVcCompleteHandler = VcPtr->CmDeactivateVcCompleteHandler;
    VcBlock->CallMgrContext = VcPtr->CallMgrContext;

    //
    // Now call down to the miniport to de-activate it
    //
    Status = (*VcPtr->WCoDeactivateVcHandler)(VcPtr->MiniportContext);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoDeactivateVcComplete(Status, VcPtr);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NDIS_STATUS
NdisMCmDeactivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the miniport resident call-manager to de-activate the Vc. This is a
    synchronous call.

Arguments:

    NdisVcHandle    The Vc to set parameters on.

Return Value:

    NDIS_STATUS_NOT_ACCEPTED    If Vc is not activated
    NDIS_STATUS_SUCCESS         Otherwise

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    if ((VcBlock->Flags & VC_ACTIVE) == 0)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else
    {
        Status = NDIS_STATUS_SUCCESS;
        VcBlock->Flags &= ~VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    return Status;
}


VOID
NdisMCoDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the mini-port to complete a pending de-activation of a Vc.

Arguments:

    NdisVcHandle    The Vc in question.

Return Value:

    NONE
    The call-manager's completion routine is called.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    ASSERT(VcBlock->Flags & VC_DEACTIVATE_PENDING);

    VcBlock->Flags &= ~VC_DEACTIVATE_PENDING;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcBlock->Flags &= ~VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    //
    // Complete the call to the call-manager
    //
    (*VcBlock->CmDeactivateVcCompleteHandler)(Status, VcBlock->CallMgrContext);
}


NDIS_STATUS
NdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_CO_PARTY_BLOCK        pParty = NULL;
    PVOID                       CallMgrPartyContext = NULL;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    do
    {
        pAf = VcPtr->AfBlock;
        ASSERT(pAf != NULL);
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Ref the VC for the life of the active vc.
        // This is Deref'd is in MakeCallComplete If the call fails and CloseCallComplete
        // when it succeeds
        //
        if (!ndisReferenceVcPtr(VcPtr))
        {
            ndisDereferenceAf(pAf);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            *NdisPartyHandle = NULL;
            pParty = (PNDIS_CO_PARTY_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_CO_PARTY_BLOCK),
                                                           NDIS_TAG_CO);
            if (pParty == NULL)
            {
                ndisDereferenceAf(pAf);
                ndisDereferenceVcPtr(VcPtr);
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            
            NdisZeroMemory(pParty, sizeof(NDIS_CO_PARTY_BLOCK));
            
            pParty->VcPtr = VcPtr;
            pParty->ClientContext = ProtocolPartyContext;
            pParty->ClIncomingDropPartyHandler = pAf->ClientEntries.ClIncomingDropPartyHandler;
            pParty->ClDropPartyCompleteHandler = pAf->ClientEntries.ClDropPartyCompleteHandler;
        }

        ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

        ASSERT((VcPtr->CallFlags & (VC_CALL_ACTIVE  |
                                    VC_CALL_PENDING |
                                    VC_CALL_ABORTED |
                                    VC_CALL_CLOSE_PENDING)) == 0);
        VcPtr->CallFlags |= VC_CALL_PENDING;

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        //
        // Pass the request off to the call manager
        //
        Status = (*pAf->CallMgrEntries->CmMakeCallHandler)(VcPtr->CallMgrContext,
                                                           CallParameters,
                                                           pParty,
                                                           &CallMgrPartyContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmMakeCallComplete(Status,
                                   VcPtr,
                                   pParty,
                                   CallMgrPartyContext,
                                   CallParameters);
            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}


VOID
NdisCmMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    KIRQL                   OldIrql;
    BOOLEAN                 fAborted = FALSE;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmMakeCallComplete(%x): VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                Status, VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));

    pAf = VcPtr->AfBlock;

    ASSERT(Status != NDIS_STATUS_PENDING);

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags &= ~VC_CALL_PENDING;
    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcPtr->CallFlags |= VC_CALL_ACTIVE;
    }
    else
    {
        fAborted = ((VcPtr->CallFlags & VC_CALL_ABORTED) != 0);
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Call completed successfully. Complete it to the client.
        //
        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            pParty->CallMgrContext = CallMgrPartyContext;
            ndisReferenceVcPtr(VcPtr);
        }

        ACQUIRE_SPIN_LOCK(&pAf->ClientOpen->SpinLock, &OldIrql);
        RemoveEntryList(&VcPtr->ClientLink);
        InsertHeadList(&pAf->ClientOpen->ActiveVcHead,
                       &VcPtr->ClientLink);
        RELEASE_SPIN_LOCK(&pAf->ClientOpen->SpinLock, OldIrql);
    }
    else
    {
        //
        // Deref the VC and Af (was ref'd in MakeCall) - but only if the call was
        // not aborted. In this case CloseCall will do the right thing.
        //
        if (!fAborted)
        {
            ndisDereferenceVcPtr(VcPtr);
            ndisDereferenceAf(pAf);
            if (pParty)
            {
                FREE_POOL(pParty);
            }
        }

        DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCmMakeCallComplete: Failed %lx\n", Status));
    }

    (*pAf->ClientEntries.ClMakeCallCompleteHandler)(Status,
                                                    VcPtr->ClientContext,
                                                    pParty,
                                                    CallParameters);
}


NDIS_STATUS
NdisCmDispatchIncomingCall(
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
/*++

Routine Description:

    Call from the call-manager to dispatch an incoming vc to the client who registered the Sap.
    The client is identified by the NdisSapHandle.

Arguments:

    NdisBindingHandle   - Identifies the miniport on which the Vc is created
    NdisSapHandle       - Identifies the client
    CallParameters      - Self explanatory
    NdisVcHandle        - Pointer to the NDIS_CO_VC_BLOCK created via NdisCmCreateVc

Return Value:

    Return value from the client or an processing error.

--*/
{
    PNDIS_CO_SAP_BLOCK      Sap;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_STATUS             Status;

    Sap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    pAf = Sap->AfBlock;

    ASSERT(pAf == VcPtr->AfBlock);

    //
    // Make sure the SAP's not closing
    //
    if (!ndisReferenceSap(Sap))
    {
        return(NDIS_STATUS_FAILURE);
    }

    //
    // Make sure the AF is not closing
    //
    if (!ndisReferenceAf(pAf))
    {
        ndisDereferenceSap(Sap);
        return(NDIS_STATUS_FAILURE);
    }

    //
    // Notify the client of this call
    //
    Status = (*pAf->ClientEntries.ClIncomingCallHandler)(Sap->ClientContext,
                                                         VcPtr->ClientContext,
                                                         CallParameters);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisClIncomingCallComplete(Status, VcPtr, CallParameters);
        Status = NDIS_STATUS_PENDING;
    }

    ndisDereferenceSap(Sap);

    return Status;
}


VOID
NdisClIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    KIRQL                   OldIrql;

    ASSERT(Status != NDIS_STATUS_PENDING);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ACQUIRE_SPIN_LOCK(&VcPtr->ClientOpen->SpinLock, &OldIrql);
        //
        // Reference the VcPtr. This is dereferenced when NdisClCloseCall is called.
        //
        VcPtr->References ++;

        RemoveEntryList(&VcPtr->ClientLink);
        InsertHeadList(&VcPtr->ClientOpen->ActiveVcHead,
                       &VcPtr->ClientLink);

        RELEASE_SPIN_LOCK(&VcPtr->ClientOpen->SpinLock, OldIrql);

        ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);
    
        ASSERT((VcPtr->CallFlags & (VC_CALL_ABORTED | VC_CALL_PENDING)) == 0);
    
        VcPtr->CallFlags |= VC_CALL_ACTIVE;
    
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    //
    // Call the call-manager handler to notify that client is done with this.
    //
    (*VcPtr->AfBlock->CallMgrEntries->CmIncomingCallCompleteHandler)(
                                            Status,
                                            VcPtr->CallMgrContext,
                                            CallParameters);
}


VOID
NdisCmDispatchCallConnected(
    IN  NDIS_HANDLE             NdisVcHandle
    )
/*++

Routine Description:

    Called by the call-manager to complete the final hand-shake on an incoming call.

Arguments:

    NdisVcHandle    - Pointer to the vc block

Return Value:

    None.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    (*VcPtr->ClCallConnectedHandler)(VcPtr->ClientContext);
}


NDIS_STATUS
NdisClModifyCallQoS(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Initiated by the client to modify the QoS associated with the call.

Arguments:

    NdisVcHandle    - Pointer to the vc block
    CallParameters  - New call QoS

Return Value:


--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS             Status;

    //
    // Ask the call-manager to take care of this
    //
    Status = (*VcPtr->CmModifyCallQoSHandler)(VcPtr->CallMgrContext,
                                                  CallParameters);
    return Status;
}

VOID
NdisCmModifyCallQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Simply notify the client
    //
    (*VcPtr->ClModifyCallQoSCompleteHandler)(Status,
                                          VcPtr->ClientContext,
                                          CallParameters);
}


VOID
NdisCmDispatchIncomingCallQoSChange(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Called by the call-manager to indicate a remote requested change in the call-qos. This is
    simply an indication. A client must respond by either accepting it (do nothing) or reject
    it (by either modifying the call qos or by tearing down the call).

Arguments:

    NdisVcHandle    - Pointer to the vc block
    CallParameters  - New call qos

Return Value:

    None.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Simply notify the client
    //
    (*VcPtr->ClIncomingCallQoSChangeHandler)(VcPtr->ClientContext,
                                          CallParameters);
}


NDIS_STATUS
NdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PVOID                   Buffer          OPTIONAL,
    IN  UINT                    Size            OPTIONAL
    )
/*++

Routine Description:

    Called by the client to close down a connection established via either NdisClMakeCall
    or accepting an incoming call via NdisClIncomingCallComplete. The optional buffer can
    be specified by the client to send a disconnect message. Upto the call-manager to do
    something reasonable with it.

Arguments:

    NdisVcHandle    - Pointer to the vc block
    Buffer          - Optional disconnect message
    Size            - Size of the disconnect message

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisClCloseCall: VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));
    //
    // Ref the VC. (Gets DeRef'd in CloseCallComplete)
    //
    if (!ndisReferenceVcPtr(VcPtr))
    {
        return (NDIS_STATUS_FAILURE);
    }

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags |= VC_CALL_CLOSE_PENDING;
    if (VcPtr->CallFlags & VC_CALL_PENDING)
        VcPtr->CallFlags |= VC_CALL_ABORTED;

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    //
    // Simply notify the call-manager
    //
    Status = (*VcPtr->AfBlock->CallMgrEntries->CmCloseCallHandler)(VcPtr->CallMgrContext,
                                                                (pParty != NULL) ?
                                                                    pParty->CallMgrContext :
                                                                    NULL,
                                                                Buffer,
                                                                Size);
    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmCloseCallComplete(Status, VcPtr, pParty);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


VOID
NdisCmCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL
    )
/*++

Routine Description:



Arguments:

    NdisVcHandle    - Pointer to the vc block

Return Value:

    Nothing. Client handler called

--*/

{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_HANDLE             ClientVcContext;
    NDIS_HANDLE             ClientPartyContext;
    CL_CLOSE_CALL_COMPLETE_HANDLER  CloseCallCompleteHandler;
    KIRQL                   OldIrql;
    ULONG                   VcFlags;
    //1  where do we put back the VC on InactiveVc list??

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmCloseCallComplete(%x): VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                Status, VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags &= ~(VC_CALL_CLOSE_PENDING | VC_CALL_ABORTED);

    ClientVcContext = VcPtr->ClientContext;
    ClientPartyContext = (pParty != NULL)? pParty->ClientContext: NULL;
    CloseCallCompleteHandler = VcPtr->AfBlock->ClientEntries.ClCloseCallCompleteHandler;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcFlags = VcPtr->CallFlags;

        VcPtr->CallFlags &= ~(VC_CALL_ACTIVE);

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        if (pParty != NULL)
        {
            ASSERT(VcPtr == pParty->VcPtr);
            ndisDereferenceVcPtr(pParty->VcPtr);
            FREE_POOL(pParty);
        }

        //
        // Deref the Vc and Af for refs taken in MakeCall/IncomingCallComplete
        //
        ndisDereferenceAf(VcPtr->AfBlock);
        if (VcFlags & VC_CALL_ACTIVE)
        {
            ndisDereferenceVcPtr(VcPtr);
        }
    }
    else
    {
        //
        // Leave the VC and VC Ptr in their original states (before this
        // failed CloseCall happened)
        //
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    //
    // Deref the VC (Refs were taken in CloseCall)
    //
    ndisDereferenceVcPtr(VcPtr);

    //
    // Now inform the client of CloseCall completion.
    //
    (*CloseCallCompleteHandler)(Status,
                                ClientVcContext,
                                ClientPartyContext);
}


VOID
NdisCmDispatchIncomingCloseCall(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PVOID                   Buffer,
    IN  UINT                    Size
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Notify the client
    //
    (*VcPtr->AfBlock->ClientEntries.ClIncomingCloseCallHandler)(
                                    CloseStatus,
                                    VcPtr->ClientContext,
                                    Buffer,
                                    Size);
}


NDIS_STATUS
NdisClAddParty(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    OUT PNDIS_HANDLE            NdisPartyHandle
    )
/*++

Routine Description:

    Call from the client to the call-manager to add a party to a point-to-multi-point call.

Arguments:

    NdisVcHandle         - The handle client obtained via NdisClMakeCall()
    ProtocolPartyContext - Protocol's context for this leaf
    Flags                - Call flags
    CallParameters       - Call parameters
    NdisPartyHandle      - Place holder for the handle to identify the leaf

Return Value:

    NDIS_STATUS_PENDING The call has pended and will complete via CoAddPartyCompleteHandler.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty;
    NDIS_STATUS             Status;

    do
    {
        *NdisPartyHandle = NULL;
        if (!ndisReferenceVcPtr(VcPtr))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pParty = ALLOC_FROM_POOL(sizeof(NDIS_CO_PARTY_BLOCK), NDIS_TAG_CO);
        
        if (pParty == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        NdisZeroMemory(pParty, sizeof(NDIS_CO_PARTY_BLOCK));

        pParty->ClientContext = ProtocolPartyContext;
        pParty->VcPtr = VcPtr;
        pParty->ClIncomingDropPartyHandler = VcPtr->AfBlock->ClientEntries.ClIncomingDropPartyHandler;
        pParty->ClDropPartyCompleteHandler = VcPtr->AfBlock->ClientEntries.ClDropPartyCompleteHandler;

        //
        // Simply call the call-manager to do its stuff.
        //
        Status = (*VcPtr->AfBlock->CallMgrEntries->CmAddPartyHandler)(
                                            VcPtr->CallMgrContext,
                                            CallParameters,
                                            pParty,
                                            &pParty->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmAddPartyComplete(Status,
                                   pParty,
                                   pParty->CallMgrContext,
                                   CallParameters);
            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}


VOID
NdisCmAddPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pParty->CallMgrContext = CallMgrPartyContext;
    }

    //
    // Complete the call to the client
    //
    (*pParty->VcPtr->AfBlock->ClientEntries.ClAddPartyCompleteHandler)(
                                    Status,
                                    pParty->ClientContext,
                                    pParty,
                                    CallParameters);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(pParty->VcPtr);
        FREE_POOL(pParty);
    }
}


NDIS_STATUS
NdisClDropParty(
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer          OPTIONAL,
    IN  UINT                    Size            OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_STATUS             Status;

    //
    // Pass it along to the call-manager to handle this
    //
    Status = (*pParty->VcPtr->AfBlock->CallMgrEntries->CmDropPartyHandler)(
                                        pParty->CallMgrContext,
                                        Buffer,
                                        Size);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmDropPartyComplete(Status, pParty);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NTSTATUS
ndisUnicodeStringToPointer(
    IN  PUNICODE_STRING         String,
    OUT PVOID *                 Value
    )
/*++

Routine Description:
    Converts an address represented as a unicode string into a pointer.
    (stolen from RtlUnicodeStringToInteger() in ntos\rtl\cnvint.c)
    
Arguments:
    String  -   The Unicode String holding the address
    Value   -   Address of the pointer in which to store the address.
    
Return Value:
    STATUS_SUCCESS - for successful conversion
    STATUS_INVALID_ARG - if the base supplied is invalid
    Other exception code - if another exception occurs

--*/
{
    PCWSTR  s;
    WCHAR   c, Sign = UNICODE_NULL;
    ULONG   nChars, Digit, Shift;
    ULONG   Base = 16;

#if defined(_WIN64)
    ULONG_PTR Result; 
#else
    ULONG Result;
#endif  

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );

    while (nChars-- && (Sign = *s++) <= ' ')
    {
        if (!nChars)
        {
            Sign = UNICODE_NULL;
            break;
        }
    }

    c = Sign;
    if ((c == L'-') || (c == L'+'))
    {
        if (nChars)
        {
            nChars--;
            c = *s++;
        }
        else
        {
            c = UNICODE_NULL;
        }
    }

    //
    // base is always 16
    //
    Shift = 4;

    Result = 0;
    while (c != UNICODE_NULL)
    {
        if (c >= L'0' && c <= L'9')
        {
            Digit = c - L'0';
        }
        else if (c >= L'A' && c <= L'F')
        {
            Digit = c - L'A' + 10;
        }
        else if (c >= L'a' && c <= L'f')
        {
            Digit = c - L'a' + 10;
        }
        else
        {
            break;
        }

        if (Digit >= Base)
        {
            break;
        }

        if (Shift == 0)
        {
            Result = (Base * Result) + Digit;
        }
        else
        {
            Result = (Result << Shift) | Digit;
        }

        if (!nChars)
        {
            break;
        }
        nChars--;
        c = *s++;
    }

    if (Sign == L'-')
    {
#if defined(_WIN64)
    Result = (ULONG_PTR)(-(LONGLONG)Result);
#else   
    Result = (ULONG)(-(LONG)Result);
#endif
    }

    try
    {
        *Value = (PVOID)Result;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return (GetExceptionCode());
    }

    return( STATUS_SUCCESS );
}


NDIS_STATUS
NdisClGetProtocolVcContextFromTapiCallId(
    IN  UNICODE_STRING          TapiCallId,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
/*++

Routine Description:
    Retrieves the protocol VC context for a VC identified by a TAPI Call ID string
    (this string is the UNICODE representation of the identifier returned by
     NdisCoGetTapiCallId).
     
Arguments:
    TapiCallId          - A TAPI Call Id String 
    ProtocolVcContext   - Pointer to a NDIS_HANDLE variable in which to store the 
                          Protocol VC Context 

Return Value:
    NDIS_STATUS_FAILURE if the VC context could not be obtained, NDIS_STATUS_SUCCESS
    otherwise.

--*/
{
    NTSTATUS    Status = ndisUnicodeStringToPointer(&TapiCallId,
                                                    (PVOID *)ProtocolVcContext);

    return (NT_SUCCESS(Status) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
}


VOID
NdisCmDropPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Complete the call to the client
    //
    (*pParty->ClDropPartyCompleteHandler)(Status,
                                          pParty->ClientContext);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(pParty->VcPtr);
        FREE_POOL(pParty);
    }
}


VOID
NdisCmDispatchIncomingDropParty(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer,
    IN  UINT                    Size
    )
/*++

Routine Description:

    Called by the call-manager to notify the client that this leaf of the multi-party
    call is terminated. The client cannot use the NdisPartyHandle after completing this
    call - synchronously or by calling NdisClIncomingDropPartyComplete.

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    //
    // Notify the client
    //
    (*pParty->ClIncomingDropPartyHandler)(DropStatus,
                                          pParty->ClientContext,
                                          Buffer,
                                          Size);
}


BOOLEAN
FASTCALL
ndisReferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK   VcPtr
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("ndisReferenceVcPtr: VcPtr %x/%x, Flags %x, Ref %d, VcBlock %x\n",
                    VcPtr, VcPtr->CallFlags, *VcPtr->pVcFlags, VcPtr->References, VcPtr->VcBlock));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if ((VcPtr->CallFlags & VC_PTR_BLOCK_CLOSING) == 0)
    {
        VcPtr->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK   VcPtr
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL               OldIrql;
    BOOLEAN             Done = FALSE;
    BOOLEAN             IsProxyVc = FALSE;
    PNDIS_CO_VC_BLOCK   VcBlock;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("ndisDereferenceVcPtr: VcPtr %x/%x, Flags %x, Ref %d, VcBlock %x\n",
                    VcPtr, VcPtr->CallFlags, *VcPtr->pVcFlags, VcPtr->References, VcPtr->VcBlock));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    //
    // Take this VcPtr out of the VC's list
    //
    VcBlock = VcPtr->VcBlock;

    ASSERT(VcBlock != NULL);

    ASSERT(VcPtr->References > 0);
    VcPtr->References --;

    if (VcPtr->References == 0)
    {
        ASSERT(VcPtr->CallFlags & VC_PTR_BLOCK_CLOSING);

        if (*VcPtr->pVcFlags & VC_DELETE_PENDING)
        {
            NDIS_STATUS Status;

            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                     ("ndisDereferenceVcPtr: Calling minport\n"));

            *VcPtr->pVcFlags &= ~VC_DELETE_PENDING; // don't call DeleteVc > once

            RELEASE_SPIN_LOCK_DPC(&VcPtr->Lock);
            Status = (*VcPtr->WCoDeleteVcHandler)(VcPtr->MiniportContext);
            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->Lock);

            ASSERT(Status == NDIS_STATUS_SUCCESS);
        }

        if (VcPtr == VcBlock->pClientVcPtr)
        {
            IsProxyVc = FALSE;
        }
        else
        {
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                     ("ndisDereferenceVcPtr: VC ptr is Proxy\n"));
            ASSERT(VcPtr == VcBlock->pProxyVcPtr);
            IsProxyVc = TRUE;
        }

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("ndisDereferenceVcPtr: freeing VcPtr %x (VcBlock %x)\n", VcPtr, VcPtr->VcBlock));
        FREE_POOL(VcPtr);

        Done = TRUE;
    }
    else
    {
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    if (Done)
    {
        //
        // Any more VC ptrs q'd off this VC? If not,
        // free the VC too. Note both pointers need to be empty, since
        // a VC with no proxy can only ever be a normal
        // non- (or pre-) proxied VC (so we leave it alone).
        //
        // Note that you can have a VC with no Proxy pointer, and a VC
        // with no non-Proxy pointer. [REVIEWERS: Maybe we should assert that a VC
        // that's been proxied should never be left without a proxy pointer when the
        // non-proxy ptr is not null! (This would be a 'dangling' VC with no owner). This
        // would require a 'proxied' flag in the VC].
        //
        ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

        if (IsProxyVc)
        {
            VcBlock->pProxyVcPtr = NULL;
        }
        else
        {
            VcBlock->pClientVcPtr = NULL;
        }

        if ((VcBlock->pProxyVcPtr == NULL) &&
            (VcBlock->pClientVcPtr == NULL))
        {
            RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                    ("ndisDereferenceVcPtr: refs are 0; VcPtrs are both NULL; freeing VCBlock %x\n", VcBlock));
            FREE_POOL(VcBlock);
        }
        else
        {
            RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);
        }
    }
}


VOID
FASTCALL
ndisMCoFreeResources(
    PNDIS_OPEN_BLOCK            Open
    )
/*++

Routine Description:

    Cleans-up address family list for call-managers etc.

    CALLED WITH MINIPORT LOCK HELD.

Arguments:

    Open    -   Pointer to the Open block for miniports

Return Value:

    None

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_AF_LIST           *pAfList, pTmp;

    Miniport = Open->MiniportHandle;

    for (pAfList = &Miniport->CallMgrAfList;
         (pTmp = *pAfList) != NULL;
         NOTHING)
    {
        if (pTmp->Open == Open)
        {
            *pAfList = pTmp->NextAf;
            FREE_POOL(pTmp);
        }
        else
        {
            pAfList = &pTmp->NextAf;
        }
    }

    ASSERT(IsListEmpty(&Open->ActiveVcHead));
}

NDIS_STATUS
NdisCoAssignInstanceName(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PNDIS_STRING            BaseInstanceName,
    OUT PNDIS_STRING            pVcInstanceName     OPTIONAL
    )
{
    NDIS_STATUS             Status;
    PNDIS_CO_VC_PTR_BLOCK   VcBlock = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = VcBlock->Miniport;
    USHORT                  cbSize;
    PWSTR                   pwBuffer;
    INT                     c;
    UINT                    Value;
    UNICODE_STRING          VcInstance;
    ULONGLONG               VcIndex;
    KIRQL                   OldIrql;

    do
    {
        //
        //  Is there already a name associated with this VC?
        //
        cbSize = VcBlock->VcInstanceName.Length;
        if (NULL == VcBlock->VcInstanceName.Buffer)
        {
            //
            //  The VC instance name will be of the format:
            //      [XXXX:YYYYYYYYYYYYYYYY] Base Name
            //  Where XXXX is the adapter instance number and YY..YY is the zero extended VC index.
            //
            cbSize = VC_INSTANCE_ID_SIZE;

            if (NULL != BaseInstanceName)
            {
                cbSize += BaseInstanceName->Length;
            }

            pwBuffer = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
            if (NULL == pwBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisZeroMemory(pwBuffer, cbSize);

            //
            //  Setup the prolog and the seperator and fill in the adapter instance #
            //  
            pwBuffer[0] =  L'[';
            pwBuffer[VC_ID_INDEX] = VC_IDENTIFIER;

            //
            //  Add the adapter instance number.
            //
            Value = Miniport->InstanceNumber;
            for (c = 4; c > 0; c--)
            {
                pwBuffer[c] = ndisHexLookUp[Value & NIBBLE_MASK];
                Value >>= 4;
            }

            //
            //  Add the VC index.
            //
            VcIndex = VcBlock->VcIndex.QuadPart;

            for (c = 15; c >= 0; c--)
            {
                //
                //  Get the nibble to convert.
                //
                Value = (UINT)(VcIndex & NIBBLE_MASK);

                pwBuffer[5+c] = ndisHexLookUp[Value];

                //
                //  Shift the VcIndex by a nibble.
                //
                VcIndex >>= 4;
            }

            //
            //  Add closing bracket and a space
            //
            pwBuffer[21] = L']';;
            pwBuffer[22] = L' ';;

            //
            //  Initialize a temporary UNICODE_STRING to build the name.
            //
            VcInstance.Buffer = pwBuffer;
            VcInstance.Length = VC_INSTANCE_ID_SIZE;
            VcInstance.MaximumLength = cbSize;

            if (NULL != BaseInstanceName)
            {
                //
                //  Append the base instance name passed into us to the end.
                //
                RtlAppendUnicodeStringToString(&VcInstance, BaseInstanceName);
            }

            ACQUIRE_SPIN_LOCK(&Miniport->VcCountLock, &OldIrql);

            Miniport->VcCount++;
            VcBlock->VcInstanceName = VcInstance;

            //
            //  Add the VC to the list of WMI enabled VCs
            //
            InsertTailList(&Miniport->WmiEnabledVcs, &VcBlock->WmiLink);

            RELEASE_SPIN_LOCK(&Miniport->VcCountLock, OldIrql);

            //
            //  Notify the arrival of this VC.
            //
            {
                PWNODE_SINGLE_INSTANCE  wnode;
                NTSTATUS                NtStatus;

                ndisSetupWmiNode(Miniport,
                                 &VcInstance,
                                 0,
                                 (PVOID)&GUID_NDIS_NOTIFY_VC_ARRIVAL,
                                 &wnode);

                if (wnode != NULL)
                {       
                    //
                    //  Indicate the event to WMI. WMI will take care of freeing
                    //  the WMI struct back to pool.
                    //
                    NtStatus = IoWMIWriteEvent(wnode);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("IoWMIWriteEvent failed %lx\n", NtStatus));
            
                        FREE_POOL(wnode);
                    }
                }
            }
        }

        //
        //  Copy the instance name string into callers NDIS_STRING.
        //
        if (ARGUMENT_PRESENT(pVcInstanceName))
        {
            pVcInstanceName->Buffer = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
            if (NULL == pVcInstanceName->Buffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
    
            NdisMoveMemory(pVcInstanceName->Buffer, VcBlock->VcInstanceName.Buffer, cbSize);
            pVcInstanceName->Length = VcBlock->VcInstanceName.Length;
            pVcInstanceName->MaximumLength = cbSize;
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return(Status);
}

NDIS_STATUS
NdisCoRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

    This api is used for two separate paths.
    1. A symmetric call between the client and the call-manager. This mechanism is a
    two-way mechanism for the call-manager and client to communicate with each other in an
    asynchronous manner.
    2. A request down to the miniport.

Arguments:

    NdisBindingHandle   - Specifies the binding and identifies the caller as call-manager/client
    NdisAfHandle        - Pointer to the AF Block and identifies the target. If absent, the
                          request is targeted to the miniport.
    NdisVcHandle        - Pointer to optional VC PTR block. If present the request relates to the
                          VC
    NdisPartyHandle     - Pointer to the optional Party Block. If present the request relates
                          to the party.
    NdisRequest         - The request itself

Return Value:
    NDIS_STATUS_PENDING if the target pends the call.
    NDIS_STATUS_FAILURE if the binding or af is closing.
    Anything else       return code from the other end.

--*/
{
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_HANDLE             VcContext;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;


    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;

    do
    {
        if (ARGUMENT_PRESENT(NdisAfHandle))
        {
            CO_REQUEST_HANDLER      CoRequestHandler;
            NDIS_HANDLE             AfContext, PartyContext;

            pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

            //
            // Attempt to reference the AF
            //
            if (!ndisReferenceAf(pAf))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            VcContext = NULL;
            PartyContext = NULL;
            NdisZeroMemory(CoReqRsvd, sizeof(NDIS_COREQ_RESERVED));
            INITIALIZE_EVENT(&CoReqRsvd->Event);
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = REQST_SIGNAL_EVENT;

            //
            // Figure out who we are and call the peer
            //
            if (pAf->ClientOpen == Open)
            {
                //
                // This is the client, so call the call-manager's CoRequestHandler
                //
                CoRequestHandler = pAf->CallMgrEntries->CmRequestHandler;

                AfContext = pAf->CallMgrContext;
                CoReqRsvd->AfContext = pAf->ClientContext;
                CoReqRsvd->CoRequestCompleteHandler = pAf->ClientEntries.ClRequestCompleteHandler;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    CoReqRsvd->VcContext = VcPtr->ClientContext;
                    VcContext = VcPtr->CallMgrContext;
                }
                if (ARGUMENT_PRESENT(NdisPartyHandle))
                {
                    CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
                    PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
                }
            }
            else
            {
                ASSERT(pAf->CallMgrOpen == Open);
                //
                // This is the call-manager, so call the client's CoRequestHandler
                //
                CoRequestHandler = pAf->ClientEntries.ClRequestHandler;
                AfContext = pAf->ClientContext;
                CoReqRsvd->AfContext = pAf->CallMgrContext;
                CoReqRsvd->CoRequestCompleteHandler = pAf->CallMgrEntries->CmRequestCompleteHandler;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    CoReqRsvd->VcContext = VcPtr->CallMgrContext;
                    VcContext = VcPtr->ClientContext;
                }
                if (ARGUMENT_PRESENT(NdisPartyHandle))
                {
                    CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
                    PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
                }
            }

            if (CoRequestHandler == NULL)
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }
            

            if (MINIPORT_PNP_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DEVICE_FAILED))
            {
                Status = (NdisRequest->RequestType == NdisRequestSetInformation) ? 
                                            NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;  

            }
            else
            {
                //
                // Now call the handler
                //
                Status = (*CoRequestHandler)(AfContext, VcContext, PartyContext, NdisRequest);
            }

            
            if (Status != NDIS_STATUS_PENDING)
            {
                NdisCoRequestComplete(Status,
                                      NdisAfHandle,
                                      NdisVcHandle,
                                      NdisPartyHandle,
                                      NdisRequest);

                Status = NDIS_STATUS_PENDING;
            }
        }
        else
        {
            PNDIS_MINIPORT_BLOCK    Miniport;

            Miniport = Open->MiniportHandle;

            //
            // Start off by referencing the open.
            //
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

            if (Open->Flags & fMINIPORT_OPEN_CLOSING)
            {
                Status = NDIS_STATUS_CLOSING;
            }
            else if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_RESET_REQUESTED)))
            {
                Status = NDIS_STATUS_RESET_IN_PROGRESS;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
                M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
            }

            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Open = Open;
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = 0;
                CoReqRsvd->CoRequestCompleteHandler = Open->CoRequestCompleteHandler;
                CoReqRsvd->VcContext = NULL;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    if (VcPtr->ClientOpen == Open)
                    {
                        CoReqRsvd->VcContext = VcPtr->ClientContext;
                    }
                    else
                    {
                        CoReqRsvd->VcContext = VcPtr->CallMgrContext;
                    }
                }

                if (MINIPORT_PNP_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DEVICE_FAILED))
                {
                    Status = (NdisRequest->RequestType == NdisRequestSetInformation) ? 
                                                NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;  

                }
                else
                {
                    //
                    // Call the miniport's CoRequest Handler
                    //
                    Status = (*Open->MiniportCoRequestHandler)(Open->MiniportAdapterContext,
                                                              (NdisVcHandle != NULL) ?
                                                                    VcPtr->MiniportContext : NULL,
                                                              NdisRequest);
                }
                
                
                if (Status != NDIS_STATUS_PENDING)
                {
                    NdisMCoRequestComplete(Status,
                                           Open->MiniportHandle,
                                           NdisRequest);

                    Status = NDIS_STATUS_PENDING;
                }
            }

        }
    } while (FALSE);

    return Status;
}


NDIS_STATUS
NdisMCmRequest(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:

    This api is a symmetric call between the client and an integrated call-manager.
    This mechanism is a two-way mechanism for the call-manager and client to communicate
    with each other in an asynchronous manner.

Arguments:

    NdisAfHandle        - Pointer to the AF Block and identifies the target. If absent, the
                          request is targeted to the miniport.
    NdisVcHandle        - Pointer to optional VC PTR block. If present the request relates to the
                          VC
    NdisPartyHandle     - Pointer to the optional Party Block. If present the request relates
                          to the party.
    NdisRequest         - The request itself

Return Value:
    NDIS_STATUS_PENDING if the target pends the call.
    NDIS_STATUS_FAILURE if the binding or af is closing.
    Anything else       return code from the other end.

--*/
{
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_HANDLE             VcContext, PartyContext;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    NDIS_STATUS             Status;

    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

    do
    {
        //
        // Attempt to reference the AF
        //
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        VcContext = NULL;
        PartyContext = NULL;
        NdisZeroMemory(CoReqRsvd, sizeof(NDIS_COREQ_RESERVED));
        INITIALIZE_EVENT(&CoReqRsvd->Event);
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = REQST_SIGNAL_EVENT;

        CoReqRsvd->AfContext = pAf->CallMgrContext;
        CoReqRsvd->CoRequestCompleteHandler = pAf->CallMgrEntries->CmRequestCompleteHandler;
        if (ARGUMENT_PRESENT(NdisVcHandle))
        {
            CoReqRsvd->VcContext = pAf->CallMgrContext;
            VcContext = ((PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle)->ClientContext;
        }
        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
            PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
        }

        //
        // Now call the handler
        //
        Status = (*pAf->ClientEntries.ClRequestHandler)(pAf->ClientContext,
                                                        VcContext,
                                                        PartyContext,
                                                        NdisRequest);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCoRequestComplete(Status,
                                  NdisAfHandle,
                                  NdisVcHandle,
                                  NdisPartyHandle,
                                  NdisRequest);

            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}

VOID
NdisCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_COREQ_RESERVED    ReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);

    UNREFERENCED_PARAMETER(NdisVcHandle);
    UNREFERENCED_PARAMETER(NdisPartyHandle);
    
    //
    // Simply call the request completion handler and deref the Af block
    //
    (*ReqRsvd->CoRequestCompleteHandler)(Status,
                                         ReqRsvd->AfContext,
                                         ReqRsvd->VcContext,
                                         ReqRsvd->PartyContext,
                                         NdisRequest);
    ndisDereferenceAf((PNDIS_CO_AF_BLOCK)NdisAfHandle);
}

NDIS_STATUS
NdisCoGetTapiCallId(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  OUT PVAR_STRING         TapiCallId
    )
/*++

Routine Description:
    Returns a string that can be used by a TAPI application to identify a particular VC.
    
Arguments:

    NdisVcHandle    - The NDIS handle to the VC to identify
    TapiCallId      - Pointer to a VAR_STRING structure in which to return
                      the identifier

Return Value:
    NDIS_STATUS_BUFFER_TOO_SHORT if the VAR_STRING structure's ulTotalSize field indicates
        that it does not contain enough space to hold the VC's identifier. The ulNeededSize
        field will be set to the size needed.
    
    NDIS_STATUS_INVALID_DATA if the NdisVcHandle passed in is not valid.
    
    NDIS_STATUS_SUCCESS otherwise. 
     
--*/
{
    NDIS_HANDLE ClientContext;

    TapiCallId->ulUsedSize = 0;

    if (NdisVcHandle)
        ClientContext = ((PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle)->ClientContext;
    else
        return NDIS_STATUS_INVALID_DATA;


    //
    // Determine the size we will need.
    //

    TapiCallId->ulNeededSize = sizeof(VAR_STRING) + sizeof(ClientContext);

    //
    // Check that there is enough space to copy the call ID. If not,
    // we bail.
    //

    if (TapiCallId->ulTotalSize < TapiCallId->ulNeededSize) 
        return NDIS_STATUS_BUFFER_TOO_SHORT;

    //
    // Set fields, do the copy.
    // 

    TapiCallId->ulStringFormat = STRINGFORMAT_BINARY;
    TapiCallId->ulStringSize = sizeof(ClientContext);
    TapiCallId->ulStringOffset = sizeof(VAR_STRING); 

    NdisMoveMemory(((PUCHAR)TapiCallId) + TapiCallId->ulStringOffset,
                   &ClientContext,
                   sizeof(ClientContext));

    TapiCallId->ulUsedSize = sizeof(VAR_STRING) + sizeof(ClientContext);

    return NDIS_STATUS_SUCCESS;

}


VOID
NdisMCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;

    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest);
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    Miniport = (PNDIS_MINIPORT_BLOCK)NdisBindingHandle;
    Open = ReqRsvd->Open;

    //1 do we need to check for this?
    if ((NdisRequest->RequestType == NdisRequestQueryInformation) &&
        (NdisRequest->DATA.QUERY_INFORMATION.Oid == OID_GEN_CURRENT_PACKET_FILTER) &&
        (NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength != 0))
    {
        if ((Open != NULL) && (Open->Flags & fMINIPORT_OPEN_PMODE))
        {
            *(PULONG)(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer) |=
                                NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL;
        }
    }

    if (Open != NULL)
    {
        KIRQL           OldIrql;

        if (ReqRsvd->Flags & REQST_DOWNLEVEL)
        {
            //
            // Complete the request to the protocol and deref the open
            //
            if (NdisRequest->RequestType == NdisRequestSetInformation)
            {
                NdisMSetInformationComplete(Miniport, Status);
            }
            else
            {
                NdisMQueryInformationComplete(Miniport, Status);
            }
        }
        else
        {
            //
            // Complete the request to the protocol and deref the open
            //
            ReqRsvd->Flags |= REQST_COMPLETED;
            (*CoReqRsvd->CoRequestCompleteHandler)(Status,
                                                   ReqRsvd->Open->ProtocolBindingContext,
                                                   CoReqRsvd->VcContext,
                                                   NULL,
                                                   NdisRequest);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

            ndisMDereferenceOpen(Open);
    
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }

    }
    else
    {
        //
        // Just set status and signal
        //
        CoReqRsvd->Status = Status;
        SET_EVENT(&CoReqRsvd->Event);
    }
}



VOID
NdisMCoIndicateReceivePacket(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate a set of packets to
    a particular VC.

Arguments:

    NdisVcHandle            - The handle suppplied by Ndis when the VC on which
                              data is received was first reserved.

    PacketArray             - Array of packets.

    NumberOfPackets         - Number of packets being indicated.

Return Value:

    None.
--*/
{
    PNULL_FILTER                Filter;
    UINT                        i, NumPmodeOpens;
    PNDIS_STACK_RESERVED        NSR;
    PNDIS_PACKET_OOB_DATA       pOob;
    PPNDIS_PACKET               pPktArray;
    PNDIS_PACKET                Packet;
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK           VcBlock = VcPtr->VcBlock;
    PNDIS_MINIPORT_BLOCK        Miniport;
    LOCK_STATE                  LockState;
#ifdef TRACK_RECEIVED_PACKETS
    ULONG                       OrgPacketStackLocation;
    PETHREAD                    CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif

    Miniport = VcBlock->Miniport;
    Filter = Miniport->NullDB;

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    VcBlock->ClientOpen->Flags |= fMINIPORT_PACKET_RECEIVED;

    //
    // NOTE that checking Vc Flags for Closing should not be needed since the CallMgr
    // holds onto the protocol's CloseCall request until the ref count goes to zero -
    // which means the miniport has to have completed its RELEASE_VC, which will
    // inturn mandate that we will NOT get any further indications from it.
    // The miniport must not complete a RELEASE_VC until it is no longer indicating data.
    //
    for (i = 0, pPktArray = PacketArray;
         i < NumberOfPackets;
         i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

#ifdef TRACK_RECEIVED_PACKETS
        OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif
        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN_PACKET(Miniport, Packet);

        //
        // Set context in the packet so that NdisReturnPacket can do the right thing
        //
        NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);

        if (pOob->Status != NDIS_STATUS_RESOURCES)
        {
            pOob->Status = NDIS_STATUS_SUCCESS;
        }

        //
        // Indicate the packet to the binding.
        //
        if ((VcBlock->Flags & VC_HANDOFF_IN_PROGRESS) == 0)
        {
            NSR->XRefCount = (SHORT)(*VcBlock->CoReceivePacketHandler)(VcBlock->ClientOpen->ProtocolBindingContext,
                                                                       VcBlock->ClientContext,
                                                                       Packet);
        }
        else
        {
            //
            // This VC is being transitioned from the NDIS proxy to
            // a proxied client. Since the proxy client may not be fully
            // set up, don't indicate this packet.
            //
            NSR->XRefCount = 0;
        }

        //
        // If there are promiscuous opens on this miniport, indicate it to them as well.
        // The client context will identify the VC.
        //
        if ((NumPmodeOpens = Miniport->PmodeOpens) > 0)
        {
            PNULL_BINDING_INFO  Open, NextOpen;
            PNDIS_OPEN_BLOCK    pPmodeOpen;

            for (Open = Filter->OpenList;
                 Open && (NumPmodeOpens > 0);
                 Open = NextOpen)
            {
                NextOpen = Open->NextOpen;
                pPmodeOpen = (PNDIS_OPEN_BLOCK)(Open->NdisBindingHandle);
                if (pPmodeOpen->Flags & fMINIPORT_OPEN_PMODE)
                {
                    NDIS_STATUS SavedStatus;
                    UINT        Ref;

                    if (pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler != NULL)
                    {
                        pPmodeOpen->Flags |= fMINIPORT_PACKET_RECEIVED;
    
                        SavedStatus = NDIS_GET_PACKET_STATUS(Packet);
                        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);
    
                        //
                        // For Pmode opens, we pass the VcId to the indication routine
                        // since the protocol does not really own the VC.
                        //

                        Ref = (*pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler)(
                                                pPmodeOpen->ProtocolBindingContext,
                                                &VcBlock->VcId,
                                                Packet);
    
                        ASSERT(Ref == 0);
    
                        NDIS_SET_PACKET_STATUS(Packet, SavedStatus);
                    }

                    NumPmodeOpens --;
                }
            }
        }

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}

VOID
NdisMCoReceiveComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate that the receive
    process is complete to all bindings. Only those bindings which
    have received packets will be notified. The Miniport lock is held
    when this is called.

Arguments:

    MiniportAdapterHandle - The handle supplied by Ndis at initialization
                            time through miniport initialize.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNULL_FILTER        Filter;
    PNDIS_OPEN_BLOCK    Open;
    LOCK_STATE          LockState;

    Filter = Miniport->NullDB;

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // check all of the bindings on this adapter
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        if (Open->Flags & fMINIPORT_PACKET_RECEIVED)
        {
            //
            // Indicate the binding.
            //
            Open->Flags &= ~fMINIPORT_PACKET_RECEIVED;

            (*Open->ReceiveCompleteHandler)(Open->ProtocolBindingContext);
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
NdisCoSendPackets(
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  PPNDIS_PACKET       PacketArray,
    IN  UINT                NumberOfPackets
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNULL_FILTER            Filter;
    LOCK_STATE              LockState;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = VcPtr->Miniport;
    PNDIS_PACKET            Packet;
    UINT                    PacketCount, Index, NumToSend;
    NDIS_STATUS             Status;
    ULONG                   NumPmodeOpens;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisCoSendPackets: VcPtr %x, FirstPkt %x, NumPkts %d\n",
                VcPtr, *PacketArray, NumberOfPackets));

    Filter = Miniport->NullDB;
    //1 why do we need to get filter lock?
    //1 do we need to ref VC or Open when we do a send?
    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // If there are promiscuous opens on this miniport, this must be indicated to them.
    // Do this before it is send down to the miniport to preserve packet ordering.
    //
    if ((NumPmodeOpens = Miniport->PmodeOpens) > 0)
    {
        PNDIS_OPEN_BLOCK    pPmodeOpen;

        for (pPmodeOpen = Miniport->OpenQueue;
             pPmodeOpen && (NumPmodeOpens > 0);
             pPmodeOpen = pPmodeOpen->MiniportNextOpen)
        {
            if (pPmodeOpen->Flags & fMINIPORT_OPEN_PMODE)
            {
                ULONG   Ref;

                pPmodeOpen->Flags |= fMINIPORT_PACKET_RECEIVED;

                for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
                {
                    Packet = PacketArray[PacketCount];

                    //
                    // For Pmode opens, we pass the VcId to the indication routine
                    // since the protocol does not really own the VC. On lookback
                    // the packet cannot be held.
                    //
                    Status = NDIS_GET_PACKET_STATUS(Packet);
                    NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);
                    Packet->Private.Flags |= NDIS_FLAGS_IS_LOOPBACK_PACKET;

                    Ref = (*pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler)(
                                            pPmodeOpen->ProtocolBindingContext,
                                            &VcBlock->VcId,
                                            Packet);

                    ASSERT(Ref == 0);
                    NDIS_SET_PACKET_STATUS(Packet, Status);
                    Packet->Private.Flags &= ~NDIS_FLAGS_IS_LOOPBACK_PACKET;
                }

                NumPmodeOpens--;
            }
        }
    }

    Status = NDIS_STATUS_SUCCESS;
    
    for (PacketCount = 0, Index = 0, NumToSend = 0;
         PacketCount < NumberOfPackets;
         PacketCount++)
    {
        Packet = PacketArray[PacketCount];
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
            {
                NSR->Open = VcPtr->ClientOpen;
                NSR->VcPtr = VcPtr;
                ndisMAllocSGList(Miniport, Packet);
            }
            else
            {
                NumToSend ++;
            }
        }
        else
        {
            NdisMCoSendComplete(NDIS_STATUS_RESOURCES, NdisVcHandle, Packet);
            if (NumToSend != 0)
            {
                ASSERT (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));

                //
                // Call down to the miniport to send this batch
                // The miniport must complete the sends for all cases.
                // The send either succeeds/pends or fails.
                //
                (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                                &PacketArray[Index],
                                                NumToSend);
                NumToSend = 0;
            }
            Index = PacketCount + 1;
        }
    }

    if (NumToSend != 0)
    {
        //
        // Send down the remaining packets
        //
        (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                        &PacketArray[Index],
                                        NumToSend);
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
NdisMCoSendComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  PNDIS_PACKET        Packet
    )
/*++

Routine Description:

    This function is called by the miniport when a send has completed. This
    routine simply calls the protocol to pass along the indication.

Arguments:

    MiniportAdapterHandle - points to the adapter block.
    NdisVcHandle          - the handle supplied to the adapter on the OID_RESERVE_VC
    PacketArray           - a ptr to an array of NDIS_PACKETS
    NumberOfPackets       - the number of packets in  PacketArray
    Status                - the send status that applies to all packets in the array

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    PNDIS_STACK_RESERVED    NSR;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisMCoSendComplete: Status %x, VcPtr %x, Pkt %x\n",
                Status, VcPtr, Packet));


    //
    // There should not be any reason to grab the spin lock and increment the
    // ref count on Open since the open cannot close until the Vc closes and
    // the Vc cannot close in the middle of an indication because the miniport
    // will not complete a RELEASE_VC until is it no longer indicating
    //
    //
    // Indicate to Protocol;
    //

    Open = VcBlock->ClientOpen;
    Miniport = VcBlock->Miniport;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
        (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
    {
        ndisMFreeSGList(Miniport, Packet);
    }
    
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
    CLEAR_WRAPPER_RESERVED(NSR);
    POP_PACKET_STACK(Packet);
    (VcBlock->CoSendCompleteHandler)(Status,
                                     VcBlock->ClientContext,
                                     Packet);

    //
    // Technically this Vc should not close since there is a send outstanding
    // on it, and the client should not close a Vc with an outstanding send.
    //
    //
    ASSERT(Open->References > 0);
}


VOID
NdisMCoIndicateStatus(
    IN  NDIS_HANDLE         MiniportAdapterHandle,
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  ULONG               StatusBufferSize
    )
/*++

Routine Description:

    This routine handles passing CoStatus to the protocol.  The miniport calls
    this routine when it has status on a VC or a general status for all Vcs - in
    this case the NdisVcHandle is null.

Arguments:

    MiniportAdapterHandle - pointer to the mini-port block;
    NdisVcHandle          - a pointer to the Vc block
    GeneralStatus         - the completion status of the request.
    StatusBuffer          - a buffer containing medium and status specific info
    StatusBufferSize      - the size of the buffer.

Return Value:

    none

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock;
    PNDIS_OPEN_BLOCK        Open;
    BOOLEAN                 fMediaConnectStateIndication = FALSE;

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMCoIndicateStatus\n"));
    
    if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
    {
        fMediaConnectStateIndication = TRUE;
    }

    do
    {
        NTSTATUS                NtStatus;
        PUNICODE_STRING         InstanceName;
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   DataBlockSize = 0;
        PUCHAR                  ptmp;
        PNDIS_GUID              pNdisGuid = NULL;
    
        //
        //  Get nice pointers to the instance names.
        //
        if (NULL != NdisVcHandle)
        {
            InstanceName = &VcPtr->VcInstanceName;
        }
        else
        {
            InstanceName = Miniport->pAdapterInstanceName;
        }

        //
        //  If there is no instance name then we can't indicate an event.
        //
        if (NULL == InstanceName)
        {
            break;
        }
    
        //
        //  Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, NULL, GeneralStatus);
        if ((pNdisGuid == NULL) ||
            !NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED))
        {
            break;
        }

        //
        //  If the data item is an array then we need to add in the number of
        //  elements.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = pNdisGuid->Size;
        }
        
        //
        // in case of media connect/disconnect status indication, include the
        // NIC's name in the WMI event
        //
        if (fMediaConnectStateIndication && (NULL == NdisVcHandle))
        {
            DataBlockSize += Miniport->MiniportName.Length + sizeof(WCHAR);
        }
        
        ndisSetupWmiNode(Miniport,
                         InstanceName,
                         DataBlockSize,
                         (PVOID)&pNdisGuid->Guid,
                         &wnode);

        if (wnode != NULL)
        {
            //
            //  Save the number of elements in the first ULONG.
            //
            ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

            //
            //  Copy in the data.
            //
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  If the status is an array but there is no data then complete it with no
                //  data and a 0 length
                //
                if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
                {
                    *((PULONG)ptmp) = 0;
                    ptmp += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;

                    //
                    //  Copy the data after the number of elements.
                    //
                    NdisMoveMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
                    ptmp += sizeof(ULONG) + StatusBufferSize;
                }
            }
            else
            {
                //
                //  Do we indicate any data up?
                //
                if (0 != pNdisGuid->Size)
                {
                    //
                    //  Copy the data into the buffer.
                    //
                    NdisMoveMemory(ptmp, StatusBuffer, pNdisGuid->Size);
                    ptmp += pNdisGuid->Size;
                }
            }
            
            if (fMediaConnectStateIndication && (NULL == NdisVcHandle))
            {
                //
                // for media connect/disconnect status, 
                // add the name of the adapter
                //
                RtlCopyMemory(ptmp,
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);
                    
            }

            //
            //  Indicate the event to WMI. WMI will take care of freeing
            //  the WMI struct back to pool.
            //
            NtStatus = IoWMIWriteEvent(wnode);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("    ndisMCoIndicateStatus: Unable to indicate the WMI event.\n"));

                FREE_POOL(wnode);
            }
        }
    } while (FALSE);

    switch (GeneralStatus)
    {
      case NDIS_STATUS_MEDIA_DISCONNECT:
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);

        //
        // miniport can do media sense and indicate that status to Ndis
        //
        //1 we don't need to keep track of fMINIPORT_REQUIRES_MEDIA_POLLING
        //1 for co-ndis media
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

        //
        //  Is this a PM enabled miniport? And is dynamic power policy
        //  enabled for the miniport?
        //

        //1 dead code for .NET
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
            (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
        {
            //
            //  Are we already waiting for the disconnect timer to fire?
            //
            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                //
                //  Mark the miniport as disconnecting and fire off the
                //  timer.
                //
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                
                NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
            }
        }
#endif
        break;

      case NDIS_STATUS_MEDIA_CONNECT:
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        //
        // miniport can do media sense and can indicate that status to Ndis. Do not poll
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

        //
        // if media disconnect timer was set, cancel the timer
        //

        //1 dead code for .NET
#ifdef NDIS_MEDIA_DISCONNECT_POWER_OFF
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
        {
            BOOLEAN fTimerCancelled;

            //
            //  Clear the disconnect wait bit and cancel the timer.
            //  IF the timer routine hasn't grabed the lock then we are ok.
            //
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

            NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
        }
        break;
#endif
    }

    if (VcPtr != NULL)
    {
        VcBlock = VcPtr->VcBlock;

        //
        // If this is a proxied VC, indicate to the proxy. 
        //

        if (VcBlock->pProxyVcPtr) 
        {
            Open = VcBlock->pProxyVcPtr->ClientOpen;
            (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(Open->ProtocolBindingContext,
                                                                            VcPtr->ClientContext,
                                                                            GeneralStatus,
                                                                            StatusBuffer,
                                                                            StatusBufferSize);
        }

        //
        // Indicate to the client.
        //

        if (VcBlock->pClientVcPtr)
        {
            Open = VcBlock->pClientVcPtr->ClientOpen;
            (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(Open->ProtocolBindingContext,
                                                                            VcPtr->ClientContext,
                                                                            GeneralStatus,
                                                                            StatusBuffer,
                                                                            StatusBufferSize);
        }
    }
    else if (Miniport->NullDB != NULL)
    {
        LOCK_STATE  LockState;

        //
        // this must be a general status for all clients of this miniport
        // since the Vc handle is null, so indicate this to all protocols.
        //

        //1 why we get filter lock?
        //1 this does not protect against Opens going away.
        READ_LOCK_FILTER(Miniport, Miniport->NullDB, &LockState);

        for (Open = Miniport->OpenQueue;
             Open != NULL;
             Open = Open->MiniportNextOpen)
        {
            if (((Open->Flags & fMINIPORT_OPEN_CLOSING) == 0) &&
                (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler != NULL))
            {
                (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(
                        Open->ProtocolBindingContext,
                        NULL,
                        GeneralStatus,
                        StatusBuffer,
                        StatusBufferSize);

            }
        }

        READ_UNLOCK_FILTER(Miniport, Miniport->NullDB, &LockState);
    }

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("<==NdisMCoIndicateStatus\n"));
}

VOID
ndisDereferenceAfNotification(
    IN  PNDIS_OPEN_BLOCK        Open
    )
{    
    ULONG   Ref;
    KIRQL   OldIrql;
    
//    DbgPrint("==>ndisDereferenceAfNotification Open: %p\n", Open);

    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);

    OPEN_DECREMENT_AF_NOTIFICATION(Open, Ref);
    
    if ((Ref == 0) &&
        (Open->AfNotifyCompleteEvent != NULL))
    {
        SET_EVENT(Open->AfNotifyCompleteEvent);
    }
    RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);

//    DbgPrint("<==ndisDereferenceAfNotification Open: %p, Ref %lx\n", Open, Ref);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndis_co.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndis_co.h

Abstract:

    NDIS wrapper CO definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jan-98  Jameel Hyder    Split up from ndisco.h
--*/

#ifndef _NDIS_CO_
#define _NDIS_CO_

//
//  NDIS_CO_AF_BLOCK:
//
//  This structure represents a client's open of an address family on an adapter.
//  An NdisAfHandle points to one of these.
//
//  Creation: NdisClOpenAddressFamily
//  Deletion: Ndis[M]CmCloseAddressFamilyComplete
//
typedef struct _NDIS_CO_AF_BLOCK
{
    struct _NDIS_CO_AF_BLOCK *      NextAf;             // the next open of the call manager per adapter open
    ULONG                           Flags;
    LONG                            References;
    PNDIS_MINIPORT_BLOCK            Miniport;           // pointer to the miniport in question

    //
    // Cached call manager entry points
    //
    PNDIS_CALL_MANAGER_CHARACTERISTICS  CallMgrEntries;
    PNDIS_OPEN_BLOCK                CallMgrOpen;        // pointer to the call manager's open adapter:
                                                        // this is NULL iff combined Miniport+CM

    NDIS_HANDLE                     CallMgrContext;     // context when calling CM's ProtXX funcs

    //
    // Cached client entry points
    //
    NDIS_CLIENT_CHARACTERISTICS     ClientEntries;
    PNDIS_OPEN_BLOCK                ClientOpen;         // pointer to the client's open adapter
    NDIS_HANDLE                     ClientContext;      // context when calling Client's ProtXX funcs

    KSPIN_LOCK                      Lock;
} NDIS_CO_AF_BLOCK, *PNDIS_CO_AF_BLOCK;


//
//  Bit definitions for Flags in NDIS_CO_AF_BLOCK
//
#define AF_COMBO                0x00000001              // Set iff combined Miniport+CM
#define AF_CLOSING              0x80000000


//
//  NDIS_CO_SAP_BLOCK:
//
//  Service Access Point (Sap) structure. The NdisSapHandle points to one of these.
//  A SAP is associated with an open AF block.
//
//  Creation: NdisClRegisterSap
//  Deletion: Ndis[M]CmDeregisterSapComplete
//
typedef struct _NDIS_CO_SAP_BLOCK
{
    NDIS_HANDLE                 CallMgrContext;
    NDIS_HANDLE                 ClientContext;
    PNDIS_CO_AF_BLOCK           AfBlock;
    PCO_SAP                     Sap;
    ULONG                       Flags;
    LONG                        References;
    KSPIN_LOCK                  Lock;
} NDIS_CO_SAP_BLOCK, *PNDIS_CO_SAP_BLOCK;

//
// Definitions for Flags in NDIS_CO_SAP_BLOCK:
//
#define SAP_CLOSING             0x80000000




//
//  NDIS_CO_VC_BLOCK:
//
//  The Virtual Connection structure. The NdisVcHandle points to a NDIS_CO_VC_PTR,
//  which points to one of these.
//
//  Creation: NdisCoCreateVc, NdisMCmCreateVc
//  Deletion: NdisCoDeleteVc, NdisMCmDeleteVc
//
typedef struct _NDIS_CO_VC_BLOCK
{
    ULONG                               References;
    ULONG                               Flags;          // to track closes
    KSPIN_LOCK                          Lock;

    PNDIS_OPEN_BLOCK                    ClientOpen;     // identifies the client for miniport
                                                        // IndicatePacket
    //
    // References for client and call-manager
    //
    NDIS_HANDLE                         ClientContext;  // passed up to the client on indications
    struct _NDIS_CO_VC_PTR_BLOCK    *   pProxyVcPtr;    // Pointer to Proxy's VcPr
    struct _NDIS_CO_VC_PTR_BLOCK    *   pClientVcPtr;   // Pointer to Client's VcPtr
    //
    // Clients cached entry points
    //
    CO_SEND_COMPLETE_HANDLER            CoSendCompleteHandler;
    CO_RECEIVE_PACKET_HANDLER           CoReceivePacketHandler;

    PNDIS_OPEN_BLOCK                    CallMgrOpen;    // identifies the call-manager
    NDIS_HANDLE                         CallMgrContext; // passed up to the call manager on indications

    //
    // Call-manager cached entry points duplicates of VC_PTR_BLOCK
    //
    CM_ACTIVATE_VC_COMPLETE_HANDLER     CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER   CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER          CmModifyCallQoSHandler;

    //
    // Miniport's context and some cached entry-points
    //
    PNDIS_MINIPORT_BLOCK                Miniport;       // pointer to the miniport in question
    NDIS_HANDLE                         MiniportContext;// passed down to the miniport

    ULONGLONG                           VcId;           // opaque ID for the VC, picked
                                                        // up from MediaParameters when
                                                        // the VC is activated

} NDIS_CO_VC_BLOCK, *PNDIS_CO_VC_BLOCK;


//
//  NDIS_CO_VC_PTR_BLOCK:
//
//  The VC Pointer structure. The NdisVcHandle points to one of these.
//  When a VC is created, one VC Block structure and one VC pointer structure
//  are created.
//
//
typedef struct _NDIS_CO_VC_PTR_BLOCK
{
    LONG                                References;
    ULONG                               CallFlags;      // call state of this VC Ptr
    PULONG                              pVcFlags;
    KSPIN_LOCK                          Lock;

    NDIS_HANDLE                         ClientContext;  // passed up to the client
                                                        // on indications and completes
    LIST_ENTRY                          ClientLink;
    LIST_ENTRY                          VcLink;

    PNDIS_CO_AF_BLOCK                   AfBlock;        // OPTIONAL - NULL for call-mgr owned VCs

    //
    // Miniport VC
    //
    PNDIS_CO_VC_BLOCK                   VcBlock;

    //
    // Identifies the client. This could be the call-manager open if the
    // Vc is call-manager owned, i.e. doesn't have an client association.
    //

    PNDIS_OPEN_BLOCK                    ClientOpen;

    LONG                                OwnsVcBlock;        

    //
    // The non-creator's handler and context
    //
    CO_DELETE_VC_HANDLER                CoDeleteVcHandler;
    NDIS_HANDLE                         DeleteVcContext;

    //
    // Clients cached entry points
    //
    CL_MODIFY_CALL_QOS_COMPLETE_HANDLER ClModifyCallQoSCompleteHandler;
    CL_INCOMING_CALL_QOS_CHANGE_HANDLER ClIncomingCallQoSChangeHandler;
    CL_CALL_CONNECTED_HANDLER           ClCallConnectedHandler;

    PNDIS_OPEN_BLOCK                    CallMgrOpen;    // identifies the call-manager
    NDIS_HANDLE                         CallMgrContext; // passed up to the call manager on indications
    LIST_ENTRY                          CallMgrLink;

    //
    // Call-manager cached entry points duplicates of VC_BLOCK
    //
    CM_ACTIVATE_VC_COMPLETE_HANDLER     CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER   CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER          CmModifyCallQoSHandler;

    //
    // Miniport's context and some cached entry-points
    //
    PNDIS_MINIPORT_BLOCK                Miniport;       // pointer to the miniport in question
    NDIS_HANDLE                         MiniportContext;// passed down to the miniport
    W_CO_SEND_PACKETS_HANDLER           WCoSendPacketsHandler;
    W_CO_DELETE_VC_HANDLER              WCoDeleteVcHandler;
    W_CO_ACTIVATE_VC_HANDLER            WCoActivateVcHandler;
    W_CO_DEACTIVATE_VC_HANDLER          WCoDeactivateVcHandler;

    UNICODE_STRING                      VcInstanceName;     //  Used to query this specific VC via WMI.
    LARGE_INTEGER                       VcIndex;            //  Used to build the instance name.
    LIST_ENTRY                          WmiLink;            //  List of WMI enabled VCs

} NDIS_CO_VC_PTR_BLOCK, *PNDIS_CO_VC_PTR_BLOCK;



#define VC_ACTIVE               0x00000001
#define VC_ACTIVATE_PENDING     0x00000002
#define VC_DEACTIVATE_PENDING   0x00000004
#define VC_DELETE_PENDING       0x00000008
#define VC_HANDOFF_IN_PROGRESS  0x00000010  // Being handed off to proxied client

//
// VC Call states:
//
#define VC_CALL_ACTIVE          0x00000008
#define VC_CALL_PENDING         0x00000010
#define VC_CALL_CLOSE_PENDING   0x00000020
#define VC_CALL_ABORTED         0x00000040
#define VC_PTR_BLOCK_CLOSING    0x80000000

//
// Structure to represent a handle generated when a multi-party call is generated.
// This handle can ONLY be used for NdisCoDropParty call.
//
typedef struct _NDIS_CO_PARTY_BLOCK
{
    PNDIS_CO_VC_PTR_BLOCK           VcPtr;
    NDIS_HANDLE                     CallMgrContext;
    NDIS_HANDLE                     ClientContext;

    //
    // Cached client Handlers
    //
    CL_INCOMING_DROP_PARTY_HANDLER  ClIncomingDropPartyHandler;
    CL_DROP_PARTY_COMPLETE_HANDLER  ClDropPartyCompleteHandler;
} NDIS_CO_PARTY_BLOCK, *PNDIS_CO_PARTY_BLOCK;


NTSTATUS
ndisUnicodeStringToPointer (
    IN  PUNICODE_STRING             String,
    OUT PVOID                       *Value
    );


#endif  // _NDIS_CO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\nfilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    nfilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Jameel Hyder (jameelh) July 1998

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop
#define MODULE_NUMBER   MODULE_NFILTER


BOOLEAN
nullCreateFilter(
    OUT PNULL_FILTER *          Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    Filter - A pointer to an NULL_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PNULL_FILTER LocalFilter;
    BOOLEAN     rc = FALSE;

    do
    {
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(NULL_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(NULL_FILTER));
            EthReferencePackage();
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}


//
// NOTE: THIS FUNCTION CANNOT BE PAGEABLE
//
VOID
nullDeleteFilter(
    IN  PNULL_FILTER                Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an NULL_FILTER to be deleted.

Return Value:

    None.

--*/
{
    ASSERT(Filter->OpenList == NULL);

    FREE_POOL(Filter);
}


NDIS_STATUS
nullDeleteFilterOpenAdapter(
    IN  PNULL_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    NDIS_STATUS         StatusToReturn = NDIS_STATUS_SUCCESS;
    PNULL_BINDING_INFO  LocalOpen = (PNULL_BINDING_INFO)NdisFilterHandle;

    //
    // Remove the reference from the original open.
    //
    if (--(LocalOpen->References) == 0)
    {
        XRemoveAndFreeBinding(Filter, LocalOpen);
    }
    else
    {
        //
        // Let the caller know that there is a reference to the open
        // by the receive indication. The close action routine will be
        // called upon return from NdisIndicateReceive.
        //
        StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
    }

    return(StatusToReturn);
}


VOID
ndisMDummyIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    )
{
    PPNDIS_PACKET           pPktArray = PacketArray;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET            Packet;
    PNDIS_PACKET_OOB_DATA   pOob;
    UINT                    i;


    //
    // if we set the dummy handler because we are in process of halting an IM miniport
    // or media is disconnected, do not complain
    //
    if (!(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER) &&
          MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING)))

    {
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_0,
                ("Miniport %p, Driver is indicating packets before setting any filter\n", Miniport));
        }
        else
        {
            NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                ("Miniport %p, Driver is indicating packets in Media disconnect state\n", Miniport));
        }
    }
    
    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // Walk all the packets and 'complete' them
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN(Miniport, PacketSize);

        //
        // Set the status here that nobody is holding the packet.
        //
        if (pOob->Status != NDIS_STATUS_RESOURCES)
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                W_RETURN_PACKET_HANDLER Handler;

                Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;
                pOob->Status = NDIS_STATUS_PENDING;
                NSR->Miniport = NULL;
                POP_PACKET_STACK(Packet);

                (*Handler)(Miniport->MiniportAdapterContext, Packet);

            }
            else
            {
                POP_PACKET_STACK(Packet);
                pOob->Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            POP_PACKET_STACK(Packet);
        }
    }
}

//1 in practice who would be calling this one?
//1 do we have any driver that is not co-ndis and
//1 does not go through a media filter either?

VOID
ndisMIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings. This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    PNULL_FILTER            Filter = Miniport->NullDB;
    PPNDIS_PACKET           pPktArray = PacketArray;
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET_OOB_DATA   pOob;
    PNDIS_BUFFER            Buffer;
    PUCHAR                  Address;
    UINT                    i, LASize,PacketSize, NumIndicates = 0;
    BOOLEAN                 fFallBack;
    PNULL_BINDING_INFO      Open, NextOpen;
    LOCK_STATE              LockState;

#ifdef TRACK_RECEIVED_PACKETS
    ULONG                   OrgPacketStackLocation;
    PETHREAD                CurThread = PsGetCurrentThread();
#endif

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

#ifdef TRACK_RECEIVED_PACKETS
       OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        ASSERT(NSR->RefCount == 0);
        if (NSR->RefCount != 0)
        {
            BAD_MINIPORT(Miniport, "Indicating packet not owned by it");

            KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                        0x12,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Packet,
                        (ULONG_PTR)PacketArray);
        }
    
        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
        NdisGetFirstBufferFromPacket(Packet,
                                     &Buffer,
                                     &Address,
                                     &LASize,
                                     &PacketSize);
        ASSERT(Buffer != NULL);
    
        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN(Miniport, PacketSize);

        //
        // Set the status here that nobody is holding the packet. This will get
        // overwritten by the real status from the protocol. Pay heed to what
        // the miniport is saying.
        //
        NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
        //
        // Set the status here that nobody is holding the packet. This will get
        // overwritten by the real status from the protocol. Pay heed to what
        // the miniport is saying.
        //
        if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
            !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
        {
            pOob->Status = NDIS_STATUS_SUCCESS;
            fFallBack = FALSE;
        }
        else
        {
#if DBG
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                        ("Miniport going into D3, not indicating chained receives\n"));
            }
#endif
            fFallBack = TRUE;
        }
    
        for (Open = Filter->OpenList;
             Open != NULL;
             Open = NextOpen)
        {
            //
            //  Get the next open to look at.
            //
            NextOpen = Open->NextOpen;
            Open->ReceivedAPacket = TRUE;
            NumIndicates ++;
    
            IndicateToProtocol(Miniport,
                               Filter,
                               (PNDIS_OPEN_BLOCK)(Open->NdisBindingHandle),
                               Packet,
                               NSR,
                               Address,
                               PacketSize,
                               pOob->HeaderSize,
                               &fFallBack,
                               FALSE,
                               NdisMediumMax);  // A dummy medium since it is unknown
        }

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (Open = Filter->OpenList;
             Open != NULL;
             Open = NextOpen)
        {
            NextOpen = Open->NextOpen;
    
            if (Open->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                Open->ReceivedAPacket = FALSE;
                FilterIndicateReceiveComplete(Open->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
FASTCALL
XFilterLockHandler(
    IN  PETH_FILTER             Filter,
    IN OUT  PLOCK_STATE         pLockState
    )
{
    xLockHandler(&Filter->BindListLock, pLockState);
}

VOID
XRemoveAndFreeBinding(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

Routine Description:

    This routine will remove a binding from the filter database and
    indicate a receive complete if necessary.  This was made a function
    to remove code redundancey in following routines.  Its not time
    critical so it's cool.

Arguments:

    Filter  -   Pointer to the filter database to remove the binding from.
    Binding -   Pointer to the binding to remove.
--*/
{
    XRemoveBindingFromLists(Filter, Binding);

    switch (Filter->Miniport->MediaType)
    {
      case NdisMedium802_3:
        ASSERT(Binding->MCastAddressBuf == NULL);
        if (Binding->OldMCastAddressBuf)
        {
            FREE_POOL(Binding->OldMCastAddressBuf);
        }
        break;

      case NdisMediumFddi:
        ASSERT(Binding->MCastLongAddressBuf == NULL);
        ASSERT(Binding->MCastShortAddressBuf == NULL);
    
        if (Binding->OldMCastLongAddressBuf)
        {
            FREE_POOL(Binding->OldMCastLongAddressBuf);
        }
    
        if (Binding->OldMCastShortAddressBuf)
        {
            FREE_POOL(Binding->OldMCastShortAddressBuf);
        }
    }

    if (Filter->MCastSet == Binding)
    {
        Filter->MCastSet = NULL;
    }

    FREE_POOL(Binding);
}


VOID
XRemoveBindingFromLists(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

    This routine will remove a binding from all of the list in a filter database.

Arguments:

    Filter  -   Pointer to the filter database to remove the binding from.
    Binding -   Pointer to the binding to remove.

--*/
{
    PX_BINDING_INFO *   ppBI;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    
    if (Filter->SingleActiveOpen == Binding)
    {
        Filter->SingleActiveOpen = NULL;
        ndisUpdateCheckForLoopbackFlag(Filter->Miniport);
    }

    //
    //  Remove the binding from the filters list
    //
    for (ppBI = &Filter->OpenList;
         *ppBI != NULL;
         ppBI = &(*ppBI)->NextOpen)
    {
        if (*ppBI == Binding)
        {
            *ppBI = Binding->NextOpen;
            break;
        }
    }
    ASSERT(*ppBI == Binding->NextOpen);

    Binding->NextOpen = NULL;
    Filter->NumOpens --;

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}

NDIS_STATUS
XFilterAdjust(
    IN  PX_FILTER               Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

    FilterClasses - The filter classes that are to be added or
    deleted.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PX_BINDING_INFO LocalOpen = (PETH_BINDING_INFO)NdisFilterHandle;
    PX_BINDING_INFO OpenList;

    UNREFERENCED_PARAMETER(Set);
    
    //
    // Set the new filter information for the open.
    //
    LocalOpen->OldPacketFilters = LocalOpen->PacketFilters;
    LocalOpen->PacketFilters = FilterClasses;
    Filter->OldCombinedPacketFilter = Filter->CombinedPacketFilter;

    //
    // We always have to reform the combined filter since
    // this filter index may have been the only filter index
    // to use a particular bit.
    //
    for (OpenList = Filter->OpenList, Filter->CombinedPacketFilter = 0;
         OpenList != NULL;
         OpenList = OpenList->NextOpen)
    {
        Filter->CombinedPacketFilter |= OpenList->PacketFilters;
    }

    return (((Filter->OldCombinedPacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL) !=
                    (Filter->CombinedPacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                    NDIS_STATUS_PENDING : NDIS_STATUS_SUCCESS);
}


VOID
XUndoFilterAdjust(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    Binding->PacketFilters = Binding->OldPacketFilters;
    Filter->CombinedPacketFilter = Filter->OldCombinedPacketFilter;
}

BOOLEAN
XNoteFilterOpenAdapter(
    IN  PX_FILTER               Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    )
/*++

Routine Description:

    This routine is used to add a new binding to the filter database.

    NOTE: THIS ROUTINE ASSUMES THAT THE DATABASE IS LOCKED WHEN
    IT IS CALLED.

Arguments:

    Filter - A pointer to the previously created and initialized filter
    database.

    NdisBindingHandle - a pointer to Ndis Open block

    NdisFilterHandle - A pointer to Filter open.

Return Value:

    Will return false if creating a new filter index will cause the maximum
    number of filter indexes to be exceeded.

--*/
{
    PX_BINDING_INFO     LocalOpen;
    BOOLEAN             rc = FALSE;
    LOCK_STATE          LockState;

    *NdisFilterHandle = LocalOpen = ALLOC_FROM_POOL(sizeof(X_BINDING_INFO), NDIS_TAG_FILTER);
    if (LocalOpen != NULL)
    {
        ZeroMemory(LocalOpen, sizeof(X_BINDING_INFO));
    
        LocalOpen->References = 1;
        LocalOpen->NdisBindingHandle = NdisBindingHandle;

        WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

        LocalOpen->NextOpen = Filter->OpenList;
        Filter->OpenList = LocalOpen;
        Filter->NumOpens ++;
    
        WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
        rc = TRUE;
    }

    return rc;
}


VOID
ndisMDummyIndicateReceive(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
{
    UNREFERENCED_PARAMETER(Filter);
    UNREFERENCED_PARAMETER(MacReceiveContext);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(HeaderBuffer);
    UNREFERENCED_PARAMETER(HeaderBufferSize);
    UNREFERENCED_PARAMETER(LookaheadBuffer);
    UNREFERENCED_PARAMETER(LookaheadBufferSize);
    UNREFERENCED_PARAMETER(PacketSize);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\precomp.h ===
#include "wrapper.h"

#include <windef.h> // needed for ks.h
#include <ks.h>
#include <ndisprv.h>
#include <ndisguid.h>
#include <tdikrnl.h>
#include <wmistr.h>
#include <wdmguid.h>
#include <wmikm.h>

#include "ndisnt.h"
#include "mini.h"
#include "protos.h"
#include "cprotos.h"
#include "sendm.h"
#include "requestm.h"
#include "nfilter.h"
#include "pragma.h"
#include "data.h"
#include "fsbpool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\nfilter.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nfilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

    Jameel Hyder (jameelh) July 1998

Environment:


Notes:

--*/

#ifndef _NULL_FILTER_DEFS_
#define _NULL_FILTER_DEFS_

typedef
VOID
(*NULL_DEFERRED_CLOSE)(
    IN  NDIS_HANDLE             BindingHandle
    );

//
// The binding info is threaded on a single list.
//
typedef X_BINDING_INFO  NULL_BINDING_INFO,*PNULL_BINDING_INFO;

typedef X_FILTER        NULL_FILTER,*PNULL_FILTER;

//
// Exported functions
//
EXPORT
BOOLEAN
nullCreateFilter(
    OUT PNULL_FILTER *          Filter
    );

EXPORT
VOID
nullDeleteFilter(
    IN  PNULL_FILTER            Filter
    );


EXPORT
NDIS_STATUS
nullDeleteFilterOpenAdapter(
    IN  PNULL_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    );

VOID
nullRemoveAndFreeBinding(
    IN  PNULL_FILTER            Filter,
    IN  PNULL_BINDING_INFO      Binding,
    IN  BOOLEAN                 fCallCloseAction
    );

VOID
FASTCALL
nullFilterLockHandler(
    IN  PNULL_FILTER                    Filter,
    IN OUT PLOCK_STATE                  pLockState
    );

/*++
  
Routine Description:

    Multiple-reader-single-writer locking scheme for Filter DB

    Use refCounts to keep track of how many readers are doing reads.
    Use per-processor refCounts to reduce bus traffic.
    Writers are serialized by means of a spin lock. Then they wait for
    readers to finish reading by waiting till refCounts for all processors
    go to zero. Rely on snoopy caches to get the sum right without doing
    interlocked operations

--*/

#define TEST_SPIN_LOCK(_L)  ((_L) != 0)

#define NDIS_READ_LOCK(_L, _pLS)                                        \
{                                                                       \
    UINT    refcount;                                                   \
    ULONG   Prc;                                                        \
                                                                        \
    RAISE_IRQL_TO_DISPATCH(&(_pLS)->OldIrql);                           \
                                                                        \
    /* go ahead and bump up the ref count IF no writes are underway */  \
    Prc = CURRENT_PROCESSOR;                                            \
    refcount = InterlockedIncrement((PLONG)&(_L)->RefCount[Prc].RefCount); \
                                                                        \
    /* Test if spin lock is held, i.e., write is underway   */          \
    /* if (KeTestSpinLock(&(_L)->SpinLock) == TRUE)         */          \
    /* This processor already is holding the lock, just     */          \
    /* allow him to take it again or else we run into a     */          \
    /* dead-lock situation with the writer                  */          \
    if (TEST_SPIN_LOCK((_L)->SpinLock) &&                               \
        (refcount == 1) &&                                              \
        ((_L)->Context != CURRENT_THREAD))                              \
    {                                                                   \
        (_L)->RefCount[Prc].RefCount--;                                 \
        ACQUIRE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
        (_L)->RefCount[Prc].RefCount++;                                 \
        RELEASE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
    }                                                                   \
    (_pLS)->LockState = READ_LOCK_STATE_FREE;                           \
}


#define NDIS_READ_LOCK_DPC(_L, _pLS)                                    \
{                                                                       \
    UINT    refcount;                                                   \
    ULONG   Prc;                                                        \
                                                                        \
    /* go ahead and bump up the ref count IF no writes are underway */  \
    Prc = CURRENT_PROCESSOR;                                            \
    refcount = InterlockedIncrement((PLONG)&(_L)->RefCount[Prc].RefCount);     \
                                                                        \
    /* Test if spin lock is held, i.e., write is underway   */          \
    /* if (KeTestSpinLock(&(_L)->SpinLock) == TRUE)         */          \
    /* This processor already is holding the lock, just     */          \
    /* allow him to take it again or else we run into a     */          \
    /* dead-lock situation with the writer                  */          \
    if (TEST_SPIN_LOCK((_L)->SpinLock) &&                               \
        (refcount == 1) &&                                              \
        ((_L)->Context != CURRENT_THREAD))                              \
    {                                                                   \
        (_L)->RefCount[Prc].RefCount--;                                 \
        ACQUIRE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
        (_L)->RefCount[Prc].RefCount++;                                 \
        RELEASE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
    }                                                                   \
    (_pLS)->LockState = READ_LOCK_STATE_FREE;                           \
}


#define NDIS_WRITE_LOCK_STATE_UNKNOWN(_L, _pLS)                         \
{                                                                       \
    UINT    i, refcount;                                                \
    ULONG   Prc;                                                        \
                                                                        \
    /*                                                                  \
     * This means we need to attempt to acquire the lock,               \
     * if we do not already own it.                                     \
     * Set the state accordingly.                                       \
     */                                                                 \
    if ((_L)->Context == CURRENT_THREAD)                                \
    {                                                                   \
        (_pLS)->LockState = LOCK_STATE_ALREADY_ACQUIRED;                \
    }                                                                   \
    else                                                                \
    {                                                                   \
        ACQUIRE_SPIN_LOCK(&(_L)->SpinLock, &(_pLS)->OldIrql);           \
                                                                        \
        Prc = KeGetCurrentProcessorNumber();                            \
        refcount = (_L)->RefCount[Prc].RefCount;                        \
        (_L)->RefCount[Prc].RefCount = 0;                               \
                                                                        \
        /* wait for all readers to exit */                              \
        for (i=0; i < ndisNumberOfProcessors; i++)                      \
        {                                                               \
            volatile UINT   *_p = &(_L)->RefCount[i].RefCount;          \
                                                                        \
            while (*_p != 0)                                            \
                NDIS_INTERNAL_STALL(50);                                \
        }                                                               \
                                                                        \
        (_L)->RefCount[Prc].RefCount = refcount;                        \
        (_L)->Context = CURRENT_THREAD;                                 \
        (_pLS)->LockState = WRITE_LOCK_STATE_FREE;                      \
    }                                                                   \
}

#define NDIS_READ_LOCK_STATE_FREE(_L, _pLS)                             \
{                                                                       \
    ULONG   Prc;                                                        \
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);                             \
    Prc = CURRENT_PROCESSOR;                                            \
    ASSERT((_L)->RefCount[Prc].RefCount > 0);                           \
    (_L)->RefCount[Prc].RefCount--;                                     \
    (_pLS)->LockState = LOCK_STATE_UNKNOWN;                             \
    if ((_pLS)->OldIrql < DISPATCH_LEVEL)                               \
    {                                                                   \
        KeLowerIrql((_pLS)->OldIrql);                                   \
    }                                                                   \
}

#define NDIS_READ_LOCK_STATE_FREE_DPC(_L, _pLS)                         \
{                                                                       \
    ULONG   Prc;                                                        \
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);                             \
    Prc = CURRENT_PROCESSOR;                                            \
    ASSERT((INT)(_L)->RefCount[Prc].RefCount > 0);                      \
    (_L)->RefCount[Prc].RefCount--;                                     \
    (_pLS)->LockState = LOCK_STATE_UNKNOWN;                             \
}

#define NDIS_WRITE_LOCK_STATE_FREE(_L, _pLS)                            \
{                                                                       \
    /* We acquired it. Now we need to free it */                        \
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);                             \
    ASSERT((_L)->Context == CURRENT_THREAD);                            \
    (_pLS)->LockState = LOCK_STATE_UNKNOWN;                             \
    (_L)->Context = NULL;                                               \
    RELEASE_SPIN_LOCK(&(_L)->SpinLock, (_pLS)->OldIrql);                \
}

#define NDIS_LOCK_STATE_ALREADY_ACQUIRED(_L, _pLS)                      \
{                                                                       \
    ASSERT((_L)->Context == CURRENT_THREAD);                            \
    /* Nothing to do */                                                 \
}


#define xLockHandler(_L, _pLS)                                                  \
    {                                                                           \
        switch ((_pLS)->LockState)                                              \
        {                                                                       \
          case READ_LOCK:                                                       \
            NDIS_READ_LOCK(_L, _pLS);                                           \
            break;                                                              \
                                                                                \
          case WRITE_LOCK_STATE_UNKNOWN:                                        \
            NDIS_WRITE_LOCK_STATE_UNKNOWN(_L, _pLS);                            \
            break;                                                              \
                                                                                \
          case READ_LOCK_STATE_FREE:                                            \
            NDIS_READ_LOCK_STATE_FREE(_L, _pLS);                                \
            break;                                                              \
                                                                                \
          case WRITE_LOCK_STATE_FREE:                                           \
            NDIS_WRITE_LOCK_STATE_FREE(_L, _pLS);                               \
            break;                                                              \
                                                                                \
          case LOCK_STATE_ALREADY_ACQUIRED:                                     \
            NDIS_LOCK_STATE_ALREADY_ACQUIRED(_L, _pLS);                         \
            /* Nothing to do */                                                 \
            break;                                                              \
                                                                                \
          default:                                                              \
            ASSERT(0);                                                          \
            break;                                                              \
        }                                                                       \
    }

#define NDIS_INITIALIZE_RCVD_PACKET(_P, _NSR, _M)                               \
    {                                                                           \
        _NSR->RefCount = -1;                                                    \
        _NSR->XRefCount = 0;                                                    \
        _NSR->Miniport = _M;                                                    \
        /*                                                                      \
         * Ensure that we force re-calculation.                                 \
         */                                                                     \
        (_P)->Private.ValidCounts = FALSE;                                      \
    }

#define NDIS_ACQUIRE_PACKET_LOCK_DPC(_NSR)  ACQUIRE_SPIN_LOCK_DPC(&(_NSR)->Lock)

#define NDIS_RELEASE_PACKET_LOCK_DPC(_NSR)  RELEASE_SPIN_LOCK_DPC(&(_NSR)->Lock)

#define ADJUST_PACKET_REFCOUNT(_NSR, _pRC)                                      \
    {                                                                           \
        *(_pRC) = InterlockedDecrement(&(_NSR)->RefCount);                      \
    }

#ifdef TRACK_RECEIVED_PACKETS                                            

//
// NSR->XRefCount = Number of times protocol said it will call NdisReturnPacket
// NSR->RefCount = is decremented every time protocol calls NdisReturnPackets
//

#define COALESCE_PACKET_REFCOUNT_DPC(_Packet, _M, _NSR, _pOob, _pRC)            \
    {                                                                           \
        LONG    _LocalXRef = (_NSR)->XRefCount;                                 \
        if (_LocalXRef != 0)                                                    \
        {                                                                       \
            LONG    _LocalRef;                                                  \
            ASSERT((_pOob)->Status != NDIS_STATUS_RESOURCES);                   \
            _LocalRef = InterlockedExchangeAdd(&(_NSR)->RefCount, (_LocalXRef + 1));    \
            *(_pRC) = _LocalRef + _LocalXRef + 1;                               \
            if ((*(_pRC) > 0) && (!MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))) \
            {                                                                   \
                NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_PENDING);           \
            }                                                                   \
            if ((*(_pRC) == 0) && ((_NSR)->RefCount != 0))                      \
            {                                                                   \
                DbgPrint("Packet %p is being returned back to the miniport"     \
                         " but the ref count is not zero.\n", _Packet);         \
                DbgBreakPoint();                                                \
            }                                                                   \
        }                                                                       \
        else                                                                    \
        {                                                                       \
            _NSR->RefCount = *(_pRC) = 0;                                       \
        }                                                                       \
    }

#define TACKLE_REF_COUNT(_M, _P, _S, _O)                                        \
    {                                                                           \
        LONG    RefCount;                                                       \
                                                                                \
        /*                                                                      \
         * We started off with the RefCount set to -1.                          \
         * NdisReturnPackets may have been called which will further reduce it. \
         * Add back the RefCount returned by the protocol                       \
         * and account for the initial -1.                                      \
         */                                                                     \
        COALESCE_PACKET_REFCOUNT_DPC(_P, _M, _S, _O, &RefCount);                \
                                                                                \
        NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                              \
                                7, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                                                                                \
        if (RefCount == 0)                                                      \
        {                                                                       \
            POP_PACKET_STACK(_P);                                               \
            if ((_O)->Status != NDIS_STATUS_RESOURCES)                          \
            {                                                                   \
                if (MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))            \
                {                                                               \
                    /*                                                          \
                     * Return packets which are truly free,                     \
                     * but only for deserialized drivers                        \
                     */                                                         \
                    W_RETURN_PACKET_HANDLER Handler;                            \
                    if (_S->RefCount != 0)                                      \
                    {                                                           \
                        DbgPrint("Packet %p is being returned back to the "     \
                                 "miniport but the ref count is not zero.\n", _P); \
                        DbgBreakPoint();                                        \
                    }                                                           \
                    if ((_P)->Private.Head == NULL)                             \
                    {                                                           \
                        DbgPrint("Packet %p is being returned back to the miniport with NULL Head.\n", _P); \
                        DbgBreakPoint();                                        \
                    }                                                           \
                                                                                \
                    if (!MINIPORT_TEST_FLAG(_M, fMINIPORT_INTERMEDIATE_DRIVER)) \
                    {                                                           \
                        ULONG    SL;                                            \
                        if ((SL = CURR_STACK_LOCATION(_P)) != -1)               \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-IM miniport"\
                                     " with stack location %lx.\n", Packet, SL);  \
                            DbgBreakPoint();                                    \
                        }                                                       \
                    }                                                           \
                                                                                \
                    Handler = (_M)->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;\
                    (_S)->Miniport = NULL;                                      \
                    (_O)->Status = NDIS_STATUS_PENDING;                         \
                                                                                \
                    NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                  \
                                            8, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                                                                                \
                    (*Handler)((_M)->MiniportAdapterContext, _P);               \
                }                                                               \
                else                                                            \
                {                                                               \
                    {                                                           \
                        ULONG    SL;                                            \
                        if ((SL = CURR_STACK_LOCATION(_P)) != -1)               \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-IM miniport"\
                                     " with stack location %lx.\n", Packet, SL);  \
                            DbgBreakPoint();                                    \
                        }                                                       \
                    }                                                           \
                                                                                \
                    if ((NDIS_GET_PACKET_STATUS(_P) == NDIS_STATUS_RESOURCES))  \
                    {                                                           \
                        NDIS_STATUS _OStatus = (NDIS_STATUS)NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalStatus); \
                                                                                \
                        if (_OStatus != NDIS_STATUS_RESOURCES)                  \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-deserialized miniport"\
                                     " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", _P, _OStatus); \
                            DbgBreakPoint();                                    \
                        }                                                       \
                                                                                \
                    }                                                           \
                                                                                \
                    (_O)->Status = NDIS_STATUS_SUCCESS;                         \
                    NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                  \
                                            9, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                }                                                               \
            }                                                                   \
        }                                                                       \
        else if (MINIPORT_TEST_FLAG((_M), fMINIPORT_INTERMEDIATE_DRIVER))       \
        {                                                                       \
            InterlockedIncrement((PLONG)&(_M)->IndicatedPacketsCount);          \
        }                                                                       \
    }

#else
//
// NSR->XRefCount = Number of times protocol said it will call NdisReturnPacket
// NSR->RefCount = is decremented every time protocol calls NdisReturnPackets
//

#define COALESCE_PACKET_REFCOUNT_DPC(_Packet, _M, _NSR, _pOob, _pRC)            \
    {                                                                           \
        LONG    _LocalXRef = (_NSR)->XRefCount;                                 \
        if (_LocalXRef != 0)                                                    \
        {                                                                       \
            LONG    _LocalRef;                                                  \
            ASSERT((_pOob)->Status != NDIS_STATUS_RESOURCES);                   \
            _LocalRef = InterlockedExchangeAdd(&(_NSR)->RefCount, (_LocalXRef + 1));    \
            *(_pRC) = _LocalRef + _LocalXRef + 1;                               \
            if ((*(_pRC) > 0) && (!MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))) \
            {                                                                   \
                NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_PENDING);           \
            }                                                                   \
        }                                                                       \
        else                                                                    \
        {                                                                       \
            _NSR->RefCount = *(_pRC) = 0;                                       \
        }                                                                       \
    }

#define TACKLE_REF_COUNT(_M, _P, _S, _O)                                        \
    {                                                                           \
        LONG    RefCount;                                                       \
                                                                                \
        /*                                                                      \
         * We started off with the RefCount set to -1.                          \
         * NdisReturnPackets may have been called which will further reduce it. \
         * Add back the RefCount returned by the protocol                       \
         * and account for the initial -1.                                      \
         */                                                                     \
        COALESCE_PACKET_REFCOUNT_DPC(_P, _M, _S, _O, &RefCount);                \
                                                                                \
        if (RefCount == 0)                                                      \
        {                                                                       \
            POP_PACKET_STACK(_P);                                               \
            if ((_O)->Status != NDIS_STATUS_RESOURCES)                          \
            {                                                                   \
                if (MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))            \
                {                                                               \
                    /*                                                          \
                     * Return packets which are truly free,                     \
                     * but only for deserialized drivers                        \
                     */                                                         \
                    W_RETURN_PACKET_HANDLER Handler;                            \
                                                                                \
                    Handler = (_M)->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;\
                    (_S)->Miniport = NULL;                                      \
                    (_O)->Status = NDIS_STATUS_PENDING;                         \
                                                                                \
                    (*Handler)((_M)->MiniportAdapterContext, _P);               \
                }                                                               \
                else                                                            \
                {                                                               \
                    (_O)->Status = NDIS_STATUS_SUCCESS;                         \
                }                                                               \
            }                                                                   \
        }                                                                       \
        else if (MINIPORT_TEST_FLAG((_M), fMINIPORT_INTERMEDIATE_DRIVER))       \
        {                                                                       \
            InterlockedIncrement((PLONG)&(_M)->IndicatedPacketsCount);          \
        }                                                                       \
    }


#endif
#endif // _NULL_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\protocol.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    NDIS wrapper functions used by protocol modules

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization

--*/

#define GLOBALS
#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_PROTOCOL

//
// Requests used by protocol modules
//
//

VOID
NdisRegisterProtocol(
    OUT PNDIS_STATUS            pStatus,
    OUT PNDIS_HANDLE            NdisProtocolHandle,
    IN  PNDIS_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics,
    IN  UINT                    CharacteristicsLength
    )
/*++

Routine Description:

    Register an NDIS protocol.

Arguments:

    Status - Returns the final status.
    NdisProtocolHandle - Returns a handle referring to this protocol.
    ProtocolCharacteritics - The NDIS_PROTOCOL_CHARACTERISTICS table.
    CharacteristicsLength - The length of ProtocolCharacteristics.

Return Value:

    None.

Comments:

    Called at passive level

--*/
{
    PNDIS_PROTOCOL_BLOCK Protocol;
    NDIS_STATUS          Status;
    KIRQL                OldIrql;
    USHORT               size;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisRegisterProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &ProtocolCharacteristics->Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    PnPReferencePackage();
    ProtocolReferencePackage();


    do
    {

        IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
        {
            BOOLEAN f = FALSE;
            if (DbgIsNull(ProtocolCharacteristics->OpenAdapterCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: OpenAdapterCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->CloseAdapterCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: CloseAdapterCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->SendCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: SendCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->TransferDataCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: TransferDataCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->ResetCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: ResetCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->RequestCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: RequestCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->ReceiveHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: ReceiveHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->ReceiveCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: ReceiveCompleteHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->StatusHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: StatusHandler Null\n"));
                f = TRUE;
            }
            if (DbgIsNull(ProtocolCharacteristics->StatusCompleteHandler))
            {
                DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR,
                    ("RegisterProtocol: StatusCompleteHandler Null\n"));
                f = TRUE;
            }
            if (f)
            {
                DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
                //1 for the time being do not fail the registeration.
//                Status = NDIS_STATUS_BAD_CHARACTERISTICS;
//                break;
            }
        }

        
        //
        // Check version numbers and CharacteristicsLength.
        //
        size = 0;   // Used to indicate bad version below
        
        if (ProtocolCharacteristics->MajorNdisVersion < 4)
        {
            DbgPrint("Ndis: NdisRegisterProtocol Ndis 3.0 protocols are not supported.\n");             
        }
        else if ((ProtocolCharacteristics->MajorNdisVersion == 4) &&
                 (ProtocolCharacteristics->MinorNdisVersion == 0))
        {
            size = sizeof(NDIS40_PROTOCOL_CHARACTERISTICS);
        }
        else if ((ProtocolCharacteristics->MajorNdisVersion == 5) &&
                 (ProtocolCharacteristics->MinorNdisVersion <= 1))
        {
            size = sizeof(NDIS50_PROTOCOL_CHARACTERISTICS);
        }
        

        //
        // Check that this is an NDIS 4.0/5.0/5.1 protocol.
        //
        if (size == 0)
        {
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }
        
        if ((ProtocolCharacteristics->BindAdapterHandler == NULL) ||
            (ProtocolCharacteristics->UnbindAdapterHandler == NULL))
        {
            DbgPrint("Ndis: NdisRegisterProtocol protocol does not have Bind/UnbindAdapterHandler and it is not supported.\n");
            Status = NDIS_STATUS_BAD_VERSION;
            break;
             
        }

        //
        // Check that CharacteristicsLength is enough.
        //
        if (CharacteristicsLength < size)
        {
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //
        // Allocate memory for the NDIS protocol block.
        //
        Protocol = (PNDIS_PROTOCOL_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_PROTOCOL_BLOCK) +
                                                          ProtocolCharacteristics->Name.Length + sizeof(WCHAR),
                                                          NDIS_TAG_PROT_BLK);
        if (Protocol == (PNDIS_PROTOCOL_BLOCK)NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        ZeroMemory(Protocol, sizeof(NDIS_PROTOCOL_BLOCK) + sizeof(WCHAR) + ProtocolCharacteristics->Name.Length);
        INITIALIZE_MUTEX(&Protocol->Mutex);

        //
        // Copy over the characteristics table.
        //
        CopyMemory(&Protocol->ProtocolCharacteristics,
                  ProtocolCharacteristics,
                  size);

        // Upcase the name in the characteristics table before saving it.
        Protocol->ProtocolCharacteristics.Name.Buffer = (PWCHAR)((PUCHAR)Protocol +
                                                                   sizeof(NDIS_PROTOCOL_BLOCK));
        Protocol->ProtocolCharacteristics.Name.Length = ProtocolCharacteristics->Name.Length;
        Protocol->ProtocolCharacteristics.Name.MaximumLength = ProtocolCharacteristics->Name.Length;
        RtlUpcaseUnicodeString(&Protocol->ProtocolCharacteristics.Name,
                               &ProtocolCharacteristics->Name,
                               FALSE);

        //
        // No opens for this protocol yet.
        //
        Protocol->OpenQueue = (PNDIS_OPEN_BLOCK)NULL;

        ndisInitializeRef(&Protocol->Ref);
        *NdisProtocolHandle = (NDIS_HANDLE)Protocol;
        Status = NDIS_STATUS_SUCCESS;

        //
        // Link the protocol into the list.
        //
        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);

        Protocol->NextProtocol = ndisProtocolList;
        ndisProtocolList = Protocol;

        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);

        REF_NDIS_DRIVER_OBJECT();
                
        ndisReferenceProtocol(Protocol);
        
        //
        // Start a worker thread to notify the protocol of any existing drivers
        //
        INITIALIZE_WORK_ITEM(&Protocol->WorkItem, ndisCheckProtocolBindings, Protocol);
        QUEUE_WORK_ITEM(&Protocol->WorkItem, CriticalWorkQueue);

    } while (FALSE);

    *pStatus = Status;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ProtocolDereferencePackage();
    }
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisRegisterProtocol\n"));
}


VOID
NdisDeregisterProtocol(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisProtocolHandle
    )
/*++

Routine Description:

    Deregisters an NDIS protocol.

Arguments:

    Status - Returns the final status.
    NdisProtocolHandle - The handle returned by NdisRegisterProtocol.

Return Value:

    None.

Note:

    This will kill all the opens for this protocol.
    Called at PASSIVE level

--*/
{
    PNDIS_PROTOCOL_BLOCK    Protocol = (PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle;
    KEVENT                  DeregEvent;
    PNDIS_PROTOCOL_BLOCK    tProtocol;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisDeregisterProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("DeregisterProtocol: Null Handle\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("DeregisterProtocol: Handle not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    //
    // first to check if the protcol exist. some buggy drivers deregister
    // even though registeration did not go through
    //

    PnPReferencePackage();
    ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);

    for (tProtocol = ndisProtocolList;
         tProtocol != NULL;
         tProtocol = tProtocol->NextProtocol)
    {
        if (tProtocol == Protocol)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
    PnPDereferencePackage();

    ASSERT(tProtocol == Protocol);
    
    if (tProtocol == NULL)
    {
        //
        // if a driver is so broken to send a bogus handle to deregister
        // better not bother to fail the call. they can mess up even more
        //
        *Status = NDIS_STATUS_SUCCESS;
        return;
    }
        
    do
    {
        //
        // If the protocol is already closing, return.
        //
        if (!ndisCloseRef(&Protocol->Ref))
        {
            DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                    ("<==NdisDeregisterProtocol\n"));
            *Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (Protocol->AssociatedMiniDriver)
        {
            Protocol->AssociatedMiniDriver->AssociatedProtocol = NULL;
            Protocol->AssociatedMiniDriver = NULL;
        }
        
        INITIALIZE_EVENT(&DeregEvent);
        Protocol->DeregEvent = &DeregEvent;
        
        ndisCloseAllBindingsOnProtocol(Protocol);

        ndisDereferenceProtocol(Protocol, FALSE);

        WAIT_FOR_PROTOCOL(Protocol, &DeregEvent);

        *Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);    
    
    ProtocolDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisDeregisterProtocol, Status %lx\n", *Status));
}


VOID
NdisOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL
    )
/*++

Routine Description:

    Opens a connection between a protocol and an adapter (Miniport).

Arguments:

    Status - Returns the final status.
    NdisBindingHandle - Returns a handle referring to this open.
    SelectedMediumIndex - Index in MediumArray of the medium type that
        the MAC wishes to be viewed as.
    MediumArray - Array of medium types which a protocol supports.
    MediumArraySize - Number of elements in MediumArray.
    NdisProtocolHandle - The handle returned by NdisRegisterProtocol.
    ProtocolBindingContext - A context for indications.
    AdapterName - The name of the adapter to open.
    OpenOptions - bit mask.
    AddressingInformation - Information passed to MacOpenAdapter.

Return Value:

    None.

Note:

    Called at PASSIVE level
    
--*/
{
    PNDIS_OPEN_BLOCK        NewOpenP = NULL;
    PNDIS_PROTOCOL_BLOCK    Protocol;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    PNDIS_POST_OPEN_PROCESSING  PostOpen = NULL;
    PNDIS_STRING            BindDeviceName, RootDeviceName;
    KIRQL                   OldIrql;
    BOOLEAN                 UsingEncapsulation = FALSE;
    BOOLEAN                 DerefProtocol = FALSE;
    BOOLEAN                 DeQueueFromGlobalList = FALSE;
    BOOLEAN                 fOpenNoBindRequest = FALSE;
    ULONG                   i, SizeOpen;

    UNREFERENCED_PARAMETER(OpenErrorStatus);
    UNREFERENCED_PARAMETER(OpenOptions);
    UNREFERENCED_PARAMETER(AddressingInformation);
    
    //
    // Allocate memory for the NDIS open block.
    //

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisOpenAdapter\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle)->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            (" is opening Adapter: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            AdapterName);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null ProtocolHandle\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: ProtocolHandle not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolBindingContext))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null Context\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(ProtocolBindingContext))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Context not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);

    }

    PnPReferencePackage();
    
    do
    {
        *NdisBindingHandle = NULL;
        ASSERT (NdisProtocolHandle != NULL);
        Protocol = (PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle;

        //
        // Increment the protocol's reference count.
        //
        if (!ndisReferenceProtocol(Protocol))
        {
            //
            // The protocol is closing.
            //
            *Status = NDIS_STATUS_CLOSING;
            break;
        }
        DerefProtocol = TRUE;
        
        if ((BindDeviceName = Protocol->BindDeviceName) != NULL)
        {
            //
            // This is a PnP transport. We know what we want.
            //
            RootDeviceName = Protocol->RootDeviceName;
            Miniport = Protocol->BindingAdapter;
            ASSERT(Miniport != NULL);
        }
        else
        {
            BOOLEAN fTester;

            //
            // This is a legacy transport and it has not come via a Bind upto the protocol.
            // Or it can be a IP arp module who wants to defeat this whole scheme.
            // Find the root of the filter chain. Sigh !!!
            //
            fTester = ((Protocol->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_TESTER) != 0);
            ndisFindRootDevice(AdapterName,
                               fTester,
                               &BindDeviceName,
                               &RootDeviceName,
                               &Miniport);

            //
            // we have to send the WMI BindUnbind notification when we complete the Open
            //
            fOpenNoBindRequest = TRUE;
                               
        }
        Protocol->BindDeviceName = NULL;

        if (Miniport == NULL)
        {
            *Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            break;
        }

        SizeOpen = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ?
                        sizeof(NDIS_OPEN_BLOCK) : (sizeof(NDIS_OPEN_BLOCK) - sizeof(struct _NDIS_OPEN_CO));

        NewOpenP = (PNDIS_OPEN_BLOCK)ALLOC_FROM_POOL(SizeOpen, NDIS_TAG_M_OPEN_BLK);
        if (NewOpenP == (PNDIS_OPEN_BLOCK)NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(NewOpenP, SizeOpen);

        //
        // queue the open on the global list
        //
        ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
        NewOpenP->NextGlobalOpen = ndisGlobalOpenList;
        ndisGlobalOpenList = NewOpenP;
        DeQueueFromGlobalList = TRUE;
        RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);


        //
        // Set the name in the Open to the name passed, not the name opened !!!
        //
        NewOpenP->BindDeviceName = BindDeviceName;
        NewOpenP->RootDeviceName = RootDeviceName;
        NewOpenP->MiniportHandle = Miniport;
        NewOpenP->ProtocolHandle = Protocol;
        NewOpenP->ProtocolBindingContext = ProtocolBindingContext;
        
        //
        // set this now just in case we end up calling the protocol for this binding
        // before returning from NdisOpenAdapter
        //
        *NdisBindingHandle = NewOpenP;

        //
        //
        //  Is this the ndiswan miniport wrapper?
        //
        if ((Miniport->MacOptions & NDISWAN_OPTIONS) == NDISWAN_OPTIONS)
        {
            //
            //  Yup.  We want the binding to think that this is an ndiswan link.
            //
            for (i = 0; i < MediumArraySize; i++)
            {
                if (MediumArray[i] == NdisMediumWan)
                {
                    break;
                }
            }
        }
        else
        {
            //
            // Select the medium to use
            //
            for (i = 0; i < MediumArraySize; i++)
            {
                if (MediumArray[i] == Miniport->MediaType)
                {
                    break;
                }
            }
        }

        if (i == MediumArraySize)
        {
            //
            // Check for ethernet encapsulation on Arcnet as
            // a possible combination.
            //
#if ARCNET
            if (Miniport->MediaType == NdisMediumArcnet878_2)
            {
                for (i = 0; i < MediumArraySize; i++)
                {
                    if (MediumArray[i] == NdisMedium802_3)
                    {
                        break;
                    }
                }

                if (i == MediumArraySize)
                {
                    *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                    break;
                }

                UsingEncapsulation = TRUE;
            }
            else
#endif
            {
                *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                break;
            }
        }

        *SelectedMediumIndex = i;


        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        //
        //  Lock the miniport in case it is not serialized
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            BLOCK_LOCK_MINIPORT_DPC_L(Miniport);
        }
        
        ndisMOpenAdapter(Status,
                         NewOpenP,
                         UsingEncapsulation);

        if (*Status == NDIS_STATUS_SUCCESS)
        {  
            if (fOpenNoBindRequest)
            {
                OPEN_SET_FLAG(NewOpenP, fMINIPORT_OPEN_NO_BIND_REQUEST);
            }
            //
            // If the media is disconnected, swap handlers
            //
            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
            {
                ndisMSwapOpenHandlers(Miniport,
                                      NDIS_STATUS_NO_CABLE,
                                      fMINIPORT_STATE_MEDIA_DISCONNECTED);
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
                (NewOpenP->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL))
            {

                PostOpen = (PNDIS_POST_OPEN_PROCESSING)ALLOC_FROM_POOL(sizeof(NDIS_POST_OPEN_PROCESSING), NDIS_TAG_WORK_ITEM);
                if (PostOpen != NULL)
                {
                    OPEN_INCREMENT_AF_NOTIFICATION(NewOpenP);
                    
                    PostOpen->Open = NewOpenP;
        
                    //
                    // Prepare a work item to send AF notifications.
                    // Don't queue it yet.
                    //
                    INITIALIZE_WORK_ITEM(&PostOpen->WorkItem,
                                         ndisMFinishQueuedPendingOpen,
                                         PostOpen);
                }
            }
        }

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            //
            // Unlock the miniport.
            //
            UNLOCK_MINIPORT_L(Miniport);
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // For SWENUM miniports, reference it so it won't go away
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
        {
            PBUS_INTERFACE_REFERENCE BusInterface;
    
            BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);
            
            ASSERT(BusInterface != NULL);

            if (BusInterface)
            {
                BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
            }
        }

        if (PostOpen != NULL)
        {
            //
            // Complete the Open before queueing AF notifications
            //
            (((PNDIS_PROTOCOL_BLOCK)NewOpenP->ProtocolHandle)->ProtocolCharacteristics.OpenAdapterCompleteHandler)(
                                NewOpenP->ProtocolBindingContext,
                                *Status,
                                *Status);


            if (fOpenNoBindRequest)
            {
                ndisNotifyWmiBindUnbind(Miniport, Protocol, TRUE);
                fOpenNoBindRequest = FALSE;
            }
            
            QUEUE_WORK_ITEM(&PostOpen->WorkItem, DelayedWorkQueue);

            *Status = NDIS_STATUS_PENDING;
        }
        
    } while (FALSE);

    if ((*Status != NDIS_STATUS_SUCCESS) && (*Status != NDIS_STATUS_PENDING))
    {
        if (DerefProtocol)
        {
            ndisDereferenceProtocol(Protocol, FALSE);
        }

        if (DeQueueFromGlobalList)
        {
            ndisRemoveOpenFromGlobalList(NewOpenP);
        }
    
        if (NewOpenP != NULL)
        {
            FREE_POOL(NewOpenP);
        }
        
        *NdisBindingHandle = NULL;
    }
    else if ((*Status == NDIS_STATUS_SUCCESS) && fOpenNoBindRequest && Miniport)
    {
        ndisNotifyWmiBindUnbind(Miniport, Protocol, TRUE);
    }
        

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisOpenAdapter\n"));
}

VOID
NdisCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    )
/*++

Routine Description:

    Closes a connection between a protocol and an adapter (MAC).

Arguments:

    Status - Returns the final status.
    NdisBindingHandle - The handle returned by NdisOpenAdapter.

Return Value:

    None.

Note:
    Called at PASSIVE level

--*/
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_OPEN_BLOCK        tOpen;
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;
    
    PnPReferencePackage();

    //
    // find the open on global open list
    //    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
    
    for (tOpen = ndisGlobalOpenList; tOpen != NULL; tOpen = tOpen->NextGlobalOpen)
    {
        if (tOpen == Open)
        {
            break;
        }
    }
    
    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);



#if DBG
    if (tOpen)
    {
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("==>NdisCloseAdapter\n"));
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("    Protocol: "));
        DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                &Open->ProtocolHandle->ProtocolCharacteristics.Name);
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                (" is closing Adapter: "));
        DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                &Open->MiniportHandle->MiniportName);
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("\n"));
    }
#endif

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(NdisBindingHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null BindingHandle\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(NdisBindingHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: BindingHandle not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
    }

    do
    {         
        if (tOpen == NULL)
        {
            *Status = NDIS_STATUS_SUCCESS;
            PnPDereferencePackage();
            break;
        }
        
        Miniport = Open->MiniportHandle;

        ASSERT(Miniport != NULL);

        //
        // For SWENUM miniports, dereference it
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
        {
            PBUS_INTERFACE_REFERENCE    BusInterface;
        
            BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

            ASSERT(BusInterface != NULL);
            
            if (BusInterface)
            {
                BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
            }
        }

        //
        // This returns TRUE if it finished synchronously.
        //
        if (ndisMKillOpen(Open))
        {
            *Status = NDIS_STATUS_SUCCESS;
            PnPDereferencePackage();
        }
        else
        {
            //
            // will complete later.  ndisMQueuedFinishClose routine will dereference
            // the PnP package. we need to have the pnp package referenced because 
            // a couple of routines called during completing the close, run at DPC
            // ex. ndisMFinishClose, ndisDeQueueOpenOnProtocol and ndisDeQueueOpenOnMiniport
            // and they are in pnp package
            //
            *Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCloseAdapter\n"));
}


//1 who uses this function?
VOID
NdisSetProtocolFilter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  RECEIVE_HANDLER         ReceiveHandler,
    IN  RECEIVE_PACKET_HANDLER  ReceivePacketHandler,
    IN  NDIS_MEDIUM             Medium,
    IN  UINT                    Offset,
    IN  UINT                    Size,
    IN  PUCHAR                  Pattern
    )
/*++

Routine Description:

    Sets a protocol filter.

Arguments:

    Status               Returns the final status.
    NdisProtocolHandle   The handle returned by NdisRegisterProtocol.
    ReceiveHandler       This will be invoked instead of the default receivehandler
                         when the pattern match happens.
    ReceivePacketHandler This will be invoked instead of the default receivepackethandler
                         when the pattern match happens.
    Size                 Size of pattern
    Pattern              This must match

Return Value:

    None.

Note:

--*/
{
    UNREFERENCED_PARAMETER(NdisBindingHandle);
    UNREFERENCED_PARAMETER(ReceiveHandler);
    UNREFERENCED_PARAMETER(ReceivePacketHandler);
    UNREFERENCED_PARAMETER(Medium);
    UNREFERENCED_PARAMETER(Offset);
    UNREFERENCED_PARAMETER(Size);
    UNREFERENCED_PARAMETER(Pattern);
    
    *Status = NDIS_STATUS_NOT_SUPPORTED;
}


VOID
NdisGetDriverHandle(
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisDriverHandle
    )
/*++

Routine Description:
    This routine will return the driver handle for the miniport identified by a binding

Arguments:
    NdisBindingHandle
    NdisDriverHandle: on return from this function, this will be set to the driver handle
    
Return Value:

    None.

Note:

--*/
{
    PNDIS_OPEN_BLOCK    OpenBlock = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisGetDriverHandle\n"));

    *NdisDriverHandle = OpenBlock->MiniportHandle->DriverHandle;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisGetDriverHandle\n"));
}


VOID
NdisReEnumerateProtocolBindings(
    IN  NDIS_HANDLE             NdisProtocolHandle
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    if (ndisReferenceProtocol((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle))
    {
        ndisCheckProtocolBindings((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle);
    }
    else
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("NdisReEnumerateProtocolBindings: Reference failed for %Z\n",
                &((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle)->ProtocolCharacteristics.Name));
    }
}


//1 add comments what this function does
NTSTATUS
FASTCALL
ndisReferenceProtocolByName(
    IN  PUNICODE_STRING         ProtocolName,
    IN OUT PNDIS_PROTOCOL_BLOCK *Protocol,
    IN  BOOLEAN                 fPartialMatch
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    KIRQL                   OldIrql;
    UNICODE_STRING          UpcaseProtocol;
    PNDIS_PROTOCOL_BLOCK    TmpProtocol;
    NTSTATUS                Status = STATUS_OBJECT_NAME_NOT_FOUND, NtStatus;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisReferenceProtocolByName\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ProtocolName);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    
    do
    {
        UpcaseProtocol.Length = ProtocolName->Length;
        UpcaseProtocol.MaximumLength = ProtocolName->Length + sizeof(WCHAR);
        UpcaseProtocol.Buffer = ALLOC_FROM_POOL(UpcaseProtocol.MaximumLength, NDIS_TAG_STRING);
    
        if (UpcaseProtocol.Buffer == NULL)
        {
            //
            // return null if we fail
            //
            *Protocol = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    
        NtStatus = RtlUpcaseUnicodeString(&UpcaseProtocol, ProtocolName, FALSE);
        ASSERT (NT_SUCCESS(NtStatus));
        
        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
    
        for (TmpProtocol = (*Protocol == NULL) ? ndisProtocolList : (*Protocol)->NextProtocol;
             TmpProtocol != NULL;
             TmpProtocol = TmpProtocol->NextProtocol)
        {
            if ((fPartialMatch && (TmpProtocol != *Protocol) &&
                 NDIS_PARTIAL_MATCH_UNICODE_STRING(&UpcaseProtocol, &TmpProtocol->ProtocolCharacteristics.Name)) ||
                (!fPartialMatch &&
                 NDIS_EQUAL_UNICODE_STRING(&UpcaseProtocol, &TmpProtocol->ProtocolCharacteristics.Name)))
            {
                if (ndisReferenceProtocol(TmpProtocol))
                {
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    TmpProtocol = NULL;
                }
                break;
            }
        }
    
        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
        *Protocol = TmpProtocol;

        FREE_POOL(UpcaseProtocol.Buffer);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisReferenceProtocolByName\n"));
            
    return Status;
}

VOID
FASTCALL
ndisDereferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK    Protocol,
    IN  BOOLEAN                 fProtocolListLockHeld
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    BOOLEAN rc;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceProtocol\n"));

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            (", RefCount: %ld\n", Protocol->Ref.ReferenceCount -1 ));
            
    rc = ndisDereferenceRef(&Protocol->Ref);
    
            
    if (rc)
    {
        KIRQL   OldIrql = PASSIVE_LEVEL;
        PNDIS_PROTOCOL_BLOCK *pProtocol;

        if (!fProtocolListLockHeld)
        {
            ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
        }

        for (pProtocol = &ndisProtocolList;
             *pProtocol != NULL;
             pProtocol = &(*pProtocol)->NextProtocol)
        {
            if (*pProtocol == Protocol)
            {
                *pProtocol = Protocol->NextProtocol;
                DEREF_NDIS_DRIVER_OBJECT();
                break;
            }
        }

        ASSERT (*pProtocol == Protocol->NextProtocol);

        ASSERT (Protocol->OpenQueue == NULL);

        if (!fProtocolListLockHeld)
        {
            RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
        }

        if (Protocol->DeregEvent != NULL)
            SET_EVENT(Protocol->DeregEvent);
        FREE_POOL(Protocol);

    }
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceProtocol\n"));
}


VOID
ndisCheckProtocolBindings(
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    KIRQL                OldIrql;
    PNDIS_M_DRIVER_BLOCK MiniBlock, NextMiniBlock;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisCheckProtocolBindings\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    //
    // Check again if reference is allowed i.e. if the protocol called NdisDeregisterProtocol
    // before this thread had a chance to run.
    //
    if (!ndisReferenceProtocol(Protocol))
    {
        ndisDereferenceProtocol(Protocol, FALSE);
        return;
    }

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    //
    // First walk the list of miniports
    //
    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = NextMiniBlock)
    {
        PNDIS_MINIPORT_BLOCK    Miniport, NM;

        NextMiniBlock = MiniBlock->NextDriver;

        if (ndisReferenceDriver(MiniBlock))
        {
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

            ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

            for (Miniport = MiniBlock->MiniportQueue;
                 Miniport != NULL;
                 Miniport = NM)
            {
                NM = Miniport->NextMiniport;

                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_ORPHANED) &&
                    MINIPORT_INCREMENT_REF(Miniport))
                {
                    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
                    ndisCheckAdapterBindings(Miniport, Protocol);
                    NM = Miniport->NextMiniport;
                    MINIPORT_DECREMENT_REF(Miniport);
                    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);
                }
            }

            RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

            NextMiniBlock = MiniBlock->NextDriver;
            ndisDereferenceDriver(MiniBlock, TRUE);
        }
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);


    //
    // Now inform this protocol that we are done for now
    //
    if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
    {
        NET_PNP_EVENT   NetPnpEvent;
        KEVENT          Event;
        NDIS_STATUS     Status;

        INITIALIZE_EVENT(&Event);
        NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
        NetPnpEvent.NetEvent = NetEventBindsComplete;

        //
        //  Initialize and save the local event with the PnP event.
        //
        PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent)->pEvent = &Event;
        
        WAIT_FOR_PROTO_MUTEX(Protocol);
        //
        //  Indicate the event to the protocol.
        //
        Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(NULL, &NetPnpEvent);

        if (NDIS_STATUS_PENDING == Status)
        {
            //
            //  Wait for completion.
            //
            WAIT_FOR_PROTOCOL(Protocol, &Event);
        }
        
        RELEASE_PROT_MUTEX(Protocol);
    }

    //
    // Dereference twice - one for reference by caller and one for reference at the beginning
    // of this routine.
    //
    ndisDereferenceProtocol(Protocol, FALSE);
    ndisDereferenceProtocol(Protocol, FALSE);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                ("<==ndisCheckProtocolBindings\n"));
}


VOID
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN   PNDIS_STRING           ProtocolSection
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    PNDIS_CONFIGURATION_HANDLE          HandleToReturn;
    PNDIS_WRAPPER_CONFIGURATION_HANDLE  ConfigHandle;
    UINT                                Size;
#define PQueryTable                     ConfigHandle->ParametersQueryTable

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisOpenProtocolConfiguration\n"));

    do
    {
        //
        // Allocate the space for configuration handle
        //
        Size = sizeof(NDIS_CONFIGURATION_HANDLE) +
                sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE) +
                ProtocolSection->MaximumLength + sizeof(WCHAR);




        HandleToReturn = ALLOC_FROM_POOL(Size, NDIS_TAG_PROTOCOL_CONFIGURATION);
        
        *Status = (HandleToReturn != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;
        
        if (*Status != NDIS_STATUS_SUCCESS)
        {
            *ConfigurationHandle = (NDIS_HANDLE)NULL;
            break;
        }

        ZeroMemory(HandleToReturn, Size);
        ConfigHandle = (PNDIS_WRAPPER_CONFIGURATION_HANDLE)((PUCHAR)HandleToReturn + sizeof(NDIS_CONFIGURATION_HANDLE));

        HandleToReturn->KeyQueryTable = ConfigHandle->ParametersQueryTable;
        HandleToReturn->ParameterList = NULL;

        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // 1.
        // Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;
        //
        // PQueryTable[0].Name and PQueryTable[0].EntryContext
        // are filled in inside ReadConfiguration, in preparation
        // for the callback.
        //
        // PQueryTable[0].Name = KeywordBuffer;
        // PQueryTable[0].EntryContext = ParameterValue;

        //
        // 2.
        // Stop
        //

        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;

        //
        // NOTE: Some fields in ParametersQueryTable[3] are used to store information for later retrieval.
        //
        PQueryTable[3].QueryRoutine = NULL;
        PQueryTable[3].Name = (PWSTR)((PUCHAR)HandleToReturn +
                                        sizeof(NDIS_CONFIGURATION_HANDLE) +
                                        sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        CopyMemory(PQueryTable[3].Name, ProtocolSection->Buffer, ProtocolSection->Length);

        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;

        *ConfigurationHandle = (NDIS_HANDLE)HandleToReturn;
        *Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisOpenProtocolConfiguration\n"));
}


BOOLEAN
FASTCALL
ndisQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK        OpenP,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:

    Attaches an open block to the list of opens for a protocol.

Arguments:

    OpenP - The open block to be queued.
    Protocol - The protocol block to queue it to.

    NOTE: can be called at raised IRQL.

Return Value:

    TRUE if the operation is successful.
    FALSE if the protocol is closing.

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisQueueOpenOnProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));

    do
    {
        //
        // we can not reference the package here because this routine can
        // be called at raised IRQL.
        // make sure the PNP package has been referenced already
        //
        ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

        //
        // Make sure the protocol is not closing.
        //

        if (Protocol->Ref.Closing)
        {
            rc = FALSE;
            break;
        }

        //
        // Attach this open at the head of the queue.
        //

        OpenP->ProtocolNextOpen = Protocol->OpenQueue;
        Protocol->OpenQueue = OpenP;

        rc = TRUE;
        
    } while (FALSE);

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisQueueOpenOnProtocol\n"));
            
    return rc;
}


VOID
FASTCALL
ndisDeQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK        OpenP,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:

    Detaches an open block from the list of opens for a protocol.

Arguments:

    OpenP - The open block to be dequeued.
    Protocol - The protocol block to dequeue it from.

    NOTE: can be called at raised IRQL

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisDeQueueOpenOnProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));
            
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Null Open Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Open Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (DbgIsNull(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Null Protocol Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Protocol Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
    }

    //
    // we can not reference the package here because this routine can
    // be claled at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    //
    // Find the open on the queue, and remove it.
    //

    if (OpenP == (PNDIS_OPEN_BLOCK)(Protocol->OpenQueue))
    {
        Protocol->OpenQueue = OpenP->ProtocolNextOpen;
    }
    else
    {
        PNDIS_OPEN_BLOCK PP = Protocol->OpenQueue;

        while ((PP != NULL) && (OpenP != (PNDIS_OPEN_BLOCK)(PP->ProtocolNextOpen)))
        {
            PP = PP->ProtocolNextOpen;
        }
        
        if (PP == NULL)
        {
#if TRACK_MOPEN_REFCOUNTS
            DbgPrint("Ndis:ndisDeQueueOpenOnProtocol Open %p is -not- on Protocol %p\n", OpenP, Protocol);
            DbgBreakPoint();
#endif
        }
        else
        {
            PP->ProtocolNextOpen = PP->ProtocolNextOpen->ProtocolNextOpen;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisDeQueueOpenOnProtocol\n"));
}


NDIS_STATUS
NdisWriteEventLogEntry(
    IN  PVOID                   LogHandle,
    IN  NDIS_STATUS             EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PVOID                   StringsList     OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data            OPTIONAL
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log on behalf of a NDIS Protocol.


Arguments:

    LogHandle           - Pointer to the driver object logging this event.

    EventCode           - Identifies the error message.

    UniqueEventValue    - Identifies this instance of a given error message.

    NumStrings          - Number of unicode strings in strings list.

    DataSize            - Number of bytes of data.

    Strings             - Array of pointers to unicode strings (PWCHAR).

    Data                - Binary dump data for this message, each piece being
                          aligned on word boundaries.

Return Value:

    NDIS_STATUS_SUCCESS             - The error was successfully logged.
    NDIS_STATUS_BUFFER_TOO_SHORT    - The error data was too large to be logged.
    NDIS_STATUS_RESOURCES           - Unable to allocate memory.

Notes:

    This code is paged and may not be called at raised IRQL.

--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    ULONG                   PaddedDataSize;
    ULONG                   PacketSize;
    ULONG                   TotalStringsSize = 0;
    USHORT                  i;
    PWCHAR                  *Strings;
    PWCHAR                  Tmp;
    NDIS_STATUS             Status;
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisWriteEventLogEntry\n"));

    do
    {
        Strings = (PWCHAR *)StringsList;

        //
        // Sum up the length of the strings
        //
        for (i = 0; i < NumStrings; i++)
        {
            PWCHAR currentString;
            ULONG   stringSize;

            stringSize = sizeof(UNICODE_NULL);
            currentString = Strings[i];

            while (*currentString++ != UNICODE_NULL)
            {
                stringSize += sizeof(WCHAR);
            }

            TotalStringsSize += stringSize;
        }

        if (DataSize % sizeof(ULONG))
        {
            PaddedDataSize = DataSize + (sizeof(ULONG) - (DataSize % sizeof(ULONG)));
        }
        else
        {
            PaddedDataSize = DataSize;
        }

        PacketSize = TotalStringsSize + PaddedDataSize;

        if (PacketSize > NDIS_MAX_EVENT_LOG_DATA_SIZE)
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;       // Too much error data
            break;
        }

        //
        // Now add in the size of the log packet, but subtract 4 from the data
        // since the packet struct contains a ULONG for data.
        //
        if (PacketSize > sizeof(ULONG))
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        }
        else
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET);
        }

        ASSERT(PacketSize <= ERROR_LOG_MAXIMUM_SIZE);

        ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry((PDRIVER_OBJECT)LogHandle,
                                                                       (UCHAR) PacketSize);

        if (ErrorLogEntry == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Fill in the necessary log packet fields.
        //
        ErrorLogEntry->UniqueErrorValue = UniqueEventValue;
        ErrorLogEntry->ErrorCode = EventCode;
        ErrorLogEntry->NumberOfStrings = NumStrings;
        ErrorLogEntry->StringOffset = (USHORT) (sizeof(IO_ERROR_LOG_PACKET) + PaddedDataSize - sizeof(ULONG));
        ErrorLogEntry->DumpDataSize = (USHORT) PaddedDataSize;

        //
        // Copy the Dump Data to the packet
        //
        if (DataSize > 0)
        {
            RtlMoveMemory((PVOID) ErrorLogEntry->DumpData,
                          Data,
                          DataSize);
        }

        //
        // Copy the strings to the packet.
        //
        Tmp =  (PWCHAR)((PUCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        for (i = 0; i < NumStrings; i++)
        {
            PWCHAR wchPtr = Strings[i];

            while( (*Tmp++ = *wchPtr++) != UNICODE_NULL)
                NOTHING;
        }

        IoWriteErrorLogEntry(ErrorLogEntry);
                
        Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisWriteEventLogEntry\n"));

    return Status;
}

#if DBG
BOOLEAN
ndisReferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    )
{
    BOOLEAN rc;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisReferenceProtocol\n"));
            
    rc = ndisReferenceRef(&Protocol->Ref);
                            
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            (", RefCount: %ld\n", Protocol->Ref.ReferenceCount));
            
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisReferenceProtocol\n"));
            
    return rc;
}
#endif




NDIS_STATUS
NdisQueryBindInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     BindingContext
    )
{
    PNDIS_BIND_CONTEXT      BindContext = (NDIS_HANDLE)BindingContext;
    PNDIS_MINIPORT_BLOCK    Miniport;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;
    PNDIS_STRING            pAdapterName;

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisQueryBindInstanceName\n"));

    Miniport = BindContext->Miniport;

    pAdapterName = Miniport->pAdapterInstanceName;

    //
    //  If we failed to create the adapter instance name then fail the call.
    //
    //1 this check may be unnecessary
    if (NULL != pAdapterName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = pAdapterName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;

            NtStatus = RtlAppendUnicodeStringToString(pAdapterInstanceName, pAdapterName);
            if (NT_SUCCESS(NtStatus))
            {   
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {   
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisQueryBindInstanceName: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
NdisQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisBindingHandle
    )
{
    PNDIS_OPEN_BLOCK        pOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport= (PNDIS_MINIPORT_BLOCK)pOpen->MiniportHandle;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;
    PNDIS_STRING            pAdapterName;

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisQueryAdapterInstanceName\n"));

    pAdapterName = Miniport->pAdapterInstanceName;

    //
    //  If we failed to create the adapter instance name then fail the call.
    //
    if (NULL != pAdapterName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = pAdapterName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;

            NtStatus = RtlAppendUnicodeStringToString(pAdapterInstanceName, pAdapterName);
            if (NT_SUCCESS(NtStatus))
            {   
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {   
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisQueryAdapterInstanceName: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
ndisCloseAllBindingsOnProtocol(
    PNDIS_PROTOCOL_BLOCK    Protocol
    )
{
    PNDIS_OPEN_BLOCK    Open, TmpOpen;
    KIRQL               OldIrql;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
        ("==>ndisCloseAllBindingsOnProtocol: Protocol %p\n", Protocol));

    PnPReferencePackage();
    
    //
    // loop through all opens on the protocol and find the first one that is
    // not already tagged as getting unbound
    //
    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    next:

    for (Open = Protocol->OpenQueue;
         Open != NULL; 
         Open = Open->ProtocolNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!OPEN_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_PROCESSING)))
        {
            OPEN_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
        
            if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING))
            {
                OPEN_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_DONT_FREE);
                RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                break;
            }
#if DBG
            else
            {
                DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                    ("ndisCloseAllBindingsOnProtocol: Open %p is already Closing, Flags %lx\n",
                    Open, Open->Flags));
            }
#endif
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }

    if (Open)
    {
        PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
        //
        // close the adapter
        //                        
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        Status = ndisUnbindProtocol(Open, Protocol, Miniport, FALSE);
        ASSERT(Status == NDIS_STATUS_SUCCESS);
        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
        goto next;
    }


    //
    // if we reached the end of the list but there are still some opens
    // that are not marked for closing (can happen if we skip an open only because of
    // processign flag being set) release the spinlocks, give whoever set the
    // processing flag time to release the open. then go back and try again
    // ultimately, all opens should either be marked for Unbinding or be gone
    // by themselves
    //

    for (TmpOpen = Protocol->OpenQueue;
         TmpOpen != NULL; 
         TmpOpen = TmpOpen->ProtocolNextOpen)
    {
        if (!MINIPORT_TEST_FLAG(TmpOpen, fMINIPORT_OPEN_UNBINDING))
            break;
    }

    if (TmpOpen != NULL)
    {
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        
        NDIS_INTERNAL_STALL(50);
        
        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

        goto next;
    }
    
    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
        ("<==ndisCloseAllBindingsOnProtocol: Protocol %p, Status %lx\n", Protocol, Status));
        
    return Status;
    
}

VOID
NdisSetPacketCancelId(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           CancelId
    )
{
    NDIS_SET_PACKET_CANCEL_ID(Packet, CancelId);
    return;
}


PVOID
NdisGetPacketCancelId(
    IN  PNDIS_PACKET    Packet
    )
{
    return NDIS_GET_PACKET_CANCEL_ID(Packet);
}

VOID
NdisCancelSendPackets(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PVOID           CancelId
    )
{
    PNDIS_OPEN_BLOCK    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    KIRQL               OldIrql;
    
    ASSERT(CancelId != NULL);
    //
    // call Miniport's CancelSendPackets handler
    //
    if (!OPEN_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DESERIALIZE))
    {
        //
        // for serialized miniports, check our send queue and cancel the packets
        //
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Open->MiniportHandle, &OldIrql);
        ndisMAbortPackets(Open->MiniportHandle, Open, CancelId);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Open->MiniportHandle, OldIrql);
    }
    else if (Open->CancelSendPacketsHandler != NULL)
    {
        Open->CancelSendPacketsHandler(Open->MiniportAdapterContext, CancelId);
    }

    return;
}

NDIS_STATUS
NdisQueryPendingIOCount(
    IN      PVOID       NdisBindingHandle,
    IN OUT  PULONG      IoCount
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    ULONG                   RefCount;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    
    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);

    if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
    {
        RefCount = 0;
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        RefCount = Open->References - Open->AfReferences -1;
        Status = NDIS_STATUS_SUCCESS;
    }

    *IoCount = RefCount;
    
    RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);

    return Status;
}


UCHAR
NdisGeneratePartialCancelId(
    VOID
    )
{
    return (UCHAR)(InterlockedIncrement(&ndisCancelId) & 0xFF);
}

#if 0
#if NDIS_RECV_SCALE

NDIS_STATUS
NdisSetReceiveScaleParameters(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_RECEIVE_SCALE_PARAMETERS  ReceiveScaleParameters
    )
/*++

Routine Description:
    Protocol drivers use NdisSetReceiveScaleParameters to set the parameters for 
    scaling receive indications on the bindings that support it.

Arguments:
    NdisBindingHandle: a pointer to NDIS_OPEN_BLOCK
    

    ReceiveScaleParameters: a pointer to scale parameters that specify the current
    hass function, the EthType and a hash to cpu mapping.
    
Return Value:
    NDIS_STATUS_SUCCES: if the call to NIC to set these parameters was successful.
    NDIS_STATUS_NOT_SUPPORTED: if the binding does not support Receive scaling
    NDIS_STATUS_RESOURCES: if the NIC can not support settign the parameters because
    it has ran out of the necessary reources.
    NDIS_STATUS_FAILURE: if the operation failed due to other reasons.
    
Note:
    Can be called at IRQL <= DISPATCH
--*/
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    

    do
    {
    
        //
        // check to see if NIC supports recv scaling
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SUPPORTS_RECEIVE_SCALE))
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        ASSERT(Miniport->DriverHandle->MiniportCharacteristics.SetReceiveScaleParametersHandler != NULL);

        if (Miniport->DriverHandle->MiniportCharacteristics.SetReceiveScaleParametersHandler)
        {
            //
            // call the miniport to set the new parameters
            //
            Status = Miniport->DriverHandle->MiniportCharacteristics.SetReceiveScaleParametersHandler(Miniport->MiniportAdapterContext,
                                                                                                      ReceiveScaleParameters);
        }
        else
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
        
    } while (FALSE);

    return Status;
    
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\protos.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    protos.h

Abstract:

    NDIS wrapper function prototypes

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PUNICODE_STRING                 RegistryPath
    );

#if NDIS_UNLOAD        
VOID
ndisUnload(
    IN  PDRIVER_OBJECT                  DriverObject
    );
#endif

NTSTATUS
ndisBuildDeviceAcl(
    OUT PACL                    *DeviceAcl,
    IN  BOOLEAN                 AddNetConfigOps,
    IN  BOOLEAN                 AddNetworkService
    );



NTSTATUS
ndisCreateSecurityDescriptor(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PSECURITY_DESCRIPTOR *  pSecurityDescriptor,
    IN  BOOLEAN                 AddNetConfigOps,
    IN  BOOLEAN                 AddNetworkService
    );

BOOLEAN
ndisCheckAccess (
    PIRP                    Irp,
    PIO_STACK_LOCATION      IrpSp,
    PNTSTATUS               Status,
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    );

VOID
ndisReadRegistry(
    VOID
    );
    
VOID
ndisWorkerThread(
    IN  PVOID                           Context
    );
    
NTSTATUS
ndisReadRegParameters(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisReadProcessorAffinityMask(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisAddMediaTypeToArray(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NDIS_STATUS
ndisCloseAllBindingsOnProtocol(
    PNDIS_PROTOCOL_BLOCK                Protocol
    );

BOOLEAN
ndisIMCheckDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK            MiniBlock,
    IN  PUNICODE_STRING                 DeviceInstance,
    OUT PNDIS_HANDLE                    DeviceContext   OPTIONAL
    );

NDIS_STATUS
ndisIMInitializeDeviceInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_HANDLE                     DeviceContext,
    IN  BOOLEAN                         fStartIrp
    );

NDIS_STATUS
ndisIMQueueDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK            MiniBlock,
    IN  PNDIS_STRING                    DeviceInstance,
    IN  NDIS_HANDLE                     DeviceContext
    );

NTSTATUS
FASTCALL
ndisPnPQueryRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPCancelRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );
    
NTSTATUS
FASTCALL
ndisPnPRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp     OPTIONAL
    );
    
VOID
ndisSetDeviceNames(
    IN  PNDIS_STRING                    ExportName,
    OUT PNDIS_STRING                    DeviceName,
    OUT PNDIS_STRING                    BaseName,
    IN  PUCHAR                          Buffer
    );

NTSTATUS
FASTCALL
ndisPnPQueryStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPCancelStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NDIS_STATUS
ndisTranslateResources(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  CM_RESOURCE_TYPE                ResourceType,
    IN  PHYSICAL_ADDRESS                Resource,
    OUT PPHYSICAL_ADDRESS               pTranslatedResource,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor OPTIONAL
    );

NTSTATUS
FASTCALL
ndisQueryBusInterface(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

ULONG
ndisGetSetBusConfigSpace(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG                           Offset,
    IN  PVOID                           Buffer,
    IN  ULONG                           Length,
    IN  ULONG                           WhichSpace,
    IN  BOOLEAN                         Read
    );

VOID
FASTCALL
ndisReinitializeMiniportBlock(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisCheckAdapterBindings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol    OPTIONAL
    );

NDIS_STATUS
FASTCALL
ndisPnPStartDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisQueryReferenceBusInterface(
    IN  PDEVICE_OBJECT                  PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE    *   BusInterface
    );

NTSTATUS
ndisPnPAddDevice(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject
    );

NTSTATUS
ndisAddDevice(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PUNICODE_STRING                 pExportName,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  ULONG                           Characteristics
    );
    
NTSTATUS
ndisWritePnPCapabilities(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG                           PnPCapabilities
    );
    
NDIS_STATUS
ndisRegisterMiniportDriver(
    IN  NDIS_HANDLE                     NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS  MiniportCharacteristics,
    IN  UINT                            CharacteristicsLength,
    OUT PNDIS_HANDLE                    DriverHandle
    );

NTSTATUS
ndisDispatchRequest(
    IN  PDEVICE_OBJECT                  pDeviceObject,
    IN  PIRP                            pIrp
    );

NTSTATUS
FASTCALL
ndisHandlePnPRequest(
    IN  PIRP                            pIrp
    );

NTSTATUS
FASTCALL
ndisHandleLegacyTransport(
    IN  PUNICODE_STRING                 pDevice
    );

NTSTATUS
FASTCALL
ndisHandleProtocolBindNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
FASTCALL
ndisHandleProtocolUnbindNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
ndisHandleProtocolReconfigNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol,
    IN  PVOID                           ReConfigBuffer,
    IN  UINT                            ReConfigBufferSize,
    IN  UINT                            Operation
    );

NTSTATUS
FASTCALL
ndisHandleProtocolUnloadNotification(
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
FASTCALL
ndisHandleOrphanDevice(
    IN  PUNICODE_STRING                 pDevice
    );

NTSTATUS
FASTCALL
ndisHandleUModePnPOp(
    IN  PNDIS_PNP_OPERATION             PnPOp
    );

NTSTATUS
FASTCALL
ndisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF                 EnumIntf,
    IN  UINT                            BufferLength,
    IN  PUINT                           OutputLength    
    );

VOID
ndisFindRootDevice(
    IN  PNDIS_STRING                    DeviceName,
    IN  BOOLEAN                         fTester,
    OUT PNDIS_STRING *                  pBindDeviceName,
    OUT PNDIS_STRING *                  pRootDeviceName,
    OUT PNDIS_MINIPORT_BLOCK *          pMiniport
    );

PNDIS_MINIPORT_BLOCK
ndisFindMiniportOnGlobalList(
    IN  PNDIS_STRING                    DeviceName
    );

NTSTATUS
ndisUnbindProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  BOOLEAN                         Notify
    );

VOID
ndisReferenceMiniportByName(
    IN  PUNICODE_STRING                 DeviceName,
    OUT PNDIS_MINIPORT_BLOCK    *       pMiniport
    );

PNDIS_OPEN_BLOCK
FASTCALL
ndisMapOpenByName(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  BOOLEAN                         fUnbinding
    );

VOID
NdisMCancelTimer(
    IN  PNDIS_MINIPORT_TIMER            Timer,
    OUT PBOOLEAN                        TimerCancelled
    );

//
// general reference/dereference functions
//

BOOLEAN
FASTCALL
ndisReferenceRef(
    IN  PREFERENCE                      RefP
    );

BOOLEAN
FASTCALL
ndisDereferenceRef(
    IN  PREFERENCE                      RefP
    );


VOID
FASTCALL
ndisInitializeRef(
    IN  PREFERENCE                      RefP
    );


BOOLEAN
FASTCALL
ndisCloseRef(
    IN  PREFERENCE                      RefP
    );


BOOLEAN
FASTCALL
ndisReferenceULongRef(
    IN  PULONG_REFERENCE                RefP
    );

VOID
FASTCALL
ndisReferenceULongRefNoCheck(
    IN  PULONG_REFERENCE                RefP
    );

BOOLEAN
FASTCALL
ndisDereferenceULongRef(
    IN  PULONG_REFERENCE                RefP
    );


VOID
FASTCALL
ndisInitializeULongRef(
    IN  PULONG_REFERENCE                RefP
    );


BOOLEAN
FASTCALL
ndisCloseULongRef(
    IN  PULONG_REFERENCE                RefP
    );


#if DBG
BOOLEAN
FASTCALL
ndisReferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );
#else
#define ndisReferenceProtocol(ProtP)    ndisReferenceRef(&(ProtP)->Ref)
#endif

NTSTATUS
FASTCALL
ndisReferenceProtocolByName(
    IN  PUNICODE_STRING                 ProtocolName,
    IN OUT  PNDIS_PROTOCOL_BLOCK *      Protocol,
    IN  BOOLEAN                         fPartialMatch
    );


VOID
FASTCALL
ndisDereferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  BOOLEAN                         fProtocolListLockHeld
    );


VOID
FASTCALL
ndisDeQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

BOOLEAN
ndisCheckPortUsage(
    IN  ULONG                           PortNumber,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PULONG                          pTranslatedPort,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor
    );
    
VOID
ndisImmediateReadWritePort(
    IN  NDIS_HANDLE                     WrapperConfigurationContext,
    IN  ULONG                           Port,
    IN  OUT PVOID                       Data,
    IN  ULONG                           Size,
    IN  BOOLEAN                         Read
    );

BOOLEAN
ndisCheckMemoryUsage(
    IN  ULONG                           Address,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PULONG                          pTranslatedAddress,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor
    );
    
VOID
ndisImmediateReadWriteSharedMemory(
    IN  NDIS_HANDLE                     WrapperConfigurationContext,
    IN  ULONG                           SharedMemoryAddress,
    OUT PUCHAR                          Buffer,
    IN  ULONG                           Length,
    IN  BOOLEAN                         Read
    );
    
NTSTATUS
ndisStartMapping(
    IN   INTERFACE_TYPE                 InterfaceType,
    IN   ULONG                          BusNumber,
    IN   ULONG                          InitialAddress,
    IN   ULONG                          Length,
    IN   ULONG                          AddressSpace,
    OUT PVOID *                         InitialMapping,
    OUT PBOOLEAN                        Mapped
    );

NTSTATUS
ndisEndMapping(
    IN  PVOID                           InitialMapping,
    IN  ULONG                           Length,
    IN  BOOLEAN                         Mapped
    );

NDIS_STATUS
ndisInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK            pMiniBlock,
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUNICODE_STRING                 RegServiceName,
    IN  NDIS_HANDLE                     DeviceContext   OPTIONAL
    );

BOOLEAN
ndisWmiGuidIsAdapterSpecific(
    IN  LPGUID                          guid
    );

NTSTATUS
ndisCreateAdapterInstanceName(
    OUT PUNICODE_STRING *               pAdapterInstanceName,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject
    );

NDIS_STATUS
ndisInitializeConfiguration(
    OUT PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PUNICODE_STRING                 pExportName
    );

NTSTATUS
ndisReadBindPaths(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PRTL_QUERY_REGISTRY_TABLE       LQueryTable
    );

NDIS_STATUS
ndisMInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK            pMiniDriver,
    IN  PNDIS_WRAPPER_CONFIGURATION_HANDLE pConfigurationHandle,
    IN  PUNICODE_STRING                 pExportName,
    IN  NDIS_HANDLE                     DeviceContext   OPTIONAL
    );

VOID
FASTCALL
ndisInitializeBinding(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

BOOLEAN
FASTCALL
ndisProtocolAlreadyBound(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
FASTCALL
ndisMShutdownMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NDIS_STATUS
FASTCALL
ndisCloseMiniportBindings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisCheckProtocolBindings(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );


VOID
ndisMQueuedAllocateSharedHandler(
    IN  PASYNC_WORKITEM                 pWorkItem
    );

VOID
ndisMQueuedFreeSharedHandler(
    IN  PASYNC_WORKITEM                 pWorkItem
    );

/*++
BOOLEAN
ndisReferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK            DriverP
    );
--*/

#define ndisReferenceDriver(DriverP)    ndisReferenceRef(&(DriverP)->Ref)

VOID
FASTCALL
ndisDereferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK            DriverP,
    IN  BOOLEAN                         fGlobalLockHeld
    );

BOOLEAN
FASTCALL
ndisQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_M_DRIVER_BLOCK            Driver
    );

VOID
FASTCALL
ndisDeQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_M_DRIVER_BLOCK            Driver
    );


#if DBG
BOOLEAN 
FASTCALL
ndisReferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisReferenceMiniportNoCheck(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );
#else
#define ndisReferenceMiniport(Miniport) ndisReferenceULongRef(&(Miniport)->Ref)
#define ndisReferenceMiniportNoCheck(Miniport) ndisReferenceULongRefNoCheck(&(Miniport)->Ref)
#endif

#ifdef TRACK_MINIPORT_REFCOUNTS
BOOLEAN
ndisReferenceMiniportAndLog(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UINT                            Line,
    IN  UINT                            Module
    );

VOID
ndisReferenceMiniportAndLogNoCheck(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module
    );
    
BOOLEAN
ndisReferenceMiniportAndLogCreate(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UINT                            Line,
    IN  UINT                            Module,
    IN  PIRP                            Irp
    );
    
#endif

VOID
FASTCALL
ndisDereferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisDeQueueOpenOnMiniport(
    IN  PNDIS_OPEN_BLOCK                MiniportOpen,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisInitializePackage(
    IN  PPKG_REF                        pPkg
    );

VOID
FASTCALL
ndisReferencePackage(
    IN  PPKG_REF                        pPkg
    );

VOID
FASTCALL
ndisDereferencePackage(
    IN  PPKG_REF                        pPkg
    );

#define ProtocolReferencePackage()      ndisReferencePackage(&ndisPkgs[NDSP_PKG])
#define MiniportReferencePackage()      ndisReferencePackage(&ndisPkgs[NDSM_PKG])
#define PnPReferencePackage()           ndisReferencePackage(&ndisPkgs[NPNP_PKG])
#define CoReferencePackage()            ndisReferencePackage(&ndisPkgs[NDCO_PKG])
#define EthReferencePackage()           ndisReferencePackage(&ndisPkgs[NDSE_PKG])
#define FddiReferencePackage()          ndisReferencePackage(&ndisPkgs[NDSF_PKG])
#define TrReferencePackage()            ndisReferencePackage(&ndisPkgs[NDST_PKG])
#define ArcReferencePackage()           ndisReferencePackage(&ndisPkgs[NDSA_PKG])

#define ProtocolDereferencePackage()    ndisDereferencePackage(&ndisPkgs[NDSP_PKG])
#define MiniportDereferencePackage()    ndisDereferencePackage(&ndisPkgs[NDSM_PKG])
#define PnPDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NPNP_PKG])
#define CoDereferencePackage()          ndisDereferencePackage(&ndisPkgs[NDCO_PKG])
#define EthDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NDSE_PKG])
#define FddiDereferencePackage()        ndisDereferencePackage(&ndisPkgs[NDSF_PKG])
#define TrDereferencePackage()          ndisDereferencePackage(&ndisPkgs[NDST_PKG])
#define ArcDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NDSA_PKG])


//
// IRP handlers established on behalf of NDIS devices by the wrapper.
//

NTSTATUS
ndisCreateIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisDeviceControlIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisCloseIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisDummyIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

VOID
ndisCancelLogIrp(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NDIS_STATUS
FASTCALL
ndisMGetLogData(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PIRP                            Irp
    );

BOOLEAN
FASTCALL
ndisQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

VOID
NdisCancelTimer(
    IN  PNDIS_TIMER                     Timer,
    OUT PBOOLEAN                        TimerCancelled
    );

//
// Dma operations
//

extern
IO_ALLOCATION_ACTION
ndisDmaExecutionRoutine(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           MapRegisterBase,
    IN  PVOID                           Context
    );


//
// Map Registers
//
extern
IO_ALLOCATION_ACTION
ndisAllocationExecutionRoutine(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           MapRegisterBase,
    IN  PVOID                           Context
    );

#undef NdisMSendResourcesAvailable
VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE                     MiniportAdapterHandle
    );

#undef NdisMResetComplete
VOID
NdisMResetComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

NTSTATUS
ndisSaveParameters(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisReadParameter(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );


VOID
FASTCALL
ndisMCommonHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisMHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMUnload(
    IN  PDRIVER_OBJECT                  DriverObject
    );

NDIS_STATUS
FASTCALL
ndisQueryDeviceOid(
    IN  PNDIS_USER_OPEN_CONTEXT         OpenContext,
    IN  PNDIS_REQUEST                   QueryRequest,
    IN  NDIS_OID                        Oid,
    IN  PVOID                           Buffer,
    IN  UINT                            BufferLength
    );

BOOLEAN
FASTCALL
ndisValidOid(
    IN  PNDIS_USER_OPEN_CONTEXT         OpenContext,
    IN  NDIS_OID                        Oid
    );

NDIS_STATUS
FASTCALL
ndisSplitStatisticsOids(
    IN  PNDIS_USER_OPEN_CONTEXT         OpenContext,
    IN  PNDIS_OID                       OidList,
    IN  ULONG                           NumOids
    );

VOID
FASTCALL
ndisMFinishClose(
    IN  PNDIS_OPEN_BLOCK                Open
    );

VOID
ndisMQueuedFinishClose(
    IN  PNDIS_OPEN_BLOCK                Open
    );

BOOLEAN
FASTCALL
ndisMKillOpen(
    IN  PNDIS_OPEN_BLOCK                Open
    );

NDIS_STATUS
FASTCALL
ndisQueryOidList(
    IN  PNDIS_USER_OPEN_CONTEXT         OpenContext
    );

VOID
ndisBugcheckHandler(
    IN  PNDIS_WRAPPER_CONTEXT           WrapperContext,
    IN  ULONG                           Size
    );

VOID
ndisMFinishQueuedPendingOpen(
    IN  PNDIS_POST_OPEN_PROCESSING      PostOpen
    );

VOID
NdisAllocatePacketPool(
    OUT PNDIS_STATUS                    Status,
    OUT PNDIS_HANDLE                    PoolHandle,
    IN  UINT                            NumberOfDescriptors,
    IN  UINT                            ProtocolReservedLength
    );
    
#undef NdisIMInitializeDeviceInstance
NDIS_STATUS
NdisIMInitializeDeviceInstance(
    IN  NDIS_HANDLE                     DriverHandle,
    IN  PNDIS_STRING                    DriverInstance
    );

#undef NdisSend
VOID
NdisSend(
    OUT PNDIS_STATUS                    Status,
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

#undef NdisSendPackets
VOID
NdisSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );


VOID
NdisMStartBufferPhysicalMapping(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_BUFFER                    Buffer,
    IN  ULONG                           PhysicalMapRegister,
    IN  BOOLEAN                         WriteToDevice,
    OUT PNDIS_PHYSICAL_ADDRESS_UNIT     PhysicalAddressArray,
    OUT PUINT                           ArraySize
    );

VOID
NdisMCompleteBufferPhysicalMapping(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_BUFFER                    Buffer,
    IN  ULONG                           PhysicalMapRegister
    );

VOID
FASTCALL
ndisMAllocSGList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

VOID
FASTCALL
ndisMFreeSGList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

VOID
ndisMProcessSGList(
    IN  PDEVICE_OBJECT                  pDO,
    IN  PIRP                            pIrp,
    IN  PSCATTER_GATHER_LIST            pSGL,
    IN  PVOID                           Context
    );

VOID
ndisWorkItemHandler(
    IN  PNDIS_WORK_ITEM                 WorkItem
    );

    
//
//  MISC
//
#undef NDIS_BUFFER_TO_SPAN_PAGES
ULONG
NDIS_BUFFER_TO_SPAN_PAGES(
    IN  PNDIS_BUFFER                    Buffer
    );

#undef NdisGetFirstBufferFromPacket
VOID
NdisGetFirstBufferFromPacket(
    IN  PNDIS_PACKET                    Packet,
    OUT PNDIS_BUFFER *                  FirstBuffer,
    OUT PVOID *                         FirstBufferVA,
    OUT PUINT                           FirstBufferLength,
    OUT PUINT                           TotalBufferLength
    );

#undef NdisGetFirstBufferFromPacketSafe
VOID
NdisGetFirstBufferFromPacketSafe(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength,
    IN  MM_PAGE_PRIORITY        Priority
    );


#undef NdisBufferLength
ULONG
NdisBufferLength(
    IN  PNDIS_BUFFER                    Buffer
    );

#undef NdisBufferVirtualAddress
PVOID
NdisBufferVirtualAddress(
    IN  PNDIS_BUFFER                    Buffer
    );

#undef NdisGetBufferPhysicalArraySize
VOID
NdisGetBufferPhysicalArraySize(
    IN  PNDIS_BUFFER                    Buffer,
    OUT PUINT                           ArraySize
    );

#undef NdisAllocateSpinLock
VOID
NdisAllocateSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisFreeSpinLock
VOID
NdisFreeSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisAcquireSpinLock
VOID
NdisAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisReleaseSpinLock
VOID
NdisReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisDprAcquireSpinLock
VOID
NdisDprAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisDprReleaseSpinLock
VOID
NdisDprReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK                 SpinLock
    );

#undef NdisGetCurrentSystemTime
VOID
NdisGetCurrentSystemTime(
    IN  PLARGE_INTEGER                  pCurrentTime
    );

#undef NdisQueryBufferSafe
VOID
NdisQueryBufferSafe(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length,
    IN  MM_PAGE_PRIORITY        Priority
    );

#undef NdisQueryBufferOffset
VOID
NdisQueryBufferOffset(
    IN  PNDIS_BUFFER                    Buffer,
    OUT PUINT                           Offset,
    OUT PUINT                           Length
    );

#undef NdisAdjustBufferLength
VOID
NdisAdjustBufferLength(
    IN  PNDIS_BUFFER                    Buffer,
    IN  UINT                            Length
    );

#undef NdisUpdateSharedMemory
VOID
NdisUpdateSharedMemory(
    IN  NDIS_HANDLE                     NdisAdapterHandle,
    IN  ULONG                           Length,
    IN  PVOID                           VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS           PhysicalAddress
    );

#undef NdisFreePacketPool
VOID
NdisFreePacketPool(
    IN  NDIS_HANDLE                     PoolHandle
    );

#undef NdisFreePacket
VOID
NdisFreePacket(
    IN  PNDIS_PACKET                    Packet
    );

#undef NdisDprFreePacketNonInterlocked
VOID
NdisDprFreePacketNonInterlocked(
    IN  PNDIS_PACKET                    Packet
    );

#undef NdisDprFreePacket
VOID
NdisDprFreePacket(
    IN  PNDIS_PACKET                    Packet
    );

VOID
FASTCALL
ndisFreePacket(
    IN  PNDIS_PACKET                    Packet,
    IN  PNDIS_PKT_POOL                  Pool
    );

#undef NdisAnsiStringToUnicodeString
NDIS_STATUS
NdisAnsiStringToUnicodeString(
    IN  OUT PUNICODE_STRING             DestinationString,
    IN      PANSI_STRING                SourceString
    );

#undef NdisUnicodeStringToAnsiString
NDIS_STATUS
NdisUnicodeStringToAnsiString(
    IN  OUT PANSI_STRING                DestinationString,
    IN      PUNICODE_STRING             SourceString
    );


#undef NdisCompareAnsiString
BOOLEAN
NdisCompareAnsiString(
    IN  PANSI_STRING                    String1,
    IN  PANSI_STRING                    String2,
    IN  BOOLEAN                         CaseInSensitive
    );

#undef NdisCompareUnicodeString
BOOLEAN
NdisCompareUnicodeString(
    IN  PUNICODE_STRING                 String1,
    IN  PUNICODE_STRING                 String2,
    IN  BOOLEAN                         CaseInSensitive
    );

#undef NdisUpcaseUnicodeString
NDIS_STATUS
NdisUpcaseUnicodeString(
    OUT PUNICODE_STRING                 DestinationString,
    IN  PUNICODE_STRING                 SourceString
    );

#undef NdisReset
VOID
NdisReset(
    OUT PNDIS_STATUS                    Status,
    IN  NDIS_HANDLE                     NdisBindingHandle
    );

#undef NdisRequest
VOID
NdisRequest(
    OUT PNDIS_STATUS                    Status,
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );

#undef NdisTransferData
VOID
NdisTransferData(
    OUT PNDIS_STATUS                    Status,
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  UINT                            ByteOffset,
    IN  UINT                            BytesToTransfer,
    IN OUT  PNDIS_PACKET                Packet,
    OUT PUINT                           BytesTransferred
    );

BOOLEAN
ndisVerifierInitialization(
    VOID
    );
    
BOOLEAN
ndisVerifierInjectResourceFailure (
    IN  BOOLEAN                         fDelayFailure
    );

EXPORT
NDIS_STATUS
ndisVerifierAllocateMemory(
    OUT PVOID *                         VirtualAddress,
    IN  UINT                            Length,
    IN  UINT                            MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS           HighestAcceptableAddress
    );

EXPORT
NDIS_STATUS
ndisVerifierAllocateMemoryWithTag(
    OUT PVOID *                         VirtualAddress,
    IN  UINT                            Length,
    IN  ULONG                           Tag
    );
    
EXPORT
VOID
ndisVerifierAllocatePacketPool(
    OUT PNDIS_STATUS                    Status,
    OUT PNDIS_HANDLE                    PoolHandle,
    IN  UINT                            NumberOfDescriptors,
    IN  UINT                            ProtocolReservedLength
    );
    
EXPORT
VOID
ndisVerifierAllocatePacketPoolEx(
    OUT PNDIS_STATUS                    Status,
    OUT PNDIS_HANDLE                    PoolHandle,
    IN  UINT                            NumberOfDescriptors,
    IN  UINT                            NumberOfOverflowDescriptors,
    IN  UINT                            ProtocolReservedLength
    );

EXPORT
VOID
ndisVerifierFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    );

NDIS_STATUS
ndisVerifierQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
    );

VOID
ndisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle,
    IN  BOOLEAN                 Verify
    );


#if TRACK_MEMORY

extern
PVOID
AllocateM(
    IN  UINT                            Size,
    IN  ULONG                           ModLine,
    IN  ULONG                           Tag
    );

extern
VOID
FreeM(
    IN  PVOID                           MemPtr
    );

#endif

VOID
ndisMNotifyMachineName(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_STRING            MachineName OPTIONAL
    );

VOID
ndisPowerStateCallback(
    IN  PVOID   CallBackContext,
    IN  PVOID   Argument1,
    IN  PVOID   Argument2
    );
    
VOID
ndisNotifyMiniports(
    IN  PNDIS_MINIPORT_BLOCK    Miniport OPTIONAL,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

PNDIS_MINIPORT_BLOCK
ndisReferenceNextUnprocessedMiniport(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock
    );

VOID
ndisUnprocessAllMiniports(
    IN  PNDIS_M_DRIVER_BLOCK        MiniBlock
    );

#undef NdisSetPacketCancelId
VOID
NdisSetPacketCancelId(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           CancelId
    );


#undef NdisGetPacketCancelId
PVOID
NdisGetPacketCancelId(
    IN  PNDIS_PACKET    Packet
    );

VOID
ndisSetupWmiNode(
    IN      PNDIS_MINIPORT_BLOCK        Miniport,
    IN      PUNICODE_STRING             InstanceName,
    IN      ULONG                       DataBlockSize,
    IN      PVOID                       pGuid,
    IN OUT  PWNODE_SINGLE_INSTANCE *    pwnode
    );

BOOLEAN
FASTCALL
ndisMStartSendPacketsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

NDIS_STATUS
ndisMSendSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    );

BOOLEAN
FASTCALL
ndisMStartSendsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

VOID
ndisMSendPacketsSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

VOID
ndisMSendCompleteSG(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    );

VOID
FASTCALL
ndisMAllocSGListS(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    );

VOID
ndisMProcessSGListS(
    IN  PDEVICE_OBJECT          pDO,
    IN  PIRP                    pIrp,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    );

VOID
ndisDereferenceDmaAdapter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

VOID
ndisDereferenceAfNotification(
    IN  PNDIS_OPEN_BLOCK        Open
    );

VOID
ndisMSetIndicatePacketHandler(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

VOID
ndisVerifierFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    );

VOID
ndisUpdateCheckForLoopbackFlag(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

BOOLEAN
ndisReferenceOpenByHandle(
    IN      PNDIS_OPEN_BLOCK    Open,
    IN      BOOLEAN             fRef
    );

BOOLEAN
ndisRemoveOpenFromGlobalList(
    IN  PNDIS_OPEN_BLOCK        Open
    );

NDIS_STATUS
ndisMRegisterInterruptCommon(
    OUT PNDIS_MINIPORT_INTERRUPT    Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    );

VOID
ndisMDeregisterInterruptCommon(
    IN  PNDIS_MINIPORT_INTERRUPT    MiniportInterrupt
    );

NTSTATUS 
CreateDeviceDriverSecurityDescriptor(
    IN  PVOID           DeviceOrDriverObject,
    IN  BOOLEAN         AddNetConfigOps,
    IN  PACL            AclToAdd OPTIONAL
    );

NTSTATUS
ndisAddUsersAce(
    IN  PACL Dacl,
    OUT PACL *NewAcl
    );

NTSTATUS
ndisCreateGenericSD(
    PACL            Acl,
    PCHAR           AccessSecurityDescriptor
    );

PACL
ndisCreateAcl(
    BOOLEAN     Admins,
    BOOLEAN     LocalSystem,
    BOOLEAN     LocalService,
    BOOLEAN     NetworkService,
    BOOLEAN     NetConfigOps,
    BOOLEAN     Users,
    ACCESS_MASK AccessMask
    );

NDIS_STATUS
ndisQueryStatisticsOids(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_OID               OidArray,
    IN  UINT                    OidCount,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   BufferLength,
    IN  PULONG                  pBytesWritten,
    IN  BOOLEAN                 AlignOutput
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\requestm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    requestm.c

Abstract:

    NDIS miniport request routines.

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_REQUESTM

NDIS_STATUS
ndisMRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    KIRQL                   OldIrql;
    NDIS_STATUS             Status;
    BOOLEAN                 rc;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMRequest\n"));

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        SET_INTERNAL_REQUEST(NdisRequest, Open, 0);
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Context = NULL;
    
        //
        // Get protocol-options
        //
        if ((NdisRequest->RequestType == NdisRequestSetInformation) &&
            (NdisRequest->DATA.SET_INFORMATION.Oid == OID_GEN_PROTOCOL_OPTIONS) &&
            (NdisRequest->DATA.SET_INFORMATION.InformationBuffer != NULL))
        {
            PULONG  ProtocolOptions;
    
            ProtocolOptions = (PULONG)(NdisRequest->DATA.SET_INFORMATION.InformationBuffer);
            if (*ProtocolOptions & NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT)
            {
                *ProtocolOptions &= ~NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT;
                Open->Flags |= fMINIPORT_OPEN_NO_PROT_RSVD;
            }
            if ((*ProtocolOptions & NDIS_PROT_OPTION_NO_LOOPBACK) &&
                (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK))
            {
                *ProtocolOptions &= ~fMINIPORT_OPEN_NO_LOOPBACK;
                Open->Flags |= fMINIPORT_OPEN_NO_LOOPBACK;
            }
        }
    
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMRequest: Queueing request 0x%x\n", NdisRequest));

        //
        //  Place the new request on the pending queue.
        //
        rc = ndisMQueueRequest(Miniport, NdisRequest);
        
        if (!rc)
        {
            Status = NDIS_STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            BOOLEAN LocalLock;

            LOCK_MINIPORT(Miniport, LocalLock);
            NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    
            if (LocalLock)
            {
                NDISM_PROCESS_DEFERRED(Miniport);
            }
            UNLOCK_MINIPORT(Miniport, LocalLock);
        }
    
        Status = NDIS_STATUS_PENDING;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMRequest: NDIS_STATUS_PENDING\n"));

    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}


NDIS_STATUS
ndisMRequestX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK                    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK                Miniport;
    PNDIS_DEFERRED_REQUEST_WORKITEM     DeferredRequestWorkItem = NULL;
    NDIS_STATUS                         Status;
    PVOID                               Caller, CallersCaller;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    do
    {
        DeferredRequestWorkItem = ALLOC_FROM_POOL(sizeof(NDIS_DEFERRED_REQUEST_WORKITEM), NDIS_TAG_WORK_ITEM);
        if (DeferredRequestWorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(DeferredRequestWorkItem, sizeof(NDIS_DEFERRED_REQUEST_WORKITEM));
        
        if (ndisReferenceOpenByHandle(Open, TRUE))
        {
            Miniport = Open->MiniportHandle;
        }
        else
        {
#if DBG
            DbgPrint("ndisMRequestX: Receiving requests %p after closing Open %p.\n", NdisRequest, Open);
            DbgBreakPoint();
#endif
            FREE_POOL(DeferredRequestWorkItem);
            Status = NDIS_STATUS_CLOSING;
            break;
        }
        
        //
        // Queue this to a work-item
        //
        DeferredRequestWorkItem->Caller = Caller;
        DeferredRequestWorkItem->CallersCaller = CallersCaller;
        DeferredRequestWorkItem->Request = NdisRequest;
        DeferredRequestWorkItem->Open = Open;
        DeferredRequestWorkItem->Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
        DeferredRequestWorkItem->InformationBuffer = NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
        SET_INTERNAL_REQUEST(NdisRequest, Open, 0);
        DeferredRequestWorkItem->WorkItem.Context = (PVOID)DeferredRequestWorkItem;
        DeferredRequestWorkItem->WorkItem.Routine = (NDIS_PROC)ndisMRundownRequests;
        INITIALIZE_WORK_ITEM((WORK_QUEUE_ITEM *)&DeferredRequestWorkItem->WorkItem.WrapperReserved[0],
                             (PWORKER_THREAD_ROUTINE)ndisMRundownRequests, 
                             DeferredRequestWorkItem);
        QUEUE_WORK_ITEM((WORK_QUEUE_ITEM *)&DeferredRequestWorkItem->WorkItem.WrapperReserved[0], CriticalWorkQueue);
        Status = NDIS_STATUS_PENDING;
    } while (FALSE);
    
    return(Status);
}


VOID
ndisMRundownRequests(
    IN  PNDIS_WORK_ITEM         pWorkItem
    )
/*++

Routine Description:

    Call ndisMDoRequests deferred

Arguments:

Return Value:

--*/
{
    PNDIS_DEFERRED_REQUEST_WORKITEM     DeferredRequestWorkItem = (PNDIS_DEFERRED_REQUEST_WORKITEM)pWorkItem->Context;
    PNDIS_REQUEST           Request;
    PNDIS_OPEN_BLOCK        Open = DeferredRequestWorkItem->Open;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STATUS             Status;
    UINT                    OpenRef;
    KIRQL                   OldIrql;

    if(ndisReferenceOpenByHandle(Open, FALSE))
    {
        Miniport = Open->MiniportHandle;
    }
    else
    {
        //
        // where did the open go?
        //
        DbgPrint("Ndis: ndisMRundownRequests Open is gone. DeferredRequestWorkItem %p\n", DeferredRequestWorkItem );
        //1 check this again.
        // DbgBreakPoint();
        return;
    }

    Request = DeferredRequestWorkItem->Request;
    
    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE));

    Status = ndisMRequest(Open, Request);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags |= REQST_COMPLETED;

        (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                   Request,
                                   Status);

    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    //
    // we have an extra ref because we called both ndisReferenceOpenByHandle
    // and SET_INTERNAL_REQUEST in ndisRequestX
    //
    M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);
    ASSERT(OpenRef > 0);
    ndisMDereferenceOpen(Open);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    FREE_POOL(DeferredRequestWorkItem);
}

LONG
ndisMDoMiniportOp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  BOOLEAN                 Query,
    IN  ULONG                   Oid,
    IN  PVOID                   Buf,
    IN  LONG                    BufSize,
    IN  LONG                    ErrorCodesToReturn,
    IN  BOOLEAN                 fMandatory
    )
/*++

Routine Description:

    Query the miniport with the information supplied. If this is not an optional operation
    then the miniport will be halted if a failure occurs and an error code returned.

    THIS IS THE ONLY PLACE CERTAIN QUERIES HAPPEN DOWN TO THE MINIPORT. THESE ARE THEN
    CACHED AND SUBSEQUENT QUERIES ARE TRAPPED AND RESPONDED FROM HERE.

Arguments:

    Miniport            -   Pointer to the Miniport.
    Query               -   TRUE if this is a query. FALSE if this is a set operation.
    Oid                 -   NDIS OID to send to the miniport.
    Buf                 -   Buffer for the operation.
    BufSize             -   Size of the buffer.
    ErrorCodesToReturn  -   If a system call failed the request then return the given error code.
                            If the miniport failed it then return error code plus 1.

Return Value:

    None.

--*/
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_SUCCESS;
    LONG                    ErrorCode = 0;
    BOOLEAN                 Set = !Query;
    NDIS_REQUEST            Request;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_REQUEST_RESERVED  ReqRsvd;


    ZeroMemory(&Request, sizeof(NDIS_REQUEST));
    
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(&Request);
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(&Request);

    if (Query)
    {
        Request.RequestType = NdisRequestQueryInformation;
    }
    else
    {
        Request.RequestType = NdisRequestSetInformation;
    }

    Request.DATA.QUERY_INFORMATION.Oid = Oid;
    Request.DATA.QUERY_INFORMATION.InformationBuffer = Buf;
    Request.DATA.QUERY_INFORMATION.InformationBufferLength = BufSize;
    
    if (fMandatory)
    {
        ReqRsvd->Flags = REQST_MANDATORY;
    }

    NdisStatus = ndisQuerySetMiniport(Miniport,
                                      NULL,
                                      Set,
                                      &Request,
                                      0);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {

        //
        //  Return the error code back to the caller.
        //
        ErrorCode = (NdisStatus == -1) ? ErrorCodesToReturn : ErrorCodesToReturn + 1;
    }

    return(ErrorCode);
}


VOID
FASTCALL
ndisMDoRequests(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Submits a request to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    TRUE if we need to place the work item back on the queue to process later.
    FALSE if we are done with the work item.

Comments:
    Called at DPC level with Miniport's SpinLock held.

--*/
{
    NDIS_STATUS     Status;
    PNDIS_REQUEST   NdisRequest;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMDoRequests\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    //  Do we have a request in progress?
    //
    while (((NdisRequest = Miniport->PendingRequest) != NULL) &&
            !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        UINT                    MulticastAddresses;
        ULONG                   PacketFilter = 0;
        BOOLEAN                 DoMove;
        PVOID                   MoveSource;
        UINT                    MoveBytes;
        ULONG                   GenericULong;

        //
        //  Set defaults.
        //
        DoMove = TRUE;
        Status = NDIS_STATUS_SUCCESS;

        //
        // Process first request
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMDoRequests: Processing Request 0x%x, Oid 0x%x\n", NdisRequest, NdisRequest->DATA.QUERY_INFORMATION.Oid));

        //
        //  Clear the timeout flag.
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);
        Miniport->CFHangXTicks = 0;

        //
        // Make it known that we are processing a request
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST);

        //
        // Submit to mini-port
        //
        switch (NdisRequest->RequestType)
        {
          case NdisRequestQueryInformation:
            Status = ndisMQueryInformation(Miniport, NdisRequest);
            break;

          case NdisRequestSetInformation:
            Status = ndisMSetInformation(Miniport, NdisRequest);
            break;

          case NdisRequestQueryStatistics:
            MoveSource = &GenericULong;
            MoveBytes = sizeof(GenericULong);

            //
            // We intercept some calls
            //
            switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
            {
              case OID_GEN_CURRENT_PACKET_FILTER:

                switch (Miniport->MediaType)
                {
                    case NdisMedium802_3:
                        PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                        break;
    
                    case NdisMedium802_5:
                        PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
                        break;
    
                    case NdisMediumFddi:
                        PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
                        break;
    
#if ARCNET
                    case NdisMediumArcnet878_2:
                        PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
                        PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                        break;
#endif
                }
    
                GenericULong = (ULONG)(PacketFilter);
                break;

              case OID_GEN_MEDIA_IN_USE:
              case OID_GEN_MEDIA_SUPPORTED:
                MoveSource = &Miniport->MediaType;
                MoveBytes = sizeof(NDIS_MEDIUM);
                break;

              case OID_GEN_CURRENT_LOOKAHEAD:
                GenericULong = (ULONG)(Miniport->CurrentLookahead);
                break;

              case OID_GEN_MAXIMUM_LOOKAHEAD:
                GenericULong = (ULONG)(Miniport->MaximumLookahead);
                break;

              case OID_PNP_WAKE_UP_PATTERN_LIST:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if (Status == NDIS_STATUS_NOT_SUPPORTED)
                {
                    //1 do we still need to do this in NDIS?
                    //
                    // get it from ndis
                    //
                    Status = ndisMQueryWakeUpPatternList(Miniport, NdisRequest);
                }
                break;
                
              case OID_PNP_CAPABILITIES:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if ((Status == NDIS_STATUS_SUCCESS) &&
                    !(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER)))
                {
                    ((PNDIS_PNP_CAPABILITIES)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer)->Flags = Miniport->PMCapabilities.Flags;
                }
                break;

              case OID_GEN_MAC_OPTIONS:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    *((PULONG)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer) |= (Miniport->MacOptions & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE);
                }
                break;

              case OID_802_3_MULTICAST_LIST:
              case OID_802_3_MAXIMUM_LIST_SIZE:
                if (Miniport->MediaType != NdisMedium802_3)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }
                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {
                  case OID_802_3_MULTICAST_LIST:

                    EthQueryGlobalFilterAddresses(&Status,
                                                  Miniport->EthDB,
                                                  NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                  &MulticastAddresses,
                                                  NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);

                    //
                    //  Did we fail?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = ETH_LENGTH_OF_ADDRESS * ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(Miniport->EthDB);
                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = MulticastAddresses * ETH_LENGTH_OF_ADDRESS;
                    }
                    DoMove = FALSE;

                    break;

                  case OID_802_3_MAXIMUM_LIST_SIZE:
                    GenericULong = Miniport->MaximumLongAddresses;
                    break;
                }
                break;
                
              case OID_802_5_CURRENT_FUNCTIONAL:
              case OID_802_5_CURRENT_GROUP:
                if (Miniport->MediaType != NdisMedium802_5)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }
                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {
                  case OID_802_5_CURRENT_FUNCTIONAL:
                    GenericULong = BYTE_SWAP_ULONG(TR_QUERY_FILTER_ADDRESSES(Miniport->TrDB));
                    break;

                  case OID_802_5_CURRENT_GROUP:
                    GenericULong = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
                    break;
                }
                break;

              case OID_FDDI_LONG_MULTICAST_LIST:
              case OID_FDDI_LONG_MAX_LIST_SIZE:
              case OID_FDDI_SHORT_MULTICAST_LIST:
              case OID_FDDI_SHORT_MAX_LIST_SIZE:
                if (Miniport->MediaType != NdisMediumFddi)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }

                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {



                  case OID_FDDI_LONG_MULTICAST_LIST:
                    FddiQueryGlobalFilterLongAddresses(&Status,
                                                       Miniport->FddiDB,
                                                       NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                       &MulticastAddresses,
                                                       NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
        
                    //
                    //  Did we fail?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                            FDDI_LENGTH_OF_LONG_ADDRESS * FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(Miniport->FddiDB);
                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = FDDI_LENGTH_OF_LONG_ADDRESS * MulticastAddresses;
                    }
                    DoMove = FALSE;
                    break;

                  case OID_FDDI_LONG_MAX_LIST_SIZE:
                    GenericULong = Miniport->MaximumLongAddresses;
                    break;

                  case OID_FDDI_SHORT_MULTICAST_LIST:
                    FddiQueryGlobalFilterShortAddresses(&Status,
                                                        Miniport->FddiDB,
                                                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                        &MulticastAddresses,
                                                        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
        
                    //
                    //  Did we fail ?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                            FDDI_LENGTH_OF_LONG_ADDRESS * FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(Miniport->FddiDB);

                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = FDDI_LENGTH_OF_SHORT_ADDRESS * MulticastAddresses;
                    }
                    DoMove = FALSE;
                    break;

                  case OID_FDDI_SHORT_MAX_LIST_SIZE:
                    GenericULong = Miniport->MaximumShortAddresses;
                    break;
                }
                break;

              default:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);
                break;
            }

            if (DoMove)
            {
                //
                // This was an intercepted request. Finish it off
                //

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    if (MoveBytes >
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength)
                    {
                        //
                        // Not enough room in InformationBuffer. Punt
                        //
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = MoveBytes;

                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        //
                        // Copy result into InformationBuffer
                        //

                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = MoveBytes;

                        if ((MoveBytes > 0) &&
                            (MoveSource != NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer))
                        {
                            MoveMemory(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                       MoveSource,
                                       MoveBytes);
                        }
                    }
                }
                else
                {
                    NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = MoveBytes;
                }
            }
            break;
        }

        //
        //  Did the request pend?  If so then there is nothing more to do.
        //
        if ((Status == NDIS_STATUS_PENDING) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
        {
            //
            // Still outstanding
            //
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                    ("Request pending, exit do requests\n"));
            break;
        }

        //
        // Complete request
        //
        if (Status != NDIS_STATUS_PENDING)
        {
            switch (NdisRequest->RequestType)
            {
              case NdisRequestQueryStatistics:
              case NdisRequestQueryInformation:
                ndisMSyncQueryInformationComplete(Miniport, Status, NULL);
                break;

              case NdisRequestSetInformation:
                ndisMSyncSetInformationComplete(Miniport, Status, NULL);
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMDoRequests\n"));
}

NDIS_STATUS
ndisMSetInformation(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

Note: Called at DPC with Miniport's lock held.

--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_NOT_SUPPORTED;
    POID_SETINFO_HANDLER    pOidSH;
    BOOLEAN                 Intercept = FALSE;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetInformaiton\n"));

    if (PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open != NULL)
    {
        //
        //  Process the binding's request.
        //
        for (pOidSH = ndisMSetInfoHandlers; pOidSH->Oid != 0; pOidSH++)
        {
            if (pOidSH->Oid == Request->DATA.SET_INFORMATION.Oid)
            {
                Intercept = TRUE;
                Status = (*pOidSH->SetInfoHandler)(Miniport, Request);
                break;
            }
        }
    }

    if (!Intercept)
    {
        //
        //  Either we are not intercepting this request or it is an internal request
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetInformaiton: Request not intercepted by NDIS\n"));
    
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetInformaiton: 0x%x\n", Status));

    return(Status);
}

VOID
NdisMSetInformationComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a set information operation.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the operation

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>NdisMSetInformationComplete\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    //  If we don't have a request to complete assume it was
    //  aborted via the reset handler.
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("NdisMSetInformationComplete: No request to process\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisMSetInformationComplete\n"));

        return;
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("Enter set information complete\n"));

    //
    //  Process the actual set information complete.
    //
    ndisMSyncSetInformationComplete(Miniport, Status, NULL);

    //
    //  Are there more requests pending?
    //
    if (Miniport->PendingRequest != NULL)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisMSetInformationComplete\n"));
}

VOID
FASTCALL
ndisMSyncSetInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  PNDIS_REQUEST           AbortedRequest
    )
/*++

Routine Description:

    This routine will process a set information complete.  This is only
    called from the wrapper.  The difference is that this routine will not
    call ndisMProcessDeferred() after processing the completion of the set.

Arguments:
    Miniport
    Status

Return Value:
    None

Comments:
    Called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST           Request;
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    PNDIS_OPEN_BLOCK        Open;
    BOOLEAN                 FreeRequest;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSyncSetInformationComplete\n"));

    //
    //  Clear the timeout flag and the request_in_process flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, (fMINIPORT_REQUEST_TIMEOUT | fMINIPORT_PROCESSING_REQUEST));
    Miniport->CFHangXTicks = 0;


    if (AbortedRequest)
    {
        Request = AbortedRequest;
        ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    }
    else
    {
        //
        //  Get a pointer to the request that we are completeing.
        //  And clear out the request in-progress pointer.
        //
        Request = Miniport->PendingRequest;
        ASSERT(Request != NULL);

        if (Request == NULL)
        {
            return;
        }
        ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
        Miniport->PendingRequest = ReqRsvd->Next;
    }
    
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    
    //
    // save the request for debugging purpose
    //
    Miniport->LastRequest = Request;
    FreeRequest =  ((ReqRsvd->Flags & REQST_FREE_REQUEST) == REQST_FREE_REQUEST);
    ReqRsvd->Flags |= REQST_COMPLETED;

    Open = ReqRsvd->Open;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSyncSetInformationComplete: Request 0x%x, Oid 0x%x\n",
            Request, Request->DATA.SET_INFORMATION.Oid));

    NDIS_WARN(((Status == NDIS_STATUS_SUCCESS) && (Request->DATA.SET_INFORMATION.BytesRead > Request->DATA.SET_INFORMATION.InformationBufferLength)),
              Miniport, NDIS_GFLAG_WARN_LEVEL_0,
              ("ndisMSyncSetInformationComplete: Miniport %p, OID %lx,  BytesRead > InformationBufferLength. "
               " BytesRead %lx, InformationBufferLength %lx\n", 
               Miniport, Request->DATA.SET_INFORMATION.Oid, 
               Request->DATA.SET_INFORMATION.BytesRead,
               Request->DATA.SET_INFORMATION.InformationBufferLength));

    RESTORE_REQUEST_BUF(Miniport, Request);

    //
    // Free the multicast buffer, if any
    //
    switch (Request->DATA.SET_INFORMATION.Oid)
    {
      case OID_802_3_MULTICAST_LIST:
      case OID_FDDI_LONG_MULTICAST_LIST:
      case OID_FDDI_SHORT_MULTICAST_LIST:
        if (Miniport->SetMCastBuffer != NULL)
        {
            FREE_POOL(Miniport->SetMCastBuffer);
            Miniport->SetMCastBuffer = NULL;
        }
        break;

    }
    
    //
    //  Get a pointer to the open that made the request.
    //  for internal requests this will be NULL.
    //
    //  Do we need to indicate this request to the protocol?
    //  We do if it's not an internal request.
    //
    if (Open != NULL)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Open 0x%x\n", Open));

        //
        //  Do any necessary post processing for the request.
        //
        ndisMRequestSetInformationPost(Miniport, Request, Status);

        if (ReqRsvd->Flags & REQST_LAST_RESTORE)
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
        }

        //
        // Don't complete internal requests
        //
        if (!FreeRequest)
        {
            //
            // Indicate to Protocol;
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                           Request,
                                           Status);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Dereference the open.
        //
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
                ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

        ndisMDereferenceOpen(Open);

        if (FreeRequest)
        {
            //
            //  Free the request.
            //
            ndisMFreeInternalRequest(Request);
        }
    }
    else
    {
        PNDIS_COREQ_RESERVED    CoReqRsvd;

        //
        //  The CoReqRsvd portion of the request contains ndis only information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);
        CoReqRsvd->Status = Status;

        //
        //  Internal requests are only used for restoring filter settings
        //  in the set information path.  this means that no post processing
        //  needs to be done.
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Completeing internal request\n"));


        //
        //  Is there a reset in progress?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
        {
            //
            // If this is the last request then complete the reset
            // but only if the request is to restore filter
            // otherwise, this is a request that is getting aborted
            // or completed in the context of a reset
            //
            if(ReqRsvd->Flags & REQST_LAST_RESTORE)
            {
                ASSERT(NDIS_STATUS_SUCCESS == Status);
                //
                // Now clear out the reset in progress stuff.
                //
                ndisMResetCompleteStage2(Miniport);
            }
        }
        else
        {
            //
            //  What if one of these requests fails???? We should probably halt
            //  the driver sine this is a fatal error as far as the bindings
            //  are concerned.
            //
            if (ReqRsvd->Flags & REQST_MANDATORY)
            {
                ASSERT(NDIS_STATUS_SUCCESS == Status);
            }

        }

        if ((ReqRsvd->Flags & REQST_LAST_RESTORE) == REQST_LAST_RESTORE)
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
        }

        if ((ReqRsvd->Flags & REQST_SIGNAL_EVENT) == REQST_SIGNAL_EVENT)
        {
            SET_EVENT(&CoReqRsvd->Event);
        }
        else if (FreeRequest)
        {
            //
            //  Free the request.
            //
            ndisMFreeInternalRequest(Request);
        }
    }

    //
    // if we are removing the miniport, we have to signal an event
    // when all requests are completed
    //
    if (Miniport->PendingRequest == NULL)
    {
        if (Miniport->AllRequestsCompletedEvent)
            SET_EVENT(Miniport->AllRequestsCompletedEvent);
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSyncSetInformationComplete\n"));
}


VOID
ndisMRequestSetInformationPost(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request,
    IN  NDIS_STATUS             Status
)
/*++

Routine Description:

    This routine will do any necessary post processing for ndis requests
    of the set information type.

Arguments:

    Miniport    - Pointer to the miniport block.

    Request     - Pointer to the request to process.

Return Value:

    None.

--*/
{
    PNDIS_REQUEST_RESERVED      ReqRsvd;
    PNDIS_OPEN_BLOCK            Open;
    PNDIS_PACKET_PATTERN_ENTRY  pPacketPattern;
    PNDIS_COREQ_RESERVED        CoReqRsvd;
    ULONG                       RequestPatternOffset, EntryPatternOffset;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMRequestSetInformationPost\n"));

    //
    //  Get the reserved information for the request.
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Open = ReqRsvd->Open;

    switch (Request->DATA.SET_INFORMATION.Oid)
    {
      case OID_GEN_CURRENT_PACKET_FILTER:
        if ((NDIS_STATUS_SUCCESS != Status) && (Open != NULL))
        {
            //
            //  The request was completed with something besides
            //  NDIS_STATUS_SUCCESS (and of course NDIS_STATUS_PENDING).
            //  Return the packete filter to the original state.
            //
            switch (Miniport->MediaType)
            {
              case NdisMedium802_3:
                if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->EthDB, Open->FilterHandle);
                }
                break;

              case NdisMedium802_5:
                if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->TrDB, Open->FilterHandle);
                }
                break;

              case NdisMediumFddi:
                if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->FddiDB, Open->FilterHandle);
                }
                break;

#if ARCNET
              case NdisMediumArcnet878_2:

                if (!OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    if (MINIPORT_TEST_FLAG(ReqRsvd->Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                    {
                        XUndoFilterAdjust(Miniport->EthDB, ReqRsvd->Open->FilterHandle);
                    }
                    else
                    {
                        arcUndoFilterAdjust(Miniport->ArcDB, ReqRsvd->Open->FilterHandle);
                    }
                }
                break;
#endif
            }
        }
        
        //
        // check to see how many opens have non zero packet filters
        //
        if (Miniport->MediaType == NdisMedium802_3)
        {
            PETH_BINDING_INFO   OpenFilter;
            PETH_BINDING_INFO   ActiveOpenFilter = NULL;
            ULONG               NumActiveOpens = 0;
            
            for (OpenFilter = Miniport->EthDB->OpenList;
                 (OpenFilter != NULL) && (NumActiveOpens <= 1);
                 OpenFilter = OpenFilter->NextOpen)
            {
                if (OpenFilter->PacketFilters != 0)
                {
                    NumActiveOpens++;
                    ActiveOpenFilter = OpenFilter;
                }
            }
            
            if (NumActiveOpens == 1)
            {
                Miniport->EthDB->SingleActiveOpen = ActiveOpenFilter;
            }
            else
            {
                Miniport->EthDB->SingleActiveOpen = NULL;
            }
            
            ndisUpdateCheckForLoopbackFlag(Miniport);
        }
        break;

      case OID_GEN_CURRENT_LOOKAHEAD:
        //
        //  If we succeeded then update the binding information.
        //
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Miniport->CurrentLookahead = *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);
            Open->CurrentLookahead = (USHORT)Miniport->CurrentLookahead;

            Request->DATA.SET_INFORMATION.BytesRead = 4;
        }
        break;

      case OID_802_3_MULTICAST_LIST:

        if (Miniport->MediaType == NdisMedium802_3)
        {
            ethCompleteChangeFilterAddresses(Miniport->EthDB, Status, NULL, FALSE);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_802_5_CURRENT_FUNCTIONAL:
        if ((Miniport->MediaType == NdisMedium802_5) &&
            (Status != NDIS_STATUS_SUCCESS) &&
            (Open != NULL) &&
            !OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            trUndoChangeFunctionalAddress(Miniport->TrDB, Open->FilterHandle);
        }
        break;

      case OID_802_5_CURRENT_GROUP:
        if ((Miniport->MediaType == NdisMedium802_5) &&
            (Status != NDIS_STATUS_SUCCESS) &&
            (Open != NULL) &&
            !OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            trUndoChangeGroupAddress(Miniport->TrDB, Open->FilterHandle);
        }

        break;

      case OID_FDDI_LONG_MULTICAST_LIST:
        if (Miniport->MediaType == NdisMediumFddi)
        {
            fddiCompleteChangeFilterLongAddresses(Miniport->FddiDB, Status);
        }
        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_FDDI_SHORT_MULTICAST_LIST:
        //1 dead code
        if (Miniport->MediaType == NdisMediumFddi)
        {
            fddiCompleteChangeFilterShortAddresses(Miniport->FddiDB, Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_PNP_ADD_WAKE_UP_PATTERN:
        //
        //  Get the packet pattern that was completed.
        //
        pPacketPattern = ReqRsvd->Context;
        if (NDIS_STATUS_SUCCESS == Status)
        {
            //
            //  Add the packet pattern to the miniport's list.
            //

            PushEntryList(&Miniport->PatternList, &pPacketPattern->Link);
        }
        else
        {
            //
            //  Free up the packet pattern that NDIS allocated and fail
            //  the request.
            //
            if (pPacketPattern != NULL)
            {
                FREE_POOL(pPacketPattern);
            }
        }
        break;


      case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        //
        //  If the miniport succeeded in removing the pattern then
        //  we need to find it and remove it from our list.
        //  
        if (NDIS_STATUS_SUCCESS == Status)
        {
            PSINGLE_LIST_ENTRY          Link;
            PSINGLE_LIST_ENTRY          PrevLink;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
            PNDIS_PM_PACKET_PATTERN     pNdisPacketPattern;

            //
            //  Walk the current list of packet patterns.
            //
            for (PrevLink = NULL, Link = Miniport->PatternList.Next;
                 Link != NULL;
                 PrevLink = Link, Link = Link->Next)
            {
                //
                //  Get a pointer to the pattern entry that the Link represents.
                //
                pPatternEntry = CONTAINING_RECORD(Link, NDIS_PACKET_PATTERN_ENTRY, Link);
    
                //
                //  Do the opens match?
                //
                if (pPatternEntry->Open == ReqRsvd->Open)
                {
                    //
                    //  Get a pointer to the packet pattern that the transport
                    //  wants to remove.
                    //
                    pNdisPacketPattern = Request->DATA.SET_INFORMATION.InformationBuffer;

    
                    //
                    //  Make sure that the size of the passed in pattern is the
                    //  same size as the pattern we are going to compare it with.
                    //
                    if ((pNdisPacketPattern->PatternSize != pPatternEntry->Pattern.PatternSize) ||
                        (pNdisPacketPattern->MaskSize != pPatternEntry->Pattern.MaskSize))
                    {
                        //
                        //  Since the sizes don't match the compare below will fail.
                        //
                        continue;
                    }
    
                    //
                    //  Now we need to match the actual pattern that was
                    //  passed to us.
                    //
                    //
                    // we compare the pattern structure + mask minus the pattern offset field
                    // and then we compare the pattern
                    //
                    RequestPatternOffset = pNdisPacketPattern->PatternOffset;
                    EntryPatternOffset = pPatternEntry->Pattern.PatternOffset;
                    pNdisPacketPattern->PatternOffset = 0;
                    pPatternEntry->Pattern.PatternOffset = 0;
                    
                    if (NdisEqualMemory(
                            (PUCHAR)pNdisPacketPattern,
                            (PUCHAR)&pPatternEntry->Pattern,
                            sizeof(NDIS_PM_PACKET_PATTERN) + pPatternEntry->Pattern.MaskSize) &&
                        NdisEqualMemory((PUCHAR)pNdisPacketPattern+ RequestPatternOffset,
                                         (PUCHAR)&pPatternEntry->Pattern + EntryPatternOffset,
                                         pPatternEntry->Pattern.PatternSize))
                    {
                        //
                        //  Remove the packet pattern.
                        //
                        if (NULL == PrevLink)
                        {
                            Miniport->PatternList.Next = Link->Next;
                        }
                        else
                        {
                            PrevLink->Next = Link->Next;
                        }

                        //
                        //  Free the memory taken by the pattern.
                        //
                        FREE_POOL(pPatternEntry);
                        pNdisPacketPattern->PatternOffset = RequestPatternOffset;
                        break;
                    }
                    
                    pNdisPacketPattern->PatternOffset = RequestPatternOffset;
                    pPatternEntry->Pattern.PatternOffset = EntryPatternOffset;
                }
            }
        }
        break;

      case OID_PNP_QUERY_POWER:
        //
        //  The CoReqRsvd portion of the request contains ndis only
        //  information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);

        //
        //  Save the status that the miniport returned.
        //
        CoReqRsvd->Status = Status;
        break;

    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMRequestSetInformationPost\n"));
}


NDIS_STATUS
FASTCALL
ndisMSetProtocolOptions(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             Status;

    UNREFERENCED_PARAMETER(Miniport);
    
    VERIFY_SET_PARAMETERS(Request, sizeof(ULONG), Status);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        *(UNALIGNED ULONG *)(&PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->ProtocolOptions) =
                        *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);
    
        Request->DATA.SET_INFORMATION.BytesRead = sizeof(ULONG);
        Status = NDIS_STATUS_SUCCESS;
    }

    return(Status);
}


NDIS_STATUS
FASTCALL
ndisMSetPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will process two types of set packet filter requests.
    The first one is for when a reset happens.  We simply take the
    packet filter setting that is in the request and send it to the adapter.
    The second is when a protocol sets the packet filter, for this we need
    to update the filter library and then send it down to the adapter.

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    NDIS_STATUS             Status;
    ULONG                   PacketFilter;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetPacketFilter\n"));

    //
    //  Verify the information buffer length that was sent in.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(PacketFilter), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetPacketFilter: 0x%x\n", Status));
        return(Status);
    }

    //
    //  Now call the filter package to set the
    //  packet filter.
    //
    PacketFilter = *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);

    //
    //  Get a pointer to the reserved information of the request.
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Open = ReqRsvd->Open;

    ASSERT(Open != NULL);
    if (Open == NULL)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetPacketFilter: 0x%x\n", Status));
        return(Status);
    }
    
    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the filter settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:
            Status = XFilterAdjust(Miniport->EthDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
            break;

          case NdisMedium802_5:
            Status = XFilterAdjust(Miniport->TrDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
            break;

          case NdisMediumFddi:
            Status = XFilterAdjust(Miniport->FddiDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
            break;

#if ARCNET
          case NdisMediumArcnet878_2:
            if (OPEN_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
            {
                Status = XFilterAdjust(Miniport->EthDB,
                                       Open->FilterHandle,
                                       PacketFilter,
                                       TRUE);
            }
            else
            {
                Status = ArcFilterAdjust(Miniport->ArcDB,
                                         Open->FilterHandle,
                                         Request,
                                         PacketFilter,
                                         TRUE);
            }
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
            PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
    
            if (MINIPORT_TEST_FLAG(Miniport,
                                   fMINIPORT_ARCNET_BROADCAST_SET) ||
                                   (PacketFilter & NDIS_PACKET_TYPE_MULTICAST))
            {
                PacketFilter &= ~NDIS_PACKET_TYPE_MULTICAST;
                PacketFilter |= NDIS_PACKET_TYPE_BROADCAST;
            }
            break;
#endif

        default:
            break;
        }
    }


    //
    // If this was a request to turn p-mode/l-only on/off then mark things appropriately
    //
    if (Open != NULL)
    {
        PULONG  Filter = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);
    
        if (*Filter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))
        {
            if ((Open->Flags & fMINIPORT_OPEN_PMODE) == 0)
            {
                Open->Flags |= fMINIPORT_OPEN_PMODE;
                Miniport->PmodeOpens ++;
                NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                ndisUpdateCheckForLoopbackFlag(Miniport);
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                *Filter &= ~(NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL);
            }
        }
        else
        {
            if (Open->Flags & fMINIPORT_OPEN_PMODE)
            {
                Open->Flags &= ~fMINIPORT_OPEN_PMODE;
                Miniport->PmodeOpens --;
                NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                ndisUpdateCheckForLoopbackFlag(Miniport);
            }
        }
    }



    //
    //  If the local-only bit is set and the miniport is doing it's own
    //  loop back then we need to make sure that we loop back non-self
    //  directed packets that are sent out on the pipe.
    //
    if ((PacketFilter & NDIS_PACKET_TYPE_ALL_LOCAL) &&
        (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK) == 0)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED);
    }
    else
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED);
    }

    //
    //  If the filter library returns NDIS_STATUS_PENDING from
    //  the XxxFitlerAdjust() then we need to call down to the
    //  miniport driver.  Other wise this will have succeeded.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Save the current global packet filter in a buffer that will stick around.
        //  Remove the ALL_LOCAL bit since miniport does not understand this (and does
        //  not need to).
        //
        Miniport->RequestBuffer = (PacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL);

        //
        //  Call the miniport driver. Save the request parms and restore on completion
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(PacketFilter));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we have success then set the Bytes read in the original request.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead = 4;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetPacketFilter: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetCurrentLookahead(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT                Lookahead;
    ULONG               CurrentMax;
    PNDIS_OPEN_BLOCK    CurrentOpen;
    NDIS_STATUS         Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetCurrentLookahead\n"));

    //
    // Verify length of the information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(Lookahead), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Put the lookahead that the binding requests into a
    //  buffer we can use...
    //
    Lookahead = *(UNALIGNED UINT *)(Request->DATA.SET_INFORMATION.InformationBuffer);

    //
    //  Verify that the lookahead is within boundaries...
    //
    if (Lookahead > Miniport->MaximumLookahead)
    {
        Request->DATA.SET_INFORMATION.BytesRead = 0;
        Request->DATA.SET_INFORMATION.BytesNeeded = 0;

        Status = NDIS_STATUS_INVALID_LENGTH;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Find the maximum lookahead between all opens that
    //  are bound to the miniport driver.
    //
    for (CurrentOpen = Miniport->OpenQueue, CurrentMax = 0;
         CurrentOpen != NULL;
         CurrentOpen = CurrentOpen->MiniportNextOpen)
    {
        if (CurrentOpen->CurrentLookahead > CurrentMax)
        {
            CurrentMax = CurrentOpen->CurrentLookahead;
        }
    }

    //
    //  Figure in the new lookahead.
    //
    if (Lookahead > CurrentMax)
    {
        CurrentMax = Lookahead;
    }

    //
    //  Adjust the current max lookahead if needed.
    //
    if (CurrentMax == 0)
    {
        CurrentMax = Miniport->MaximumLookahead;
    }

    //
    //  Set the default status.
    //
    Status = NDIS_STATUS_SUCCESS;

    //
    //  Do we need to call the miniport driver with the
    //  new max lookahead?
    //
    if (Miniport->CurrentLookahead != CurrentMax)
    {
        //
        //  Save the new lookahead value in a buffer
        //  that will stick around.
        //
        Miniport->RequestBuffer = CurrentMax;

        //
        //  Send it to the driver.
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(CurrentMax));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we succeeded then update the binding information.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->CurrentLookahead = (USHORT)Lookahead;
            Request->DATA.SET_INFORMATION.BytesRead = sizeof(Lookahead);
            Miniport->CurrentLookahead = CurrentMax;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetAddWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will add a packet pattern to a miniports list to be used for
    remote wake-up.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the packet pattern was successfully added.
    NDIS_STATUS_PENDING if the request will complete asynchronously.

--*/
{
    PNDIS_PACKET_PATTERN_ENTRY  pPacketEntry;
    ULONG                       cbSize;
    PNDIS_REQUEST_RESERVED      ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    NDIS_STATUS                 Status;
    PNDIS_PM_PACKET_PATTERN     PmPacketPattern;
    UINT                        BytesToCopy;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetAddWakeUpPattern\n"));

    do
    {
        Request->DATA.SET_INFORMATION.BytesNeeded = 0;

        //
        //  Verify the size of the information buffer.
        //
        VERIFY_SET_PARAMETERS(Request, sizeof(NDIS_PM_PACKET_PATTERN), Status);
        
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }
        
        //
        // do some validation on pattern
        //
        PmPacketPattern = (PNDIS_PM_PACKET_PATTERN)Request->DATA.SET_INFORMATION.InformationBuffer;

        if (PmPacketPattern->MaskSize == 0)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        // the pattern offset should not overlap the mask
        //
        if (PmPacketPattern->PatternOffset < sizeof(NDIS_PM_PACKET_PATTERN) + PmPacketPattern->MaskSize)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        // information buffer should have enough room for the pattern
        //        
        VERIFY_SET_PARAMETERS(Request, (PmPacketPattern->PatternOffset + PmPacketPattern->PatternSize), Status);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }
        
        //
        //  Allocate an NDIS_PACKET_PATTERN_ENTRY to store the new pattern.
        //
        cbSize =  sizeof(NDIS_PACKET_PATTERN_ENTRY) +
                  PmPacketPattern->MaskSize + 
                  PmPacketPattern->PatternSize;

        pPacketEntry = ALLOC_FROM_POOL(cbSize, NDIS_TAG_PKT_PATTERN);
        if (pPacketEntry == NULL)
        {
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                    ("ndisMSetAddWakeUpPattern: Unable to allocate memory for internal data structure\n"));
            ReqRsvd->Context = NULL;
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Copy the request information to the pattern entry.
        //
        BytesToCopy = sizeof(NDIS_PM_PACKET_PATTERN) + PmPacketPattern->MaskSize;
        MoveMemory(&pPacketEntry->Pattern,
                   (PUCHAR)PmPacketPattern,
                   BytesToCopy);

        MoveMemory((PUCHAR)&pPacketEntry->Pattern + BytesToCopy,
                    (PUCHAR)PmPacketPattern + PmPacketPattern->PatternOffset,
                   PmPacketPattern->PatternSize);


        //
        //  Save the open with the pattern entry.
        //
        pPacketEntry->Open = ReqRsvd->Open;

        //
        //  Save the packet entry with the request.
        //
        ReqRsvd->Context = pPacketEntry;

        //
        //  Call the miniport driver.
        //
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
        
    }while (FALSE);
    
    if (Status == NDIS_STATUS_INVALID_LENGTH)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                ("ndisMSetAddWakeupPattern: Invalid request size\n"));
        
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetAddWakeUpPattern\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetRemoveWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++


Routine Description:

    This routine will remove a packet pattern from a miniports list so that the
    adapter will no longer generate wake-up events for it.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the packet pattern was successfully added.
    NDIS_STATUS_PENDING if the request will complete asynchronously.

--*/
{
    NDIS_STATUS                 Status;
    PNDIS_PM_PACKET_PATTERN     PmPacketPattern;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetRemoveWakeUpPattern\n"));

    do
    {
        //
        //  Verify the size of the information buffer.
        //
        VERIFY_SET_PARAMETERS(Request, sizeof(NDIS_PM_PACKET_PATTERN), Status);
        
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }

        PmPacketPattern = (PNDIS_PM_PACKET_PATTERN)Request->DATA.SET_INFORMATION.InformationBuffer;

        if (PmPacketPattern->MaskSize == 0)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        // the pattern offset should not overlap the mask
        //
        if (PmPacketPattern->PatternOffset < sizeof(NDIS_PM_PACKET_PATTERN) + PmPacketPattern->MaskSize)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        // information buffer should have enough room for the pattern
        //        
        VERIFY_SET_PARAMETERS(Request, (PmPacketPattern->PatternOffset + PmPacketPattern->PatternSize), Status);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }

        //
        //  Call the miniport driver.
        //
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);

    }while (FALSE);

    if (Status == NDIS_STATUS_INVALID_LENGTH)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
            ("ndisMSetRemoveWakeUpPattern: Invalid request size\n"));
    }
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetRemoveWakeUpPattern\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will set the wake-up bits for the open and or the with the
    other opens.  If this is different from what is already set on the miniport
    then it will pass the new bits to the miniport.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    
--*/
{
    NDIS_STATUS             Status;
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    PNDIS_OPEN_BLOCK        tmpOpen;
    PULONG                  pEnableWakeUp;
    ULONG                   newWakeUpEnable;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetEnableWakeUp\n"));

    //
    //  Verify the request's information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(ULONG), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        
        //
        //  Get a PULONG to the information buffer.
        //
        pEnableWakeUp = (PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer;
    
        //
        //  Save the new wake-up enables with the open.
        //
        ReqRsvd->Open->WakeUpEnable = *pEnableWakeUp;

        //
        // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
        //
        newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);
        //
        //  Get the new bitwise or of the wake-up bits.
        //
        for (tmpOpen = Miniport->OpenQueue;
             tmpOpen != NULL;
             tmpOpen = tmpOpen->MiniportNextOpen)
        {
            newWakeUpEnable |= tmpOpen->WakeUpEnable;
        }

        //
        //  Save the combination of all opens options with the miniport.
        //
        Miniport->WakeUpEnable = newWakeUpEnable;

        //
        // if this is an IM driver, give it a chance to send the OID down to the physical device
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
        {

            MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);

    
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = sizeof(ULONG);
        }
        
    }
    else
    {
        Request->DATA.SET_INFORMATION.BytesRead = 0;
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetEnableWakeUp\n"));

    return(Status);
}


NDIS_STATUS
ndisMQueryInformation(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS         Status;
    PULONG              pulBuffer;
    PNDIS_OPEN_BLOCK    Open;
    ULONG               Generic;

    //
    //  If there is no open associated with the request then it is an internal request
    //  and we just send it down to the adapter.
    //
    Open = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open;
    if (Open == NULL)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMQueryInformation: Internal request calling to the miniport directly\n"));

        MINIPORT_QUERY_INFO(Miniport, Request, &Status);

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMQueryInformaiton: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Copy the request information into temporary storage.
    //
    pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    //
    // increase the request time out for some requests
    //
    if ((Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MEDIA_CONNECT_STATUS) || 
        (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_LINK_SPEED))
    {
        Miniport->CFHangXTicks = 3;
    }
    
    //
    //  We intercept some calls.
    //
    switch (Request->DATA.QUERY_INFORMATION.Oid)
    {
      case OID_GEN_CURRENT_PACKET_FILTER:
        Status = ndisMQueryCurrentPacketFilter(Miniport, Request);
        break;
    
      case OID_GEN_MEDIA_IN_USE:
      case OID_GEN_MEDIA_SUPPORTED:
        Status = ndisMQueryMediaSupported(Miniport, Request);
        break;
    
      case OID_GEN_CURRENT_LOOKAHEAD:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = (ULONG)Open->CurrentLookahead;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_GEN_MAXIMUM_LOOKAHEAD:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumLookahead;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_802_3_MULTICAST_LIST:
        Status = ndisMQueryEthernetMulticastList(Miniport, Request);
        break;

      case OID_802_3_MAXIMUM_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumLongAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_802_5_CURRENT_FUNCTIONAL:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Generic = TR_QUERY_FILTER_BINDING_ADDRESS(Miniport->TrDB,
                                                      Open->FilterHandle);
    
            *pulBuffer = BYTE_SWAP_ULONG(Generic);
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_802_5_CURRENT_GROUP:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
    
        break;

      case OID_FDDI_LONG_MULTICAST_LIST:
        Status = ndisMQueryLongMulticastList(Miniport, Request);
        break;

      case OID_FDDI_LONG_MAX_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (Status == NDIS_STATUS_SUCCESS)
        {
            *pulBuffer = Miniport->MaximumLongAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_FDDI_SHORT_MULTICAST_LIST:
        //1 dead code
        Status = ndisMQueryShortMulticastList(Miniport, Request);
        break;

      case OID_FDDI_SHORT_MAX_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(ULONG),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumShortAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        }
        break;

      case OID_GEN_MAXIMUM_FRAME_SIZE:
        Status = ndisMQueryMaximumFrameSize(Miniport, Request);
        break;

      case OID_GEN_MAXIMUM_TOTAL_SIZE:
        Status = ndisMQueryMaximumTotalSize(Miniport, Request);
        break;

      case OID_802_3_PERMANENT_ADDRESS:
      case OID_802_3_CURRENT_ADDRESS:
        Status = ndisMQueryNetworkAddress(Miniport, Request);
        break;

      case OID_PNP_WAKE_UP_PATTERN_LIST:
        Status = ndisMQueryWakeUpPatternList(Miniport, Request);
        break;

      case OID_PNP_ENABLE_WAKE_UP:
        Status = ndisMQueryEnableWakeUp(Miniport, Request);
        break;

      case OID_GEN_FRIENDLY_NAME:
        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        if (Request->DATA.QUERY_INFORMATION.InformationBufferLength >= (Miniport->pAdapterInstanceName->Length + sizeof(WCHAR)))
        {
            PUCHAR  p = Request->DATA.QUERY_INFORMATION.InformationBuffer;

            NdisMoveMemory(p,
                           Miniport->pAdapterInstanceName->Buffer,
                           Miniport->pAdapterInstanceName->Length);
            *(PWCHAR)(p + Miniport->pAdapterInstanceName->Length) = 0;
            Request->DATA.QUERY_INFORMATION.BytesWritten = 
            Request->DATA.QUERY_INFORMATION.BytesNeeded = Miniport->pAdapterInstanceName->Length + sizeof(WCHAR);
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

      default:
        //
        //  We don't filter this request, just pass it down to the driver.
        //
        MINIPORT_QUERY_INFO(Miniport, Request, &Status);
        break;
    }

    return(Status);
}


VOID
FASTCALL
ndisMSyncQueryInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  PNDIS_REQUEST           AbortedRequest
    )
/*++

Routine Description:

    This routine will process a query information complete. This is only
    called from the wrapper.  The difference is that this routine will not
    call ndisMProcessDeferred() after processing the completion of the query.

Arguments:

Return Value:

--*/
{
    PNDIS_REQUEST           Request;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_REQUEST_RESERVED  ReqRsvd;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSyncQueryInformationComplete\n"));

    //
    //  Clear the timeout flag and the request_in_process flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, (fMINIPORT_REQUEST_TIMEOUT | fMINIPORT_PROCESSING_REQUEST));
    Miniport->CFHangXTicks = 0;

    if (AbortedRequest)
    {
        Request = AbortedRequest;
        ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    }
    else
    {
        //
        //  Remove the request.
        //
        Request = Miniport->PendingRequest;
        ASSERT(Request != NULL);
        ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
        Miniport->PendingRequest = ReqRsvd->Next;
    }
    
    ReqRsvd->Flags |= REQST_COMPLETED;

    Open = ReqRsvd->Open;
    ASSERT ((ReqRsvd->Flags & REQST_LAST_RESTORE) != REQST_LAST_RESTORE);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSyncQueryInformaitonComplete: Request 0x%x, Oid 0x%x\n", Request, Request->DATA.QUERY_INFORMATION.Oid));


    NDIS_WARN(((Status == NDIS_STATUS_SUCCESS) && (Request->DATA.QUERY_INFORMATION.BytesWritten > Request->DATA.QUERY_INFORMATION.InformationBufferLength)),
              Miniport, NDIS_GFLAG_WARN_LEVEL_0,
              ("ndisMSyncQueryInformationComplete: Miniport %p, OID %lx,  BytesWritten > InformationBufferLength. "
               " BytesWritten %lx, InformationBufferLength %lx\n", 
               Miniport, Request->DATA.QUERY_INFORMATION.Oid, 
               Request->DATA.QUERY_INFORMATION.BytesWritten,
               Request->DATA.QUERY_INFORMATION.InformationBufferLength));


    //
    //  Was this an internal request?
    //
    if (Open != NULL)
    {
        //
        //  Do any necessary post-processing on the query.
        //
        if (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_SUPPORTED_LIST)
        {
            //
            //  Was this a query for the size of the list?
            //
            if (NDIS_STATUS_SUCCESS != Status)
            {
                
#if ARCNET
                if ((NULL == Request->DATA.QUERY_INFORMATION.InformationBuffer) ||
                    (0 == Request->DATA.QUERY_INFORMATION.InformationBufferLength))
                {
                    //
                    //  If this is ARCnet running encapsulated ethernet then
                    //  we need to add a couple of OIDs to be safe.
                    //
                    if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
                        MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                                           fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                    {
                        Request->DATA.QUERY_INFORMATION.BytesNeeded += (ARC_NUMBER_OF_EXTRA_OIDS * sizeof(NDIS_OID));
                    }
                }
#endif
                Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
            }
        }
        else if (Request->DATA.QUERY_INFORMATION.Oid == OID_PNP_CAPABILITIES)
        {
            if ((Status == NDIS_STATUS_SUCCESS) &&
                !(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER)))
            {
                //
                // setup the WOL flag
                //
                ((PNDIS_PNP_CAPABILITIES)Request->DATA.QUERY_INFORMATION.InformationBuffer)->Flags = Miniport->PMCapabilities.Flags;
            }
        }
        else if (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MAC_OPTIONS)
        {
            if (Status == NDIS_STATUS_SUCCESS)
            {
                *((PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer) |= (Miniport->MacOptions & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE);
                
            }
        }

        //
        // do post processing for media connect OID to make sure our state is consistent with
        // those protocols that queried the media
        //

        if ((Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MEDIA_CONNECT_STATUS) &&
            (Status == NDIS_STATUS_SUCCESS))
        {
            BOOLEAN NowConnected = (*(PULONG)(Request->DATA.QUERY_INFORMATION.InformationBuffer) == NdisMediaStateConnected);
            if (NowConnected ^ MINIPORT_TEST_FLAGS(Miniport, fMINIPORT_MEDIA_CONNECTED))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                NdisMIndicateStatus(Miniport,
                                    NowConnected ?
                                        NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT,
                                    INTERNAL_INDICATION_BUFFER,
                                    (UINT)INTERNAL_INDICATION_SIZE);
                NdisMIndicateStatusComplete(Miniport);
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
        
        //
        // Indicate to Protocol;
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Open 0x%x\n", Open));

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                       Request,
                                       Status);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMDereferenceOpen(Open);
    }
    else
    {
        PNDIS_COREQ_RESERVED    CoReqRsvd;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Completing Internal Request\n"));

        //
        //  The CoReqRsvd portion of the request contains ndis only
        //  information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);
        CoReqRsvd->Status = Status;
         
        //
        // Do post processing for media-connect query
        //
        if ((Miniport->MediaRequest == Request) && (Status == NDIS_STATUS_SUCCESS))
        {
            BOOLEAN NowConnected = (*(PULONG)(Request->DATA.QUERY_INFORMATION.InformationBuffer) == NdisMediaStateConnected);
    
            ASSERT (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MEDIA_CONNECT_STATUS);
            if (NowConnected ^ MINIPORT_TEST_FLAGS(Miniport, fMINIPORT_MEDIA_CONNECTED))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                NdisMIndicateStatus(Miniport,
                                    NowConnected ?
                                        NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT,
                                    INTERNAL_INDICATION_BUFFER,
                                    (UINT)INTERNAL_INDICATION_SIZE);
                NdisMIndicateStatusComplete(Miniport);
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }

        //
        //  Do we need to signal anyone?
        //
        if ((ReqRsvd->Flags & REQST_SIGNAL_EVENT) == REQST_SIGNAL_EVENT)
        {
            SET_EVENT(&CoReqRsvd->Event);
        }
        else if ((ReqRsvd->Flags & REQST_FREE_REQUEST) == REQST_FREE_REQUEST)
        {
            ndisMFreeInternalRequest(Request);
        }
    }

    //
    // if we are removing the miniport, we have to signal an event
    // when all requests are completed
    //
    if (Miniport->PendingRequest == NULL)
    {
        if (Miniport->AllRequestsCompletedEvent)
            SET_EVENT(Miniport->AllRequestsCompletedEvent);
    }
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSyncQueryInformationComplete\n"));
}

VOID
NdisMQueryInformationComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a query information operation.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the operation

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryInformationComplete\n"));

    //
    //  If there is no request then we assume this is a complete that was
    //  aborted due to the heart-beat.
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMQueryInformationComplete: No request to complete\n"));

        //1 should we put an assert here?
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMQueryInformationComplete\n"));

        return;
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("Enter query information complete\n"));

    //
    //  Do the actual processing of the query information complete.
    //
    ndisMSyncQueryInformationComplete(Miniport, Status, NULL);

    //
    //  Are there more requests pending?
    //
    if (Miniport->PendingRequest != NULL)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryInformationComplete\n"));
}


NDIS_STATUS
FASTCALL
ndisMQueryCurrentPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG       PacketFilter = 0;
    NDIS_HANDLE FilterHandle;
    NDIS_STATUS Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryCurrentPacketFilter\n"));

    //
    //  Verify the buffer that was passed to us.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(PacketFilter), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMQueryCurrentPacketFilter: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Get the filter handle from the open block.
    //
    FilterHandle = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle;

    //
    //  Get the packet filter from the filter library.
    //
    switch (Miniport->MediaType)
    {
        case NdisMedium802_3:
            PacketFilter = ETH_QUERY_PACKET_FILTER(Miniport->EthDB, FilterHandle);
            break;

        case NdisMedium802_5:
            PacketFilter = TR_QUERY_PACKET_FILTER(Miniport->TrDB, FilterHandle);
            break;

        case NdisMediumFddi:
            PacketFilter = FDDI_QUERY_PACKET_FILTER(Miniport->FddiDB, FilterHandle);
            break;

#if ARCNET
        case NdisMediumArcnet878_2:
            if (MINIPORT_TEST_FLAG(
                    PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                    fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
            {
                PacketFilter = ETH_QUERY_PACKET_FILTER(Miniport->EthDB, FilterHandle);
            }
            else
            {
                PacketFilter = ARC_QUERY_PACKET_FILTER(Miniport->ArcDB, FilterHandle);
            }
            break;
#endif
    }

    //
    //  Place the packet filter in the buffer that was passed in.
    //
    *(UNALIGNED ULONG *)(Request->DATA.QUERY_INFORMATION.InformationBuffer) = PacketFilter;

    Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(PacketFilter);
    Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryCurrentPacketFilter: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMediaSupported(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG       MediaType;
    NDIS_STATUS Status;

    //
    //  Verify the size of the buffer that was passed in by the binding.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(MediaType), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

    //
    //  Default the media type to what the miniport knows it is.
    //
    MediaType = (ULONG)Miniport->MediaType;

#if ARCNET
    //
    //  If we are doing ethernet encapsulation then lie.
    //
    if ((NdisMediumArcnet878_2 == Miniport->MediaType) &&
        MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        //
        //  Tell the binding that we are ethernet.
        //
        MediaType = (ULONG)NdisMedium802_3;
    }
#endif
    //
    //  Save it in the request.
    //
    *(UNALIGNED ULONG *)(Request->DATA.QUERY_INFORMATION.InformationBuffer) = MediaType;

    Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(MediaType);

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
FASTCALL
ndisMQueryEthernetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  call the filter library to get the list of multicast
    //  addresses for this open
    //
    EthQueryOpenFilterAddresses(&Status,
                                Miniport->EthDB,
                                PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                &NumberOfAddresses,
                                Request->DATA.QUERY_INFORMATION.InformationBuffer);

    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    ETH_LENGTH_OF_ADDRESS *
                    EthNumberOfOpenFilterAddresses(
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);

        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;

        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * ETH_LENGTH_OF_ADDRESS;
    }

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryLongMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  Call the filter library to get the list of long
    //  multicast address for this open.
    //
    FddiQueryOpenFilterLongAddresses(&Status,
                                     Miniport->FddiDB,
                                     PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                     Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                     &NumberOfAddresses,
                                     Request->DATA.QUERY_INFORMATION.InformationBuffer);


    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    FDDI_LENGTH_OF_LONG_ADDRESS *
                    FddiNumberOfOpenFilterLongAddresses(
                        Miniport->FddiDB,
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);


        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS;
    }

    return(Status);
}

//1 dead code
NDIS_STATUS
FASTCALL
ndisMQueryShortMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  Call the filter library to get the list of long
    //  multicast address for this open.
    //
    FddiQueryOpenFilterShortAddresses(&Status,
                                      Miniport->FddiDB,
                                      PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                      Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                      &NumberOfAddresses,
                                      Request->DATA.QUERY_INFORMATION.InformationBuffer);


    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    FDDI_LENGTH_OF_SHORT_ADDRESS *
                    FddiNumberOfOpenFilterShortAddresses(
                        Miniport->FddiDB,
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);

        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS;
    }

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMaximumFrameSize(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PULONG  pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    VERIFY_QUERY_PARAMETERS(Request, sizeof(*pulBuffer), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            //
            // 504 - 14 (ethernet header) == 490.
            //
            *pulBuffer = ARC_MAX_FRAME_SIZE - 14;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif
    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMaximumTotalSize(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PULONG  pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    VERIFY_QUERY_PARAMETERS(Request, sizeof(*pulBuffer), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            *pulBuffer = ARC_MAX_FRAME_SIZE;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif
    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryNetworkAddress(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UCHAR       Address[ETH_LENGTH_OF_ADDRESS];

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryNetworkAddress\n"));

    VERIFY_QUERY_PARAMETERS(Request, ETH_LENGTH_OF_ADDRESS, Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            //
            //  Arcnet-to-ethernet conversion.
            //
            ZeroMemory(Address, ETH_LENGTH_OF_ADDRESS);

            Address[5] = Miniport->ArcnetAddress;

            ETH_COPY_NETWORK_ADDRESS(Request->DATA.QUERY_INFORMATION.InformationBuffer, Address);

            Request->DATA.QUERY_INFORMATION.BytesWritten = ETH_LENGTH_OF_ADDRESS;

            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMQueryNetworkAddress\n"));

            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif

    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryNetworkAddress\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryWakeUpPatternList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routinen is executed when a client requests the list of wake-up
    patterns that are set on a given open.

Arguments:

    Miniport    -   Pointer to the miniport block of the adapter.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the request is successful.
    NDIS_STATUS_PENDING if the request will complete asynchronously.
    NDIS_STATUS_FAILURE if we are unable to complete the request.

--*/
{
    PNDIS_REQUEST_RESERVED      ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    PNDIS_OPEN_BLOCK            Open = ReqRsvd->Open;
    PSINGLE_LIST_ENTRY          Link;
    PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
    ULONG                       SizeNeeded = 0;
    NDIS_STATUS                 Status;
    PUCHAR                      Buffer;
    NDIS_REQUEST_TYPE           RequestType = Request->RequestType;
    ULONG                       BytesWritten = 0;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryWakeUpPatternList\n"));

    //
    //  Go through the pattern list and determine the size of the buffer
    //  that is needed for the query.
    //
    for (Link = Miniport->PatternList.Next; Link != NULL; Link = Link->Next)
    {
        //
        //  Get a pointer to the pattern.
        //
        pPatternEntry = CONTAINING_RECORD(
                            Link,
                            NDIS_PACKET_PATTERN_ENTRY,
                            Link);

        //
        //  Is this pattern for the correct open block? or is the request
        //  for global statistics?
        //
        if ((pPatternEntry->Open == Open) ||
            (RequestType == NdisRequestQueryStatistics))
        {
            //
            //  Add the size of the pattern to the total size.
            //
            SizeNeeded += (sizeof(NDIS_PM_PACKET_PATTERN) +
                            pPatternEntry->Pattern.MaskSize +
                            pPatternEntry->Pattern.PatternSize);
        }
    }

    //
    //  Verify the buffer that was passed us.
    //
    VERIFY_QUERY_PARAMETERS(Request, SizeNeeded, Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Get a temp pointer to the InformationBuffer.
        //
        Buffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

        //
        //  Loop through again and copy the patterns into the information
        //  buffer.
        //
        for (Link = Miniport->PatternList.Next; Link != NULL; Link = Link->Next)
        {
            //
            //  Get a pointer to the pattern.
            //
            pPatternEntry = CONTAINING_RECORD(
                                Link,
                                NDIS_PACKET_PATTERN_ENTRY,
                                Link);
    
            //
            //  Is this pattern for the correct open block? or is the request
            //  for global statistics?
            //
            if ((pPatternEntry->Open == Open) ||
                (RequestType == NdisRequestQueryStatistics))
            {
                //
                //  Get the size of the pattern that needs to be copied.
                //
                SizeNeeded = (sizeof(NDIS_PM_PACKET_PATTERN) +
                                pPatternEntry->Pattern.MaskSize +
                                pPatternEntry->Pattern.PatternSize);

                //
                //  Copy the packet pattern to the buffer.
                //
                NdisMoveMemory(Buffer, &pPatternEntry->Pattern, SizeNeeded);

                //
                //  Increment the Buffer to the place to start copying next.
                //
                Buffer += SizeNeeded;
                BytesWritten += SizeNeeded;
            }
        }
    }

    Request->DATA.QUERY_INFORMATION.BytesWritten = BytesWritten;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryWakeUpPatternList\n"));
    
    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will process the query information for the
    OID_PNP_ENABLE_WAKE_UP.  This is a bit mask that defines what will generate
    a wake-up event.  This is set on an open basis but when it's passed down
    to the miniport it is the bit wise or of all opens on the miniport.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request block describing the OID.

Return Value:

    NDIS_STATUS_SUCCESS if the set is successful.

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    NDIS_STATUS             Status;
    PULONG                  pEnableWakeUp;

    UNREFERENCED_PARAMETER(Miniport);
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryEnableWakeUp\n"));

    //
    //  Verify that we have enough room in the information buffer.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(ULONG), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Get a pointer to the information buffer as a PULONG.
        //
        pEnableWakeUp = (PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer;

        //
        //  Store the currently enabled wake-up's with the request buffer.
        //
        *pEnableWakeUp = ReqRsvd->Open->WakeUpEnable;

        //
        //  Finish the request.
        //
        Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryEnableWakeUp\n"));

    return(Status);
}


VOID
FASTCALL
ndisMRestoreFilterSettings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        Open OPTIONAL,
    IN  BOOLEAN                 fReset
    )
/*++

Routine Description:

    This routine will build request's to send down to the driver to
    restore the filter settings.  we have free run of the request queue
    since we just reset it.

Arguments:
    Miniport
    Open: Optional. set when the restore is the result of an adapter getting closed
    fReset: flag to specify if we are restoreing filters as a result of resetting the adapter
    

Return Value:
    None

Comments:
    called with Miniport's Spinlock held.
--*/
{
    PNDIS_REQUEST           LastRequest = NULL, Request = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    ULONG                   PacketFilter;
    UINT                    NumberOfAddresses;
    UINT                    FunctionalAddress;
    UINT                    GroupAddress;
    BOOLEAN                 fSetPacketFilter = TRUE;

    do
    {
        //
        //  Get the packet filter for the media type.
        //
        switch (Miniport->MediaType)
        {
            case NdisMedium802_3:
                PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                break;
    
            case NdisMedium802_5:
                PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
                break;
    
            case NdisMediumFddi:
                PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
                break;
#if ARCNET
            case NdisMediumArcnet878_2:
                PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
                PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
        
                if (MINIPORT_TEST_FLAG(
                        Miniport,
                        fMINIPORT_ARCNET_BROADCAST_SET) ||
                    (PacketFilter & NDIS_PACKET_TYPE_MULTICAST))
                {
                    PacketFilter &= ~NDIS_PACKET_TYPE_MULTICAST;
                    PacketFilter |= NDIS_PACKET_TYPE_BROADCAST;
                }
                break;
#endif
            default:
                fSetPacketFilter = FALSE;
                break;
        }
    
        //
        //  If the media in question needs it then set the packet filter.
        //
        if (fSetPacketFilter)
        {
            //
            //  Allocate a request to restore the packet filter.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_GEN_CURRENT_PACKET_FILTER,
                                          &PacketFilter,
                                          sizeof(PacketFilter));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);
        }
    
        //
        //  Now build media dependant requests.
        //
        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:

            ///
            //  For ethernet we need to restore the multicast address list.
            ///
    
            //
            //  Get a list of all the multicast address that need
            //  to be set.
            //
            NumberOfAddresses = ethNumberOfGlobalAddresses(Miniport->EthDB);
    
            //
            //  Allocate a request to restore the multicast address list.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_3_MULTICAST_LIST,
                                          NULL,
                                          NumberOfAddresses * ETH_LENGTH_OF_ADDRESS);
    
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
    
            EthQueryGlobalFilterAddresses(&Status,
                                          Miniport->EthDB,
                                          NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                          &NumberOfAddresses,
                                          (PVOID)(Request + 1));
        
            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
            
            ndisMQueueRequest(Miniport, Request);
            break;

          case NdisMedium802_5:

            ///
            //  For token ring we need to restore the functional address
            //  and the group address.
            ///
    
            //
            //  Get the current functional address from the filter
            //  library.
            //
            FunctionalAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_ADDRESSES(Miniport->TrDB));
    
            //
            //  Allocate a request to restore the functional address.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_5_CURRENT_FUNCTIONAL,
                                          &FunctionalAddress,
                                          sizeof(FunctionalAddress));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);

            //
            //  Get the current group address from the filter library.
            //
            GroupAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
    
            //
            //  Allocate a request to restore the group address.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_5_CURRENT_GROUP,
                                          &GroupAddress,
                                          sizeof(GroupAddress));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);
            break;

          case NdisMediumFddi:

            //
            //  For FDDI we need to restore the long multicast address
            //  list and the short multicast address list.
            //
    
            //
            //  Get the number of multicast addresses and the list
            //  of multicast addresses to send to the miniport driver.
            //
            NumberOfAddresses = fddiNumberOfLongGlobalAddresses(Miniport->FddiDB);
    
            //
            //  Allocate a request to restore the long multicast address list.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_FDDI_LONG_MULTICAST_LIST,
                                          NULL,
                                          NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
    
            FddiQueryGlobalFilterLongAddresses(&Status,
                                               Miniport->FddiDB,
                                               NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS,
                                               &NumberOfAddresses,
                                               (PVOID)(Request + 1));
    
            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
            
            ndisMQueueRequest(Miniport, Request);
    
            //
            //  Get the number of multicast addresses and the list
            //  of multicast addresses to send to the miniport driver.
            //
            NumberOfAddresses = fddiNumberOfShortGlobalAddresses(Miniport->FddiDB);

            //
            //  Allocate a request to restore the short multicast address list.
            //
            if (FDDI_FILTER_SUPPORTS_SHORT_ADDR(Miniport->FddiDB))
            {
                Status = ndisMAllocateRequest(&Request,
                                              OID_FDDI_SHORT_MULTICAST_LIST,
                                              NULL,
                                              NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS);
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    break;
                }
    
                FddiQueryGlobalFilterShortAddresses(&Status,
                                                    Miniport->FddiDB,
                                                    NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                    &NumberOfAddresses,
                                                    (PVOID)(Request + 1));
        
                //
                //  Does the internal request have an open associated with it?
                //
                SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                LastRequest = Request;
            
                ndisMQueueRequest(Miniport, Request);
            }
            break;

#if ARCNET
          case NdisMediumArcnet878_2:
    
                //
                //  Only the packet filter is restored for arcnet and
                //  that was done above.
                //
                Status = NDIS_STATUS_SUCCESS;
                break;
#endif
        }
    
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }

        //
        //  Do we need to update the miniports enabled wake-up states?
        //  Or remove any packet patterns?
        //
        {
            PNDIS_OPEN_BLOCK            tmpOpen;
            ULONG                       newWakeUpEnable;
            PSINGLE_LIST_ENTRY          Link;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;

            //
            // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
            //
            newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);

            //
            //  If we are restoring the filter settings for a NdisCloseAdapter and not a reset
            //  then we need to remove the packet patterns that were added by the open.
            //
            if (!fReset && (Open != NULL))
            {
                //1 why do we need to do this if protocols cleaned up after themselves.
                //
                //  Find any packet patterns that were added for the open.
                //  Build and queue a request to remove these.
                //
                for (Link = Miniport->PatternList.Next;
                     Link != NULL;
                     Link = Link->Next)
                {
                    //
                    //  Get a pointer to the pattern entry.
                    //
                    pPatternEntry = CONTAINING_RECORD(Link,
                                                      NDIS_PACKET_PATTERN_ENTRY,
                                                      Link);
    
                    //
                    //  Does this pattern belong to the open?
                    //
                    if (pPatternEntry->Open == Open)
                    {
                        //
                        //  Build a request to remove it.
                        //
                        Status = ndisMAllocateRequest(&Request,
                                                      OID_PNP_REMOVE_WAKE_UP_PATTERN,
                                                      &pPatternEntry->Pattern,
                                                      sizeof(NDIS_PM_PACKET_PATTERN) +
                                                            pPatternEntry->Pattern.MaskSize +
                                                            pPatternEntry->Pattern.PatternSize);
    
    
                        if (NDIS_STATUS_SUCCESS != Status)
                        {
                            break;
                        }
    
                        SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                    
                        ndisMQueueRequest(Miniport, Request);
                    }
                }
            }
            else
            {
                //
                //  This routine was called for a reset.  Walk the open queue and
                //  re-add the packet patterns.
                //
                //
                //  Find any packet patterns that were added for the open.
                //  Build and queue a request to remove these.
                //
                for (Link = Miniport->PatternList.Next;
                     Link != NULL;
                     Link = Link->Next)
                {
                    //
                    //  Get a pointer to the pattern entry.
                    //
                    pPatternEntry = CONTAINING_RECORD(
                                        Link,
                                        NDIS_PACKET_PATTERN_ENTRY,
                                        Link);
    
                    //
                    //  Build a request to remove it.
                    //
                    Status = ndisMAllocateRequest(&Request,
                                                  OID_PNP_ADD_WAKE_UP_PATTERN,
                                                  &pPatternEntry->Pattern,
                                                  sizeof(NDIS_PM_PACKET_PATTERN) +
                                                    pPatternEntry->Pattern.MaskSize +
                                                    pPatternEntry->Pattern.PatternSize);
    
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        break;
                    }
    
                    SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                    LastRequest = Request;

                    ndisMQueueRequest(Miniport, Request);
                }
            }

            if (NDIS_STATUS_SUCCESS != Status)
            {
                break;
            }
    
            //
            //  Determine the wake-up enable bits.
            //
            for (tmpOpen = Miniport->OpenQueue;
                 tmpOpen != NULL;
                 tmpOpen = tmpOpen->MiniportNextOpen)
            {
                //
                //  If the Open is being closed then we don't want to include
                //  it's wake-up bits.  If the adapter is being reset then
                //  Open will be NULL and we will get all of the open's wake-up
                //  bits.
                //
                if (Open != tmpOpen)
                {
                    newWakeUpEnable |= tmpOpen->WakeUpEnable;
                }
            }
    
            //
            //  Is this different that what is currently set on the adapter?
            //
            if (newWakeUpEnable != Miniport->WakeUpEnable)
            {
                //
                //  Allocate a request and queue it up!
                //
                Status = ndisMAllocateRequest(&Request,
                                              OID_PNP_ENABLE_WAKE_UP,
                                              &newWakeUpEnable,
                                              sizeof(newWakeUpEnable));
                if (NDIS_STATUS_SUCCESS != Status)
                {
                    break;
                }
    
                //
                //  Does the internal request have an open associated with it?
                //
                SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                LastRequest = Request;
            
                ndisMQueueRequest(Miniport, Request);
            }
        }
    } while (FALSE);

    //
    //  Mark the last request that was queued as the last request needed to restore the filter.
    //
    if (fReset && (LastRequest != NULL))
    {
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(LastRequest)->Flags |= REQST_LAST_RESTORE;
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
    }

    if (NULL != Miniport->PendingRequest)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }
}

//1 may be dead code
VOID
ndisMPollMediaState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    )
/*++

Routine Description:
    Polls the media connect state for miniports that need to be polled.

Arguments:
    Miniport    Pointer to the miniport block

Return Value:
    None.

Comments: 
    called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd;

    ASSERT(Miniport->MediaRequest != NULL);

    //
    // Make sure the previously queued internal request is complete
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Miniport->MediaRequest);
    if ((ReqRsvd->Flags & REQST_COMPLETED) &&
        (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
    {
        SET_INTERNAL_REQUEST_NULL_OPEN(Miniport->MediaRequest, 0);
        ndisMQueueRequest(Miniport, Miniport->MediaRequest);
    
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
        }
    }
}



BOOLEAN
FASTCALL
ndisMQueueRequest(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:
    checks to make sure the request is not already queued on miniport
    and if it is not, it queues the request on miniport's PendingRequest queue.

Arguments:
    Miniport
    Request

Return Value:
    TRUE if the request was successfully queued on the miniport
    FALSE is the request is already queued.
    
Comments:
    called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST   *ppReq;
    BOOLEAN         rc;
    
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next = NULL;

    for (ppReq = &Miniport->PendingRequest;
         *ppReq != NULL;
         NOTHING)
    {
        ASSERT (*ppReq != Request);
        
        if (*ppReq == Request)
        {
            break;
        }
        ppReq = &(PNDIS_RESERVED_FROM_PNDIS_REQUEST(*ppReq))->Next;
    }

    if (*ppReq != Request)
    {
        *ppReq = Request;

        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    return(rc);
}


NDIS_STATUS
ndisMAllocateRequest(
    OUT PNDIS_REQUEST   *       pRequest,
    IN  NDIS_OID                Oid,
    IN  PVOID                   Buffer      OPTIONAL,
    IN  ULONG                   BufferLength
    )
/*++

Routine Description:

    This routine will allocate a request to be used as an internal request.

Arguments:

    Request     - Will contain a pointer to the new request on exit.
    RequestType - Type of ndis request.
    Oid         - Request identifier.
    Buffer      - Pointer to the buffer for the request.
    BufferLength- Length of the buffer.

Return Value:

    NDIS_STATUS_SUCCESS if the request allocation succeeded.
    NDIS_STATUS_FAILURE otherwise.

--*/
{
    PNDIS_REQUEST   Request;

    //
    //  Allocate the request structure.
    //
    Request = (PNDIS_REQUEST)ALLOC_FROM_POOL(sizeof(NDIS_REQUEST) + BufferLength,
                                             NDIS_TAG_Q_REQ);
    if (NULL == Request)
    {
        *pRequest = NULL;
        return(NDIS_STATUS_RESOURCES);
    }

    //
    //  Zero out the request.
    //
    ZeroMemory(Request, sizeof(NDIS_REQUEST) + BufferLength);
    INITIALIZE_EVENT(&(PNDIS_COREQ_RESERVED_FROM_REQUEST(Request)->Event));

    Request->RequestType = NdisRequestSetInformation;

    //
    //  Copy the buffer that was passed to us into the new buffer.
    //
    Request->DATA.SET_INFORMATION.Oid = Oid;
    Request->DATA.SET_INFORMATION.InformationBuffer = Request + 1;
    Request->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
    if (Buffer != NULL)
    {
        MoveMemory(Request + 1, Buffer, BufferLength);
    }

    //
    //  Give it back to the caller.
    //
    *pRequest = Request;

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
FASTCALL
ndisMDispatchRequest(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PNDIS_REQUEST               Request,
    IN  BOOLEAN                     fQuery
    )
/*++

Routine Description:
    all requests directed to drivers go through this function. except those made
    to NdisCoRequest.

Arguments:
    

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    NDIS_STATUS         Status;

    do
    {

        //
        // for deserialized drivers, if the device has been handed a reset and the reset call 
        // has not come back or completed, then abort this request
        //

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_CALLING_RESET))
            {
                Status = NDIS_STATUS_RESET_IN_PROGRESS;
                break;
            }
        }
        
        //
        // if the device is sleep or about to sleep, block all user mode requests except the power ones
        //
        if ((Request->RequestType == NdisRequestQueryStatistics) &&
            ((MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING)) ||
             (Miniport->CurrentDevicePowerState > PowerDeviceD0)))
        {
                Status = STATUS_DEVICE_POWERED_OFF;
                break;
        }
        
        if ((MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | fMINIPORT_REJECT_REQUESTS)) ||
            ((Miniport->CurrentDevicePowerState > PowerDeviceD0) && (Request->DATA.SET_INFORMATION.Oid != OID_PNP_SET_POWER)))
        {
            if (fQuery)
            {
                Status = NDIS_STATUS_FAILURE;
                Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
                Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
            }
            break;
        }

        //
        // Satisfy this request right away
        //
        //1 why   the request type is NdisRequestSetInformation?
        if ((Request->RequestType == NdisRequestSetInformation) &&
            (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_INIT_TIME_MS))
        {
            PULONG  InitTime = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);

            *InitTime = Miniport->InitTimeMs;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
            Request->DATA.QUERY_INFORMATION.BytesNeeded = sizeof(ULONG);
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // If this was a request to turn p-mode/l-only on/off then mark things appropriately
        //  This should be moved to completion handler for this OID
        //
        if ((Request->RequestType == NdisRequestSetInformation) &&
            (Request->DATA.SET_INFORMATION.Oid == OID_GEN_CURRENT_PACKET_FILTER))
        {
            //1 do we still need this?
            PULONG              Filter = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);

            if ((Open = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open) != NULL)
            {

                //1 we are doing this too early. we should do this -after-
                //1 the request succeeds.
                if (*Filter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))
                {
                    if ((Open->Flags & fMINIPORT_OPEN_PMODE) == 0)
                    {
                        Open->Flags |= fMINIPORT_OPEN_PMODE;
                        Miniport->PmodeOpens ++;
                        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                        ndisUpdateCheckForLoopbackFlag(Miniport);
                    }

                }
                else
                {
                    if (Open->Flags & fMINIPORT_OPEN_PMODE)
                    {
                        Open->Flags &= ~fMINIPORT_OPEN_PMODE;
                        Miniport->PmodeOpens --;
                        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                        ndisUpdateCheckForLoopbackFlag(Miniport);
                    }
                }

            }
            
            //
            //  Remove the ALL_LOCAL bit since miniport does not understand this (and does
            //  not need to).
            //
            *Filter &= ~NDIS_PACKET_TYPE_ALL_LOCAL;

        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->RequestCount++;
        }
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags |= REQST_DOWNLEVEL;
            Status = (Miniport)->DriverHandle->MiniportCharacteristics.CoRequestHandler(
                        (Miniport)->MiniportAdapterContext,
                        NULL,
                        (Request));
        }
        else
        {
            
            if (fQuery)
            {
                Status = (Miniport->DriverHandle->MiniportCharacteristics.QueryInformationHandler)(
                                        Miniport->MiniportAdapterContext,
                                        Request->DATA.QUERY_INFORMATION.Oid,
                                        Request->DATA.QUERY_INFORMATION.InformationBuffer,
                                        Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                        (PULONG)&Request->DATA.QUERY_INFORMATION.BytesWritten,
                                        (PULONG)&Request->DATA.QUERY_INFORMATION.BytesNeeded);
            }
            else
            {
                Status = (Miniport->DriverHandle->MiniportCharacteristics.SetInformationHandler)(
                                        Miniport->MiniportAdapterContext,
                                        Request->DATA.SET_INFORMATION.Oid,
                                        Request->DATA.SET_INFORMATION.InformationBuffer,
                                        Request->DATA.SET_INFORMATION.InformationBufferLength,
                                        (PULONG)&Request->DATA.SET_INFORMATION.BytesRead,
                                        (PULONG)&Request->DATA.SET_INFORMATION.BytesNeeded);
            }
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->RequestCount--;
        }


    } while (FALSE);

    return(Status);
}

VOID
FASTCALL
ndisMAdjustFilters(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PFILTERDBS              FilterDB
    )

/*++

Routine Description:

    Replace the dummy filters by real ones.

Arguments:

    Miniport - Pointer to the Miniport.
    FilterDB - New valid filters

Return Value:

    None.

--*/
{
    ASSERT(Miniport->EthDB == NULL);
    ASSERT(Miniport->TrDB == NULL);
    ASSERT(Miniport->FddiDB == NULL);
#if ARCNET
    ASSERT(Miniport->ArcDB == NULL);
#endif

    Miniport->EthDB = FilterDB->EthDB;
    Miniport->TrDB = FilterDB->TrDB;
    Miniport->FddiDB = FilterDB->FddiDB;
#if ARCNET
    Miniport->ArcDB = FilterDB->ArcDB;
#endif
}

VOID
ndisMNotifyMachineName(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_STRING            MachineName OPTIONAL
    )
/*++

Routine Description:

    Send an OID_GEN_MACHINE_NAME to notify the miniport of this machine's name.
    If MachineName is supplied to this routine, use it. Otherwise, read it from
    the registry.

Arguments:

    Miniport - Pointer to the Miniport.
    MachineName - if specified, the name to be sent to the miniport.

Return Value:

    None.
--*/
{
    NDIS_STRING                 HostNameKey;
    NTSTATUS                    NtStatus;
    LONG                        ErrorCode;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    PUCHAR                      HostNameBuffer;

    HostNameKey.Buffer = NULL;
    HostNameBuffer = NULL;

    //1 is there a kernel call to read machine name??
    do
    {
        if (MachineName == NULL)
        {
            //1 we need to check for type of HostName
            ZeroMemory(QueryTable, sizeof(QueryTable));
            ZeroMemory(&HostNameKey, sizeof(HostNameKey));

            QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT|
                                  RTL_QUERY_REGISTRY_REQUIRED;
            QueryTable[0].Name = L"HostName";
            QueryTable[0].EntryContext = &HostNameKey;
            QueryTable[0].DefaultType = REG_NONE;

            QueryTable[1].Name = NULL;

            NtStatus = RtlQueryRegistryValues(
                            RTL_REGISTRY_SERVICES,
                            L"\\Tcpip\\Parameters",
                            &QueryTable[0],
                            NULL,   // Context
                            NULL    // Environment
                            );
    
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                    ("ndisMNotifyMachineName: Miniport %p, registry query for %ws failed, Status %x\n",
                        Miniport, QueryTable[0].Name, NtStatus));
                break;
            }

        }
        else
        {
            HostNameKey = *MachineName;
        }

        ASSERT(HostNameKey.MaximumLength >= HostNameKey.Length);

        //
        // Copy the name into non-paged memory since the OID
        // will be sent to the miniport at raised IRQL.
        //
        HostNameBuffer = ALLOC_FROM_POOL(HostNameKey.MaximumLength, NDIS_TAG_NAME_BUF);
        if (HostNameBuffer == NULL)
        {
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                ("ndisMNotifyMachineName: Miniport %p, failed to alloc %d bytes\n",
                    Miniport, HostNameKey.MaximumLength));
            break;
        }

        ZeroMemory(HostNameBuffer, HostNameKey.MaximumLength);
        NdisMoveMemory(HostNameBuffer, HostNameKey.Buffer, HostNameKey.Length);

        ErrorCode = ndisMDoMiniportOp(Miniport,
                                      FALSE,
                                      OID_GEN_MACHINE_NAME,
                                      HostNameBuffer,
                                      HostNameKey.Length,
                                      0x77,
                                      FALSE);

    }
    while (FALSE);

    if (MachineName == NULL)
    {
        if (HostNameKey.Buffer != NULL)
        {
            FREE_POOL(HostNameKey.Buffer);
        }
    }

    if (HostNameBuffer != NULL)
    {
        FREE_POOL(HostNameBuffer);
    }
}

VOID
ndisUpdateCheckForLoopbackFlag(
    IN      PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    if (Miniport->EthDB && Miniport->EthDB->SingleActiveOpen)
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
    }
    else
    {
        if ((Miniport->PmodeOpens > 0) && (Miniport->NumOpens > 1))
        {
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
        }
        else
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\requestm.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    requestm.h

Abstract:

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __REQUESTM_H
#define __REQUESTM_H

typedef struct _NDIS_REQUEST_RESERVED
{
    PNDIS_REQUEST               Next;
    PNDIS_OPEN_BLOCK            Open;
    PVOID                       Context;
    ULONG                       Flags;
} NDIS_REQUEST_RESERVED, *PNDIS_REQUEST_RESERVED;

#define PNDIS_RESERVED_FROM_PNDIS_REQUEST(_request) ((PNDIS_REQUEST_RESERVED)((_request)->MacReserved))

//
// Used by the NdisCoRequest api to keep context information in the Request->NdisReserved
//
typedef struct _NDIS_COREQ_RESERVED
{
    union
    {
      struct
      {
        CO_REQUEST_COMPLETE_HANDLER CoRequestCompleteHandler;
        NDIS_HANDLE                 VcContext;
        NDIS_HANDLE                 AfContext;
        NDIS_HANDLE                 PartyContext;
      };
      struct
      {
        NDIS_STATUS                 Status;
        KEVENT                      Event;
      };
    };

} NDIS_COREQ_RESERVED, *PNDIS_COREQ_RESERVED;

#define REQST_DOWNLEVEL             0x00000001
#define REQST_FREE_REQUEST          0x00000002
#define REQST_SIGNAL_EVENT          0x00000004
#define REQST_SAVE_BUF              0x00000008
#define REQST_LAST_RESTORE          0x00000010
#define REQST_MANDATORY             0x00000020
#define REQST_COMPLETED             0x80000000

#define PNDIS_COREQ_RESERVED_FROM_REQUEST(_request) ((PNDIS_COREQ_RESERVED)((_request)->NdisReserved))

//
//  The following structure keeps track of wakeup patterns for open blocks.
//
typedef struct _NDIS_PACKET_PATTERN_ENTRY
{
    SINGLE_LIST_ENTRY       Link;
    PNDIS_OPEN_BLOCK        Open;
    NDIS_PM_PACKET_PATTERN  Pattern;
} NDIS_PACKET_PATTERN_ENTRY, *PNDIS_PACKET_PATTERN_ENTRY;

#define MINIPORT_QUERY_INFO(_M_, _R_, _S_)  *(_S_) = ndisMDispatchRequest(_M_, _R_, TRUE)

#define MINIPORT_SET_INFO(_M_, _R_, _S_)    *(_S_) = ndisMDispatchRequest(_M_, _R_, FALSE)

#define SAVE_REQUEST_BUF(_M_, _R_, _B_, _L_)                                                        \
    {                                                                                               \
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags |= REQST_SAVE_BUF;                            \
        (_M_)->SetInfoBuf = (_R_)->DATA.SET_INFORMATION.InformationBuffer;                          \
        (_M_)->SetInfoBufLen = (USHORT)((_R_)->DATA.SET_INFORMATION.InformationBufferLength);       \
        (_R_)->DATA.SET_INFORMATION.InformationBuffer = _B_;                                        \
        (_R_)->DATA.SET_INFORMATION.InformationBufferLength = _L_;                                  \
    }

#define RESTORE_REQUEST_BUF(_M_, _R_)                                                               \
    {                                                                                               \
        if (PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags & REQST_SAVE_BUF)                         \
        {                                                                                           \
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags &= ~REQST_SAVE_BUF;                       \
            (_R_)->DATA.SET_INFORMATION.InformationBuffer = (_M_)->SetInfoBuf;                      \
            (_R_)->DATA.SET_INFORMATION.InformationBufferLength = (_M_)->SetInfoBufLen;             \
            (_M_)->SetInfoBuf = NULL;                                                               \
            (_M_)->SetInfoBufLen = 0;                                                               \
        }                                                                                           \
    }

//
//  This macro verifies the query information buffer length.
//
#define VERIFY_QUERY_PARAMETERS(_Request, _SizeNeeded, _Status)                                     \
{                                                                                                   \
    _Status = NDIS_STATUS_SUCCESS;                                                                  \
    if ((_Request)->DATA.QUERY_INFORMATION.InformationBufferLength < (_SizeNeeded))                 \
    {                                                                                               \
        (_Request)->DATA.QUERY_INFORMATION.BytesNeeded = (_SizeNeeded);                             \
        _Status = NDIS_STATUS_INVALID_LENGTH;                                                       \
    }                                                                                               \
}

//
//  This macro verifies the set information buffer length.
//
#define VERIFY_SET_PARAMETERS(_Request, _SizeNeeded, _Status)                                       \
{                                                                                                   \
    _Status = NDIS_STATUS_SUCCESS;                                                                  \
    if ((_Request)->DATA.SET_INFORMATION.InformationBufferLength < (_SizeNeeded))                   \
    {                                                                                               \
        (_Request)->DATA.SET_INFORMATION.BytesNeeded = (_SizeNeeded);                               \
        _Status = NDIS_STATUS_INVALID_LENGTH;                                                       \
    }                                                                                               \
}

#define SET_INTERNAL_REQUEST(_Request, _Open, _Flags)                                               \
{                                                                                                   \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Open = (_Open);                                    \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = _Flags;                                    \
                                                                                                    \
    if (NULL != (_Open))                                                                            \
    {                                                                                               \
        M_OPEN_INCREMENT_REF_INTERLOCKED(_Open);                                                    \
                                                                                                    \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                                  \
                ("+ Open 0x%x Reference 0x%x\n", _Open, (_Open)->References));                      \
    }                                                                                               \
}

#define SET_INTERNAL_REQUEST_NULL_OPEN(_Request, _Flags)                                            \
{                                                                                                   \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Open = NULL;                                       \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = _Flags;                                    \
}

#define INIT_INTERNAL_REQUEST(_Request, _Oid, _Type, _Buf, _Len)                                    \
{                                                                                                   \
    NdisZeroMemory(_Request, sizeof(NDIS_REQUEST));                                                 \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = REQST_SIGNAL_EVENT;                        \
    (_Request)->DATA.QUERY_INFORMATION.Oid = _Oid;                                                  \
    (_Request)->RequestType = _Type;                                                                \
    (_Request)->DATA.QUERY_INFORMATION.InformationBuffer = _Buf;                                    \
    (_Request)->DATA.QUERY_INFORMATION.InformationBufferLength = _Len;                              \
}

#endif // __REQUESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\sendm.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    sendm.h

Abstract:

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __SENDM_H
#define __SENDM_H

#define SEND_PACKET_ARRAY   16

//
// The following definitions apply to serialized drivers only. Packets for the deserialized drivers are not queued
// within NDIS
//
#define PACKET_LIST(_P)     (PLIST_ENTRY)((_P)->WrapperReserved)

#define GET_FIRST_MINIPORT_PACKET(_M, _P)                                       \
    {                                                                           \
        *(_P) = NULL;                                                           \
        if (!IsListEmpty(&(_M)->PacketList))                                    \
        {                                                                       \
            PLIST_ENTRY _L;                                                     \
                                                                                \
            _L = (_M)->PacketList.Flink;                                        \
            *(_P) = CONTAINING_RECORD(_L, NDIS_PACKET, WrapperReserved);        \
        }                                                                       \
    }

//
//  Macros used for getting to OOB data and packet extension.
//
#define PNDIS_PACKET_OOB_DATA_FROM_PNDIS_PACKET(_P)                             \
                (PNDIS_PACKET_OOB_DATA)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset)

#define INIT_PACKET_LIST(_P)            InitializeListHead(PACKET_LIST(_P))

#define LINK_PACKET(_M, _P, _NSR, _O)                                           \
    {                                                                           \
        (_NSR)->Open = _O;                                                      \
        INIT_PACKET_LIST(_P);                                                   \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       PACKET_LIST(_P));                                        \
    }

#define LINK_WAN_PACKET(_M, _P)                                                 \
    {                                                                           \
        InitializeListHead(&(_P)->WanPacketQueue);                              \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       &(_P)->WanPacketQueue);                                  \
    }

#define UNLINK_PACKET(_M, _P, _NSR)                                             \
    {                                                                           \
        ASSERT(_P != (_M)->FirstPendingPacket);                                 \
        RemoveEntryList(PACKET_LIST(_P));                                       \
        INIT_PACKET_LIST(_P);                                                   \
    }

#define UNLINK_WAN_PACKET(_P)                                                   \
    {                                                                           \
        RemoveEntryList(&(_P)->WanPacketQueue);                                 \
        InitializeListHead(&(_P)->WanPacketQueue);                              \
    }

#if DBG
#define VALIDATE_PACKET_OPEN(_P)                                                \
    {                                                                           \
        PNDIS_STACK_RESERVED    _NSR;                                           \
                                                                                \
        NDIS_STACK_RESERVED_FROM_PACKET(_P, &_NSR);                             \
        ASSERT(VALID_OPEN(_NSR->Open));                                         \
    }
#else
#define VALIDATE_PACKET_OPEN(_P)
#endif

#define NEXT_PACKET_PENDING(_M, _P)                                             \
    {                                                                           \
        PLIST_ENTRY             _List;                                          \
                                                                                \
        _List = PACKET_LIST(_P);                                                \
        (_M)->FirstPendingPacket = NULL;                                        \
        if (_List->Flink != &(_M)->PacketList)                                  \
        {                                                                       \
             (_M)->FirstPendingPacket =                                         \
                CONTAINING_RECORD(_List->Flink,                                 \
                                  NDIS_PACKET,                                  \
                                  WrapperReserved);                             \
            VALIDATE_PACKET_OPEN((_M)->FirstPendingPacket);                     \
        }                                                                       \
    }

#if DBG

#define CHECK_FOR_DUPLICATE_PACKET(_M, _P)                                      \
{                                                                               \
    IF_DBG(DBG_COMP_SEND, DBG_LEVEL_FATAL)                                      \
    {                                                                           \
        PLIST_ENTRY     _List;                                                  \
                                                                                \
        if (!IsListEmpty(&(_M)->PacketList))                                    \
        {                                                                       \
            PNDIS_PACKET    _Pkt;                                               \
                                                                                \
            for (_List = (_M)->PacketList.Flink;                                \
                 _List != &(_M)->PacketList;                                    \
                 _List = _List->Flink)                                          \
            {                                                                   \
                _Pkt = CONTAINING_RECORD(_List,                                 \
                                         NDIS_PACKET,                           \
                                         WrapperReserved);                      \
                if (_P == _Pkt)                                                 \
                {                                                               \
                    DBGBREAK(DBG_COMP_SEND, DBG_LEVEL_FATAL);                   \
                }                                                               \
            }                                                                   \
        }                                                                       \
    }                                                                           \
}

#else

#define CHECK_FOR_DUPLICATE_PACKET(_M, _P)

#endif

#define ADD_RESOURCE(_M, C)     MINIPORT_SET_FLAG(_M, fMINIPORT_RESOURCES_AVAILABLE)
#define CLEAR_RESOURCE(_M, C)   MINIPORT_CLEAR_FLAG(_M, fMINIPORT_RESOURCES_AVAILABLE)

#define VALID_OPEN(_O)  (((ULONG_PTR)(_O) & 0xFFFFFF00) != MAGIC_OPEN)

#define MAGIC_OPEN      'MOC\00'
#define MAGIC_OPEN_I(x) (PVOID)((MAGIC_OPEN & 0xFFFFFF00) + 0x00000030 + x)

#define CLEAR_WRAPPER_RESERVED(_NSR)    (_NSR)->RefUlong = 0

#if ARCNET

#define FREE_ARCNET_BUFFER(_M, _P, _O)                                          \
{                                                                               \
    /*                                                                          \
     * If this is arcnet, then free the appended header.                        \
     */                                                                         \
    if ((_M)->MediaType == NdisMediumArcnet878_2)                               \
    {                                                                           \
        ndisMFreeArcnetHeader(_M, _P, _O);                                      \
    }                                                                           \
}

#else

#define FREE_ARCNET_BUFFER(_M, _P, _O)

#endif

#define NDISM_COMPLETE_SEND(_M, _P, _NSR, _S, _L, _I)                           \
{                                                                               \
    PNDIS_OPEN_BLOCK    _O;                                                     \
    ULONG               _OR;                                                    \
                                                                                \
    if (!(_L))                                                                  \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
                                                                                \
    _O = (_NSR)->Open;                                                          \
                                                                                \
    UNLINK_PACKET(_M, _P, _NSR);                                                \
    POP_PACKET_STACK(_P);                                                       \
                                                                                \
    ADD_RESOURCE((_M), 'F');                                                    \
                                                                                \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Completed 0x%x\n", (_S)));                                        \
                                                                                \
    FREE_ARCNET_BUFFER(_M, _P, _O);                                             \
                                                                                \
    (_NSR)->Open = MAGIC_OPEN_I(_I);                                            \
                                                                                \
    if (!(_L) && (NULL != (_M)->FirstPendingPacket))                            \
    {                                                                           \
        /*                                                                      \
         *  Do we need to queue another workitem to process more sends ?        \
         */                                                                     \
        NDISM_QUEUE_WORK_ITEM(_M, NdisWorkItemSend, NULL);                      \
    }                                                                           \
                                                                                \
    /*                                                                          \
     *  Indicate the completion to the protocol.                                \
     */                                                                         \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                                  \
                                                                                \
    /*                                                                          \
     * Make sure that an IM which shares send and receive packets on the same   \
     * pool works fine with the check in the receive path.                      \
     */                                                                         \
    (_NSR)->RefCount = 0;                                                       \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_CLEAR_ITEMS);                        \
    CLEAR_WRAPPER_RESERVED(_NSR);                                               \
    (_O->SendCompleteHandler)(_O->ProtocolBindingContext,                       \
                              (_P),                                             \
                              (_S));                                            \
                                                                                \
    M_OPEN_DECREMENT_REF_INTERLOCKED(_O, _OR)                                   \
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                  \
        ("- Open 0x%x Reference 0x%x\n", _O, _O->References));                  \
                                                                                \
    if (_OR == 0)                                                               \
    {                                                                           \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        ndisMFinishClose(_O);                                                   \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                              \
    }                                                                           \
                                                                                \
    if (_L)                                                                     \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
}                                                                               
                                                                                
#define NDISM_COMPLETE_SEND_RESOURCES(_M, _NSR, _P)                             \
{                                                                               \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Deferring send\n"));                                              \
                                                                                \
    ASSERT(VALID_OPEN((_NSR)->Open));                                           \
    /*                                                                          \
     * Put on pending queue                                                     \
     */                                                                         \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_PENDING);                            \
    (_M)->FirstPendingPacket = (_P);                                            \
                                                                                \
    /*                                                                          \
     * Mark the miniport as out of send resources.                              \
     */                                                                         \
    CLEAR_RESOURCE((_M), 'S');                                                  \
}

#define NDISM_SEND_PACKET(_M, _O, _P, _pS)                                      \
{                                                                               \
    UINT    _Flags;                                                             \
    BOOLEAN _SelfDirected;                                                      \
                                                                                \
    /*                                                                          \
     * Indicate the packet loopback if necessary.                               \
    */                                                                          \
                                                                                \
    if (NDIS_CHECK_FOR_LOOPBACK(_M, _P))                                        \
    {                                                                           \
        _SelfDirected = ndisMLoopbackPacketX(_M, _P);                           \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        _SelfDirected = FALSE;                                                  \
    }                                                                           \
                                                                                \
    if (_SelfDirected)                                                          \
    {                                                                           \
        DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                 \
            ("Packet is self-directed.\n"));                                    \
                                                                                \
        /*                                                                      \
         * Self-directed loopback always succeeds.                              \
         */                                                                     \
        *(_pS) = NDIS_STATUS_SUCCESS;                                           \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                 \
            ("Sending packet 0x%p\n", _P));                                     \
                                                                                \
        NdisQuerySendFlags((_P), &_Flags);                                      \
                                                                                \
        /*                                                                      \
         * Call down to the driver.                                             \
         */                                                                     \
        MINIPORT_SET_PACKET_FLAG(_P, fPACKET_PENDING);                          \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        *(_pS) = ((_O)->WSendHandler)((_O)->MiniportAdapterContext, _P, _Flags);\
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
    }                                                                           \
}


#define PACKETS_OUT(_M)         (_M)->NdisStats.DirectedPacketsOut ++
#define DIRECTED_PACKETS_IN(_M) (_M)->NdisStats.DirectedPacketsIn ++
#define BYTES_OUT(_M, _B)
#define DIRECTED_BYTES_IN(_M, _S)
#define DIRECTED_BYTES_IN_PACKET(_M, _P)

#define ndisMCheckPacketAndGetStatsOut(_M, _P, _S)                              \
    {                                                                           \
        PNDIS_BUFFER    _Buffer;                                                \
                                                                                \
        *(_S) = NDIS_STATUS_SUCCESS;                                            \
        PACKETS_OUT(_M);                                                        \
        _Buffer = (_P)->Private.Head;                                           \
        while (_Buffer != NULL)                                                 \
        {                                                                       \
            if (MDL_ADDRESS_SAFE(_Buffer, HighPagePriority) == NULL)            \
            {                                                                   \
                *(_S) = NDIS_STATUS_RESOURCES;                                  \
                break;                                                          \
            }                                                                   \
            BYTES_OUT(_M, _Buffer);                                             \
            _Buffer = _Buffer->Next;                                            \
        }                                                                       \
    }

#define ndisMCheckPacketAndGetStatsOutAlreadyMapped(_M, _P)                     \
    {                                                                           \
        PNDIS_BUFFER    _Buffer;                                                \
                                                                                \
        PACKETS_OUT(_M);                                                        \
        _Buffer = (_P)->Private.Head;                                           \
        while (_Buffer != NULL)                                                 \
        {                                                                       \
            BYTES_OUT(_M, _Buffer);                                             \
            _Buffer = _Buffer->Next;                                            \
        }                                                                       \
    }


#define NDISM_COMPLETE_SEND_SG(_M, _P, _NSR, _S, _L, _I, _UNLINK)               \
{                                                                               \
    PNDIS_OPEN_BLOCK    _O;                                                     \
    ULONG               _OR;                                                    \
                                                                                \
    if (!(_L))                                                                  \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
                                                                                \
    _O = (_NSR)->Open;                                                          \
                                                                                \
    if (_UNLINK)                                                                \
    {                                                                           \
        UNLINK_PACKET(_M, _P, _NSR);                                            \
    }                                                                           \
    POP_PACKET_STACK(_P);                                                       \
                                                                                \
    ADD_RESOURCE((_M), 'F');                                                    \
                                                                                \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Completed 0x%x\n", (_S)));                                        \
                                                                                \
    (_NSR)->Open = MAGIC_OPEN_I(_I);                                            \
                                                                                \
    if (!(_L) && (NULL != (_M)->FirstPendingPacket))                            \
    {                                                                           \
        /*                                                                      \
         *  Do we need to queue another workitem to process more sends ?        \
         */                                                                     \
        NDISM_QUEUE_WORK_ITEM(_M, NdisWorkItemSend, NULL);                      \
    }                                                                           \
                                                                                \
    /*                                                                          \
     *  Indicate the completion to the protocol.                                \
     */                                                                         \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                                  \
                                                                                \
    if (NDIS_PER_PACKET_INFO_FROM_PACKET(_P, ScatterGatherListPacketInfo) != NULL) \
    {                                                                           \
        ndisMFreeSGList(_M, _P);                                                \
    }                                                                           \
    /*                                                                          \
     * Make sure that an IM which shares send and receive packets on the same   \
     * pool works fine with the check in the receive path.                      \
     */                                                                         \
    (_NSR)->RefCount = 0;                                                       \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_CLEAR_ITEMS);                        \
    CLEAR_WRAPPER_RESERVED(_NSR);                                               \
    (_O->SendCompleteHandler)(_O->ProtocolBindingContext,                       \
                              (_P),                                             \
                              (_S));                                            \
                                                                                \
    M_OPEN_DECREMENT_REF_INTERLOCKED(_O, _OR)                                   \
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                  \
        ("- Open 0x%x Reference 0x%x\n", _O, _O->References));                  \
                                                                                \
    if (_OR == 0)                                                               \
    {                                                                           \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        ndisMFinishClose(_O);                                                   \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                              \
    }                                                                           \
                                                                                \
    if (_L)                                                                     \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
}

#define LINK_PACKET_SG(_M, _P, _NSR)                                            \
    {                                                                           \
        INIT_PACKET_LIST(_P);                                                   \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       PACKET_LIST(_P));                                        \
    }

#endif // __SENDM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\timer.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    NDIS wrapper functions for full mac drivers isr/timer

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93

Environment:

    Kernel mode, FSD

Revision History:
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

--*/

#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_TIMER

VOID
NdisInitializeTimer(
    IN  OUT PNDIS_TIMER         NdisTimer,
    IN  PNDIS_TIMER_FUNCTION    TimerFunction,
    IN  PVOID                   FunctionContext
    )
/*++

Routine Description:

    Sets up an NdisTimer object, initializing the DPC in the timer to
    the function and context.

Arguments:

    NdisTimer - the timer object.
    TimerFunction - Routine to start.
    FunctionContext - Context of TimerFunction.

Return Value:

    None.

--*/
{
    INITIALIZE_TIMER(&NdisTimer->Timer);

    //
    // Initialize our dpc. If Dpc was previously initialized, this will
    // reinitialize it.
    //
    INITIALIZE_DPC(&NdisTimer->Dpc,
                   (PKDEFERRED_ROUTINE)TimerFunction,
                   FunctionContext);

    SET_DPC_IMPORTANCE(&NdisTimer->Dpc);
}

VOID
NdisSetTimer(
    IN  PNDIS_TIMER             NdisTimer,
    IN  UINT                    MillisecondsToDelay
    )
/*++

Routine Description:

    Sets up TimerFunction to fire after MillisecondsToDelay.

Arguments:

    NdisTimer - the timer object.
    MillisecondsToDelay - Amount of time before TimerFunction is started.

Return Value:

    None.

--*/
{
    LARGE_INTEGER FireUpTime;

    if ((NdisTimer->Dpc.DeferredRoutine == ndisMTimerDpc) ||
        (NdisTimer->Dpc.DeferredRoutine == ndisMTimerDpcX))
    {
        NdisMSetTimer((PNDIS_MINIPORT_TIMER)NdisTimer, MillisecondsToDelay);
    }
    else
    {
        FireUpTime.QuadPart = Int32x32To64((LONG)MillisecondsToDelay, -10000);
    
        //
        // Set the timer
        //
        SET_TIMER(&NdisTimer->Timer, FireUpTime, &NdisTimer->Dpc);
    }
}


VOID
NdisSetTimerEx(
    IN  PNDIS_TIMER             NdisTimer,
    IN  UINT                    MillisecondsToDelay,
    IN  PVOID                   FunctionContext
    )
/*++

Routine Description:

    Sets up TimerFunction to fire after MillisecondsToDelay.

Arguments:

    NdisTimer - the timer object.
    MillisecondsToDelay - Amount of time before TimerFunction is started.
    FunctionContext - This over-rides the one specified via NdisInitializeTimer

Return Value:

    None.

--*/
{
    LARGE_INTEGER FireUpTime;

    NdisTimer->Dpc.DeferredContext = FunctionContext;
    if ((NdisTimer->Dpc.DeferredRoutine == ndisMTimerDpc) ||
        (NdisTimer->Dpc.DeferredRoutine == ndisMTimerDpcX))
    {
        NdisMSetTimer((PNDIS_MINIPORT_TIMER)NdisTimer, MillisecondsToDelay);
    }
    else
    {
        FireUpTime.QuadPart = Int32x32To64((LONG)MillisecondsToDelay, -10000);
    
        //
        // Set the timer
        //
        SET_TIMER(&NdisTimer->Timer, FireUpTime, &NdisTimer->Dpc);
    }
}


VOID
NdisCancelTimer(
    IN  PNDIS_TIMER             Timer,
    OUT PBOOLEAN                TimerCancelled
    )
{
    *TimerCancelled = KeCancelTimer(&Timer->Timer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\tfilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    tfilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Anthony V. Ercolano (Tonye) 03-Aug-1990

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Adam Barr (adamba) 19-Mar-1991

        - Modified for Token-Ring
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_TFILTER

//
// Used in case we have to call TrChangeFunctionalAddress or
// TrChangeGroupAddress with a NULL address.
//
static UCHAR NullFunctionalAddress[4] = { 0x00 };


//
// Maximum number of supported opens
//
#define TR_FILTER_MAX_OPENS 32


#define TR_CHECK_FOR_INVALID_BROADCAST_INDICATION(_F)                   \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    if (!((_F)->CombinedPacketFilter & NDIS_PACKET_TYPE_BROADCAST))     \
    {                                                                   \
        /*                                                              \
            We should never receive broadcast packets                   \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating broadcast packets when not set to.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}


#define TR_CHECK_FOR_INVALID_DIRECTED_INDICATION(_F, _A)                \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    /*                                                                  \
        The result of comparing an element of the address               \
        array and the functional address.                               \
                                                                        \
            Result < 0 Implies the adapter address is greater.          \
            Result > 0 Implies the address is greater.                  \
            Result = 0 Implies that the they are equal.                 \
    */                                                                  \
    INT Result;                                                         \
                                                                        \
    TR_COMPARE_NETWORK_ADDRESSES_EQ(                                    \
        (_F)->AdapterAddress,                                           \
        (_A),                                                           \
        &Result);                                                       \
    if (Result != 0)                                                    \
    {                                                                   \
        /*                                                              \
            We should never receive directed packets                    \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating packets to another station when not in promiscuous mode.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}


BOOLEAN
TrCreateFilter(
    IN  PUCHAR                  AdapterAddress,
    OUT PTR_FILTER *            Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    AdapterAddress - the address of the adapter associated with this filter
    database.

    Filter - A pointer to a TR_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PTR_FILTER  LocalFilter;
    BOOLEAN     rc = FALSE;

    do
    {
        //
        // Allocate the database and initialize it.
        //
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(TR_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(TR_FILTER));
            //1 what is this LocalFilter->NumOpens?
            LocalFilter->NumOpens ++;
            TrReferencePackage();
            TR_COPY_NETWORK_ADDRESS(LocalFilter->AdapterAddress, AdapterAddress);
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}

//
// NOTE : THIS ROUTINE CANNOT BE PAGEABLE
//

VOID
TrDeleteFilter(
    IN  PTR_FILTER              Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to a TR_FILTER to be deleted.

Return Value:

    None.

--*/
{
    //1 check to see if we should free memory for group addresses
    ASSERT(Filter->OpenList == NULL);

    FREE_POOL(Filter);
    TrDereferencePackage();
}


NDIS_STATUS
TrDeleteFilterOpenAdapter(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE FUNCTIONAL ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    NDIS_STATUS      StatusToReturn;
    PTR_BINDING_INFO LocalOpen = (PTR_BINDING_INFO)NdisFilterHandle;

    //
    //  Set the packet filter to NONE.
    //
    StatusToReturn = XFilterAdjust(Filter,
                                   NdisFilterHandle,
                                   (UINT)0,
                                   FALSE);
    if ((NDIS_STATUS_SUCCESS == StatusToReturn) ||
        (NDIS_STATUS_PENDING == StatusToReturn))
    {
        NDIS_STATUS StatusToReturn2;

        //
        //  Clear the functional address.
        //
        StatusToReturn2 = TrChangeFunctionalAddress(
                             Filter,
                             NdisFilterHandle,
                             NullFunctionalAddress,
                             FALSE);
        if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
        {
            StatusToReturn = StatusToReturn2;
        }
    }

    if (((StatusToReturn == NDIS_STATUS_SUCCESS) ||
         (StatusToReturn == NDIS_STATUS_PENDING)) &&
         (LocalOpen->UsingGroupAddress))
    {
        Filter->GroupReferences--;

        LocalOpen->UsingGroupAddress = FALSE;

        if (Filter->GroupReferences == 0)
        {
            NDIS_STATUS StatusToReturn2;

            //
            //  Clear the group address if no other bindings are using it.
            //
            StatusToReturn2 = TrChangeGroupAddress(
                                  Filter,
                                  NdisFilterHandle,
                                  NullFunctionalAddress,
                                  FALSE);
            if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
            {
                StatusToReturn = StatusToReturn2;
            }
        }
    }

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // If this is the last reference to the open - remove it.
        //
        if ((--(LocalOpen->References)) == 0)
        {
            //
            //  Remove the binding and indicate a receive complete
            //  if necessary.
            //
            XRemoveAndFreeBinding(Filter, LocalOpen);
        }
        else
        {
            //
            // Let the caller know that this "reference" to the open
            // is still "active".  The close action routine will be
            // called upon return from NdisIndicateReceive.
            //
            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return(StatusToReturn);
}

NDIS_STATUS
TrChangeFunctionalAddress(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UCHAR                   FunctionalAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFunctionalAddress routine will call an action
    routine when the overall functional address for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the functional address
    for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open

    FunctionalAddress - The new functional address for this binding.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    //
    // Holds the functional address as a longword.
    //
    TR_FUNCTIONAL_ADDRESS FunctionalAddress;

    //
    // Pointer to the open.
    //
    PTR_BINDING_INFO LocalOpen = (PTR_BINDING_INFO)NdisFilterHandle;

    //
    // Holds the status returned to the user of this routine, if the
    // action routine is not called then the status will be success,
    // otherwise, it is whatever the action routine returns.
    //
    NDIS_STATUS StatusOfAdjust;

    //
    // Simple iteration variable.
    //
    PTR_BINDING_INFO OpenList;


    UNREFERENCED_PARAMETER(Set);
    
    //
    // Convert the 32 bits of the address to a longword.
    //
    RetrieveUlong(&FunctionalAddress, FunctionalAddressArray);

    //
    // Set the new filter information for the open.
    //
    LocalOpen->OldFunctionalAddress = LocalOpen->FunctionalAddress;
    LocalOpen->FunctionalAddress = FunctionalAddress;

    //
    // Contains the value of the combined functional address before
    // it is adjusted.
    //
    Filter->OldCombinedFunctionalAddress = Filter->CombinedFunctionalAddress;

    //
    // We always have to reform the compbined filter since
    // this filter index may have been the only filter index
    // to use a particular bit.
    //

    for (OpenList = Filter->OpenList, Filter->CombinedFunctionalAddress = 0;
         OpenList != NULL;
         OpenList = OpenList->NextOpen)
    {
        Filter->CombinedFunctionalAddress |= OpenList->FunctionalAddress;
    }

    if (Filter->OldCombinedFunctionalAddress != Filter->CombinedFunctionalAddress)
    {
        StatusOfAdjust = NDIS_STATUS_PENDING;
    }
    else
    {
        StatusOfAdjust = NDIS_STATUS_SUCCESS;
    }

    return(StatusOfAdjust);
}

VOID
trUndoChangeFunctionalAddress(
    IN  PTR_FILTER              Filter,
    IN  PTR_BINDING_INFO        Binding
)
{
    //
    // The user returned a bad status.  Put things back as
    // they were.
    //
    Binding->FunctionalAddress = Binding->OldFunctionalAddress;
    Filter->CombinedFunctionalAddress = Filter->OldCombinedFunctionalAddress;
}



NDIS_STATUS
TrChangeGroupAddress(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UCHAR                   GroupAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeGroupAddress routine will call an action
    routine when the overall group address for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the group address
    for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

    GroupAddressArray - The new group address for this binding.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    //
    // Holds the Group address as a longword.
    //
    TR_FUNCTIONAL_ADDRESS GroupAddress;

    PTR_BINDING_INFO LocalOpen = (PTR_BINDING_INFO)NdisFilterHandle;

    UNREFERENCED_PARAMETER(Set);
    
    //
    // Convert the 32 bits of the address to a longword.
    //
    RetrieveUlong(&GroupAddress, GroupAddressArray);

    Filter->OldGroupAddress = Filter->GroupAddress;
    Filter->OldGroupReferences = Filter->GroupReferences;
    LocalOpen->OldUsingGroupAddress = LocalOpen->UsingGroupAddress;

    //
    //  If the new group address is 0 then a binding is
    //  attempting to delete the current group address.
    //
    if (0 == GroupAddress)
    {
        //
        //  Is the binding using the group address?
        //
        if (LocalOpen->UsingGroupAddress)
        {
            //
            //  Remove the bindings reference.
            //
            Filter->GroupReferences--;
            LocalOpen->UsingGroupAddress = FALSE;

            //
            //  Are any other bindings using the group address?
            //
            if (Filter->GroupReferences != 0)
            {
                //
                //  Since other bindings are using the group address
                //  we cannot tell the driver to remove it.
                //
                return(NDIS_STATUS_SUCCESS);
            }

            //
            //  We are the only binding using the group address
            //  so we fall through and call the driver to delete it.
            //
        }
        else
        {
            //
            //  This binding is not using the group address but
            //  it is trying to clear it.
            //
            if (Filter->GroupReferences != 0)
            {
                //
                //  There are other bindings using the group address
                //  so we cannot delete it.
                //
                return(NDIS_STATUS_GROUP_ADDRESS_IN_USE);
            }
            else
            {
                //
                //  There are no bindings using the group address.
                //
                return(NDIS_STATUS_SUCCESS);
            }
        }
    }
    else
    {
        //
        // See if this address is already the current address.
        //
        if (GroupAddress == Filter->GroupAddress)
        {
            //
            //  If the current binding is already using the
            //  group address then do nothing.
            //
            if (LocalOpen->UsingGroupAddress)
            {
                return(NDIS_STATUS_SUCCESS);
            }

            //
            //  If there are already bindings that are using the group
            //  address then we just need to update the bindings
            //  information.
            //
            if (Filter->GroupReferences != 0)
            {
                //
                //  We can take care of everything here...
                //
                Filter->GroupReferences++;
                LocalOpen->UsingGroupAddress = TRUE;

                return(NDIS_STATUS_SUCCESS);
            }
        }
        else
        {
            //
            //  If there are other bindings using the address then
            //  we can't change it.
            //
            if (Filter->GroupReferences > 1)
            {
                return(NDIS_STATUS_GROUP_ADDRESS_IN_USE);
            }

            //
            //  Is there only one binding using the address?
            //  If is it some other binding?
            //
            if ((Filter->GroupReferences == 1) &&
                (!LocalOpen->UsingGroupAddress))
            {
                //
                //  Some other binding is using the group address.
                //
                return(NDIS_STATUS_GROUP_ADDRESS_IN_USE);
            }

            //
            //  Is this the only binding using the address.
            //
            if ((Filter->GroupReferences == 1) &&
                (LocalOpen->UsingGroupAddress))
            {
                //
                //  Remove the reference.
                //
                Filter->GroupReferences = 0;
                LocalOpen->UsingGroupAddress = FALSE;
            }
        }
    }

    //
    // Set the new filter information for the open.
    //
    Filter->GroupAddress = GroupAddress;

    if (GroupAddress == 0)
    {
        LocalOpen->UsingGroupAddress = FALSE;
        Filter->GroupReferences = 0;
    }
    else
    {
        LocalOpen->UsingGroupAddress = TRUE;
        Filter->GroupReferences = 1;
    }

    return(NDIS_STATUS_PENDING);
}


VOID
trUndoChangeGroupAddress(
    IN  PTR_FILTER          Filter,
    IN  PTR_BINDING_INFO    Binding
    )
{
    //
    // The user returned a bad status.  Put things back as
    // they were.
    //
    Filter->GroupAddress = Filter->OldGroupAddress;
    Filter->GroupReferences = Filter->OldGroupReferences;

    Binding->UsingGroupAddress = Binding->OldUsingGroupAddress;
}


NDIS_STATUS
FASTCALL
ndisMSetFunctionalAddress(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        FunctionalAddress;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetFunctionalAddress\n"));

    //
    //  Verify the media type.
    //
    if (Miniport->MediaType != NdisMedium802_5)
    {
        Request->DATA.SET_INFORMATION.BytesRead = 0;
        Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        Status = NDIS_STATUS_NOT_SUPPORTED;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetFunctionalAddress: Invalid media type\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFunctionalAddress: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Verify the buffer length that was passed in.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(FunctionalAddress), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFunctionalAddress: 0x%x\n", Status));

        return(Status);
    }

    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        //  Call the filter library to set the functional address.
        //
        Status = TrChangeFunctionalAddress(
                     Miniport->TrDB,
                     PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                     (PUCHAR)(Request->DATA.SET_INFORMATION.InformationBuffer),
                     TRUE);
    }

    //
    //  If the filter library returned NDIS_STATUS_PENDING then we
    //  need to call down to the miniport driver.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Get the new combined functional address from the filter library
        //  and save it in a buffer that will stick around.
        //
        FunctionalAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_ADDRESSES(Miniport->TrDB));
        Miniport->RequestBuffer = FunctionalAddress;

        //
        //  Call the miniport driver.
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(FunctionalAddress));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we succeeded then update the request.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFunctionalAddress: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetGroupAddress(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        GroupAddress;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetGroupAddress\n"));

    //
    //  Verify the media type.
    //
    if (Miniport->MediaType != NdisMedium802_5)
    {
        Request->DATA.SET_INFORMATION.BytesRead = 0;
        Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        Status = NDIS_STATUS_NOT_SUPPORTED;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetGroupAddress: invalid media type\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetGroupAddress: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Verify the information buffer length.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(GroupAddress), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetGroupAddress: 0x%x\n", Status));

        return(Status);
    }

    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        //  Call the filter library to set the new group address.
        //
        Status = TrChangeGroupAddress(
                     Miniport->TrDB,
                     PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                     (PUCHAR)(Request->DATA.SET_INFORMATION.InformationBuffer),
                     TRUE);
    }

    //
    //  If the filter library returned NDIS_STATUS_PENDING then we
    //  need to call down to the miniport driver.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Get the new group address from the filter library
        //  and save it in a buffer that will stick around.
        //
        GroupAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
        Miniport->RequestBuffer = GroupAddress;

        //
        //  Call the miniport driver with the new group address.
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(GroupAddress));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we succeeded then update the request.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead =
                        Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetGroupAddress: 0x%x\n", Status));

    return(Status);
}

VOID
TrFilterDprIndicateReceive(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate a packet to
    all bindings.  The packet will be filtered so that only the
    appropriate bindings will receive the packet.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

    MacReceiveContext - A MAC supplied context value that must be
    returned by the protocol if it calls MacTransferData.

    HeaderBuffer - A virtual address of the virtually contiguous
    buffer containing the MAC header of the packet.

    HeaderBufferSize - An unsigned integer indicating the size of
    the header buffer, in bytes.

    LookaheadBuffer - A virtual address of the virtually contiguous
    buffer containing the first LookaheadBufferSize bytes of data
    of the packet.  The packet buffer is valid only within the current
    call to the receive event handler.

    LookaheadBufferSize - An unsigned integer indicating the size of
    the lookahead buffer, in bytes.

    PacketSize - An unsigned integer indicating the size of the received
    packet, in bytes.  This number has nothing to do with the lookahead
    buffer, but indicates how large the arrived packet is so that a
    subsequent MacTransferData request can be made to transfer the entire
    packet as necessary.

Return Value:

    None.

--*/
{
    //
    // The destination address in the lookahead buffer.
    //
    PUCHAR      DestinationAddress = (PUCHAR)HeaderBuffer + 2;

    //
    // The source address in the lookahead buffer.
    //
    PUCHAR      SourceAddress = (PUCHAR)HeaderBuffer + 8;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT        AddressType = 0;

    //
    // TRUE if the packet is source routing packet.
    //
    BOOLEAN     IsSourceRouting;

    //
    //  TRUE if the packet is a MAC frame packet.
    //
    BOOLEAN     IsMacFrame;

    //
    // The functional address as a longword, if the packet
    // is addressed to one.
    //
    TR_FUNCTIONAL_ADDRESS   FunctionalAddress = 0;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS             StatusOfReceive;

    //
    // Will hold the open being indicated.
    //
    PTR_BINDING_INFO        LocalOpen, NextOpen;

    LOCK_STATE              LockState;

    //
    // Holds intersection of open filters and this packet's type
    //
    UINT                    IntersectionOfFilters;

    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        NDIS_WARN(TRUE,
                  Filter->Miniport, 
                  NDIS_GFLAG_WARN_LEVEL_1,
                  ("TrFilterDprIndicateReceive: Miniport %p IndicateReceives with media disconnected\n",
                  Filter->Miniport));
        return;     
    }

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

#if DBG
    Filter->Miniport->cDpcRcvIndications++;
    Filter->Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // If the packet is a runt packet, then only indicate to PROMISCUOUS
    //
    if ((HeaderBufferSize >= 14) && (PacketSize != 0))
    {
        UINT    ResultOfAddressCheck;

        TR_IS_NOT_DIRECTED(DestinationAddress, &ResultOfAddressCheck);

        //
        //  Handle the directed packet case first
        //
        if (!ResultOfAddressCheck)
        {
            UINT    IsNotOurs;

            DIRECTED_PACKETS_IN(Filter->Miniport);
            DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);

            //
            // If it is a directed packet, then check if the combined packet
            // filter is PROMISCUOUS, if it is check if it is directed towards
            // us
            //
            IsNotOurs = FALSE;  // Assume it is
            if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                NDIS_PACKET_TYPE_ALL_FUNCTIONAL))
            {
                TR_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                DestinationAddress,
                                                &IsNotOurs);
            }

            //
            //  Walk the directed list and indicate up the packets.
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;

                //
                // Ignore if not directed to us and if the binding is not promiscuous
                //
                if (((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_PROMISCUOUS) == 0) &&
                    (IsNotOurs ||
                    ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                {
                        continue;
                }

                //
                // Indicate the packet to the binding.
                //
                ProtocolFilterIndicateReceive(&StatusOfReceive,
                                              LocalOpen->NdisBindingHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookaheadBuffer,
                                              LookaheadBufferSize,
                                              PacketSize,
                                              NdisMedium802_5);

                LocalOpen->ReceivedAPacket = TRUE;
            }

            READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
            return;
        }

        TR_IS_SOURCE_ROUTING(SourceAddress, &IsSourceRouting);
        IsMacFrame = TR_IS_MAC_FRAME(HeaderBuffer);

        //
        // First check if it *at least* has the functional address bit.
        //
        TR_IS_NOT_DIRECTED(DestinationAddress, &ResultOfAddressCheck);
        if (ResultOfAddressCheck)
        {
            //
            // It is at least a functional address.  Check to see if
            // it is a broadcast address.
            //
            TR_IS_BROADCAST(DestinationAddress, &ResultOfAddressCheck);
            if (ResultOfAddressCheck)
            {
                TR_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);

                AddressType = NDIS_PACKET_TYPE_BROADCAST;
            }
            else
            {
                TR_IS_GROUP(DestinationAddress, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    AddressType = NDIS_PACKET_TYPE_GROUP;
                }
                else
                {
                    AddressType = NDIS_PACKET_TYPE_FUNCTIONAL;
                }

                RetrieveUlong(&FunctionalAddress, (DestinationAddress + 2));
            }
        }
    }
    else
    {
        // Runt Packet
        AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
        IsSourceRouting = FALSE;
        IsMacFrame = FALSE;
    }


    //
    // At this point we know that the packet is either:
    // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
    // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
    // - Functional packet - indicated by AddressType = NDIS_PACKET_TYPE_FUNCTIONAL
    //
    // Walk the broadcast/functional list and indicate up the packets.
    //
    // The packet is indicated if it meets the following criteria:
    //
    // if ((Binding is promiscuous) OR
    //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
    //   ((Packet is functional) AND
    //    ((Binding is all-functional) OR
    //      ((Binding is functional) AND (binding using functional address)))) OR
    //      ((Packet is a group packet) AND (Intersection of filters uses group addresses)) OR
    //      ((Packet is a macframe) AND (Binding wants mac frames)) OR
    //      ((Packet is a source routing packet) AND (Binding wants source routing packetss)))
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        UINT    LocalFilter = LocalOpen->PacketFilters;

        IntersectionOfFilters = LocalFilter & AddressType;

        //
        //  Get the next open to look at.
        //
        NextOpen = LocalOpen->NextOpen;

        if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||

            ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
             (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||

            ((AddressType == NDIS_PACKET_TYPE_FUNCTIONAL)  &&
             ((LocalFilter & NDIS_PACKET_TYPE_ALL_FUNCTIONAL) ||
              ((LocalFilter & NDIS_PACKET_TYPE_FUNCTIONAL) &&
                (FunctionalAddress & LocalOpen->FunctionalAddress)))) ||

              ((IntersectionOfFilters & NDIS_PACKET_TYPE_GROUP) &&
                (LocalOpen->UsingGroupAddress)                  &&
                (FunctionalAddress == Filter->GroupAddress))    ||

            ((LocalFilter & NDIS_PACKET_TYPE_SOURCE_ROUTING) &&
             IsSourceRouting)                                   ||

            ((LocalFilter & NDIS_PACKET_TYPE_MAC_FRAME) &&
             IsMacFrame))
        {
            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMedium802_5);

            LocalOpen->ReceivedAPacket = TRUE;
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
trFilterDprIndicateReceivePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings.  The packets will be filtered so that only the
    appropriate bindings will receive the individual packets.
    This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport    - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    //
    // The Filter of interest
    //
    PTR_FILTER          Filter = Miniport->TrDB;

    //
    // Current packet being processed
    //
    PPNDIS_PACKET       pPktArray = PacketArray;
    PNDIS_PACKET        Packet;
    PNDIS_PACKET_OOB_DATA pOob;

    //
    // Pointer to the buffer in the ndispacket
    //
    PNDIS_BUFFER        Buffer;

    //
    // Pointer to the 1st segment of the buffer, points to dest address
    //
    PUCHAR              Address;

    //
    // Total packet length
    //
    UINT                i, LASize, PacketSize, NumIndicates = 0;

    //
    // The destination address in the lookahead buffer.
    //
    PUCHAR              DestinationAddress;

    //
    // The source address in the lookahead buffer.
    //
    PCHAR               SourceAddress;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType = 0;

    //
    // TRUE if the packet is source routing packet.
    //
    BOOLEAN             IsSourceRouting;

    //
    //  TRUE if the packet is a MAC frame packet.
    //
    BOOLEAN             IsMacFrame;

    //
    // The functional address as a longword, if the packet
    // is addressed to one.
    //
    TR_FUNCTIONAL_ADDRESS FunctionalAddress = 0;

    LOCK_STATE          LockState;

    //
    //  Decides whether we use the protocol's revpkt handler or fall
    //  back to old rcvindicate handler
    //
    BOOLEAN             fFallBack, fPmode;

    //
    // Will hold the open being indicated.
    //
    PTR_BINDING_INFO    LocalOpen, NextOpen;
    PNDIS_OPEN_BLOCK    pOpenBlock;
    PNDIS_STACK_RESERVED NSR;

#ifdef TRACK_RECEIVED_PACKETS
    ULONG               OrgPacketStackLocation;
    PETHREAD            CurThread = PsGetCurrentThread();
#endif
    

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

#if DBG
    Miniport->cDpcRcvIndications += NumberOfPackets;
    Miniport->cDpcRcvIndicationCalls++;
#endif

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        do
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);
#ifdef TRACK_RECEIVED_PACKETS
            OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif
            PUSH_PACKET_STACK(Packet);
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            ASSERT(NSR->RefCount == 0);
            //1 this does not check for current stack location for non-im drivers
            //1 to be -1 as we do for Ethernet
            if (NSR->RefCount != 0)
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");

                KeBugCheckEx(BUGCODE_NDIS_DRIVER,
                            0x12,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Packet,
                            (ULONG_PTR)PacketArray);
            }
    
            pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
            NdisGetFirstBufferFromPacket(Packet,
                                         &Buffer,
                                         &Address,
                                         &LASize,
                                         &PacketSize);
            ASSERT(Buffer != NULL);
    
            //
            // Set context in the packet so that NdisReturnPacket can do the right thing
            //
            NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
            //
            // Set the status here that nobody is holding the packet. This will get
            // overwritten by the real status from the protocol. Pay heed to what
            // the miniport is saying.
            //
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                pOob->Status = NDIS_STATUS_SUCCESS;
                fFallBack = FALSE;
            }
            else
            {
#if DBG
                if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                    MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                            ("Miniport going into D3, not indicating chained receives\n"));
                }
#endif
                fFallBack = TRUE;
            }
    
            //1 what are the first two bytes in token-ring header
            //
            // The destination address in the lookahead buffer.
            //
            DestinationAddress = (PUCHAR)Address + 2;
    
            //
            // The source address in the lookahead buffer.
            //
            SourceAddress = (PCHAR)Address + 8;
    
            // Determine if there is source routing info and compute hdr len
#if DBG     
            {
                UINT    HdrSize;
    
                HdrSize = 14;
                if (Address[8] & 0x80)
                {
                    HdrSize += (Address[14] & 0x1F);
                }
                ASSERT(HdrSize == pOob->HeaderSize);
            }
#endif      
            //
            // A quick check for Runt packets. These are only indicated to Promiscuous bindings
            //
            if (PacketSize >= pOob->HeaderSize)
            {
                UINT    ResultOfAddressCheck;
    
                //
                // If it is a directed packet, then check if the combined packet
                // filter is PROMISCUOUS, if it is check if it is directed towards us
                //
                TR_IS_NOT_DIRECTED(DestinationAddress, &ResultOfAddressCheck);
    
                //
                //  Handle the directed packet case first
                //
                if (!ResultOfAddressCheck)
                {
                    UINT    IsNotOurs;
    
                    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK))
                    {
                        DIRECTED_PACKETS_IN(Miniport);
                        DIRECTED_BYTES_IN(Miniport, PacketSize);
                    }

                    //
                    // If it is a directed packet, then check if the combined packet
                    // filter is PROMISCUOUS, if it is check if it is directed towards
                    // us
                    //
                    IsNotOurs = FALSE;  // Assume it is
                    if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                        NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                        NDIS_PACKET_TYPE_ALL_FUNCTIONAL))
                    {
                        TR_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                        DestinationAddress,
                                                        &IsNotOurs);
                    }
    
                    //
                    //  We definitely have a directed packet so lets indicate it now.
                    //
                    //  Walk the directed list and indicate up the packets.
                    //
                    for (LocalOpen = Filter->OpenList;
                         LocalOpen != NULL;
                         LocalOpen = NextOpen)
                    {
                        //
                        //  Get the next open to look at.
                        //
                        NextOpen = LocalOpen->NextOpen;
    
                        //
                        // Ignore if not directed to us and if the binding is not promiscuous
                        // Or if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                              NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                            TRUE : FALSE;

                        
                        if (!fPmode &&
                            (IsNotOurs || 
                            ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                        {
                                
                            continue;
                        }
    
                        if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                            (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                        {
                            continue;
                        }
    

                        pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                        LocalOpen->ReceivedAPacket = TRUE;
                        NumIndicates ++;
    
                        IndicateToProtocol(Miniport,
                                           Filter,
                                           pOpenBlock,
                                           Packet,
                                           NSR,
                                           Address,
                                           PacketSize,
                                           pOob->HeaderSize,
                                           &fFallBack,
                                           fPmode,
                                           NdisMedium802_5);
                    }
    
                    // Done with this packet
                    break;  // out of do { } while (FALSE);
                }
    
                TR_IS_SOURCE_ROUTING(SourceAddress, &IsSourceRouting);
                IsMacFrame = TR_IS_MAC_FRAME(Address);
    
                //
                // First check if it *at least* has the functional address bit.
                //
                TR_IS_NOT_DIRECTED(DestinationAddress, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    //
                    // It is at least a functional address.  Check to see if
                    // it is a broadcast address.
                    //
                    TR_IS_BROADCAST(DestinationAddress, &ResultOfAddressCheck);
                    if (ResultOfAddressCheck)
                    {
                        TR_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);
    
                        AddressType = NDIS_PACKET_TYPE_BROADCAST;
                    }
                    else
                    {
                        TR_IS_GROUP(DestinationAddress, &ResultOfAddressCheck);
                        if (ResultOfAddressCheck)
                        {
                            AddressType = NDIS_PACKET_TYPE_GROUP;
                        }
                        else
                        {
                            AddressType = NDIS_PACKET_TYPE_FUNCTIONAL;
                        }
    
                        RetrieveUlong(&FunctionalAddress, (DestinationAddress + 2));
                    }
                }
            }
            else
            {
                // Runt Packet
                AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
                IsSourceRouting = FALSE;
                IsMacFrame = FALSE;
            }
    
            //
            // At this point we know that the packet is either:
            // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
            // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
            // - Functional packet - indicated by AddressType = NDIS_PACKET_TYPE_FUNCTIONAL
            //
            // Walk the broadcast/functional list and indicate up the packets.
            //
            // The packet is indicated if it meets the following criteria:
            //
            // if ((Binding is promiscuous) OR
            //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
            //   ((Packet is functional) AND
            //    ((Binding is all-functional) OR
            //      ((Binding is functional) AND (binding using functional address)))) OR
            //      ((Packet is a group packet) AND (Intersection of filters uses group addresses)) OR
            //      ((Packet is a macframe) AND (Binding wants mac frames)) OR
            //      ((Packet is a source routing packet) AND (Binding wants source routing packetss)))
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                UINT    LocalFilter = LocalOpen->PacketFilters;
                UINT    IntersectionOfFilters = LocalFilter & AddressType;
    
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;
    
                if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                    (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                {
                    continue;
                }
    
                if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||
    
                    ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||
    
                    ((AddressType == NDIS_PACKET_TYPE_FUNCTIONAL)  &&
                     ((LocalFilter & NDIS_PACKET_TYPE_ALL_FUNCTIONAL) ||
                      ((LocalFilter & NDIS_PACKET_TYPE_FUNCTIONAL) &&
                        (FunctionalAddress & LocalOpen->FunctionalAddress)))) ||
    
                      ((IntersectionOfFilters & NDIS_PACKET_TYPE_GROUP) &&
                        (LocalOpen->UsingGroupAddress)                  &&
                        (FunctionalAddress == Filter->GroupAddress))    ||
    
                    ((LocalFilter & NDIS_PACKET_TYPE_SOURCE_ROUTING) &&
                     IsSourceRouting)                                   ||
    
                    ((LocalFilter & NDIS_PACKET_TYPE_MAC_FRAME) &&
                     IsMacFrame))
                {
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
    
                    fPmode = (LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                TRUE : FALSE;
                    
                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Address,
                                       PacketSize,
                                       pOob->HeaderSize,
                                       &fFallBack,
                                       fPmode,
                                       NdisMedium802_5);
                }
            }
        } while (FALSE);

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (LocalOpen = Filter->OpenList;
             LocalOpen != NULL;
             LocalOpen = NextOpen)
        {
            NextOpen = LocalOpen->NextOpen;
    
            if (LocalOpen->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                LocalOpen->ReceivedAPacket = FALSE;
    
                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
TrFilterDprIndicateReceiveComplete(
    IN  PTR_FILTER              Filter
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate that the receive
    process is done and to indicate to all protocols which received
    a packet that receive is complete.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{
    PTR_BINDING_INFO    LocalOpen, NextOpen;
    LOCK_STATE          LockState;

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // We need to aquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //
            LocalOpen->ReceivedAPacket = FALSE;

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


BOOLEAN
TrShouldAddressLoopBack(
    IN  PTR_FILTER              Filter,
    IN  UCHAR                   DestinationAddress[TR_LENGTH_OF_ADDRESS],
    IN  UCHAR                   SourceAddress[TR_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    Do a quick check to see whether the input address should
    loopback.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: THIS ROUTINE DOES NOT CHECK THE SPECIAL CASE OF SOURCE
    EQUALS DESTINATION.

Arguments:

    Filter - Pointer to the filter database.

    Address - A network address to check for loopback.


Return Value:

    Returns TRUE if the address is *likely* to need loopback.  It
    will return FALSE if there is *no* chance that the address would
    require loopback.

--*/
{
    BOOLEAN fLoopback, fSelfDirected;

    TrShouldAddressLoopBackMacro(Filter,
                                 DestinationAddress,
                                 SourceAddress,
                                 &fLoopback,
                                 &fSelfDirected);

    return(fLoopback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\sendm.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    sendm.c

Abstract:

Author:

    Jameel Hyder (JameelH)
    Kyle Brandon (KyleB)

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_SENDM

///////////////////////////////////////////////////////////////////////////////////////
//
//                      UPPER-EDGE SEND HANDLERS
//
///////////////////////////////////////////////////////////////////////////////////////
VOID
ndisMSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    BOOLEAN                 LocalLock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    UINT                    c;
    PPNDIS_PACKET           pPktArray;;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPackets\n"));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    //
    //  Place the packets on the miniport queue.
    //
    for (c = 0, pPktArray = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;
        ASSERT(Packet != NULL);

        ASSERT(Packet->Private.Head != NULL);
        
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

        if (Packet->Private.Head == NULL)
        {
            Status = NDIS_STATUS_FAILURE;

        }
        else
        {

            if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
            {
                ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
            }
            else
            {
                ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
            }
        }

        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_PENDING);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);

        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        LINK_PACKET(Miniport, Packet, NSR, Open);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 0);
            Status = NDIS_STATUS_SUCCESS;
        }
        else if (Miniport->FirstPendingPacket == NULL)
        {
            Miniport->FirstPendingPacket = Packet;
        }

    }

    //
    //  Queue a workitem for the new sends.
    //
    NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

    LOCK_MINIPORT(Miniport, LocalLock);
    if (LocalLock)
    {
        //
        //  We have the local lock
        //
        NDISM_PROCESS_DEFERRED(Miniport);
        UNLOCK_MINIPORT(Miniport, LocalLock);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPackets\n"));
}

VOID
ndisMSendPacketsX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray, pSend;
    NDIS_STATUS             Status;
    UINT                    c, k = 0, Flags;
    BOOLEAN                 SelfDirected;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPacketsX\n"));

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

    Status = NDIS_STATUS_SUCCESS ;

    for (c = k =  0, pPktArray = pSend = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;

        //
        //  Initialize the packets with the Open
        //
        ASSERT(Packet != NULL);
        ASSERT(Packet->Private.Head != NULL);

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        NSR->Open = Open;
        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
        
        NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }


        SelfDirected = FALSE;
        
        if (Status == NDIS_STATUS_SUCCESS)
        {

            //
            // if PmodeOpens > 0 and NumOpens > 1, then check to see if we should 
            // loop back the packet.
            //
            // we should also should loopback the packet if the protocol did not
            // explicitly asked for the packet not to be looped back and we have a miniport
            // that has indicated that it does not do loopback itself or it is in all_local
            // mode
            //
            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {                
                //
                // Handle loopback
                //
                SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);                
                 
            }            
        }

        //
        // Is this self-directed or if we should drop it due to low-resources?
        //
        if ((Status != NDIS_STATUS_SUCCESS) ||
            MINIPORT_TEST_PACKET_FLAG((Packet), fPACKET_SELF_DIRECTED) ||
            SelfDirected)
        {
            //
            //  Complete the packet back to the protocol.
            //
            ndisMSendCompleteX(Miniport, Packet, Status);

            if (k > 0)
            {
                ASSERT(MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY));

                //
                // Send down the packets so far and skip this one.
                //
                (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                           pSend,
                                           k);
    
                pSend = pPktArray + 1;
                k = 0;
            }
        }
        else
        {
            //
            // This needs to go on the wire
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
            {
                ndisMAllocSGList(Miniport, Packet);
            }
            else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
            {
                MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
                k++;
            }
            else
            {
                NDIS_STATUS SendStatus;

                //
                //  We need to send this down right away
                //
                NdisQuerySendFlags(Packet, &Flags);
                MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
                SendStatus = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);

                //
                //  If the packet is not pending then complete it.
                //
                if (SendStatus != NDIS_STATUS_PENDING)
                {
                    ndisMSendCompleteX(Miniport, Packet, SendStatus);
                }
            }
        }
    }

    //
    //  Pass the remaining packet array down to the miniport.
    //
    if (k > 0)
    {
        ASSERT(MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY));
        (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                   pSend,
                                   k);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPacketsX\n"));
}


NDIS_STATUS
ndisMSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSend\n"));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT(Packet->Private.Head != NULL);

    CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        //1 do we need to do this for miniports that support stat OID
        //1 for bytes out?
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }
    
    if (Status == NDIS_STATUS_SUCCESS)
    {
        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    
        //
        //  Increment the references on this open.
        //
        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        
    
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->References));
    
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        LINK_PACKET(Miniport, Packet, NSR, Open);
    
        if (Miniport->FirstPendingPacket == NULL)
        {
            Miniport->FirstPendingPacket = Packet;
        }
        
        //
        //  If we have the local lock and there is no
        //  packet pending, then fire off a send.
        //
        LOCK_MINIPORT(Miniport, LocalLock);
    
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        if (LocalLock)
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }
        Status = NDIS_STATUS_PENDING;
    
        UNLOCK_MINIPORT(Miniport, LocalLock);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSend\n"));

    return Status;
}


NDIS_STATUS
ndisMSendX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    UINT                    Flags;
    UINT                    OpenRef;
    NDIS_STATUS             Status;
    BOOLEAN                 SelfDirected;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendX\n"));

    ASSERT(Packet->Private.Head != NULL);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        return NDIS_STATUS_RESOURCES;
    }

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

    //
    //  Initialize the packet info.
    //
    PUSH_PACKET_STACK(Packet);
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    NSR->Open = Open;

    //
    //  Increment the references on this open.
    //
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
        ("+ Open 0x%x Reference 0x%x\n", Open, Open->References));


    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

    //
    // HANDLE loopback
    //

    if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
    {
        SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);
    }
    else
    {
        SelfDirected = FALSE;
    }

    if ((!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED)) &&
        (!SelfDirected))
    {
        //
        // Does the driver support the SG method ?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
        {
            ndisMAllocSGList(Miniport, Packet);
        }

        //
        // Handle Send/SendPacket differently
        //
        else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
        {
            //
            //  Pass the packet down to the miniport.
            //
            (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                       &Packet,
                                       1);
        }
        else
        {
            NdisQuerySendFlags(Packet, &Flags);
            MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
            //1 what is in the Flags parameter below?
            Status = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);
    
            if (Status != NDIS_STATUS_PENDING)
            {
                ndisMSendCompleteX(Miniport, Packet, Status);
            }
        }

        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        //  Remove the reference added earlier.
        //
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("- Open 0x%x Reference 0x%x\n", Open, Open->References));
        
        M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);

        /*
         * Make sure that an IM which shares send and receive packets on the same
         * pool works fine with the check in the receive path.
         */
        NSR->RefCount = 0;
        POP_PACKET_STACK(Packet);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
        
        Status = NDIS_STATUS_SUCCESS;
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMSendX\n"));

    return(Status);
}


VOID
NdisMSendComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_STACK_RESERVED    NSR;

    ASSERT_MINIPORT_LOCKED(Miniport);

#if DBG
    Miniport->cDpcSendCompletes++;
#endif

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendComplete\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT(Packet->Private.Head != NULL);

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    ASSERT(VALID_OPEN(NSR->Open));
    ASSERT(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING));

    //
    // Guard against double/bogus completions.
    //
    if (VALID_OPEN(NSR->Open) &&
        MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))
    {
        ASSERT(Packet != Miniport->FirstPendingPacket);
        if (MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE))
        {
            //
            // If the packet completed in the context of a SendPackets, then
            // defer completion. It will get completed when we unwind.
            //
            NDIS_SET_PACKET_STATUS(Packet, Status);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);
        }
        else
        {
            NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, FALSE, 1);
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendComplete\n"));
}


VOID
ndisMSendCompleteX(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_OPEN_BLOCK        Open;
    UINT                    OpenRef;
    KIRQL                   OldIrql;

#if DBG
    Miniport->cDpcSendCompletes++;
#endif

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendCompleteX\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT(Packet->Private.Head != NULL);

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
        (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
    {
        ndisMFreeSGList(Miniport, Packet);        
    }

    //
    // Indicate to Protocol;
    //
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    POP_PACKET_STACK(Packet);

    Open = NSR->Open;
    ASSERT(VALID_OPEN(Open));
    NSR->Open = MAGIC_OPEN_I(6);

#if ARCNET
    ASSERT (Miniport->MediaType != NdisMediumArcnet878_2);
#endif

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
    
    /*
     * Make sure that an IM which shares send and receive packets on the same
     * pool works fine with the check in the receive path.
     */
    CLEAR_WRAPPER_RESERVED(NSR);

    (Open->SendCompleteHandler)(Open->ProtocolBindingContext,
                                Packet,
                                Status);

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

    M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
        ("==0 Open 0x%x Reference 0x%x\n", Open, Open->References));

    if (OpenRef == 0)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMFinishClose(Open);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendCompleteX\n"));
}

BOOLEAN
FASTCALL
ndisMStartSendPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_PACKET            Packet;
    NDIS_STATUS             Status;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray;
    PNDIS_PACKET            PacketArray[SEND_PACKET_ARRAY];
    UINT                    MaxPkts = Miniport->MaxSendPackets;
    W_SEND_PACKETS_HANDLER  SendPacketsHandler = Miniport->WSendPacketsHandler;
    BOOLEAN                 SelfDirected;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendPackets\n"));

    //
    // We could possibly end up with a situation (with intermediate serialized
    // miniports) where there are no packets down with the driver and we the
    // resource window is closed. In such a case open it fully. We are seeing this
    // with wlbs
    //
    //1 do we need this any more? we don't support serialized IM drivers
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE) &&
        (Miniport->FirstPendingPacket == NULL))
    {
        ADD_RESOURCE(Miniport, 'X');
    }

    //
    // Work-around for a scenario we are hitting when PacketList is empty but FirstPendingPacket is NOT
    // Not sure how this can happen - yet.
    //
    if (IsListEmpty(&Miniport->PacketList))
    {
        ASSERT (Miniport->FirstPendingPacket == NULL);
        Miniport->FirstPendingPacket = NULL;
    }

    while ((Miniport->FirstPendingPacket != NULL) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        UINT            Count;
        UINT            NumberOfPackets;

        ASSERT(!IsListEmpty(&Miniport->PacketList));

        //
        //  Initialize the packet array.
        //
        pPktArray = PacketArray;

        //
        //  Place as many packets as we can in the packet array to send
        //  to the miniport.
        //
        for (NumberOfPackets = 0;
             (NumberOfPackets < MaxPkts) && (Miniport->FirstPendingPacket != NULL);
             NOTHING)
        {
            //
            //  Grab the packet off of the pending queue.
            //
            ASSERT(!IsListEmpty(&Miniport->PacketList));

            Packet = Miniport->FirstPendingPacket;
            ASSERT(Packet->Private.Head != NULL);

            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
            
            ASSERT(VALID_OPEN(NSR->Open));

            NEXT_PACKET_PENDING(Miniport, Packet);
        
            //
            // Indicate the packet loopback if necessary.
            //

            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {
                //
                // make sure the packet does not get looped back at lower levels.
                // we will restore the original flag on send completion
                //

                SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);
            }
            else
            {
                SelfDirected = FALSE;
            }

            if (SelfDirected)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Packet 0x%x is self-directed.\n", Packet));

                //
                //  Complete the packet back to the binding.
                //
                NDISM_COMPLETE_SEND(Miniport, Packet, NSR, NDIS_STATUS_SUCCESS, TRUE, 2);

                //
                //  No, we don't want to increment the counter for the
                //  miniport's packet array.
                //
            }
            else
            {
                //
                //  We have to re-initialize this.
                //
                *pPktArray = Packet;
                MINIPORT_SET_PACKET_FLAG(Packet, (fPACKET_DONT_COMPLETE | fPACKET_PENDING));
                NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

                //
                //  Increment the counter for the packet array index.
                //
                NumberOfPackets++;
                pPktArray++;
            }
        }

        //
        //  Are there any packets to send?
        //
        if (NumberOfPackets == 0)
        {
            break;
        }

        pPktArray = PacketArray;

        {

            //
            //  Pass the packet array down to the miniport.
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (SendPacketsHandler)(Miniport->MiniportAdapterContext,
                                 pPktArray,
                                 NumberOfPackets);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the packet completion.
        //
        for (Count = 0; Count < NumberOfPackets; Count++, pPktArray++)
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            Status = NDIS_GET_PACKET_STATUS(*pPktArray);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);

            //
            //  Process the packet based on it's return status.
            //
            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Complete is pending\n"));
            }
            else if (Status != NDIS_STATUS_RESOURCES)
            {
                //
                //  Remove from the finish queue.
                //
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                        ("Completed packet 0x%x with status 0x%x\n",
                        Packet, Status));

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                if (VALID_OPEN(NSR->Open))
                {
                    NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 3);
                }
            }
            else
            {
                //
                //  Once we hit a return code of NDIS_STATUS_RESOURCES
                //  for a packet then we must break out and re-queue.
                //
                UINT    i;

                Miniport->FirstPendingPacket = Packet;
                CLEAR_RESOURCE(Miniport, 'S');
                for (i = Count; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET    QueuedPacket = PacketArray[i];

                    MINIPORT_CLEAR_PACKET_FLAG(QueuedPacket, fPACKET_PENDING);
                    VALIDATE_PACKET_OPEN(QueuedPacket);
                }
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendPackets\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMStartSends(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    If there are more packets to send but no resources to do it with
    the this is TRUE to keep a workitem queue'd.

--*/
{
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSends\n"));

    while ((Miniport->FirstPendingPacket != NULL) &&
           MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        //
        //  Grab the packet off of the pending queue.
        //
        ASSERT(!IsListEmpty(&Miniport->PacketList));
    
        Packet = Miniport->FirstPendingPacket;

        ASSERT(Packet->Private.Head != NULL);

        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

#if ARCNET
        //
        //  Is this arcnet using ethernet encapsulation ?
        //
        if (Miniport->MediaType == NdisMediumArcnet878_2)
        {
            //
            //  Build the header for arcnet.
            //
            Status = ndisMBuildArcnetHeader(Miniport, Open, Packet);
            if (NDIS_STATUS_PENDING == Status)
            {
                break;
            }
        }
#endif  
        NEXT_PACKET_PENDING(Miniport, Packet);

        NDISM_SEND_PACKET(Miniport, Open, Packet, &Status);

        //
        //  Process the packet pending completion status.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO, ("Complete is pending\n"));
        }
        else
        {
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);

            //
            //  Handle the completion and resources cases.
            //
            if (Status == NDIS_STATUS_RESOURCES)
            {
                NDISM_COMPLETE_SEND_RESOURCES(Miniport, NSR, Packet);
            }
            else
            {
                NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 4);
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSends\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMIsLoopbackPacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_PACKET    *       LoopbackPacket  OPTIONAL
    )
/*++

Routine Description:

    This routine will determine if a packet needs to be looped back in
    software.   if the packet is any kind of loopback packet then it
    will get placed on the loopback queue and a workitem will be queued
    to process it later.

Arguments:

    Miniport-   Pointer to the miniport block to send the packet on.
    Packet  -   Packet to check for loopback.

Return Value:

    Returns TRUE if the packet is self-directed.

--*/
{
    PNDIS_BUFFER    FirstBuffer;
    UINT            Length;
    UINT            Offset;
    PUCHAR          BufferAddress;
    BOOLEAN         Loopback;
    BOOLEAN         SelfDirected, NotDirected;
    PNDIS_PACKET    pNewPacket = NULL;
    PUCHAR          Buffer;
    NDIS_STATUS     Status;
    PNDIS_BUFFER    pNdisBuffer = NULL;
    UINT            HdrLength;
    LOCK_STATE      LockState;

    //
    //  We should not be here if the driver handles loopback.
    //

    Loopback = FALSE;
    SelfDirected = FALSE;
    FirstBuffer = Packet->Private.Head;
    BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);
    if (BufferAddress == NULL)
    {
        if (ARGUMENT_PRESENT(LoopbackPacket))
            *LoopbackPacket = NULL;
        return(FALSE);
    }

    //
    // If the card does not do loopback, then we check if we need to send it to ourselves,
    // then if that is the case we also check for it being self-directed.
    //
    switch (Miniport->MediaType)
    {
      case NdisMedium802_3:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            if (!ETH_IS_MULTICAST(BufferAddress))
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress,
                                                 Miniport->EthDB->AdapterAddress,
                                                 &NotDirected);

                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->EthDB, &LockState);

        //
        //  Check for the miniports that don't do loopback.
        //  
        EthShouldAddressLoopBackMacro(Miniport->EthDB,
                                      BufferAddress,
                                      &Loopback,
                                      &SelfDirected);
        READ_UNLOCK_FILTER(Miniport, Miniport->EthDB, &LockState);

        break;

      case NdisMedium802_5:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            TR_IS_NOT_DIRECTED(BufferAddress + 2, &NotDirected);
            if (!NotDirected)
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                TR_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress + 2,
                                                Miniport->TrDB->AdapterAddress,
                                                &NotDirected);
                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->TrDB, &LockState);
        
        TrShouldAddressLoopBackMacro(Miniport->TrDB,
                                     BufferAddress +2,
                                     BufferAddress +8,
                                     &Loopback,
                                     &SelfDirected);
        
        READ_UNLOCK_FILTER(Miniport, Miniport->TrDB, &LockState);
        break;

      case NdisMediumFddi:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            BOOLEAN IsMulticast;

            FDDI_IS_MULTICAST(BufferAddress + 1,
                              (BufferAddress[0] & 0x40) ?
                                            FDDI_LENGTH_OF_LONG_ADDRESS : FDDI_LENGTH_OF_SHORT_ADDRESS,
                              &IsMulticast);
            if (!IsMulticast)
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress + 1,
                                                  (BufferAddress[0] & 0x40) ?
                                                    Miniport->FddiDB->AdapterLongAddress : Miniport->FddiDB->AdapterShortAddress,
                                                  (BufferAddress[0] & 0x40) ?
                                                    FDDI_LENGTH_OF_LONG_ADDRESS : FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &NotDirected);
                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->FddiDB, &LockState);

        FddiShouldAddressLoopBackMacro(Miniport->FddiDB,
                                       BufferAddress + 1,  // Skip FC byte to dest address.
                                       (BufferAddress[0] & 0x40) ?
                                            FDDI_LENGTH_OF_LONG_ADDRESS :
                                            FDDI_LENGTH_OF_SHORT_ADDRESS,
                                        &Loopback,
                                        &SelfDirected);

        READ_UNLOCK_FILTER(Miniport, Miniport->FddiDB, &LockState);
        break;
    
#if ARCNET
      case NdisMediumArcnet878_2:

        //
        //  We just handle arcnet packets (encapsulated or not) in
        //   a totally different manner...
        //
        SelfDirected = ndisMArcnetSendLoopback(Miniport, Packet);

        //
        //  Mark the packet as having been looped back.
        //
        return(SelfDirected);
        break;
#endif
    }

    if (Loopback && (NdisGetPacketFlags(Packet) & NDIS_FLAGS_LOOPBACK_ONLY))
    {
        SelfDirected = TRUE;
    }

    //
    // Mark packet with reserved bit to indicate that it is self-directed
    //
    if (SelfDirected)
    {
        MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    }

    //
    //  If it is not a loopback packet then get out of here.
    //
    if (!Loopback)
    {
        ASSERT(!SelfDirected);
        return (NdisGetPacketFlags(Packet) & NDIS_FLAGS_LOOPBACK_ONLY) ? TRUE : FALSE;
    }

    do
    {
        PNDIS_STACK_RESERVED NSR;
        UINT    PktSize;
        ULONG   j;


        //
        //
        //  Get the buffer length.
        //
        NdisQueryPacketLength(Packet, &Length);
        Offset = 0;

        //
        //  Allocate a buffer for the packet.
        //
        PktSize = NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET);
        pNewPacket = (PNDIS_PACKET)ALLOC_FROM_POOL(Length + PktSize, NDIS_TAG_LOOP_PKT);
        if (NULL == pNewPacket)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        //  Get a pointer to the destination buffer.
        //
        ZeroMemory(pNewPacket, PktSize);
        Buffer = (PUCHAR)pNewPacket + PktSize;
        pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket + SIZE_PACKET_STACKS);

        for (j = 0; j < ndisPacketStackSize; j++)
        {
            CURR_STACK_LOCATION(pNewPacket) = j;
            NDIS_STACK_RESERVED_FROM_PACKET(pNewPacket, &NSR);
            INITIALIZE_SPIN_LOCK(&NSR->Lock);
        }

        CURR_STACK_LOCATION(pNewPacket) = (ULONG)-1;

        //
        //  Allocate an MDL for the packet.
        //
        NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, Buffer, Length);
        if (NDIS_STATUS_SUCCESS != Status)
        {    
            break;
        }
    
        //
        //  NdisChainBufferAtFront()
        //
        pNewPacket->Private.Head = pNdisBuffer;
        pNewPacket->Private.Tail = pNdisBuffer;
        pNewPacket->Private.Pool = (PVOID)'pooL';
        pNewPacket->Private.NdisPacketOobOffset = (USHORT)(PktSize - (SIZE_PACKET_STACKS +
                                                                      sizeof(NDIS_PACKET_OOB_DATA) +
                                                                      sizeof(NDIS_PACKET_EXTENSION)));
        NDIS_SET_ORIGINAL_PACKET(pNewPacket, pNewPacket);

        ndisMCopyFromPacketToBuffer(Packet,     // Packet to copy from.
                                    Offset,     // Offset from beginning of packet.
                                    Length,     // Number of bytes to copy.
                                    Buffer,     // The destination buffer.
                                    &HdrLength);//  The number of bytes copied.

        if (HdrLength != Length)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        if (ARGUMENT_PRESENT(LoopbackPacket))
        {
            *LoopbackPacket = pNewPacket;
            MINIPORT_SET_PACKET_FLAG(pNewPacket, fPACKET_IS_LOOPBACK);
            pNewPacket->Private.Flags = NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK;
            pNewPacket->Private.Flags |= NDIS_FLAGS_IS_LOOPBACK_PACKET;
        }
    } while (FALSE);

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != pNewPacket)
        {
            pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket - SIZE_PACKET_STACKS);
            FREE_POOL(pNewPacket);
        }

        if (pNdisBuffer != NULL)
        {
            NdisFreeBuffer(pNdisBuffer);
        }
    
        *LoopbackPacket = NULL;
        SelfDirected = FALSE;
    }
    
    return SelfDirected;
}

BOOLEAN
FASTCALL
ndisMLoopbackPacketX(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_PACKET            LoopbackPacket = NULL;
    PNDIS_PACKET_OOB_DATA   pOob;
    PNDIS_STACK_RESERVED    NSR;
    PUCHAR                  BufferAddress;
    KIRQL                   OldIrql = PASSIVE_LEVEL;
    BOOLEAN                 fSelfDirected;

    fSelfDirected = !MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_ALREADY_LOOPEDBACK) &&
                    ndisMIsLoopbackPacket(Miniport, Packet, &LoopbackPacket);

    if ((LoopbackPacket != NULL) && (NdisMediumArcnet878_2 != Miniport->MediaType))
    {
        MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_ALREADY_LOOPEDBACK);
        pOob = NDIS_OOB_DATA_FROM_PACKET(LoopbackPacket);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
        pOob->Status = NDIS_STATUS_RESOURCES;
        PNDIS_LB_REF_FROM_PNDIS_PACKET(LoopbackPacket)->Open = NSR->Open;

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            RAISE_IRQL_TO_DISPATCH(&OldIrql);
        }
        
        //
        // For ethernet/token-ring/fddi/encapsulated arc-net, we want to
        // indicate the packet using the receivepacket way.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:
            pOob->HeaderSize = 14;
            ethFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;
        
          case NdisMedium802_5:
            pOob->HeaderSize = 14;
            BufferAddress = (PUCHAR)LoopbackPacket + NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET) - SIZE_PACKET_STACKS;
            if (BufferAddress[8] & 0x80)
            {
                pOob->HeaderSize += (BufferAddress[14] & 0x1F);
            }
            trFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;
        
          case NdisMediumFddi:
            BufferAddress = (PUCHAR)LoopbackPacket + NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET) - SIZE_PACKET_STACKS;
            pOob->HeaderSize = (*BufferAddress & 0x40) ?
                                    2 * FDDI_LENGTH_OF_LONG_ADDRESS + 1:
                                    2 * FDDI_LENGTH_OF_SHORT_ADDRESS + 1;

            fddiFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;

          default:
            ASSERT(0);
            break;
        }

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }
        else
        {
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }

        ASSERT(NDIS_GET_PACKET_STATUS(LoopbackPacket) != NDIS_STATUS_PENDING);
        NdisFreeBuffer(LoopbackPacket->Private.Head);
        LoopbackPacket = (PNDIS_PACKET)((PUCHAR)LoopbackPacket - SIZE_PACKET_STACKS);
        FREE_POOL(LoopbackPacket);
    }

    return(fSelfDirected);
}


VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This function indicates that some send resources are available and are free for
    processing more sends.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendResourcesAvailable\n"));

    ASSERT(MINIPORT_AT_DPC_LEVEL);


    ADD_RESOURCE(Miniport, 'V');

    //
    //  Are there more sends to process?
    //
    if (Miniport->FirstPendingPacket != NULL)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        ASSERT(!IsListEmpty(&Miniport->PacketList));
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMSendResourcesAvailable\n"));
}


VOID
NdisMTransferDataComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    )
/*++

Routine Description:

    This function indicates the completion of a transfer data request.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Packet - The packet the data was copied into.

    Status - Status of the operation.

    BytesTransferred - Total number of bytes transferred.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open = NULL;
    KIRQL                OldIrql = PASSIVE_LEVEL;

    ASSERT_MINIPORT_LOCKED(Miniport);

//    GET_CURRENT_XFER_DATA_PACKET_STACK(Packet, Open);
    GET_CURRENT_XFER_DATA_PACKET_STACK_AND_ZERO_OUT(Packet, Open);

    if (Open)
    {
        POP_XFER_DATA_PACKET_STACK(Packet);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            RAISE_IRQL_TO_DISPATCH(&OldIrql);
        }


        //
        // Indicate to Protocol;
        //

        (Open->TransferDataCompleteHandler)(Open->ProtocolBindingContext,
                                            Packet,
                                            Status,
                                            BytesTransferred);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }
    }
}


NDIS_STATUS
ndisMTransferData(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN  OUT PNDIS_PACKET        Packet,
    OUT PUINT                   BytesTransferred
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // Handle non-loopback (non-indicated) as the default case.
    //
    if ((MacReceiveContext == INDICATED_PACKET(Miniport)) &&
        (INDICATED_PACKET(Miniport) != NULL))
    {
        PNDIS_PACKET_OOB_DATA   pOob;

        //
        // This packet is a indicated (or possibly a loopback) packet
        //
        pOob = NDIS_OOB_DATA_FROM_PACKET((PNDIS_PACKET)MacReceiveContext);
        NdisCopyFromPacketToPacketSafe(Packet,
                                       0,
                                       BytesToTransfer,
                                       (PNDIS_PACKET)MacReceiveContext,
                                       ByteOffset + pOob->HeaderSize,
                                       BytesTransferred,
                                       NormalPagePriority);
    
        Status = (*BytesTransferred == BytesToTransfer) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
    }
    else
    {
        PUSH_XFER_DATA_PACKET_STACK(Packet);
        
        if (CONTAINING_RECORD(Packet, NDIS_PACKET_WRAPPER, Packet)->StackIndex.XferDataIndex >= 3 * ndisPacketStackSize)
        {
            POP_XFER_DATA_PACKET_STACK(Packet);
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            PNDIS_BUFFER    Buffer = Packet->Private.Head;
            
            Status = NDIS_STATUS_SUCCESS;

            if (!MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
            {
                //
                // miniport will not use safe APIs
                // so map the buffers in destination packet
                //
                Buffer = Packet->Private.Head;

                while (Buffer != NULL)
                {
                    if (MDL_ADDRESS_SAFE(Buffer, HighPagePriority) == NULL)
                    {
                        Status = NDIS_STATUS_RESOURCES;
                        break;
                    }
                    Buffer = Buffer->Next;
                }
            }
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                SET_CURRENT_XFER_DATA_PACKET_STACK(Packet, Open)

                //
                // Call Miniport.
                //
                Status = (Open->WTransferDataHandler)(Packet,
                                                      BytesTransferred,
                                                      Open->MiniportAdapterContext,
                                                      MacReceiveContext,
                                                      ByteOffset,
                                                      BytesToTransfer);
                if (Status != NDIS_STATUS_PENDING)
                {
                    SET_CURRENT_XFER_DATA_PACKET_STACK(Packet, 0);
                    POP_XFER_DATA_PACKET_STACK(Packet);
                }
            }
        }
    }

    return Status;
}


NDIS_STATUS
ndisMWanSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PNDIS_WAN_PACKET        Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock = FALSE;
    KIRQL                   OldIrql = PASSIVE_LEVEL;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMWanSend\n"));

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING))
    {
        return NDIS_STATUS_FAILURE;
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        LOCK_MINIPORT(Miniport, LocalLock);
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) || LocalLock)
    {
        //
        // Call Miniport to send WAN packet
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        Status = (Miniport->DriverHandle->MiniportCharacteristics.WanSendHandler)(
                            Miniport->MiniportAdapterContext,
                            NdisLinkHandle,
                            Packet);

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the status of the send.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: send is pending\n"));
        }
        else
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: Completed 0x%x\n", Status));
        }
    }
    else
    {
        LINK_WAN_PACKET(Miniport, Packet);
        Packet->MacReserved1 = NdisLinkHandle;
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

        if (LocalLock)
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }
        Status = NDIS_STATUS_PENDING;
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        UNLOCK_MINIPORT(Miniport, LocalLock);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMWanSend\n"));

    return Status;
}


VOID
NdisMWanSendComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_WAN_PACKET        Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql = PASSIVE_LEVEL;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMWanSendComplete\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT_MINIPORT_LOCKED(Miniport);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    for (Open = Miniport->OpenQueue; Open != NULL; Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to complete open
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        (Open->ProtocolHandle->ProtocolCharacteristics.WanSendCompleteHandler)(
            Open->ProtocolBindingContext,
            Packet,
            Status);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMWanSendComplete\n"));
}

BOOLEAN
FASTCALL
ndisMStartWanSends(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the WAN mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    None

--*/
{
    PNDIS_WAN_PACKET        Packet;
    PLIST_ENTRY             Link;
    NDIS_STATUS             Status;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSends\n"));

    while (!IsListEmpty(&Miniport->PacketList))
    {
        Link = Miniport->PacketList.Flink;
        Packet = CONTAINING_RECORD(Link, NDIS_WAN_PACKET, WanPacketQueue);
        UNLINK_WAN_PACKET(Packet);

        //
        // Call Miniport to send WAN packet
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        Status = (Miniport->DriverHandle->MiniportCharacteristics.WanSendHandler)(
                            Miniport->MiniportAdapterContext,
                            Packet->MacReserved1,
                            Packet);

        //
        //  Process the status of the send.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: send is pending\n"));
        }
        else
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: Completed 0x%x\n", Status));
            NdisMWanSendComplete(Miniport, Packet, Status);
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSends\n"));

    return(FALSE);
}


VOID
ndisMCopyFromPacketToBuffer(
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Offset,
    IN  UINT                    BytesToCopy,
    OUT PUCHAR                  Buffer,
    OUT PUINT                   BytesCopied
    )
/*++

Routine Description:

    Copy from an ndis packet into a buffer.

Arguments:

    Packet - The packet to copy from.

    Offset - The offset from which to start the copy.

    BytesToCopy - The number of bytes to copy from the packet.

    Buffer - The destination of the copy.

    BytesCopied - The number of bytes actually copied.  Can be less then
    BytesToCopy if the packet is shorter than BytesToCopy.

Return Value:

    None

--*/
{
    //
    // Holds the number of ndis buffers comprising the packet.
    //
    UINT NdisBufferCount;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER CurrentBuffer;

    //
    // Holds the virtual address of the current buffer.
    //
    PVOID VirtualAddress;

    //
    // Holds the length of the current buffer of the packet.
    //
    UINT CurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer.
    //

    NdisQueryPacket(Packet,
                    NULL,
                    &NdisBufferCount,
                    &CurrentBuffer,
                    NULL);

    //
    // Could have a null packet.
    //

    if (!NdisBufferCount)
        return;

    VirtualAddress = MDL_ADDRESS_SAFE(CurrentBuffer, NormalPagePriority);
    CurrentLength = MDL_SIZE(CurrentBuffer);

    if (VirtualAddress == NULL)
        return;
    
    while (LocalBytesCopied < BytesToCopy)
    {
        if (CurrentLength == 0)
        {
            NdisGetNextBuffer(CurrentBuffer, &CurrentBuffer);

            //
            // We've reached the end of the packet. We return
            // with what we've done so far. (Which must be shorter
            // than requested.
            //

            if (!CurrentBuffer)
                break;

            VirtualAddress = MDL_ADDRESS_SAFE(CurrentBuffer, NormalPagePriority);

            if (VirtualAddress == NULL)
                break;
                
            CurrentLength = MDL_SIZE(CurrentBuffer);
            
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (Offset)
        {
            if (Offset > CurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;
            }
            else
            {
                VirtualAddress = (PCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        //
        // Copy the data.
        //
        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            AmountToMove = ((CurrentLength <= (BytesToCopy - LocalBytesCopied)) ?
                            (CurrentLength):
                            (BytesToCopy - LocalBytesCopied));

            MoveMemory(Buffer, VirtualAddress, AmountToMove);

            Buffer = Buffer + AmountToMove;
            VirtualAddress = (PCHAR)VirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            CurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

NDIS_STATUS
ndisMRejectSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    This routine handles any error cases where a protocol binds to an Atm
    miniport and tries to use the normal NdisSend() call.

Arguments:

    NdisBindingHandle - Handle returned by NdisOpenAdapter.

    Packet - the Ndis packet to send


Return Value:

    NDIS_STATUS - always fails

--*/
{
    UNREFERENCED_PARAMETER(NdisBindingHandle);
    UNREFERENCED_PARAMETER(Packet);

    return(NDIS_STATUS_NOT_SUPPORTED);
}


VOID
ndisMRejectSendPackets(
    IN  PNDIS_OPEN_BLOCK        OpenBlock,
    IN  PPNDIS_PACKET           Packet,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine handles any error cases where a protocol binds to an Atm
    miniport and tries to use the normal NdisSend() call.

Arguments:

    OpenBlock       - Pointer to the NdisOpenBlock

    Packet          - Pointer to the array of packets to send

    NumberOfPackets - self-explanatory


Return Value:

    None - SendCompleteHandler is called for the protocol calling this.

--*/
{
    UINT                i;

    for (i = 0; i < NumberOfPackets; i++)
    {
        MINIPORT_CLEAR_PACKET_FLAG(Packet[i], fPACKET_CLEAR_ITEMS);
        (*OpenBlock->SendCompleteHandler)(OpenBlock->ProtocolBindingContext,
                                          Packet[i],
                                          NDIS_STATUS_NOT_SUPPORTED);
    }
}


VOID
NdisIMCopySendPerPacketInfo(
    IN PNDIS_PACKET DstPacket,
    IN PNDIS_PACKET SrcPacket
    )
/*++

Routine Description:

    This routine is used by IM miniport and copies all relevant per packet info from 
    the SrcPacket to the DstPacket. Used in the Send Code path
    
Arguments:

    DstPacket - Pointer to the destination packet

    SrcPacket - Pointer to the Source Packet

Return Value:


--*/

{
    PVOID *     pDstInfo;                                                        
    PVOID *     pSrcInfo;                                                        
                                                                               
  
    pDstInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(DstPacket)->NdisPacketInfo;    
    pSrcInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(SrcPacket)->NdisPacketInfo;    
                                                                               
  
    pDstInfo[TcpIpChecksumPacketInfo] = pSrcInfo[TcpIpChecksumPacketInfo];       
    pDstInfo[IpSecPacketInfo] = pSrcInfo[IpSecPacketInfo];                       
    pDstInfo[TcpLargeSendPacketInfo] = pSrcInfo[TcpLargeSendPacketInfo];         
    pDstInfo[ClassificationHandlePacketInfo] = pSrcInfo[ClassificationHandlePacketInfo]; 
    pDstInfo[Ieee8021pPriority] = pSrcInfo[Ieee8021pPriority];                   
    pDstInfo[PacketCancelId] = pSrcInfo[PacketCancelId];                   

    DstPacket->Private.NdisPacketFlags &= ~fPACKET_WRAPPER_RESERVED;
    DstPacket->Private.NdisPacketFlags |= SrcPacket->Private.NdisPacketFlags & fPACKET_WRAPPER_RESERVED;
}



EXPORT
VOID
NdisIMCopySendCompletePerPacketInfo(
    IN PNDIS_PACKET DstPacket, 
    IN PNDIS_PACKET SrcPacket
    )
    
/*++

Routine Description:

    This routine is used by IM miniport and copies all relevant per packet info from 
    the SrcPacket to the DstPacket. Used in the SendComplete Code path
    
Arguments:

    DstPacket - Pointer to the destination packet

    SrcPacket - Pointer to the Source Packet

Return Value:


--*/



{
    PVOID *     pDstInfo;                                                        
  
    pDstInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(DstPacket)->NdisPacketInfo;    
  
    pDstInfo[TcpLargeSendPacketInfo] = NDIS_PER_PACKET_INFO_FROM_PACKET(SrcPacket, TcpLargeSendPacketInfo);

}


VOID
ndisMSendPacketsSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    UINT                    c;
    PPNDIS_PACKET           pPktArray;;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPacketsSG\n"));

    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    
    //
    //  Place the packets on the miniport queue.
    //
    for (c = 0, pPktArray = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;
        ASSERT(Packet != NULL);

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
        NSR->Open = Open;

        CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }

        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_PENDING);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);

        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 0, FALSE);
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            ndisMAllocSGListS(Miniport, Packet);
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        }

    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPacketsSG\n"));
}

NDIS_STATUS
ndisMSendSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:
    nsiaMSend for serialized drivers that handle SG lists

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendSG\n"));
    
    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    
        //
        //  Increment the references on this open.
        //
        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
    
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->References));
    
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NSR->Open = Open;

        Status = NDIS_STATUS_PENDING;
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        ndisMAllocSGListS(Miniport, Packet);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendSG\n"));


    return Status;
}

VOID
ndisMSendCompleteSG(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_STACK_RESERVED    NSR;

    ASSERT_MINIPORT_LOCKED(Miniport);
    
#if DBG
    Miniport->cDpcSendCompletes++;
#endif

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendCompleteSG\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));
    
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    ASSERT(VALID_OPEN(NSR->Open));
    ASSERT(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING));
    
    //
    // Guard against double/bogus completions.
    //
    if (VALID_OPEN(NSR->Open) &&
        MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))
    {
        ASSERT(Packet != Miniport->FirstPendingPacket);
        if (MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE))
        {
            //
            // If the packet completed in the context of a SendPackets, then
            // defer completion. It will get completed when we unwind.
            //
            NDIS_SET_PACKET_STATUS(Packet, Status);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);
        }
        else
        {
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, FALSE, 1, TRUE);
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendCompleteSG\n"));
}


BOOLEAN
FASTCALL
ndisMStartSendPacketsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_PACKET            Packet;
    NDIS_STATUS             Status;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray;
    PNDIS_PACKET            PacketArray[SEND_PACKET_ARRAY];
    UINT                    MaxPkts = Miniport->MaxSendPackets;
    W_SEND_PACKETS_HANDLER  SendPacketsHandler = Miniport->WSendPacketsHandler;
    BOOLEAN                 SelfDirected;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendPacketsSG\n"));

    //
    // We could possibly end up with a situation (with intermediate serialized
    // miniports) where there are no packets down with the driver and we the
    // resource window is closed. In such a case open it fully. We are seeing this
    // with wlbs
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE) &&
        (Miniport->FirstPendingPacket == NULL))
    {
        ADD_RESOURCE(Miniport, 'X');
    }

    //
    // Work-around for a scenario we are hitting when PacketList is empty but FirstPendingPacket is NOT
    // Not sure how this can happen - yet.
    //
    if (IsListEmpty(&Miniport->PacketList))
    {
        ASSERT (Miniport->FirstPendingPacket == NULL);
        Miniport->FirstPendingPacket = NULL;
    }

    while ((Miniport->FirstPendingPacket != NULL) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        UINT            Count;
        UINT            NumberOfPackets;

        ASSERT(!IsListEmpty(&Miniport->PacketList));

        //
        //  Initialize the packet array.
        //
        pPktArray = PacketArray;

        //
        //  Place as many packets as we can in the packet array to send
        //  to the miniport.
        //
        for (NumberOfPackets = 0;
             (NumberOfPackets < MaxPkts) && (Miniport->FirstPendingPacket != NULL);
             NOTHING)
        {
            //
            //  Grab the packet off of the pending queue.
            //
            ASSERT(!IsListEmpty(&Miniport->PacketList));

            Packet = Miniport->FirstPendingPacket;
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
            
            ASSERT(VALID_OPEN(NSR->Open));

            NEXT_PACKET_PENDING(Miniport, Packet);
        
            //
            // Indicate the packet loopback if necessary.
            //

            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {
                SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);
            }
            else
            {
                SelfDirected = FALSE;
            }

            if (SelfDirected)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Packet 0x%x is self-directed.\n", Packet));

                //
                //  Complete the packet back to the binding.
                //
                NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, NDIS_STATUS_SUCCESS, TRUE, 2, TRUE);

                //
                //  No, we don't want to increment the counter for the
                //  miniport's packet array.
                //
            }
            else
            {
                //
                //  We have to re-initialize this.
                //
                *pPktArray = Packet;
                MINIPORT_SET_PACKET_FLAG(Packet, (fPACKET_DONT_COMPLETE | fPACKET_PENDING));
                NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

                //
                //  Increment the counter for the packet array index.
                //
                NumberOfPackets++;
                pPktArray++;
            }
        }

        //
        //  Are there any packets to send?
        //
        if (NumberOfPackets == 0)
        {
            break;
        }

        pPktArray = PacketArray;

        {

            //
            //  Pass the packet array down to the miniport.
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (SendPacketsHandler)(Miniport->MiniportAdapterContext,
                                 pPktArray,
                                 NumberOfPackets);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the packet completion.
        //
        for (Count = 0; Count < NumberOfPackets; Count++, pPktArray++)
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            Status = NDIS_GET_PACKET_STATUS(*pPktArray);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);

            //
            //  Process the packet based on it's return status.
            //
            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Complete is pending\n"));
            }
            else if (Status != NDIS_STATUS_RESOURCES)
            {
                //
                //  Remove from the finish queue.
                //
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                        ("Completed packet 0x%x with status 0x%x\n",
                        Packet, Status));

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                if (VALID_OPEN(NSR->Open))
                {
                    NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 3, TRUE);
                }
            }
            else
            {
                //
                //  Once we hit a return code of NDIS_STATUS_RESOURCES
                //  for a packet then we must break out and re-queue.
                //
                UINT    i;

                Miniport->FirstPendingPacket = Packet;
                CLEAR_RESOURCE(Miniport, 'S');
                for (i = Count; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET    QueuedPacket = PacketArray[i];

                    MINIPORT_CLEAR_PACKET_FLAG(QueuedPacket, fPACKET_PENDING);
                    VALIDATE_PACKET_OPEN(QueuedPacket);
                }
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendPacketsSG\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMStartSendsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    If there are more packets to send but no resources to do it with
    the this is TRUE to keep a workitem queue'd.

--*/
{
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendsSG\n"));

    while ((Miniport->FirstPendingPacket != NULL) &&
           MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        //
        //  Grab the packet off of the pending queue.
        //
        ASSERT(!IsListEmpty(&Miniport->PacketList));
    
        Packet = Miniport->FirstPendingPacket;
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NEXT_PACKET_PENDING(Miniport, Packet);

        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

        //
        // we can use the same NDISM_SEND_PACKET we do for non SG miniports
        //
        NDISM_SEND_PACKET(Miniport, Open, Packet, &Status);

        //
        //  Process the packet pending completion status.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO, ("Complete is pending\n"));
        }
        else
        {
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);

            //
            //  Handle the completion and resources cases.
            //
            if (Status == NDIS_STATUS_RESOURCES)
            {
                NDISM_COMPLETE_SEND_RESOURCES(Miniport, NSR, Packet);
            }
            else
            {
                NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 4, TRUE);
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendsSG\n"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\verify.c ===
/*++
Copyright (c) 1999  Microsoft Corporation

Module Name:

    verify.c

Abstract:

    verifer support routines for Ndis wrapper

Author:

    Alireza Dabagh (alid) 8-9-1999

Environment:

    Kernel mode, FSD

Revision History:

    8-9-99 alid: initial version
    
--*/

#include <precomp.h>
#pragma hdrstop

#define MODULE_NUMBER   MODULE_VERIFY

LARGE_INTEGER VerifierRequiredTimeSinceBoot = {(ULONG)(40 * 1000 * 1000 * 10), 1};

#define VERIFIERFUNC(pfn)   ((PDRIVER_VERIFIER_THUNK_ROUTINE)(pfn))

const DRIVER_VERIFIER_THUNK_PAIRS ndisVerifierFunctionTable[] = 
{
    {VERIFIERFUNC(NdisAllocateMemory        ), VERIFIERFUNC(ndisVerifierAllocateMemory)},
    {VERIFIERFUNC(NdisAllocateMemoryWithTag ), VERIFIERFUNC(ndisVerifierAllocateMemoryWithTag)},
    {VERIFIERFUNC(NdisAllocatePacketPool    ), VERIFIERFUNC(ndisVerifierAllocatePacketPool)},
    {VERIFIERFUNC(NdisAllocatePacketPoolEx  ), VERIFIERFUNC(ndisVerifierAllocatePacketPoolEx)},
    {VERIFIERFUNC(NdisFreePacketPool        ), VERIFIERFUNC(ndisVerifierFreePacketPool)},
    {VERIFIERFUNC(NdisQueryMapRegisterCount ), VERIFIERFUNC(ndisVerifierQueryMapRegisterCount)},
    {VERIFIERFUNC(NdisFreeMemory            ), VERIFIERFUNC(ndisVerifierFreeMemory)}
};


BOOLEAN
ndisVerifierInitialization(
    VOID
    )
{
    NTSTATUS    Status;
    BOOLEAN     cr = FALSE;
    ULONG       Level;
    
    Status = MmIsVerifierEnabled (&Level);

    if (NT_SUCCESS(Status))
    {

        ndisVerifierLevel = Level;
        
        //
        // combine what we read from registry for ndis with the global flags
        //
        if (ndisFlags & NDIS_GFLAG_INJECT_ALLOCATION_FAILURE)
            ndisVerifierLevel |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
            
        if (ndisFlags & NDIS_GFLAG_SPECIAL_POOL_ALLOCATION)
            ndisVerifierLevel |= DRIVER_VERIFIER_SPECIAL_POOLING;
        
        Status = MmAddVerifierThunks ((VOID *) ndisVerifierFunctionTable,
                                      sizeof(ndisVerifierFunctionTable));

        if (NT_SUCCESS(Status))
        {
            InitializeListHead(&ndisMiniportTrackAllocList);
            InitializeListHead(&ndisDriverTrackAllocList);
            INITIALIZE_SPIN_LOCK(&ndisTrackMemLock);
            cr = TRUE;
        }

    }

    return cr;

}

NDIS_STATUS
ndisVerifierAllocateMemory(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    )
{
    PVOID       Address;
    
#if DBG
    if ((ndisFlags & NDIS_GFLAG_WARNING_LEVEL_MASK) >= NDIS_GFLAG_WARN_LEVEL_1)
    {
        DbgPrint("Driver is using NdisAllocateMemory instead of NdisAllocateMemoryWithTag\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
            DbgBreakPoint();
    }
#endif
    if (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION)
    {
        Length += sizeof(NDIS_TRACK_MEM);
    }
    
    ndisFlags |= NDIS_GFLAG_ABORT_TRACK_MEM_ALLOCATION;
    ndisMiniportTrackAlloc = NULL;
    ndisDriverTrackAlloc = NULL;

    if (ndisVerifierInjectResourceFailure(TRUE))
    {
        Address = NULL;
    }
    else
    {
    
        if (MemoryFlags != 0)
        {
            NdisAllocateMemory(
                        &Address,
                        Length,
                        MemoryFlags,
                        HighestAcceptableAddress);
            
        }
        else
        {
            if (ndisVerifierLevel & DRIVER_VERIFIER_SPECIAL_POOLING)
            {
                Address = ExAllocatePoolWithTagPriority(
                                            NonPagedPool,
                                            Length,
                                            NDIS_TAG_ALLOC_MEM_VERIFY_ON,
                                            NormalPoolPrioritySpecialPoolOverrun);  // most common problem
                            
            
            }
            else
            {
                Address = ALLOC_FROM_POOL(Length, NDIS_TAG_ALLOC_MEM);
            }
        }
    }

    *VirtualAddress = Address;
    
    if ((Address != NULL) && (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION))
    {
        *VirtualAddress = (PVOID)((PUCHAR)Address + sizeof(NDIS_TRACK_MEM));
    }

    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
ndisVerifierAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    )
{

    PVOID           Caller = NULL, CallersCaller = NULL;
    PVOID           Address;
    PNDIS_TRACK_MEM TrackMem;
    KIRQL           OldIrql;
    

    if (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION)
    {
        RtlGetCallersAddress(&Caller, &CallersCaller);
        Length += sizeof(NDIS_TRACK_MEM);
    }
    
    if (ndisVerifierInjectResourceFailure(TRUE))
    {
        Address = NULL;
    }
    else
    {
        if (ndisVerifierLevel & DRIVER_VERIFIER_SPECIAL_POOLING)
        {
            Address = ExAllocatePoolWithTagPriority(
                                        NonPagedPool,
                                        Length,
                                        Tag,
                                        NormalPoolPrioritySpecialPoolOverrun);  // most common problem
        }
        else
        {
            Address = ALLOC_FROM_POOL(Length, Tag);
        }
    }

    if ((Address != NULL) && (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION))
    {
        *VirtualAddress = (PVOID)((PUCHAR)Address + sizeof(NDIS_TRACK_MEM));
        TrackMem = (PNDIS_TRACK_MEM)Address;
        RtlZeroMemory(TrackMem, sizeof(NDIS_TRACK_MEM));
        TrackMem->Tag = Tag;
        TrackMem->Length = Length;
        TrackMem->Caller = Caller;
        TrackMem->CallersCaller = CallersCaller;
        
        ACQUIRE_SPIN_LOCK(&ndisTrackMemLock, &OldIrql);
        if (ndisMiniportTrackAlloc)
        {
            //
            // charge it against miniport
            //
            InsertHeadList(&ndisMiniportTrackAllocList, &TrackMem->List);
         }
        else
        {
            //
            // charge it against driver
            //
            InsertHeadList(&ndisDriverTrackAllocList, &TrackMem->List);
            
        }
        RELEASE_SPIN_LOCK(&ndisTrackMemLock, OldIrql);
    }
    else
    {
        *VirtualAddress = Address;
    }

    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}


VOID
ndisVerifierAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
{
    PVOID   Caller, CallersCaller;

    RtlGetCallersAddress(&Caller, &CallersCaller);

    if (ndisVerifierInjectResourceFailure(TRUE))
    {
        *PoolHandle = NULL;
        *Status = NDIS_STATUS_RESOURCES;    
    }
    else
    {
        NdisAllocatePacketPool(
                            Status,
                            PoolHandle,
                            NumberOfDescriptors,
                            ProtocolReservedLength);
        if (*Status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PKT_POOL  Pool = *PoolHandle;

            Pool->Allocator = Caller;
        }
    }
}

VOID
ndisVerifierAllocatePacketPoolEx(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
{
    PVOID   Caller, CallersCaller;

    RtlGetCallersAddress(&Caller, &CallersCaller);

    if (ndisVerifierInjectResourceFailure(TRUE))
    {
        *PoolHandle = NULL;
        *Status = NDIS_STATUS_RESOURCES;    
    }
    else
    {
        NdisAllocatePacketPoolEx(
                            Status,
                            PoolHandle,
                            NumberOfDescriptors,
                            NumberOfOverflowDescriptors,
                            ProtocolReservedLength);
        if (*Status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PKT_POOL  Pool = *PoolHandle;

            Pool->Allocator = Caller;
        }
    }
}

VOID
ndisVerifierFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    )
{
    ndisFreePacketPool(PoolHandle, TRUE);
}   

BOOLEAN
ndisVerifierInjectResourceFailure(
    BOOLEAN     fDelayFailure
    )

/*++

Routine Description:

    This function determines whether a resource allocation should be
    deliberately failed.  This may be a pool allocation, MDL creation,
    system PTE allocation, etc.

Arguments:

    None.

Return Value:

    TRUE if the allocation should be failed.  FALSE otherwise.

Environment:

    Kernel mode.  DISPATCH_LEVEL or below.

--*/

{
    LARGE_INTEGER CurrentTime;

    if (!(ndisVerifierLevel & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES))
    {
        return FALSE;
    }
    
    if (fDelayFailure)
    {
        //
        // Don't fail any requests in the first 7 or 8 minutes as we want to
        // give the system enough time to boot.
        //

        if (VerifierSystemSufficientlyBooted == FALSE)
        {
            KeQuerySystemTime (&CurrentTime);
            if (CurrentTime.QuadPart > KeBootTime.QuadPart + VerifierRequiredTimeSinceBoot.QuadPart)
            {
                VerifierSystemSufficientlyBooted = TRUE;
            }
        }
    }
    
    if (!fDelayFailure || (VerifierSystemSufficientlyBooted == TRUE))
    {

        KeQueryTickCount(&CurrentTime);

        if ((CurrentTime.LowPart & 0x7) == 0)
        {
            //
            // Deliberately fail this request.
            //
            InterlockedIncrement((PLONG)&ndisVeriferFailedAllocations);
            return TRUE;
        }
    }

    return FALSE;
}

NDIS_STATUS
ndisVerifierQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
    )
{
#if DBG
    DbgPrint("NdisQueryMapRegisterCount: Driver is using an obsolete API.\n");
    if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        DbgBreakPoint();
#endif
    UNREFERENCED_PARAMETER(BusType);

    *MapRegisterCount = 0;
    return NDIS_STATUS_NOT_SUPPORTED;
}

VOID
ndisVerifierFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    )

{    
    if (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION)
    {
        PNDIS_TRACK_MEM TrackMem;
        KIRQL           OldIrql;
        
        Length += sizeof(NDIS_TRACK_MEM);
        VirtualAddress = (PVOID)((PUCHAR)VirtualAddress - sizeof(NDIS_TRACK_MEM));
        TrackMem = (PNDIS_TRACK_MEM)VirtualAddress;
        
        if(!(ndisFlags & NDIS_GFLAG_ABORT_TRACK_MEM_ALLOCATION))
        {
            
            ACQUIRE_SPIN_LOCK(&ndisTrackMemLock, &OldIrql);
            RemoveEntryList(&TrackMem->List);
            RELEASE_SPIN_LOCK(&ndisTrackMemLock, OldIrql);
        }
    }
    
    NdisFreeMemory(VirtualAddress, Length, MemoryFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\wrapper.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    wrapper.h

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

#ifndef _WRAPPER_
#define _WRAPPER_


#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4514)   // unreferenced inline function has been removed

#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4213)   // nonstandard extension used : cast on l-value
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4055)   // cast of function pointer to PVOID
// take care of ks
#pragma warning(disable:4244)   // conversion from 'int' to 'BOOLEAN', possible loss of data




#include <ntosp.h>
#include <zwapi.h>

#pragma warning(disable:4514)   // unreferenced inline function has been removed
#include <netpnp.h>
#include <ndismain.h>
#include <ndisprot.h>
#include <ndisprv.h>


#if DBG

#undef  FASTCALL
#define FASTCALL

#endif

//
// Ndis Major and Minor version
//
#define NDIS_MAJOR_VERSION          5
#define NDIS_MINOR_VERSION          1

#define NDIS_MAX_CPU_COUNT          32

typedef union _FILTER_LOCK_REF_COUNT
{
    UINT    RefCount;
    UCHAR   cacheLine[16];      // want one refCount per cache line
} FILTER_LOCK_REF_COUNT;

typedef struct _NDIS_M_OPEN_BLOCK   NDIS_M_OPEN_BLOCK, *PNDIS_M_OPEN_BLOCK;

#include <ndismini.h>

//
// The following structure is used to queue closeadapter calls to
// worker threads so that they can complete at PASSIVE_LEVEL.
//
typedef struct _QUEUED_CLOSE
{
    NDIS_STATUS         Status;
    WORK_QUEUE_ITEM     WorkItem;
} QUEUED_CLOSE, *PQUEUED_CLOSE;


#include <filter.h>
#include <ndisco.h>
#include <ndis_co.h>
#include <ndismac.h>
#include <macros.h>
#include <ndiswan.h>
#include <ndisdbg.h>
#include <ndistags.h>
//
// ndispnp.h sets the following back to default, disable them again
//
#include <ndispnp.h>
// #pragma warning(disable:4201)
// #pragma warning(disable:4214)
// #pragma warning(disable:4514)
#include <ntddpcm.h>


#if !DBG

#if ASSERT_ON_FREE_BUILDS

extern
VOID
ndisAssert(
    IN  PVOID               exp,
    IN  PUCHAR              File,
    IN  UINT                Line
    );

#undef  ASSERT
#define ASSERT(exp)                                 \
    if (!(exp))                                     \
    {                                               \
        ndisAssert( #exp, __FILE__, __LINE__);      \
    }

#endif  // ASSERT_ON_FREE_BUILDS

#endif  // DBG

//
// values for ndisFlags
//
#define NDIS_GFLAG_INIT_TIME                        0x00000001
#define NDIS_GFLAG_RESERVED                         0x00000002
#define NDIS_GFLAG_INJECT_ALLOCATION_FAILURE        0x00000004
#define NDIS_GFLAG_SPECIAL_POOL_ALLOCATION          0x00000008
#define NDIS_GFLAG_DONT_VERIFY                      0x00000100
#define NDIS_GFLAG_BREAK_ON_WARNING                 0x00000200
#define NDIS_GFLAG_TRACK_MEM_ALLOCATION             0x00000400
#define NDIS_GFLAG_ABORT_TRACK_MEM_ALLOCATION       0x00000800

#define NDIS_GFLAG_WARNING_LEVEL_MASK               0x00000030

#define NDIS_GFLAG_WARN_LEVEL_0                     0x00000000
#define NDIS_GFLAG_WARN_LEVEL_1                     0x00000010
#define NDIS_GFLAG_WARN_LEVEL_2                     0x00000020
#define NDIS_GFLAG_WARN_LEVEL_3                     0x00000030


#if DBG
#define NDIS_WARN(_Condition, _M, _Level, Fmt)                              \
{                                                                           \
    if ((_Condition) &&                                                     \
        MINIPORT_PNP_TEST_FLAG(_M, fMINIPORT_VERIFYING) &&                  \
        ((ndisFlags & NDIS_GFLAG_WARNING_LEVEL_MASK) >= _Level))            \
    {                                                                       \
        DbgPrint Fmt;                                                       \
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)                        \
            DbgBreakPoint();                                                \
    }                                                                       \
}
#else
#define NDIS_WARN(_Condition, _M, Level, Fmt)
#endif

#define PACKET_TRACK_COUNT      1032

#define BYTE_SWAP(_word)    ((USHORT) (((_word) >> 8) | ((_word) << 8)))

#define LOW_WORD(_dword)    ((USHORT) ((_dword) & 0x0000FFFF))

#define HIGH_WORD(_dword)   ((USHORT) (((_dword) >> 16) & 0x0000FFFF))

#define BYTE_SWAP_ULONG(_ulong) ((ULONG)((ULONG)(BYTE_SWAP(LOW_WORD(_ulong)) << 16) + \
                                 BYTE_SWAP(HIGH_WORD(_ulong))))

//
// A set of macros to manipulate bitmasks.
//

//VOID
//CLEAR_BIT_IN_MASK(
//  IN UINT Offset,
//  IN OUT PMASK MaskToClear
//  )
//
///*++
//
//Routine Description:
//
//  Clear a bit in the bitmask pointed to by the parameter.
//
//Arguments:
//
//  Offset - The offset (from 0) of the bit to altered.
//
//  MaskToClear - Pointer to the mask to be adjusted.
//
//Return Value:
//
//  None.
//
//--*/
//
#define CLEAR_BIT_IN_MASK(Offset, MaskToClear) *(MaskToClear) &= (~(1 << Offset))

//VOID
//SET_BIT_IN_MASK(
//  IN      UINT    Offset,
//  IN OUT  PMASK   MaskToSet
//  )
//
///*++
//
//Routine Description:
//
//  Set a bit in the bitmask pointed to by the parameter.
//
//Arguments:
//
//  Offset - The offset (from 0) of the bit to altered.
//
//  MaskToSet - Pointer to the mask to be adjusted.
//
//Return Value:
//
//  None.
//
//--*/
#define SET_BIT_IN_MASK(Offset, MaskToSet) *(MaskToSet) |= (1 << Offset)

//BOOLEAN
//IS_BIT_SET_IN_MASK(
//  IN UINT Offset,
//  IN MASK MaskToTest
//  )
//
///*++
//
//Routine Description:
//
//  Tests if a particular bit in the bitmask pointed to by the parameter is
//  set.
//
//Arguments:
//
//  Offset - The offset (from 0) of the bit to test.
//
//  MaskToTest - The mask to be tested.
//
//Return Value:
//
//  Returns TRUE if the bit is set.
//
//--*/
#define IS_BIT_SET_IN_MASK(Offset, MaskToTest)  ((MaskToTest & (1 << Offset)) ? TRUE : FALSE)

//BOOLEAN
//IS_MASK_CLEAR(
//  IN MASK MaskToTest
//  )
//
///*++
//
//Routine Description:
//
//  Tests whether there are *any* bits enabled in the mask.
//
//Arguments:
//
//  MaskToTest - The bit mask to test for all clear.
//
//Return Value:
//
//  Will return TRUE if no bits are set in the mask.
//
//--*/
#define IS_MASK_CLEAR(MaskToTest) ((MaskToTest) ? FALSE : TRUE)

//VOID
//CLEAR_MASK(
//  IN OUT PMASK MaskToClear
//  );
//
///*++
//
//Routine Description:
//
//  Clears a mask.
//
//Arguments:
//
//  MaskToClear - The bit mask to adjust.
//
//Return Value:
//
//  None.
//
//--*/
#define CLEAR_MASK(MaskToClear) *(MaskToClear) = 0

//
// This constant is used for places where NdisAllocateMemory
// needs to be called and the HighestAcceptableAddress does
// not matter.
//
#define RetrieveUlong(Destination, Source)              \
{                                                       \
    PUCHAR _S = (Source);                               \
    *(Destination) = ((ULONG)(*_S) << 24)      |        \
                      ((ULONG)(*(_S+1)) << 16) |        \
                      ((ULONG)(*(_S+2)) << 8)  |        \
                      ((ULONG)(*(_S+3)));               \
}


//
//  This is the number of extra OIDs that ARCnet with Ethernet encapsulation
//  supports.
//
#define ARC_NUMBER_OF_EXTRA_OIDS    2

//
// ZZZ NonPortable definitions.
//
#define AllocPhys(s, l)     NdisAllocateMemory((PVOID *)(s), (l), 0, HighestAcceptableMax)
#define FreePhys(s, l)      NdisFreeMemory((PVOID)(s), (l), 0)

//
// Internal wrapper data structures.
//
#define NDIS_PROXY_SERVICE  L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NDProxy"

#if NDIS_NO_REGISTRY
#define NDIS_DEFAULT_EXPORT_NAME    L"\\Device\\DefaultNic"
#endif

//
// NDIS_PKT_POOL
//
// Moved from ndis.h where it existed as NDIS_PACKET_POOL which is now a NDIS_HANDLE.
//
typedef struct _NDIS_PKT_POOL NDIS_PKT_POOL, *PNDIS_PKT_POOL;

typedef enum _POOL_BLOCK_TYPE
{
    NDIS_PACKET_POOL_BLOCK_FREE,
    NDIS_PACKET_POOL_BLOCK_USED,
    NDIS_PACKET_POOL_BLOCK_AGING
} POOL_BLOCK_TYPE;

#if defined(_WIN64)
typedef struct DECLSPEC_ALIGN(16) _NDIS_PKT_POOL_HDR
#else
typedef struct _NDIS_PKT_POOL_HDR
#endif
{
    LIST_ENTRY                  List;           // linked from NDIS_PKT_POOL
    LARGE_INTEGER               TimeStamp;      // via KeQueryTickCount (normalized)
    SLIST_HEADER                FreeList;       // linked list of free blocks in pool
    POOL_BLOCK_TYPE             State;          // what (free/used/aging) pool this block belongs to
} NDIS_PKT_POOL_HDR, * PNDIS_PKT_POOL_HDR;

#if defined(_WIN64)
C_ASSERT(sizeof(NDIS_PKT_POOL_HDR) % 16 == 0);
#endif

typedef struct _NDIS_PKT_POOL
{
    ULONG                       Tag;            // Protocol supplied pool tag, 'NDpp' by default
    USHORT                      PacketLength;   // amount needed in each packet
    USHORT                      PktsPerBlock;   // # of packets in each block. Each block is page size
    USHORT                      MaxBlocks;      // maximum # of blocks
    USHORT                      StackSize;      // stack size for packets allocated on this pool
    LONG                        BlocksAllocated;// # of blocks in use (incl. ones on aging list)
    ULONG                       ProtocolId;     // Id of the owning protocol.
    ULONG                       BlockSize;      // does not have to be page size
    PVOID                       Allocator;      // Address of pool allocator
    KSPIN_LOCK                  Lock;           // Protects the NDIS_PKT_POOL entries
    LIST_ENTRY                  FreeBlocks;     // These have atleast one free packet in them
    LIST_ENTRY                  UsedBlocks;     // These are completely used and have no free packets
    LIST_ENTRY                  AgingBlocks;    // These are completely free and will age out over time
    LIST_ENTRY                  GlobalPacketPoolList;   // to link all the packet pools allocated by Ndis
    LARGE_INTEGER               NextScavengeTick;
#ifdef NDIS_PKT_POOL_STATISTICS
    ULONG                       cAllocatedNewBlocks;
    ULONG                       cAllocatedFromFreeBlocks;
    ULONG                       cMovedFreeBlocksToUsed;
    ULONG                       cMovedUsedBlocksToFree;
    ULONG                       cMovedFreeBlocksToAged;
    ULONG                       cMovedAgedBlocksToFree;
    ULONG                       cFreedAgedBlocks;
#endif
} NDIS_PKT_POOL, * PNDIS_PKT_POOL;

//
// we need to make the size of _STACK_INDEX structure a multiple of 16 for
// WIN64 to make sure the packets fall on 16 byte boundary. if we do this 
// by making the structure 16 bytes aligned, it does the job but will move the 
// Index fields to the beginning of the structure. to avoid any regression
// at this point. pad the structure at the beginning.
//
typedef union _STACK_INDEX
{
    ULONGLONG       Alignment;
    struct _PACKET_INDEXES
    {
#if defined(_WIN64)
        ULONGLONG       Reserved;       // to make the _STACK_INDEX size 16 bytes
#endif
        ULONG           XferDataIndex;
        ULONG           Index;
    };
} STACK_INDEX;

#if defined(_WIN64)
C_ASSERT(sizeof(STACK_INDEX) % 16 == 0);
#endif

typedef struct _NDIS_PACKET_WRAPPER
{
    STACK_INDEX     StackIndex;
    NDIS_PACKET     Packet;
} NDIS_PACKET_WRAPPER;


#define POOL_AGING_TIME                 60      // In seconds

#define SIZE_PACKET_STACKS              (sizeof(STACK_INDEX) + (sizeof(NDIS_PACKET_STACK) * ndisPacketStackSize))

/*
#define PUSH_PACKET_STACK(_P)           (*(((PULONG)(_P)) - 1)) ++
#define POP_PACKET_STACK(_P)            (*(((PULONG)(_P)) - 1)) --
#define CURR_STACK_LOCATION(_P)         *(((PULONG)(_P)) - 1)
*/

#define PUSH_PACKET_STACK(_P)           \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.Index ++)
#define POP_PACKET_STACK(_P)            \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.Index --)
#define CURR_STACK_LOCATION(_P)         \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.Index)

#define PUSH_XFER_DATA_PACKET_STACK(_P)         \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.XferDataIndex ++)
#define POP_XFER_DATA_PACKET_STACK(_P)          \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.XferDataIndex --)
#define CURR_XFER_DATA_STACK_LOCATION(_P)           \
    (CONTAINING_RECORD(_P, NDIS_PACKET_WRAPPER, Packet)->StackIndex.XferDataIndex)



#define GET_CURRENT_PACKET_STACK(_P, _S)                \
    {                                                   \
        UINT    _SL;                                    \
                                                        \
        *(_S) = (PNDIS_PACKET_STACK)((PUCHAR)(_P) - SIZE_PACKET_STACKS); \
        _SL = CURR_STACK_LOCATION(_P);                  \
        if (_SL < ndisPacketStackSize)                  \
        {                                               \
            *(_S) += _SL;                               \
        }                                               \
        else                                            \
        {                                               \
            *(_S) = NULL;                               \
        }                                               \
    }

#define GET_CURRENT_XFER_DATA_PACKET_STACK(_P, _O)      \
    {                                                   \
        UINT    _SL;                                    \
        PNDIS_PACKET_STACK _SI;                         \
                                                        \
        _SI = (PNDIS_PACKET_STACK)((PUCHAR)(_P) - SIZE_PACKET_STACKS); \
        _SL = CURR_XFER_DATA_STACK_LOCATION(_P);        \
        if (_SL < ndisPacketStackSize * 3)              \
        {                                               \
            _SI += _SL / 3;                             \
            (_O) = ((PNDIS_STACK_RESERVED)_SI->NdisReserved)->Opens[_SL % 3]; \
        }                                               \
        else                                            \
        {                                               \
            (_O) = NULL;                                \
        }                                               \
    }

#define GET_CURRENT_XFER_DATA_PACKET_STACK_AND_ZERO_OUT(_P, _O)      \
    {                                                   \
        UINT    _SL, _SLX;                              \
        PNDIS_PACKET_STACK _SI;                         \
                                                        \
        _SI = (PNDIS_PACKET_STACK)((PUCHAR)(_P) - SIZE_PACKET_STACKS); \
        _SL = CURR_XFER_DATA_STACK_LOCATION(_P);        \
        if (_SL < ndisPacketStackSize * 3)              \
        {                                               \
            _SI += _SL / 3;                             \
            _SLX = _SL % 3;                             \
            (_O) = ((PNDIS_STACK_RESERVED)_SI->NdisReserved)->Opens[_SLX]; \
            ((PNDIS_STACK_RESERVED)_SI->NdisReserved)->Opens[_SLX] = 0; \
        }                                               \
        else                                            \
        {                                               \
            (_O) = NULL;                                \
        }                                               \
    }

#define SET_CURRENT_XFER_DATA_PACKET_STACK(_P, _O)      \
    {                                                   \
        UINT    _SL;                                    \
        PNDIS_PACKET_STACK _SI;                         \
                                                        \
        _SI = (PNDIS_PACKET_STACK)((PUCHAR)(_P) - SIZE_PACKET_STACKS); \
        _SL = CURR_XFER_DATA_STACK_LOCATION(_P);        \
        if (_SL < ndisPacketStackSize * 3)              \
        {                                               \
            _SI += _SL / 3;                             \
            ((PNDIS_STACK_RESERVED)_SI->NdisReserved)->Opens[_SL % 3] = (_O); \
        }                                               \
    }

//
// this macro returns the current stack location as well whether or not
// there is any stack locations left. (_SR) parameter
//
#define GET_CURRENT_PACKET_STACK_X(_P, _S, _SR)         \
    {                                                   \
        UINT    _SL;                                    \
                                                        \
        *(_S) = (PNDIS_PACKET_STACK)((PUCHAR)(_P) - SIZE_PACKET_STACKS); \
        _SL = CURR_STACK_LOCATION(_P);                  \
        if (_SL < ndisPacketStackSize)                  \
        {                                               \
            *(_S) += _SL;                               \
            *(_SR) = (ndisPacketStackSize - _SL - 1) > 0;\
        }                                               \
        else                                            \
        {                                               \
            *(_S) = NULL;                               \
            *(_SR) = FALSE;                             \
        }                                               \
    }

#undef NDIS_WRAPPER_HANDLE
#undef PNDIS_WRAPPER_HANDLE
typedef struct _NDIS_WRAPPER_HANDLE
{
    PDRIVER_OBJECT              DriverObject;
    UNICODE_STRING              ServiceRegPath;
} NDIS_WRAPPER_HANDLE, *PNDIS_WRAPPER_HANDLE;
                                              

typedef struct _POWER_QUERY
{
    KEVENT      Event;
    NTSTATUS    Status;
} POWER_QUERY, *PPOWER_QUERY;

#define MINIPORT_DEVICE_MAGIC_VALUE 'PMDN'
#define CUSTOM_DEVICE_MAGIC_VALUE   '5IDN'

typedef struct _NDIS_DEVICE_LIST
{
    //
    // The signature field must be at the same place as the one in the MINIPORT_BLOCK
    //
    PVOID                       Signature;      // To identify this as a device created for driver
    LIST_ENTRY                  List;
    PNDIS_M_DRIVER_BLOCK        MiniBlock;
    PDEVICE_OBJECT              DeviceObject;
    PDRIVER_DISPATCH            MajorFunctions[IRP_MJ_MAXIMUM_FUNCTION+1];
    NDIS_STRING                 DeviceName;
    NDIS_STRING                 SymbolicLinkName;
    
} NDIS_DEVICE_LIST, *PNDIS_DEVICE_LIST;

//
// NDIS_WRAPPER_CONTEXT
//
// This data structure contains internal data items for use by the wrapper.
//
typedef struct _NDIS_WRAPPER_CONTEXT
{
    //
    // Mac/miniport defined shutdown context.
    //
    PVOID                       ShutdownContext;

    //
    // Mac/miniport registered shutdown handler.
    //
    ADAPTER_SHUTDOWN_HANDLER    ShutdownHandler;

    //
    // Kernel bugcheck record for bugcheck handling.
    //
    KBUGCHECK_CALLBACK_RECORD   BugcheckCallbackRecord;

    //
    // HAL common buffer cache.
    //
    PVOID                       SharedMemoryPage[2];
    ULONG                       SharedMemoryLeft[2];
    NDIS_PHYSICAL_ADDRESS       SharedMemoryAddress[2];

} NDIS_WRAPPER_CONTEXT, *PNDIS_WRAPPER_CONTEXT;

//
// This is the structure pointed to by the FsContext of an
// open used for query statistics.
//
typedef struct _OID_LIST
{
    ULONG                       StatsOidCount;
    ULONG                       FullOidCount;
    PNDIS_OID                   StatsOidArray;
    PNDIS_OID                   FullOidArray;
} OID_LIST, *POID_LIST;


typedef struct _NDIS_USER_OPEN_CONTEXT
{
    PDEVICE_OBJECT              DeviceObject;
    PNDIS_MINIPORT_BLOCK        Miniport;
    POID_LIST                   OidList;
    BOOLEAN                     AdminAccessAllowed;
} NDIS_USER_OPEN_CONTEXT, *PNDIS_USER_OPEN_CONTEXT;

typedef struct _NDIS_DEVICE_OBJECT_OPEN_CONTEXT
{
    BOOLEAN                     AdminAccessAllowed;
    UCHAR                       Padding[3];
} NDIS_DEVICE_OBJECT_OPEN_CONTEXT, *PNDIS_DEVICE_OBJECT_OPEN_CONTEXT;

//
// Used to queue configuration parameters
//
typedef struct _NDIS_CONFIGURATION_PARAMETER_QUEUE
{
    struct _NDIS_CONFIGURATION_PARAMETER_QUEUE* Next;
    NDIS_CONFIGURATION_PARAMETER Parameter;
} NDIS_CONFIGURATION_PARAMETER_QUEUE, *PNDIS_CONFIGURATION_PARAMETER_QUEUE;

//
// Configuration Handle
//
typedef struct _NDIS_CONFIGURATION_HANDLE
{
    PRTL_QUERY_REGISTRY_TABLE           KeyQueryTable;
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterList;
} NDIS_CONFIGURATION_HANDLE, *PNDIS_CONFIGURATION_HANDLE;


//
//  This is used during addadapter/miniportinitialize so that when the
//  driver calls any NdisImmediatexxx routines we can access its driverobj.
//
typedef struct _NDIS_WRAPPER_CONFIGURATION_HANDLE
{
    RTL_QUERY_REGISTRY_TABLE        ParametersQueryTable[5];
    PDRIVER_OBJECT                  DriverObject;
    PDEVICE_OBJECT                  DeviceObject;
    PUNICODE_STRING                 DriverBaseName;
} NDIS_WRAPPER_CONFIGURATION_HANDLE, *PNDIS_WRAPPER_CONFIGURATION_HANDLE;

//
// one of these per protocol registered
//
typedef struct _NDIS_PROTOCOL_BLOCK
{
    PNDIS_OPEN_BLOCK                OpenQueue;              // queue of opens for this protocol
    REFERENCE                       Ref;                    // contains spinlock for OpenQueue
    PKEVENT                         DeregEvent;             // Used by NdisDeregisterProtocol
    struct _NDIS_PROTOCOL_BLOCK *   NextProtocol;           // Link to next
    NDIS50_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics;// handler addresses

    WORK_QUEUE_ITEM                 WorkItem;               // Used during NdisRegisterProtocol to
                                                            // notify protocols of existing drivers.
    KMUTEX                          Mutex;                  // For serialization of Bind/Unbind requests
    ULONG                           MutexOwner;             // For debugging
    PNDIS_STRING                    BindDeviceName;
    PNDIS_STRING                    RootDeviceName;
    PNDIS_M_DRIVER_BLOCK            AssociatedMiniDriver;
    PNDIS_MINIPORT_BLOCK            BindingAdapter;
} NDIS_PROTOCOL_BLOCK, *PNDIS_PROTOCOL_BLOCK;

//
// Context for Bind Adapter.
//
typedef struct _NDIS_BIND_CONTEXT
{
    struct _NDIS_BIND_CONTEXT   *   Next;
    PNDIS_PROTOCOL_BLOCK            Protocol;
    PNDIS_MINIPORT_BLOCK            Miniport;
    NDIS_STRING                     ProtocolSection;
    PNDIS_STRING                    DeviceName;
    WORK_QUEUE_ITEM                 WorkItem;
    NDIS_STATUS                     BindStatus;
    KEVENT                          Event;
    KEVENT                          ThreadDoneEvent;
} NDIS_BIND_CONTEXT, *PNDIS_BIND_CONTEXT;


//
// Describes an open NDIS file
//
typedef struct _NDIS_FILE_DESCRIPTOR
{
    PVOID                           Data;
    KSPIN_LOCK                      Lock;
    BOOLEAN                         Mapped;
} NDIS_FILE_DESCRIPTOR, *PNDIS_FILE_DESCRIPTOR;

#if defined(_ALPHA_)

typedef struct _NDIS_LOOKAHEAD_ELEMENT
{
    ULONG                           Length;
    struct _NDIS_LOOKAHEAD_ELEMENT *Next;

} NDIS_LOOKAHEAD_ELEMENT, *PNDIS_LOOKAHEAD_ELEMENT;

#endif

typedef struct _PKG_REF
{
    LONG                            ReferenceCount;
    BOOLEAN                         PagedIn;
    PVOID                           Address;
    PVOID                           ImageHandle;
} PKG_REF, *PPKG_REF;

//
// Structures for dealing with making the module specific routines pagable
//

typedef enum _PKG_TYPE
{
    NDSP_PKG,
    NDSM_PKG,
    NPNP_PKG,
    NDCO_PKG,
    NDSE_PKG,
    NDSF_PKG,
    NDST_PKG,
#if ARCNET
    NDSA_PKG,
#endif
    MAX_PKG 
} PKG_TYPE;

#define NDIS_PNP_MINIPORT_DRIVER_ID         'NMID'
#define NDIS_PNP_MAC_DRIVER_ID              'NFID'

#define MINIPORT_SIGNATURE                  'MPRT'

typedef struct _NDIS_SHARED_MEM_SIGNATURE 
{
    ULONG Tag;
    ULONG PageRef;

}  NDIS_SHARED_MEM_SIGNATURE, *PNDIS_SHARED_MEM_SIGNATURE ;

#define NDIS_MAXIMUM_SCATTER_GATHER_SEGMENTS    16

__inline
VOID
ConvertSecondsToTicks(
    IN  ULONG               Seconds,
    OUT PLARGE_INTEGER      Ticks
    );

#if defined(_WIN64)

typedef struct _NDIS_INTERFACE32
{
    UNICODE_STRING32    DeviceName;
    UNICODE_STRING32    DeviceDescription;
} NDIS_INTERFACE32, *PNDIS_INTERFACE32;

typedef struct _NDIS_ENUM_INTF32
{
    UINT                TotalInterfaces;
    UINT                AvailableInterfaces;
    UINT                BytesNeeded;
    UINT                Reserved;
    NDIS_INTERFACE32    Interface[1];
} NDIS_ENUM_INTF32, *PNDIS_ENUM_INTF32;

typedef struct _NDIS_VAR_DATA_DESC32
{
    USHORT              Length;
    USHORT              MaximumLength;
    ULONG               Offset;
} NDIS_VAR_DATA_DESC32, *PNDIS_VAR_DATA_DESC32;

typedef struct _NDIS_PNP_OPERATION32
{
    UINT                    Layer;
    UINT                    Operation;
    union
    {
        ULONG               ReConfigBufferPtr;
        ULONG               ReConfigBufferOff;
    };
    UINT                    ReConfigBufferSize;
    NDIS_VAR_DATA_DESC32    LowerComponent;
    NDIS_VAR_DATA_DESC32    UpperComponent;
    NDIS_VAR_DATA_DESC32    BindList;
} NDIS_PNP_OPERATION32, *PNDIS_PNP_OPERATION32;

#endif // _WIN64

//
// These are now obsolete. Use Deserialized driver model for optimal performance.
//
EXPORT
NDIS_STATUS
NdisIMQueueMiniportCallback(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  W_MINIPORT_CALLBACK     CallbackRoutine,
    IN  PVOID                   CallbackContext
    );

EXPORT
BOOLEAN
NdisIMSwitchToMiniport(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    OUT PNDIS_HANDLE            SwitchHandle
    );

EXPORT
VOID
NdisIMRevertBack(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             SwitchHandle
    );


typedef struct _NDIS_MAC_CHARACTERISTICS
{
    UCHAR                       MajorNdisVersion;
    UCHAR                       MinorNdisVersion;
    USHORT                      Filler;
    UINT                        Reserved;
    PVOID                       OpenAdapterHandler;
    PVOID                       CloseAdapterHandler;
    SEND_HANDLER                SendHandler;
    TRANSFER_DATA_HANDLER       TransferDataHandler;
    RESET_HANDLER               ResetHandler;
    REQUEST_HANDLER             RequestHandler;
    PVOID                       QueryGlobalStatisticsHandler;
    PVOID                       UnloadMacHandler;
    PVOID                       AddAdapterHandler;
    PVOID                       RemoveAdapterHandler;
    NDIS_STRING                 Name;

} NDIS_MAC_CHARACTERISTICS, *PNDIS_MAC_CHARACTERISTICS;



typedef struct _NDIS_MAC_BLOCK
{
    PVOID                       AdapterQueue;           // queue of adapters for this MAC
    NDIS_HANDLE                 MacMacContext;          // Context for calling MACUnload and
                                                        //  MACAddAdapter.

    REFERENCE                   Ref;                    // contains spinlock for AdapterQueue

    PVOID                       PciAssignedResources;
    PVOID                       NextMac;
    //
    // The offset to MacCharacteristics need to be preserved. Older protocols directly referenced this.
    //
    NDIS_MAC_CHARACTERISTICS    MacCharacteristics;     // handler addresses
    PVOID                       NdisMacInfo;            // Mac information.
    KEVENT                      AdaptersRemovedEvent;   // used to find when all adapters are gone.
    BOOLEAN                     Unloading;              // TRUE if unloading
} NDIS_MAC_BLOCK, *PNDIS_MAC_BLOCK;

PVOID
GetSystemRoutineAddress (
    IN PUNICODE_STRING SystemRoutineName
    );

PVOID
FindExportedRoutineByName (
    IN PVOID DllBase,
    IN PANSI_STRING AnsiImageRoutineName
    );


typedef struct _NDIS_TRACK_MEM
{
    LIST_ENTRY  List;
    ULONG       Tag;
    UINT        Length;
    PVOID       Caller;
    PVOID       CallersCaller;
} NDIS_TRACK_MEM, *PNDIS_TRACK_MEM;

typedef struct _NDIS_DEFERRED_REQUEST_WORKITEM
{
    NDIS_WORK_ITEM          WorkItem;
    PVOID                   Caller;
    PVOID                   CallersCaller;
    PNDIS_REQUEST           Request;
    PNDIS_OPEN_BLOCK        Open;
    NDIS_OID                Oid;
    PVOID                   InformationBuffer;
} NDIS_DEFERRED_REQUEST_WORKITEM, *PNDIS_DEFERRED_REQUEST_WORKITEM;

// #define NDIS_MINIPORT_USES_MAP_REGISTERS            0x01000000
// #define NDIS_MINIPORT_USES_SHARED_MEMORY            0x02000000
// #define NDIS_MINIPORT_USES_IO                       0x04000000
// #define NDIS_MINIPORT_USES_MEMORY                   0x08000000


#if !NDIS_RECV_SCALE
//
// move this to ndismini.w for blackcomb
//

typedef struct _NDIS_MINIPORT_INTERRUPT_EX
{
    PKINTERRUPT                 InterruptObject;
    KSPIN_LOCK                  DpcCountLock;
    union
    {
        PVOID                   Reserved;
        PVOID                   InterruptContext;
    };
    W_ISR_HANDLER               MiniportIsr;
    W_HANDLE_INTERRUPT_HANDLER  MiniportDpc;
    KDPC                        InterruptDpc;
    PNDIS_MINIPORT_BLOCK        Miniport;

    UCHAR                       DpcCount;
    BOOLEAN                     Filler1;

    //
    // This is used to tell when all the Dpcs for the adapter are completed.
    //

    KEVENT                      DpcsCompletedEvent;

    BOOLEAN                     SharedInterrupt;
    BOOLEAN                     IsrRequested;
    struct _NDIS_MINIPORT_INTERRUPT_EX *NextInterrupt;
} NDIS_MINIPORT_INTERRUPT_EX, *PNDIS_MINIPORT_INTERRUPT_EX;

NDIS_STATUS
NdisMRegisterInterruptEx(
    OUT PNDIS_MINIPORT_INTERRUPT_EX Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    );

VOID
NdisMDeregisterInterruptEx(
    IN  PNDIS_MINIPORT_INTERRUPT_EX     MiniportInterrupt
    );

//
// for interrupts registered with NdisMRegisterInterruptEx 
// BOOLEAN
// NdisMSynchronizeWithInterruptEx(
//     IN  PNDIS_MINIPORT_INTERRUPT_EX  Interrupt,
//     IN  PVOID                        SynchronizeFunction,
//     IN  PVOID                        SynchronizeContext
//     );

#define NdisMSynchronizeWithInterruptEx(_Interrupt, _SynchronizeFunction, _SynchronizeContext) \
        NdisMSynchronizeWithInterrupt((PNDIS_MINIPORT_INTERRUPT)(_Interrupt),  _SynchronizeFunction, _SynchronizeContext)
#endif

#define NDIS_ORIGINAL_STATUS_FROM_PACKET(_Packet) ((PVOID)(_Packet)->Reserved[0])
#define NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(_P) NDIS_PER_PACKET_INFO_FROM_PACKET(_P, NdisReserved)

#define NDIS_MAX_USER_OPEN_HANDLES  0x01000000
#define NDIS_MAX_ADMIN_OPEN_HANDLES 0x01000000
#define NDIS_RESERVED_REF_COUNTS    (0xffffffff - NDIS_MAX_USER_OPEN_HANDLES - NDIS_RESERVED_REF_COUNTS)

#define NDIS_USER_OPEN_WAIT_TIME    50          // wait time in milliseconds

/*
#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Ndis,(5b5a3f4e,a33b,4d79,bbb7,97f46ac4d889), \
    WPP_DEFINE_BIT(NdisDebugFatal) \
    WPP_DEFINE_BIT(NdisDebugError) \
    WPP_DEFINE_BIT(NdisDebugWarn)  \
    WPP_DEFINE_BIT(NdisDebugLog)  \
    WPP_DEFINE_BIT(NdisDebugInfo) \
    )
*/

/*
NTSTATUS
ndisSetWmiSecurity(
    IN PNDIS_GUID              NdisGuid
    );
*/
#endif  // _WRAPPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndissym\makefile.inc ===
$(O)\ndis.c : ndissym.c
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndiskd\ndiskd.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>

#include <wdbgexts.h>
#include <stdlib.h> // needed for atoi function

#include "wrapper.h"
#include "mini.h"
#include "ndiskd.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER64, 0 };


#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


//
//  Names of interesting structures
//
CHAR *  NDIS_PROTOCOL_CHARACTERISTICS_NAME = "ndis!_NDIS50_PROTOCOL_CHARACTERISTICS";
CHAR *  NDIS_PROTOCOL_BLOCK_NAME = "ndis!_NDIS_PROTOCOL_BLOCK";
CHAR *  NDIS_OPEN_BLOCK_NAME = "ndis!_NDIS_OPEN_BLOCK";
CHAR *  NDIS_COMMON_OPEN_BLOCK_NAME = "ndis!_NDIS_COMMON_OPEN_BLOCK";
CHAR *  NDIS_MINIPORT_BLOCK_NAME = "ndis!_NDIS_MINIPORT_BLOCK";
CHAR *  NDIS_M_DRIVER_BLOCK_NAME = "ndis!_NDIS_M_DRIVER_BLOCK";
CHAR *  NDIS_CO_VC_PTR_BLOCK_NAME = "ndis!_NDIS_CO_VC_PTR_BLOCK";
CHAR *  NDIS_CO_VC_BLOCK_NAME = "ndis!_NDIS_CO_VC_BLOCK";
CHAR *  NDIS_CO_AF_BLOCK_NAME = "ndis!_NDIS_CO_AF_BLOCK";
CHAR *  NDIS_PACKET_NAME = "ndis!_NDIS_PACKET";
CHAR *  NDIS_BUFFER_NAME = "ndis!_MDL";
CHAR *  NDIS_STRING_NAME = "ndis!_UNICODE_STRING";
CHAR *  LIST_ENTRY_NAME = "ndis!_LIST_ENTRY";
CHAR *  NDIS_PKT_POOL_NAME = "ndis!_NDIS_PKT_POOL";
CHAR *  NDIS_TRACK_MEM_NAME = "ndis!_NDIS_TRACK_MEM";
CHAR *  NDIS_PKT_POOL_HDR_NAME = "ndis!_NDIS_PKT_POOL_HDR";
CHAR *  STACK_INDEX_NAME = "ndis!_STACK_INDEX";
CHAR *  NDIS_PACKET_STACK_NAME = "ndis!_NDIS_PACKET_STACK";
CHAR *  CPRD_NAME = "ndis!_CM_PARTIAL_RESOURCE_DESCRIPTOR";
CHAR *  CFRD_NAME = "ndis!_CM_FULL_RESOURCE_DESCRIPTOR";
CHAR *  CRL_NAME = "ndis!_CM_RESOURCE_LIST";
CHAR *  DEVICE_CAPS_NAME =  "ndis!_DEVICE_CAPABILITIES";
CHAR *  NDIS_PACKET_OOB_DATA_NAME = "ndis!_NDIS_PACKET_OOB_DATA";

typedef struct
{
    CHAR    Name[16];
    unsigned int     Val;
} DBG_LEVEL;

DBG_LEVEL DbgLevel[] = {
    {"INFO",  DBG_LEVEL_INFO},
    {"LOG",  DBG_LEVEL_LOG},
    {"WARN",  DBG_LEVEL_WARN},
    {"ERR",  DBG_LEVEL_ERR},
    {"FATAL",  DBG_LEVEL_FATAL}
    };

typedef struct
{
    CHAR    Name[16];
    unsigned int     Val;
} DBG_COMP;


DBG_COMP DbgSystems[] = {
    {"INIT",  DBG_COMP_INIT},
    {"CONFIG",  DBG_COMP_CONFIG},
    {"SEND",  DBG_COMP_SEND},
    {"RECV",  DBG_COMP_RECV},
    {"PROTOCOL",  DBG_COMP_PROTOCOL},
    {"BIND",  DBG_COMP_BIND},
    {"BUS_QUERY", DBG_COMP_BUSINFO},
    {"REGISTRY", DBG_COMP_REG},
    {"MEMORY",  DBG_COMP_MEMORY},
    {"FILTER",  DBG_COMP_FILTER},
    {"REQUEST",  DBG_COMP_REQUEST},
    {"WORK_ITEM",  DBG_COMP_WORK_ITEM},
    {"PNP",  DBG_COMP_PNP},
    {"PM",  DBG_COMP_PM},
    {"OPEN",  DBG_COMP_OPENREF},
    {"LOCKS",  DBG_COMP_LOCKS},
    {"RESET",  DBG_COMP_RESET},
    {"WMI",  DBG_COMP_WMI},
    {"NDIS_CO",  DBG_COMP_CO},
    {"REFERENCE",  DBG_COMP_REF}
    };


typedef struct
{
    CHAR    Name[40];
    UINT    Val;
} DBG_PER_PACKET_INFO_ID_TYPES;


DBG_PER_PACKET_INFO_ID_TYPES DbgPacketInfoIdTypes[] = {
    {"TcpIpChecksumPacketInfo", TcpIpChecksumPacketInfo},
    {"IpSecPacketInfo", IpSecPacketInfo},
    {"TcpLargeSendPacketInfo", TcpLargeSendPacketInfo},
    {"ClassificationHandlePacketInfo", ClassificationHandlePacketInfo},
    {"NdisReserved", NdisReserved},
    {"ScatterGatherListPacketInfo", ScatterGatherListPacketInfo},
    {"Ieee8021pPriority", Ieee8021pPriority},
    {"OriginalPacketInfo", OriginalPacketInfo},
    {"PacketCancelId", PacketCancelId},
    {"MaxPerPacketInfo", MaxPerPacketInfo}
    };

typedef struct
{
    CHAR    Name[20];
    unsigned int    Val;
} DBG_MEDIA_TYPES;

DBG_MEDIA_TYPES DbgMediaTypes[] = {
    {"802.3", NdisMedium802_3},
    {"802.5", NdisMedium802_5},
    {"FDDI", NdisMediumFddi},
    {"WAN", NdisMediumWan},
    {"LocalTalk", NdisMediumLocalTalk},
    {"Dix", NdisMediumDix},
    {"ArcNet Raw", NdisMediumArcnetRaw},
    {"ArcNet 878.2", NdisMediumArcnet878_2},
    {"ATM", NdisMediumAtm},
    {"Wireless WAN", NdisMediumWirelessWan},
    {"IRDA", NdisMediumIrda},
    {"BPC", NdisMediumBpc},
    {"CO-WAN", NdisMediumCoWan},
    {"IEEE1394",NdisMedium1394},
    {"Illegal", NdisMediumMax}
    };




typedef struct
{
    CHAR    Name[64];
    unsigned int    Val;

} DBG_MINIPORT_FLAGS;

DBG_MINIPORT_FLAGS DbgMiniportFlags[] = {
    {"NORMAL_INTERRUPTS", fMINIPORT_NORMAL_INTERRUPTS},
    {"IN_INITIALIZE", fMINIPORT_IN_INITIALIZE},
    {"ARCNET_BROADCAST_SET", fMINIPORT_ARCNET_BROADCAST_SET},
    {"BUS_MASTER", fMINIPORT_BUS_MASTER},
    {"64BIT_DMA", fMINIPORT_64BITS_DMA},
    {"DEREGISTERED_INTERRUPT", fMINIPORT_DEREGISTERED_INTERRUPT},
    {"SG_LIST", fMINIPORT_SG_LIST},
    {"REQUEST_TIMEOUT", fMINIPORT_REQUEST_TIMEOUT},
    {"PROCESSING_REQUEST", fMINIPORT_PROCESSING_REQUEST},
    {"IGNORE_PACKET_QUEUE", fMINIPORT_IGNORE_PACKET_QUEUE},
    {"IGNORE_REQUEST_QUEUE", fMINIPORT_IGNORE_REQUEST_QUEUE},
    {"IGNORE_TOKEN_RING_ERRORS", fMINIPORT_IGNORE_TOKEN_RING_ERRORS},
    {"CHECK_FOR_LOOPBACK", fMINIPORT_CHECK_FOR_LOOPBACK},
    {"INTERMEDIATE_DRIVER", fMINIPORT_INTERMEDIATE_DRIVER},
    {"NDIS_5", fMINIPORT_IS_NDIS_5},
    {"IS_CO", fMINIPORT_IS_CO},
    {"DESERIALIZED", fMINIPORT_DESERIALIZE},
    {"CALLING_RESET", fMINIPORT_CALLING_RESET},
    {"RESET_REQUESTED", fMINIPORT_RESET_REQUESTED},
    {"RESET_IN_PROGRESS", fMINIPORT_RESET_IN_PROGRESS},
    {"RESOURCES_AVAILABLE", fMINIPORT_RESOURCES_AVAILABLE},
    {"SEND_LOOPBACK_DIRECTED", fMINIPORT_SEND_LOOPBACK_DIRECTED},
    {"RESTORING_FILTERS", fMINIPORT_RESTORING_FILTERS},
    {"REQUIRES_MEDIA_POLLING", fMINIPORT_REQUIRES_MEDIA_POLLING},
    {"SUPPORTS_MEDIA_SENSE", fMINIPORT_SUPPORTS_MEDIA_SENSE},
    {"DOES_NOT_DO_LOOPBACK", fMINIPORT_DOES_NOT_DO_LOOPBACK},
    {"SECONDARY", fMINIPORT_SECONDARY},
    {"MEDIA_CONNECTED", fMINIPORT_MEDIA_CONNECTED},
    {"NETBOOT_CARD", fMINIPORT_NETBOOT_CARD},
    {"PM_HALTING", fMINIPORT_PM_HALTING}
    };


//
// flags that we care more if they are cleared
//
DBG_MINIPORT_FLAGS DbgMiniportClearedFlags[] = {
    {"NOT_BUS_MASTER", fMINIPORT_BUS_MASTER},
    {"NOT_IGNORE_TOKEN_RING_ERRORS", fMINIPORT_IGNORE_TOKEN_RING_ERRORS},
    {"NOT_RESOURCES_AVAILABLE", fMINIPORT_RESOURCES_AVAILABLE},
    {"NOT_SUPPORTS_MEDIA_SENSE", fMINIPORT_SUPPORTS_MEDIA_SENSE},
    {"DOES_LOOPBACK", fMINIPORT_DOES_NOT_DO_LOOPBACK},
    {"NOT_MEDIA_CONNECTED", fMINIPORT_MEDIA_CONNECTED}
    };


typedef DBG_MINIPORT_FLAGS DBG_MINIPORT_PNP_FLAGS;

DBG_MINIPORT_PNP_FLAGS DbgMiniportPnPFlags[] = {
    {"PM_SUPPORTED", fMINIPORT_PM_SUPPORTED},
    {"NO_SHUTDOWN", fMINIPORT_NO_SHUTDOWN},
    {"MEDIA_DISCONNECT_WAIT", fMINIPORT_MEDIA_DISCONNECT_WAIT},
    {"REMOVE_IN_PROGRESS", fMINIPORT_REMOVE_IN_PROGRESS},
    {"DEVICE_POWER_ENABLED", fMINIPORT_DEVICE_POWER_ENABLE},
    {"DEVICE_POWER_WAKE_ENABLE", fMINIPORT_DEVICE_POWER_WAKE_ENABLE},
    {"DEVICE_FAILED", fMINIPORT_DEVICE_FAILED},
    {"MEDIA_DISCONNECT_CANCELLED", fMINIPORT_MEDIA_DISCONNECT_CANCELLED},
    {"SEND_WAIT_WAKE", fMINIPORT_SEND_WAIT_WAKE},
    {"SYSTEM_SLEEPING", fMINIPORT_SYSTEM_SLEEPING},
    {"HIDDEN", fMINIPORT_HIDDEN},
    {"SWENUM", fMINIPORT_SWENUM},
    {"PM_HALTED", fMINIPORT_PM_HALTED},
    {"NO_HALT_ON_SUSPEND", fMINIPORT_NO_HALT_ON_SUSPEND},
    {"RECEIVED_START", fMINIPORT_RECEIVED_START},
    {"REJECT_REQUESTS", fMINIPORT_REJECT_REQUESTS},
    {"PROCESSING", fMINIPORT_PROCESSING},
    {"HALTING", fMINIPORT_HALTING},
    {"VERIFYING", fMINIPORT_VERIFYING},
    {"HARDWARE_DEVICE", fMINIPORT_HARDWARE_DEVICE},
    {"NDIS_WDM_DRIVER", fMINIPORT_NDIS_WDM_DRIVER},
    {"SHUT_DOWN", fMINIPORT_SHUT_DOWN},
    {"SHUTTING_DOWN", fMINIPORT_SHUTTING_DOWN},
    {"ORPHANED", fMINIPORT_ORPHANED},
    {"QUEUED_BIND_WORKITEM", fMINIPORT_QUEUED_BIND_WORKITEM},
    {"FILTER_IM", fMINIPORT_FILTER_IM}
 };

typedef DBG_MINIPORT_FLAGS DBG_MINIPORT_PNP_CAPABILITIES;

DBG_MINIPORT_PNP_CAPABILITIES DbgMiniportCapabilities[] = {
    {"NOT_STOPPABLE", NDIS_DEVICE_NOT_STOPPABLE},
    {"NOT_REMOVEABLE", NDIS_DEVICE_NOT_REMOVEABLE},
    {"NOT_SUSPENDABLE", NDIS_DEVICE_NOT_SUSPENDABLE},
    {"DISABLE_PM", NDIS_DEVICE_DISABLE_PM},
    {"DISABLE_WAKE_UP", NDIS_DEVICE_DISABLE_WAKE_UP},
    {"DISABLE_WAKE_ON_RECONNECT", NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT}
};

typedef DBG_MINIPORT_FLAGS DBG_MINIPORT_VERIFY_FLAGS;

DBG_MINIPORT_VERIFY_FLAGS DbgMiniportVerifyFlags[] = {
    {"FAIL_MAP_REG_ALLOC", fMINIPORT_VERIFY_FAIL_MAP_REG_ALLOC},
    {"FAIL_INTERRUPT_REGISTER", fMINIPORT_VERIFY_FAIL_INTERRUPT_REGISTER},
    {"FAIL_SHARED_MEM_ALLOC", fMINIPORT_VERIFY_FAIL_SHARED_MEM_ALLOC},
    {"FAIL_CANCEL_TIMER", fMINIPORT_VERIFY_FAIL_CANCEL_TIMER},
    {"FAIL_MAP_IO_SPACE", fMINIPORT_VERIFY_FAIL_MAP_IO_SPACE},
    {"FAIL_REGISTER_IO", fMINIPORT_VERIFY_FAIL_REGISTER_IO},
    {"FAIL_READ_CONFIG_SPACE", fMINIPORT_VERIFY_FAIL_READ_CONFIG_SPACE},
    {"FAIL_WRITE_CONFIG_SPACE", fMINIPORT_VERIFY_FAIL_WRITE_CONFIG_SPACE},
    {"FAIL_INIT_SG_DMA", fMINIPORT_VERIFY_FAIL_INIT_SG}
};


typedef struct
{

    CHAR    Name[32];
    unsigned long   Val;
} DBG_DEVICE_STATE;

DBG_DEVICE_STATE DbgDeviceState[] = {


    {"PowerDeviceUnspecified",PowerDeviceUnspecified},
    {"PowerDeviceD0",PowerDeviceD0},
    {"PowerDeviceD1",PowerDeviceD1},
    {"PowerDeviceD2",PowerDeviceD2},
    {"PowerDeviceD3",PowerDeviceD3},
    {"PowerDeviceMaximum",PowerDeviceMaximum},
    };



typedef struct
{
    CHAR    Name[32];
    unsigned long   Val;

} DBG_VC_FLAGS;


DBG_VC_FLAGS DbgVcPtrFlags[] = {
    {"VC_CALL_ACTIVE", VC_CALL_ACTIVE},
    {"VC_CALL_PENDING", VC_CALL_PENDING},
    {"VC_CALL_CLOSE_PENDING", VC_CALL_CLOSE_PENDING},
    {"VC_CALL_ABORTED", VC_CALL_ABORTED},
    {"VC_PTR_BLOCK_CLOSING", VC_PTR_BLOCK_CLOSING}
    };


DBG_VC_FLAGS DbgVcFlags[] = {
    {"VC_ACTIVE", VC_ACTIVE},
    {"VC_ACTIVATE_PENDING", VC_ACTIVATE_PENDING},
    {"VC_DEACTIVATE_PENDING", VC_DEACTIVATE_PENDING},
    {"VC_DELETE_PENDING", VC_DELETE_PENDING},
    {"VC_HANDOFF_IN_PROGRESS", VC_HANDOFF_IN_PROGRESS}
    };

typedef DBG_VC_FLAGS DBG_MINIPORT_PNP_DEVICE_STATE;

DBG_MINIPORT_PNP_DEVICE_STATE DbgMiniportPnPDeviceState[] = {
    {"PNP_DEVICE_ADDED", NdisPnPDeviceAdded},
    {"PNP_DEVICE_STARTED", NdisPnPDeviceStarted},
    {"PNP_DEVICE_QUERY_STOPPED", NdisPnPDeviceQueryStopped},
    {"PNP_DEVICE_STOPPED", NdisPnPDeviceStopped},
    {"PNP_DEVICE_QUERY_REMOVED", NdisPnPDeviceQueryRemoved},
    {"PNP_DEVICE_REMOVED", NdisPnPDeviceRemoved}
    };


typedef DBG_MINIPORT_FLAGS DBG_PACKET_FLAGS;

DBG_PACKET_FLAGS DbgPacketFlags[] = {
    {"MULTICAST_PACKET", NDIS_FLAGS_MULTICAST_PACKET},
    {"RESERVED2", NDIS_FLAGS_RESERVED2},
    {"RESERVED3", NDIS_FLAGS_RESERVED3},
    {"DONT_LOOPBACK", NDIS_FLAGS_DONT_LOOPBACK},
    {"IS_LOOPBACK_PACKET", NDIS_FLAGS_IS_LOOPBACK_PACKET},
    {"LOOPBACK_ONLY", NDIS_FLAGS_LOOPBACK_ONLY},
    {"RESERVED4", NDIS_FLAGS_RESERVED4},
    {"DOUBLE_BUFFERED", NDIS_FLAGS_DOUBLE_BUFFERED}
};



DBG_PACKET_FLAGS DbgNdisPacketFlags[] = {
    {"fPACKET_HAS_TIMED_OUT", fPACKET_HAS_TIMED_OUT},
    {"fPACKET_IS_LOOPBACK", fPACKET_IS_LOOPBACK},
    {"fPACKET_SELF_DIRECTED", fPACKET_SELF_DIRECTED},
    {"fPACKET_DONT_COMPLETE", fPACKET_DONT_COMPLETE},
    {"fPACKET_PENDING", fPACKET_PENDING},
    {"fPACKET_ALREADY_LOOPEDBACK", fPACKET_ALREADY_LOOPEDBACK},
    {"fPACKET_CLEAR_ITEMS", fPACKET_CLEAR_ITEMS},
    {"fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO", fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO},
    {"fPACKET_ALLOCATED_BY_NDIS", fPACKET_ALLOCATED_BY_NDIS}
};



typedef DBG_MINIPORT_FLAGS DBG_PROTOCOL_FLAGS;

DBG_PROTOCOL_FLAGS DbgProtocolFlags[]={
    {"NDIS_PROTOCOL_TESTER", NDIS_PROTOCOL_TESTER},
    {"NDIS_PROTOCOL_PROXY", NDIS_PROTOCOL_PROXY},
    {"NDIS_PROTOCOL_BIND_ALL_CO", NDIS_PROTOCOL_BIND_ALL_CO}
};

typedef DBG_MINIPORT_FLAGS DBG_OPEN_FLAGS;
DBG_OPEN_FLAGS DbgOpenFlags[]={
    {"OPEN_USING_ETH_ENCAPSULATION", fMINIPORT_OPEN_USING_ETH_ENCAPSULATION},
    {"OPEN_NO_LOOPBACK", fMINIPORT_OPEN_NO_LOOPBACK},
    {"OPEN_PMODE", fMINIPORT_OPEN_PMODE},
    {"OPEN_NO_PROT_RSVD", fMINIPORT_OPEN_NO_PROT_RSVD},
    {"OPEN_PROCESSING", fMINIPORT_OPEN_PROCESSING},
    {"PACKET_RECEIVED", fMINIPORT_PACKET_RECEIVED},
    {"STATUS_RECEIVED", fMINIPORT_STATUS_RECEIVED},
    {"OPEN_CLOSING", fMINIPORT_OPEN_CLOSING},
    {"OPEN_UNBINDING", fMINIPORT_OPEN_UNBINDING},
    {"OPEN_CALL_MANAGER", fMINIPORT_OPEN_CALL_MANAGER},
    {"OPEN_NOTIFY_PROCESSING", fMINIPORT_OPEN_NOTIFY_PROCESSING},
    {"OPEN_CLOSE_COMPLETE", fMINIPORT_OPEN_CLOSE_COMPLETE},
    {"OPEN_DONT_FREE", fMINIPORT_OPEN_DONT_FREE}
};


/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN ULONG64 dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

        if (count >= 3000)
            count = 3000;

        b = ReadMemory(dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG64 dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    CHAR *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

DECLARE_API( help )
{
    dprintf("NDIS extensions:\n");
    

    dprintf("   ndis                                dump ndis information\n");
    dprintf("   dbglevel [Level [Level] ...]        toggle debug level\n");
    dprintf("   dbgsystems [Level [Level] ...]      toggle debug systems\n");
    dprintf("   miniports <'all'>                   list all Miniports\n");
    dprintf("   gminiports <'all'>                  list all Miniports, even those not started yet\n");
    dprintf("   miniport <Miniport Block>           dump Miniport block\n");
    dprintf("   mopen <Miniport Open Block>         dump Miniport Open block\n");
    dprintf("   protocols                           dump all protocols and their opens\n");
    dprintf("   protocol <Protocol Block>           dump the protocols block's contents\n");
    dprintf("   pkt <Packet> <Verbosity>            dump the contents of the packet\n");
    dprintf("   pktpools                            list all allocated packet pools\n");
    dprintf("   mem                                 list log of allocated memory if enabled\n");
    dprintf("   opens                               dump all opens\n");
    dprintf("   findpacket v <VirtualAddress>       finds a packet containing a virtual address\n");
    dprintf("   findpacket p <PoolAddress>          finds un-returned packets in a pool\n");
}


VOID
ErrorCheckSymbols(
    CHAR    *symbol
    )
{
    dprintf("NDISKD: error - could not access %s - check symbols for ndis.sys\n",
            symbol);
}

DECLARE_API( dbglevel )
{
    INT i;
    INT col = 0;
    ULONG DbgSettings;
    CHAR argbuf[ MAX_PATH ];
    CHAR *p;
    ULONG64   dwAddress;
    DWORD   Written;

    dwAddress = GetExpression("ndis!ndisDebugLevel");

    if (dwAddress == 0)
    {
        ErrorCheckSymbols("ndis!ndisDebugLevel");
        return;
    }

    DbgSettings = GetUlongFromAddress(dwAddress);


    if (!args || !*args)
    {
        dprintf("Current setting: ");

        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (DbgSettings == DbgLevel[i].Val)
            {
                dprintf("  %s\n", DbgLevel[i].Name);

                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col++;
                }

                break;
            }
        }

        if (col != 0)
            dprintf("\n");

        dprintf("Available settings: \n");
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (!(DbgSettings == DbgLevel[i].Val))
            {
                dprintf("  %s", DbgLevel[i].Name);

                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col++;
                }
            }
        }

        if (col != 0)
            dprintf("\n");

        return;
    }

    strcpy( argbuf, args );

    for (p = mystrtok( argbuf, " \t,;" );
         p && *p;
         p = mystrtok(NULL, " \t,;"))
    {
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (strcmp(p, DbgLevel[i].Name) == 0)
            {
                DbgSettings = DbgLevel[i].Val;

            }
        }
    }

    WriteMemory(dwAddress, &DbgSettings, sizeof(DWORD), &Written);
}

DECLARE_API( dbgsystems )
{
    INT i;
    INT col = 0;
    DWORD DbgSettings;
    CHAR argbuf[ MAX_PATH ];
      char *p;
    ULONG64   dwAddress;
    DWORD   Written;

    dwAddress = GetExpression("ndis!ndisDebugSystems");

    if (dwAddress == 0)
    {
        ErrorCheckSymbols("ndis!ndisDebugSystems");
        return;
    }

    DbgSettings = GetUlongFromAddress(dwAddress);

    if (!args || !*args)
    {

        dprintf("Current settings:\n");

        for (i = 0; i < sizeof(DbgSystems)/sizeof(DBG_COMP); i++)
        {
            if (DbgSettings & DbgSystems[i].Val)
            {
                dprintf("  %s", DbgSystems[i].Name);
                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col ++;
                }
            }
        }
        if (col != 0)
            dprintf("\n");

        col = 0;

        dprintf("Available settings:\n");
        for (i = 0; i < sizeof(DbgSystems)/sizeof(DBG_COMP); i++)
        {
            if (!(DbgSettings & DbgSystems[i].Val))
            {
                dprintf("  %s", DbgSystems[i].Name);

                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col++;
                }
            }
        }

        if (col != 0)
            dprintf("\n");

        return;
    }

    strcpy( argbuf, args );

    for (p = mystrtok( argbuf, " \t,;" );
         p && *p;
         p = mystrtok(NULL, " \t,;"))
    {
       dprintf("\nArg = %s\n",p);

       for (i = 0; i < sizeof(DbgSystems)/sizeof(DBG_COMP); i++)
        {
            if (strcmp(p, DbgSystems[i].Name) == 0)
            {
                if (DbgSettings & DbgSystems[i].Val)
                {
                    DbgSettings &= ~DbgSystems[i].Val;
                }
                else
                {
                    DbgSettings |= DbgSystems[i].Val;
                }
            }
        }
    }

    WriteMemory(dwAddress, &DbgSettings, sizeof(DWORD), &Written);
}

DECLARE_API( miniports )
{
    ULONG64         Addr;
    ULONG           Val;
    ULONG64         DriverBlockAddr;
    ULONG64         MiniportAddr;
    CHAR            argbuf[ MAX_PATH ];
    BOOLEAN         fAll = FALSE;

    //
    // The flag fALL is used to dump all the miniport blocks in the minidriver list
    //
    if (args)
    {
        strcpy (argbuf,args);
        if ( strcmp ("all",argbuf )== 0 ) 
        {
            fAll = TRUE;
        }
    }

    Addr = GetExpression("ndis!ndisVerifierLevel");

    if (Addr != 0)
    {
        Val = GetUlongFromAddress(Addr);
        dprintf("NDIS Driver verifier level: %lx\n", Val);
    }
    else
    {
        ErrorCheckSymbols("ndis!ndisVerifierLevel");
    }

    Addr = GetExpression("ndis!ndisVeriferFailedAllocations");

    if (Addr != 0)
    {
        Val = GetUlongFromAddress(Addr);
        dprintf("NDIS Failed allocations   : %lx\n", Val);
    }
    else
    {
        ErrorCheckSymbols("ndis!ndisVeriferFailedAllocations");
    }

    DriverBlockAddr = GetExpression("ndis!ndisMiniDriverList");

    if (DriverBlockAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisMiniDriverList");
        return;
    }

    DriverBlockAddr = GetPointerFromAddress(DriverBlockAddr);

    while (DriverBlockAddr != 0)
    {
        GetFieldValue(DriverBlockAddr, NDIS_M_DRIVER_BLOCK_NAME, "DriverVersion", Val);
    
        dprintf("Miniport Driver Block: %p, Version %u.%u\n", DriverBlockAddr,
                                                            (USHORT)((Val & 0xffff0000)>>16),
                                                            (USHORT)(Val & 0x0000ffff));

        GetFieldValue(DriverBlockAddr, NDIS_M_DRIVER_BLOCK_NAME, "MiniportQueue", MiniportAddr);

        while (MiniportAddr != 0)
        {
            if (CheckControlC())
            {
                break;
            }

            dprintf("  Miniport: %p ", MiniportAddr);

            PrintMiniportName(MiniportAddr);
            dprintf("\n");

            if (fAll == TRUE)
            {
                PrintMiniportDetails(MiniportAddr);
                dprintf("\n");
            }

            GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "NextMiniport", MiniportAddr);
        }

        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(DriverBlockAddr, NDIS_M_DRIVER_BLOCK_NAME, "NextDriver", DriverBlockAddr);
    }
}


DECLARE_API(gminiports)
{
    ULONG64             MiniportListAddr;
    ULONG64             MiniportAddr;
    ULONG64             MiniBlockAddr;
    BOOLEAN             fAll = FALSE;
    CHAR                argbuf[ MAX_PATH ];

    if (args)
    {
        strcpy (argbuf,args);
        if ( strcmp ("all",argbuf )== 0 ) 
        {
            fAll = TRUE;
        }
    }

    MiniportListAddr = GetExpression("ndis!ndisMiniportList");

    if (MiniportListAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisMiniportList");
        return;
    }

    MiniportAddr = GetPointerFromAddress(MiniportListAddr);

    while (MiniportAddr != 0)
    {
        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DriverHandle", MiniBlockAddr);

        dprintf("  MiniBlock: %p, Miniport: %p  ", MiniBlockAddr, MiniportAddr);

        PrintMiniportName(MiniportAddr);
        dprintf("\n");

        if (fAll == TRUE)
        {
            PrintMiniportDetails(MiniportAddr);
            dprintf("\n");
        }

        GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "NextGlobalMiniport", MiniportAddr);
    }
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s NDIS Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{

    //
    // for now don't bother to version check
    //
    return;
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
//  VOID
//  PrintName(
//      ULONG64 UnicodeStringAddr
//      );
// print a unicode string
//
VOID
PrintName(
    ULONG64 UnicodeStringAddr
    )
{
    USHORT i;
#define MAX_STRING_LENGTH   256
    WCHAR ubuf[MAX_STRING_LENGTH];
    UCHAR abuf[MAX_STRING_LENGTH+1];
    ULONG MaxChars;

    ULONG64 BufAddr;
    USHORT  Length;
    USHORT  MaximumLength;

    ULONG64 Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "Buffer", Val);
    BufAddr = Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "Length", Val);
    Length = (USHORT)Val;

    GetFieldValue(UnicodeStringAddr, NDIS_STRING_NAME, "MaximumLength", Val);
    MaximumLength = (USHORT)Val;

    //
    // Truncate so that we don't crash with bad data.
    //
    MaxChars = (Length > MAX_STRING_LENGTH)? MAX_STRING_LENGTH: Length;

    if (!GetData(ubuf, BufAddr, MaxChars, "STRING"))
    {
        return;
    }

    for (i = 0; i < Length/2; i++)
    {
        abuf[i] = (UCHAR)ubuf[i];
    }
    abuf[i] = 0;

    dprintf("%s",abuf);
}

VOID
PrintMiniportName(
    ULONG64 MiniportAddr
    )
{
    ULONG64 Val;

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "pAdapterInstanceName", Val);
    PrintName(Val);
}



VOID
PrintMiniportDetails(
    ULONG64     MiniportAddr
    )
{
    ULONG       i;
    ULONG       j;
    ULONG       Flags;
    ULONG64     Val;
    ULONG       Offset;
    ULONG64     DeviceCapsAddr;
    ULONG64     DeviceStateAddr;
    ULONG64     ResourcesAddr;
    ULONG       DeviceState;
    ULONG       SizeOfDeviceState;
    ULONG       SystemWake, DeviceWake;
    ULONG       SizeOfPvoid;
    ULONG64     VarAddr;

#define MAX_FLAGS_PER_LINE  3

    InitTypeRead(MiniportAddr, ndis!NDIS_MINIPORT_BLOCK);

    Val = ReadField(MiniportAdapterContext);
    dprintf("    AdapterContext : %p\n", Val);

    Flags = (ULONG)ReadField(Flags);
    dprintf("    Flags          : %08x\n", Flags);

    j = 0;
    for (i = 0; i < sizeof(DbgMiniportFlags)/sizeof(DBG_MINIPORT_FLAGS); i++)
    {
        if (Flags & DbgMiniportFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgMiniportFlags[i].Name);

            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }

    j = 0;
    for (i = 0; i < sizeof(DbgMiniportClearedFlags)/sizeof(DBG_MINIPORT_FLAGS); i++)
    {
        if (!(Flags & DbgMiniportClearedFlags[i].Val))
        {
            if (j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgMiniportClearedFlags[i].Name);

            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }


    Flags = (ULONG)ReadField(PnPFlags);
    dprintf("    PnPFlags       : %08x\n", Flags);
    j = 0;
    for (i = 0; i < sizeof(DbgMiniportPnPFlags)/sizeof(DBG_MINIPORT_PNP_FLAGS); i++)
    {
        if (Flags & DbgMiniportPnPFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgMiniportPnPFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }

//    dprintf("    CheckforHang interval : %ld seconds\n", ReadField(CheckForHangSeconds));
//    dprintf("        CurrentTick       : %04u\n", ReadField(CFHangCurrentTick));
//    dprintf("        IntervalTicks     : %04u\n", ReadField(CFHangTicks));
    dprintf("    InternalResetCount    : %04u\n", (USHORT)ReadField(InternalResetCount));
    dprintf("    MiniportResetCount    : %04u\n", (USHORT)ReadField(MiniportResetCount));

    dprintf("    References            : %u\n", (USHORT)ReadField(Ref.ReferenceCount));
    dprintf("    UserModeOpenReferences: %ld\n", (ULONG)ReadField(UserModeOpenReferences));

    dprintf("    PnPDeviceState        : ");
    Val = (ULONG)ReadField(PnPDeviceState);
    if (Val <= NdisPnPDeviceRemoved)
    {
        dprintf("%s\n", DbgMiniportPnPDeviceState[Val].Name);
    }

    dprintf("    CurrentDevicePowerState : ");

    Val = (ULONG)ReadField(CurrentDevicePowerState);
    if (Val < PowerDeviceMaximum)
    {
        dprintf("%s\n", DbgDeviceState[Val].Name);
    }
    else 
    {
        dprintf("Illegal Value\n");
    }


    dprintf("    Bus PM capabilities\n");

    //
    //  Use GetFieldValue() rather than ReadField() for bit fields.
    //
    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.DeviceD1", Val);
    dprintf("\tDeviceD1:\t\t%lu\n", (ULONG)Val);

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.DeviceD2", Val);
    dprintf("\tDeviceD2:\t\t%lu\n", (ULONG)Val);

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.WakeFromD0", Val);
    dprintf("\tWakeFromD0:\t\t%lu\n", (ULONG)Val);

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.WakeFromD1", Val);
    dprintf("\tWakeFromD1:\t\t%lu\n", (ULONG)Val);

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.WakeFromD2", Val);
    dprintf("\tWakeFromD2:\t\t%lu\n", (ULONG)Val);

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.WakeFromD3", Val);
    dprintf("\tWakeFromD3:\t\t%lu\n\n", (ULONG)Val);

    dprintf("\tSystemState\t\tDeviceState\n");

    do
    {
        if (GetFieldOffset(NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.DeviceState", &Offset) != 0)
        {
            dprintf("Can't get offset of DeviceCaps.DeviceState in %s\n", NDIS_MINIPORT_BLOCK_NAME);
            break;
        }


        SizeOfDeviceState = sizeof(ULONG) ; // sizeof(ULONG) is same across all platforms
        DeviceStateAddr = MiniportAddr + (ULONG)Offset;
        DeviceState = GetUlongFromAddress(DeviceStateAddr);
        DeviceStateAddr += SizeOfDeviceState;

        if (DeviceState == PowerDeviceUnspecified)
        {
            dprintf("\tPowerSystemUnspecified\tPowerDeviceUnspecified\n");
        }
        else
        {
            dprintf("\tPowerSystemUnspecified\t\tD%ld\n", (ULONG)(DeviceState - 1));
        }

        for (i = 1; i < PowerSystemMaximum; i++)
        {
            DeviceState = GetUlongFromAddress(DeviceStateAddr);
            DeviceStateAddr += SizeOfDeviceState;

            if (DeviceState ==  PowerDeviceUnspecified)
            {
                dprintf("\tS%lu\t\t\tPowerDeviceUnspecified\n",(i-1));
            }
            else
            {
                dprintf("\tS%lu\t\t\tD%lu\n",(ULONG)(i-1), (ULONG)(DeviceState - 1));
            }

        }
    }
    while (FALSE);


    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.SystemWake", SystemWake);
    if (SystemWake == PowerSystemUnspecified)
        dprintf("\tSystemWake: PowerSystemUnspecified\n");
    else
        dprintf("\tSystemWake: S%lu\n", (ULONG)(SystemWake - 1));

    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "DeviceCaps.DeviceWake", DeviceWake);
    if (DeviceWake == PowerDeviceUnspecified)
    {
        dprintf("\tDeviceWake: PowerDeviceUnspecified\n");
    }
    else
    {
        dprintf("\tDeviceWake: D%lu\n", (ULONG)(DeviceWake - 1));        
    }
    Flags = (ULONG)ReadField(PnPFlags);
    if ((DeviceWake != PowerDeviceUnspecified) &&
        (SystemWake != PowerSystemUnspecified) &&
        (Flags & fMINIPORT_PM_SUPPORTED))
    {
        ULONG   WakeUpEnable;

        WakeUpEnable = (ULONG)ReadField(WakeUpEnable);
        dprintf("\n    WakeupMethods Enabled %lx:\n\t", WakeUpEnable);

        if (WakeUpEnable & NDIS_PNP_WAKE_UP_MAGIC_PACKET)
            dprintf("WAKE_UP_MAGIC_PACKET  ");
        if (WakeUpEnable & NDIS_PNP_WAKE_UP_PATTERN_MATCH)
            dprintf("WAKE_UP_PATTERN_MATCH  ");
        if (WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE)
            dprintf("WAKE_UP_LINK_CHANGE  ");

        dprintf("\n    WakeUpCapabilities:\n");

        dprintf("\tMinMagicPacketWakeUp: %lu\n",(ULONG)ReadField(PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp));
        dprintf("\tMinPatternWakeUp: %lu\n", (ULONG)ReadField(PMCapabilities.WakeUpCapabilities.MinPatternWakeUp));
        dprintf("\tMinLinkChangeWakeUp: %lu\n", (ULONG)ReadField(PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp));
    }

    Flags = (ULONG)ReadField(PnPCapabilities);
    dprintf("    Current PnP and PM Settings:          : %08x\n", Flags);
    j = 0;
    for (i = 0; i < sizeof(DbgMiniportCapabilities)/sizeof(DBG_MINIPORT_PNP_CAPABILITIES); i++)
    {
        if (Flags & DbgMiniportCapabilities[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgMiniportCapabilities[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }


    if (j != 0)
    {
        dprintf("\n");
    }

    ResourcesAddr = ReadField(AllocatedResources);
    if (ResourcesAddr)
    {
        dprintf("    Allocated Resources:\n");
        PrintResources(ResourcesAddr);
        dprintf("    Translated Allocated Resources:\n");
        ResourcesAddr = ReadField(AllocatedResourcesTranslated);
        PrintResources(ResourcesAddr);
    }
    else 
    {
        dprintf("    No Resources Allocated\n");
    }

    dprintf("    MediaType      : ");
    Val = ReadField(MediaType);
    if (Val < NdisMediumMax)
    {
        dprintf("%s\n", DbgMediaTypes[Val].Name);
    }
    else
    {
        dprintf("Illegal value: %d\n", Val);
    }
    dprintf("    DeviceObject   : %p, PhysDO : %p  Next DO: %p\n",
                    ReadField(DeviceObject),
                    ReadField(PhysicalDeviceObject),
                    ReadField(NextDeviceObject));
    dprintf("    MapRegisters   : %p\n", ReadField(MapRegisters));
    dprintf("    FirstPendingPkt: %p\n", ReadField(FirstPendingPacket));
/*    
    SizeOfPvoid = GetTypeSize("SINGLE_LIST_ENTRY");
    if (GetFieldOffset(NDIS_MINIPORT_BLOCK_NAME, "SingleWorkItems", &Offset) != 0)
    {
        dprintf("Can't get offset of SingleWorkItems in %s\n", NDIS_MINIPORT_BLOCK_NAME);
    }
    else
    {
        VarAddr = MiniportAddr + Offset;
        dprintf("    SingleWorkItems:\n");
        for (i = 0, j = 1; i < NUMBER_OF_SINGLE_WORK_ITEMS; i++)
        {
            if (j == 1)
            {
                dprintf("      ");
            }
            dprintf("[%d]: %p ", i, GetPointerFromAddress(VarAddr));
            VarAddr += SizeOfPvoid;
            if (j == 4)
            {
                dprintf("\n");
                j = 1;
            }
            else
            {
                j++;
            }
        }
        if (j != 1)
        {
            dprintf("\n");
        }
    }
*/
    Flags = (ULONG)ReadField(DriverVerifyFlags);
    dprintf("    DriverVerifyFlags  : %08x\n", Flags);
    j = 0;
    for (i = 0; i < sizeof(DbgMiniportVerifyFlags)/sizeof(DBG_MINIPORT_VERIFY_FLAGS); i++)
    {
        if (Flags & DbgMiniportVerifyFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgMiniportVerifyFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }

    dprintf("    Miniport Interrupt : %p\n", ReadField(Interrupt));

    PrintMiniportOpenList(MiniportAddr);
}


VOID
PrintMiniportOpenList(
    ULONG64                 MiniportAddr
    )
{
    ULONG64                 OpenAddr;
    ULONG64                 ProtocolAddr;
    ULONG64                 ProtocolContext;
    ULONG                   Offset;

    InitTypeRead(MiniportAddr, ndis!NDIS_MINIPORT_BLOCK);

    dprintf("    Miniport Open Block Queue:\n");
    OpenAddr = ReadField(OpenQueue);

    if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
    {
        dprintf("Cant get offset of Name in Protocol block!");
        Offset = (ULONG)-1;
    }

    while (OpenAddr != 0)
    {
        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolHandle", ProtocolAddr);

        dprintf("      %p: Protocol %p = ", OpenAddr, ProtocolAddr);

        if (Offset != (ULONG)-1)
        {
            PrintName(ProtocolAddr + Offset);
        }

        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolBindingContext", ProtocolContext);

        dprintf(", ProtocolBindingContext %p\n", ProtocolContext);

        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "MiniportNextOpen", OpenAddr);
    }
}



//
//  PrintResources: ResourceListAddr is addr of CM_RESOURCE_LIST
//
VOID
PrintResources(
    ULONG64     ResourceListAddr
    )
{
    ULONG64             FullResourceDescrAddr;
    ULONG64             PartialResourceDescrAddr;
    ULONG               SizeOfFullDescr;
    ULONG               SizeOfPartialDescr;
    ULONG               Offset;
    ULONG               CountVal;
    ULONG64             Val1;
    ULONG               Val2, Val3, TypeVal;
    ULONG               j;

    SizeOfFullDescr = GetTypeSize(CFRD_NAME);
    SizeOfPartialDescr = GetTypeSize(CPRD_NAME);

    if (GetFieldOffset(CRL_NAME, "List", &Offset) != 0)
    {
        dprintf("Can't get offset of List in CM_RESOURCE_LIST\n");
        return;
    }
    FullResourceDescrAddr = ResourceListAddr + Offset;

    GetFieldValue(FullResourceDescrAddr, CFRD_NAME, "PartialResourceList.Count", CountVal);
    if (GetFieldOffset(CFRD_NAME, "PartialResourceList.PartialDescriptors", &Offset) != 0)
    {
        dprintf("Can't get offset of PartialResourceList.PartialDescriptors in %s\n",
                CFRD_NAME);
        return;
    }

    PartialResourceDescrAddr = FullResourceDescrAddr + Offset;

    for (j = 0; j < CountVal; j++)
    {
        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "Type", TypeVal);

        switch (TypeVal)
        {
            case CmResourceTypePort:
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Port.Start", Val1);
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Port.Length", Val2);
                dprintf("        IO Port: %p, Length: %lx\n", Val1, Val2);
                break;

            case CmResourceTypeMemory:
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Memory.Start", Val1);
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Memory.Length", Val2);
                dprintf("        Memory: %p, Length: %lx\n", Val1, Val2);
                break;

            case CmResourceTypeInterrupt:
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Interrupt.Level", Val3);
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Interrupt.Vector", Val2);
                dprintf("        Interrupt Level: %lx, Vector: %lx\n", Val3, Val2);
                break;

            case CmResourceTypeDma:
                GetFieldValue(PartialResourceDescrAddr, CPRD_NAME, "u.Dma.Channel", Val3);
                dprintf("        DMA Channel: %lx\n", Val3);
                break;

            default:
                break;
        }

        PartialResourceDescrAddr += SizeOfPartialDescr;
    }

}


DECLARE_API( miniport )
{
    ULONG64 pMiniport;

    if (!args || !*args)
    {
        dprintf("Usage: miniport <pointer to miniport block>\n");
        return;
    }

    pMiniport = (ULONG64)GetExpression(args);

    dprintf(" Miniport %p : ", pMiniport);

    PrintMiniportName(pMiniport);
    dprintf("\n");
    PrintMiniportDetails(pMiniport);
}


DECLARE_API( mopen )
{
    ULONG64                 OpenAddr;
    ULONG64                 ProtocolAddr;
    ULONG64                 MiniportAddr;
    ULONG64                 AfAddr;
    ULONG64                 Val;
    ULONG64                 VcHeadAddr;
    ULONG64                 VcPtrAddr;
    ULONG                   ClientLinkOffset;
    ULONG                   CallMgrLinkOffset;

    ULONG                   Offset;
    ULONG                   Flags;
    ULONG                   VcCount;
    UINT                    i, j;

    BOOLEAN                 bPrintingActiveVcs;
    BOOLEAN                 fCoOpen = FALSE;
    BOOLEAN                 fClientOpen;

    if (!args || !*args)
    {
        dprintf("Usage: mopen <pointer to miniport open block>\n");
        return;
    }

    OpenAddr = GetExpression(args);

    if (OpenAddr == 0)
    {
        dprintf("Invalid open block address\n");
        return;
    }

    dprintf(" Miniport Open Block %p\n", OpenAddr);

    //
    //  Get and print the protocol's name
    //
    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolHandle", ProtocolAddr);

    dprintf("    Protocol %p = ", ProtocolAddr);

    if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
    {
        dprintf("Cant get offset of Name in Protocol block!");
    }
    else
    {
        PrintName(ProtocolAddr + Offset);
    }

    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolBindingContext", Val);
    dprintf(", ProtocolContext %p\n", Val);
    

    //
    //  Get and print the miniport's name
    //
    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "MiniportHandle", MiniportAddr);

    dprintf("    Miniport %p = ", MiniportAddr);

    PrintMiniportName(MiniportAddr);
    dprintf("\n");

    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "MiniportAdapterContext", Val);
    dprintf("    MiniportAdapterContext: %p\n", Val);

    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "Flags", Val);
    dprintf("    Flags                 : %08x\n", Val);

    j = 0;
    for (i = 0; i < sizeof(DbgOpenFlags)/sizeof(DBG_OPEN_FLAGS ); i++)
    {
        if (Val & DbgOpenFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgOpenFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }


    fClientOpen = (Val & fMINIPORT_OPEN_CLIENT) ? TRUE : FALSE;
        
    GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "References", (ULONG)Val);
    dprintf("    References            : %d\n", (ULONG)Val);


    //
    //  Check if this is a CONDIS miniport. If not, we are done.
    //
    GetFieldValue(MiniportAddr, NDIS_MINIPORT_BLOCK_NAME, "Flags", Flags);

    fCoOpen = ((Flags & fMINIPORT_IS_CO) != 0);

    if (!fCoOpen)
    {
        return;
    }

    //
    //  If there are open AFs on this Open, display them.
    //
    GetFieldValue(OpenAddr, NDIS_OPEN_BLOCK_NAME, "NextAf", AfAddr);

    while (AfAddr != 0)
    {
        ULONG       AfFlags;
        ULONG       Refs;
        ULONG64     AfOpenAddr;
        ULONG64     AfProtocolAddr;

        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "Flags", AfFlags);
        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "References", Refs);

        dprintf("    Af Block %p, Flags %08x, References %d\n", AfAddr, AfFlags, Refs);

        //
        //  Client open values:
        //
        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "ClientOpen", AfOpenAddr);

        dprintf("      Client  Open %p : ", AfOpenAddr);

        GetFieldValue(AfOpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolHandle", AfProtocolAddr);

        if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
        {
            dprintf("Cant get offset of Name in Protocol block!");
        }
        else
        {
            PrintName(AfProtocolAddr + Offset);
        }

        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "ClientContext", Val);

        dprintf(", CL AFContext %p\n", Val);

        //
        //  Call Mgr open values:
        //
        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "CallMgrOpen", AfOpenAddr);

        dprintf("      CallMgr Open %p : ", AfOpenAddr);

        GetFieldValue(AfOpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolHandle", AfProtocolAddr);

        PrintName(AfProtocolAddr + Offset);

        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "CallMgrContext", Val);

        dprintf(", CM AFContext %p\n", Val);

        GetFieldValue(AfAddr, NDIS_CO_AF_BLOCK_NAME, "NextAf", AfAddr);
    }

    //
    //  If there are any VCs in the active VC list, display them.
    //

    //
    //  First, get some offsets.
    //
    if (GetFieldOffset(NDIS_CO_VC_PTR_BLOCK_NAME, "ClientLink", &ClientLinkOffset) != 0)
    {
        dprintf("Can't get offset of ClientLink in NDIS_CO_VC_PTR_BLOCK!\n");
        return;
    }

    if (GetFieldOffset(NDIS_CO_VC_PTR_BLOCK_NAME, "CallMgrLink", &CallMgrLinkOffset) != 0)
    {
        dprintf("Can't get offset of CallMgrLink in NDIS_CO_VC_PTR_BLOCK!\n");
        return;
    }

    if (GetFieldOffset(NDIS_OPEN_BLOCK_NAME, "ActiveVcHead", &Offset) != 0)
    {
        dprintf("Can't get offset of ActiveVcHead in NDIS_OPEN_BLOCK!\n");
        return;
    }

    VcHeadAddr = OpenAddr + Offset;

    GetFieldValue(OpenAddr, NDIS_OPEN_BLOCK_NAME, "ActiveVcHead.Flink", VcPtrAddr);

    if (VcPtrAddr != VcHeadAddr)
    {
        dprintf("\n    Active VC list:\n");
    }

    bPrintingActiveVcs = TRUE;

Again:

    VcCount = 0;

    while (VcPtrAddr != VcHeadAddr)
    {
        if (CheckControlC())
        {
            break;
        }

        if (VcCount++ == 2000)
        {
            // something wrong?
            dprintf("Too many VCs (%d), bailing out!\n", VcCount);
            break;
        }

        if (bPrintingActiveVcs)
        {
            VcPtrAddr -= ClientLinkOffset;
        }
        else
        {
            if (fClientOpen)
            {
                VcPtrAddr -= ClientLinkOffset;
            }
            else
            {
                VcPtrAddr -= CallMgrLinkOffset;
            }
        }

        PrintVcPtrBlock(VcPtrAddr);

        if (bPrintingActiveVcs)
        {
            GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "ClientLink.Flink", VcPtrAddr);
        }
        else
        {
            if (fClientOpen)
                GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "ClientLink.Flink", VcPtrAddr);
            else
                GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "CallMgrLink.Flink", VcPtrAddr);            
        }
    }

    if (bPrintingActiveVcs)
    {
        bPrintingActiveVcs = FALSE;
        //
        //  If there are any VCs in the inactive VC list, display them.
        //
        if (GetFieldOffset(NDIS_OPEN_BLOCK_NAME, "InactiveVcHead", &Offset) != 0)
        {
            dprintf("Can't get offset of InActiveVcHead in NDIS_OPEN_BLOCK!\n");
            return;
        }

        VcHeadAddr = OpenAddr + Offset;

        GetFieldValue(OpenAddr, NDIS_OPEN_BLOCK_NAME, "InactiveVcHead.Flink", VcPtrAddr);

        if (VcPtrAddr != VcHeadAddr)
        {
            dprintf("\n    Inactive VC list:\n");
            goto Again;
        }
    }

    return;

}


DECLARE_API( vc )
{
    ULONG64             VcPtrAddr;
    ULONG64             ClientOpen, CallMgrOpen, AfBlock, Miniport;

    if (!args || !*args)
    {
        dprintf("Usage: vc <pointer to VC pointer block>\n");
        return;
    }

    VcPtrAddr = GetExpression(args);

    PrintVcPtrBlock(VcPtrAddr);

    //
    //  For some reason, InitTypeRead(NDIS_CO_VC_PTR_BLOCK_NAME) followed
    //  by ReadField() didn't work - we get all 0's.
    //
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "ClientOpen", ClientOpen);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "CallMgrOpen", CallMgrOpen);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "AfBlock", AfBlock);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "Miniport", Miniport);

    dprintf("      ClientOpen %p CallMgrOpen %p AfBlock %p Miniport %p\n",
                ClientOpen,
                CallMgrOpen,
                AfBlock,
                Miniport);
}

VOID
PrintProtocolOpenQueue(
    ULONG64             ProtocolAddr)
{

    ULONG64         OpenAddr;
    ULONG64         MiniportHandle;
    ULONG64         MiniportAddr;
    ULONG64         Val;

    GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "OpenQueue", OpenAddr);

    while (OpenAddr != 0)
    {
        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "MiniportHandle", MiniportAddr);
        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolNextOpen", Val);

        dprintf("    Open %p - ", OpenAddr);

        dprintf("Miniport: %p ", MiniportAddr);
        PrintMiniportName(MiniportAddr);
        dprintf("\n");

        OpenAddr = Val;
    }

    dprintf("\n");
}


VOID
PrintVcPtrBlock(
    IN  ULONG64                 VcPtrAddr)
{
    ULONG64         VcBlockAddr;
    ULONG64         ClientContext, CallMgrContext, MiniportContext;
    ULONG           Flags;
    ULONG           VcFlags;
    INT             i, j;

    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "CallFlags", Flags);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "ClientContext", ClientContext);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "CallMgrContext", CallMgrContext);
    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "MiniportContext", MiniportContext);
    dprintf("    VcPtr %p, Contexts: Cl %p, CM %p, MP %p, CallFlags %08x\n",
                    VcPtrAddr,
                    ClientContext,
                    CallMgrContext,
                    MiniportContext,
                    Flags);

    j = 0;
    for (i = 0; i < sizeof(DbgVcPtrFlags)/sizeof(DBG_VC_FLAGS); i++)
    {
        if (Flags & DbgVcPtrFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgVcPtrFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }

    GetFieldValue(VcPtrAddr, NDIS_CO_VC_PTR_BLOCK_NAME, "VcBlock", VcBlockAddr);

    if (VcBlockAddr != 0)
    {
        GetFieldValue(VcBlockAddr, NDIS_CO_VC_BLOCK_NAME, "Flags", VcFlags);

        dprintf("      VcBlock %p, Flags %08x\n", VcBlockAddr, VcFlags);
        j = 0;
        for (i = 0; i < sizeof(DbgVcFlags)/sizeof(DBG_VC_FLAGS); i++)
        {
            if (VcFlags & DbgVcFlags[i].Val)
            {
                if (j == 0)
                {
                    dprintf("                     ");
                }
                dprintf("%s", DbgVcFlags[i].Name);
                j++;

                if (j != MAX_FLAGS_PER_LINE)
                {
                    dprintf(", ");
                }
                else
                {
                    dprintf("\n");
                    j = 0;
                }
            }
        }

        if (j != 0)
        {
            dprintf("\n");
        }
    }
}



DECLARE_API( protocols )
{
    ULONG64             ProtocolListAddr;
    ULONG64             ProtocolAddr;
    ULONG               Offset;

    ProtocolListAddr = GetExpression("ndis!ndisProtocolList");
    ProtocolAddr = GetPointerFromAddress(ProtocolListAddr);

    while (ProtocolAddr != 0)
    {
        if (CheckControlC())
        {
            break;
        }

        dprintf(" Protocol %p: ", ProtocolAddr);
        if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
        {
            dprintf("Cant get offset of Name in Protocol block!");
        }
        else
        {
            PrintName(ProtocolAddr + Offset);
        }
        dprintf("\n");

        PrintProtocolOpenQueue(ProtocolAddr);

        GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "NextProtocol", ProtocolAddr);
    }
}

   
VOID
PrintNdisBuffer(
    ULONG64         BufferAddr
    )
{
    ULONG64     Val1;
    ULONG64     Val2;

    dprintf("NDIS_BUFFER at %p\n", BufferAddr);

    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "Next", Val1);
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "Size", Val2);

    dprintf("  Next           %p\n  Size           %x\n", Val1, (ULONG)Val2);

    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "MdlFlags", Val1);
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "Process", Val2);

    dprintf("  MdlFlags       %x\n  Process        %p\n", (ULONG)Val1, Val2);
  
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "MappedSystemVa", Val1);
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "StartVa", Val2);

    dprintf("  MappedSystemVa %p\n  Start VA       %p\n", Val1, Val2);
  
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "ByteCount", Val1);
    GetFieldValue(BufferAddr, NDIS_BUFFER_NAME, "ByteOffset", Val2);

    dprintf("  ByteCount      %x\n  ByteOffset     %x\n", (ULONG)Val1, (ULONG)Val2);

}


// Verbosity for packet display:
//      1. Print Packet.Private
//      2. Print NdisPacketExtension
//      3. Print NDIS_PACKET_REFERENCE
//      4. Print NDIS_BUFFER_LIST
//

DECLARE_API( pkt )
{
    ULONG64     PacketAddr;
    INT         Verbosity;
    CHAR        argbuf[ MAX_PATH ];
    CHAR        arglist[10][MAX_PATH];
    CHAR        *str;
    INT         index=0;
    CHAR        *p;
   
    if (!args || !*args) 
    {
        dprintf("Usage: Packet <pointer to packet> <verbosity>\n");
        return;
    }        

    PacketAddr = GetExpression(args); 
     
    strcpy(argbuf,args);
     
    for (p = mystrtok( argbuf, " \t,;" );
         p && *p;
         p = mystrtok(NULL, " \t,;"))
    {
        strcpy(&arglist[index++][0],p);
    }

    Verbosity = atoi(&arglist[1][0]);

    if (index>2 || Verbosity>4)
    {
        dprintf("Usage: pkt <pointer to packet> <verbosity>\n");
        dprintf("1-Packet Private, 2-Packet Extension\n");
        dprintf("3-Ndis Reference, 4-Buffer List\n");
        return;
    }
      
    dprintf("NDIS_PACKET at %p\n", PacketAddr);

    switch(Verbosity)
    {
        case 4:
            PrintNdisBufferList(PacketAddr);
            // FALLTHRU
     
        case 3:
            PrintNdisReserved(PacketAddr);
            // FALLTHRU

        case 2:
            PrintNdisPacketExtension(PacketAddr);
            // FALLTHRU
       
        case 1:
        default:
            PrintNdisPacketPrivate(PacketAddr);
            break;
    }
}


VOID
PrintPacketPrivateFlags(
    ULONG64 PacketAddr
    )
{
    ULONG       NdisPacketFlags;
    ULONG       i;
    ULONG       j;
    ULONG       Flags;

    #define MAX_FLAGS_PER_LINE  3

    GetFieldValue(PacketAddr, NDIS_PACKET_NAME, "Private.Flags", Flags);

    //
    // Prints Flags and NdisPacketFlags
    //
    dprintf("\n  ");

    dprintf("    Private.Flags          : %08x\n", Flags);
    j = 0;
    for (i = 0; i < sizeof(DbgPacketFlags)/sizeof(DBG_PACKET_FLAGS); i++)
    {
        if (Flags & DbgPacketFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgPacketFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }

    GetFieldValue(PacketAddr, NDIS_PACKET_NAME, "Private.NdisPacketFlags", NdisPacketFlags);

    dprintf("  ");

    dprintf("    Private.NdisPacketFlags: %01x\n", NdisPacketFlags);
    j = 0;
    for (i = 0; i < sizeof(DbgNdisPacketFlags)/sizeof(DBG_PACKET_FLAGS); i++)
    {
        if (NdisPacketFlags & DbgNdisPacketFlags[i].Val)
        {
            if (j == 0)
            {
                dprintf("                     ");
            }
            dprintf("%s", DbgNdisPacketFlags[i].Name);
            j++;

            if (j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if (j != 0)
    {
        dprintf("\n");
    }
}


VOID
PrintNdisPacketPrivate(
    ULONG64     PacketAddr
    )
{ 
    ULONG64     Val1, Val2;
    ULONG64     Addr1, Addr2;

    dprintf("\nPacket.Private\n");
    InitTypeRead(PacketAddr, ndis!NDIS_PACKET);

    Val1 = ReadField(Private.PhysicalCount);
    Val2 = ReadField(Private.TotalLength);

    dprintf("  PhysicalCount       %.8d  Total Length        %.8x\n", 
            (ULONG)Val1, (ULONG)Val2);

    Addr1 = ReadField(Private.Head);
    Addr2 = ReadField(Private.Tail);
    dprintf("  Head                %p  Tail                %p\n", Addr1, Addr2);

    Addr1 = ReadField(Private.Pool);
    Val1 = (UINT)ReadField(Private.Count);
    dprintf("  Pool                %p  Count               %p\n", Addr1, Val1);

    Val1 = ReadField(Private.Flags);
    Val2 = (BOOLEAN)ReadField(Private.ValidCounts);
    dprintf("  Flags               %08x  ValidCounts         %.2x\n", (ULONG)Val1, (BOOLEAN)Val2);

    Val1 = (UCHAR)ReadField(Private.NdisPacketFlags);
    Val2 = (USHORT)ReadField(Private.NdisPacketOobOffset);
    dprintf("  NdisPacketFlags     %08x  NdisPacketOobOffset %.4x\n", (UCHAR)Val1, (USHORT)Val2);

    PrintPacketPrivateFlags (PacketAddr);
}




VOID 
PrintNdisPacketExtension(
    ULONG64         PacketAddr
    )
{
    ULONG64 PacketExtensionAddr;
    ULONG   PtrSize;
    UINT    i;
    USHORT  OobOffset;

    GetFieldValue(PacketAddr, NDIS_PACKET_NAME, "Private.NdisPacketOobOffset", OobOffset);
    PacketExtensionAddr = PacketAddr + OobOffset + GetTypeSize(NDIS_PACKET_OOB_DATA_NAME);
    PtrSize = IsPtr64() ? 8 : 4;


    for (i = 0; i < MaxPerPacketInfo; i++)
    {
        dprintf("  %d. %s = %p\n",
            i, DbgPacketInfoIdTypes[i].Name, GetPointerFromAddress(PacketExtensionAddr));
        PacketExtensionAddr += PtrSize;
    }

}


VOID
PrintNdisBufferList(
    ULONG64     PacketAddr
    )
{
    ULONG64     BufAddr;
    ULONG64     TailAddr;

    GetFieldValue(PacketAddr, NDIS_PACKET_NAME, "Private.Head", BufAddr);
    GetFieldValue(PacketAddr, NDIS_PACKET_NAME, "Private.Tail", TailAddr);

    while (BufAddr != 0)
    {
        if (CheckControlC())
        {
            break;
        }

        PrintNdisBuffer(BufAddr);

        if (BufAddr == TailAddr)
        {
            break;
        }

        GetFieldValue(BufAddr, NDIS_BUFFER_NAME, "Next", BufAddr);
    }
}

VOID
PrintNdisReserved(
    ULONG64     PacketAddr
    )
{
    ULONG   Offset;
    ULONG   Size;
    ULONG64 EntryAddr;
    ULONG64 EntryVal;
    ULONG   NumEntries;
    ULONG   EntrySize;
    ULONG   i;

    if (GetFieldOffsetAndSize(NDIS_PACKET_NAME, "MacReserved", &Offset, &Size) != 0)
    {
        dprintf("Can't get offset of MacReserved in %s!\n", NDIS_PACKET_NAME);
        return;
    }

    EntrySize = IsPtr64() ? 8 : 4;
    NumEntries = Size / EntrySize;
    EntryAddr = PacketAddr + Offset;

    dprintf("MacReserved[]:");
    for (i = 0; i < NumEntries; i++)
    {
        EntryVal = GetPointerFromAddress(EntryAddr);
        dprintf("    %p  ", EntryVal);
        EntryAddr += EntrySize;
    }
    dprintf("\n");
}



VOID
PrintProtocolDetails(
    ULONG64     ProtocolAddr
    )
{
    ULONG64     NameAddr;
    ULONG64     ProtocolCharsAddr;
    ULONG64     Val1, Val2;
    ULONG       Val;
    ULONG       Offset;

    GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "BindDeviceName", NameAddr);

    if (NameAddr != 0)
    {
        dprintf(" BindDeviceName is ");
        PrintName(NameAddr);
        dprintf("\n");
    }

    GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "RootDeviceName", NameAddr);

    if (NameAddr != 0)
    {
        dprintf(" RootDeviceName is ");
        PrintName(NameAddr);
        dprintf("\n");
    }

    GetFieldValue(ProtocolAddr, NDIS_PROTOCOL_BLOCK_NAME, "Ref.ReferenceCount", Val);
    dprintf(" RefCount %d\n", Val);
    dprintf("\n");

    //
    //  Walk the Open Block Queue
    //
    PrintProtocolOpenQueue(ProtocolAddr);

    if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics", &Offset) != 0)
    {
        dprintf("Can't get offset of ProtocolCharacteristics in %s\n",
            NDIS_PROTOCOL_BLOCK_NAME);
        return;
    }

    ProtocolCharsAddr = ProtocolAddr + Offset;

    //
    //  Addresses of handlers.
    //
    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "BindAdapterHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "UnbindAdapterHandler", Val2);

    dprintf(" BindAdapterHandler   %p, UnbindAdapterHandler  %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "PnPEventHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "UnloadHandler", Val2);

    dprintf(" PnPEventHandler      %p, UnloadHandler         %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "OpenAdapterCompleteHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "CloseAdapterCompleteHandler", Val2);

    dprintf(" OpenAdapterComplete  %p, CloseAdapterComplete  %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "SendCompleteHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "TransferDataCompleteHandler", Val2);

    dprintf(" SendCompleteHandler  %p, TransferDataComplete  %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "ReceiveHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "ReceivePacketHandler", Val2);

    dprintf(" ReceiveHandler       %p, ReceivePacketHandler  %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "ReceiveCompleteHandler", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "StatusHandler", Val2);

    dprintf(" ReceiveComplete      %p, StatusHandler         %p\n", Val1, Val2);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "StatusCompleteHandler", Val1);

    dprintf(" StatusComplete       %p\n", Val1);

    GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                    "AssociatedMiniDriver", Val1);

    dprintf(" AssociatedMiniDriver %p\n", Val1);

    {
        ULONG       i;
        ULONG       j;
        ULONG       Flags;

        #define MAX_FLAGS_PER_LINE  3

        dprintf("\n  ");

        GetFieldValue(ProtocolCharsAddr, NDIS_PROTOCOL_CHARACTERISTICS_NAME,
                        "Flags", Val1);

        Flags = (ULONG)Val1;

        dprintf("    Flags          : %08x\n", Flags);
        j = 0;
        for (i = 0; i < sizeof(DbgProtocolFlags)/sizeof(DBG_PROTOCOL_FLAGS ); i++)
        {
            if (Flags & DbgProtocolFlags[i].Val)
            {
                if (j == 0)
                {
                    dprintf("                     ");
                }
                dprintf("%s", DbgProtocolFlags[i].Name);
                j++;

                if (j != MAX_FLAGS_PER_LINE)
                {
                    dprintf(", ");
                }
                else
                {
                    dprintf("\n");
                    j = 0;
                }
            }
        }

        if (j != 0)
        {
            dprintf("\n");
        }
   }
}


DECLARE_API( protocol )
{
    ULONG64                 ProtocolAddr;
    ULONG                   Offset;

    //
    // Verify if any args are present
    //
    if (!args || !*args)
    {
        dprintf("Usage: protocol <pointer to protocol block>\n");
        return;
    }

    ProtocolAddr = GetExpression(args);

    dprintf(" Protocol %p : ", ProtocolAddr);

    if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
    {
        dprintf("Can't get offset of Name in Protocol block!");
    }
    else
    {
        PrintName(ProtocolAddr + Offset);
    }
    dprintf("\n");

    PrintProtocolDetails(ProtocolAddr);
}



/**
   
   Routine to get offset and size of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.
   
 **/
ULONG GetFieldOffsetAndSize(
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize) 
{ 
   FIELD_INFO flds = {
       Field, "", 0, 
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;
   LPSTR dot, last=Field;
   
   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
}

ULONG GetUlongFromAddress (
    ULONG64 Location)
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG64 GetPointerFromAddress(
    ULONG64 Location)
{
    ULONG64 Value;
    ULONG result;

    if (!ReadPointer(Location,&Value)) 
    {
        dprintf("unable to read from %p\n",Location);
        return 0;
    }

    return Value;
}

DECLARE_API(pktpools)
{
    ULONG64             PoolListAddr;
    ULONG64             LinkAddr;
    ULONG64             Pool;
    ULONG64             Allocator;
    ULONG               LinkOffset;
    LONG                BlocksAllocated;
    ULONG               BlockSize;
    USHORT              PacketLength;
    USHORT              PktsPerBlock;
    
    
    PoolListAddr = GetExpression("ndis!ndisGlobalPacketPoolList");

    if (PoolListAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisGlobalPacketPoolList");
        return;
    }
    
    GetFieldValue(PoolListAddr, LIST_ENTRY_NAME, "Flink", LinkAddr);

    //
    //  First, get some offsets.
    //
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, "GlobalPacketPoolList", &LinkOffset) != 0)
    {
        dprintf("Can't get offset of GlobalPacketPoolList in NDIS_PKT_POOL!\n");
        return;
    }


    dprintf("Pool      Allocator  BlocksAllocated  BlockSize  PktsPerBlock  PacketLength\n");
    
    while (LinkAddr !=  PoolListAddr)
    {
        if (CheckControlC())
        {
            break;
        }
        Pool = LinkAddr - LinkOffset;
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "Allocator", Allocator);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "BlocksAllocated", BlocksAllocated);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "BlockSize", BlockSize);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PktsPerBlock", PktsPerBlock);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PacketLength", PacketLength);
        
        dprintf("%p  %p   0x%lx\t      0x%lx\t 0x%lx\t       0x%lx\n", Pool, 
                                                                       Allocator,
                                                                       BlocksAllocated,
                                                                       BlockSize,
                                                                       PktsPerBlock,
                                                                       PacketLength);
        
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "GlobalPacketPoolList.Flink", LinkAddr);

        if (LinkAddr == 0)
        {
            break;
        }

    }

}

/*
DECLARE_API(pktpool)
{
    ULONG64 PktPoolAddr;
    
    //
    // Verify if any args are present
    //
    if (!args || !*args)
    {
        dprintf("Usage: pktpool <pointer to a Ndis packet pool>\n");
        return;
    }

    PktPoolAddr = GetExpression(args);

    dprintf(" Packet Pool %p : ", PktPoolAddr);

    
}
*/

DECLARE_API(mem)
{
    ULONG64             MiniportAddr, MiniBlockAddr;
    ULONG64             Miniport, MiniBlock;
    ULONG64             ListAddr;
    ULONG64             LinkAddr;
    ULONG64             TrackMem, Address, Caller, CallersCaller;
    ULONG               LinkOffset;
    ULONG               Tag;
    UINT                Length;
    BOOLEAN             Done;

    do
    {
        MiniBlockAddr = GetExpression("ndis!ndisDriverTrackAlloc");
        if (MiniBlockAddr == 0)
        {
            ErrorCheckSymbols("ndis!ndisDriverTrackAlloc");
            break;
        }
        
        MiniportAddr = GetExpression("ndis!ndisMiniportTrackAlloc");
        if (MiniportAddr == 0)
        {
            ErrorCheckSymbols("ndis!ndisMiniportTrackAlloc");
            break;
        }
        
        //
        //  First, get some offsets.
        //
        if (GetFieldOffset(NDIS_TRACK_MEM_NAME, "List", &LinkOffset) != 0)
        {
            dprintf("Can't get offset of List in NDIS_TRACK_MEM!\n");
            break;
        }

        ListAddr = GetExpression("ndis!ndisDriverTrackAllocList");
        if (ListAddr == 0)
        {
            ErrorCheckSymbols("ndis!ndisDriverTrackAllocList");
            break;
        }

        Done = FALSE;

        MiniBlock = GetPointerFromAddress(MiniBlockAddr);
        dprintf("Allocations charged to Miniport Driver Block at %p\n", MiniBlock);
again:        
        GetFieldValue(ListAddr, LIST_ENTRY_NAME, "Flink", LinkAddr);

        dprintf("Address     Tag      Length    Caller     Caller'sCaller\n");
        
        while (LinkAddr !=  ListAddr)
        {
            if (CheckControlC())
            {
                break;
            }
            TrackMem = (ULONG64)((PUCHAR)LinkAddr - LinkOffset);
            Address = TrackMem + sizeof(NDIS_TRACK_MEM);
            
            GetFieldValue(TrackMem, NDIS_TRACK_MEM_NAME, "Length", Length);
            GetFieldValue(TrackMem, NDIS_TRACK_MEM_NAME, "Tag", Tag);
            GetFieldValue(TrackMem, NDIS_TRACK_MEM_NAME, "Caller", Caller);
            GetFieldValue(TrackMem, NDIS_TRACK_MEM_NAME, "CallersCaller", CallersCaller);
            
            dprintf("%p    %c%c%c%c   %8lx    %p   %p\n", 
                                Address, 
                                Tag & 0xff,
                                (Tag >> 8) & 0xff,
                                (Tag >> 16) & 0xff, 
                                (Tag >> 24) & 0xff,
                                Length, Caller, CallersCaller);
            
            GetFieldValue(LinkAddr, NDIS_TRACK_MEM_NAME, "List.Flink", LinkAddr);

            if (LinkAddr == 0)
            {
                break;
            }

        }

        if (Done)
            break;

        Done = TRUE;
        ListAddr = GetExpression("ndis!ndisMiniportTrackAllocList");
        if (ListAddr == 0)
        {
            ErrorCheckSymbols("ndis!ndisMiniportTrackAllocList");
            break;
        }
        
        Miniport = GetPointerFromAddress(MiniportAddr);
        dprintf("\nAllocations charged to Miniport at %p\n", Miniport);
        
        GetFieldValue(ListAddr, LIST_ENTRY_NAME, "Flink", LinkAddr);
        goto again;
    }while (FALSE);
    
}

DECLARE_API(ndis)
{
    ULONG64   dwAddress;
    ULONG     CheckedVersion;
    //
    // get Ndis build date and time
    //
    dwAddress = GetExpression("ndis!ndisChecked");

    if (dwAddress != 0)
    {
        CheckedVersion = GetUlongFromAddress(dwAddress);
        if (CheckedVersion == 1)
            dprintf("Checked");
        else
            dprintf("Free");
        dprintf(" Ndis built on: ");
        dwAddress = GetExpression("ndis!ndisBuildDate");
        if (dwAddress != 0)
        {
            PrintName(dwAddress);
        }
        
        dprintf(", ");
        dwAddress = GetExpression("ndis!ndisBuildTime");
        if (dwAddress != 0)
        {
            PrintName(dwAddress);
        }

        dprintf(", by ");
        dwAddress = GetExpression("ndis!ndisBuiltBy");
        if (dwAddress != 0)
        {
            PrintName(dwAddress);
        }
        
        dprintf(".\n");
        
    }

}

DECLARE_API(opens)
{
    ULONG64             OpenListAddr;
    ULONG64             OpenAddr;
    ULONG64             ProtocolAddr;
    ULONG64             MiniportAddr;
    ULONG               Offset;

    OpenListAddr = GetExpression("ndis!ndisGlobalOpenList");

    if (OpenListAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisGlobalOpenList");
        return;
    }

    OpenAddr = GetPointerFromAddress(OpenListAddr);


    if (GetFieldOffset(NDIS_PROTOCOL_BLOCK_NAME, "ProtocolCharacteristics.Name", &Offset) != 0)
    {
        dprintf("Cant get offset of Name in Protocol block!");
        return;
    }

    while (OpenAddr != 0)
    {
        if (CheckControlC())
        {
            break;
        }

        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "ProtocolHandle", ProtocolAddr);
        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "MiniportHandle", MiniportAddr);

        dprintf("  Open %p \n", OpenAddr);
        if (MiniportAddr)
        {
            dprintf("    Miniport: %p - ", MiniportAddr);
            PrintMiniportName(MiniportAddr);
            dprintf("\n");
        }
        if (ProtocolAddr)
        {
            dprintf("    Protocol: %p - ", ProtocolAddr);
            PrintName(ProtocolAddr + Offset);
            dprintf("\n");
        }
        
        dprintf("\n");

        GetFieldValue(OpenAddr, NDIS_COMMON_OPEN_BLOCK_NAME, "NextGlobalOpen", OpenAddr);
    }
}

/*++
Routine Desc:
   This function searches one block for the packet with the
   specified virtual address.

Argument:
   CurBlock        --- The starting of the searched block
   CurPacket       --- The first packet inside CurBlock to search
   PktsPerBlock    --- Number of packets inside the searched block
   PacketStackSize --- The stack size inside the searched block
   Flags           --- 1: Free block to search
                   --- 0: Used block to search
   Address         --- The virtual address
   PacketLength    --- Packet length of the search block
   BlockSize       --- The size of the current block
   
Return Value:
   True  --- Packet found
   False --- Packet not found
   
--*/
BOOL 
SearchVaInOneBlock(
        ULONG64  CurBlock,
        ULONG    PktsPerBlock,
        ULONG    PacketStackSize,
        UCHAR    Flags,
        ULONG64  Address,
        USHORT   PacketLength,
        ULONG    BlockSize)
{
    USHORT        i;
    UCHAR         NdisPacketFlags;
    ULONG64       TmpVal;
    PVOID         MappedSystemVa;
    ULONG         ByteCount;
    ULONG64       pNdisBuf;
    PUCHAR        p;
    ULONG64       CurPacket;
    
   
    CurPacket = CurBlock + GetTypeSize(NDIS_PKT_POOL_HDR_NAME);
    p = (PUCHAR)CurPacket;
    
    for(i = 0; i < PktsPerBlock; i++, p += PacketLength)
    {
        if (CheckControlC())
        {
            break;
        }
        CurPacket = (ULONG64)(p + PacketStackSize);
        //
        // Flags = 1 means free blocks
        // 
        if (Flags)
        {
            //
            // skip the packet if it is not allocated, check for the flag
            //
            GetFieldValue(CurPacket, NDIS_PACKET_NAME,
                          "Private.NdisPacketFlags", NdisPacketFlags);
                
            if ((NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) == 0) 
            {
                continue;
            }
                
            //
            // For packets in the free list
            // 
            GetFieldValue(CurPacket, NDIS_PACKET_NAME,
                          "Private.Head", pNdisBuf);
           
            //
            // PAGE_SIZE may not be BlockSize
            // 
             
            if (pNdisBuf >= CurBlock && pNdisBuf < CurBlock + BlockSize) 
                  
            {
                
                continue;
            }
        }
        //
        // for each allocated packet, walk through all MDLs
        //
        GetFieldValue(CurPacket, NDIS_PACKET_NAME,
                      "Private.Head", pNdisBuf);
         
               
        while(pNdisBuf)
        {
            GetFieldValue(pNdisBuf, NDIS_BUFFER_NAME,
                           "MappedSystemVa", TmpVal);
            MappedSystemVa = (PVOID)TmpVal ;
             
            GetFieldValue((ULONG64)pNdisBuf, NDIS_BUFFER_NAME,
                            "ByteCount", ByteCount);
                   
            if (Address >= (ULONG64)MappedSystemVa
                && Address < (ULONG64)MappedSystemVa + ByteCount)
            {
                //
                // Packet found, and print out the information about the packet
                // 
                dprintf("\nPacket found\n");
                dprintf("Packet at 0x%p\n", CurPacket);
                PrintNdisPacketPrivate(CurPacket);
                return TRUE;
            }
            
            GetFieldValue((ULONG64)pNdisBuf, NDIS_BUFFER_NAME,
                           "Next", TmpVal);
           
            pNdisBuf = TmpVal;
        }
                
             
    }
    return FALSE;
}


/*++
Roution Desc:
   This function traverses blocks inside a list to search for the packet

Arguments:
   CurBlockLink      --- The "List" addresss inside one block
   BlocksHeadAddress --- The header address of the block list inside one pool
   BlcokLinkOffset   --- The offset of "List" inside one block
   PktsPerBlock      --- Number of packets inside the searched block
   PacketStackSize   --- The stack size inside the searched block
   Flags             --- 1: Free block to search
                     --- 0: Used block to search
   Address           --- The virtual address
   PacketLength      --- Packet length of the search block
   BlockSize         --- Size of the block
   
Return Value:
   True  --- Packet found
   False --- Packet not found

--*/
BOOL 
SearchVaInBlocks(
        ULONG64 CurBlockLink,
        ULONG64 BlocksHeadAddr,
        ULONG   BlockLinkOffset,
        ULONG   PacketStackSize,
        USHORT  PktPerBlock,
        UCHAR   Flags,
        ULONG64 Address,
        USHORT  PacketLength,
        ULONG   BlockSize)
{
    
    ULONG64 CurBlock;
    BOOL    fRet;
    
    while((ULONG64)CurBlockLink != BlocksHeadAddr)
    {
        if (CheckControlC())
        {
            break;
        }
        //
        // for each free block, walk through all allocated packets
        //
        CurBlock = (ULONG64)CurBlockLink - BlockLinkOffset;
   
   
        dprintf("\nSearching %s block <0x%p>\n", (Flags == 1)? "Free":"Used", CurBlock);
        
        fRet = SearchVaInOneBlock(CurBlock,
                                 PktPerBlock,
                                 PacketStackSize,
                                 Flags,
                                 Address,
                                 PacketLength,
                                 BlockSize);
        if (fRet)
        {
            return fRet;
        }
            
        GetFieldValue((ULONG64)CurBlockLink, LIST_ENTRY_NAME, 
                       "Flink", CurBlockLink);
        
        if (CurBlockLink == 0)
        {
            break;
        }
            
    }
    
    return FALSE;
}


/*++
Routine Desc:
   This function searches one block for the packets in use.

Argument:
   CurBlock        --- The starting of the searched block
   PktsPerBlock    --- Number of packets inside the searched block
   PacketStackSize --- The stack size inside the searched block
   Flags           --- 1: Free block to search
                   --- 0: Used block to search
   Address         ---  The virtual address
   PacketLength    --- Packet length of the search block

Return Value:
   None
   
--*/
void 
SearchPktInOneBlock(
        ULONG64  CurBlock,
        ULONG    PktsPerBlock,
        ULONG    PacketStackSize,
        UCHAR    Flags,
        USHORT   PacketLength)
{
    USHORT        i;
    ULONG64       BlockStartAddr;
    PUCHAR        p;
    ULONG64       pStackIndex;
    ULONG         Index;
    ULONG64       CurPacket;
   

    CurPacket = CurBlock + GetTypeSize(NDIS_PKT_POOL_HDR_NAME);
    p = (PUCHAR)CurPacket;
    
    for(i = 0; i < PktsPerBlock; i++, p += PacketLength)
    {
        if (CheckControlC())
        {
            break;
        }
     
        CurPacket = (ULONG64)(p + PacketStackSize);
        pStackIndex = CurPacket - sizeof(ULONG); // sizeof(ULONG) is same across all platforms
        Index = GetUlongFromAddress((ULONG64)pStackIndex);                           
        
        if (Index != (ULONG)-1)
        {
            dprintf("Packet at 0x%p\n", CurPacket);
        }
            
    }
}

/*++
Roution Desc:
   This function traverses blocks inside a list to search for the packets in use

Arguments:
   CurBlockLink      --- The "List" addresss inside one block
   BlocksHeadAddress --- The header address of the block list inside one pool
   BlcokLinkOffset   --- The offset of "List" inside one block
   PktsPerBlock      --- Number of packets inside the searched block
   PacketStackSize   --- The stack size inside the searched block
   Flags             --- 1: Free block to search
                     --- 0: Used block to search
   PacketLength      --- Packet length of the search block
   
Return Value:
   None
--*/
void 
SearchPktInBlocks(
        ULONG64 CurBlockLink,
        ULONG64 BlocksHeadAddr,
        ULONG   BlockLinkOffset,
        ULONG   PacketStackSize,
        USHORT  PktPerBlock,
        UCHAR   Flags,
        USHORT  PacketLength)
{
    
    ULONG64 CurBlock;
    ULONG64 TmpVal;
    
    while(CurBlockLink != BlocksHeadAddr)
    {
        if (CheckControlC())
        {
            break;
        }
        //
        // for each free block, walk through all allocated packets
        //
        CurBlock = (ULONG64)CurBlockLink - BlockLinkOffset;
   
        dprintf("\nSearching %s block <0x%p>\n", (Flags == 1)? "Free":"Used", CurBlock);
   
        SearchPktInOneBlock(CurBlock,
                            PktPerBlock,
                            PacketStackSize,
                            Flags,
                            PacketLength);
            
        GetFieldValue((ULONG64)CurBlockLink, LIST_ENTRY_NAME, 
                       "Flink", TmpVal);
        CurBlockLink = TmpVal;
        
        if (CurBlockLink == 0)
        {
            break;
        }
            
    }
    
}

/*++
Routine Desc:
    This function is to find the packets with the given virtual address.
    It traverses each pool, and inside one pool it traverses freeblockslist 
    and usedblockslist, then inside each block in the list, it search for 
    the packet with the given virtual address
    
    
--*/
void
FindPacketWithVa(ULONG64 Address)
{
    ULONG64             PoolListAddr;
    ULONG64             LinkAddr;
    ULONG64             Pool;
    ULONG               LinkOffset;
    LONG                BlocksAllocated;
    ULONG               BlockSize;
    USHORT              PacketLength;
    USHORT              PktsPerBlock;
    ULONG               NumberOfStacks;
    ULONG               PacketStackSize;
    ULONG               FreeBlocksLinkOffset;
    ULONG               UsedBlocksLinkOffset;
    ULONG               BlockLinkOffset;
    ULONG64             PoolFreeBlocksListAddr;
    ULONG64             PoolUsedBlocksListAddr;
    ULONG64             CurBlockLink;   
    ULONG64             BlocksHeadAddr;
    BOOL                fRet;
    ULONG64             NumberOfStacksAddr;
    
    
    PoolListAddr = GetExpression("ndis!ndisGlobalPacketPoolList");

    if (PoolListAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisGlobalPacketPoolList");
        return;
    }
 
    GetFieldValue(PoolListAddr, LIST_ENTRY_NAME, "Flink", LinkAddr);
    if (LinkAddr == 0)
    {
        dprintf("Can't get Flink of PoolListAddr.\n");
        return;
    }
    
    NumberOfStacksAddr = GetExpression("ndis!ndisPacketStackSize");

    if (NumberOfStacksAddr == 0)
    {
        ErrorCheckSymbols("ndis!ndisPacketStackSize");
        return;
    }
    NumberOfStacks = GetUlongFromAddress(NumberOfStacksAddr);

    PacketStackSize = (ULONG)GetTypeSize(STACK_INDEX_NAME) 
                       + (ULONG)GetTypeSize(NDIS_PACKET_STACK_NAME) * NumberOfStacks;
    
    //
    //  First, get some offsets.
    //
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, "GlobalPacketPoolList", &LinkOffset) != 0)
    {
        dprintf("Can't get offset of GlobalPacketPoolList in NDIS_PKT_POOL!\n");
        return;
    }
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, 
                "FreeBlocks",&FreeBlocksLinkOffset) != 0)
    {
        dprintf("Can't get offset of FreeBlocks in NDIS_PKT_POOL!\n");
        return;
    }
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, "UsedBlocks", &UsedBlocksLinkOffset) != 0)
    {
        dprintf("Can't get offset of UsedBlocks in NDIS_PKT_POOL!\n");
       return;
    }


    if (GetFieldOffset(NDIS_PKT_POOL_HDR_NAME, "List", &BlockLinkOffset) != 0)
    {
        dprintf("Can't get offset of List in NDIS_PKT_POOL_HDR!\n");
        return;
    }


    //
    // walk through all the allocated packet pools
    //
    while (LinkAddr !=  PoolListAddr)
    {
        //
        // Just safe check, usually this condition never satisfied
        if (LinkAddr == 0)
        {
            break;
        }
        
        if (CheckControlC())
        {
            break;
        }
        //
        // Get the pool
        // 
        Pool = LinkAddr - LinkOffset;

        PoolFreeBlocksListAddr = Pool + FreeBlocksLinkOffset;
        PoolUsedBlocksListAddr = Pool + UsedBlocksLinkOffset;
        

        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "BlockSize", BlockSize);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PktsPerBlock", PktsPerBlock);
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PacketLength", PacketLength);

        //
        // walk through all free and used blocks on this packet pool
        //
        BlocksHeadAddr = PoolFreeBlocksListAddr;
        // 
        // Search free blocks
        // 
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, 
                     "FreeBlocks.Flink", CurBlockLink);

        if (CurBlockLink != 0)
        { 
            fRet = SearchVaInBlocks ((ULONG64)CurBlockLink,
                                      BlocksHeadAddr,
                                      BlockLinkOffset,
                                      PacketStackSize,
                                      PktsPerBlock,
                                      1,
                                      Address,
                                      PacketLength,
                                      BlockSize);
            if (fRet)
            {
                return;
            }
        }
        
        BlocksHeadAddr = PoolUsedBlocksListAddr;
        // 
        // Search used blocks
        GetFieldValue(Pool, NDIS_PKT_POOL_NAME, 
                      "UsedBlocks.Flink", CurBlockLink);
 
        if (CurBlockLink != 0)
        {
            fRet = SearchVaInBlocks (CurBlockLink,
                                      BlocksHeadAddr,
                                      BlockLinkOffset,
                                      PacketStackSize,
                                      PktsPerBlock,
                                      0,
                                      Address,
                                      PacketLength,
                                      BlockSize);
            if (fRet)
            {
                return;
            }
        }
                
        //
        // Go to the next pool
        // 
        GetFieldValue(LinkAddr, LIST_ENTRY_NAME,
                      "Flink", LinkAddr);
        
        if (LinkAddr == 0)
        {
            break;
        }

    }
    dprintf("\nPACKET with VA 0x%p Not Found\n", Address);

}

/*++
Routine Desc:
    This function is to find the packets in use inside a pool with the 
    given pool address. Inside the pool it traverses freeblockslist 
    and usedblockslist, then inside each block in the list, it search for 
    the packets that are in use
    
    
--*/
void
FindPacketInUse(ULONG64 Pool)
{
    ULONG               BlockSize;
    USHORT              PacketLength;
    USHORT              PktsPerBlock;
    ULONG               NumberOfStacks;
    ULONG               PacketStackSize;
    ULONG64             TmpVal;
    ULONG               FreeBlocksLinkOffset;
    ULONG               UsedBlocksLinkOffset;
    ULONG               BlockLinkOffset;
    ULONG64             PoolFreeBlocksListAddr;
    ULONG64             PoolUsedBlocksListAddr;
    ULONG64             CurBlockLink;   
    ULONG64             BlocksHeadAddr;
    ULONG64             NumberOfStacksAddr;
    
    
    NumberOfStacksAddr = GetExpression("ndis!ndisPacketStackSize");
   
    NumberOfStacks = GetUlongFromAddress(NumberOfStacksAddr);


    PacketStackSize = (ULONG)GetTypeSize(STACK_INDEX_NAME) 
                       + (ULONG)GetTypeSize(NDIS_PACKET_STACK_NAME) * NumberOfStacks;
    
    //
    //  First, get some offsets.
    //
    
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, 
                "FreeBlocks",&FreeBlocksLinkOffset) != 0)
    {
        dprintf("Can't get offset of FreeBlocks in NDIS_PKT_POOL!\n");
        return;
    }
    if (GetFieldOffset(NDIS_PKT_POOL_NAME, "UsedBlocks", &UsedBlocksLinkOffset) != 0)
    {
        dprintf("Can't get offset of UsedBlocks in NDIS_PKT_POOL!\n");
       return;
    }


    if (GetFieldOffset(NDIS_PKT_POOL_HDR_NAME, "List", &BlockLinkOffset) != 0)
    {
        dprintf("Can't get offset of List in NDIS_PKT_POOL_HDR!\n");
        return;
    }


        
    //
    // Get the pool
    // 

    PoolFreeBlocksListAddr = Pool + FreeBlocksLinkOffset;
    PoolUsedBlocksListAddr = Pool + UsedBlocksLinkOffset;
        

    GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "BlockSize", BlockSize);
    GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PktsPerBlock", PktsPerBlock);
    GetFieldValue(Pool, NDIS_PKT_POOL_NAME, "PacketLength", PacketLength);

    //
    // walk through all free and used blocks on this packet pool
    //
    BlocksHeadAddr = PoolFreeBlocksListAddr;
    // 
    // Search free blocks
    // 
    GetFieldValue(Pool, NDIS_PKT_POOL_NAME, 
                 "FreeBlocks.Flink", CurBlockLink);

    if (CurBlockLink != 0)
    { 
        SearchPktInBlocks ((ULONG64)CurBlockLink,
                            BlocksHeadAddr,
                            BlockLinkOffset,
                            PacketStackSize,
                            PktsPerBlock,
                            1,
                            PacketLength);
    }
        
    BlocksHeadAddr = PoolUsedBlocksListAddr;
    // 
    // Search used blocks
    GetFieldValue(Pool, NDIS_PKT_POOL_NAME, 
                  "UsedBlocks.Flink", CurBlockLink);

    if (CurBlockLink != 0)
    {
        SearchPktInBlocks ((ULONG64)CurBlockLink,
                            BlocksHeadAddr,
                            BlockLinkOffset,
                            PacketStackSize,
                            PktsPerBlock,
                            0,
                            PacketLength);
    }


}

/*++
Routine Desc:
    This function is to find packets with the given selection

   v --- with virtual address
   p --- with pool address

--*/ 
DECLARE_API(findpacket)
{

    CHAR        Verbosity;
    CHAR        argbuf[ MAX_PATH ];
    CHAR        arglist[10][MAX_PATH];
    CHAR        *str;
    INT         index=0;
    CHAR        *p;
    ULONG64       Address;
    
    
    
    if (!args || !*args) 
    {
        dprintf("Usag: findpacket v <virtual address>\n");
        dprintf("                 p <pool address>\n");
        return;
    }        

    strcpy(argbuf,args);
     
    for (p = mystrtok( argbuf, " \t,;" );
         p && *p;
         p = mystrtok(NULL, " \t,;"))
    {
        strcpy(&arglist[index++][0], p);
    }
    
    Verbosity = arglist[0][0];
    

    if (Verbosity != 'v' && Verbosity != 'p')
    {
        dprintf("Usag: findpacket v <virtual address>\n");
        dprintf("                 p <pool address>\n");
        return;
    }

    if (index < 2)
    {
        dprintf("\nAddress is needed \n");
        return;
    }
    
    Address = GetExpression(&arglist[1][0]);
    
    switch (Verbosity)
    {
        case 'v':
            FindPacketWithVa(Address);
            break;

        case 'p':
            FindPacketInUse(Address);

        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\timerm.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    timerm.c

Abstract:

    NDIS wrapper functions for miniport isr/timer

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93

Environment:

    Kernel mode, FSD

Revision History:

    Jameel Hyder (JameelH) Re-organization 01-Jun-95
--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_TIMERM

//
// Timers
//
VOID
NdisMInitializeTimer(
    IN OUT PNDIS_MINIPORT_TIMER     MiniportTimer,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN PNDIS_TIMER_FUNCTION         TimerFunction,
    IN PVOID                        FunctionContext
    )
/*++

Routine Description:

    Sets up an Miniport Timer object, initializing the DPC in the timer to
    the function and context.

Arguments:

    MiniportTimer - the timer object.
    MiniportAdapterHandle - pointer to the mini-port block;
    TimerFunction - Routine to start.
    FunctionContext - Context of TimerFunction.

Return Value:

    None.

--*/
{
    INITIALIZE_TIMER(&MiniportTimer->Timer);

    MiniportTimer->Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    MiniportTimer->MiniportTimerFunction = TimerFunction;
    MiniportTimer->MiniportTimerContext = FunctionContext;

    //
    // Initialize our dpc. If Dpc was previously initialized, this will
    // reinitialize it.
    //
    INITIALIZE_DPC(&MiniportTimer->Dpc,
                   MINIPORT_TEST_FLAG(MiniportTimer->Miniport, fMINIPORT_DESERIALIZE) ?
                        (PKDEFERRED_ROUTINE)ndisMTimerDpcX : (PKDEFERRED_ROUTINE)ndisMTimerDpc,
                   (PVOID)MiniportTimer);

    SET_PROCESSOR_DPC(&MiniportTimer->Dpc,
                      MiniportTimer->Miniport->AssignedProcessor);
}


VOID
NdisMSetTimer(
    IN  PNDIS_MINIPORT_TIMER    MiniportTimer,
    IN  UINT                    MillisecondsToDelay
    )
/*++

Routine Description:

    Sets up TimerFunction to fire after MillisecondsToDelay.

Arguments:

    MiniportTimer       - the timer object.
    MillisecondsToDelay - Amount of time before TimerFunction is started.

Return Value:

    None.

--*/
{
    LARGE_INTEGER FireUpTime;

    FireUpTime.QuadPart = Int32x32To64((LONG)MillisecondsToDelay, -10000);

    if (MiniportTimer->Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
    {
        KIRQL   OldIrql;
        PNDIS_MINIPORT_TIMER    pTimer;

        ACQUIRE_SPIN_LOCK(&MiniportTimer->Miniport->TimerQueueLock, &OldIrql);

        //
        // check to see if the timer is already set
        //
        for (pTimer = MiniportTimer->Miniport->TimerQueue;
             pTimer != NULL;
             pTimer = pTimer->NextTimer)
        {
            if (pTimer == MiniportTimer)
                break;
        }

        if (pTimer == NULL)
        {
            MiniportTimer->NextTimer = MiniportTimer->Miniport->TimerQueue;
            MiniportTimer->Miniport->TimerQueue = MiniportTimer;
        }
        
        RELEASE_SPIN_LOCK(&MiniportTimer->Miniport->TimerQueueLock, OldIrql);
    }
    //
    // Set the timer
    //
    SET_TIMER(&MiniportTimer->Timer, FireUpTime, &MiniportTimer->Dpc);
}

VOID
NdisMCancelTimer(
    IN PNDIS_MINIPORT_TIMER         Timer,
    OUT PBOOLEAN                    TimerCancelled
    )
/*++

Routine Description:

    Cancels a timer.

Arguments:

    Timer - The timer to cancel.

    TimerCancelled - TRUE if the timer was canceled, else FALSE.

Return Value:

    None

--*/
{
    if (MINIPORT_VERIFY_TEST_FLAG(Timer->Miniport, fMINIPORT_VERIFY_FAIL_CANCEL_TIMER))
    {
        *TimerCancelled = FALSE;
#if DBG
            DbgPrint("NdisMCancelTimer for Timer %p failed to verify miniport %p\n", 
                Timer, Timer->Miniport);
#endif
        
        return;
    }

    *TimerCancelled = CANCEL_TIMER(&((PNDIS_TIMER)Timer)->Timer);
    if (Timer->Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
    {
        if (*TimerCancelled)
        {
            PNDIS_MINIPORT_TIMER    *pTimer;
            KIRQL                   OldIrql;
            BOOLEAN                 Dequeued = FALSE;

            ACQUIRE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, &OldIrql);

            for (pTimer = &Timer->Miniport->TimerQueue;
                 *pTimer != NULL;
                 pTimer = &(*pTimer)->NextTimer)
            {
                if (*pTimer == Timer)
                {
                    *pTimer = Timer->NextTimer;
                    Dequeued = TRUE;
                    break;
                }
            }

            RELEASE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, OldIrql);
        }
    }
}


VOID
ndisMTimerDpc(
    IN  PKDPC                       Dpc,
    IN  PVOID                       Context,
    IN  PVOID                       SystemContext1,
    IN  PVOID                       SystemContext2
    )
/*++

Routine Description:

    This function services all mini-port timer interrupts. It then calls the
    appropriate function that mini-port consumers have registered in the
    call to NdisMInitializeTimer.

Arguments:

    Dpc - Not used.

    Context - A pointer to the NDIS_MINIPORT_TIMER which is bound to this DPC.

    SystemContext1,2 - not used.

Return Value:

    None.

Note: 
    by virtue of having either the local lock or miniport spinlock, the driver's
    timer function is protected against getting unloaded .

--*/
{
    PNDIS_MINIPORT_TIMER MiniportTimer = (PNDIS_MINIPORT_TIMER)(Context);
    PNDIS_MINIPORT_BLOCK Miniport = MiniportTimer->Miniport;
    PNDIS_TIMER_FUNCTION TimerFunction;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    do
    {
        BLOCK_LOCK_MINIPORT_DPC_L(Miniport);

        if (Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
        {
            PNDIS_MINIPORT_TIMER    *pTimer;
            BOOLEAN                 Dequeued = FALSE;
    
            ACQUIRE_SPIN_LOCK_DPC(&Miniport->TimerQueueLock);
    
            for (pTimer = &Miniport->TimerQueue;
                 *pTimer != NULL;
                 pTimer = &(*pTimer)->NextTimer)
            {
                if (*pTimer == MiniportTimer)
                {
                    //
                    // don't dequeue periodic timers when they fire
                    //
                    if (MiniportTimer->Timer.Period == 0)
                    {
                        *pTimer = MiniportTimer->NextTimer;
                    }
                    Dequeued = TRUE;
                    break;
                }
            }
        
            RELEASE_SPIN_LOCK_DPC(&Miniport->TimerQueueLock);
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IN_INITIALIZE))
        {
            //
            // Queue the timer as we cannot call the miniport
            //
            NdisMSetTimer(MiniportTimer, 10);

            //
            //  Unlock the miniport
            //
            UNLOCK_MINIPORT_L(Miniport);
            break;
        }
        
        //
        // if the miniport is shut down (no, I don't mean halted)
        // then don't send the timer down.
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN))
        {
            UNLOCK_MINIPORT_L(Miniport);
            break;
        }

        
        //
        // Call Miniport timer function
        //
        TimerFunction = MiniportTimer->MiniportTimerFunction;

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        (*TimerFunction)(NULL, MiniportTimer->MiniportTimerContext, NULL, NULL);
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        NDISM_PROCESS_DEFERRED(Miniport);

        UNLOCK_MINIPORT_L(Miniport);

    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

}


VOID
ndisMTimerDpcX(
    IN  PKDPC                       Dpc,
    IN  PVOID                       Context,
    IN  PVOID                       SystemContext1,
    IN  PVOID                       SystemContext2
    )
/*++

Routine Description:

    This function services all mini-port timer DPCs. It then calls the
    appropriate function that mini-port consumers have registered in the
    call to NdisMInitializeTimer.

Arguments:

    Dpc - Not used.

    Context - A pointer to the NDIS_MINIPORT_TIMER which is bound to this DPC.

    SystemContext1,2 - not used.

Return Value:

    None.

Note:
    we have to make sure the driver does not go away while the driver's timer function
    is running. this can happen for example if the timer function was to signal an event
    to let the Halthandler and Halt proceed.
    No need to protect the miniport here becasue we do not touch the miniport after the 
    timer function returns.

--*/
{
    PNDIS_MINIPORT_TIMER MiniportTimer = (PNDIS_MINIPORT_TIMER)(Context);
    PNDIS_MINIPORT_BLOCK Miniport = MiniportTimer->Miniport;
    PNDIS_M_DRIVER_BLOCK MiniDriver = Miniport->DriverHandle;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);
    
    //
    // make sure the driver does not go away while the timer function
    // is running
    ndisReferenceDriver(MiniDriver);
    
    if (MiniportTimer->Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
    {
        PNDIS_MINIPORT_TIMER    *pTimer;
        BOOLEAN                 Dequeued = FALSE;

        ACQUIRE_SPIN_LOCK_DPC(&MiniportTimer->Miniport->TimerQueueLock);

        for (pTimer = &Miniport->TimerQueue;
             *pTimer != NULL;
             pTimer = &(*pTimer)->NextTimer)
        {
            if (*pTimer == MiniportTimer)
            {
                //
                // don't dequeue periodic timers when they fire
                //
                if (MiniportTimer->Timer.Period == 0)
                {
                    *pTimer = MiniportTimer->NextTimer;
                }
                Dequeued = TRUE;
                break;
            }
        }

        RELEASE_SPIN_LOCK_DPC(&MiniportTimer->Miniport->TimerQueueLock);
    }

    //
    // if the miniport is shut down (no, I don't mean halted)
    // then don't send the timer down.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN))
    {
        (*MiniportTimer->MiniportTimerFunction)(NULL, MiniportTimer->MiniportTimerContext, NULL, NULL);
    }

    //
    // this can be called at DPC
    //
    ndisDereferenceDriver(MiniDriver, FALSE);

}

NDIS_STATUS
NdisMRegisterInterrupt(
    OUT PNDIS_MINIPORT_INTERRUPT    Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    )
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NDIS_STATUS Status;

    Interrupt->Reserved = (PVOID)Miniport->MiniportAdapterContext;
    Miniport->Interrupt = (PNDIS_MINIPORT_INTERRUPT)Interrupt;

    INITIALIZE_DPC(&Interrupt->InterruptDpc,
               MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) ?
                    ndisMDpcX : ndisMDpc,
               Interrupt);

    SET_DPC_IMPORTANCE(&Interrupt->InterruptDpc);

    SET_PROCESSOR_DPC(&Interrupt->InterruptDpc,
                      Miniport->AssignedProcessor);

    Status = ndisMRegisterInterruptCommon(
                                Interrupt,
                                MiniportAdapterHandle,
                                InterruptVector,
                                InterruptLevel,
                                RequestIsr,
                                SharedInterrupt,
                                InterruptMode);


    if (Status != NDIS_STATUS_SUCCESS)
    {
        Miniport->Interrupt = NULL;
    }

    return Status;
}


VOID
NdisMDeregisterInterrupt(
    IN  PNDIS_MINIPORT_INTERRUPT    MiniportInterrupt
    )
{
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterInterrupt: Miniport %p\n", MiniportInterrupt->Miniport));
    do
    {
        if (MiniportInterrupt->InterruptObject == NULL)
            break;

        ndisMDeregisterInterruptCommon(MiniportInterrupt);
        
        MiniportInterrupt->Miniport->Interrupt = NULL;
    } while (FALSE);

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterInterrupt: Miniport %p\n", MiniportInterrupt->Miniport));
}


BOOLEAN
NdisMSynchronizeWithInterrupt(
    IN PNDIS_MINIPORT_INTERRUPT     Interrupt,
    IN PVOID                        SynchronizeFunction,
    IN PVOID                        SynchronizeContext
    )
{
    return (SYNC_WITH_ISR((Interrupt)->InterruptObject,
                          (PKSYNCHRONIZE_ROUTINE)SynchronizeFunction,
                          SynchronizeContext));
}


VOID
ndisMWakeUpDpcX(
    IN  PKDPC                       Dpc,
    IN  PVOID                       Context,
    IN  PVOID                       SystemContext1,
    IN  PVOID                       SystemContext2
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LARGE_INTEGER               FireUpTime;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)(Context);
    BOOLEAN                     Hung = FALSE;
    NDIS_STATUS                 Status;
    BOOLEAN                     AddressingReset = FALSE;
    BOOLEAN                     fDontReset = FALSE;
    BOOLEAN                     fSetTimer = TRUE;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);
    
    do
    {

        //
        // If the miniport is halting then try to set the event that the halt routine
        // may be waiting on. if the event is not there, do nothing but let the timer
        // fire again so you can set the event next time.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_CANCEL_WAKE_UP_TIMER))
        {
            if (Miniport->WakeUpTimerEvent != NULL)
            {
                fSetTimer = FALSE;
                SET_EVENT(Miniport->WakeUpTimerEvent);
            }

            break;
        }
    
        Miniport->CFHangCurrentTick--;
        if (Miniport->CFHangCurrentTick == 0)
        {
            Miniport->CFHangCurrentTick = Miniport->CFHangTicks;

            //
            // Call Miniport stall checker.
            //
            if (Miniport->DriverHandle->MiniportCharacteristics.CheckForHangHandler != NULL)
            {
                Hung = (Miniport->DriverHandle->MiniportCharacteristics.CheckForHangHandler)(Miniport->MiniportAdapterContext);
            }
        
            //
            //  Was there a request to reset the device?
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS))
            {
                Hung = FALSE;
                break;
            }
        
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
            //
            //  Check the internal wrapper states for the miniport and
            //  see if we think the miniport should be reset.
            //
            if (!Hung)
            {
                //
                //  Should we check the request queue?
                //  Did a request pend too long?
                //
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_REQUEST_QUEUE) &&
                    MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
                {
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT))
                    {
                        Miniport->InternalResetCount ++;
                        Hung = TRUE;
                    }
                    else
                    {
                        if (Miniport->CFHangXTicks == 0)
                        {
                            MINIPORT_SET_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);
                        }
                        else
                        {
                            Miniport->CFHangXTicks--;
                        }
                    }
                }
            }
            else
            {
                Miniport->MiniportResetCount ++;
            }
        
            if (Hung)
            {
                if (NULL != Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)
                {
                    if ((MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS)) ||
                        (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING)))
                    {
                        fDontReset = TRUE;
                    }
                    else
                    {
                        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS);
                        Miniport->ResetOpen = NULL;
                    }
                
                    ndisMSwapOpenHandlers(Miniport, 
                                          NDIS_STATUS_RESET_IN_PROGRESS,
                                          fMINIPORT_STATE_RESETTING);
                }
                else Hung = FALSE;
            }
        
    
            if (Hung && !fDontReset)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_CALLING_RESET);

                //
                // wait for all the requests to come back.
                // note: this is not the same as waiting for all requests to complete
                // we just make sure the original request call has come back
                //
                do
                {
                    if (Miniport->RequestCount == 0)
                    {
                        break;
                    }
                    else
                    {
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                        NDIS_INTERNAL_STALL(50);
                        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                    }
                } while (TRUE);

                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

                NdisMIndicateStatus(Miniport, NDIS_STATUS_RESET_START, NULL, 0);
                NdisMIndicateStatusComplete(Miniport);
        
                DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("Calling miniport reset\n"));
        
                //
                //  Call the miniport's reset handler.
                //
                Status = (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)(
                                          &AddressingReset,
                                          Miniport->MiniportAdapterContext);
                
                if (NDIS_STATUS_PENDING != Status)
                {
                    NdisMResetComplete(Miniport, Status, AddressingReset);
                }
            }
            else
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }

        if (!Hung)
        {
            //
            //1 this may be unnecessary
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING) == TRUE)
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                ndisMPollMediaState(Miniport);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
    } while (FALSE);
    
    if (fSetTimer)
    {
        //
        // If the miniport is halting then try to set the event that the halt routine
        // may be waiting on. if the event is not there, let the timer
        // fire again so you can set the event next time.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_CANCEL_WAKE_UP_TIMER))
        {
            if (Miniport->WakeUpTimerEvent != NULL)
            {
                fSetTimer = FALSE;
                SET_EVENT(Miniport->WakeUpTimerEvent);
            }
        }
    }

    if (fSetTimer)
    {
        FireUpTime.QuadPart = Int32x32To64((LONG)(Miniport->CheckForHangSeconds*1000), -10000);        
        SET_TIMER(&Miniport->WakeUpDpcTimer.Timer, FireUpTime, &Miniport->WakeUpDpcTimer.Dpc);
    }

}


VOID
ndisMWakeUpDpc(
    IN  PKDPC                       Dpc,
    IN  PVOID                       Context,
    IN  PVOID                       SystemContext1,
    IN  PVOID                       SystemContext2
    )
/*++

Routine Description:

    This function services all mini-port. It checks to see if a mini-port is
    ever stalled.

Arguments:

    Dpc - Not used.

    Context - A pointer to the NDIS_TIMER which is bound to this DPC.

    SystemContext1,2 - not used.

Return Value:

    None.

--*/
{
    LARGE_INTEGER               FireUpTime;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)(Context);
    BOOLEAN                     Hung = FALSE;
    BOOLEAN                     LocalLock;
    BOOLEAN                     fSetTimer = TRUE;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    do
    {
        //
        // If the miniport is halting then try to set the event that the halt routine
        // may be waiting on. if the event is not there, do nothing but let the timer
        // fire again so you can set the event next time.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_CANCEL_WAKE_UP_TIMER))
        {
            if (Miniport->WakeUpTimerEvent != NULL)
            {
                fSetTimer = FALSE;
                SET_EVENT(Miniport->WakeUpTimerEvent);
            }
            break;
        }

        //
        //  Can we get the miniport lock. If not then quit. This is not time-critical
        //  and we can try again next tick
        //
        LOCK_MINIPORT(Miniport, LocalLock);
        if (!LocalLock ||
            MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_RESET_REQUESTED)))
        {
            UNLOCK_MINIPORT(Miniport, LocalLock);
            break;
        }
    
        Miniport->CFHangCurrentTick--;
        if (Miniport->CFHangCurrentTick == 0)
        {
            Miniport->CFHangCurrentTick = Miniport->CFHangTicks;
    
            //
            // Call Miniport stall checker.
            //
            if (Miniport->DriverHandle->MiniportCharacteristics.CheckForHangHandler != NULL)
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                Hung = (Miniport->DriverHandle->MiniportCharacteristics.CheckForHangHandler)(Miniport->MiniportAdapterContext);
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS))
            {
                //
                //  We are restoring filters post reset. Don't pre-empt again
                //
                Hung = FALSE;
                UNLOCK_MINIPORT(Miniport, LocalLock);
                break;
            }

            //
            //  Check the internal wrapper states for the miniport and
            //  see if we think the miniport should be reset.
            //
            if (Hung)
            {
                Miniport->MiniportResetCount ++;
            }
            else do
            {
                //
                //  Should we check the request queue ?  Did a request pend too long ?
                //
                if ((Miniport->Flags & (fMINIPORT_IGNORE_REQUEST_QUEUE|fMINIPORT_PROCESSING_REQUEST)) == fMINIPORT_PROCESSING_REQUEST)
                {
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT))
                    {
                        Miniport->InternalResetCount ++;
                        Hung = TRUE;
                        break;
                    }
                    else
                    {
                        if (Miniport->CFHangXTicks == 0)
                        {
                            MINIPORT_SET_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);
                        }
                        else
                        {
                            Miniport->CFHangXTicks--;
                        }
                            
                    }
                }
    
                //
                //  Should we check the packet queue ? Did a packet pend too long ?
                //
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_PACKET_QUEUE))
                {
                    PNDIS_PACKET    Packet;
    
                    GET_FIRST_MINIPORT_PACKET(Miniport, &Packet);
    
                    //
                    //  Does the miniport have possession of any packets?
                    //
                    if ((Packet != NULL) &&
                        MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))
                    {
                        //
                        //  Has the packet timed out?
                        //
                        if (MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_HAS_TIMED_OUT))
                        {
                            //
                            //  Reset the miniport.
                            //
                            Miniport->InternalResetCount ++;
                            Hung = TRUE;
                        }
                        else
                        {
                            //
                            //  Set the packet flag and wait to see if it is still
                            //  there next time in.
                            //
                            MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_HAS_TIMED_OUT);
                        }
                    }
                    else
                    {
                        break;
                    }
        
                    //
                    //  If we are hung then we don't need to check for token ring errors.
                    //
                    if (Hung)
                    {
                        break;
                    }
                }
    
                //
                //  Are we ignoring token ring errors?
                //
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS))
                {
                    //
                    //  Token Ring reset...
                    //
                    if (Miniport->TrResetRing == 1)
                    {
                        Miniport->InternalResetCount ++;
                        Hung = TRUE;
                        break;
                    }
                    else if (Miniport->TrResetRing > 1)
                    {
                        Miniport->TrResetRing--;
                    }
                }
            } while (FALSE);
    
            //
            //  If the miniport is hung then queue a workitem to reset it.
            //
            if (Hung)
            {
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS))
                {
                    if (NULL != Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)
                    {
                        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemResetRequested, NULL);
                    }
                }
            }
        }

        if (!Hung)
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING) == TRUE)
            {
                ndisMPollMediaState(Miniport);
            }
        }

        //
        // Process any changes that have occurred.
        //
        NDISM_PROCESS_DEFERRED(Miniport);

        UNLOCK_MINIPORT_L(Miniport);

    } while (FALSE);

    if (fSetTimer)
    {
        //
        // If the miniport is halting then try to set the event that the halt routine
        // may be waiting on. if the event is not there, let the timer
        // fire again so you can set the event next time.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_CANCEL_WAKE_UP_TIMER))
        {
            if (Miniport->WakeUpTimerEvent != NULL)
            {
                fSetTimer = FALSE;
                SET_EVENT(Miniport->WakeUpTimerEvent);
            }
        }
    }

    if (fSetTimer)
    {
        FireUpTime.QuadPart = Int32x32To64((LONG)(Miniport->CheckForHangSeconds*1000), -10000);        
        SET_TIMER(&Miniport->WakeUpDpcTimer.Timer, FireUpTime, &Miniport->WakeUpDpcTimer.Dpc);
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

}


BOOLEAN
ndisMIsr(
    IN PKINTERRUPT                  KInterrupt,
    IN PVOID                        Context
    )
/*++

Routine Description:

    Handles ALL Miniport interrupts, calling the appropriate Miniport ISR and DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT Interrupt = (PNDIS_MINIPORT_INTERRUPT)Context;
    PNDIS_MINIPORT_BLOCK     Miniport = Interrupt->Miniport;
    BOOLEAN                  InterruptRecognized;
    BOOLEAN                  IsrCalled = FALSE, QueueDpc = FALSE;

    UNREFERENCED_PARAMETER(KInterrupt);
    
    do
    {   
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS))
        {
            MINIPORT_DISABLE_INTERRUPT_EX(Miniport, Interrupt);

            InterruptRecognized = QueueDpc = TRUE;
        }
        else
        {
            IsrCalled = TRUE;
//            Interrupt->MiniportIsr(&InterruptRecognized,
//                                   &QueueDpc,
//                                   Miniport->MiniportAdapterContext);
            Interrupt->MiniportIsr(&InterruptRecognized,
                                   &QueueDpc,
                                   Interrupt->Reserved);
        }

        if (QueueDpc)
        {
            InterlockedIncrement((PLONG)&Interrupt->DpcCount);

            if (QUEUE_DPC(&Interrupt->InterruptDpc))
            {
                break;
            }

            //
            // The DPC was already queued, so we have an extra reference (we
            // do it this way to ensure that the reference is added *before*
            // the DPC is queued).
            InterlockedDecrement((PLONG)&Interrupt->DpcCount);

            break;
        }

        if (!IsrCalled)
        {
            if (!Interrupt->SharedInterrupt &&
                !Interrupt->IsrRequested &&
                !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IN_INITIALIZE))
            {
                ASSERT(Miniport->DisableInterruptHandler != NULL);
    
                MINIPORT_DISABLE_INTERRUPT_EX(Miniport, Interrupt);
                InterruptRecognized = TRUE;
                break;
            }

            //
            // Call MiniportIsr, but don't queue a DPC.
            //
//            Interrupt->MiniportIsr(&InterruptRecognized,
//                                   &QueueDpc,
//                                   Miniport->MiniportAdapterContext);

            Interrupt->MiniportIsr(&InterruptRecognized,
                                   &QueueDpc,
                                   Interrupt->Reserved);
            
        }

    } while (FALSE);

    return(InterruptRecognized);
}


VOID
ndisMDpc(
    IN PVOID                        SystemSpecific1,
    IN PVOID                        InterruptContext,
    IN PVOID                        SystemSpecific2,
    IN PVOID                        SystemSpecific3
    )
/*++

Routine Description:

    Handles ALL Miniport interrupt DPCs, calling the appropriate Miniport DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the Interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT Interrupt = (PNDIS_MINIPORT_INTERRUPT)(InterruptContext);
    PNDIS_MINIPORT_BLOCK     Miniport = Interrupt->Miniport;
    W_HANDLE_INTERRUPT_HANDLER MiniportDpc = Interrupt->MiniportDpc;

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    do
    {
        if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_PM_HALTING)) ||
            Interrupt->DpcCountLock)
        {
            InterlockedDecrement((PLONG)&Interrupt->DpcCount);

            if (Interrupt->DpcCount==0)
            {
                SET_EVENT(&Interrupt->DpcsCompletedEvent);
            }

            break;
        }

        BLOCK_LOCK_MINIPORT_DPC_L(Miniport);

#if DBG
        //
        // reset SendComplete and RcvIndication counters
        //
        Miniport->cDpcSendCompletes = 0;
        Miniport->cDpcRcvIndications = 0;
        Miniport->cDpcRcvIndicationCalls = 0;
#endif
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        (*MiniportDpc)(Interrupt->Reserved);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        MINIPORT_SYNC_ENABLE_INTERRUPT_EX(Miniport, Interrupt);
        
        NDISM_PROCESS_DEFERRED(Miniport);

        UNLOCK_MINIPORT(Miniport, TRUE);

    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
}


VOID
ndisMDpcX(
    IN PVOID SystemSpecific1,
    IN PVOID InterruptContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
/*++

Routine Description:

    Handles ALL Miniport interrupt DPCs, calling the appropriate Miniport DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the Interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT    Interrupt = (PNDIS_MINIPORT_INTERRUPT)(InterruptContext);
    PNDIS_MINIPORT_BLOCK        Miniport = Interrupt->Miniport;
    W_HANDLE_INTERRUPT_HANDLER MiniportDpc = Interrupt->MiniportDpc;
    
    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);

    if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_PM_HALTING)) ||
        Interrupt->DpcCountLock)
    {
        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        if (Interrupt->DpcCount==0)
        {
            SET_EVENT(&Interrupt->DpcsCompletedEvent);
        }
    }
    else
    {

#if DBG
        //
        // reset SendComplete and RcvIndication counters
        //
        Miniport->cDpcSendCompletes = 0;
        Miniport->cDpcRcvIndications = 0;
        Miniport->cDpcRcvIndicationCalls = 0;
#endif
        
        (*MiniportDpc)(Interrupt->Reserved);

        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        MINIPORT_SYNC_ENABLE_INTERRUPT_EX(Miniport, Interrupt);
    }
}


VOID
ndisMDeferredDpc(
    IN  PKDPC                       Dpc,
    IN  PVOID                       Context,
    IN  PVOID                       SystemContext1,
    IN  PVOID                       SystemContext2
    )

/*++

Routine Description:

    This is a DPC routine that is queue'd by some of the [full-duplex] routines
    in order to get ndisMProcessDeferred to run outside of their
    context.

Arguments:



Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Context;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    BLOCK_LOCK_MINIPORT_DPC_L(Miniport);

    NDISM_PROCESS_DEFERRED(Miniport);

    UNLOCK_MINIPORT(Miniport, TRUE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
}


#if NDIS_RECV_SCALE
NDIS_STATUS
NdisMRegisterInterruptEx(
    OUT PNDIS_MINIPORT_INTERRUPT_EX Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    )
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    ULONG                           Vector;
    NDIS_STATUS                     Status;
    NTSTATUS                        NtStatus;
    KIRQL                           Irql;
    KAFFINITY                       InterruptAffinity;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor;
    PHYSICAL_ADDRESS                NonTranslatedInterrupt, TranslatedIrql;
    CCHAR                           i;
    KIRQL                           OldIrql;


    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMRegisterInterruptEx: Miniport %p\n", MiniportAdapterHandle));

    if (MINIPORT_VERIFY_TEST_FLAG((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle, fMINIPORT_VERIFY_FAIL_INTERRUPT_REGISTER))
    {
    #if DBG
        DbgPrint("NdisMRegisterInterrupt failed to verify miniport %p\n", MiniportAdapterHandle);
    #endif
        return NDIS_STATUS_RESOURCES;
    }

    
    Interrupt->InterruptContext = (PVOID)Interrupt;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Interrupt->NextInterrupt = (PNDIS_MINIPORT_INTERRUPT_EX)Miniport->Interrupt;
    Miniport->Interrupt = (PNDIS_MINIPORT_INTERRUPT)Interrupt;
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);


    do
    {
        Status = NDIS_STATUS_SUCCESS;
        InterlockedIncrement(&Miniport->RegisteredInterrupts);

        //
        // We must do this stuff first because if we connect the
        // interrupt first then an interrupt could occur before
        // the ISR is recorded in the Ndis interrupt structure.
        //
        Interrupt->DpcCount = 0;
        Interrupt->DpcCountLock = 0;
        Interrupt->Miniport = Miniport;
        Interrupt->MiniportIsr = Miniport->DriverHandle->MiniportCharacteristics.MiniportISRHandler;
        Interrupt->MiniportDpc = Miniport->DriverHandle->MiniportCharacteristics.InterruptDpcHandler;
        Interrupt->SharedInterrupt = SharedInterrupt;
        Interrupt->IsrRequested = RequestIsr;

        if (!SharedInterrupt)
        {
            Miniport->InfoFlags |= NDIS_MINIPORT_EXCLUSIVE_INTERRUPT;
        }
        
         //
        // This is used to tell when all Dpcs are completed after the
        // interrupt has been removed.
        //
        INITIALIZE_EVENT(&Interrupt->DpcsCompletedEvent);
        Interrupt->DpcQueued = 0;

        //
        // set the the default DPC handler
        //
        INITIALIZE_DPC(&Interrupt->InterruptDpc,
                       ndisMiniportDpc, Interrupt);

        SET_DPC_IMPORTANCE(&Interrupt->InterruptDpc);
    
        SET_PROCESSOR_DPC(&Interrupt->InterruptDpc,
                          Miniport->AssignedProcessor);


        //
        // initialize one DPC for each processor
        //

        for (i = 0; i < ndisNumberOfProcessors; i++)
        {
            INITIALIZE_DPC(&Interrupt->Dpc[i],
                        ndisMiniportMultipleDpc, Interrupt);
            SET_DPC_IMPORTANCE(&Interrupt->InterruptDpc);
            
            KeSetTargetProcessorDpc(&Interrupt->Dpc[i],
                                    i);
        }

        NonTranslatedInterrupt.QuadPart = InterruptLevel;
        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypeInterrupt,
                                        NonTranslatedInterrupt,
                                        &TranslatedIrql,
                                        &pResourceDescriptor);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (("    NdisMRegisterInterrupt: trying to register interrupt %p which is not allocated to device\n"),
                    InterruptLevel));
                    
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Irql = (KIRQL)pResourceDescriptor->u.Interrupt.Level;
        Vector = pResourceDescriptor->u.Interrupt.Vector;
        InterruptAffinity = pResourceDescriptor->u.Interrupt.Affinity;


        if (pResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)
        {
            InterruptMode = LevelSensitive;
        }
        else 
        {
            InterruptMode = Latched;
        }
    
        //
        // just in case this is not the first time we try to get an interrupt
        // for this miniport (suspend/resume or if the miniport has decided to
        // let go of interrupt and hook it again
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_DEREGISTERED_INTERRUPT);

        NtStatus = IoConnectInterrupt(&Interrupt->InterruptObject,
                                      (PKSERVICE_ROUTINE)ndisMiniportIsr,
                                      Interrupt,
                                      NULL,
                                      Vector,
                                      Irql,
                                      Irql,
                                      (KINTERRUPT_MODE)InterruptMode,
                                      SharedInterrupt,
                                      InterruptAffinity,
                                      FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            Status = NDIS_STATUS_FAILURE;

            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (("    NdisMRegisterInterrupt: IoConnectInterrupt failed on Interrupt Level:%lx, Vector: %lx\n"),
                    Irql, Vector));

            //
            // zero out the interrupt object just in case driver tries to remove the interrupt
            // they are aligned in both structures
            //
            Interrupt->InterruptObject = NULL;
        }

    } while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        PNDIS_MINIPORT_INTERRUPT_EX *ppQ;

        InterlockedDecrement(&Miniport->RegisteredInterrupts);
        
        PnPReferencePackage();
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        for (ppQ = (PNDIS_MINIPORT_INTERRUPT_EX *)&Miniport->Interrupt;
             *ppQ != NULL;
             ppQ = &(*ppQ)->NextInterrupt)
        {
            if (*ppQ == Interrupt)
            {
                *ppQ = Interrupt->NextInterrupt;
                break;
            }
        }
        
        PnPDereferencePackage();
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMRegisterInterruptEx: Miniport %p, Status %lx\n", MiniportAdapterHandle, Status));

    return Status;
}


BOOLEAN
ndisMiniportIsr(
    IN PKINTERRUPT                  KInterrupt,
    IN PVOID                        Context
    )
/*++

Routine Description:

    Handles ALL Miniport interrupts, calling the appropriate Miniport ISR and DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT_EX Interrupt = (PNDIS_MINIPORT_INTERRUPT_EX)Context;
    ULONG                       TargetProcessors = 0;
    ULONG                       DpcProcessor;
    ULONG                       TargetProcessor = 0;
    BOOLEAN                     InterruptRecognized;
    BOOLEAN                     QueueDpc = FALSE;


    InterruptRecognized = Interrupt->MiniportIsr(Interrupt->Reserved,
                                                 &QueueDpc,
                                                 &TargetProcessors);
    if (QueueDpc)
    {
        InterlockedIncrement((PLONG)&Interrupt->DpcCount);
        if (!QUEUE_DPC(&Interrupt->InterruptDpc))
        {
            InterlockedDecrement((PLONG)&Interrupt->DpcCount);
        }            
    }
    else
    {
        DpcProcessor = 0;
        while (TargetProcessor)
        {
            if (TargetProcessor & 0x00000001)
            {
                InterlockedIncrement((PLONG)&Interrupt->DpcCount);
                if (!QUEUE_DPC(&Interrupt->Dpc[DpcProcessor]))
                {
                    InterlockedDecrement((PLONG)&Interrupt->DpcCount);
                }

            }
            TargetProcessor >>= 1;
            DpcProcessor++;
        }
    }

    return(InterruptRecognized);
}


VOID
ndisMiniportMultipleDpc(
    IN PVOID SystemSpecific1,
    IN PVOID InterruptContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
/*++

Routine Description:

    Handles ALL Miniport interrupt DPCs, calling the appropriate Miniport DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the Interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT_EX     Interrupt = (PNDIS_MINIPORT_INTERRUPT_EX)(InterruptContext);
    PNDIS_MINIPORT_BLOCK            Miniport = Interrupt->Miniport;
    ULONG                           TargetProcessor;
    ULONG                           DpcProcessor;
    
    MINIPORT_INTERRUPT_DPC_HANDLER MiniportDpc = Interrupt->MiniportDpc;

    if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_PM_HALTING)) ||
        Interrupt->DpcCountLock)
    {
        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        if (Interrupt->DpcCount==0)
        {
            SET_EVENT(&Interrupt->DpcsCompletedEvent);
        }
    }
    else
    {
        
#if DBG
        //
        // reset SendComplete and RcvIndication counters
        //
        Miniport->cDpcSendCompletes = 0;
        Miniport->cDpcRcvIndications = 0;
        Miniport->cDpcRcvIndicationCalls = 0;
#endif
        //
        // call the interrupt DPC handler and check to see if miniport
        // is interested in additional DPCs on other processors
        //
        TargetProcessor = 0;

        (*MiniportDpc)(Interrupt->Reserved,
                       &TargetProcessor);

        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        DpcProcessor = 0;
        while (TargetProcessor)
        {
            if (TargetProcessor & 0x00000001)
            {
                InterlockedIncrement((PLONG)&Interrupt->DpcCount);
                if (!QUEUE_DPC(&Interrupt->Dpc[DpcProcessor]))
                {
                    InterlockedDecrement((PLONG)&Interrupt->DpcCount);
                }

            }
            TargetProcessor >>= 1;
            DpcProcessor++;
        }

    }
    

}


VOID
ndisMiniportDpc(
    IN PVOID SystemSpecific1,
    IN PVOID InterruptContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
/*++

Routine Description:

    Handles ALL Miniport interrupt DPCs, calling the appropriate Miniport DPC
    depending on the context.

Arguments:

    Interrupt - Interrupt object for the Mac.

    Context - Really a pointer to the Interrupt.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_INTERRUPT_EX     Interrupt = (PNDIS_MINIPORT_INTERRUPT_EX)(InterruptContext);
    PNDIS_MINIPORT_BLOCK            Miniport = Interrupt->Miniport;

    MINIPORT_INTERRUPT_DPC_HANDLER MiniportDpc = Interrupt->MiniportDpc;

    if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_PM_HALTING)) ||
        Interrupt->DpcCountLock)
    {
        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        if (Interrupt->DpcCount==0)
        {
            SET_EVENT(&Interrupt->DpcsCompletedEvent);
        }
    }
    else
    {

#if DBG
        //
        // reset SendComplete and RcvIndication counters
        //
        Miniport->cDpcSendCompletes = 0;
        Miniport->cDpcRcvIndications = 0;
        Miniport->cDpcRcvIndicationCalls = 0;
#endif
        
        (*MiniportDpc)(Interrupt->Reserved,
                       NULL);

        InterlockedDecrement((PLONG)&Interrupt->DpcCount);

        MINIPORT_SYNC_ENABLE_INTERRUPT_EX(Miniport, Interrupt);
    }
}


#else

NDIS_STATUS
NdisMRegisterInterruptEx(
    OUT PNDIS_MINIPORT_INTERRUPT_EX Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    )
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NDIS_STATUS Status;
    KIRQL       OldIrql;
    
    Interrupt->InterruptContext = (PVOID)Interrupt;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Interrupt->NextInterrupt = (PNDIS_MINIPORT_INTERRUPT_EX)Miniport->Interrupt;
    Miniport->Interrupt = (PNDIS_MINIPORT_INTERRUPT)Interrupt;
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    Status = ndisMRegisterInterruptCommon(
                                (PNDIS_MINIPORT_INTERRUPT)Interrupt,
                                MiniportAdapterHandle,
                                InterruptVector,
                                InterruptLevel,
                                RequestIsr,
                                SharedInterrupt,
                                InterruptMode);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        PNDIS_MINIPORT_INTERRUPT_EX *ppQ;
        
        PnPReferencePackage();
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        for (ppQ = (PNDIS_MINIPORT_INTERRUPT_EX *)&Miniport->Interrupt;
             *ppQ != NULL;
             ppQ = &(*ppQ)->NextInterrupt)
        {
            if (*ppQ == Interrupt)
            {
                *ppQ = Interrupt->NextInterrupt;
                break;
            }
        }
        
        PnPDereferencePackage();
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    return Status;
}

#endif

VOID
NdisMDeregisterInterruptEx(
    IN  PNDIS_MINIPORT_INTERRUPT_EX     MiniportInterrupt
    )
{
    PNDIS_MINIPORT_BLOCK        Miniport = MiniportInterrupt->Miniport;
    PNDIS_MINIPORT_INTERRUPT_EX *ppQ;
    KIRQL                       OldIrql;
    
            
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterInterruptEx: Miniport %p\n", MiniportInterrupt->Miniport));

    ndisMDeregisterInterruptCommon((PNDIS_MINIPORT_INTERRUPT)MiniportInterrupt);

    PnPReferencePackage();

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
    for (ppQ = (PNDIS_MINIPORT_INTERRUPT_EX *)&Miniport->Interrupt;
         *ppQ != NULL;
         ppQ = &(*ppQ)->NextInterrupt)
    {
        if (*ppQ == MiniportInterrupt)
        {
            *ppQ = MiniportInterrupt->NextInterrupt;
            break;
        }
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    PnPDereferencePackage();
        
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterInterruptEx: Miniport %p\n", MiniportInterrupt->Miniport));

}

NDIS_STATUS
ndisMRegisterInterruptCommon(
    OUT PNDIS_MINIPORT_INTERRUPT    Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    )
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    ULONG                           Vector;
    NDIS_STATUS                     Status;
    NTSTATUS                        NtStatus;
    KIRQL                           Irql;
    KAFFINITY                       InterruptAffinity;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor;
    PHYSICAL_ADDRESS                NonTranslatedInterrupt, TranslatedIrql;

    UNREFERENCED_PARAMETER(InterruptVector);
    
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisMRegisterInterruptCommon: Miniport %p\n", MiniportAdapterHandle));

    if (MINIPORT_VERIFY_TEST_FLAG((PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle, fMINIPORT_VERIFY_FAIL_INTERRUPT_REGISTER))
    {
    #if DBG
        DbgPrint("NdisMRegisterInterrupt failed to verify miniport %p\n", MiniportAdapterHandle);
    #endif
        return NDIS_STATUS_RESOURCES;
    }

    do
    {
        Status = NDIS_STATUS_SUCCESS;
        InterlockedIncrement((PLONG)&Miniport->RegisteredInterrupts);

        //
        // We must do this stuff first because if we connect the
        // interrupt first then an interrupt could occur before
        // the ISR is recorded in the Ndis interrupt structure.
        //
        Interrupt->DpcCount = 0;
        Interrupt->DpcCountLock = 0;
        Interrupt->Miniport = Miniport;
        Interrupt->MiniportIsr = Miniport->DriverHandle->MiniportCharacteristics.ISRHandler;
        Interrupt->MiniportDpc = Miniport->HandleInterruptHandler;
        Interrupt->SharedInterrupt = SharedInterrupt;
        Interrupt->IsrRequested = RequestIsr;

        if (!SharedInterrupt)
        {
            Miniport->InfoFlags |= NDIS_MINIPORT_EXCLUSIVE_INTERRUPT;
        }
        
         //
        // This is used to tell when all Dpcs are completed after the
        // interrupt has been removed.
        //
        INITIALIZE_EVENT(&Interrupt->DpcsCompletedEvent);

        INITIALIZE_DPC(&Interrupt->InterruptDpc,
                   MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) ?
                        ndisMDpcX : ndisMDpc,
                   Interrupt);

        SET_DPC_IMPORTANCE(&Interrupt->InterruptDpc);
    
        SET_PROCESSOR_DPC(&Interrupt->InterruptDpc,
                          Miniport->AssignedProcessor);

        NonTranslatedInterrupt.QuadPart = InterruptLevel;
        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypeInterrupt,
                                        NonTranslatedInterrupt,
                                        &TranslatedIrql,
                                        &pResourceDescriptor);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (("    NdisMRegisterInterrupt: trying to register interrupt %p which is not allocated to device\n"),
                    InterruptLevel));
                    
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Irql = (KIRQL)pResourceDescriptor->u.Interrupt.Level;
        Vector = pResourceDescriptor->u.Interrupt.Vector;
        InterruptAffinity = pResourceDescriptor->u.Interrupt.Affinity;


        if (pResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)
        {
            InterruptMode = LevelSensitive;
        }
        else 
        {
            InterruptMode = Latched;
        }
    
        //
        // just in case this is not the first time we try to get an interrupt
        // for this miniport (suspend/resume or if the miniport has decided to
        // let go of interrupt and hook it again
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_DEREGISTERED_INTERRUPT);

        NtStatus = IoConnectInterrupt(&Interrupt->InterruptObject,
                                      (PKSERVICE_ROUTINE)ndisMIsr,
                                      Interrupt,
                                      NULL,
                                      Vector,
                                      Irql,
                                      Irql,
                                      (KINTERRUPT_MODE)InterruptMode,
                                      SharedInterrupt,
                                      InterruptAffinity,
                                      FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            Status = NDIS_STATUS_FAILURE;

            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (("    NdisMRegisterInterrupt: IoConnectInterrupt failed on Interrupt Level:%lx, Vector: %lx\n"),
                    Irql, Vector));

            //
            // zero out the interrupt object just in case driver tries to remove the interrupt
            // they are aligned in both structures
            //
            Interrupt->InterruptObject = NULL;
        }

    } while (FALSE);


    if (Status != NDIS_STATUS_SUCCESS)
    {
        InterlockedDecrement((PLONG)&Miniport->RegisteredInterrupts);
    }

                            
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisMRegisterInterruptCommon: Miniport %p, Status %lx\n", MiniportAdapterHandle, Status));
            
    return Status;
}



VOID
ndisMDeregisterInterruptCommon(
    IN  PNDIS_MINIPORT_INTERRUPT    MiniportInterrupt
    )
{
    PNDIS_MINIPORT_BLOCK        Miniport = MiniportInterrupt->Miniport;

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisMDeregisterInterruptCommon: Miniport %p\n", MiniportInterrupt->Miniport));

    do
    {
        //
        // drivers can register interrupts only during initialization
        // and deregister them only during halt
        // so here we can safely set the flag after the ref count
        // goes to zero.
        //
        if (InterlockedDecrement((PLONG)&Miniport->RegisteredInterrupts) == 0)
        {
            MINIPORT_SET_FLAG(MiniportInterrupt->Miniport, fMINIPORT_DEREGISTERED_INTERRUPT);
        }

        //
        // overloading the DpcCountLock to say that interrupt is
        // deregistered
        //
        (ULONG)MiniportInterrupt->DpcCountLock = 1;
        
        //
        //  Now we disconnect the interrupt.
        //  NOTE: they are aligned in both structures
        //
        IoDisconnectInterrupt(MiniportInterrupt->InterruptObject);

        //
        // Right now we know that any Dpcs that may fire are counted.
        // We don't have to guard this with a spin lock because the
        // Dpc will set the event it completes first, or we may
        // wait for it to complete.
        //
        if (MiniportInterrupt->DpcCount > 0)
        {
            //
            // Now we wait for all dpcs to complete.
            //
            WAIT_FOR_OBJECT(&MiniportInterrupt->DpcsCompletedEvent, NULL);
    
            RESET_EVENT(&MiniportInterrupt->DpcsCompletedEvent);
        }

    } while (FALSE);
    
    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisMDeregisterInterruptCommon: Miniport %p\n", MiniportInterrupt->Miniport));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndiskd\ndiskd.h ===
//
// Function prototypes.
//
VOID
PrintName(
    ULONG64 UnicodeStringAddr
    );

VOID
PrintMiniportName(
    ULONG64 MiniportAddr
    );

VOID
PrintMiniportDetails(
    ULONG64 MiniportAddr
    );

VOID
PrintMiniportOpenList(
    ULONG64 MiniportAddr
    );

VOID 
PrintNdisPacketPrivate(
    ULONG64     PacketAddr
    );

VOID 
PrintNdisPacketExtension (
    ULONG64     PacketAddr
    );

VOID
PrintNdisBufferList(
    ULONG64     PacketAddr
    );

VOID 
PrintNdisBuffer(
    ULONG64     PacketAddr
    );

VOID
PrintNdisPacket(
    ULONG64     PacketAddr
    );

VOID
PrintResources(
    ULONG64     ResourcesAddr
    );

VOID
PrintPacketPrivateFlags(
    ULONG64     PacketAddr
    );

VOID
PrintNdisReserved(
    ULONG64     PacketAddr
    );


VOID
PrintProtocolDetails(
    ULONG64     ProtocolAddr
    );



VOID
PrintProtocolOpenQueue(
    ULONG64 ProtocolAddr );

VOID
PrintVcPtrBlock(
    IN  ULONG64 VcPtrAddr
    );


ULONG
GetFieldOffsetAndSize(
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize);

ULONG
GetUlongFromAddress (
    ULONG64 Location);

ULONG64
GetPointerFromAddress(
    ULONG64 Location);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	Created, based on ATM ARP.

Notes:

--*/

#include <precomp.h>

#define __FILENUMBER 'GBED'

#if DBG

INT             	TunDebugLevel = DL_FATAL;

NDIS_SPIN_LOCK		TunDbgLogLock;

PTUND_ALLOCATION	TundMemoryHead = (PTUND_ALLOCATION)NULL;
PTUND_ALLOCATION	TundMemoryTail = (PTUND_ALLOCATION)NULL;
ULONG				TundAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		TundMemoryLock;
BOOLEAN				TundInitDone = FALSE;


PVOID
TunAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PTUND_ALLOCATION	pAllocInfo;

	if (!TundInitDone)
	{
		NdisAllocateSpinLock(&(TundMemoryLock));
		TundInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+sizeof(TUND_ALLOCATION),
		(ULONG)'oiuN'
	);

	if (pAllocInfo == (PTUND_ALLOCATION)NULL)
	{
		DEBUGP(DL_VERY_LOUD+50,
			("TunAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		TUN_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = TUND_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = (ULONG_PTR)pPointer;
		pAllocInfo->Next = (PTUND_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(TundMemoryLock));

		pAllocInfo->Prev = TundMemoryTail;
		if (TundMemoryTail == (PTUND_ALLOCATION)NULL)
		{
			// empty list
			TundMemoryHead = TundMemoryTail = pAllocInfo;
		}
		else
		{
			TundMemoryTail->Next = pAllocInfo;
		}
		TundMemoryTail = pAllocInfo;
		
		TundAllocCount++;
		NdisReleaseSpinLock(&(TundMemoryLock));
	}

	DEBUGP(DL_VERY_LOUD+100,
	 ("TunAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
TunAuditFreeMem(
	PVOID	Pointer
)
{
	PTUND_ALLOCATION	pAllocInfo;

	NdisAcquireSpinLock(&(TundMemoryLock));

	pAllocInfo = CONTAINING_RECORD(Pointer, TUND_ALLOCATION, UserData);

	if (pAllocInfo->Signature != TUND_MEMORY_SIGNATURE)
	{
		DEBUGP(DL_ERROR,
		 ("TunAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
		NdisReleaseSpinLock(&(TundMemoryLock));
#if DBG
		DbgBreakPoint();
#endif
		return;
	}

	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PTUND_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		TundMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PTUND_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		TundMemoryTail = pAllocInfo->Prev;
	}
	TundAllocCount--;
	NdisReleaseSpinLock(&(TundMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
TunAuditShutdown(
	VOID
)
{
	if (TundInitDone)
	{
		if (TundAllocCount != 0)
		{
			DEBUGP(DL_ERROR, ("AuditShutdown: unfreed memory, %d blocks!\n",
					TundAllocCount));
			DEBUGP(DL_ERROR, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
					TundMemoryHead, TundMemoryTail));
			DbgBreakPoint();
			{
				PTUND_ALLOCATION		pAllocInfo;

				while (TundMemoryHead != (PTUND_ALLOCATION)NULL)
				{
					pAllocInfo = TundMemoryHead;
					DEBUGP(DL_INFO, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
					TunAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		TundInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}
#endif // DBG


#if DBG_SPIN_LOCK
ULONG	TundSpinLockInitDone = 0;
NDIS_SPIN_LOCK	TundLockLock;

VOID
TunAllocateSpinLock(
	IN	PTUN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (TundSpinLockInitDone == 0)
	{
		TundSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(TundLockLock));
	}

	NdisAcquireSpinLock(&(TundLockLock));
	pLock->Signature = TUNL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(TundLockLock));
}


VOID
TunAcquireSpinLock(
	IN	PTUN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(TundLockLock));
	if (pLock->Signature != TUNL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(TundLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
TunReleaseSpinLock(
	IN	PTUN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(TundLockLock));
	if (pLock->Signature != TUNL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(TundLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\sys\ndissym\ndissym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    acpisym.c

--*/

#include <..\precomp.h>


NDIS50_PROTOCOL_CHARACTERISTICS   t1;
NDIS_PROTOCOL_BLOCK               t2;
NDIS_OPEN_BLOCK                   t3;
NDIS_COMMON_OPEN_BLOCK            t4;
NDIS_MINIPORT_BLOCK               t5;
NDIS_M_DRIVER_BLOCK               t6;
NDIS_CO_VC_PTR_BLOCK              t7;
NDIS_CO_VC_BLOCK                  t8;
NDIS_CO_AF_BLOCK                  t9;
NDIS_PACKET                       t10;
MDL                               t11;
UNICODE_STRING                    t12;
LIST_ENTRY                        t13;
NDIS_PKT_POOL                     t14;
NDIS_TRACK_MEM                    t15;
NDIS_PKT_POOL_HDR                 t16;
STACK_INDEX                       t17;
NDIS_PACKET_STACK                 t18;
CM_PARTIAL_RESOURCE_DESCRIPTOR    t19;
CM_FULL_RESOURCE_DESCRIPTOR       t20;
CM_RESOURCE_LIST                  t21;
DEVICE_CAPABILITIES               t22;


int __cdecl main() {
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for NDISUIO

Revision History:

    arvindm     04/11/2000    created based on rawwan.

Notes:

--*/

#ifndef _TUN_DEBUG__H
#define _TUN_DEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD       20
#define DL_VERY_LOUD        10
#define DL_LOUD             8
#define DL_INFO             6
#define DL_WARN             4
#define DL_ERROR            2
#define DL_FATAL            0

#if DBG_SPIN_LOCK

typedef struct _TUN_LOCK
{
    ULONG                   Signature;
    ULONG                   IsAcquired;
    PKTHREAD                OwnerThread;
    ULONG                   TouchedByFileNumber;
    ULONG                   TouchedInLineNumber;
    NDIS_SPIN_LOCK          NdisLock;
} TUN_LOCK, *PTUN_LOCK;

#define TUNL_SIG    'KCOL'

extern NDIS_SPIN_LOCK       TunDbgLogLock;

extern
VOID
TunAllocateSpinLock(
    IN  PTUN_LOCK           pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
TunAcquireSpinLock(
    IN  PTUN_LOCK           pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
TunReleaseSpinLock(
    IN  PTUN_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)                                         \
            {                                                           \
                if ((INT)(Count) < 0)                                   \
                {                                                       \
                    DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",\
                        Count, __FILE__, __LINE__);                     \
                    DbgBreakPoint();                                    \
                }                                                       \
            }
#else

#define CHECK_LOCK_COUNT(Count)

typedef NDIS_SPIN_LOCK      TUN_LOCK;
typedef PNDIS_SPIN_LOCK     PTUN_LOCK;

#endif    // DBG_SPIN_LOCK

#if DBG

extern INT                TunDebugLevel;


#define DEBUGP(lev, stmt)                                               \
        {                                                               \
            if ((lev) <= TunDebugLevel)                             \
            {                                                           \
                DbgPrint("TunMp: "); DbgPrint stmt;                   \
            }                                                           \
        }

#define DEBUGPDUMP(lev, pBuf, Len)                                      \
        {                                                               \
            if ((lev) <= TunDebugLevel)                                 \
            {                                                           \
                DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));          \
            }                                                           \
        }

#define TUN_ASSERT(exp)                                                 \
        {                                                               \
            if (!(exp))                                                 \
            {                                                           \
                DbgPrint("TunMp: assert " #exp " failed in"             \
                    " file %s, line %d\n", __FILE__, __LINE__);         \
                DbgBreakPoint();                                        \
            }                                                           \
        }

#define TUN_SET_SIGNATURE(s, t)\
        (ULONG)(s)->t##_sig = (ULONG)t##_signature;

#define TUN_STRUCT_ASSERT(s, t)                                         \
        if ((ULONG)(s)->t##_sig != (ULONG)t##_signature)                \
        {                                                               \
            DbgPrint("Tun: assertion failure"                           \
            " for type " #t " at 0x%p in file %s, line %d\n",           \
             (PUCHAR)s, __FILE__, __LINE__);                            \
            DbgBreakPoint();                                            \
        }


//
// Memory Allocation/Freeing Audit:
//

//
// The TUND_ALLOCATION structure stores all info about one allocation
//
typedef struct _TUND_ALLOCATION {

        ULONG                    Signature;
        struct _TUND_ALLOCATION *Next;
        struct _TUND_ALLOCATION *Prev;
        ULONG                    FileNumber;
        ULONG                    LineNumber;
        ULONG                    Size;
        ULONG_PTR                Location;  // where the returned ptr was stored
        union
        {
            ULONGLONG            Alignment;
            UCHAR                    UserData;
        };

} TUND_ALLOCATION, *PTUND_ALLOCATION;

#define TUND_MEMORY_SIGNATURE    (ULONG)'CSII'

extern
PVOID
TunAuditAllocMem (
    PVOID        pPointer,
    ULONG        Size,
    ULONG        FileNumber,
    ULONG        LineNumber
);

extern
VOID
TunAuditFreeMem(
    PVOID        Pointer
);

extern
VOID
TunAuditShutdown(
    VOID
);

extern
VOID
DbgPrintHexDump(
    PUCHAR        pBuffer,
    ULONG        Length
);

#else

//
// No debug
//
#define DEBUGP(lev, stmt)
#define DEBUGPDUMP(lev, pBuf, Len)

#define TUN_ASSERT(exp)
#define TUN_SET_SIGNATURE(s, t)
#define TUN_STRUCT_ASSERT(s, t)

#endif    // DBG


#endif // _TUN_DEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\globals.c ===
/* 
Copyright (c) 2001  Microsoft Corporation

Module Name:

    globals.c

Abstract:
    global variables for Microsoft Tunnel interface Miniport driver

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001 

--*/

#include "precomp.h"

#define __FILENUMBER 'MUNT'

const TUN_MEDIA_INFO MediaParams[] =
//MaxFrameLen, MacHeaderLen, PacketFilters, LinkSpeed
{
    { 1500, 14, 100000}, // NdisMedium802_3
    { 4082, 14, 40000}, // NdisMedium802_5
    { 4486, 13, 1000000}, // NdisMediumFddi
    {    0,  0, 0}, // NdisMediumWan
    {  600,  3, 2300}, // NdisMediumLocalTalk
    { 1500, 14, 100000}, // NdisMediumDix
    { 1512,  3, 25000}, // NdisMediumArcnetRaw
    { 1512,  3, 25000}  // NdisMediumArcnet878_2
};

NDIS_HANDLE NdisWrapperHandle = NULL;

LONG GlobalDeviceInstanceNumber = -1;

NDIS_SPIN_LOCK  TunGlobalLock;
LIST_ENTRY      TunAdapterList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\precomp.h ===
#include "ndis.h"
#include "ntddk.h"
#include "tunuser.h"
#include "debug.h"
#include "tunmp.h"
#include "macros.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\request.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    send.c

Abstract:

    NDIS entry points to handle requests.

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001   modified for tunmp
    arvindm     4/10/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'TQER'

NDIS_OID TunMpSupportedOidArray[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
        
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,

    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,

    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,

    OID_CUSTOM_TUNMP_INSTANCE_ID

};

UINT    TunMpSupportedOids = sizeof(TunMpSupportedOidArray)/sizeof(NDIS_OID);
UCHAR   TunMpVendorDescription[] = "MS Tunnel Interface Driver";
UCHAR   TunMpVendorId[3] = {0xFF, 0xFF, 0xFF};

NDIS_PNP_CAPABILITIES       Power_Management_Capabilities = { 0, 
                                                              NdisDeviceStateUnspecified,
                                                              NdisDeviceStateUnspecified,
                                                              NdisDeviceStateUnspecified
                                                            };
                                                              

NDIS_STATUS
TunMpQueryInformation(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_OID            Oid,
    IN  PVOID               InformationBuffer,
    IN  ULONG               InformationBufferLength,
    OUT PULONG              BytesWritten,
    OUT PULONG              BytesNeeded
    )

/*++

Routine Description:

    Miniport QueryInfo handler.

Arguments:

    MiniportAdapterContext      Pointer to the adapter structure
    Oid                         Oid for this query
    InformationBuffer           Buffer for information
    InformationBufferLength     Size of this buffer
    BytesWritten                Specifies how much info is written
    BytesNeeded                 In case the buffer is smaller than what
                                we need, tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/

{
    PTUN_ADAPTER            pAdapter = (PTUN_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS             NdisStatus = NDIS_STATUS_SUCCESS;
    UINT                    i;
    NDIS_OID                MaskOid;
    PVOID                   SourceBuffer;
    UINT                    SourceBufferLength;
    ULONG                   GenericUlong = 0;
    USHORT                  GenericUshort;

    DEBUGP(DL_LOUD, ("==>TunMpQueryInformation: Adapter %p, Oid %lx\n",
            pAdapter, Oid));

    *BytesWritten = 0;
    *BytesNeeded  = 0;

    //
    // Initialize these once, since this is the majority of cases.
    //

    SourceBuffer = (PVOID)&GenericUlong;
    SourceBufferLength = sizeof(ULONG);

    switch (Oid)
    {
        case OID_GEN_MAC_OPTIONS:
            GenericUlong = (ULONG)(NDIS_MAC_OPTION_NO_LOOPBACK);
            break;

        case OID_GEN_SUPPORTED_LIST:
            (NDIS_OID*)SourceBuffer = TunMpSupportedOidArray;
            SourceBufferLength = TunMpSupportedOids * sizeof(ULONG);
            break;

        case OID_GEN_HARDWARE_STATUS:
            GenericUlong = NdisHardwareStatusReady;
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            GenericUlong = pAdapter->Medium;
            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            GenericUlong = pAdapter->MaxLookAhead;
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            GenericUlong = pAdapter->MediumMaxFrameLen;
            break;

        case OID_GEN_LINK_SPEED:
            GenericUlong = pAdapter->MediumLinkSpeed;
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            GenericUlong = (pAdapter->MediumMaxPacketLen);
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            GenericUlong = (pAdapter->MediumMaxPacketLen);
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            GenericUlong = 1;
            break;

        case OID_GEN_RECEIVE_BLOCK_SIZE:
            GenericUlong = 1;
            break;

        case OID_GEN_VENDOR_ID:
            SourceBuffer = TunMpVendorId;
            SourceBufferLength = sizeof(TunMpVendorId);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            SourceBuffer = TunMpVendorDescription;
            SourceBufferLength = sizeof(TunMpVendorDescription);
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            GenericUlong = pAdapter->PacketFilter;
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            GenericUlong = pAdapter->MaxLookAhead;
            break;

        case OID_GEN_DRIVER_VERSION:
            GenericUshort = (NDIS_MINIPORT_MAJOR_VERSION << 8) + NDIS_MINIPORT_MINOR_VERSION;
            SourceBuffer = &GenericUshort;
            SourceBufferLength = sizeof(USHORT);
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            GenericUlong = pAdapter->MediumMaxPacketLen;
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            KdPrint(("OID_GEN_MEDIA_CONNECT_STATUS: %lx\n", Oid));
            if(TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OPEN))
                GenericUlong = NdisMediaStateConnected;
            else
                GenericUlong = NdisMediaStateDisconnected;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            GenericUlong = MAX_RECV_QUEUE_SIZE;
            break;

        case OID_GEN_XMIT_OK:
            SourceBuffer = &(pAdapter->SendPackets);
            SourceBufferLength = sizeof(ULONG);
            break;
            
        case OID_GEN_RCV_OK:
            SourceBuffer = &(pAdapter->RcvPackets);
            SourceBufferLength = sizeof(ULONG);
            break;

        case OID_GEN_XMIT_ERROR:
            SourceBuffer = &(pAdapter->XmitError);
            SourceBufferLength = sizeof(ULONG);
            break;
            
        case OID_GEN_RCV_ERROR:
            SourceBuffer = &(pAdapter->RcvError);
            SourceBufferLength = sizeof(ULONG);
            break;

        case OID_GEN_RCV_NO_BUFFER:
            SourceBuffer = &(pAdapter->RcvNoBuffer);
            SourceBufferLength = sizeof(ULONG);
            break;             
    
        case OID_802_3_PERMANENT_ADDRESS:
            SourceBuffer = pAdapter->PermanentAddress;
            SourceBufferLength = TUN_MAC_ADDR_LEN;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            SourceBuffer = pAdapter->CurrentAddress;
            SourceBufferLength = TUN_MAC_ADDR_LEN;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            GenericUlong = TUN_MAX_MULTICAST_ADDRESS;
            break;

        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
            GenericUlong = 0;
            break;

        case OID_PNP_CAPABILITIES:
            //
            // we support going to D3, but we don't do any WOL
            //
            SourceBufferLength = sizeof (NDIS_PNP_CAPABILITIES);
            SourceBuffer = (PVOID)&Power_Management_Capabilities;
            break;
            
        case OID_PNP_QUERY_POWER:
            //
            // we should always succeed this OID.
            //
            SourceBufferLength = 0;
            break;

        case OID_CUSTOM_TUNMP_INSTANCE_ID:
            GenericUlong = pAdapter->DeviceInstanceNumber;
            break;
            
        default:
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }
                   

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        *BytesNeeded = SourceBufferLength;

        if (SourceBufferLength <= InformationBufferLength)
        {
            *BytesWritten = SourceBufferLength;
            if (SourceBufferLength)
            {
                NdisMoveMemory(InformationBuffer, SourceBuffer, SourceBufferLength);
            }
        }
        else 
        {
            NdisStatus = NDIS_STATUS_BUFFER_TOO_SHORT;
        }

    }

    DEBUGP(DL_LOUD, ("<==TunMpQueryInformation: Adapter %p, NdisStatus %lx\n",
            pAdapter, NdisStatus));

    return (NdisStatus);
}


NDIS_STATUS
TunMpSetInformation(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_OID            Oid,
    IN  PVOID               InformationBuffer,
    IN  ULONG               InformationBufferLength,
    OUT PULONG              BytesRead,
    OUT PULONG              BytesNeeded
    )

/*++

Routine Description:

    Miniport SetInfo handler.

Arguments:

    MiniportAdapterContext     Pointer to the adapter structure
    Oid                        Oid for this query
    InformationBuffer          Buffer for information
    InformationBufferLength    Size of this buffer
    BytesRead                  Specifies how much info is read
    BytesNeeded                In case the buffer is smaller than what we need,
                               tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/

{
    PTUN_ADAPTER        pAdapter = (PTUN_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_SUCCESS;
    NDIS_DEVICE_POWER_STATE NewPowerState;

    DEBUGP(DL_LOUD, ("==>TunMpSetInformation: Adapter %p, Oid %lx\n",
            pAdapter, Oid));

    
    *BytesRead = 0;
    *BytesNeeded = 0;

    switch (Oid)
    {

      case OID_GEN_CURRENT_PACKET_FILTER:
        if (InformationBufferLength != sizeof(ULONG))
        {
            NdisStatus = NDIS_STATUS_INVALID_DATA;
        }
        else
        {
            ULONG    PacketFilter;

            PacketFilter = *(UNALIGNED ULONG *)InformationBuffer;


            pAdapter->PacketFilter = PacketFilter;
            *BytesRead = InformationBufferLength;

            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
            
            if (PacketFilter != 0)
            {
                //
                // if packet filter is set to a non-zero value, then activate
                // the adapter. i.e. start indicating packets.
                //
                TUN_SET_FLAG(pAdapter, TUN_ADAPTER_ACTIVE);
            }
            else
            {
                //
                // if packet filter is set to zero, then we should
                // fail all writes
                //
                TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_ACTIVE);
                if (pAdapter->PendedSendCount != 0)
                {
                    NdisStatus = NDIS_STATUS_PENDING;
                    TUN_SET_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
                }
                else
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;
                }

            }
            
            TUN_RELEASE_LOCK(&pAdapter->Lock);

        }
        break;

      case OID_GEN_CURRENT_LOOKAHEAD:
        if (InformationBufferLength != sizeof(ULONG))
        {
            NdisStatus = NDIS_STATUS_INVALID_DATA;
        }
        else
        {
            ULONG    CurrentLookahead;

            CurrentLookahead = *(UNALIGNED ULONG *)InformationBuffer;
    
            if (CurrentLookahead > TUN_MAX_LOOKAHEAD)
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            }
            else if (CurrentLookahead >= pAdapter->MaxLookAhead)
            {
                pAdapter->MaxLookAhead = CurrentLookahead;
                *BytesRead = sizeof(ULONG);
                NdisStatus = NDIS_STATUS_SUCCESS;
            }
        }
        break;
        

      case OID_802_3_MULTICAST_LIST:
        if (pAdapter->Medium != NdisMedium802_3)
        {
            NdisStatus = NDIS_STATUS_INVALID_OID;
            break;
        }

        if ((InformationBufferLength % ETH_LENGTH_OF_ADDRESS) != 0)
        {
            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }
        //1 set BytesNeeded, check for max multicastlist
        break;

      case OID_PNP_SET_POWER:

        if (InformationBufferLength != sizeof(NDIS_DEVICE_POWER_STATE ))
        {
            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        NewPowerState = *(PNDIS_DEVICE_POWER_STATE)InformationBuffer;
        *BytesRead = sizeof(NDIS_DEVICE_POWER_STATE);

        TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        if (NewPowerState != NdisDeviceStateD0)
        {
            //
            // complete any oustanding NDIS sends. do not allow any
            // more NDIS sends. wait for all the indicated packets
            // to return and do not allow any more packet 
            // indications (application Write)
            //
            TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_ACTIVE);
            TUN_SET_FLAG(pAdapter, TUN_ADAPTER_OFF);
            
            //
            // complete all outstanding NDIS Send requests
            //
            TUN_RELEASE_LOCK(&pAdapter->Lock);
            //
            // abort all pending NDIS send requests
            TunFlushReceiveQueue(pAdapter);                
            //
            // cancel all pending read IRPs if any
            //
            TunCancelPendingReads(pAdapter);
            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
            
            //
            // is there any outstanding NDIS sends?
            //
            if ((pAdapter->PendedSendCount != 0) ||
                (pAdapter->PendedReadCount != 0))
            {
                NdisStatus = NDIS_STATUS_PENDING;
                TUN_SET_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
            }

        }
        else
        {
            TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_OFF);

            if (pAdapter->PacketFilter != 0)
            {
                TUN_SET_FLAG(pAdapter, TUN_ADAPTER_ACTIVE);
            }
            
            //
            // 
            NdisStatus = NDIS_STATUS_SUCCESS; 
        }

        TUN_RELEASE_LOCK(&pAdapter->Lock);
            
        break;

      default:
        NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    DEBUGP(DL_LOUD, ("<==TunMpSetInformation: Adapter %p, NdisStatus %lx\n",
            pAdapter, NdisStatus));
    

    return NdisStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\send.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    send.c

Abstract:

    utility routines to handle sending data.

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001   modified for tunmp
    arvindm     4/10/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'DNES'


NTSTATUS
TunWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_WRITE. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   DataLength;
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PTUN_ADAPTER            pAdapter;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_BUFFER            pNdisBuffer;
    PVOID                   Address;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrp->IoStatus.Information = 0;
    pAdapter = (PTUN_ADAPTER)pIrpSp->FileObject->FsContext;

    DEBUGP(DL_LOUD, ("==>TunWrite: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));


    pNdisPacket = NULL;

    do
    {
        if (pAdapter == NULL)
        {
            DEBUGP(DL_WARN, ("Write: FileObject %p not yet associated with a device\n",
                pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
               
        TUN_STRUCT_ASSERT(pAdapter, mc);

        
        if(pIrp->MdlAddress == NULL)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Sanity-check the length.
        //
        DataLength = MmGetMdlByteCount(pIrp->MdlAddress);
        if (DataLength < sizeof(TUN_ETH_HEADER))
        {
            DEBUGP(DL_WARN, ("Write: too small to be a valid packet (%d bytes)\n",
                DataLength));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        Address = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
        if (Address == NULL)
        {
            DEBUGP(DL_WARN, ("Write: Adapter %p: Mdl %p"
                    " couldn't get the system address for MDL\n",
                    pAdapter, pIrp->MdlAddress));

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if (DataLength > (pAdapter->MediumMaxFrameLen + sizeof(TUN_ETH_HEADER)))
        {
            DEBUGP(DL_WARN, ("Write: Adapter %p: data length (%d)"
                    " larger than max frame size (%d)\n",
                    pAdapter, DataLength, pAdapter->MediumMaxFrameLen));

            NtStatus = STATUS_INVALID_BUFFER_SIZE;
            break;
        }


        TUN_ACQUIRE_LOCK(&pAdapter->Lock);

        if ((!TUN_TEST_FLAGS(pAdapter, TUN_ADAPTER_ACTIVE)) ||
             TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OFF))
        {
            TUN_RELEASE_LOCK(&pAdapter->Lock);

            DEBUGP(DL_FATAL, ("Write: Adapter %p is not bound"
            " or in low power state\n", pAdapter));

            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Allocate a send packet.
        //
        TUN_ASSERT(pAdapter->SendPacketPool != NULL);
        NdisAllocatePacket(
            &Status,
            &pNdisPacket,
            pAdapter->SendPacketPool);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            TUN_RELEASE_LOCK(&pAdapter->Lock);

            DEBUGP(DL_FATAL, ("Write: open %p, failed to alloc send pkt\n",
                    pAdapter));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //1 we should do a copy here
        pNdisBuffer = pIrp->MdlAddress;
        pAdapter->PendedSendCount++;
        pAdapter->RcvBytes += MmGetMdlByteCount(pIrp->MdlAddress);

        TUN_REF_ADAPTER(pAdapter);  // pended send

        IoMarkIrpPending(pIrp);

        //
        //  Initialize the packet ref count. This packet will be freed
        //  when this count goes to zero.
        //
        TUN_SEND_PKT_RSVD(pNdisPacket)->RefCount = 1;

        TUN_RELEASE_LOCK(&pAdapter->Lock);

        //
        //  Set a back pointer from the packet to the IRP.
        //
        TUN_IRP_FROM_SEND_PKT(pNdisPacket) = pIrp;

        NtStatus = STATUS_PENDING;

        pNdisBuffer->Next = NULL;
        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

#if SEND_DBG
        {
            PUCHAR      pData;

            pData = MmGetSystemAddressForMdlSafe(pNdisBuffer, NormalPagePriority);
            TUN_ASSERT(pEthHeader == pData);

            DEBUGP(DL_VERY_LOUD, 
                ("Write: MDL %p, MdlFlags %x, SystemAddr %p, %d bytes\n",
                    pIrp->MdlAddress, pIrp->MdlAddress->MdlFlags, pData, DataLength));

            DEBUGPDUMP(DL_VERY_LOUD, pData, MIN(DataLength, 48));
        }
#endif // SEND_DBG

        NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);
        NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, sizeof(TUN_ETH_HEADER));

        NdisMIndicateReceivePacket(pAdapter->MiniportHandle,
                                   &pNdisPacket,
                                   1);


    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    DEBUGP(DL_LOUD, ("<==TunWrite: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\macros.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Some macros for TUNMP.

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001  copied from macros.h for ndisuio
    arvindm     4/5/2000    Created
    

--*/


#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b)? (_a): (_b))
#endif

#if DBG
#define TUN_REF_ADAPTER(_pAdapter)      TunMpDbgRefAdapter(_pAdapter, __FILENUMBER, __LINE__)
#define TUN_DEREF_ADAPTER(_pAdapter)    TunMpDbgDerefAdapter(_pAdapter, __FILENUMBER, __LINE__)
#else
#define TUN_REF_ADAPTER(_pAdapter)      TunMpRefAdapter(_pAdapter)
#define TUN_DEREF_ADAPTER(_pAdapter)    TunMpDerefAdapter(_pAdapter)
#endif

//
//  Spinlock macros
//
#if DBG_SPIN_LOCK

#define TUN_INIT_LOCK(_pLock)              \
           TunAllocateSpinLock(_pLock, __FILENUMBER, __LINE__)

#define TUN_ACQUIRE_LOCK(_pLock)           \
            TunAcquireSpinLock(_pLock, __FILENUMBER, __LINE__)

#define TUN_RELEASE_LOCK(_pLock)           \
            TunReleaseSpinLock(_pLock, __FILENUMBER, __LINE__)

#else

#define TUN_INIT_LOCK(_pLock)           NdisAllocateSpinLock(_pLock)
#define TUN_ACQUIRE_LOCK(_pLock)        NdisAcquireSpinLock(_pLock)
#define TUN_RELEASE_LOCK(_pLock)        NdisReleaseSpinLock(_pLock)

#endif // DBG

//
//  List manipulation.
//
#define TUN_INIT_LIST_HEAD(_pList)             InitializeListHead(_pList)
#define TUN_IS_LIST_EMPTY(_pList)              IsListEmpty(_pList)
#define TUN_INSERT_HEAD_LIST(_pList, _pEnt)    InsertHeadList(_pList, _pEnt)
#define TUN_INSERT_TAIL_LIST(_pList, _pEnt)    InsertTailList(_pList, _pEnt)
#define TUN_REMOVE_ENTRY_LIST(_pEnt)           RemoveEntryList(_pEnt)


//
//  Receive packet queueing.
//
#define TUN_LIST_ENTRY_TO_RCV_PKT(_pEnt)   \
    CONTAINING_RECORD(CONTAINING_RECORD(_pEnt, TUN_RECV_PACKET_RSVD, Link), NDIS_PACKET, MiniportReserved)

#define TUN_RCV_PKT_TO_LIST_ENTRY(_pPkt)   \
    (&((PTUN_RECV_PACKET_RSVD)&((_pPkt)->MiniportReserved[0]))->Link)



//
//  Send packet context.
//
#define TUN_IRP_FROM_SEND_PKT(_pPkt)        \
    (((PTUN_SEND_PACKET_RSVD)&((_pPkt)->MiniportReserved[0]))->pIrp)

#define TUN_SEND_PKT_RSVD(_pPkt)            \
    ((PTUN_SEND_PACKET_RSVD)&((_pPkt)->MiniportReserved[0]))


#define TUN_REF_SEND_PKT(_pPkt)             \
    (VOID)NdisInterlockedIncrement(&TUN_SEND_PKT_RSVD(_pPkt)->RefCount)


#define TUN_DEREF_SEND_PKT(_pPkt)           \
    {                                                                               \
        if (NdisInterlockedDecrement(&TUN_SEND_PKT_RSVD(_pPkt)->RefCount) == 0)     \
        {                                                                           \
            NdisFreePacket(_pPkt);                                                  \
        }                                                                           \
    }

//
//  Memory allocation
//
#if DBG
#define TUN_ALLOC_MEM(_pVar, _Size)         \
    (_pVar) = TunAuditAllocMem(             \
                    (PVOID)&(_pVar),        \
                    _Size,                  \
                    __FILENUMBER,           \
                    __LINE__);

#define TUN_FREE_MEM(_pMem)                 \
    TunAuditFreeMem(_pMem);

#else

#define TUN_ALLOC_MEM(_pVar, _Size)         \
    NdisAllocateMemoryWithTag((PVOID *)(&_pVar), (_Size), TUN_ALLOC_TAG)

#define TUN_FREE_MEM(_pMem)                 \
    NdisFreeMemory(_pMem, 0, 0)

#endif // DBG


#define TUN_ZERO_MEM(_pMem, _ByteCount)         \
    NdisZeroMemory(_pMem, _ByteCount)

#define TUN_COPY_MEM(_pDst, _pSrc, _ByteCount)  \
    NdisMoveMemory(_pDst, _pSrc, _ByteCount)

#define TUN_MEM_CMP(_p1, _p2, _ByteCount)       \
    NdisEqualMemory(_p1, _p2, _ByteCount)

#define TUN_SET_MEM(_pMem, _ByteVal, _ByteCount)    \
    NdisFillMemory(_pMem, _ByteCount, _ByteVal)

//
//  Events.
//
#define TUN_INIT_EVENT(_pEvent)            NdisInitializeEvent(_pEvent)
#define TUN_SIGNAL_EVENT(_pEvent)          NdisSetEvent(_pEvent)
#define TUN_WAIT_EVENT(_pEvent, _MsToWait) NdisWaitEvent(_pEvent, _MsToWait)



//
//  Block the calling thread for the given duration:
//
#define TUN_SLEEP(_Seconds)                             \
{                                                       \
    NDIS_EVENT  _SleepEvent;                            \
    NdisInitializeEvent(&_SleepEvent);                  \
    (VOID)NdisWaitEvent(&_SleepEvent, _Seconds*1000);   \
}


#define NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                           \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_FOUND == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_NO_MORE_ENTRIES;                                     \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_READY == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_DEVICE_NOT_READY;                                    \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\tunf.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tunf.c

Abstract:

    utility routines to handle opening and closing the tunmp device.

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001   modified for tunmp

--*/



#include "precomp.h"

#define __FILENUMBER 'FNUT'


NTSTATUS
TunFOpen(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    Hanndles IRP_MJ_CREATE. Here we set the device status in use, assigns a pointer
    from the file object to the adapter object using pIrpSp->FileObject->FsContext,
    allocates packet and buffer pools, and returns a success status

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      pIrpSp;
    NDIS_STATUS             NdisStatus;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    UINT                    i;
    BOOLEAN                 Found = FALSE;
    PLIST_ENTRY             pListEntry;
    PTUN_ADAPTER            pAdapter = NULL;
    BOOLEAN                 DerefAdapter = FALSE;

    DEBUGP(DL_INFO, ("Open: DeviceObject %p\n", DeviceObject));

    do
    {
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        
        TUN_ACQUIRE_LOCK(&TunGlobalLock); 
        
        for (pListEntry = TunAdapterList.Flink;
             pListEntry != &TunAdapterList;
             pListEntry = pListEntry->Flink)
        {
             pAdapter = CONTAINING_RECORD(pListEntry,
                                          TUN_ADAPTER,
                                          Link);

            if(pAdapter->DeviceObject == DeviceObject)
            {
                Found = TRUE;
                TUN_REF_ADAPTER(pAdapter);
                DerefAdapter = TRUE;
                break;
            }
        }

        TUN_RELEASE_LOCK(&TunGlobalLock);

        if (Found == FALSE)
        {
            NtStatus = STATUS_NO_SUCH_DEVICE;
            break;
        }

        TUN_ACQUIRE_LOCK(&pAdapter->Lock);

        if (TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OPEN))
        {
            //
            // adapter is already open by another device. fail
            //
            TUN_RELEASE_LOCK(&pAdapter->Lock);
            NtStatus = STATUS_INVALID_DEVICE_STATE;
            break;
        }
        
        TUN_SET_FLAG(pAdapter, TUN_ADAPTER_OPEN | TUN_ADAPTER_CANT_HALT);
        TUN_RELEASE_LOCK(&pAdapter->Lock);
            
        //Assign a pointer to the adapter object from the file object
        pIrpSp->FileObject->FsContext = (PVOID)pAdapter;
        
    
        //Get the device connected to the network by cable plugging in
        NdisMIndicateStatus(pAdapter->MiniportHandle,
                            NDIS_STATUS_MEDIA_CONNECT,
                            NULL,
                            0);
        
        NdisMIndicateStatusComplete(pAdapter->MiniportHandle);

        DerefAdapter = FALSE;


    } while (FALSE);
    

    //
    //Complete the IRP
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    if (DerefAdapter)
    {
        TUN_DEREF_ADAPTER(pAdapter);
    }

    return (NtStatus);
}    

//************************************************************************

NTSTATUS
TunFClose(
    IN PDEVICE_OBJECT        pDeviceObject,
    IN PIRP                  pIrp
    )

/*++

Routine Description:

    Handles IRP_MJ_CLOSE. Here we change the device state into available (not in
    use), free the the file object's pointer to the adapter object, free the
    allocated packet/buffer pools, and set the success status.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    //1 this may be moved to clean_up
    NTSTATUS                NtStatus;
    PIO_STACK_LOCATION      pIrpSp;
    PTUN_ADAPTER                pAdapter;
    PLIST_ENTRY             pRcvPacketEntry;
    PNDIS_PACKET            pRcvPacket;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pAdapter = (PTUN_ADAPTER)pIrpSp->FileObject->FsContext;

    DEBUGP(DL_INFO, ("Close: FileObject %p\n",
        IoGetCurrentIrpStackLocation(pIrp)->FileObject));
    
    //If no adapter/device object is associated with the this file object
    if (pAdapter == NULL)
    {
        NtStatus = STATUS_IO_DEVICE_ERROR;
    }
    else
    {
        TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_OPEN);
        TUN_RELEASE_LOCK(&pAdapter->Lock);

        NdisMIndicateStatus(pAdapter->MiniportHandle,
                            NDIS_STATUS_MEDIA_DISCONNECT,
                            NULL,
                            0);
 
        NdisMIndicateStatusComplete(pAdapter->MiniportHandle);
 
        //Let the adapter object free
        pIrpSp->FileObject->FsContext = NULL;


        TUN_ACQUIRE_LOCK(&pAdapter->Lock);

        //
        //Emtpy the received packets queue, and return the packets to NDIS
        //with success status
        //
        while(!IsListEmpty(&pAdapter->RecvPktQueue))
        {
            //
            //Remove the first queued received packet from the entry list
            //
            pRcvPacketEntry = pAdapter->RecvPktQueue.Flink;
            RemoveEntryList(pRcvPacketEntry);
            ExInterlockedDecrementLong(&pAdapter->RecvPktCount, &pAdapter->Lock);

            //Get the packet from
            pRcvPacket = CONTAINING_RECORD(pRcvPacketEntry,
                                           NDIS_PACKET,
                                           MiniportReserved[0]);

            TUN_RELEASE_LOCK(&pAdapter->Lock);
            
            //Indicate NDIS about comletion of the packet
            NdisMSendComplete(pAdapter->MiniportHandle,
                              pRcvPacket,
                              NDIS_STATUS_FAILURE);

            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        
        }
        
        TUN_RELEASE_LOCK(&pAdapter->Lock);

        NtStatus = STATUS_SUCCESS;
    }
    //1 who should do the testing of tunmp
    //
    //Complete the IRP
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    if (pAdapter != NULL)
    {
        TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        
        TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_CANT_HALT);
        if (pAdapter->HaltEvent != NULL)
        {
            NdisSetEvent(pAdapter->HaltEvent);
        }
        
        TUN_RELEASE_LOCK(&pAdapter->Lock);
    }

    KdPrint(("\nTunFClose: Exit\n"));

    return (NtStatus);
}



//************************************************************************

NTSTATUS
TunFCleanup(
    IN PDEVICE_OBJECT        pDeviceObject,
    IN PIRP                  pIrp
    )

/*++

Routine Description:

    Handles IRP_MJ_CLEANUP. Here we reset the driver's cancel entry point to NULL
    in every IRP currently in the driver's internal queue of read IRPs, cancel
    all the queued IRPs, and return a success status.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus;
    PTUN_ADAPTER            pAdapter;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pAdapter = (PTUN_ADAPTER)pIrpSp->FileObject->FsContext;

    DEBUGP(DL_INFO, ("Cleanup: FileObject %p, pAdapter %p\n",
        pIrpSp->FileObject, pAdapter));


    if (pAdapter != NULL)
    {
        TUN_STRUCT_ASSERT(pAdapter, mc);

        //
        //  Mark this endpoint.
        //
        TUN_ACQUIRE_LOCK(&pAdapter->Lock);

        TUN_CLEAR_FLAG(pAdapter, TUN_ADAPTER_OPEN);
        pAdapter->pFileObject = NULL;

        TUN_RELEASE_LOCK(&pAdapter->Lock);
        
        TunCancelPendingReads(pAdapter);       
    }

    NtStatus = STATUS_SUCCESS;

    //
    //Complete the IRP
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    DEBUGP(DL_INFO, ("Cleanup: OpenContext %p\n", pAdapter));

    return (NtStatus);
}



//************************************************************************

NTSTATUS
TunFIoControl(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )

/*++

Routine Description:

    This is the dispatch routine for handling device IOCTL requests.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      pIrpSp;
    PTUN_ADAPTER            pAdapter;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   BytesReturned = 0;
    PUCHAR                  OutputBuffer = NULL;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pAdapter = (PTUN_ADAPTER)pIrpSp->FileObject->FsContext;

//    pIrp->IoStatus.Information = 0;

    //if no adapter/device object is associated with this file object
    if (pAdapter == NULL)
    {
        pIrp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return NtStatus;
    }
    //1 check for valid adapter

    pIrp->IoStatus.Information = 0;
    OutputBuffer = (PUCHAR)pIrp->AssociatedIrp.SystemBuffer;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {

        case IOCTL_TUN_GET_MEDIUM_TYPE:

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(NDIS_MEDIUM))
            {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
            }
            
            else
            {
                *((PNDIS_MEDIUM)OutputBuffer) = pAdapter->Medium;
                BytesReturned = sizeof(ULONG);
            }
            break;


        case IOCTL_TUN_GET_MTU:

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
            {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
            }

            else
            {
                *((PULONG)OutputBuffer) = pAdapter->MediumMaxPacketLen;
                BytesReturned = sizeof(ULONG);
            }
            
            break;
            
        case IOCTL_TUN_GET_PACKET_FILTER:

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
            {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                *((PULONG)OutputBuffer) = pAdapter->PacketFilter;
                BytesReturned = sizeof(ULONG);
            }

            break;

        case IOCTL_TUN_GET_MINIPORT_NAME:

            if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < pAdapter->MiniportName.Length + sizeof(USHORT))
            {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                *((PUSHORT)OutputBuffer) = pAdapter->MiniportName.Length;
                
                TUN_COPY_MEM(OutputBuffer + sizeof(USHORT),
                             (PUCHAR)pAdapter->MiniportName.Buffer,
                             pAdapter->MiniportName.Length);
                
                BytesReturned = pAdapter->MiniportName.Length + sizeof(USHORT);                
            }

            break;
            
    
        default:
            NtStatus = STATUS_NOT_SUPPORTED;
            break;
    }

    pIrp->IoStatus.Information = BytesReturned;
    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength = BytesReturned;

    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\recv.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    NDIS send entry points and utility routines to handle receiving
    data.

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001 modified for TunMp driver
    arvindm     4/6/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'VCER'


NTSTATUS
TunRead(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_READ. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   FunctionCode;
    NTSTATUS                NtStatus;
    PTUN_ADAPTER            pAdapter;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pAdapter = pIrpSp->FileObject->FsContext;

    DEBUGP(DL_LOUD, ("==>TunRead, pAdapter %p\n", 
                        pAdapter));
    do
    {
        //
        // Validate!
        //
        if (pAdapter == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL FsContext on FileObject %p\n",
                        pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
            
        TUN_STRUCT_ASSERT(pAdapter, mc);

        if (pIrp->MdlAddress == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL MDL address on IRP %p\n", pIrp));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Try to get a virtual address for the MDL.
        //
        if (MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority) == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: MmGetSystemAddr failed for IRP %p, MDL %p\n",
                    pIrp, pIrp->MdlAddress));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        TUN_ACQUIRE_LOCK(&pAdapter->Lock);

        if (TUN_TEST_FLAGS(pAdapter, TUN_ADAPTER_OFF))
        {
            DEBUGP(DL_WARN, ("TunRead, Adapter off. pAdapter %p\n", 
                                pAdapter));
            
            TUN_RELEASE_LOCK(&pAdapter->Lock);
            NtStatus = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        //
        //  Add this IRP to the list of pended Read IRPs
        //
        TUN_INSERT_TAIL_LIST(&pAdapter->PendedReads, &pIrp->Tail.Overlay.ListEntry);
        TUN_REF_ADAPTER(pAdapter);  // pended read IRP
        pAdapter->PendedReadCount++;

        //
        //  Set up the IRP for possible cancellation.
        //
        pIrp->Tail.Overlay.DriverContext[0] = (PVOID)pAdapter;
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp, TunCancelRead);

        TUN_RELEASE_LOCK(&pAdapter->Lock);

        NtStatus = STATUS_PENDING;

        //
        //  Run the service routine for reads.
        //
        TunServiceReads(pAdapter);

        break;
    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        TUN_ASSERT(NtStatus != STATUS_SUCCESS);
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
    
    DEBUGP(DL_LOUD, ("<==TunRead, pAdapter %p\n", 
                        pAdapter));

    return (NtStatus);
}



VOID
TunCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    )
/*++

Routine Description:

    Cancel a pending read IRP. We unlink the IRP from the open context
    queue and complete it.

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - IRP to be cancelled

Return Value:

    None

--*/
{
    PTUN_ADAPTER                pAdapter;
    PLIST_ENTRY                 pEnt;
    PLIST_ENTRY                 pIrpEntry;
    BOOLEAN                     Found;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    Found = FALSE;
    pAdapter = (PTUN_ADAPTER) pIrp->Tail.Overlay.DriverContext[0];
    
    DEBUGP(DL_LOUD, ("==>TunCancelRead, pAdapter %p\n", 
                        pAdapter));

    
    TUN_STRUCT_ASSERT(pAdapter, mc);

    TUN_ACQUIRE_LOCK(&pAdapter->Lock);

    //
    //  Locate the IRP in the pended read queue and remove it if found.
    //
    for (pIrpEntry = pAdapter->PendedReads.Flink;
         pIrpEntry != &pAdapter->PendedReads;
         pIrpEntry = pIrpEntry->Flink)
    {
        if (pIrp == CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry))
        {
            TUN_REMOVE_ENTRY_LIST(&pIrp->Tail.Overlay.ListEntry);
            pAdapter->PendedReadCount--;
            Found = TRUE;
            break;
        }
    }

    if ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_ACTIVE)) &&
        (pAdapter->PendedSendCount == 0) &&
        (pAdapter->PendedReadCount == 0) &&
        (TUN_TEST_FLAG(pAdapter, TUN_COMPLETE_REQUEST)))
    {
        TUN_CLEAR_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
        TUN_RELEASE_LOCK(&pAdapter->Lock);
        NdisMSetInformationComplete(&pAdapter->MiniportHandle, 
                                    NDIS_STATUS_SUCCESS);
    }
    else
    {
        TUN_RELEASE_LOCK(&pAdapter->Lock);
    }

    if (Found)
    {
        DEBUGP(DL_LOUD, ("CancelRead: Open %p, IRP %p\n", pAdapter, pIrp));
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        TUN_DEREF_ADAPTER(pAdapter); // Cancel removed pended Read
    }

    DEBUGP(DL_LOUD, ("<==TunCancelRead, pAdapter %p\n", 
                    pAdapter));

}
        


VOID
TunServiceReads(
    IN PTUN_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Utility routine to copy received data into user buffers and
    complete READ IRPs.

Arguments:

    pAdapter - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;
    PNDIS_PACKET        pRcvPacket;
    PLIST_ENTRY         pRcvPacketEntry;
    PUCHAR              pSrc, pDst;
    ULONG               BytesRemaining; // at pDst
    PNDIS_BUFFER        pNdisBuffer;
    ULONG               BytesAvailable, BytesCopied;

    DEBUGP(DL_VERY_LOUD, ("==>ServiceReads: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));

    TUN_REF_ADAPTER(pAdapter);
    
    TUN_ACQUIRE_LOCK(&pAdapter->Lock);

    while (!TUN_IS_LIST_EMPTY(&pAdapter->PendedReads) &&
           !TUN_IS_LIST_EMPTY(&pAdapter->RecvPktQueue))
    {
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pAdapter->PendedReads.Flink;
        pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

        //
        //  Check to see if it is being cancelled.
        //
        if (IoSetCancelRoutine(pIrp, NULL))
        {
            //
            //  It isn't being cancelled, and can't be cancelled henceforth.
            //
            RemoveEntryList(pIrpEntry);

            //
            //  NOTE: we decrement PendedReadCount way below in the
            //  while loop, to avoid letting through a thread trying
            //  to unbind.
            //
        }
        else
        {
            //
            //  The IRP is being cancelled; let the cancel routine handle it.
            //
            DEBUGP(DL_LOUD, ("ServiceReads: Adapter %p, skipping cancelled IRP %p\n",
                    pAdapter, pIrp));
            continue;
        }

        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pAdapter->RecvPktQueue.Flink;
        RemoveEntryList(pRcvPacketEntry);

        pAdapter->RecvPktCount--;

        TUN_RELEASE_LOCK(&pAdapter->Lock);

        TUN_DEREF_ADAPTER(pAdapter);  // Service: dequeue rcv packet

        pRcvPacket = TUN_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        //
        //  Copy as much data as possible from the receive packet to
        //  the IRP MDL.
        //

        pDst = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
        TUN_ASSERT(pDst != NULL);  // since it was already mapped
        BytesRemaining = MmGetMdlByteCount(pIrp->MdlAddress);

        pNdisBuffer = pRcvPacket->Private.Head;

        BytesCopied = 0;
        
        while (BytesRemaining > 0 && (pNdisBuffer != NULL))
        {
            NdisQueryBufferSafe(pNdisBuffer, &pSrc, &BytesAvailable, NormalPagePriority);

            if (pSrc == NULL) 
            {
                DEBUGP(DL_FATAL,
                    ("ServiceReads: Adapter %p, QueryBuffer failed for buffer %p\n",
                            pAdapter, pNdisBuffer));
                break;
            }

            if (BytesAvailable)
            {
                ULONG       BytesToCopy = MIN(BytesAvailable, BytesRemaining);

                TUN_COPY_MEM(pDst, pSrc, BytesToCopy);
                BytesCopied += BytesToCopy;
                BytesRemaining -= BytesToCopy;
                pDst += BytesToCopy;
            }

            NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
        }

        //
        //  Complete the IRP.
        //
        //1 shouldn't we fail the read IRP if we couldn't copy the entire data?
        //1  check for pNdisBuffer != NULL
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = MmGetMdlByteCount(pIrp->MdlAddress) - BytesRemaining;

        DEBUGP(DL_LOUD, ("ServiceReads: Adapter %p, IRP %p completed with %d bytes\n",
            pAdapter, pIrp, pIrp->IoStatus.Information));

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        NdisMSendComplete(pAdapter->MiniportHandle,
                          pRcvPacket,
                          NDIS_STATUS_SUCCESS);

        TUN_DEREF_ADAPTER(pAdapter);    // took out pended Read

        TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        pAdapter->PendedReadCount--;        
        pAdapter->SendPackets++;
        pAdapter->SendBytes += BytesCopied;
        

    }

    //1 convert to macro or in-line function
    if ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_ACTIVE)) &&
        (pAdapter->PendedSendCount == 0) &&
        (pAdapter->PendedReadCount == 0) &&
        (TUN_TEST_FLAG(pAdapter, TUN_COMPLETE_REQUEST)))
    {
        TUN_CLEAR_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
        TUN_RELEASE_LOCK(&pAdapter->Lock);
        NdisMSetInformationComplete(&pAdapter->MiniportHandle, 
                                    NDIS_STATUS_SUCCESS);
    }
    else
    {
        TUN_RELEASE_LOCK(&pAdapter->Lock);
    }

    TUN_DEREF_ADAPTER(pAdapter);    // temp ref - service reads

    DEBUGP(DL_VERY_LOUD, ("<==ServiceReads: Adapter %p\n",
        pAdapter));

}
        

VOID
TunCancelPendingReads(
    IN PTUN_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Cancel any pending read IRPs queued on the given open.

Arguments:

    pAdapter - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;

    DEBUGP(DL_LOUD, ("==>TunCancelPendingReads: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));

    
    TUN_REF_ADAPTER(pAdapter);  // temp ref - cancel reads

    TUN_ACQUIRE_LOCK(&pAdapter->Lock);

    while (!TUN_IS_LIST_EMPTY(&pAdapter->PendedReads))
    {
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pAdapter->PendedReads.Flink;
        pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

        //
        //  Check to see if it is being cancelled.
        //
        if (IoSetCancelRoutine(pIrp, NULL))
        {
            //
            //  It isn't being cancelled, and can't be cancelled henceforth.
            //
            TUN_REMOVE_ENTRY_LIST(pIrpEntry);

            TUN_RELEASE_LOCK(&pAdapter->Lock);

            //
            //  Complete the IRP.
            //
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            DEBUGP(DL_LOUD, ("CancelPendingReads: Open %p, IRP %p cancelled\n",
                pAdapter, pIrp));

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);

            TUN_DEREF_ADAPTER(pAdapter);    // took out pended Read for cancelling

            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
            pAdapter->PendedReadCount--;
        }
        else
        {
            //
            //  It is being cancelled, let the cancel routine handle it.
            //
            TUN_RELEASE_LOCK(&pAdapter->Lock);

            //
            //  Give the cancel routine some breathing space, otherwise
            //  we might end up examining the same (cancelled) IRP over
            //  and over again.
            //
            TUN_SLEEP(1);

            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
        }
    }

    if ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_ACTIVE)) &&
        (pAdapter->PendedSendCount == 0) &&
        (pAdapter->PendedReadCount == 0) &&
        (TUN_TEST_FLAG(pAdapter, TUN_COMPLETE_REQUEST)))
    {
        TUN_CLEAR_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
        TUN_RELEASE_LOCK(&pAdapter->Lock);
        NdisMSetInformationComplete(&pAdapter->MiniportHandle, 
                                    NDIS_STATUS_SUCCESS);
    }
    else
    {
        TUN_RELEASE_LOCK(&pAdapter->Lock);
    }

    TUN_DEREF_ADAPTER(pAdapter);    // temp ref - cancel reads
    
    DEBUGP(DL_LOUD, ("<==TunCancelPendingReads: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));


}


VOID
TunFlushReceiveQueue(
    IN PTUN_ADAPTER            pAdapter
    )
/*++

Routine Description:

    Free any receive packets queued up on the specified open

Arguments:

    pAdapter - pointer to open context

Return Value:

    None

--*/
{
    PLIST_ENTRY         pRcvPacketEntry;
    PNDIS_PACKET        pRcvPacket;

    DEBUGP(DL_LOUD, ("==>TunFlushReceiveQueue: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));

    TUN_REF_ADAPTER(pAdapter);  // temp ref - flushRcvQueue

    TUN_ACQUIRE_LOCK(&pAdapter->Lock);
    
    while (!TUN_IS_LIST_EMPTY(&pAdapter->RecvPktQueue))
    {
        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pAdapter->RecvPktQueue.Flink;
        TUN_REMOVE_ENTRY_LIST(pRcvPacketEntry);

        pAdapter->RecvPktCount --;
        pAdapter->XmitError++;
        
        TUN_RELEASE_LOCK(&pAdapter->Lock);

        pRcvPacket = TUN_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        DEBUGP(DL_LOUD, ("FlushReceiveQueue: open %p, pkt %p\n",
            pAdapter, pRcvPacket));

        NdisMSendComplete(pAdapter->MiniportHandle,
                          pRcvPacket,
                          NDIS_STATUS_REQUEST_ABORTED);


        TUN_DEREF_ADAPTER(pAdapter);    // took out pended Read

        TUN_ACQUIRE_LOCK(&pAdapter->Lock);
    }

    TUN_RELEASE_LOCK(&pAdapter->Lock);

    TUN_DEREF_ADAPTER(pAdapter);    // temp ref - flushRcvQueue

    DEBUGP(DL_LOUD, ("<==TunFlushReceiveQueue: Adapter %p/%x\n",
            pAdapter, pAdapter->Flags));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\tunmp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tunmp.h

Abstract:

    Data structures, defines and function prototypes for TUNMP.

Environment:

    Kernel mode only.

Revision History:

    alid     10/22/2001    Created

--*/

#ifndef __TUNMP__H
#define __TUNMP__H


typedef struct _TUN_MEDIA_INFO
{
    ULONG           MaxFrameLen;
    UINT            MacHeaderLen;
    ULONG           LinkSpeed;

} TUN_MEDIA_INFO, *PTUN_MEDIA_INFO;

extern const TUN_MEDIA_INFO MediaParams[];

extern NDIS_HANDLE NdisWrapperHandle;

//internal device name and size
#define DEVICE_NAME                     L"\\Device\\Tun"

//device name visible to users
#define SYMBOLIC_NAME                   L"\\GLOBAL??\\Tun"

extern LONG GlobalDeviceInstanceNumber;

extern NDIS_SPIN_LOCK   TunGlobalLock;
extern LIST_ENTRY       TunAdapterList;

#define TUN_MAX_MULTICAST_ADDRESS       16

#define TUN_MAC_ADDR_LEN                6

#define TUN_MAX_LOOKAHEAD               256


//
//  The Open Context represents an open of our device object.
//  We allocate this on processing a BindAdapter from NDIS,
//  and free it when all references (see below) to it are gone.
//
//  Binding/unbinding to an NDIS device:
//
//  On processing a BindAdapter call from NDIS, we set up a binding
//  to the specified NDIS device (miniport). This binding is
//  torn down when NDIS asks us to Unbind by calling
//  our UnbindAdapter handler.
//
//  Receiving data:
//
//  While an NDIS binding exists, read IRPs are queued on this
//  structure, to be processed when packets are received.
//  If data arrives in the absense of a pended read IRP, we
//  queue it, to the extent of one packet, i.e. we save the
//  contents of the latest packet received. We fail read IRPs
//  received when no NDIS binding exists (or is in the process
//  of being torn down).
//
//  Sending data:
//
//  Write IRPs are used to send data. Each write IRP maps to
//  a single NDIS packet. Packet send-completion is mapped to
//  write IRP completion. We use NDIS 5.1 CancelSend to support
//  write IRP cancellation. Write IRPs that arrive when we don't
//  have an active NDIS binding are failed.
//
//  Reference count:
//
//  The following are long-lived references:
//  OPEN_DEVICE ioctl (goes away on processing a Close IRP)
//  Pended read IRPs
//  Queued received packets
//  Uncompleted write IRPs (outstanding sends)
//  Existence of NDIS binding
//
typedef struct _TUN_ADAPTER
{
    LIST_ENTRY              Link;           // Link into global list
    
    ULONG                   Flags;          // State information
    ULONG                   RefCount;
    TUN_LOCK                Lock;
    NDIS_MEDIUM             Medium;

    PFILE_OBJECT            pFileObject;    // Set on OPEN_DEVICE

    NDIS_HANDLE             MiniportHandle;
    ULONG                   MaxLookAhead;
    ULONG                   PacketFilter;
    
    ULONG                   MediumLinkSpeed;
    ULONG                   MediumMinPacketLen;
    ULONG                   MediumMaxPacketLen;
    UINT                    MediumMacHeaderLen;
    ULONG                   MediumMaxFrameLen;

    UCHAR                   PermanentAddress[TUN_MAC_ADDR_LEN];
    UCHAR                   CurrentAddress[TUN_MAC_ADDR_LEN];

    ULONG                   SendPackets;    // number of frames that are sent
    ULONG                   RcvPackets;     // number of frames that are received
    ULONG                   RcvBytes;
    ULONG                   SendBytes;

    ULONG                   XmitError;
    ULONG                   XmitErrorNoReadIrps;
    ULONG                   RcvError;
    ULONG                   RcvNoBuffer;
    
    NDIS_HANDLE             SendPacketPool;
    ULONG                   MacOptions;

    LIST_ENTRY              PendedWrites;   // pended Write IRPs
    ULONG                   PendedSendCount;// number of outstanding Write IRPs

    LIST_ENTRY              PendedReads;    // pended Read IRPs
    ULONG                   PendedReadCount;// number of outstanding Read IRPs
    
    LIST_ENTRY              RecvPktQueue;   // queued rcv packets
    ULONG                   RecvPktCount;   // number of outstanding NDIS Send requests

    PDEVICE_OBJECT          DeviceObject;
    NDIS_HANDLE             NdisDeviceHandle;
    ULONG                   DeviceInstanceNumber;

    NDIS_DEVICE_POWER_STATE PowerState;
    NDIS_STRING             MiniportName;
    PNDIS_EVENT             HaltEvent;

    ULONG                   mc_sig;         // Signature for sanity

} TUN_ADAPTER, *PTUN_ADAPTER;

#define mc_signature        'nuTN'


#define TUN_SET_FLAG(_M, _F)            ((_M)->Flags |= (_F))
#define TUN_CLEAR_FLAG(_M, _F)          ((_M)->Flags &= ~(_F))
#define TUN_TEST_FLAG(_M, _F)           (((_M)->Flags & (_F)) != 0)
#define TUN_TEST_FLAGS(_M, _F)          (((_M)->Flags & (_F)) == (_F))

//
//  Definitions for Flags above.
//
#define TUN_ADAPTER_ACTIVE          0x00000001  // packet filter is non zero
#define TUN_ADAPTER_OPEN            0x00000002  // app has an open handle
#define TUN_MEDIA_CONNECTED         0x00000004
#define TUN_COMPLETE_REQUEST        0x00000008
#define TUN_ADAPTER_OFF             0x00000010
#define TUN_ADAPTER_CANT_HALT       0x00000020

//
//  Send packet pool bounds
//
#define MIN_SEND_PACKET_POOL_SIZE    20
#define MAX_SEND_PACKET_POOL_SIZE    400

//
//  MiniportReserved in written packets. We save a pointer to the IRP
//  that generated the send.
//
//  The RefCount is used to determine when to free the packet back
//  to its pool. It is used to synchronize between a thread completing
//  a send and a thread attempting to cancel a send.
//
typedef struct _TUN_SEND_PACKET_RSVD
{
    PIRP                    pIrp;
    ULONG                   RefCount;
} TUN_SEND_PACKET_RSVD, *PTUN_SEND_PACKET_RSVD;

//
//  Receive packet pool bounds
//
#define MIN_RECV_PACKET_POOL_SIZE    4
#define MAX_RECV_PACKET_POOL_SIZE    20

//
//  Max receive packets we allow to be queued up
//
//1 check to see if this value is good enough
#define MAX_RECV_QUEUE_SIZE          10

//
//  MiniportReserved in received packets: we link these
//  packets up in a queue waiting for Read IRPs.
//
typedef struct _TUN_RECV_PACKET_RSVD
{
    LIST_ENTRY              Link;
} TUN_RECV_PACKET_RSVD, *PTUN_RECV_PACKET_RSVD;

#define TUN_ALLOC_TAG      'untN'

//
//  Prototypes.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    );

VOID
TunUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
TunOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
TunClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
TunCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
TunIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

VOID
TunMpRefAdapter(
    IN PTUN_ADAPTER         pAdapter
    );

VOID
TunMpDerefAdapter(
    IN PTUN_ADAPTER         pAdapter
    );

#if DBG
VOID
TunMpDbgRefAdapter(
    IN PTUN_ADAPTER                 pAdapter,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );

VOID
TunMpDbgDerefAdapter(
    IN PTUN_ADAPTER                 pAdapter,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );
#endif // DBG



VOID
TunPnPEvent(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    );

VOID
TunWaitForPendingIO(
    IN PTUN_ADAPTER                 pAdapter,
    IN BOOLEAN                      DoCancelReads
    );


PTUN_ADAPTER
TunLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

NDIS_STATUS
TunQueryOidValue(
    IN  PTUN_ADAPTER                pAdapter,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    );

NDIS_STATUS
TunSetOidValue(
    IN  PTUN_ADAPTER                pAdapter,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    );

NTSTATUS
TunRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );


VOID
TunCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
TunServiceReads(
    IN PTUN_ADAPTER        pAdapter
    );


INT
TunReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
TunShutdownBinding(
    IN PTUN_ADAPTER        pAdapter
    );


VOID
TunCancelPendingReads(
    IN PTUN_ADAPTER        pAdapter
    );

VOID
TunFlushReceiveQueue(
    IN PTUN_ADAPTER            pAdapter
    );

NTSTATUS
TunWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

//
// Tun miniport entry points
//
NDIS_STATUS
TunMpInitialize(
    OUT PNDIS_STATUS        OpenErrorStatus,
    OUT PUINT               SelectedMediumIndex,
    IN  PNDIS_MEDIUM        MediumArray,
    IN  UINT                MediumArraySize,
    IN  NDIS_HANDLE         MiniportAdapterHandle,
    IN  NDIS_HANDLE         ConfigurationContext
    );

VOID
TunMpHalt(
    IN  NDIS_HANDLE         MiniportAdapterContext
    );

VOID
TunMpShutdown(
    IN  NDIS_HANDLE     MiniportAdapterContext
    );

NDIS_STATUS
TunMpSetInformation(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_OID            Oid,
    IN  PVOID               InformationBuffer,
    IN  ULONG               InformationBufferLength,
    OUT PULONG              BytesRead,
    OUT PULONG              BytesNeeded
    );

NDIS_STATUS
TunMpQueryInformation(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_OID            Oid,
    IN  PVOID               InformationBuffer,
    IN  ULONG               InformationBufferLength,
    OUT PULONG              BytesWritten,
    OUT PULONG              BytesNeeded
    );

VOID
TunMpReturnPacket(
    IN NDIS_HANDLE          pMiniportAdapterContext,
    IN PNDIS_PACKET         pNdisPacket
    );

VOID
TunMpSendPackets(
    IN    NDIS_HANDLE         MiniportAdapterContext,
    IN    PPNDIS_PACKET       PacketArray,
    IN    UINT                NumberOfPackets
    );

NTSTATUS
TunFOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
TunFClose(
    IN PDEVICE_OBJECT        pDeviceObject,
    IN PIRP                  pIrp
    );

NTSTATUS
TunFCleanup(
    IN PDEVICE_OBJECT        pDeviceObject,
    IN PIRP                  pIrp
    );

NTSTATUS
TunFIoControl(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NDIS_STATUS
TunMpCreateDevice(
    IN  PTUN_ADAPTER    pAdapter
    );

NTSTATUS
CreateDeviceDriverSecurityDescriptor(
    IN  PVOID           DeviceOrDriverObject
    );

NTSTATUS
TunSetSecurity(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
TunCreateSD(
    VOID
    );

VOID
TunDeleteSD(
    VOID
    );

VOID
TunMpUnload(
    IN  PDRIVER_OBJECT      DriverObject
    );

#endif // __TUNMP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\test\tuntest.c ===
//
// UIOTEST.C
//
// Test program for tunmp.sys
//
// usage: UIOTEST [options] <devicename>
//
// options:
//        -e: Enumerate devices
//        -r: Read
//        -w: Write (default)
//        -l <length>: length of each packet (default: %d)\n", PacketLength
//        -n <count>: number of packets (defaults to infinity)
//        -m <MAC address> (defaults to local MAC)
//

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>

#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include "tunuser.h"
#include "nuiouser.h"
#include <ndisguid.h>
#include <wmium.h>

#ifndef NDIS_STATUS
#define NDIS_STATUS     ULONG
#endif

#if DBG
#define DEBUGP(stmt)    printf stmt
#else
#define DEBUGP(stmt)
#endif

#define PRINTF(stmt)    printf stmt

#ifndef MAC_ADDR_LEN
#define MAC_ADDR_LEN                    6
#endif

#define MAX_NDIS_DEVICE_NAME_LEN        256
#define MAX_ADAPTER_NAME_LENGTH         512

#define DEVICE_PREFIX L"\\Device\\"

//DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_ON,       0x5f81cfd0, 0xf046, 0x4342, 0xaf, 0x61, 0x89, 0x5a, 0xce, 0xda, 0xef, 0xd9);
//DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,      0x81bc8189, 0xb026, 0x46ab, 0xb9, 0x64, 0xf1, 0x82, 0xe3, 0x42, 0x93, 0x4e);
//#include <initguid.h>

//DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_ON_X, 0x5f81cfd0, 0xf046, 0x4342, 0xaf, 0x61, 0x89, 0x5a, 0xce, 0xda, 0xef, 0xd9);
//DEFINE_GUID(GUID_NDIS_NOTIFY_DEVICE_POWER_OFF_X, 0x81bc8189, 0xb026, 0x46ab, 0xb9, 0x64, 0xf1, 0x82, 0xe3, 0x42, 0x93, 0x4e);

LPGUID WmiEvent[] = {
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
    (LPGUID) &GUID_NDIS_NOTIFY_DEVICE_POWER_OFF
};


CHAR            NdisuioDevice[] = "\\\\.\\\\Ndisuio";
CHAR *          pNdisuioDevice = &NdisuioDevice[0];

CHAR            TunDevice[] = "\\\\.\\\\Tun0";
CHAR *          pTunDevice = &TunDevice[0];

BOOLEAN         DoEnumerate = FALSE;
BOOLEAN         DoReads = FALSE;
INT             NumberOfPackets = -1;
ULONG           PacketLength = 100;
UCHAR           SrcMacAddr[MAC_ADDR_LEN];
UCHAR           DstMacAddr[MAC_ADDR_LEN];
BOOLEAN         bDstMacSpecified = FALSE;
CHAR *          pNdisDeviceName = "JUNK";
USHORT          EthType = 0x8e88;

HANDLE      UioDeviceHandle, TunDeviceHandle;

BOOLEAN     UioDeviceClosed = FALSE;
BOOLEAN     TunDeviceClosed = FALSE;

VOID CALLBACK
UioIoCompletion(
  DWORD dwErrorCode,                // completion code
  DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
  LPOVERLAPPED lpOverlapped         // I/O information buffer
  );

VOID CALLBACK
TunIoCompletion(
  DWORD dwErrorCode,                // completion code
  DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
  LPOVERLAPPED lpOverlapped         // I/O information buffer
  );
/*
typedef struct _OVERLAPPED { 
    ULONG_PTR  Internal; 
    ULONG_PTR  InternalHigh; 
    DWORD  Offset; 
    DWORD  OffsetHigh; 
    HANDLE hEvent; 
} OVERLAPPED; 

*/


DWORD
__inline
EnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    );

VOID
__inline
DeregisterWmiEventNotification(
    VOID
    );

DWORD
__inline
RegisterWmiEventNotification(
    VOID
    );

VOID
WINAPI
WmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    );

typedef enum _TEST_IO_TYPE
{
    TestIoTypeRead,
    TestIoTypeWrite
} TEST_IO_TYPE;

typedef struct _TEST_IO_COMPLETION
{
    OVERLAPPED      OverLappedIo;
    TEST_IO_TYPE    Type;
    PVOID           Buffer;
} TEST_IO_COMPLETION, *PTEST_IO_COMPLETION;

TEST_IO_COMPLETION UioOverlappedIo[5];
TEST_IO_COMPLETION TunOverlappedIo[5];

PVOID   ReadUioBuffer[5], ReadTunBuffer[5];

#include <pshpack1.h>

typedef struct _ETH_HEADER
{
    UCHAR       DstAddr[MAC_ADDR_LEN];
    UCHAR       SrcAddr[MAC_ADDR_LEN];
    USHORT      EthType;
} ETH_HEADER, *PETH_HEADER;

#include <poppack.h>


VOID
PrintUsage()
{
    PRINTF(("usage: TUNTEST [options] <devicename>\n"));
    PRINTF(("options:\n"));
    PRINTF(("       -e: Enumerate devices\n"));
    PRINTF(("       -r: Read\n"));
    PRINTF(("       -w: Write (default)\n"));
    PRINTF(("       -l <length>: length of each packet (default: %d)\n", PacketLength));
    PRINTF(("       -n <count>: number of packets (defaults to infinity)\n"));
    PRINTF(("       -m <MAC address> (defaults to local MAC)\n"));

}

BOOL
GetOptions(
    INT         argc,
    CHAR        *argv[]
)
{
    BOOL        bOkay;
    INT         i, j, increment;
    CHAR        *pOption;
    ULONG       DstMacAddrUlong[MAC_ADDR_LEN];

    bOkay = TRUE;

    do
    {
        if (argc < 2)
        {
            PRINTF(("Missing <devicename> argument\n"));
            bOkay = FALSE;
            break;
        }

        i = 1;
        while (i < argc)
        {
            increment = 1;
            pOption = argv[i];

            if ((*pOption == '-') || (*pOption == '/'))
            {
                pOption++;
                if (*pOption == '\0')
                {
                    DEBUGP(("Badly formed option\n"));
                    return (FALSE);
                }
            }
            else
            {
                break;
            }

            switch (*pOption)
            {
                case 'e':
                    DoEnumerate = TRUE;
                    break;

                case 'r':
                    DoReads = TRUE;
                    break;

                case 'w':
                    DoReads = FALSE;
                    break;

                case 'l':

                    if (i+1 < argc-1)
                    {
                        sscanf(argv[i+1], "%d", &PacketLength);
                        DEBUGP((" Option: PacketLength = %d\n", PacketLength));
                        increment = 2;
                    }
                    else
                    {
                        PRINTF(("Option l needs PacketLength parameter\n"));
                        return (FALSE);
                    }
                    break;

                case 'n':

                    if (i+1 < argc-1)
                    {
                        sscanf(argv[i+1], "%d", &NumberOfPackets);
                        DEBUGP((" Option: NumberOfPackets = %d\n", NumberOfPackets));
                        increment = 2;
                    }
                    else
                    {
                        PRINTF(("Option n needs NumberOfPackets parameter\n"));
                        return (FALSE);
                    }
                    break;

                case 'm':

                    if (i+1 < argc-1)
                    {
                        sscanf(argv[i+1], "%2x:%2x:%2x:%2x:%2x:%2x",
                                &DstMacAddrUlong[0],
                                &DstMacAddrUlong[1],
                                &DstMacAddrUlong[2],
                                &DstMacAddrUlong[3],
                                &DstMacAddrUlong[4],
                                &DstMacAddrUlong[5]);

                        for (j = 0; j < MAC_ADDR_LEN; j++)
                        {
                            DstMacAddr[j] = (UCHAR)DstMacAddrUlong[j];
                        }

                        DEBUGP((" Option: Dest MAC Addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
                            DstMacAddr[0],
                            DstMacAddr[1],
                            DstMacAddr[2],
                            DstMacAddr[3],
                            DstMacAddr[4],
                            DstMacAddr[5]));
                        bDstMacSpecified = TRUE;

                        increment = 2;
                    }
                    else
                    {
                        PRINTF(("Option m needs MAC address parameter\n"));
                        return (FALSE);
                    }
                    break;
                
                case '?':
                    return (FALSE);

                default:
                    PRINTF(("Unknown option %c\n", *pOption));
                    return (FALSE);
            }

            i+= increment;
        }

        pNdisDeviceName = argv[argc-1];
        break;
    }
    while (FALSE);

    return (bOkay);
}


HANDLE
OpenHandle(
    CHAR    *pDeviceName,
    BOOLEAN  fWaitForBind
)
{
    DWORD   DesiredAccess;
    DWORD   ShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;

    DWORD   CreationDistribution;
    DWORD   FlagsAndAttributes;
    HANDLE  TemplateFile;
    HANDLE  Handle;
    DWORD   BytesReturned;

    DesiredAccess = GENERIC_READ|GENERIC_WRITE;
    ShareMode = 0;
    CreationDistribution = OPEN_EXISTING;
    FlagsAndAttributes = FILE_FLAG_OVERLAPPED;
    TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    Handle = CreateFile(
                pDeviceName,
                DesiredAccess,
                ShareMode,
                lpSecurityAttributes,
                CreationDistribution,
                FlagsAndAttributes,
                TemplateFile
            );

    if ((Handle != INVALID_HANDLE_VALUE) && fWaitForBind)
    {
        //
        //  Wait for the driver to finish binding.
        //
        if (!DeviceIoControl(
                    Handle,
                    IOCTL_NDISUIO_BIND_WAIT,
                    NULL,
                    0,
                    NULL,
                    0,
                    &BytesReturned,
                    NULL))
        {
            DEBUGP(("IOCTL_NDISIO_BIND_WAIT failed, error %x\n", GetLastError()));
            CloseHandle(Handle);
            Handle = INVALID_HANDLE_VALUE;
        }
    }
    
    return (Handle);
}


BOOL
OpenNdisDevice(
    HANDLE  Handle,
    CHAR   *pDeviceName
)
{
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];
    INT     wNameLength;
    INT     NameLength = strlen(pDeviceName);
    DWORD   BytesReturned;
    INT     i;

    //
    // Convert to unicode string - non-localized...
    //
    wNameLength = 0;
    for (i = 0; i < NameLength && i < MAX_NDIS_DEVICE_NAME_LEN-1; i++)
    {
        wNdisDeviceName[i] = (WCHAR)pDeviceName[i];
        wNameLength++;
    }
    wNdisDeviceName[i] = L'\0';

    DEBUGP(("Trying to access NDIS Device: %ws\n", wNdisDeviceName));

    return (DeviceIoControl(
                Handle,
                IOCTL_NDISUIO_OPEN_DEVICE,
                (LPVOID)&wNdisDeviceName[0],
                wNameLength*sizeof(WCHAR),
                NULL,
                0,
                &BytesReturned,
                NULL));

}


BOOL
GetSrcMac(
    HANDLE  Handle,
    PUCHAR  pSrcMacAddr
    )
{
    DWORD       BytesReturned;
    BOOLEAN     bSuccess;
    UCHAR       QueryBuffer[sizeof(NDISUIO_QUERY_OID) + MAC_ADDR_LEN];
    PNDISUIO_QUERY_OID  pQueryOid;

    DEBUGP(("Trying to get src mac address\n"));

    pQueryOid = (PNDISUIO_QUERY_OID)&QueryBuffer[0];
    pQueryOid->Oid = OID_802_3_CURRENT_ADDRESS;

    bSuccess = (BOOLEAN)DeviceIoControl(
                            Handle,
                            IOCTL_NDISUIO_QUERY_OID_VALUE,
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            &BytesReturned,
                            NULL);

    if (bSuccess)
    {
        DEBUGP(("GetSrcMac: IoControl success, BytesReturned = %d\n",
                BytesReturned));

        memcpy(pSrcMacAddr, pQueryOid->Data, MAC_ADDR_LEN);
    }
    else
    {
        DEBUGP(("GetSrcMac: IoControl failed: %d\n", GetLastError()));
    }

    return (bSuccess);
}


BOOL
SetPacketFilter(
    HANDLE  Handle,
    ULONG   FilterValue
    )
{
    BOOLEAN     bSuccess;
    UCHAR       SetBuffer[sizeof(NDISUIO_SET_OID)];
    PNDISUIO_SET_OID  pSetOid;
    DWORD       BytesReturned;

    DEBUGP(("Trying to set packet filter to %x\n", FilterValue));

    pSetOid = (PNDISUIO_SET_OID)&SetBuffer[0];
    pSetOid->Oid = OID_GEN_CURRENT_PACKET_FILTER;
    memcpy(&pSetOid->Data[0], &FilterValue, sizeof(FilterValue));

    bSuccess = (BOOLEAN)DeviceIoControl(
                            Handle,
                            IOCTL_NDISUIO_SET_OID_VALUE,
                            (LPVOID)&SetBuffer[0],
                            sizeof(SetBuffer),
                            (LPVOID)&SetBuffer[0],
                            0,
                            &BytesReturned,
                            NULL);

    if (bSuccess)
    {
        DEBUGP(("SetPacketFilter: IoControl success\n"));

    }
    else
    {
        DEBUGP(("SetPacketFilter: IoControl failed %x\n", GetLastError()));
    }

    return (bSuccess);
}

VOID
EnumerateDevices(
    HANDLE  Handle
    )
{
    CHAR        Buf[1024];
    DWORD       BufLength = sizeof(Buf);
    DWORD       BytesWritten;
    DWORD       i;
    PNDISUIO_QUERY_BINDING pQueryBinding;

    pQueryBinding = (PNDISUIO_QUERY_BINDING)Buf;

    i = 0;
    for (pQueryBinding->BindingIndex = i;
         /* NOTHING */;
         pQueryBinding->BindingIndex = ++i)
    {
        if (DeviceIoControl(
                Handle,
                IOCTL_NDISUIO_QUERY_BINDING,
                pQueryBinding,
                sizeof(NDISUIO_QUERY_BINDING),
                Buf,
                BufLength,
                &BytesWritten,
                NULL))
        {
            PRINTF(("%2d. %ws\n     - %ws\n",
                pQueryBinding->BindingIndex,
                (PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset,
                (PUCHAR)pQueryBinding + pQueryBinding->DeviceDescrOffset));

            memset(Buf, 0, BufLength);
        }
        else
        {
            ULONG   rc = GetLastError();
            if (rc != ERROR_NO_MORE_ITEMS)
            {
                PRINTF(("EnumerateDevices: terminated abnormally, error %d\n", rc));
            }
            break;
        }
    }
}




VOID __cdecl
main(
    INT         argc,
    CHAR        *argv[]
)
{
    ULONG       FilterValue;
    UINT        i;
    DWORD       BytesWritten, BytesRead;
    DWORD       ErrorCode;
    BOOLEAN     bSuccess;

    //
    // test wmi
    //
    {
        if ((ErrorCode = RegisterWmiEventNotification()) != NO_ERROR)
        {
            printf("error %d calling RegisterWmiEventNotification.\n", ErrorCode);
            return;
        }
        while (_fgetchar() != 'q')
        {
            Sleep(1000);
        }
        DeregisterWmiEventNotification();

        return;
    }
    
    UioDeviceHandle = TunDeviceHandle = INVALID_HANDLE_VALUE;

    do
    {
        for (i = 0; i < 5; i++)
        {
            ReadUioBuffer[i] = ReadTunBuffer[i] = NULL;
        }

        if (!GetOptions(argc, argv))
        {
            PrintUsage();
            break;
        }
        

        UioDeviceHandle = OpenHandle(pNdisuioDevice, TRUE);
        if (UioDeviceHandle == INVALID_HANDLE_VALUE)
        {
            PRINTF(("Failed to open %s\n", pNdisuioDevice));
            break;
        }

        if (DoEnumerate)
        {
            EnumerateDevices(UioDeviceHandle);
            break;
        }
        
        TunDeviceHandle = OpenHandle(TunDevice, FALSE);
        if (TunDeviceHandle == INVALID_HANDLE_VALUE)
        {
            PRINTF(("Failed to open %s\n", pTunDevice));
            break;
        }

        {
            WCHAR   wTunMiniportName[MAX_NDIS_DEVICE_NAME_LEN];
            UCHAR   MiniportName[MAX_NDIS_DEVICE_NAME_LEN];
            INT     wNameLength;
            DWORD   BytesReturned;

            memset((LPVOID)wTunMiniportName, 0, MAX_NDIS_DEVICE_NAME_LEN);
            
            if (DeviceIoControl(
                        TunDeviceHandle,
                        IOCTL_TUN_GET_MINIPORT_NAME,
                        NULL,
                        0,
                        (LPVOID)&wTunMiniportName[0],
                        MAX_NDIS_DEVICE_NAME_LEN,
                        &BytesReturned,
                        NULL))
            {
                
                printf("Tun Miniport Name: %ws\n", (PUCHAR)wTunMiniportName + sizeof(USHORT));
/*                
                NameLength = *(PUSHORT)wTunMiniportName;
                for (i = 0; i < NameLength && i < MAX_NDIS_DEVICE_NAME_LEN-1; i++)
                {
                    wNdisDeviceName[i] = (WCHAR)pDeviceName[i];
                    wNameLength++;
                }
                wNdisDeviceName[i] = L'\0';
*/
            }
            else
            {
                printf("failed to get the miniport name.\n");
            }

        }
            
        if (!OpenNdisDevice(UioDeviceHandle, pNdisDeviceName))
        {
            PRINTF(("Failed to access %s\n", pNdisDeviceName));
            break;
        }

        DEBUGP(("Opened device %s successfully!\n", pNdisDeviceName));

        if (!GetSrcMac(UioDeviceHandle, SrcMacAddr))
        {
            PRINTF(("Failed to obtain local MAC address\n"));
            break;
        }


        FilterValue = NDIS_PACKET_TYPE_DIRECTED |
                      NDIS_PACKET_TYPE_BROADCAST |
                      NDIS_PACKET_TYPE_ALL_MULTICAST;

        DEBUGP(("Got local MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
                    SrcMacAddr[0],
                    SrcMacAddr[1],
                    SrcMacAddr[2],
                    SrcMacAddr[3],
                    SrcMacAddr[4],
                    SrcMacAddr[5]));

        if (!bDstMacSpecified)
        {
            memcpy(DstMacAddr, SrcMacAddr, MAC_ADDR_LEN);
        }

        if (!SetPacketFilter(UioDeviceHandle, FilterValue))
        {
            PRINTF(("Failed to set packet filter\n"));
            break;
        }

        for (i = 0; i < 5; i++)
        {
            if ((ReadUioBuffer[i] = malloc(1512)) == NULL)
            {
                PRINTF(("Failed to allocate memory for reading Uio device.\n"));
                break;
            }

            memset((PUCHAR)&UioOverlappedIo[i], 0, sizeof (TEST_IO_COMPLETION));
            UioOverlappedIo[i].Buffer = ReadUioBuffer[i];
            UioOverlappedIo[i].Type = TestIoTypeRead;
                
            if ((ReadTunBuffer[i] = malloc(1512)) == NULL)
            {
                PRINTF(("Failed to allocate memory for reading Tun device.\n"));
                break;
            }
            memset((PUCHAR)&TunOverlappedIo[i], 0, sizeof (TEST_IO_COMPLETION));
            TunOverlappedIo[i].Buffer = ReadTunBuffer[i];
            TunOverlappedIo[i].Type = TestIoTypeRead;
        }

        if (i < 5)
        {
            break;            
        }


        if (!BindIoCompletionCallback(
                    UioDeviceHandle,
                    UioIoCompletion,
                    0))
        {
            break;
        }

        if (!BindIoCompletionCallback(
                    TunDeviceHandle,
                    TunIoCompletion,
                    0))
        {
            break;
        }

                                  
        for (i = 0; i < 5; i++)
        {
            //
            // post reads from ndis uio
            //
            bSuccess = (BOOLEAN)ReadFile(
                                    UioDeviceHandle,
                                    (LPVOID)UioOverlappedIo[i].Buffer,
                                    1500,
                                    &BytesRead,
                                    &UioOverlappedIo[i].OverLappedIo);
            
            bSuccess = (BOOLEAN)ReadFile(
                                    TunDeviceHandle,
                                    (LPVOID)TunOverlappedIo[i].Buffer,
                                    1500,
                                    &BytesRead,
                                    &TunOverlappedIo[i].OverLappedIo);
        }


    }
    while (FALSE);

    while (_fgetchar() != 'q')
    {
        Sleep(1000);
    }

    if (UioDeviceHandle != INVALID_HANDLE_VALUE)
    {
        CancelIo(UioDeviceHandle);
        UioDeviceClosed = TRUE;
        Sleep(1000);
        CloseHandle(UioDeviceHandle);
    }
    
    if (TunDeviceHandle != INVALID_HANDLE_VALUE)
    {
        
        CancelIo(TunDeviceHandle);
        TunDeviceClosed = TRUE;
        Sleep(1000);
        CloseHandle(TunDeviceHandle);
    }

    for (i = 0; i < 5; i++)
    {
        if (ReadTunBuffer[i])
            free(ReadTunBuffer[i]);
        
        if (ReadUioBuffer[i])
            free(ReadUioBuffer[i]);
    }

}

VOID CALLBACK
UioIoCompletion(
  DWORD dwErrorCode,                // completion code
  DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
  LPOVERLAPPED lpOverlapped         // I/O information buffer
  )
{
    PTEST_IO_COMPLETION pTestIoComp = (PTEST_IO_COMPLETION)lpOverlapped;
    DWORD       BytesWritten, BytesRead;
    BOOLEAN     bSuccess;

    if (UioDeviceClosed || TunDeviceClosed)
        return;
    //
    // determine if this was a read or write
    //
    if (pTestIoComp->Type == TestIoTypeRead)
    {

        if (dwErrorCode == 0)
        {
            //
            // a read to uio device got completed. post a write to
            // Tun device with the same data.
            // 

            pTestIoComp->Type = TestIoTypeWrite;

            bSuccess = (BOOLEAN)WriteFile(
                        TunDeviceHandle,
                        pTestIoComp->Buffer,
                        dwNumberOfBytesTransfered,
                        &BytesWritten,
                        lpOverlapped);

        }
        else
        {
            //
            // post another read
            //
            bSuccess = (BOOLEAN)ReadFile(
                                    UioDeviceHandle,
                                    (LPVOID)pTestIoComp->Buffer,
                                    1500,
                                    &BytesRead,
                                    lpOverlapped);

            
        }
    }
    else
    {
        //
        // a write to uio device just got completed.
        // post a read to Tun device.
        //
        pTestIoComp->Type = TestIoTypeRead;
        
        bSuccess = (BOOLEAN)ReadFile(
                                TunDeviceHandle,
                                (LPVOID)pTestIoComp->Buffer,
                                1500,
                                &BytesRead,
                                lpOverlapped);
    }
}

VOID CALLBACK
TunIoCompletion(
  DWORD dwErrorCode,                // completion code
  DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
  LPOVERLAPPED lpOverlapped         // I/O information buffer
  )
{
    PTEST_IO_COMPLETION pTestIoComp = (PTEST_IO_COMPLETION)lpOverlapped;
    DWORD       BytesWritten, BytesRead;
    BOOLEAN     bSuccess;

    if (UioDeviceClosed || TunDeviceClosed)
        return;

    //
    // determine if this was a read or write
    //
    if (pTestIoComp->Type == TestIoTypeRead)
    {

        if (dwErrorCode == 0)
        {
            //
            // a read to Tun device got completed. post a write to
            // uio device with the same data.
            // 

            pTestIoComp->Type = TestIoTypeWrite;

            bSuccess = (BOOLEAN)WriteFile(
                        UioDeviceHandle,
                        pTestIoComp->Buffer,
                        dwNumberOfBytesTransfered,
                        &BytesWritten,
                        lpOverlapped);

        }
        else
        {
            //
            // post another read
            //
            bSuccess = (BOOLEAN)ReadFile(
                                    TunDeviceHandle,
                                    (LPVOID)pTestIoComp->Buffer,
                                    1500,
                                    &BytesRead,
                                    lpOverlapped);

            
        }
    }
    else
    {
        //
        // a write to Tun device just got completed.
        // post a read to Uio device.
        //
        pTestIoComp->Type = TestIoTypeRead;
        
        bSuccess = (BOOLEAN)ReadFile(
                                UioDeviceHandle,
                                (LPVOID)pTestIoComp->Buffer,
                                1500,
                                &BytesRead,
                                lpOverlapped);
    }


}


DWORD
__inline
EnableWmiEvent(
    IN LPGUID EventGuid,
    IN BOOLEAN Enable
    )
{
    return WmiNotificationRegistrationW(
        EventGuid,                      // Event Type.
        Enable,                         // Enable or Disable.
        WmiEventNotification,           // Callback.
        0,                              // Context.
        NOTIFICATION_CALLBACK_DIRECT);  // Notification Flags.
}


VOID
__inline
DeregisterWmiEventNotification(
    VOID
    )
{
    int i;
    
    for (i = 0; i < (sizeof(WmiEvent) / sizeof(LPGUID)); i++) {
        (VOID) EnableWmiEvent(WmiEvent[i], FALSE);
    }
}


DWORD
__inline
RegisterWmiEventNotification(
    VOID
    )
{
    DWORD Error;
    int i;
    
    for (i = 0; i < (sizeof(WmiEvent) / sizeof(LPGUID)); i++) {
        Error = EnableWmiEvent(WmiEvent[i], TRUE);
        if (Error != NO_ERROR) {
            goto Bail;
        }
    }

    return NO_ERROR;

Bail:
    DeregisterWmiEventNotification();
    return Error;
}


VOID
WINAPI
WmiEventNotification(
    IN PWNODE_HEADER Event,
    IN UINT_PTR Context
    )
/*++

Routine Description:

    Process a WMI event (specifically adapter arrival or removal).
    
Arguments:

    Event - Supplies event specific information.

    Context - Supplies the context registered.
    
Return Value:

    None.
    
--*/ 
{
    PWNODE_SINGLE_INSTANCE Instance = (PWNODE_SINGLE_INSTANCE) Event;
    USHORT AdapterNameLength;
    WCHAR AdapterName[MAX_ADAPTER_NAME_LENGTH], *AdapterGuid;
    USHORT AdapterInstanceNameLength;
    WCHAR AdapterInstanceName[MAX_ADAPTER_NAME_LENGTH];

    if (Instance == NULL) {
        return;
    }
    
    //
    // WNODE_SINGLE_INSTANCE is organized thus...
    // +-----------------------------------------------------------+
    // |<--- DataBlockOffset --->| AdapterNameLength | AdapterName |
    // +-----------------------------------------------------------+
    //
    // AdapterName is defined as "\DEVICE\"AdapterGuid
    //
    AdapterNameLength =
        *((PUSHORT) (((PUCHAR) Instance) + Instance->DataBlockOffset));
    RtlCopyMemory(
        AdapterName,
        ((PUCHAR) Instance) + Instance->DataBlockOffset + sizeof(USHORT),
        AdapterNameLength);
    AdapterName[AdapterNameLength / sizeof(WCHAR)] = L'\0';
    AdapterGuid = AdapterName + wcslen(DEVICE_PREFIX);        


    AdapterInstanceNameLength =
        *((PUSHORT) (((PUCHAR) Instance) + Instance->OffsetInstanceName));
    RtlCopyMemory(
        AdapterInstanceName,
        ((PUCHAR) Instance) + Instance->OffsetInstanceName + sizeof(USHORT),
        AdapterInstanceNameLength);
    if (AdapterInstanceNameLength < MAX_ADAPTER_NAME_LENGTH - 1)
    {
        AdapterInstanceName[AdapterInstanceNameLength / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        AdapterInstanceName[MAX_ADAPTER_NAME_LENGTH - 1] = L'\0';
    }

    if (memcmp(
        &(Event->Guid),
        &GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
        sizeof(GUID)) == 0) {
        //
        // Adapter arrival.
        //
        printf("adapter arrival. %ws\n", AdapterGuid);
        
    }

    if (memcmp(
        &(Event->Guid),
        &GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
        sizeof(GUID)) == 0) {
        //
        // Adapter removal.
        //
        printf("adapter removal. %ws\n", AdapterGuid);
    }
    
    if (memcmp(
        &(Event->Guid),
        (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON,
        sizeof(GUID)) == 0) {
        //
        // Adapter powered on
        //
        printf("adapter powered on. %ws\n", AdapterInstanceName );
    }
    
    if (memcmp(
        &(Event->Guid),
        (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
        sizeof(GUID)) == 0) {
        //
        // Adapter powered off
        //
        printf("adapter powered off. %ws\n", AdapterInstanceName );
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\tunmp.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tunmp.c

Abstract:
    Microsoft Tunnel interface Miniport driver

Environment:

    Kernel mode only.

Revision History:

    alid        10/22/2001 

--*/

#include "precomp.h"

#define __FILENUMBER 'MUNT'


NTSTATUS
DriverEntry(
    IN    PDRIVER_OBJECT         DriverObject,
    IN    PUNICODE_STRING        RegistryPath
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NDIS_STATUS                        Status;
    NDIS_MINIPORT_CHARACTERISTICS      MChars;
    NDIS_STRING                        Name;

    DEBUGP(DL_INFO, ("Tunmp: ==>DriverEntry\n"));


    //
    // Register the miniport with NDIS.
    //
    NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, NULL);

    if (NdisWrapperHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;
        return Status;
    }    
    
    TUN_INIT_LOCK(&TunGlobalLock);
    TUN_INIT_LIST_HEAD(&TunAdapterList);


    TUN_ZERO_MEM(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    MChars.MajorNdisVersion         = NDIS_MINIPORT_MAJOR_VERSION;
    MChars.MinorNdisVersion         = NDIS_MINIPORT_MINOR_VERSION;

    MChars.InitializeHandler        = TunMpInitialize;
    MChars.QueryInformationHandler  = TunMpQueryInformation;
    MChars.SetInformationHandler    = TunMpSetInformation;
    MChars.ResetHandler             = NULL;
    MChars.ReturnPacketHandler      = TunMpReturnPacket;
    MChars.SendPacketsHandler       = TunMpSendPackets;
    MChars.HaltHandler              = TunMpHalt;
    MChars.CheckForHangHandler      = NULL;

    MChars.CancelSendPacketsHandler = NULL;
    MChars.PnPEventNotifyHandler    = NULL;
    MChars.AdapterShutdownHandler   = TunMpShutdown;

    Status = NdisMRegisterMiniport(NdisWrapperHandle,
                                   &MChars,
                                   sizeof(MChars));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMRegisterUnloadHandler(NdisWrapperHandle, TunMpUnload);
        Status = TunCreateSD();
    }

    if(Status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }

    
    DEBUGP(DL_INFO, ("Tunmp: <==DriverEntry Status %lx\n", Status));

    return(Status);
}

VOID
TunMpUnload(
    IN  PDRIVER_OBJECT      DriverObject
    )
{
    TunDeleteSD();
    return;
}

NDIS_STATUS
TunMpInitialize(
    OUT PNDIS_STATUS        OpenErrorStatus,
    OUT PUINT               SelectedMediumIndex,
    IN  PNDIS_MEDIUM        MediumArray,
    IN  UINT                MediumArraySize,
    IN  NDIS_HANDLE         MiniportAdapterHandle,
    IN  NDIS_HANDLE         ConfigurationContext
    )

/*++

Routine Description:

    This is the initialize handler.

Arguments:

    OpenErrorStatus                Not used by us.
    SelectedMediumIndex            Place-holder for what media we are using
    MediumArray                    Array of ndis media passed down to us to pick from
    MediumArraySize                Size of the array
    MiniportAdapterHandle          The handle NDIS uses to refer to us
    WrapperConfigurationContext    For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/

{
    UINT                            i, Length;
    PTUN_ADAPTER                    pAdapter = NULL;
    NDIS_MEDIUM                     AdapterMedium;
    NDIS_HANDLE                     ConfigHandle = NULL;
    PNDIS_CONFIGURATION_PARAMETER   Parameter;
    PUCHAR                          NetworkAddress;
    NDIS_STATUS                     Status;
    NDIS_STRING                     MiniportNameStr = NDIS_STRING_CONST("MiniportName");


    DEBUGP(DL_INFO, ("==>TunMpInitialize: MiniportAdapterHandle %p\n", MiniportAdapterHandle));

    do
    {
                
        TUN_ALLOC_MEM(pAdapter, sizeof(TUN_ADAPTER));

        if (pAdapter == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        TUN_ZERO_MEM(pAdapter, sizeof(TUN_ADAPTER));
        TUN_SET_SIGNATURE(pAdapter, mc);

        pAdapter->MiniportHandle = MiniportAdapterHandle;

        //1 no need to specify NDIS_ATTRIBUTE_IGNORE...
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pAdapter,
                             0,
                             NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS |
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                             NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                             NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                             NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK |
                             NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS |
                             NDIS_ATTRIBUTE_DESERIALIZE,
                             0);

        NdisOpenConfiguration(&Status,
                              &ConfigHandle,
                              ConfigurationContext);
    
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_ERROR, ("TunMpInitialize: NdisOpenConfiguration failed. Status %lx\n", Status));            
            break;
        }

        AdapterMedium = NdisMedium802_3;    // Default

        TUN_COPY_MEM(pAdapter->PermanentAddress,
                       TUN_CARD_ADDRESS,
                       TUN_MAC_ADDR_LEN);

        TUN_COPY_MEM(pAdapter->CurrentAddress,
                       TUN_CARD_ADDRESS,
                       TUN_MAC_ADDR_LEN);
    
        pAdapter->Medium                = AdapterMedium;
        pAdapter->MediumLinkSpeed       = MediaParams[(UINT)AdapterMedium].LinkSpeed;
        pAdapter->MediumMinPacketLen    = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
        pAdapter->MediumMaxPacketLen    = MediaParams[(UINT)AdapterMedium].MacHeaderLen+
                                          MediaParams[(UINT)AdapterMedium].MaxFrameLen;
        pAdapter->MediumMacHeaderLen    = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
        pAdapter->MediumMaxFrameLen     = MediaParams[(UINT)AdapterMedium].MaxFrameLen;
        
        pAdapter->MaxLookAhead          = MediaParams[(UINT)AdapterMedium].MaxFrameLen;
        
        //Get the software-configurable network address that was stored in the
        //registry when the adapter was installed in the machine.
        NdisReadNetworkAddress(&Status,
                               &NetworkAddress,
                               &Length,
                               ConfigHandle);


        if (Status == NDIS_STATUS_SUCCESS)
        {
#if TUN_ALLOW_ANY_MAC_ADDRESS        
            if ((Length == ETH_LENGTH_OF_ADDRESS) &&
                (!ETH_IS_MULTICAST(NetworkAddress)))

#else
            if ((Length == ETH_LENGTH_OF_ADDRESS) &&
                (!ETH_IS_MULTICAST(NetworkAddress)) &&
                (NetworkAddress[0] & 0x02))
#endif
            {
                TUN_COPY_MEM(pAdapter->CurrentAddress,
                               NetworkAddress,
                               Length);
            }
        }

        //
        // read the miniport name
        //
        //1 make sure miniport name is really used
        NdisReadConfiguration(&Status, 
                              &Parameter, 
                              ConfigHandle, 
                              &MiniportNameStr, 
                              NdisParameterString);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            TUN_ALLOC_MEM(pAdapter->MiniportName.Buffer, 
                          Parameter->ParameterData.StringData.Length);
            
            if (pAdapter->MiniportName.Buffer == NULL)
            {
                DEBUGP(DL_ERROR, ("TunMpInitialize: failed to allocate memory for miniport name.\n"));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            
            pAdapter->MiniportName.Length = pAdapter->MiniportName.MaximumLength = 
                                                Parameter->ParameterData.StringData.Length;

            TUN_COPY_MEM(pAdapter->MiniportName.Buffer, 
                         Parameter->ParameterData.StringData.Buffer,
                         Parameter->ParameterData.StringData.Length);
            
        }
        else
        {
            DEBUGP(DL_ERROR, ("TunMpInitialize: NdisReadConfiguration failed to read miniport name. Status %lx\n", Status));            
            break;
        }

        NdisCloseConfiguration(ConfigHandle);
        ConfigHandle = NULL;

        //
        //Make sure the medium saved is one of the ones being offered
        //
        for (i = 0; i < MediumArraySize; i++)
        {
            if (MediumArray[i] == AdapterMedium)
            {
                *SelectedMediumIndex = i;
                break;
            }
        }
    
        if (i == MediumArraySize)
        {
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            DEBUGP(DL_ERROR, ("TunMpInitialize: Status %lx, AdapterMedium %lx\n", 
                                Status, AdapterMedium));
            break;
        }

        Status = TunMpCreateDevice(pAdapter);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_ERROR, ("TunMpInitialize: TunMpCreateDevice failed. Status %lx\n", 
                                Status));
            break;
        }
        
        pAdapter->RefCount = 1;
        
        //Initialize the adapter spin lock
        TUN_INIT_LOCK(&pAdapter->Lock);

        //
        //Get the list heads for the pended read/write IRPS and received
        //packets (from the NDIS) initialized
        //
        InitializeListHead(&pAdapter->PendedReads);  //read IRPs
        InitializeListHead(&pAdapter->PendedWrites); //writes IRPs
        InitializeListHead(&pAdapter->RecvPktQueue); //received packets


        NdisAllocatePacketPoolEx(&Status,
                                 &pAdapter->SendPacketPool,
                                 MIN_SEND_PACKET_POOL_SIZE,
                                 MAX_SEND_PACKET_POOL_SIZE
                                 - MIN_SEND_PACKET_POOL_SIZE,
                                 4 * sizeof(PVOID)
                                 );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_ERROR, ("TunMpInitialize: NdisAllocatePacketPoolEx for Send failed. Status %lx\n", 
                               Status));
            break;
        }

        //
        //Get the adapter listed in the tun global list of adapters
        //
        TUN_ACQUIRE_LOCK(&TunGlobalLock); 

        TUN_INSERT_HEAD_LIST(&TunAdapterList, &pAdapter->Link);
        
        TUN_RELEASE_LOCK(&TunGlobalLock);

    } while (FALSE);


    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pAdapter != NULL)
        {

            if (ConfigHandle)
            {
                NdisCloseConfiguration(ConfigHandle);
            }
            
            if (pAdapter->NdisDeviceHandle)
            {
                NdisMDeregisterDevice(pAdapter->NdisDeviceHandle);
            }
            
            if (pAdapter->SendPacketPool)
            {
                NdisFreePacketPool(pAdapter->SendPacketPool);
            }

            TUN_FREE_MEM(pAdapter);
        }
    }
    
    DEBUGP(DL_INFO, ("<==TunMpInitialize: MiniportAdapterHandle %p, Status\n", 
                     MiniportAdapterHandle, Status));
    
    return Status;
}


NDIS_STATUS
TunMpCreateDevice(
    IN  PTUN_ADAPTER    pAdapter
    )
{
    LONG                DeviceInstanceNumber;
    UNICODE_STRING      usDeviceID;
    WCHAR               TempBuffer[4] = {0};
    WCHAR               DeviceNameBuffer[sizeof(DEVICE_NAME)+4] = {0};
    WCHAR               SymbolicNameBuffer[sizeof(SYMBOLIC_NAME)+4] = {0};
    UNICODE_STRING      DeviceName, SymbolicName;
    PDRIVER_DISPATCH    MajorFunctions[IRP_MJ_MAXIMUM_FUNCTION+1];
    NTSTATUS            NtStatus;
    NDIS_STATUS         Status;
    UINT                i;
    PDEVICE_OBJECT      DeviceObject = NULL;
    NDIS_HANDLE         NdisDeviceHandle = NULL;

    DEBUGP(DL_INFO, ("==>TunMpCreateDevice, pAdapter %p\n", pAdapter));
    
    do
    {
    
        DeviceInstanceNumber = InterlockedIncrement(&GlobalDeviceInstanceNumber);
        //
        // for the time being, allow one device only
        //
        
        if (DeviceInstanceNumber > 0)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pAdapter->DeviceInstanceNumber = (ULONG)DeviceInstanceNumber;
        
        //
        //Initiallize a unicode string
        //
        usDeviceID.Buffer = TempBuffer;
        usDeviceID.Length = 0;
        usDeviceID.MaximumLength = sizeof(TempBuffer);


        NtStatus = RtlIntegerToUnicodeString ((ULONG)DeviceInstanceNumber, 10, &usDeviceID);

        if (!NT_SUCCESS(NtStatus))
        {
            //1 GlobalDeviceInstanceNumber is not protected properly
            InterlockedDecrement(&GlobalDeviceInstanceNumber);
            Status = NDIS_STATUS_RESOURCES;
            DEBUGP(DL_ERROR, ("TunMpCreateDevice: RtlIntegerToUnicodeString failed. NtStatus %lx\n", 
                             NtStatus));
            break;
        }


        wcscpy(DeviceNameBuffer, DEVICE_NAME);
        RtlInitUnicodeString(&DeviceName, DeviceNameBuffer);
        RtlAppendUnicodeStringToString(&DeviceName, &usDeviceID);


        wcscpy(SymbolicNameBuffer, SYMBOLIC_NAME);
        RtlInitUnicodeString(&SymbolicName, SymbolicNameBuffer);
        RtlAppendUnicodeStringToString(&SymbolicName, &usDeviceID);

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            MajorFunctions[i] = NULL;
        }

        MajorFunctions[IRP_MJ_CREATE]         = TunFOpen;
        MajorFunctions[IRP_MJ_CLOSE]          = TunFClose;
        MajorFunctions[IRP_MJ_READ]           = TunRead;
        MajorFunctions[IRP_MJ_WRITE]          = TunWrite;
        MajorFunctions[IRP_MJ_CLEANUP]        = TunFCleanup;
        MajorFunctions[IRP_MJ_DEVICE_CONTROL] = TunFIoControl;

        
        Status = NdisMRegisterDevice(
                                NdisWrapperHandle,
                                &DeviceName,
                                &SymbolicName,
                                MajorFunctions,
                                &DeviceObject,
                                &NdisDeviceHandle
                                );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_ERROR, ("TunMpCreateDevice: NdisMRegisterDevice failed. Status %lx\n", 
                             Status));
            
            InterlockedDecrement(&GlobalDeviceInstanceNumber);
            break;
        }

        DeviceObject->Flags |= DO_DIRECT_IO;
        pAdapter->DeviceObject = DeviceObject;
        pAdapter->NdisDeviceHandle = NdisDeviceHandle;


        Status = TunSetSecurity(DeviceObject);

        if (!NT_SUCCESS(Status))
        {
            NdisMDeregisterDevice(NdisDeviceHandle);
            pAdapter->NdisDeviceHandle = NULL;
        }

    }while (FALSE);

    DEBUGP(DL_INFO, ("<==TunMpCreateDevice, pAdapter %p, Status %lx\n", pAdapter, Status));

    return Status;
    
}



VOID
TunMpHalt(
    IN  NDIS_HANDLE     MiniportAdapterContext
    )

/*++

Routine Description:

    Halt handler. It frees the adapter object and corresponding device object.

Arguments:

    MiniportAdapterContext    Pointer to the Adapter

Return Value:

    None.

--*/

{
    PTUN_ADAPTER    pAdapter = (PTUN_ADAPTER)MiniportAdapterContext;
    NDIS_EVENT      HaltReadyEvent;

    DEBUGP(DL_INFO, ("==>TunMpHalt, pAdapter %p\n", pAdapter));

    NdisInitializeEvent(&HaltReadyEvent);
    //
    // let's wait for the app to close all the handles
    //
    TUN_ACQUIRE_LOCK(&pAdapter->Lock);
    if (TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_CANT_HALT))
    {
        pAdapter->HaltEvent = &HaltReadyEvent;
    }
    TUN_RELEASE_LOCK(&pAdapter->Lock);

    if (pAdapter->HaltEvent)
    {
        NdisWaitEvent(pAdapter->HaltEvent, 0);
    }
    pAdapter->HaltEvent = 0;

    //
    // we should not have any pending NDIS sends
    //
    ASSERT(pAdapter->PendedReadCount == 0);

    //
    // Free the resources now
    //

    if (pAdapter->NdisDeviceHandle)
    {
        NdisMDeregisterDevice(pAdapter->NdisDeviceHandle);
    }
    
    InterlockedDecrement(&GlobalDeviceInstanceNumber);

    if (pAdapter->SendPacketPool)
    {
        NdisFreePacketPool(pAdapter->SendPacketPool);
    }

    //
    // remove it from the global queue
    //

    TUN_ACQUIRE_LOCK(&TunGlobalLock); 
    TUN_REMOVE_ENTRY_LIST(&pAdapter->Link);
    TUN_RELEASE_LOCK(&TunGlobalLock);
    
    TUN_FREE_MEM(pAdapter);

    DEBUGP(DL_INFO, ("<==TunMpHalt, pAdapter %p\n", pAdapter));

 }

VOID
TunMpShutdown(
    IN  NDIS_HANDLE     MiniportAdapterContext
    )
{
    DEBUGP(DL_INFO, ("==>TunMpShutdown, pAdapter %p\n", MiniportAdapterContext));
    //
    // nothing to do here
    //
    DEBUGP(DL_INFO, ("<==TunMpShutdown, pAdapter %p\n", MiniportAdapterContext));
}
    


VOID
TunMpSendPackets(
    IN    NDIS_HANDLE         MiniportAdapterContext,
    IN    PPNDIS_PACKET       PacketArray,
    IN    UINT                NumberOfPackets
    )

/*++

Routine Description:

    Send packets handler. Just queues packets in the list of pended received packets.
    And then calls TunServiceReads to process packets.

Arguments:

    MiniportAdapterContext   Pointer to the adapter
    Packet                   Packet to send
    Flags                    Unused, passed down below

Return Value:

    Return code from NdisSend

--*/

{
    PTUN_ADAPTER    pAdapter = (PTUN_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS     NdisStatus;
    UINT            Index;
    UINT            BytesToSend;
    PLIST_ENTRY     pRcvPacketEntry;
    PNDIS_PACKET    pOldRcvPacket;

    DEBUGP(DL_LOUD, ("==>TunMpSendPackets, pAdapter %p, PacketArray %p, NumberOfPackets\n", 
                        MiniportAdapterContext, PacketArray, NumberOfPackets));

    TUN_REF_ADAPTER(pAdapter);    // queued rcv packet
    TUN_ACQUIRE_LOCK(&pAdapter->Lock);

    if ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OPEN)) ||
        TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OFF))

    {
        pAdapter->XmitError += NumberOfPackets;
        TUN_RELEASE_LOCK(&pAdapter->Lock);
        
        if (!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OPEN))
        {
            DEBUGP(DL_WARN, ("TunMpSendPackets, pAdapter %p, Adapter not open\n", 
                                pAdapter));
            NdisStatus = NDIS_STATUS_NO_CABLE;
        }
        else
        {
            DEBUGP(DL_WARN, ("TunMpSendPackets, pAdapter %p, Adapter off.\n", 
                                pAdapter));
            
            NdisStatus = NDIS_STATUS_ADAPTER_NOT_READY;
        }

        for(Index = 0; Index < NumberOfPackets; Index++)
        {
            NDIS_SET_PACKET_STATUS(PacketArray[Index], NdisStatus);
            NdisMSendComplete(pAdapter->MiniportHandle,
                      PacketArray[Index],
                      NdisStatus);
        }

        TUN_DEREF_ADAPTER(pAdapter);
        DEBUGP(DL_LOUD, ("<==TunMpSendPackets, pAdapter %p\n", 
                            MiniportAdapterContext));
        return;
    }

    for(Index = 0; Index < NumberOfPackets; Index++)
    {
        NdisQueryPacket(PacketArray[Index], NULL, NULL, NULL, &BytesToSend);
      
        //
        //if the packet size is invalid or no data buffer associated with it,
        //inform NDIS about the invalidity
        //
        if ((BytesToSend == 0) || (BytesToSend > pAdapter->MediumMaxPacketLen))
        {
            NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_FAILURE);
            pAdapter->XmitError++;

            TUN_RELEASE_LOCK(&pAdapter->Lock);
            NdisMSendComplete(pAdapter->MiniportHandle,
                  PacketArray[Index],
                  NDIS_STATUS_FAILURE);
            TUN_ACQUIRE_LOCK(&pAdapter->Lock);

            continue;
        }

        //
        //if there are already MAX_PEND packets in miniport's pended packet queue,
        // refuse the new ones with NDIS_STATUS_RESOURCES
        //
        else if(pAdapter->RecvPktCount >= MAX_RECV_QUEUE_SIZE)
        {
            pAdapter->XmitError += NumberOfPackets - Index;
            pAdapter->XmitErrorNoReadIrps += NumberOfPackets - Index;
            
            TUN_RELEASE_LOCK(&pAdapter->Lock);
            
            for (;Index < NumberOfPackets; Index++)
            {
                NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_RESOURCES);

                
                NdisMSendComplete(pAdapter->MiniportHandle,
                      PacketArray[Index],
                      NDIS_STATUS_RESOURCES);
            }

            TUN_ACQUIRE_LOCK(&pAdapter->Lock);
            
            break;

        }

        //
        //queue the new packet, and set the packet status to pending
        //
        TUN_INSERT_TAIL_LIST(&pAdapter->RecvPktQueue, TUN_RCV_PKT_TO_LIST_ENTRY(PacketArray[Index]));
        
        //need to make sure the packet pointer in this statement

        pAdapter->RecvPktCount++;
        TUN_REF_ADAPTER(pAdapter);  // pended send
            
        NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_PENDING);
    }

    TUN_RELEASE_LOCK(&pAdapter->Lock);

    //
    //  Run the receive queue service routine now.
    //
    TunServiceReads(pAdapter);
    
    TUN_DEREF_ADAPTER(pAdapter);

    DEBUGP(DL_LOUD, ("<==TunMpSendPackets, pAdapter %p\n", 
                        MiniportAdapterContext));
    return;

}

VOID
TunMpReturnPacket(
    IN NDIS_HANDLE                  MiniportAdapterContext,
    IN PNDIS_PACKET                 NdisPacket
    )
/*++

Routine Description:

    NDIS entry point called to signify completion of a packet send.
    We pick up and complete the Write IRP corresponding to this packet.

    NDIS 5.1: 

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - packet that completed send
    Status - status of send

Return Value:

    None

--*/
{
    PIRP                        pIrp;
    PIO_STACK_LOCATION          pIrpSp;
    PTUN_ADAPTER                pAdapter;

    pAdapter = (PTUN_ADAPTER)MiniportAdapterContext;
    
    DEBUGP(DL_LOUD, ("==>TunMpReturnPacket, pAdapter %p\n", 
                        pAdapter));

    //1 get rid of this
    TUN_STRUCT_ASSERT(pAdapter, mc);

    pIrp = TUN_IRP_FROM_SEND_PKT(NdisPacket);

    //
    //  We are done with the NDIS_PACKET:
    //
    TUN_DEREF_SEND_PKT(NdisPacket);

    //
    //  Complete the Write IRP with the right status.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
    pIrp->IoStatus.Information = pIrpSp->Parameters.Write.Length;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    DEBUGP(DL_VERY_LOUD, ("SendComplete: packet %p/IRP %p/Length %d "
                    "completed with status %x\n",
                    NdisPacket, pIrp, pIrp->IoStatus.Information, pIrp->IoStatus.Status));

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    TUN_ACQUIRE_LOCK(&pAdapter->Lock);

    pAdapter->PendedSendCount--;
    pAdapter->RcvPackets++;

    if ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_ACTIVE)) &&
        (pAdapter->PendedSendCount == 0) &&
        (TUN_TEST_FLAG(pAdapter, TUN_COMPLETE_REQUEST)) &&
        ((!TUN_TEST_FLAG(pAdapter, TUN_ADAPTER_OFF)) ||
         (pAdapter->PendedReadCount == 0)))
    {
        TUN_CLEAR_FLAG(pAdapter, TUN_COMPLETE_REQUEST);
        TUN_RELEASE_LOCK(&pAdapter->Lock);
        NdisMSetInformationComplete(&pAdapter->MiniportHandle, 
                                    NDIS_STATUS_SUCCESS);
    }
    else
    {
        TUN_RELEASE_LOCK(&pAdapter->Lock);
    }

    TUN_DEREF_ADAPTER(pAdapter); // send complete - dequeued send IRP

    DEBUGP(DL_LOUD, ("<==TunMpReturnPacket, pAdapter %p\n", 
                        pAdapter));
}

VOID
TunMpRefAdapter(
    IN PTUN_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Reference the given open context.

    NOTE: Can be called with or without holding the opencontext lock.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    NdisInterlockedIncrement(&pAdapter->RefCount);
}


VOID
TunMpDerefAdapter(
    IN PTUN_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Dereference the given open context. If the ref count goes to zero,
    free it.

    NOTE: called without holding the opencontext lock

Arguments:

    pAdapter - pointer to open context

Return Value:

    None

--*/
{
    //1 how do we protect against ref count going to zero and back up again?
    if (NdisInterlockedDecrement(&pAdapter->RefCount) == 0)
    {
        DEBUGP(DL_INFO, ("DerefAdapter: Adapter %p, Flags %x, ref count is zero!\n",
            pAdapter, pAdapter->Flags));
        
        TUN_ASSERT(pAdapter->MiniportHandle == NULL);
        TUN_ASSERT(pAdapter->RefCount == 0);
        TUN_ASSERT(pAdapter->pFileObject == NULL);

        pAdapter->mc_sig++;

        //
        //  Free it.
        //
        TUN_FREE_MEM(pAdapter);
    }
}


#if DBG
VOID
TunMpDbgRefAdapter(
    IN PTUN_ADAPTER        pAdapter,
    IN ULONG               FileNumber,
    IN ULONG               LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("  RefAdapter: Adapter %p, old ref %d, File %c%c%c%c, line %d\n",
            pAdapter,
            pAdapter->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    TunMpRefAdapter(pAdapter);
}

VOID
TunMpDbgDerefAdapter(
    IN PTUN_ADAPTER         pAdapter,
    IN ULONG                FileNumber,
    IN ULONG                LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("DerefAdapter: Adapter %p, old ref %d, File %c%c%c%c, line %d\n",
            pAdapter,
            pAdapter->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    TunMpDerefAdapter(pAdapter);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	Created, based on ATM ARP.

Notes:

--*/

#include <precomp.h>

#define __FILENUMBER 'GBED'

#if DBG

INT             	ndisuioDebugLevel=DL_WARN;

NDIS_SPIN_LOCK		ndisuioDbgLogLock;

PNUIOD_ALLOCATION	ndisuiodMemoryHead = (PNUIOD_ALLOCATION)NULL;
PNUIOD_ALLOCATION	ndisuiodMemoryTail = (PNUIOD_ALLOCATION)NULL;
ULONG				ndisuiodAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		ndisuiodMemoryLock;
BOOLEAN				ndisuiodInitDone = FALSE;


PVOID
ndisuioAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PNUIOD_ALLOCATION	pAllocInfo;

	if (!ndisuiodInitDone)
	{
		NdisAllocateSpinLock(&(ndisuiodMemoryLock));
		ndisuiodInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+sizeof(NUIOD_ALLOCATION),
		(ULONG)'oiuN'
	);

	if (pAllocInfo == (PNUIOD_ALLOCATION)NULL)
	{
		DEBUGP(DL_VERY_LOUD+50,
			("ndisuioAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		NUIO_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = NUIOD_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = (ULONG_PTR)pPointer;
		pAllocInfo->Next = (PNUIOD_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(ndisuiodMemoryLock));

		pAllocInfo->Prev = ndisuiodMemoryTail;
		if (ndisuiodMemoryTail == (PNUIOD_ALLOCATION)NULL)
		{
			// empty list
			ndisuiodMemoryHead = ndisuiodMemoryTail = pAllocInfo;
		}
		else
		{
			ndisuiodMemoryTail->Next = pAllocInfo;
		}
		ndisuiodMemoryTail = pAllocInfo;
		
		ndisuiodAllocCount++;
		NdisReleaseSpinLock(&(ndisuiodMemoryLock));
	}

	DEBUGP(DL_VERY_LOUD+100,
	 ("ndisuioAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
ndisuioAuditFreeMem(
	PVOID	Pointer
)
{
	PNUIOD_ALLOCATION	pAllocInfo;

	NdisAcquireSpinLock(&(ndisuiodMemoryLock));

	pAllocInfo = CONTAINING_RECORD(Pointer, NUIOD_ALLOCATION, UserData);

	if (pAllocInfo->Signature != NUIOD_MEMORY_SIGNATURE)
	{
		DEBUGP(DL_ERROR,
		 ("ndisuioAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
		NdisReleaseSpinLock(&(ndisuiodMemoryLock));
#if DBG
		DbgBreakPoint();
#endif
		return;
	}

	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PNUIOD_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		ndisuiodMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PNUIOD_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		ndisuiodMemoryTail = pAllocInfo->Prev;
	}
	ndisuiodAllocCount--;
	NdisReleaseSpinLock(&(ndisuiodMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
ndisuioAuditShutdown(
	VOID
)
{
	if (ndisuiodInitDone)
	{
		if (ndisuiodAllocCount != 0)
		{
			DEBUGP(DL_ERROR, ("AuditShutdown: unfreed memory, %d blocks!\n",
					ndisuiodAllocCount));
			DEBUGP(DL_ERROR, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
					ndisuiodMemoryHead, ndisuiodMemoryTail));
			DbgBreakPoint();
			{
				PNUIOD_ALLOCATION		pAllocInfo;

				while (ndisuiodMemoryHead != (PNUIOD_ALLOCATION)NULL)
				{
					pAllocInfo = ndisuiodMemoryHead;
					DEBUGP(DL_INFO, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
					ndisuioAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		ndisuiodInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}
#endif // DBG


#if DBG_SPIN_LOCK
ULONG	ndisuiodSpinLockInitDone = 0;
NDIS_SPIN_LOCK	ndisuiodLockLock;

VOID
ndisuioAllocateSpinLock(
	IN	PNUIO_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (ndisuiodSpinLockInitDone == 0)
	{
		ndisuiodSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(ndisuiodLockLock));
	}

	NdisAcquireSpinLock(&(ndisuiodLockLock));
	pLock->Signature = NUIOL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(ndisuiodLockLock));
}


VOID
ndisuioAcquireSpinLock(
	IN	PNUIO_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(ndisuiodLockLock));
	if (pLock->Signature != NUIOL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(ndisuiodLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
ndisuioReleaseSpinLock(
	IN	PNUIO_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(ndisuiodLockLock));
	if (pLock->Signature != NUIOL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(ndisuiodLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\macros.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Some macros for NDISUIO.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/


#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b)? (_a): (_b))
#endif

#if DBG
#define NUIO_REF_OPEN(_pOpen)   ndisuioDbgRefOpen(_pOpen, __FILENUMBER, __LINE__)
#define NUIO_DEREF_OPEN(_pOpen) ndisuioDbgDerefOpen(_pOpen, __FILENUMBER, __LINE__)
#else
#define NUIO_REF_OPEN(_pOpen)   ndisuioRefOpen(_pOpen)
#define NUIO_DEREF_OPEN(_pOpen) ndisuioDerefOpen(_pOpen)
#endif

//
//  Spinlock macros
//
#if DBG_SPIN_LOCK

#define NUIO_INIT_LOCK(_pLock)              \
           ndisuioAllocateSpinLock(_pLock, __FILENUMBER, __LINE__)

#define NUIO_ACQUIRE_LOCK(_pLock)           \
            ndisuioAcquireSpinLock(_pLock, __FILENUMBER, __LINE__)

#define NUIO_RELEASE_LOCK(_pLock)           \
            ndisuioReleaseSpinLock(_pLock, __FILENUMBER, __LINE__)

#else

#define NUIO_INIT_LOCK(_pLock)           NdisAllocateSpinLock(_pLock)
#define NUIO_ACQUIRE_LOCK(_pLock)        NdisAcquireSpinLock(_pLock)
#define NUIO_RELEASE_LOCK(_pLock)        NdisReleaseSpinLock(_pLock)

#endif // DBG

//
//  List manipulation.
//
#define NUIO_INIT_LIST_HEAD(_pList)             InitializeListHead(_pList)
#define NUIO_IS_LIST_EMPTY(_pList)              IsListEmpty(_pList)
#define NUIO_INSERT_HEAD_LIST(_pList, _pEnt)    InsertHeadList(_pList, _pEnt)
#define NUIO_INSERT_TAIL_LIST(_pList, _pEnt)    InsertTailList(_pList, _pEnt)
#define NUIO_REMOVE_ENTRY_LIST(_pEnt)           RemoveEntryList(_pEnt)


//
//  Receive packet queueing.
//
#define NUIO_LIST_ENTRY_TO_RCV_PKT(_pEnt)   \
    CONTAINING_RECORD(CONTAINING_RECORD(_pEnt, NUIO_RECV_PACKET_RSVD, Link), NDIS_PACKET, ProtocolReserved)

#define NUIO_RCV_PKT_TO_LIST_ENTRY(_pPkt)   \
    (&((PNUIO_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->Link)


//
//  In case we allocate a receive packet of our own to copy and queue
//  received data, we might have to also allocate an auxiliary NDIS_BUFFER
//  to map part of the receive buffer (skipping the header bytes), so as
//  to satisfy NdisTransferData. In such cases, we keep a pointer to the
//  fully mapped receive buffer in the packet reserved space:
//
#define NUIO_RCV_PKT_TO_ORIGINAL_BUFFER(_pPkt)  \
    (((PNUIO_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pOriginalBuffer)


//
//  Send packet context.
//
#define NUIO_IRP_FROM_SEND_PKT(_pPkt)		\
	(((PNUIO_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pIrp)

#define NUIO_SEND_PKT_RSVD(_pPkt)           \
    ((PNUIO_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))


#define NUIO_REF_SEND_PKT(_pPkt)            \
    (VOID)NdisInterlockedIncrement((PLONG)&NUIO_SEND_PKT_RSVD(_pPkt)->RefCount)


#define NUIO_DEREF_SEND_PKT(_pPkt)          \
    {                                                                               \
        if (NdisInterlockedDecrement((PLONG)&NUIO_SEND_PKT_RSVD(_pPkt)->RefCount) == 0)    \
        {                                                                           \
            NdisFreePacket(_pPkt);                                                  \
        }                                                                           \
    }


#ifdef NDIS51

//
//  Cancel IDs are generated by using the partial cancel ID we got from
//  NDIS ORed with a monotonically increasing locally generated ID.
//
#define NUIO_CANCEL_ID_LOW_MASK     (((ULONG_PTR)-1) >> 8) 

#define NUIO_GET_NEXT_CANCEL_ID()                                                   \
        (PVOID)(Globals.PartialCancelId |                                           \
         ((NdisInterlockedIncrement((PLONG)&Globals.LocalCancelId)) & NUIO_CANCEL_ID_LOW_MASK))

#endif // NDIS51

//
//  Memory allocation
//
#if DBG
#define NUIO_ALLOC_MEM(_pVar, _Size)        \
    (_pVar) = ndisuioAuditAllocMem(         \
                    (PVOID)&(_pVar),        \
                    _Size,                  \
                    __FILENUMBER,           \
                    __LINE__);

#define NUIO_FREE_MEM(_pMem)                \
    ndisuioAuditFreeMem(_pMem);

#else

#define NUIO_ALLOC_MEM(_pVar, _Size)        \
    NdisAllocateMemoryWithTag((PVOID *)(&_pVar), (_Size), NUIO_ALLOC_TAG)

#define NUIO_FREE_MEM(_pMem)                \
    NdisFreeMemory(_pMem, 0, 0)

#endif // DBG


#define NUIO_ZERO_MEM(_pMem, _ByteCount)        \
    NdisZeroMemory(_pMem, _ByteCount)

#define NUIO_COPY_MEM(_pDst, _pSrc, _ByteCount) \
    NdisMoveMemory(_pDst, _pSrc, _ByteCount)

#define NUIO_MEM_CMP(_p1, _p2, _ByteCount)      \
    NdisEqualMemory(_p1, _p2, _ByteCount)

#define NUIO_SET_MEM(_pMem, _ByteVal, _ByteCount)   \
    NdisFillMemory(_pMem, _ByteCount, _ByteVal)

//
//  Events.
//
#define NUIO_INIT_EVENT(_pEvent)            NdisInitializeEvent(_pEvent)
#define NUIO_SIGNAL_EVENT(_pEvent)          NdisSetEvent(_pEvent)
#define NUIO_WAIT_EVENT(_pEvent, _MsToWait) NdisWaitEvent(_pEvent, _MsToWait)


//
//  Flags
//
#define NUIO_SET_FLAGS(_FlagsVar, _Mask, _BitsToSet)    \
        (_FlagsVar) = ((_FlagsVar) & ~(_Mask)) | (_BitsToSet)

#define NUIO_TEST_FLAGS(_FlagsVar, _Mask, _BitsToCheck)    \
        (((_FlagsVar) & (_Mask)) == (_BitsToCheck))


//
//  Block the calling thread for the given duration:
//
#define NUIO_SLEEP(_Seconds)                            \
{                                                       \
    NDIS_EVENT  _SleepEvent;                            \
    NdisInitializeEvent(&_SleepEvent);                  \
    (VOID)NdisWaitEvent(&_SleepEvent, _Seconds*1000);   \
}


#define NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                           \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_FOUND == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_NO_MORE_ENTRIES;                                     \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_READY == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_DEVICE_NOT_READY;                                    \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}

#ifdef WIN9X
#undef NdisGetPoolFromPacket
#define NdisGetPoolFromPacket(_Pkt) ((_Pkt)->Private.Pool)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\ndisuio.inf: ndisuio.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\tunmp\sys\tunsd.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    tunsd.c

Abstract:

    utility routines to handle setting security descriptor on tunmp device.

Environment:

    Kernel mode only.

Revision History:

    alid        5/17/2002

--*/

#include <ntosp.h>
#include <ntrtl.h>

#define TUN_ALLOC_TAG      'untN'

PACL    NetConfigAcl = NULL;
PSID    NetConfigOpsSid = NULL;
CHAR    NetConfigSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];

PACL
TunCreateAcl(
    BOOLEAN     Admins,
    BOOLEAN     LocalSystem,
    BOOLEAN     LocalService,
    BOOLEAN     NetworkService,
    BOOLEAN     NetConfigOps,
    BOOLEAN     Users,
    ACCESS_MASK AccessMask
    );

NTSTATUS
TunCreateGenericSD(
    PACL            Acl,
    PCHAR           AccessSecurityDescriptor
    );


PACL
TunCreateAcl(
    BOOLEAN     Admins,
    BOOLEAN     LocalSystem,
    BOOLEAN     LocalService,
    BOOLEAN     NetworkService,
    BOOLEAN     NetConfigOps,
    BOOLEAN     Users,
    ACCESS_MASK AccessMask
    )
{
    PACL    AccessDacl = NULL, pAcl = NULL;
    ULONG   AclLength = 0;
    ULONG   NetConfigOpsSidSize;
    SID_IDENTIFIER_AUTHORITY NetConfigOpsSidAuth = SECURITY_NT_AUTHORITY;
    PISID               ISid;
    NTSTATUS            Status;
    

    do
    {
        if (Admins)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeAliasAdminsSid);

        }

        if (LocalSystem)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeLocalSystemSid);

        }
        
        if (LocalService)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeLocalServiceSid);

        }
        
        if (NetworkService)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeNetworkServiceSid);

        }

        if (NetConfigOps)
        {
            NetConfigOpsSidSize = RtlLengthRequiredSid(2);
            NetConfigOpsSid = (PSID)ExAllocatePoolWithTag(PagedPool, NetConfigOpsSidSize, TUN_ALLOC_TAG);
            if (NULL == NetConfigOpsSid)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            Status = RtlInitializeSid(NetConfigOpsSid, &NetConfigOpsSidAuth, 2);
            if (Status != STATUS_SUCCESS)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ISid = (PISID)(NetConfigOpsSid);
            ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
            ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) + 
                         RtlLengthSid(NetConfigOpsSid);

        }

        if (Users)
        {
            AclLength += sizeof(ACL)                                 +
                         FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                         RtlLengthSid(SeExports->SeAliasUsersSid);

        }

        AccessDacl = (PACL)ExAllocatePoolWithTag(PagedPool,
                                                 AclLength,
                                                 TUN_ALLOC_TAG);
        
        if (AccessDacl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = RtlCreateAcl(AccessDacl,
                              AclLength,
                              ACL_REVISION2);
        
        if (!NT_SUCCESS(Status))
        {
#if DBG
            DbgPrint("RtlCreateAcl failed, Status %lx.\n", Status);
#endif
            break;
        }


        if (Admins)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeAliasAdminsSid
                                        );
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
#endif

                break;
            }
        }

        if (LocalSystem)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeLocalSystemSid
                                        );
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
#endif
                break;
            }
        }
        
        if (LocalService)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeLocalServiceSid
                                        );
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
#endif
                break;
            }

        }
        
        if (NetworkService)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        SeExports->SeNetworkServiceSid
                                        );
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
#endif
                break;
            }
        }

        if (NetConfigOps)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                                        NetConfigOpsSid
                                        );
            if (!NT_SUCCESS(Status))
            {
#if DBG
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
#endif
                break;
            }

        }

        if (Users)
        {
            Status = RtlAddAccessAllowedAce(
                                        AccessDacl,
                                        ACL_REVISION2,
                                        AccessMask,
                                        SeExports->SeAliasUsersSid
                                        );
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("RtlAddAccessAllowedAce failed, Status %lx.\n", Status);
                break;
            }            
        }
        
        pAcl = AccessDacl;
        
    }while (FALSE);

    if (pAcl == NULL)
    {
        if (AccessDacl)
            ExFreePool(AccessDacl);
        if (NetConfigOpsSid)
        {
            ExFreePool(NetConfigOpsSid);
            NetConfigOpsSid = NULL;
        }
    }
    
    return pAcl;
    
}



NTSTATUS
TunCreateGenericSD(
    PACL            Acl,
    PCHAR           AccessSecurityDescriptor
    )

/*++

Routine Description:

    Creates the SD responsible for giving access to different users.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PSECURITY_DESCRIPTOR    AccessSd;
    NTSTATUS                Status;

    if (Acl == NULL)
        return STATUS_UNSUCCESSFUL;
    
    do
    {
        AccessSd = AccessSecurityDescriptor;
        Status = RtlCreateSecurityDescriptor(
                     AccessSd,
                     SECURITY_DESCRIPTOR_REVISION1
                     );

        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlCreateSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }
        
        Status = RtlSetDaclSecurityDescriptor(
                     AccessSd,
                     TRUE,                       // DaclPresent
                     Acl,
                     FALSE                       // DaclDefaulted
                     );
        
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetDaclSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

        Status = RtlSetOwnerSecurityDescriptor(AccessSd,
                                               SeExports->SeAliasAdminsSid,
                                               FALSE);
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetOwnerSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

        Status = RtlSetGroupSecurityDescriptor(AccessSd,
                                               SeExports->SeAliasAdminsSid,
                                               FALSE);

        if (!NT_SUCCESS(Status))
        {
            DbgPrint("RtlSetGroupSecurityDescriptor failed, Status %lx.\n", Status);
            break;
        }

    }while (FALSE);
    
    return (Status);
}

NTSTATUS
TunCreateSD(
    VOID
    )
{
    NTSTATUS    Status;
    
    //
    // create an ACL for admin types
    //
    NetConfigAcl = TunCreateAcl(TRUE,         // Admins
                              TRUE,         //LocalSystem
                              TRUE,         //LocalService
                              TRUE,         //NetworkService
                              TRUE,         //NetConfigOps
                              FALSE,        //Users
                              GENERIC_READ | GENERIC_WRITE
                              );

    if (NetConfigAcl != NULL)
    {
        Status = TunCreateGenericSD(NetConfigAcl, NetConfigSecurityDescriptor);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
TunSetSecurity(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS                Status;
    SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | 
                               GROUP_SECURITY_INFORMATION | 
                               DACL_SECURITY_INFORMATION;

    
    Status = ObSetSecurityObjectByPointer(DeviceObject, 
                                          secInfo, 
                                          NetConfigSecurityDescriptor);

    ASSERT(NT_SUCCESS(Status));

    return Status;

}


VOID
TunDeleteSD(
    VOID
    )
/*
delete NetConfigAcl
*/
{
    if (NetConfigAcl != NULL)
    {
        ExFreePool(NetConfigAcl);
        NetConfigAcl = NULL;
    }
    if (NetConfigOpsSid != NULL)
    {
        ExFreePool(NetConfigOpsSid);
        NetConfigOpsSid = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for NDISUIO

Revision History:

    arvindm     04/11/2000    created based on rawwan.

Notes:

--*/

#ifndef _NUIODEBUG__H
#define _NUIODEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD       20
#define DL_VERY_LOUD        10
#define DL_LOUD             8
#define DL_INFO             6
#define DL_WARN             4
#define DL_ERROR            2
#define DL_FATAL            0

#if DBG_SPIN_LOCK

typedef struct _NUIO_LOCK
{
    ULONG                   Signature;
    ULONG                   IsAcquired;
    PKTHREAD                OwnerThread;
    ULONG                   TouchedByFileNumber;
    ULONG                   TouchedInLineNumber;
    NDIS_SPIN_LOCK          NdisLock;
} NUIO_LOCK, *PNUIO_LOCK;

#define NUIOL_SIG    'KCOL'

extern NDIS_SPIN_LOCK       ndisuioDbgLogLock;

extern
VOID
ndisuioAllocateSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisuioAcquireSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisuioReleaseSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)                                         \
            {                                                           \
                if ((INT)(Count) < 0)                                   \
                {                                                       \
                    DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",\
                        Count, __FILE__, __LINE__);                     \
                    DbgBreakPoint();                                    \
                }                                                       \
            }
#else

#define CHECK_LOCK_COUNT(Count)

typedef NDIS_SPIN_LOCK      NUIO_LOCK;
typedef PNDIS_SPIN_LOCK     PNUIO_LOCK;

#endif    // DBG_SPIN_LOCK

#if DBG

extern INT                ndisuioDebugLevel;


#define DEBUGP(lev, stmt)                                               \
        {                                                               \
            if ((lev) <= ndisuioDebugLevel)                             \
            {                                                           \
                DbgPrint("Ndisuio: "); DbgPrint stmt;                   \
            }                                                           \
        }

#define DEBUGPDUMP(lev, pBuf, Len)                                      \
        {                                                               \
            if ((lev) <= ndisuioDebugLevel)                             \
            {                                                           \
                DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));          \
            }                                                           \
        }

#define NUIO_ASSERT(exp)                                                \
        {                                                               \
            if (!(exp))                                                 \
            {                                                           \
                DbgPrint("Ndisuio: assert " #exp " failed in"           \
                    " file %s, line %d\n", __FILE__, __LINE__);         \
                DbgBreakPoint();                                        \
            }                                                           \
        }

#define NUIO_SET_SIGNATURE(s, t)\
        (s)->t##_sig = t##_signature;

#define NUIO_STRUCT_ASSERT(s, t)                                        \
        if ((s)->t##_sig != t##_signature)                              \
        {                                                               \
            DbgPrint("ndisuio: assertion failure"                       \
            " for type " #t " at 0x%x in file %s, line %d\n",           \
             (PUCHAR)s, __FILE__, __LINE__);                            \
            DbgBreakPoint();                                            \
        }


//
// Memory Allocation/Freeing Audit:
//

//
// The NUIOD_ALLOCATION structure stores all info about one allocation
//
typedef struct _NUIOD_ALLOCATION {

        ULONG                    Signature;
        struct _NUIOD_ALLOCATION *Next;
        struct _NUIOD_ALLOCATION *Prev;
        ULONG                    FileNumber;
        ULONG                    LineNumber;
        ULONG                    Size;
        ULONG_PTR                Location;  // where the returned ptr was stored
        union
        {
            ULONGLONG            Alignment;
            UCHAR                    UserData;
        };

} NUIOD_ALLOCATION, *PNUIOD_ALLOCATION;

#define NUIOD_MEMORY_SIGNATURE    (ULONG)'CSII'

extern
PVOID
ndisuioAuditAllocMem (
    PVOID        pPointer,
    ULONG        Size,
    ULONG        FileNumber,
    ULONG        LineNumber
);

extern
VOID
ndisuioAuditFreeMem(
    PVOID        Pointer
);

extern
VOID
ndisuioAuditShutdown(
    VOID
);

extern
VOID
DbgPrintHexDump(
    PUCHAR        pBuffer,
    ULONG        Length
);

#else

//
// No debug
//
#define DEBUGP(lev, stmt)
#define DEBUGPDUMP(lev, pBuf, Len)

#define NUIO_ASSERT(exp)
#define NUIO_SET_SIGNATURE(s, t)
#define NUIO_STRUCT_ASSERT(s, t)

#endif    // DBG


#endif // _NUIODEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\ndisuio.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndisuio.h

Abstract:

    Data structures, defines and function prototypes for NDISUIO.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/

#ifndef __NDISUIO__H
#define __NDISUIO__H


#define NT_DEVICE_NAME          L"\\Device\\Ndisuio"
#define DOS_DEVICE_NAME         L"\\DosDevices\\Ndisuio"

//
//  Abstract types
//
typedef NDIS_EVENT              NUIO_EVENT;


#define NUIO_MAC_ADDR_LEN            6

//
//  The Open Context represents an open of our device object.
//  We allocate this on processing a BindAdapter from NDIS,
//  and free it when all references (see below) to it are gone.
//
//  Binding/unbinding to an NDIS device:
//
//  On processing a BindAdapter call from NDIS, we set up a binding
//  to the specified NDIS device (miniport). This binding is
//  torn down when NDIS asks us to Unbind by calling
//  our UnbindAdapter handler.
//
//  Receiving data:
//
//  While an NDIS binding exists, read IRPs are queued on this
//  structure, to be processed when packets are received.
//  If data arrives in the absense of a pended read IRP, we
//  queue it, to the extent of one packet, i.e. we save the
//  contents of the latest packet received. We fail read IRPs
//  received when no NDIS binding exists (or is in the process
//  of being torn down).
//
//  Sending data:
//
//  Write IRPs are used to send data. Each write IRP maps to
//  a single NDIS packet. Packet send-completion is mapped to
//  write IRP completion. We use NDIS 5.1 CancelSend to support
//  write IRP cancellation. Write IRPs that arrive when we don't
//  have an active NDIS binding are failed.
//
//  Reference count:
//
//  The following are long-lived references:
//  OPEN_DEVICE ioctl (goes away on processing a Close IRP)
//  Pended read IRPs
//  Queued received packets
//  Uncompleted write IRPs (outstanding sends)
//  Existence of NDIS binding
//
typedef struct _NDISUIO_OPEN_CONTEXT
{
    LIST_ENTRY              Link;           // Link into global list
    ULONG                   Flags;          // State information
    ULONG                   RefCount;
    NUIO_LOCK               Lock;

    PFILE_OBJECT            pFileObject;    // Set on OPEN_DEVICE

    NDIS_HANDLE             BindingHandle;
    NDIS_HANDLE             SendPacketPool;
    NDIS_HANDLE             SendBufferPool;
    NDIS_HANDLE             RecvPacketPool;
    NDIS_HANDLE             RecvBufferPool;
    ULONG                   MacOptions;
    ULONG                   MaxFrameSize;

    LIST_ENTRY              PendedWrites;   // pended Write IRPs
    ULONG                   PendedSendCount;

    LIST_ENTRY              PendedReads;    // pended Read IRPs
    ULONG                   PendedReadCount;
    LIST_ENTRY              RecvPktQueue;   // queued rcv packets
    ULONG                   RecvPktCount;

    NET_DEVICE_POWER_STATE  PowerState;
    NDIS_EVENT              PoweredUpEvent; // signalled iff PowerState is D0
    NDIS_STRING             DeviceName;     // used in NdisOpenAdapter
    NDIS_STRING				DeviceDescr;	// friendly name

    NDIS_STATUS             BindStatus;     // for Open/CloseAdapter
    NUIO_EVENT              BindEvent;      // for Open/CloseAdapter

    BOOLEAN                 bRunningOnWin9x;// TRUE if Win98/SE/ME, FALSE if NT

    ULONG                   oc_sig;         // Signature for sanity

    UCHAR                   CurrentAddress[NUIO_MAC_ADDR_LEN];

} NDISUIO_OPEN_CONTEXT, *PNDISUIO_OPEN_CONTEXT;

#define oc_signature        'OiuN'

//
//  Definitions for Flags above.
//
#define NUIOO_BIND_IDLE             0x00000000
#define NUIOO_BIND_OPENING          0x00000001
#define NUIOO_BIND_FAILED           0x00000002
#define NUIOO_BIND_ACTIVE           0x00000004
#define NUIOO_BIND_CLOSING          0x00000008
#define NUIOO_BIND_FLAGS            0x0000000F  // State of the binding

#define NUIOO_OPEN_IDLE             0x00000000
#define NUIOO_OPEN_ACTIVE           0x00000010
#define NUIOO_OPEN_FLAGS            0x000000F0  // State of the I/O open

#define NUIOO_RESET_IN_PROGRESS     0x00000100
#define NUIOO_NOT_RESETTING         0x00000000
#define NUIOO_RESET_FLAGS           0x00000100

#define NUIOO_MEDIA_CONNECTED       0x00000000
#define NUIOO_MEDIA_DISCONNECTED    0x00000200
#define NUIOO_MEDIA_FLAGS           0x00000200

#define NUIOO_READ_SERVICING        0x00100000  // Is the read service
                                                // routine running?
#define NUIOO_READ_FLAGS            0x00100000

#define NUIOO_UNBIND_RECEIVED       0x10000000  // Seen NDIS Unbind?
#define NUIOO_UNBIND_FLAGS          0x10000000


//
//  Globals:
//
typedef struct _NDISUIO_GLOBALS
{
    PDRIVER_OBJECT          pDriverObject;
    PDEVICE_OBJECT          ControlDeviceObject;
    NDIS_HANDLE             NdisProtocolHandle;
    USHORT                  EthType;            // frame type we are interested in
    UCHAR                   PartialCancelId;    // for cancelling sends
    ULONG                   LocalCancelId;
    LIST_ENTRY              OpenList;           // of OPEN_CONTEXT structures
    NUIO_LOCK               GlobalLock;         // to protect the above
    NUIO_EVENT              BindsComplete;      // have we seen NetEventBindsComplete?

} NDISUIO_GLOBALS, *PNDISUIO_GLOBALS;

//
//  The following are arranged in the way a little-endian processor
//  would read 2 bytes off the wire.
//
#define NUIO_ETH_TYPE               0x8e88
#define NUIO_8021P_TAG_TYPE         0x0081

//
//  NDIS Request context structure
//
typedef struct _NDISUIO_REQUEST
{
    NDIS_REQUEST            Request;
    NUIO_EVENT              ReqEvent;
    ULONG                   Status;

} NDISUIO_REQUEST, *PNDISUIO_REQUEST;


#define NUIOO_PACKET_FILTER  (NDIS_PACKET_TYPE_DIRECTED|    \
                              NDIS_PACKET_TYPE_MULTICAST|   \
                              NDIS_PACKET_TYPE_BROADCAST)

//
//  Send packet pool bounds
//
#define MIN_SEND_PACKET_POOL_SIZE    20
#define MAX_SEND_PACKET_POOL_SIZE    400

//
//  ProtocolReserved in sent packets. We save a pointer to the IRP
//  that generated the send.
//
//  The RefCount is used to determine when to free the packet back
//  to its pool. It is used to synchronize between a thread completing
//  a send and a thread attempting to cancel a send.
//
typedef struct _NUIO_SEND_PACKET_RSVD
{
    PIRP                    pIrp;
    ULONG                   RefCount;

} NUIO_SEND_PACKET_RSVD, *PNUIO_SEND_PACKET_RSVD;

//
//  Receive packet pool bounds
//
#define MIN_RECV_PACKET_POOL_SIZE    4
#define MAX_RECV_PACKET_POOL_SIZE    20

//
//  Max receive packets we allow to be queued up
//
#define MAX_RECV_QUEUE_SIZE          4

//
//  ProtocolReserved in received packets: we link these
//  packets up in a queue waiting for Read IRPs.
//
typedef struct _NUIO_RECV_PACKET_RSVD
{
    LIST_ENTRY              Link;
    PNDIS_BUFFER            pOriginalBuffer;    // used if we had to partial-map

} NUIO_RECV_PACKET_RSVD, *PNUIO_RECV_PACKET_RSVD;



#include <pshpack1.h>

typedef struct _NDISUIO_ETH_HEADER
{
    UCHAR       DstAddr[NUIO_MAC_ADDR_LEN];
    UCHAR       SrcAddr[NUIO_MAC_ADDR_LEN];
    USHORT      EthType;

} NDISUIO_ETH_HEADER;

typedef struct _NDISUIO_ETH_HEADER UNALIGNED * PNDISUIO_ETH_HEADER;

#include <poppack.h>


extern NDISUIO_GLOBALS      Globals;


#define NUIO_ALLOC_TAG      'oiuN'


#ifndef NDIS51
#define NdisGetPoolFromPacket(_Pkt) (_Pkt->Private.Pool)
#endif

//
//  Prototypes.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    );

VOID
NdisuioUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NdisuioOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
ndisuioOpenDevice(
    IN PUCHAR                   pDeviceName,
    IN ULONG                    DeviceNameLength,
    IN PFILE_OBJECT             pFileObject,
    OUT PNDISUIO_OPEN_CONTEXT * ppOpenContext
    );

VOID
ndisuioRefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

#if DBG
VOID
ndisuioDbgRefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );

VOID
ndisuioDbgDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    );
#endif // DBG

VOID
NdisuioBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  BindContext,
    IN PNDIS_STRING                 DeviceName,
    IN PVOID                        SystemSpecific1,
    IN PVOID                        SystemSpecific2
    );

VOID
NdisuioOpenAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status,
    IN NDIS_STATUS                  OpenErrorCode
    );

VOID
NdisuioUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  UnbindContext
    );

VOID
NdisuioCloseAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );


NDIS_STATUS
NdisuioPnPEventHandler(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNET_PNP_EVENT               pNetPnPEvent
    );

VOID
NdisuioProtocolUnloadHandler(
    VOID
    );

NDIS_STATUS
ndisuioCreateBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

VOID
ndisuioShutdownBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioFreeBindResources(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioWaitForPendingIO(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN BOOLEAN                      DoCancelReads
    );

VOID
ndisuioDoProtocolUnload(
    VOID
    );

NDIS_STATUS
ndisuioDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed
    );

NDIS_STATUS
ndisuioValidateOpenAndDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed,
    IN BOOLEAN                      bWaitForPowerOn
    );

VOID
NdisuioResetComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );

VOID
NdisuioRequestComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_REQUEST                pNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
NdisuioStatus(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  GeneralStatus,
    IN PVOID                        StatusBuffer,
    IN UINT                         StatusBufferSize
    );

VOID
NdisuioStatusComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

NDIS_STATUS
ndisuioQueryBinding(
    IN PUCHAR                       pBuffer,
    IN ULONG                        InputLength,
    IN ULONG                        OutputLength,
    OUT PULONG                      pBytesReturned
    );

PNDISUIO_OPEN_CONTEXT
ndisuioLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

NDIS_STATUS
ndisuioQueryOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    );

NDIS_STATUS
ndisuioSetOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    );

BOOLEAN
ndisuioValidOid(
    IN  NDIS_OID                    Oid
    );


NTSTATUS
NdisuioRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );


VOID
NdisuioCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
ndisuioServiceReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

NDIS_STATUS
NdisuioReceive(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  MacReceiveContext,
    IN PVOID                        pHeaderBuffer,
    IN UINT                         HeaderBufferSize,
    IN PVOID                        pLookaheadBuffer,
    IN UINT                         LookaheadBufferSize,
    IN UINT                         PacketSize
    );

VOID
NdisuioTransferDataComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  TransferStatus,
    IN UINT                         BytesTransferred
    );

VOID
NdisuioReceiveComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

INT
NdisuioReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisuioShutdownBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioQueueReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pRcvPacket
    );

PNDIS_PACKET
ndisuioAllocateReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN UINT                         DataLength,
    OUT PUCHAR *                    ppDataBuffer
    );

VOID
ndisuioFreeReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisuioCancelPendingReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioFlushReceiveQueue(
    IN PNDISUIO_OPEN_CONTEXT            pOpenContext
    );

NTSTATUS
NdisuioWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
NdisuioCancelWrite(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
NdisuioSendComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  Status
    );

#endif // __NDISUIO__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\recv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    NDIS protocol entry points and utility routines to handle receiving
    data.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/6/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'VCER'



NTSTATUS
NdisuioRead(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_READ. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus;
    PNDISUIO_OPEN_CONTEXT   pOpenContext;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    do
    {
        //
        // Validate!
        //
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL FsContext on FileObject %p\n",
                        pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
            
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        if (pIrp->MdlAddress == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: NULL MDL address on IRP %p\n", pIrp));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Try to get a virtual address for the MDL.
        //
#ifndef WIN9X
        if (MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority) == NULL)
        {
            DEBUGP(DL_FATAL, ("Read: MmGetSystemAddr failed for IRP %p, MDL %p\n",
                    pIrp, pIrp->MdlAddress));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
#endif
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }

        //
        //  Add this IRP to the list of pended Read IRPs
        //
        NUIO_INSERT_TAIL_LIST(&pOpenContext->PendedReads, &pIrp->Tail.Overlay.ListEntry);
        NUIO_REF_OPEN(pOpenContext);  // pended read IRP
        pOpenContext->PendedReadCount++;

        //
        //  Set up the IRP for possible cancellation.
        //
        pIrp->Tail.Overlay.DriverContext[0] = (PVOID)pOpenContext;
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp, NdisuioCancelRead);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        NtStatus = STATUS_PENDING;

        //
        //  Run the service routine for reads.
        //
        ndisuioServiceReads(pOpenContext);

    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        NUIO_ASSERT(NtStatus != STATUS_SUCCESS);
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return (NtStatus);
}


VOID
NdisuioCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    )
/*++

Routine Description:

    Cancel a pending read IRP. We unlink the IRP from the open context
    queue and complete it.

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - IRP to be cancelled

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pIrpEntry;
    BOOLEAN                     Found;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    Found = FALSE;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT) pIrp->Tail.Overlay.DriverContext[0];
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    //
    //  Locate the IRP in the pended read queue and remove it if found.
    //
    for (pIrpEntry = pOpenContext->PendedReads.Flink;
         pIrpEntry != &pOpenContext->PendedReads;
         pIrpEntry = pIrpEntry->Flink)
    {
        if (pIrp == CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry))
        {
            NUIO_REMOVE_ENTRY_LIST(&pIrp->Tail.Overlay.ListEntry);
            pOpenContext->PendedReadCount--;
            Found = TRUE;
            break;
        }
    }

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    if (Found)
    {
        DEBUGP(DL_INFO, ("CancelRead: Open %p, IRP %p\n", pOpenContext, pIrp));
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        NUIO_DEREF_OPEN(pOpenContext); // Cancel removed pended Read
    }
}
        


VOID
ndisuioServiceReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Utility routine to copy received data into user buffers and
    complete READ IRPs.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;
    PNDIS_PACKET        pRcvPacket;
    PLIST_ENTRY         pRcvPacketEntry;
    PUCHAR              pSrc, pDst;
    ULONG               BytesRemaining; // at pDst
    PNDIS_BUFFER        pNdisBuffer;
    ULONG               BytesAvailable;
    BOOLEAN             FoundPendingIrp;

    DEBUGP(DL_VERY_LOUD, ("ServiceReads: open %p/%x\n",
            pOpenContext, pOpenContext->Flags));

    NUIO_REF_OPEN(pOpenContext);  // temp ref - service reads

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    while (!NUIO_IS_LIST_EMPTY(&pOpenContext->PendedReads) &&
           !NUIO_IS_LIST_EMPTY(&pOpenContext->RecvPktQueue))
    {
        FoundPendingIrp = FALSE;
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pOpenContext->PendedReads.Flink;
        while (pIrpEntry != &pOpenContext->PendedReads)
        {
            pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

            //
            //  Check to see if it is being cancelled.
            //
            if (IoSetCancelRoutine(pIrp, NULL))
            {
                //
                //  It isn't being cancelled, and can't be cancelled henceforth.
                //
                NUIO_REMOVE_ENTRY_LIST(pIrpEntry);
                FoundPendingIrp = TRUE;
                break;

                //
                //  NOTE: we decrement PendedReadCount way below in the
                //  while loop, to avoid letting through a thread trying
                //  to unbind.
                //
            }
            else
            {
                //
                //  The IRP is being cancelled; let the cancel routine handle it.
                //
                DEBUGP(DL_INFO, ("ServiceReads: open %p, skipping cancelled IRP %p\n",
                        pOpenContext, pIrp));
                pIrpEntry = pIrpEntry->Flink;

            }
        }
        //
        // If no pending IRP
        //
        if (FoundPendingIrp == FALSE)
        {
            break;
        }
        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pOpenContext->RecvPktQueue.Flink;
        NUIO_REMOVE_ENTRY_LIST(pRcvPacketEntry);

        pOpenContext->RecvPktCount --;

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        NUIO_DEREF_OPEN(pOpenContext);  // Service: dequeue rcv packet

        pRcvPacket = NUIO_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        //
        //  Copy as much data as possible from the receive packet to
        //  the IRP MDL.
        //
#ifndef WIN9X
        pDst = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
        NUIO_ASSERT(pDst != NULL);  // since it was already mapped
#else
        pDst = MmGetSystemAddressForMdl(pIrp->MdlAddress);  // Win9x
#endif
        BytesRemaining = MmGetMdlByteCount(pIrp->MdlAddress);

        pNdisBuffer = pRcvPacket->Private.Head;

        //
        // Copy the data in the received packet into the buffer provided by the client.
        // If the length of the receive packet is greater than length of the given buffer, 
        // we just copy as many bytes as we can. Once the buffer is full, we just discard 
        // the rest of the data, and complete the IRP sucessfully even we only did a partial copy.
        // 
        while (BytesRemaining && (pNdisBuffer != NULL))
        {
#ifndef WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &pSrc, &BytesAvailable, NormalPagePriority);

            if (pSrc == NULL) 
            {
                DEBUGP(DL_FATAL,
                    ("ServiceReads: Open %p, QueryBuffer failed for buffer %p\n",
                            pOpenContext, pNdisBuffer));
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &pSrc, &BytesAvailable);
#endif

            if (BytesAvailable)
            {
                ULONG       BytesToCopy = MIN(BytesAvailable, BytesRemaining);

                NUIO_COPY_MEM(pDst, pSrc, BytesToCopy);
                BytesRemaining -= BytesToCopy;
                pDst += BytesToCopy;
            }

            NdisGetNextBuffer(pNdisBuffer, &pNdisBuffer);
        }

        //
        //  Complete the IRP.
        //
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = MmGetMdlByteCount(pIrp->MdlAddress) - BytesRemaining;

        DEBUGP(DL_INFO, ("ServiceReads: Open %p, IRP %p completed with %d bytes\n",
            pOpenContext, pIrp, pIrp->IoStatus.Information));

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        //
        //  Free up the receive packet - back to the miniport if it
        //  belongs to it, else reclaim it (local copy).
        //
        if (NdisGetPoolFromPacket(pRcvPacket) != pOpenContext->RecvPacketPool)
        {
            NdisReturnPackets(&pRcvPacket, 1);
        }
        else
        {
            ndisuioFreeReceivePacket(pOpenContext, pRcvPacket);
        }

        NUIO_DEREF_OPEN(pOpenContext);    // took out pended Read

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
        pOpenContext->PendedReadCount--;

    }

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    NUIO_DEREF_OPEN(pOpenContext);    // temp ref - service reads
}




NDIS_STATUS
NdisuioReceive(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  MacReceiveContext,
    IN PVOID                        pHeaderBuffer,
    IN UINT                         HeaderBufferSize,
    IN PVOID                        pLookaheadBuffer,
    IN UINT                         LookaheadBufferSize,
    IN UINT                         PacketSize
    )
/*++

Routine Description:

    Our protocol receive handler called by NDIS, typically if we have
    a miniport below that doesn't indicate packets.

    We make a local packet/buffer copy of this data, queue it up, and
    kick off the read service routine.

Arguments:

    ProtocolBindingContext - pointer to open context
    MacReceiveContext - for use in NdisTransferData
    pHeaderBuffer - pointer to data header
    HeaderBufferSize - size of the above
    pLookaheadBuffer - pointer to buffer containing lookahead data
    LookaheadBufferSize - size of the above
    PacketSize - size of the entire packet, minus header size.

Return Value:

    NDIS_STATUS_NOT_ACCEPTED - if this packet is uninteresting
    NDIS_STATUS_SUCCESS - if we processed this successfully

--*/
{
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    NDIS_STATUS             Status;
    PNDISUIO_ETH_HEADER     pEthHeader;
    PNDIS_PACKET            pRcvPacket;
    PUCHAR                  pRcvData;
    UINT                    BytesTransferred;
    PNDIS_BUFFER            pOriginalNdisBuffer, pPartialNdisBuffer;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);
    pRcvPacket = NULL;
    pRcvData = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        if (HeaderBufferSize != sizeof(NDISUIO_ETH_HEADER))
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pEthHeader = (PNDISUIO_ETH_HEADER)pHeaderBuffer;

        //
        //  Check the EtherType. If the Ether type indicates presence of
        //  a tag, then the "real" Ether type is 4 bytes further down.
        //
        if (pEthHeader->EthType == NUIO_8021P_TAG_TYPE)
        {
            USHORT UNALIGNED *pEthType;

            pEthType = (USHORT UNALIGNED *)((PUCHAR)&pEthHeader->EthType + 4);

            if (*pEthType != Globals.EthType)
            {
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
            }
        }
        else if (pEthHeader->EthType != Globals.EthType)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        //
        //  Allocate resources for queueing this up.
        //
        pRcvPacket = ndisuioAllocateReceivePacket(
                        pOpenContext,
                        PacketSize + HeaderBufferSize,
                        &pRcvData
                        );

        if (pRcvPacket == NULL)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        NdisMoveMappedMemory(pRcvData, pHeaderBuffer, HeaderBufferSize);

        //
        //  Check if the entire packet is within the lookahead.
        //
        if (PacketSize == LookaheadBufferSize)
        {
            NdisCopyLookaheadData(pRcvData+HeaderBufferSize,
                                  pLookaheadBuffer,
                                  LookaheadBufferSize,
                                  pOpenContext->MacOptions);
            //
            //  Queue this up for receive processing, and
            //  try to complete some read IRPs.
            //
            ndisuioQueueReceivePacket(pOpenContext, pRcvPacket);
        }
        else
        {
            //
            //  Allocate an NDIS buffer to map the receive area
            //  at an offset "HeaderBufferSize" from the current
            //  start. This is so that NdisTransferData can copy
            //  in at the right point in the destination buffer.
            //

            NdisAllocateBuffer(
                &Status,
                &pPartialNdisBuffer,
                pOpenContext->RecvBufferPool,
                pRcvData + HeaderBufferSize,
                PacketSize);
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                //  Unlink and save away the original NDIS Buffer
                //  that maps the full receive buffer.
                //
                NdisUnchainBufferAtFront(pRcvPacket, &pOriginalNdisBuffer);
                NUIO_RCV_PKT_TO_ORIGINAL_BUFFER(pRcvPacket) = pOriginalNdisBuffer;

                //
                //  Link in the partial buffer for NdisTransferData to
                //  operate on.
                //
                NdisChainBufferAtBack(pRcvPacket, pPartialNdisBuffer);

                DEBUGP(DL_LOUD, ("Receive: setting up for TransferData:"
                        " Pkt %p, OriginalBuf %p, PartialBuf %p\n",
                        pRcvPacket, pOriginalNdisBuffer, pPartialNdisBuffer));

                NdisTransferData(
                    &Status,
                    pOpenContext->BindingHandle,
                    MacReceiveContext,
                    0,  // ByteOffset
                    PacketSize,
                    pRcvPacket,
                    &BytesTransferred);
            }
            else
            {
                //
                //  Failure handled below in TransferDataComplete.
                //
                BytesTransferred = 0;
            }
    
            if (Status != NDIS_STATUS_PENDING)
            {
                NdisuioTransferDataComplete(
                    (NDIS_HANDLE)pOpenContext,
                    pRcvPacket,
                    Status,
                    BytesTransferred);
            }
        }

    }
    while (FALSE);


    DEBUGP(DL_LOUD, ("Receive: Open %p, Pkt %p, Size %d\n",
            pOpenContext, pRcvPacket, PacketSize));

    return Status;
}



VOID
NdisuioTransferDataComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  TransferStatus,
    IN UINT                         BytesTransferred
    )
/*++

Routine Description:

    NDIS entry point called to signal completion of a call to
    NdisTransferData that had pended.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - our receive packet into which data is transferred
    TransferStatus - status of the transfer
    BytesTransferred - bytes copied into the packet.

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    PNDIS_BUFFER            pOriginalBuffer, pPartialBuffer;

    UNREFERENCED_PARAMETER(BytesTransferred);
	
    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Check if an NDIS_BUFFER was created to map part of the receive buffer;
    //  if so, free it and link back the original NDIS_BUFFER that maps
    //  the full receive buffer to the packet.
    //
    pOriginalBuffer = NUIO_RCV_PKT_TO_ORIGINAL_BUFFER(pNdisPacket);
    if (pOriginalBuffer != NULL)
    {
        //
        //  We had stashed off the NDIS_BUFFER for the full receive
        //  buffer in the packet reserved area. Unlink the partial
        //  buffer and link in the full buffer.
        //
        NdisUnchainBufferAtFront(pNdisPacket, &pPartialBuffer);
        NdisChainBufferAtBack(pNdisPacket, pOriginalBuffer);

        DEBUGP(DL_LOUD, ("TransferComp: Pkt %p, OrigBuf %p, PartialBuf %p\n",
                pNdisPacket, pOriginalBuffer, pPartialBuffer));

        //
        //  Free up the partial buffer.
        //
        NdisFreeBuffer(pPartialBuffer);
    }

    if (TransferStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  Queue this up for receive processing, and
        //  try to complete some read IRPs.
        //
        ndisuioQueueReceivePacket(pOpenContext, pNdisPacket);
    }
    else
    {
        ndisuioFreeReceivePacket(pOpenContext, pNdisPacket);
    }
}


VOID
NdisuioReceiveComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    )
/*++

Routine Description:

    Protocol entry point called by NDIS when the miniport
    has finished indicating up a batch of receives.

    We ignore this.

Arguments:

    ProtocolBindingContext - pointer to open context

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT   pOpenContext;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    return;
}


INT
NdisuioReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    )
/*++

Routine Description:

    Protocol entry point called by NDIS if the driver below
    uses NDIS 4 style receive packet indications.

    If the miniport allows us to hold on to this packet, we
    use it as is, otherwise we make a copy.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - the packet being indicated up.

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    PNDIS_BUFFER            pNdisBuffer;
    UINT                    BufferLength;
    PNDISUIO_ETH_HEADER     pEthHeader;
    PNDIS_PACKET            pCopyPacket;
    PUCHAR                  pCopyBuf;
    UINT                    TotalPacketLength;
    UINT                    BytesCopied;
    INT                     RefCount = 0;
    NDIS_STATUS             Status;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

#ifdef NDIS51
    NdisGetFirstBufferFromPacketSafe(
        pNdisPacket,
        &pNdisBuffer,
        &pEthHeader,
        &BufferLength,
        &TotalPacketLength,
        NormalPagePriority);

    if (pEthHeader == NULL)
    {
        //
        //  The system is low on resources. Set up to handle failure
        //  below.
        //
        BufferLength = 0;
    }
#else
    NdisGetFirstBufferFromPacket(
        pNdisPacket,
        &pNdisBuffer,
        &pEthHeader,
        &BufferLength,
        &TotalPacketLength);
#endif

    do
    {
        if (BufferLength < sizeof(NDISUIO_ETH_HEADER))
        {
            DEBUGP(DL_WARN,
                ("ReceivePacket: Open %p, runt pkt %p, first buffer length %d\n",
                    pOpenContext, pNdisPacket, BufferLength));

            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        //
        //  Check the EtherType. If the Ether type indicates presence of
        //  a tag, then the "real" Ether type is 4 bytes further down.
        //
        if (pEthHeader->EthType == NUIO_8021P_TAG_TYPE)
        {
            USHORT UNALIGNED *pEthType;

            pEthType = (USHORT UNALIGNED *)((PUCHAR)&pEthHeader->EthType + 4);

            if (*pEthType != Globals.EthType)
            {
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
            }
        }
        else if (pEthHeader->EthType != Globals.EthType)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        DEBUGP(DL_LOUD, ("ReceivePacket: Open %p, interesting pkt %p\n",
                    pOpenContext, pNdisPacket));

        //
        //  If the miniport is out of resources, we can't queue
        //  this packet - make a copy if this is so.
        //
        if ((NDIS_GET_PACKET_STATUS(pNdisPacket) == NDIS_STATUS_RESOURCES) ||
            pOpenContext->bRunningOnWin9x)
        {
            pCopyPacket = ndisuioAllocateReceivePacket(
                            pOpenContext,
                            TotalPacketLength,
                            &pCopyBuf
                            );
            
            if (pCopyPacket == NULL)
            {
                DEBUGP(DL_FATAL, ("ReceivePacket: Open %p, failed to"
                    " alloc copy, %d bytes\n", pOpenContext, TotalPacketLength));
                break;
            }

            NdisCopyFromPacketToPacket(
                pCopyPacket,
                0,
                TotalPacketLength,
                pNdisPacket,
                0,
                &BytesCopied);
            
            NUIO_ASSERT(BytesCopied == TotalPacketLength);

            pNdisPacket = pCopyPacket;
        }
        else
        {
            //
            //  We can queue the original packet - return
            //  a packet reference count indicating that
            //  we will call NdisReturnPackets when we are
            //  done with this packet.
            //
            RefCount = 1;
        }

        //
        //  Queue this up and service any pending Read IRPs.
        //
        ndisuioQueueReceivePacket(pOpenContext, pNdisPacket);
    
    }
    while (FALSE);

    return (RefCount);
}


VOID
ndisuioQueueReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pRcvPacket
    )
/*++

Routine Description:

    Queue up a received packet on the open context structure.
    If the queue size goes beyond a water mark, discard a packet
    at the head of the queue.

    Finally, run the queue service routine.

Arguments:
    
    pOpenContext - pointer to open context
    pRcvPacket - the received packet

Return Value:

    None

--*/
{
    PLIST_ENTRY     pEnt;
    PLIST_ENTRY     pDiscardEnt;
    PNDIS_PACKET    pDiscardPkt;

    do
    {
        pEnt = NUIO_RCV_PKT_TO_LIST_ENTRY(pRcvPacket);

        NUIO_REF_OPEN(pOpenContext);    // queued rcv packet

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if the binding is in the proper state to receive
        //  this packet.
        //
        if (NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE) &&
            (pOpenContext->PowerState == NetDeviceStateD0))
        {
            NUIO_INSERT_TAIL_LIST(&pOpenContext->RecvPktQueue, pEnt);
            pOpenContext->RecvPktCount++;

            DEBUGP(DL_VERY_LOUD, ("QueueReceivePacket: open %p,"
                    " queued pkt %p, queue size %d\n",
                    pOpenContext, pRcvPacket, pOpenContext->RecvPktCount));
        }
        else
        {
            //
            //  Received this packet when the binding is going away.
            //  Drop this.
            //
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            ndisuioFreeReceivePacket(pOpenContext, pRcvPacket);

            NUIO_DEREF_OPEN(pOpenContext);  // dropped rcv packet - bad state
            break;
        }

        //
        //  Trim the queue if it has grown too big.
        //
        if (pOpenContext->RecvPktCount > MAX_RECV_QUEUE_SIZE)
        {
            //
            //  Remove the head of the queue.
            //
            pDiscardEnt = pOpenContext->RecvPktQueue.Flink;
            NUIO_REMOVE_ENTRY_LIST(pDiscardEnt);

            pOpenContext->RecvPktCount --;

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            pDiscardPkt = NUIO_LIST_ENTRY_TO_RCV_PKT(pDiscardEnt);

            ndisuioFreeReceivePacket(pOpenContext, pDiscardPkt);

            NUIO_DEREF_OPEN(pOpenContext);  // dropped rcv packet - queue too long

            DEBUGP(DL_INFO, ("QueueReceivePacket: open %p queue"
                    " too long, discarded pkt %p\n",
                    pOpenContext, pDiscardPkt));
        }
        else
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
        }

        //
        //  Run the receive queue service routine now.
        //
        ndisuioServiceReads(pOpenContext);
    }
    while (FALSE);
}


PNDIS_PACKET
ndisuioAllocateReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN UINT                         DataLength,
    OUT PUCHAR *                    ppDataBuffer
    )
/*++

Routine Description:

    Allocate resources to copy and queue a received packet.

Arguments:

    pOpenContext - pointer to open context for received packet
    DataLength - total length in bytes of the packet
    ppDataBuffer - place to return pointer to allocated buffer

Return Value:

    Pointer to NDIS packet if successful, else NULL.

--*/
{
    PNDIS_PACKET            pNdisPacket;
    PNDIS_BUFFER            pNdisBuffer;
    PUCHAR                  pDataBuffer;
    NDIS_STATUS             Status;

    pNdisPacket = NULL;
    pNdisBuffer = NULL;
    pDataBuffer = NULL;

    do
    {
        NUIO_ALLOC_MEM(pDataBuffer, DataLength);

        if (pDataBuffer == NULL)
        {
            DEBUGP(DL_FATAL, ("AllocRcvPkt: open %p, failed to alloc"
                " data buffer %d bytes\n", pOpenContext, DataLength));
            break;
        }

        //
        //  Make this an NDIS buffer.
        //
        NdisAllocateBuffer(
            &Status,
            &pNdisBuffer,
            pOpenContext->RecvBufferPool,
            pDataBuffer,
            DataLength);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_FATAL, ("AllocateRcvPkt: open %p, failed to alloc"
                " NDIS buffer, %d bytes\n", pOpenContext, DataLength));
            break;
        }

        NdisAllocatePacket(&Status, &pNdisPacket, pOpenContext->RecvPacketPool);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_FATAL, ("AllocateRcvPkt: open %p, failed to alloc"
                " NDIS packet, %d bytes\n", pOpenContext, DataLength));
            break;
        }

        NDIS_SET_PACKET_STATUS(pNdisPacket, 0);
        NUIO_RCV_PKT_TO_ORIGINAL_BUFFER(pNdisPacket) = NULL;

        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

        *ppDataBuffer = pDataBuffer;

      
    }
    while (FALSE);

    if (pNdisPacket == NULL)
    {
        //
        //  Clean up
        //
        if (pNdisBuffer != NULL)
        {
            NdisFreeBuffer(pNdisBuffer);
        }

        if (pDataBuffer != NULL)
        {
            NUIO_FREE_MEM(pDataBuffer);
        }
    }

    return (pNdisPacket);
}



VOID
ndisuioFreeReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pNdisPacket
    )
/*++

Routine Description:

    Free up all resources associated with a received packet. If this
    is a local copy, free the packet to our receive pool, else return
    this to the miniport.

Arguments:
    
    pOpenContext - pointer to open context
    pNdisPacket - pointer to packet to be freed.

Return Value:

    None

--*/
{
    PNDIS_BUFFER        pNdisBuffer;
    UINT                TotalLength;
    UINT                BufferLength;
    PUCHAR              pCopyData;

    if (NdisGetPoolFromPacket(pNdisPacket) == pOpenContext->RecvPacketPool)
    {
        //
        //  This is a local copy.
        //
#ifdef NDIS51
        NdisGetFirstBufferFromPacketSafe(
            pNdisPacket,
            &pNdisBuffer,
            (PVOID *)&pCopyData,
            &BufferLength,
            &TotalLength,
            NormalPagePriority);
#else
        NdisGetFirstBufferFromPacket(
            pNdisPacket,
            &pNdisBuffer,
            (PVOID *)&pCopyData,
            &BufferLength,
            &TotalLength);
#endif

        NUIO_ASSERT(BufferLength == TotalLength);

        NUIO_ASSERT(pNdisBuffer != NULL);

        NUIO_ASSERT(pCopyData != NULL); // we would have allocated non-paged pool

        NdisFreePacket(pNdisPacket);

        NdisFreeBuffer(pNdisBuffer);

        NUIO_FREE_MEM(pCopyData);
    }
    else
    {
        NdisReturnPackets(&pNdisPacket, 1);
    }
}
        

VOID
ndisuioCancelPendingReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Cancel any pending read IRPs queued on the given open.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PIRP                pIrp;
    PLIST_ENTRY         pIrpEntry;

    NUIO_REF_OPEN(pOpenContext);  // temp ref - cancel reads

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    while (!NUIO_IS_LIST_EMPTY(&pOpenContext->PendedReads))
    {
        //
        //  Get the first pended Read IRP
        //
        pIrpEntry = pOpenContext->PendedReads.Flink;
        pIrp = CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry);

        //
        //  Check to see if it is being cancelled.
        //
        if (IoSetCancelRoutine(pIrp, NULL))
        {
            //
            //  It isn't being cancelled, and can't be cancelled henceforth.
            //
            NUIO_REMOVE_ENTRY_LIST(pIrpEntry);

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            //
            //  Complete the IRP.
            //
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            DEBUGP(DL_INFO, ("CancelPendingReads: Open %p, IRP %p cancelled\n",
                pOpenContext, pIrp));

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);

            NUIO_DEREF_OPEN(pOpenContext);    // took out pended Read for cancelling

            NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
            pOpenContext->PendedReadCount--;
        }
        else
        {
            //
            //  It is being cancelled, let the cancel routine handle it.
            //
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            //
            //  Give the cancel routine some breathing space, otherwise
            //  we might end up examining the same (cancelled) IRP over
            //  and over again.
            //
            NUIO_SLEEP(1);

            NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
        }
    }

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    NUIO_DEREF_OPEN(pOpenContext);    // temp ref - cancel reads
}


VOID
ndisuioFlushReceiveQueue(
    IN PNDISUIO_OPEN_CONTEXT            pOpenContext
    )
/*++

Routine Description:

    Free any receive packets queued up on the specified open

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    PLIST_ENTRY         pRcvPacketEntry;
    PNDIS_PACKET        pRcvPacket;

    NUIO_REF_OPEN(pOpenContext);  // temp ref - flushRcvQueue

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
    
    while (!NUIO_IS_LIST_EMPTY(&pOpenContext->RecvPktQueue))
    {
        //
        //  Get the first queued receive packet
        //
        pRcvPacketEntry = pOpenContext->RecvPktQueue.Flink;
        NUIO_REMOVE_ENTRY_LIST(pRcvPacketEntry);

        pOpenContext->RecvPktCount --;

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        pRcvPacket = NUIO_LIST_ENTRY_TO_RCV_PKT(pRcvPacketEntry);

        DEBUGP(DL_LOUD, ("FlushReceiveQueue: open %p, pkt %p\n",
            pOpenContext, pRcvPacket));

        ndisuioFreeReceivePacket(pOpenContext, pRcvPacket);

        NUIO_DEREF_OPEN(pOpenContext);    // took out pended Read

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
    }

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    NUIO_DEREF_OPEN(pOpenContext);    // temp ref - flushRcvQueue
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\ntdisp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ntdisp.c

Abstract:

    NT Entry points and dispatch routines for NDISUIO.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/6/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'PSID'


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NdisuioUnload)
#pragma alloc_text(PAGE, NdisuioOpen)
#pragma alloc_text(PAGE, NdisuioClose)
#pragma alloc_text(PAGE, NdisuioIoControl)

#endif // ALLOC_PRAGMA


//
//  Globals:
//
NDISUIO_GLOBALS         Globals = {0};

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    )
/*++

Routine Description:

    Called on loading. We create a device object to handle user-mode requests
    on, and register ourselves as a protocol with NDIS.

Arguments:

    pDriverObject - Pointer to driver object created by system.

    pRegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    NT Status code
    
--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS   protocolChar;
    NTSTATUS                        status = STATUS_SUCCESS;
    NDIS_STRING                     protoName = NDIS_STRING_CONST("NDISUIO");     
    UNICODE_STRING                  ntDeviceName;
    UNICODE_STRING                  win32DeviceName;
    BOOLEAN                         fSymbolicLink = FALSE;
    PDEVICE_OBJECT                  deviceObject = NULL;

    UNREFERENCED_PARAMETER(pRegistryPath);
	
    DEBUGP(DL_LOUD, ("DriverEntry\n"));

    Globals.pDriverObject = pDriverObject;
    Globals.EthType = NUIO_ETH_TYPE;
    NUIO_INIT_EVENT(&Globals.BindsComplete);

    do
    {

        //
        // Create our device object using which an application can
        // access NDIS devices.
        //
        RtlInitUnicodeString(&ntDeviceName, NT_DEVICE_NAME);

        status = IoCreateDevice (pDriverObject,
                                 0,
                                 &ntDeviceName,
                                 FILE_DEVICE_NETWORK,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &deviceObject);

    
        if (!NT_SUCCESS (status))
        {
            //
            // Either not enough memory to create a deviceobject or another
            // deviceobject with the same name exits. This could happen
            // if you install another instance of this device.
            //
            break;
        }

        RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

        status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

        if (!NT_SUCCESS(status))
        {
            break;
        }

        fSymbolicLink = TRUE;
    
        deviceObject->Flags |= DO_DIRECT_IO;
        Globals.ControlDeviceObject = deviceObject;

        NUIO_INIT_LIST_HEAD(&Globals.OpenList);
        NUIO_INIT_LOCK(&Globals.GlobalLock);

        //
        // Initialize the protocol characterstic structure
        //
    
        NdisZeroMemory(&protocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        protocolChar.MajorNdisVersion            = 5;
        protocolChar.MinorNdisVersion            = 0;
        protocolChar.Name                        = protoName;
        protocolChar.OpenAdapterCompleteHandler  = NdisuioOpenAdapterComplete;
        protocolChar.CloseAdapterCompleteHandler = NdisuioCloseAdapterComplete;
        protocolChar.SendCompleteHandler         = NdisuioSendComplete;
        protocolChar.TransferDataCompleteHandler = NdisuioTransferDataComplete;
        protocolChar.ResetCompleteHandler        = NdisuioResetComplete;
        protocolChar.RequestCompleteHandler      = NdisuioRequestComplete;
        protocolChar.ReceiveHandler              = NdisuioReceive;
        protocolChar.ReceiveCompleteHandler      = NdisuioReceiveComplete;
        protocolChar.StatusHandler               = NdisuioStatus;
        protocolChar.StatusCompleteHandler       = NdisuioStatusComplete;
        protocolChar.BindAdapterHandler          = NdisuioBindAdapter;
        protocolChar.UnbindAdapterHandler        = NdisuioUnbindAdapter;
        protocolChar.UnloadHandler               = NULL;
        protocolChar.ReceivePacketHandler        = NdisuioReceivePacket;
        protocolChar.PnPEventHandler             = NdisuioPnPEventHandler;

        //
        // Register as a protocol driver
        //
    
        NdisRegisterProtocol(
            (PNDIS_STATUS)&status,
            &Globals.NdisProtocolHandle,
            &protocolChar,
            sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("Failed to register protocol with NDIS\n"));
            status = STATUS_UNSUCCESSFUL;
            break;
        }

#ifdef NDIS51
        Globals.PartialCancelId = NdisGeneratePartialCancelId();
        Globals.PartialCancelId <<= ((sizeof(PVOID) - 1) * 8);
        DEBUGP(DL_LOUD, ("DriverEntry: CancelId %lx\n", Globals.PartialCancelId));
#endif

        //
        // Now set only the dispatch points we would like to handle.
        //
        pDriverObject->MajorFunction[IRP_MJ_CREATE] = NdisuioOpen;
        pDriverObject->MajorFunction[IRP_MJ_CLOSE]  = NdisuioClose;
        pDriverObject->MajorFunction[IRP_MJ_READ]   = NdisuioRead;
        pDriverObject->MajorFunction[IRP_MJ_WRITE]  = NdisuioWrite;
        pDriverObject->MajorFunction[IRP_MJ_CLEANUP]  = NdisuioCleanup;
        pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = NdisuioIoControl;
        pDriverObject->DriverUnload = NdisuioUnload;
    
        status = STATUS_SUCCESS;

    }
    while (FALSE);
       

    if (!NT_SUCCESS(status))
    {
        if (deviceObject)
        {
            IoDeleteDevice(deviceObject);
            Globals.ControlDeviceObject = NULL;
        }

        if (fSymbolicLink)
        {
            IoDeleteSymbolicLink(&win32DeviceName);
        }

    }
    
    return status;

}


VOID
NdisuioUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    UNICODE_STRING     win32DeviceName;

    UNREFERENCED_PARAMETER(DriverObject);
	
    DEBUGP(DL_LOUD, ("Unload Enter\n"));

    //
    // First delete the Control deviceobject and the corresponding
    // symbolicLink
    //
    RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

    IoDeleteSymbolicLink(&win32DeviceName);           

    if (Globals.ControlDeviceObject)
    {
        IoDeleteDevice(Globals.ControlDeviceObject);
        Globals.ControlDeviceObject = NULL;
    }

    ndisuioDoProtocolUnload();

#if DBG
    ndisuioAuditShutdown();
#endif

    DEBUGP(DL_LOUD, ("Unload Exit\n"));
}



NTSTATUS
NdisuioOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CREATE.
    We simply succeed this.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->FileObject->FsContext = NULL;

    DEBUGP(DL_INFO, ("Open: FileObject %p\n", pIrpSp->FileObject));

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return NtStatus;
}

NTSTATUS
NdisuioClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CLOSE.
    We simply succeed this.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS                NtStatus;
    PIO_STACK_LOCATION      pIrpSp;
    PNDISUIO_OPEN_CONTEXT   pOpenContext;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    DEBUGP(DL_INFO, ("Close: FileObject %p\n",
        IoGetCurrentIrpStackLocation(pIrp)->FileObject));

    if (pOpenContext != NULL)
    {
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Deref the endpoint
        //
        NUIO_DEREF_OPEN(pOpenContext);  // Close
    }

    pIrpSp->FileObject->FsContext = NULL;
    NtStatus = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return NtStatus;
}

    

NTSTATUS
NdisuioCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling IRP_MJ_CLEANUP.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                NtStatus;
    NDIS_STATUS             NdisStatus;
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    ULONG                   PacketFilter;
    ULONG                   BytesProcessed;

    
    UNREFERENCED_PARAMETER(pDeviceObject);
	
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    DEBUGP(DL_VERY_LOUD, ("Cleanup: FileObject %p, Open %p\n",
        pIrpSp->FileObject, pOpenContext));

    if (pOpenContext != NULL)
    {
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Mark this endpoint.
        //
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE);
        pOpenContext->pFileObject = NULL;

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set the packet filter to 0, telling NDIS that we aren't
        //  interested in any more receives.
        //
        PacketFilter = 0;
        NdisStatus = ndisuioValidateOpenAndDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesProcessed,
                        FALSE   // Don't wait for device to be powered on
                        );
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_INFO, ("Cleanup: Open %p, set packet filter (%x) failed: %x\n",
                    pOpenContext, PacketFilter, NdisStatus));
            //
            //  Ignore the result. If this failed, we may continue
            //  to get indicated receives, which will be handled
            //  appropriately.
            //
            NdisStatus = NDIS_STATUS_SUCCESS;
        }

        //
        //  Cancel any pending reads.
        //
        ndisuioCancelPendingReads(pOpenContext);
        //
        // Clean up the receive packet queue
        //
        ndisuioFlushReceiveQueue(pOpenContext);
    }

    NtStatus = STATUS_SUCCESS;

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = NtStatus;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    DEBUGP(DL_INFO, ("Cleanup: OpenContext %p\n", pOpenContext));

    return (NtStatus);
}

NTSTATUS
NdisuioIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This is the dispatch routine for handling device ioctl requests.

Arguments:

    pDeviceObject - Pointer to the device object.

    pIrp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   FunctionCode;
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    ULONG                   BytesReturned;
    USHORT                  EthType;

#if !DBG
    UNREFERENCED_PARAMETER(pDeviceObject);
#endif
    
    DEBUGP(DL_LOUD, ("IoControl: DevObj %p, Irp %p\n", pDeviceObject, pIrp));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    FunctionCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    pOpenContext = (PNDISUIO_OPEN_CONTEXT)pIrpSp->FileObject->FsContext;
    BytesReturned = 0;

    switch (FunctionCode)
    {
        case IOCTL_NDISUIO_BIND_WAIT:
            //
            //  Block until we have seen a NetEventBindsComplete event,
            //  meaning that we have finished binding to all running
            //  adapters that we are supposed to bind to.
            //
            //  If we don't get this event in 5 seconds, time out.
            //
            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            
            if (NUIO_WAIT_EVENT(&Globals.BindsComplete, 5000))
            {
                NtStatus = STATUS_SUCCESS;
            }
            else
            {
                NtStatus = STATUS_TIMEOUT;
            }
            DEBUGP(DL_INFO, ("IoControl: BindWait returning %x\n", NtStatus));
            break;

        case IOCTL_NDISUIO_QUERY_BINDING:
            
            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            
            Status = ndisuioQueryBinding(
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &BytesReturned
                            );

            NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);

            DEBUGP(DL_LOUD, ("IoControl: QueryBinding returning %x\n", NtStatus));

            break;

        case IOCTL_NDISUIO_OPEN_DEVICE:

            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                NUIO_STRUCT_ASSERT(pOpenContext, oc);
                DEBUGP(DL_WARN, ("IoControl: OPEN_DEVICE: FileObj %p already"
                    " associated with open %p\n", pIrpSp->FileObject, pOpenContext));

                NtStatus = STATUS_DEVICE_BUSY;
                break;
            }

            NtStatus = ndisuioOpenDevice(
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            pIrpSp->FileObject,
                            &pOpenContext
                            );

            if (NT_SUCCESS(NtStatus))
            {

                DEBUGP(DL_VERY_LOUD, ("IoControl OPEN_DEVICE: Open %p <-> FileObject %p\n",
                        pOpenContext, pIrpSp->FileObject));

            }

            break;

        case IOCTL_NDISUIO_QUERY_OID_VALUE:

            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                Status = ndisuioQueryOidValue(
                            pOpenContext,
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            &BytesReturned
                            );

                NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            }
            else
            {
                NtStatus = STATUS_DEVICE_NOT_CONNECTED;
            }
            break;

        case IOCTL_NDISUIO_SET_OID_VALUE:

            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pOpenContext != NULL)
            {
                Status = ndisuioSetOidValue(
                            pOpenContext,
                            pIrp->AssociatedIrp.SystemBuffer,
                            pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            );

                BytesReturned = 0;

                NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            }
            else
            {
                NtStatus = STATUS_DEVICE_NOT_CONNECTED;
            }
            break;

        case IOCTL_NDISUIO_SET_ETHER_TYPE:
            
            NUIO_ASSERT((FunctionCode & 0x3) == METHOD_BUFFERED);
            if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Globals.EthType))
            {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                //
                //  We only allow this value to be set to certain types.
                //
                EthType = *(USHORT *)pIrp->AssociatedIrp.SystemBuffer;
                if (EthType != NUIO_ETH_TYPE)
                {
                    DEBUGP(DL_WARN, ("IoControl: failed setting EthType to %x\n",
                            EthType));
                    NtStatus = STATUS_INVALID_PARAMETER;
                    break;
                }

                Globals.EthType = EthType;
                DEBUGP(DL_INFO, ("IoControl: new Ether Type %x\n", Globals.EthType));
                NtStatus = STATUS_SUCCESS;
            }
            break;
                        
        default:

            NtStatus = STATUS_NOT_SUPPORTED;
            break;
    }

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Information = BytesReturned;
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return NtStatus;
}



NTSTATUS
ndisuioOpenDevice(
    IN PUCHAR                   pDeviceName,
    IN ULONG                    DeviceNameLength,
    IN PFILE_OBJECT             pFileObject,
    OUT PNDISUIO_OPEN_CONTEXT * ppOpenContext
    )
/*++

Routine Description:

    Helper routine called to process IOCTL_NDISUIO_OPEN_DEVICE. Check if
    there is a binding to the specified device, and is not associated with
    a file object already. If so, make an association between the binding
    and this file object.

Arguments:

    pDeviceName - pointer to device name string
    DeviceNameLength - length of above
    pFileObject - pointer to file object being associated with the device binding

Return Value:

    Status is returned.
--*/
{
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    NTSTATUS                NtStatus;
    ULONG                   PacketFilter;
    NDIS_STATUS             NdisStatus;
    ULONG                   BytesProcessed;
    PNDISUIO_OPEN_CONTEXT   pCurrentOpenContext = NULL;

    pOpenContext = NULL;

    do
    {
        pOpenContext = ndisuioLookupDevice(
                        pDeviceName,
                        DeviceNameLength
                        );

        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("ndisuioOpenDevice: couldn't find device\n"));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
        }

        //
        //  else ndisuioLookupDevice would have addref'ed the open.
        //
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE))
        {
            NUIO_ASSERT(pOpenContext->pFileObject != NULL);

            DEBUGP(DL_WARN, ("ndisuioOpenDevice: Open %p/%x already associated"
                " with another FileObject %p\n", 
                pOpenContext, pOpenContext->Flags, pOpenContext->pFileObject));
            
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            NUIO_DEREF_OPEN(pOpenContext); // ndisuioOpenDevice failure
            NtStatus = STATUS_DEVICE_BUSY;
            break;
        }
        //
        // This InterlockedXXX function performs an atomic operation: First it compare
        // pFileObject->FsContext with NULL, if they are equal, the function puts  pOpenContext
        // into FsContext, and return NULL. Otherwise, it return pFileObject->FsContext without
        // changing anything.
        // 
            
        if ((pCurrentOpenContext = InterlockedCompareExchangePointer (& (pFileObject->FsContext), pOpenContext, NULL)) != NULL)
        {
            //
            // pFileObject->FsContext already is used by other open
            //
            DEBUGP(DL_WARN, ("ndisuioOpenDevice: FileObject %p already associated"
                " with another Open %p/%x\n", 
                pFileObject, pCurrentOpenContext, pCurrentOpenContext->Flags));  //BUG
            
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            NUIO_DEREF_OPEN(pOpenContext); // ndisuioOpenDevice failure
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        pOpenContext->pFileObject = pFileObject;

        NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_ACTIVE);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set the packet filter now.
        //
        PacketFilter = NUIOO_PACKET_FILTER;
        NdisStatus = ndisuioValidateOpenAndDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesProcessed,
                        TRUE    // Do wait for power on
                        );
    
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("openDevice: Open %p: set packet filter (%x) failed: %x\n",
                    pOpenContext, PacketFilter, NdisStatus));

            //
            //  Undo all that we did above.
            //
            NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);
            //
            // Need to set pFileObject->FsContext to NULL again, so others can open a device
            // for this file object later
            //
            pCurrentOpenContext = InterlockedCompareExchangePointer (& (pFileObject->FsContext), NULL, pOpenContext);
            
     
            NUIO_ASSERT(pCurrentOpenContext == pOpenContext);
            
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_OPEN_FLAGS, NUIOO_OPEN_IDLE);
            pOpenContext->pFileObject = NULL;

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            NUIO_DEREF_OPEN(pOpenContext); // ndisuioOpenDevice failure

            NDIS_STATUS_TO_NT_STATUS(NdisStatus, &NtStatus);
            break;
        }

        *ppOpenContext = pOpenContext;
        
        NtStatus = STATUS_SUCCESS;
    }
    while (FALSE);

    return (NtStatus);
}


VOID
ndisuioRefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Reference the given open context.

    NOTE: Can be called with or without holding the opencontext lock.

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    NdisInterlockedIncrement((PLONG)&pOpenContext->RefCount);
}


VOID
ndisuioDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Dereference the given open context. If the ref count goes to zero,
    free it.

    NOTE: called without holding the opencontext lock

Arguments:

    pOpenContext - pointer to open context

Return Value:

    None

--*/
{
    if (NdisInterlockedDecrement((PLONG)&pOpenContext->RefCount) == 0)
    {
        DEBUGP(DL_INFO, ("DerefOpen: Open %p, Flags %x, ref count is zero!\n",
            pOpenContext, pOpenContext->Flags));
        
        NUIO_ASSERT(pOpenContext->BindingHandle == NULL);
        NUIO_ASSERT(pOpenContext->RefCount == 0);
        NUIO_ASSERT(pOpenContext->pFileObject == NULL);

        pOpenContext->oc_sig++;

        //
        //  Free it.
        //
        NUIO_FREE_MEM(pOpenContext);
    }
}


#if DBG
VOID
ndisuioDbgRefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("  RefOpen: Open %p, old ref %d, File %c%c%c%c, line %d\n",
            pOpenContext,
            pOpenContext->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    ndisuioRefOpen(pOpenContext);
}

VOID
ndisuioDbgDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN ULONG                        FileNumber,
    IN ULONG                        LineNumber
    )
{
    DEBUGP(DL_VERY_LOUD, ("DerefOpen: Open %p, old ref %d, File %c%c%c%c, line %d\n",
            pOpenContext,
            pOpenContext->RefCount,
            (CHAR)(FileNumber),
            (CHAR)(FileNumber >> 8),
            (CHAR)(FileNumber >> 16),
            (CHAR)(FileNumber >> 24),
            LineNumber));

    ndisuioDerefOpen(pOpenContext);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\precomp.h ===
#pragma warning(disable:4214)   // bit field types other than int

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4244)   // conversion from 'int' to 'BOOLEAN', possible loss of data
#pragma warning(disable:4206)   // nonstandard extension used : translation unit is empty

#include "ndis.h"
#include "ntddk.h"
#include "debug.h"
#include "ndisuio.h"
#include "macros.h"
#include "nuiouser.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\test\uiotest.c ===
//
// UIOTEST.C
//
// Test program for ndisuio.sys
//
// usage: UIOTEST [options] <devicename>
//
// options:
//        -e: Enumerate devices
//        -r: Read
//        -w: Write (default)
//        -l <length>: length of each packet (default: %d)\n", PacketLength
//        -n <count>: number of packets (defaults to infinity)
//        -m <MAC address> (defaults to local MAC)
//

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // conditional expression is constant

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>

#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include "nuiouser.h"

#ifndef NDIS_STATUS
#define NDIS_STATUS     ULONG
#endif

#if DBG
#define DEBUGP(stmt)    printf stmt
#else
#define DEBUGP(stmt)
#endif

#define PRINTF(stmt)    printf stmt

#ifndef MAC_ADDR_LEN
#define MAC_ADDR_LEN                    6
#endif

#define MAX_NDIS_DEVICE_NAME_LEN        256

CHAR            NdisuioDevice[] = "\\\\.\\\\Ndisuio";
CHAR *          pNdisuioDevice = &NdisuioDevice[0];

BOOLEAN         DoEnumerate = FALSE;
BOOLEAN         DoReads = FALSE;
INT             NumberOfPackets = -1;
ULONG           PacketLength = 100;
UCHAR           SrcMacAddr[MAC_ADDR_LEN];
UCHAR           DstMacAddr[MAC_ADDR_LEN];
BOOLEAN         bDstMacSpecified = FALSE;
CHAR *          pNdisDeviceName = "JUNK";
USHORT          EthType = 0x8e88;
BOOLEAN         bUseFakeAddress = FALSE;
UCHAR           FakeSrcMacAddr[MAC_ADDR_LEN] = {0};


#include <pshpack1.h>

typedef struct _ETH_HEADER
{
    UCHAR       DstAddr[MAC_ADDR_LEN];
    UCHAR       SrcAddr[MAC_ADDR_LEN];
    USHORT      EthType;
} ETH_HEADER, *PETH_HEADER;

#include <poppack.h>


VOID
PrintUsage()
{
    PRINTF(("usage: UIOTEST [options] <devicename>\n"));
    PRINTF(("options:\n"));
    PRINTF(("       -e: Enumerate devices\n"));
    PRINTF(("       -r: Read\n"));
    PRINTF(("       -w: Write (default)\n"));
    PRINTF(("       -l <length>: length of each packet (default: %d)\n", PacketLength));
    PRINTF(("       -n <count>: number of packets (defaults to infinity)\n"));
    PRINTF(("       -m <MAC address> (defaults to local MAC)\n"));
    PRINTF(("       -f Use a fake address to send out the packets.\n"));
    

}

BOOL
GetOptions(
    INT         argc,
    CHAR        *argv[]
)
{
    BOOL        bOkay;
    INT         i, j, increment;
    CHAR        *pOption;
    ULONG       DstMacAddrUlong[MAC_ADDR_LEN];
    INT         RetVal;

    bOkay = TRUE;

    do
    {
        if (argc < 2)
        {
            PRINTF(("Missing <devicename> argument\n"));
            bOkay = FALSE;
            break;
        }

        i = 1;
        while (i < argc)
        {
            increment = 1;
            pOption = argv[i];

            if ((*pOption == '-') || (*pOption == '/'))
            {
                pOption++;
                if (*pOption == '\0')
                {
                    DEBUGP(("Badly formed option\n"));
                    return (FALSE);
                }
            }
            else
            {
                break;
            }

            switch (*pOption)
            {
                case 'e':
                    DoEnumerate = TRUE;
                    break;
                
                case 'f':
                    bUseFakeAddress = TRUE;
                    break;

                case 'r':
                    DoReads = TRUE;
                    break;

                case 'w':
                    DoReads = FALSE;
                    break;

                case 'l':

                    if (i+1 < argc-1)
                    {
                        RetVal = atoi(argv[i+1]);
                        if (RetVal != 0)
                        {
                            PacketLength = RetVal;
                            DEBUGP((" Option: PacketLength = %d\n", PacketLength));
                            increment = 2;
                            break;
                        }
                    }    
                    PRINTF(("Option l needs PacketLength parameter\n"));
                    return (FALSE);
                
                case 'n':

                    if (i+1 < argc-1)
                    {
                        RetVal = atoi(argv[i+1]);
                        if (RetVal != 0)
                        {
                            NumberOfPackets = RetVal;
                            DEBUGP((" Option: NumberOfPackets = %d\n", NumberOfPackets));
                            increment = 2;
                            break;
                        }
                    }
                    PRINTF(("Option n needs NumberOfPackets parameter\n"));
                    return (FALSE);

                case 'm':

                    if (i+1 < argc-1)
                    {
                        RetVal = sscanf(argv[i+1], "%2x:%2x:%2x:%2x:%2x:%2x",
                                    &DstMacAddrUlong[0],
                                    &DstMacAddrUlong[1],
                                    &DstMacAddrUlong[2],
                                    &DstMacAddrUlong[3],
                                    &DstMacAddrUlong[4],
                                    &DstMacAddrUlong[5]);

                        if (RetVal == 6)
                        {
                            for (j = 0; j < MAC_ADDR_LEN; j++)
                            {
                                DstMacAddr[j] = (UCHAR)DstMacAddrUlong[j];
                            }
    
                            DEBUGP((" Option: Dest MAC Addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
                                DstMacAddr[0],
                                DstMacAddr[1],
                                DstMacAddr[2],
                                DstMacAddr[3],
                                DstMacAddr[4],
                                DstMacAddr[5]));
                            bDstMacSpecified = TRUE;

                            increment = 2;
                            break;
                        }
                    }
                        
                    PRINTF(("Option m needs MAC address parameter\n"));
                    return (FALSE);
                
                case '?':
                    return (FALSE);

                default:
                    PRINTF(("Unknown option %c\n", *pOption));
                    return (FALSE);
            }

            i+= increment;
        }

        pNdisDeviceName = argv[argc-1];
        
    }
    while (FALSE);

    return (bOkay);
}


HANDLE
OpenHandle(
    CHAR    *pDeviceName
)
{
    DWORD   DesiredAccess;
    DWORD   ShareMode;
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes = NULL;

    DWORD   CreationDistribution;
    DWORD   FlagsAndAttributes;
    HANDLE  TemplateFile;
    HANDLE  Handle;
    DWORD   BytesReturned;

    DesiredAccess = GENERIC_READ|GENERIC_WRITE;
    ShareMode = 0;
    CreationDistribution = OPEN_EXISTING;
    FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
    TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

    Handle = CreateFile(
                pDeviceName,
                DesiredAccess,
                ShareMode,
                lpSecurityAttributes,
                CreationDistribution,
                FlagsAndAttributes,
                TemplateFile
            );
    if (Handle == INVALID_HANDLE_VALUE)
    {
        DEBUGP(("Creating file failed, error %x\n", GetLastError()));
        return Handle;
    }
    //
    //  Wait for the driver to finish binding.
    //
    if (!DeviceIoControl(
                Handle,
                IOCTL_NDISUIO_BIND_WAIT,
                NULL,
                0,
                NULL,
                0,
                &BytesReturned,
                NULL))
    {
        DEBUGP(("IOCTL_NDISIO_BIND_WAIT failed, error %x\n", GetLastError()));
        CloseHandle(Handle);
        Handle = INVALID_HANDLE_VALUE;
    }

    return (Handle);
}


BOOL
OpenNdisDevice(     
    HANDLE  Handle,
    CHAR   *pDeviceName
)
{
    WCHAR   wNdisDeviceName[MAX_NDIS_DEVICE_NAME_LEN];
    INT     wNameLength;
    INT     NameLength = strlen(pDeviceName);
    DWORD   BytesReturned;
    INT     i;


    //
    // Convert to unicode string - non-localized...
    //
    wNameLength = 0;
    for (i = 0; i < NameLength && i < MAX_NDIS_DEVICE_NAME_LEN-1; i++)
    {
        wNdisDeviceName[i] = (WCHAR)pDeviceName[i];
        wNameLength++;
    }
    wNdisDeviceName[i] = L'\0';

    DEBUGP(("Trying to access NDIS Device: %ws\n", wNdisDeviceName));

    return (DeviceIoControl(
                Handle,
                IOCTL_NDISUIO_OPEN_DEVICE,
                (LPVOID)&wNdisDeviceName[0],
                wNameLength*sizeof(WCHAR),
                NULL,
                0,
                &BytesReturned,
                NULL));

}


BOOL
GetSrcMac(
    HANDLE  Handle,
    PUCHAR  pSrcMacAddr
    )
{
    DWORD       BytesReturned;
    BOOLEAN     bSuccess;
    UCHAR       QueryBuffer[sizeof(NDISUIO_QUERY_OID) + MAC_ADDR_LEN];
    PNDISUIO_QUERY_OID  pQueryOid;

    
    DEBUGP(("Trying to get src mac address\n"));

    pQueryOid = (PNDISUIO_QUERY_OID)&QueryBuffer[0];
    pQueryOid->Oid = OID_802_3_CURRENT_ADDRESS;

    bSuccess = (BOOLEAN)DeviceIoControl(
                            Handle,
                            IOCTL_NDISUIO_QUERY_OID_VALUE,
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            (LPVOID)&QueryBuffer[0],
                            sizeof(QueryBuffer),
                            &BytesReturned,
                            NULL);

    if (bSuccess)
    {
        DEBUGP(("GetSrcMac: IoControl success, BytesReturned = %d\n",
                BytesReturned));

        memcpy(pSrcMacAddr, pQueryOid->Data, MAC_ADDR_LEN);

                    
    }
    else
    {
        DEBUGP(("GetSrcMac: IoControl failed: %d\n", GetLastError()));
    }

    return (bSuccess);
}



VOID
DoReadProc(
    HANDLE  Handle
    )
{
    PUCHAR      pReadBuf = NULL;
    INT         ReadCount = 0;
    BOOLEAN     bSuccess;
    ULONG       BytesRead;

    DEBUGP(("DoReadProc\n"));

    do
    {
        pReadBuf = malloc(PacketLength);

        if (pReadBuf == NULL)
        {
            PRINTF(("DoReadProc: failed to alloc %d bytes\n", PacketLength));
            break;
        }

        ReadCount = 0; 
        while (TRUE)
        {
            bSuccess = (BOOLEAN)ReadFile(
                                    Handle,
                                    (LPVOID)pReadBuf,
                                    PacketLength,
                                    &BytesRead,
                                    NULL);
            
            if (!bSuccess)
            {
                PRINTF(("DoReadProc: ReadFile failed on Handle %p, error %x\n",
                        Handle, GetLastError()));
                break;
            }
            ReadCount++;

            DEBUGP(("DoReadProc: read pkt # %d, %d bytes\n", ReadCount, BytesRead));

            if ((NumberOfPackets != -1) && (ReadCount == NumberOfPackets))
            {
                break;
            }
        }
    }
    while (FALSE);

    if (pReadBuf)
    {
        free(pReadBuf);
    }

    PRINTF(("DoReadProc finished: read %d packets\n", ReadCount));

}


VOID
DoWriteProc(
    HANDLE  Handle
    )
{
    PUCHAR      pWriteBuf = NULL;
    PUCHAR      pData;
    UINT        i;
    INT         SendCount;
    PETH_HEADER pEthHeader;
    DWORD       BytesWritten;
    BOOLEAN     bSuccess;

    DEBUGP(("DoWriteProc\n"));
    SendCount = 0;

    do
    {
        pWriteBuf = malloc(PacketLength);

        if (pWriteBuf == NULL)
        {
            DEBUGP(("DoWriteProc: Failed to malloc %d bytes\n", PacketLength));
            break;
        }
        pEthHeader = (PETH_HEADER)pWriteBuf;
        pEthHeader->EthType = EthType;
        
        if (bUseFakeAddress)
        {
            memcpy(pEthHeader->SrcAddr, FakeSrcMacAddr, MAC_ADDR_LEN);
        }
        else
        {
            memcpy(pEthHeader->SrcAddr, SrcMacAddr, MAC_ADDR_LEN);
        }
        
        memcpy(pEthHeader->DstAddr, DstMacAddr, MAC_ADDR_LEN);

        pData = (PUCHAR)(pEthHeader + 1);
        for (i = 0; i < PacketLength - sizeof(ETH_HEADER); i++)
        {
            *pData++ = (UCHAR)i;
        }
        
        SendCount = 0;
        
        while (TRUE)
        {
            
            bSuccess = (BOOLEAN)WriteFile(
                                    Handle,
                                    pWriteBuf,
                                    PacketLength,
                                    &BytesWritten,
                                    NULL);
            if (!bSuccess)
            {
                PRINTF(("DoWriteProc: WriteFile failed on Handle %p\n", Handle));
                break;
            }
            SendCount++;
            
            DEBUGP(("DoWriteProc: sent %d bytes\n", BytesWritten));

            if ((NumberOfPackets != -1) && (SendCount == NumberOfPackets))
            {
                break;
            }
        }

    }
    while (FALSE);

    if (pWriteBuf)
    {
        free(pWriteBuf);
    }

    PRINTF(("DoWriteProc: finished sending %d packets of %d bytes each\n",
            SendCount, PacketLength));
}

VOID
EnumerateDevices(
    HANDLE  Handle
    )
{
    CHAR        Buf[1024];
    DWORD       BufLength = sizeof(Buf);
    DWORD       BytesWritten;
    DWORD       i;
    PNDISUIO_QUERY_BINDING pQueryBinding;

    pQueryBinding = (PNDISUIO_QUERY_BINDING)Buf;

    i = 0;
    for (pQueryBinding->BindingIndex = i;
         /* NOTHING */;
         pQueryBinding->BindingIndex = ++i)
    {
        if (DeviceIoControl(
                Handle,
                IOCTL_NDISUIO_QUERY_BINDING,
                pQueryBinding,
                sizeof(NDISUIO_QUERY_BINDING),
                Buf,
                BufLength,
                &BytesWritten,
                NULL))
        {
            PRINTF(("%2d. %ws\n     - %ws\n",
                pQueryBinding->BindingIndex,
                (WCHAR *)((PUCHAR)pQueryBinding + pQueryBinding->DeviceNameOffset),
                (WCHAR *)((PUCHAR )pQueryBinding + pQueryBinding->DeviceDescrOffset)));

            memset(Buf, 0, BufLength);
        }
        else
        {
            ULONG   rc = GetLastError();
            if (rc != ERROR_NO_MORE_ITEMS)
            {
                PRINTF(("EnumerateDevices: terminated abnormally, error %d\n", rc));
            }
            break;
        }
    }
}




VOID __cdecl
main(
    INT         argc,
    CHAR        *argv[]
)
{
    HANDLE      DeviceHandle;

    DeviceHandle = INVALID_HANDLE_VALUE;

    do
    {
        if (!GetOptions(argc, argv))
        {
            PrintUsage();
            break;
        }

        DeviceHandle = OpenHandle(pNdisuioDevice);

        if (DeviceHandle == INVALID_HANDLE_VALUE)
        {
            PRINTF(("Failed to open %s\n", pNdisuioDevice));
            break;
        }

        if (DoEnumerate)
        {
            EnumerateDevices(DeviceHandle);
            break;
        }

        if (!OpenNdisDevice(DeviceHandle, pNdisDeviceName))
        {
            PRINTF(("Failed to access %s\n", pNdisDeviceName));
            break;
        }

        DEBUGP(("Opened device %s successfully!\n", pNdisDeviceName));

        if (!GetSrcMac(DeviceHandle, SrcMacAddr))
        {
            PRINTF(("Failed to obtain local MAC address\n"));
            break;
        }


        DEBUGP(("Got local MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
                    SrcMacAddr[0],
                    SrcMacAddr[1],
                    SrcMacAddr[2],
                    SrcMacAddr[3],
                    SrcMacAddr[4],
                    SrcMacAddr[5]));

        if (!bDstMacSpecified)
        {
            memcpy(DstMacAddr, SrcMacAddr, MAC_ADDR_LEN);
        }

        if (DoReads)
        {
            DoReadProc(DeviceHandle);
        }
        else
        {
            DoWriteProc(DeviceHandle);
            DoReadProc(DeviceHandle);
        }

    }
    while (FALSE);

    if (DeviceHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(DeviceHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\ndisbind.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndisbind.c

Abstract:

    NDIS protocol entry points and utility routines to handle binding
    and unbinding from adapters.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/5/2000    Created

--*/


#include "precomp.h"

#define __FILENUMBER 'DNIB'

NDIS_OID    ndisuioSupportedSetOids[] =
{
	OID_802_11_INFRASTRUCTURE_MODE,
	OID_802_11_AUTHENTICATION_MODE,
	OID_802_11_RELOAD_DEFAULTS,
	OID_802_11_REMOVE_WEP,
	OID_802_11_WEP_STATUS,
	OID_802_11_BSSID_LIST_SCAN,
	OID_802_11_ADD_WEP,
	OID_802_11_SSID,
	OID_802_11_BSSID,
	OID_802_11_BSSID_LIST,
	OID_802_11_DISASSOCIATE,
	OID_802_11_STATISTICS,            // Later used by power management
	OID_802_11_POWER_MODE,            // Later  used by power management
	OID_802_11_NETWORK_TYPE_IN_USE,
	OID_802_11_RSSI,
	OID_802_11_SUPPORTED_RATES,
	OID_802_11_CONFIGURATION,
	OID_802_3_MULTICAST_LIST
};


VOID
NdisuioBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  BindContext,
    IN PNDIS_STRING                 pDeviceName,
    IN PVOID                        SystemSpecific1,
    IN PVOID                        SystemSpecific2
    )
/*++

Routine Description:

    Protocol Bind Handler entry point called when NDIS wants us
    to bind to an adapter. We go ahead and set up a binding.
    An OPEN_CONTEXT structure is allocated to keep state about
    this binding.

Arguments:

    pStatus - place to return bind status
    BindContext - handle to use with NdisCompleteBindAdapter
    DeviceName - adapter to bind to
    SystemSpecific1 - used to access protocol-specific registry
                 key for this binding
    SystemSpecific2 - unused

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT           pOpenContext;
    NDIS_STATUS                     Status, ConfigStatus;
    NDIS_HANDLE                     ConfigHandle;

    UNREFERENCED_PARAMETER(BindContext);
    UNREFERENCED_PARAMETER(SystemSpecific2);
	
    do
    {
        //
        //  Allocate our context for this open.
        //
        NUIO_ALLOC_MEM(pOpenContext, sizeof(NDISUIO_OPEN_CONTEXT));
        if (pOpenContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Initialize it.
        //
        NUIO_ZERO_MEM(pOpenContext, sizeof(NDISUIO_OPEN_CONTEXT));
        NUIO_SET_SIGNATURE(pOpenContext, oc);

        NUIO_INIT_LOCK(&pOpenContext->Lock);
        NUIO_INIT_LIST_HEAD(&pOpenContext->PendedReads);
        NUIO_INIT_LIST_HEAD(&pOpenContext->PendedWrites);
        NUIO_INIT_LIST_HEAD(&pOpenContext->RecvPktQueue);
        NUIO_INIT_EVENT(&pOpenContext->PoweredUpEvent);

        //
        //  Start off by assuming that the device below is powered up.
        //
        NUIO_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);

        //
        //  Determine the platform we are running on.
        //
        pOpenContext->bRunningOnWin9x = TRUE;

        NdisOpenProtocolConfiguration(
            &ConfigStatus,
            &ConfigHandle,
            (PNDIS_STRING)SystemSpecific1);
        
        if (ConfigStatus == NDIS_STATUS_SUCCESS)
        {
            PNDIS_CONFIGURATION_PARAMETER   pParameter;
            NDIS_STRING                     VersionKey = NDIS_STRING_CONST("Environment");

            NdisReadConfiguration(
                &ConfigStatus,
                &pParameter,
                ConfigHandle,
                &VersionKey,
                NdisParameterInteger);
            
            if ((ConfigStatus == NDIS_STATUS_SUCCESS) &&
                ((pParameter->ParameterType == NdisParameterInteger) ||
                 (pParameter->ParameterType == NdisParameterHexInteger)))
            {
                pOpenContext->bRunningOnWin9x =
                    (pParameter->ParameterData.IntegerData == NdisEnvironmentWindows);
            }

            NdisCloseConfiguration(ConfigHandle);
        }

        NUIO_REF_OPEN(pOpenContext); // Bind

        //
        //  Add it to the global list.
        //
        NUIO_ACQUIRE_LOCK(&Globals.GlobalLock);

        NUIO_INSERT_TAIL_LIST(&Globals.OpenList,
                             &pOpenContext->Link);

        NUIO_RELEASE_LOCK(&Globals.GlobalLock);

        //
        //  Set up the NDIS binding.
        //
        Status = ndisuioCreateBinding(
                     pOpenContext,
                     (PUCHAR)pDeviceName->Buffer,
                     pDeviceName->Length);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
    }
    while (FALSE);

    *pStatus = Status;

    return;
}


VOID
NdisuioOpenAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status,
    IN NDIS_STATUS                  OpenErrorCode
    )
/*++

Routine Description:

    Completion routine called by NDIS if our call to NdisOpenAdapter
    pends. Wake up the thread that called NdisOpenAdapter.

Arguments:

    ProtocolBindingContext - pointer to open context structure
    Status - status of the open
    OpenErrorCode - if unsuccessful, additional information

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT           pOpenContext;

    UNREFERENCED_PARAMETER(OpenErrorCode);
	
    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    pOpenContext->BindStatus = Status;

    NUIO_SIGNAL_EVENT(&pOpenContext->BindEvent);
}


VOID
NdisuioUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  UnbindContext
    )
/*++

Routine Description:

    NDIS calls this when it wants us to close the binding to an adapter.

Arguments:

    pStatus - place to return status of Unbind
    ProtocolBindingContext - pointer to open context structure
    UnbindContext - to use in NdisCompleteUnbindAdapter if we return pending

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT           pOpenContext;

    UNREFERENCED_PARAMETER(UnbindContext);
	
    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Mark this open as having seen an Unbind.
    //
    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED);

    //
    //  In case we had threads blocked for the device below to be powered
    //  up, wake them up.
    //
    NUIO_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    ndisuioShutdownBinding(pOpenContext);

    *pStatus = NDIS_STATUS_SUCCESS;
    return;
}


VOID
NdisuioCloseAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    Called by NDIS to complete a pended call to NdisCloseAdapter.
    We wake up the thread waiting for this completion.

Arguments:

    ProtocolBindingContext - pointer to open context structure
    Status - Completion status of NdisCloseAdapter

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT           pOpenContext;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    pOpenContext->BindStatus = Status;

    NUIO_SIGNAL_EVENT(&pOpenContext->BindEvent);
}

    
NDIS_STATUS
NdisuioPnPEventHandler(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNET_PNP_EVENT               pNetPnPEvent
    )
/*++

Routine Description:

    Called by NDIS to notify us of a PNP event. The most significant
    one for us is power state change.

Arguments:

    ProtocolBindingContext - pointer to open context structure
                this is NULL for global reconfig events.

    pNetPnPEvent - pointer to the PNP event

Return Value:

    Our processing status for the PNP event.

--*/
{
    PNDISUIO_OPEN_CONTEXT           pOpenContext;
    NDIS_STATUS                     Status;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;

    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventSetPower:
            NUIO_STRUCT_ASSERT(pOpenContext, oc);
            pOpenContext->PowerState = *(PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

            if (pOpenContext->PowerState > NetDeviceStateD0)
            {
                //
                //  The device below is transitioning to a low power state.
                //  Block any threads attempting to query the device while
                //  in this state.
                //
                NUIO_INIT_EVENT(&pOpenContext->PoweredUpEvent);

                //
                //  Wait for any I/O in progress to complete.
                //
                ndisuioWaitForPendingIO(pOpenContext, FALSE);

                //
                //  Return any receives that we had queued up.
                //
                ndisuioFlushReceiveQueue(pOpenContext);
                DEBUGP(DL_INFO, ("PnPEvent: Open %p, SetPower to %d\n",
                    pOpenContext, pOpenContext->PowerState));
            }
            else
            {
                //
                //  The device below is powered up.
                //
                DEBUGP(DL_INFO, ("PnPEvent: Open %p, SetPower ON: %d\n",
                    pOpenContext, pOpenContext->PowerState));
                NUIO_SIGNAL_EVENT(&pOpenContext->PoweredUpEvent);
            }

            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventQueryPower:
            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventBindsComplete:
            NUIO_SIGNAL_EVENT(&Globals.BindsComplete);
            Status = NDIS_STATUS_SUCCESS;
            break;

        case NetEventQueryRemoveDevice:
        case NetEventCancelRemoveDevice:
        case NetEventReconfigure:
        case NetEventBindList:
        case NetEventPnPCapabilities:
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    DEBUGP(DL_INFO, ("PnPEvent: Open %p, Event %d, Status %x\n",
            pOpenContext, pNetPnPEvent->NetEvent, Status));

    return (Status);
}
    
VOID
NdisuioProtocolUnloadHandler(
    VOID
    )
/*++

Routine Description:

    NDIS calls this on a usermode request to uninstall us.

Arguments:

    None

Return Value:

    None

--*/
{
    ndisuioDoProtocolUnload();
}

NDIS_STATUS
ndisuioCreateBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    )
/*++

Routine Description:

    Utility function to create an NDIS binding to the indicated device,
    if no such binding exists.

    Here is where we also allocate additional resources (e.g. packet pool)
    for the binding.

    Things to take care of:
    1. Is another thread doing this (or has finished binding) already?
    2. Is the binding being closed at this time?
    3. NDIS calls our Unbind handler while we are doing this.

    These precautions are not needed if this routine is only called from
    the context of our BindAdapter handler, but they are here in case
    we initiate binding from elsewhere (e.g. on processing a user command).

    NOTE: this function blocks and finishes synchronously.

Arguments:

    pOpenContext - pointer to open context block
    pBindingInfo - pointer to unicode device name string
    BindingInfoLength - length in bytes of the above.

Return Value:

    NDIS_STATUS_SUCCESS if a binding was successfully set up.
    NDIS_STATUS_XXX error code on any failure.

--*/
{
    NDIS_STATUS             Status;
    NDIS_STATUS             OpenErrorCode;
    NDIS_MEDIUM             MediumArray[1] = {NdisMedium802_3};
    UINT                    SelectedMediumIndex;
    PNDISUIO_OPEN_CONTEXT   pTmpOpenContext;
    BOOLEAN                 fDoNotDisturb = FALSE;
    BOOLEAN                 fOpenComplete = FALSE;
    ULONG                   BytesProcessed;
    ULONG                   GenericUlong = 0;

    DEBUGP(DL_LOUD, ("CreateBinding: open %p/%x, device [%ws]\n",
                pOpenContext, pOpenContext->Flags, pBindingInfo));

    Status = NDIS_STATUS_SUCCESS;

    do
    {
        //
        //  Check if we already have a binding to this device.
        //
        pTmpOpenContext = ndisuioLookupDevice(pBindingInfo, BindingInfoLength);

        if (pTmpOpenContext != NULL)
        {
            DEBUGP(DL_WARN,
                ("CreateBinding: Binding to device %ws already exists on open %p\n",
                    pTmpOpenContext->DeviceName.Buffer, pTmpOpenContext));

            NUIO_DEREF_OPEN(pTmpOpenContext);  // temp ref added by Lookup
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if this open context is already bound/binding/closing.
        //
        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE) ||
            NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED))
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            Status = NDIS_STATUS_NOT_ACCEPTED;

            //
            // Make sure we don't abort this binding on failure cleanup.
            //
            fDoNotDisturb = TRUE;

            break;
        }

        NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Copy in the device name. Add room for a NULL terminator.
        //
        NUIO_ALLOC_MEM(pOpenContext->DeviceName.Buffer, BindingInfoLength + sizeof(WCHAR));
        if (pOpenContext->DeviceName.Buffer == NULL)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc device name buf (%d bytes)\n",
                BindingInfoLength + sizeof(WCHAR)));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NUIO_COPY_MEM(pOpenContext->DeviceName.Buffer, pBindingInfo, BindingInfoLength);
        *(PWCHAR)((PUCHAR)pOpenContext->DeviceName.Buffer + BindingInfoLength) = L'\0';
        NdisInitUnicodeString(&pOpenContext->DeviceName, pOpenContext->DeviceName.Buffer);

        //
        //  Allocate packet pools.
        //
        NdisAllocatePacketPoolEx(
            &Status,
            &pOpenContext->SendPacketPool,
            MIN_SEND_PACKET_POOL_SIZE,
            MAX_SEND_PACKET_POOL_SIZE - MIN_SEND_PACKET_POOL_SIZE,
            sizeof(NUIO_SEND_PACKET_RSVD));
       
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " send packet pool: %x\n", Status));
            break;
        }


        NdisAllocatePacketPoolEx(
            &Status,
            &pOpenContext->RecvPacketPool,
            MIN_RECV_PACKET_POOL_SIZE,
            MAX_RECV_PACKET_POOL_SIZE - MIN_RECV_PACKET_POOL_SIZE,
            sizeof(NUIO_RECV_PACKET_RSVD));
       
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " recv packet pool: %x\n", Status));
            break;
        }

        //
        //  Buffer pool for receives.
        //
        NdisAllocateBufferPool(
            &Status,
            &pOpenContext->RecvBufferPool,
            MAX_RECV_PACKET_POOL_SIZE);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                    " recv buffer pool: %x\n", Status));
            break;
        }

        //
        //  If we are running on Win9X, allocate a buffer pool for sends
        //  as well, since we can't simply cast MDLs to NDIS_BUFFERs.
        //
        if (pOpenContext->bRunningOnWin9x)
        {
            NdisAllocateBufferPool(
                &Status,
                &pOpenContext->SendBufferPool,
                MAX_SEND_PACKET_POOL_SIZE);
            
            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("CreateBinding: failed to alloc"
                        " send buffer pool: %x\n", Status));
                break;
            }
        }
        //
        //  Assume that the device is powered up.
        //
        pOpenContext->PowerState = NetDeviceStateD0;

        //
        //  Open the adapter.
        //
        NUIO_INIT_EVENT(&pOpenContext->BindEvent);

        NdisOpenAdapter(
            &Status,
            &OpenErrorCode,
            &pOpenContext->BindingHandle,
            &SelectedMediumIndex,
            &MediumArray[0],
            sizeof(MediumArray) / sizeof(NDIS_MEDIUM),
            Globals.NdisProtocolHandle,
            (NDIS_HANDLE)pOpenContext,
            &pOpenContext->DeviceName,
            0,
            NULL);
    
        if (Status == NDIS_STATUS_PENDING)
        {
            NUIO_WAIT_EVENT(&pOpenContext->BindEvent, 0);
            Status = pOpenContext->BindStatus;
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: NdisOpenAdapter (%ws) failed: %x\n",
                pOpenContext->DeviceName.Buffer, Status));
            break;
        }

        //
        //  Note down the fact that we have successfully bound.
        //  We don't update the state on the open just yet - this
        //  is to prevent other threads from shutting down the binding.
        //
        fOpenComplete = TRUE;

        //
        //  Get the friendly name for the adapter. It is not fatal for this
        //  to fail.
        //
        (VOID)NdisQueryAdapterInstanceName(
                &pOpenContext->DeviceDescr,
                pOpenContext->BindingHandle
                );
        //
        // Get Current address
        //
        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_802_3_CURRENT_ADDRESS,
                    &pOpenContext->CurrentAddress[0],
                    NUIO_MAC_ADDR_LEN,
                    &BytesProcessed
                    );
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry current address failed: %x\n",
                    Status));
            break;
        }
        
        //
        //  Get MAC options.
        //
        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MAC_OPTIONS,
                    &pOpenContext->MacOptions,
                    sizeof(pOpenContext->MacOptions),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry MAC options failed: %x\n",
                    Status));
            break;
        }

        //
        //  Get the max frame size.
        //
        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MAXIMUM_FRAME_SIZE,
                    &pOpenContext->MaxFrameSize,
                    sizeof(pOpenContext->MaxFrameSize),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry max frame failed: %x\n",
                    Status));
            break;
        }

        //
        //  Get the media connect status.
        //
        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    OID_GEN_MEDIA_CONNECT_STATUS,
                    &GenericUlong,
                    sizeof(GenericUlong),
                    &BytesProcessed
                    );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGP(DL_WARN, ("CreateBinding: qry media connect status failed: %x\n",
                    Status));
            break;
        }

        if (GenericUlong == NdisMediaStateConnected)
        {
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_CONNECTED);
        }
        else
        {
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_MEDIA_FLAGS, NUIOO_MEDIA_DISCONNECTED);
        }



        //
        //  Mark this open. Also check if we received an Unbind while
        //  we were setting this up.
        //
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);

        //
        //  Did an unbind happen in the meantime?
        //
        if (NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, NUIOO_UNBIND_RECEIVED))
        {
            Status = NDIS_STATUS_FAILURE;
        }

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);
       
    }
    while (FALSE);

    if ((Status != NDIS_STATUS_SUCCESS) && !fDoNotDisturb)
    {
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Check if we had actually finished opening the adapter.
        //
        if (fOpenComplete)
        {
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE);
        }
        else if (NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING))
        {
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_FAILED);
        }

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        ndisuioShutdownBinding(pOpenContext);
    }

    DEBUGP(DL_INFO, ("CreateBinding: OpenContext %p, Status %x\n",
            pOpenContext, Status));

    return (Status);
}



VOID
ndisuioShutdownBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    )
/*++

Routine Description:

    Utility function to shut down the NDIS binding, if one exists, on
    the specified open. This is written to be called from:

        ndisuioCreateBinding - on failure
        NdisuioUnbindAdapter

    We handle the case where a binding is in the process of being set up.
    This precaution is not needed if this routine is only called from
    the context of our UnbindAdapter handler, but they are here in case
    we initiate unbinding from elsewhere (e.g. on processing a user command).

    NOTE: this blocks and finishes synchronously.

Arguments:

    pOpenContext - pointer to open context block

Return Value:

    None

--*/
{
    NDIS_STATUS             Status;
    BOOLEAN                 DoCloseBinding = FALSE;

    do
    {
        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_OPENING))
        {
            //
            //  We are still in the process of setting up this binding.
            //
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
            break;
        }

        if (NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_CLOSING);
            DoCloseBinding = TRUE;
        }

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        if (DoCloseBinding)
        {
            ULONG    PacketFilter = 0;
            ULONG    BytesRead = 0;
            
            //
            // Set Packet filter to 0 before closing the binding
            // 
            Status = ndisuioDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_GEN_CURRENT_PACKET_FILTER,
                        &PacketFilter,
                        sizeof(PacketFilter),
                        &BytesRead);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("ShutDownBinding: set packet filter failed: %x\n", Status));
            }
            
            //
            // Set multicast list to null before closing the binding
            // 
            Status = ndisuioDoRequest(
                        pOpenContext,
                        NdisRequestSetInformation,
                        OID_802_3_MULTICAST_LIST,
                        NULL,
                        0,
                        &BytesRead);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGP(DL_WARN, ("ShutDownBinding: set multicast list failed: %x\n", Status));
            }
                
            //
            //  Wait for any pending sends or requests on
            //  the binding to complete.
            //
            ndisuioWaitForPendingIO(pOpenContext, TRUE);

            //
            //  Discard any queued receives.
            //
            ndisuioFlushReceiveQueue(pOpenContext);

            //
            //  Close the binding now.
            //
            NUIO_INIT_EVENT(&pOpenContext->BindEvent);

            DEBUGP(DL_INFO, ("ShutdownBinding: Closing OpenContext %p,"
                    " BindingHandle %p\n",
                    pOpenContext, pOpenContext->BindingHandle));

            NdisCloseAdapter(&Status, pOpenContext->BindingHandle);

            if (Status == NDIS_STATUS_PENDING)
            {
                NUIO_WAIT_EVENT(&pOpenContext->BindEvent, 0);
                Status = pOpenContext->BindStatus;
            }

            NUIO_ASSERT(Status == NDIS_STATUS_SUCCESS);

            pOpenContext->BindingHandle = NULL;
        }

        if (DoCloseBinding)
        {
            NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_IDLE);

            NUIO_SET_FLAGS(pOpenContext->Flags, NUIOO_UNBIND_FLAGS, 0);

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        }

        //
        //  Remove it from the global list.
        //
        NUIO_ACQUIRE_LOCK(&Globals.GlobalLock);

        NUIO_REMOVE_ENTRY_LIST(&pOpenContext->Link);

        NUIO_RELEASE_LOCK(&Globals.GlobalLock);

        //
        //  Free any other resources allocated for this bind.
        //
        ndisuioFreeBindResources(pOpenContext);

        NUIO_DEREF_OPEN(pOpenContext);  // Shutdown binding

    }
    while (FALSE);
}


VOID
ndisuioFreeBindResources(
    IN PNDISUIO_OPEN_CONTEXT       pOpenContext
    )
/*++

Routine Description:

    Free any resources set up for an NDIS binding.

Arguments:

    pOpenContext - pointer to open context block

Return Value:

    None

--*/
{
    if (pOpenContext->SendPacketPool != NULL)
    {
        NdisFreePacketPool(pOpenContext->SendPacketPool);
        pOpenContext->SendPacketPool = NULL;
    }

    if (pOpenContext->RecvPacketPool != NULL)
    {
        NdisFreePacketPool(pOpenContext->RecvPacketPool);
        pOpenContext->RecvPacketPool = NULL;
    }

    if (pOpenContext->RecvBufferPool != NULL)
    {
        NdisFreeBufferPool(pOpenContext->RecvBufferPool);
        pOpenContext->RecvBufferPool = NULL;
    }

    if (pOpenContext->SendBufferPool != NULL)
    {
        NdisFreeBufferPool(pOpenContext->SendBufferPool);
        pOpenContext->SendBufferPool = NULL;
    }

    if (pOpenContext->DeviceName.Buffer != NULL)
    {
        NUIO_FREE_MEM(pOpenContext->DeviceName.Buffer);
        pOpenContext->DeviceName.Buffer = NULL;
        pOpenContext->DeviceName.Length =
        pOpenContext->DeviceName.MaximumLength = 0;
    }

    if (pOpenContext->DeviceDescr.Buffer != NULL)
    {
        //
        // this would have been allocated by NdisQueryAdpaterInstanceName.
        //
        NdisFreeMemory(pOpenContext->DeviceDescr.Buffer, 0, 0);
        pOpenContext->DeviceDescr.Buffer = NULL;
    }
}


VOID
ndisuioWaitForPendingIO(
    IN PNDISUIO_OPEN_CONTEXT            pOpenContext,
    IN BOOLEAN                          DoCancelReads
    )
/*++

Routine Description:

    Utility function to wait for all outstanding I/O to complete
    on an open context. It is assumed that the open context
    won't go away while we are in this routine.

Arguments:

    pOpenContext - pointer to open context structure
    DoCancelReads - do we wait for pending reads to go away (and cancel them)?

Return Value:

    None

--*/
{
    NDIS_STATUS     Status;
    ULONG           LoopCount;
    ULONG           PendingCount;

#ifdef NDIS51
    //
    //  Wait for any pending sends or requests on the binding to complete.
    //
    for (LoopCount = 0; LoopCount < 60; LoopCount++)
    {
        Status = NdisQueryPendingIOCount(
                    pOpenContext->BindingHandle,
                    &PendingCount);

        if ((Status != NDIS_STATUS_SUCCESS) ||
            (PendingCount == 0))
        {
            break;
        }

        DEBUGP(DL_INFO, ("WaitForPendingIO: Open %p, %d pending I/O at NDIS\n",
                pOpenContext, PendingCount));

        NUIO_SLEEP(2);
    }

    NUIO_ASSERT(LoopCount < 60);

#endif // NDIS51

    //
    //  Make sure any threads trying to send have finished.
    //
    for (LoopCount = 0; LoopCount < 60; LoopCount++)
    {
        if (pOpenContext->PendedSendCount == 0)
        {
            break;
        }

        DEBUGP(DL_WARN, ("WaitForPendingIO: Open %p, %d pended sends\n",
                pOpenContext, pOpenContext->PendedSendCount));

        NUIO_SLEEP(1);
    }

    NUIO_ASSERT(LoopCount < 60);

    if (DoCancelReads)
    {
        //
        //  Wait for any pended reads to complete/cancel.
        //
        while (pOpenContext->PendedReadCount != 0)
        {
            DEBUGP(DL_INFO, ("WaitForPendingIO: Open %p, %d pended reads\n",
                pOpenContext, pOpenContext->PendedReadCount));

            //
            //  Cancel any pending reads.
            //
            ndisuioCancelPendingReads(pOpenContext);

            NUIO_SLEEP(1);
        }
    }

}


VOID
ndisuioDoProtocolUnload(
    VOID
    )
/*++

Routine Description:

    Utility routine to handle unload from the NDIS protocol side.

Arguments:

    None

Return Value:

    None

--*/
{
    NDIS_HANDLE     ProtocolHandle;
    NDIS_STATUS     Status;

    DEBUGP(DL_INFO, ("ProtocolUnload: ProtocolHandle %lx\n", 
        Globals.NdisProtocolHandle));

    if (Globals.NdisProtocolHandle != NULL)
    {
        ProtocolHandle = Globals.NdisProtocolHandle;
        Globals.NdisProtocolHandle = NULL;

        NdisDeregisterProtocol(
            &Status,
            ProtocolHandle
            );

    }
}


NDIS_STATUS
ndisuioDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed
    )
/*++

Routine Description:

    Utility routine that forms and sends an NDIS_REQUEST to the
    miniport, waits for it to complete, and returns status
    to the caller.

    NOTE: this assumes that the calling routine ensures validity
    of the binding handle until this returns.

Arguments:

    pOpenContext - pointer to our open context
    RequestType - NdisRequest[Set|Query]Information
    Oid - the object being set/queried
    InformationBuffer - data for the request
    InformationBufferLength - length of the above
    pBytesProcessed - place to return bytes read/written

Return Value:

    Status of the set/query request

--*/
{
    NDISUIO_REQUEST             ReqContext;
    PNDIS_REQUEST               pNdisRequest = &ReqContext.Request;
    NDIS_STATUS                 Status;

    NUIO_INIT_EVENT(&ReqContext.ReqEvent);

    pNdisRequest->RequestType = RequestType;

    switch (RequestType)
    {
        case NdisRequestQueryInformation:
            pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                                    InformationBuffer;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
            break;

        case NdisRequestSetInformation:
            pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
            pNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
                                    InformationBuffer;
            pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
                                    InformationBufferLength;
            break;

        default:
            NUIO_ASSERT(FALSE);
            break;
    }

    NdisRequest(&Status,
                pOpenContext->BindingHandle,
                pNdisRequest);
    

    if (Status == NDIS_STATUS_PENDING)
    {
        NUIO_WAIT_EVENT(&ReqContext.ReqEvent, 0);
        Status = ReqContext.Status;
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        *pBytesProcessed = (RequestType == NdisRequestQueryInformation)?
                            pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten:
                            pNdisRequest->DATA.SET_INFORMATION.BytesRead;
        
        //
        // The driver below should set the correct value to BytesWritten 
        // or BytesRead. But now, we just truncate the value to InformationBufferLength
        //
        if (*pBytesProcessed > InformationBufferLength)
        {
            *pBytesProcessed = InformationBufferLength;
        }
    }

    return (Status);
}


NDIS_STATUS
ndisuioValidateOpenAndDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN ULONG                        InformationBufferLength,
    OUT PULONG                      pBytesProcessed,
    IN BOOLEAN                      bWaitForPowerOn
    )
/*++

Routine Description:

    Utility routine to prevalidate and reference an open context
    before calling ndisuioDoRequest. This routine makes sure
    we have a valid binding.

Arguments:

    pOpenContext - pointer to our open context
    RequestType - NdisRequest[Set|Query]Information
    Oid - the object being set/queried
    InformationBuffer - data for the request
    InformationBufferLength - length of the above
    pBytesProcessed - place to return bytes read/written
    bWaitForPowerOn - Wait for the device to be powered on if it isn't already.

Return Value:

    Status of the set/query request

--*/
{
    NDIS_STATUS             Status;

    do
    {
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("ValidateOpenAndDoRequest: request on unassociated file object!\n"));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }
               
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        //
        //  Proceed only if we have a binding.
        //
        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        NUIO_ASSERT(pOpenContext->BindingHandle != NULL);

        //
        //  Make sure that the binding does not go away until we
        //  are finished with the request.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        if (bWaitForPowerOn)
        {
            //
            //  Wait for the device below to be powered up.
            //  We don't wait indefinitely here - this is to avoid
            //  a PROCESS_HAS_LOCKED_PAGES bugcheck that could happen
            //  if the calling process terminates, and this IRP doesn't
            //  complete within a reasonable time. An alternative would
            //  be to explicitly handle cancellation of this IRP.
            //
            NUIO_WAIT_EVENT(&pOpenContext->PoweredUpEvent, 4500);
        }

        Status = ndisuioDoRequest(
                    pOpenContext,
                    RequestType,
                    Oid,
                    InformationBuffer,
                    InformationBufferLength,
                    pBytesProcessed);
        
        //
        //  Let go of the binding.
        //
        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);
      
    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("ValidateOpenAndDoReq: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
}


VOID
NdisuioResetComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point indicating that a protocol initiated reset
    has completed. Since we never call NdisReset(), this should
    never be called.

Arguments:

    ProtocolBindingContext - pointer to open context
    Status - status of reset completion

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER(ProtocolBindingContext);
    UNREFERENCED_PARAMETER(Status);
	
    ASSERT(FALSE);
    return;
}


VOID
NdisuioRequestComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_REQUEST                pNdisRequest,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point indicating completion of a pended NDIS_REQUEST.

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisRequest - pointer to NDIS request
    Status - status of reset completion

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;
    PNDISUIO_REQUEST            pReqContext;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Get at the request context.
    //
    pReqContext = CONTAINING_RECORD(pNdisRequest, NDISUIO_REQUEST, Request);

    //
    //  Save away the completion status.
    //
    pReqContext->Status = Status;

    //
    //  Wake up the thread blocked for this request to complete.
    //
    NUIO_SIGNAL_EVENT(&pReqContext->ReqEvent);
}


VOID
NdisuioStatus(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  GeneralStatus,
    IN PVOID                        StatusBuffer,
    IN UINT                         StatusBufferSize
    )
/*++

Routine Description:

    Protocol entry point called by NDIS to indicate a change
    in status at the miniport.

    We make note of reset and media connect status indications.

Arguments:

    ProtocolBindingContext - pointer to open context
    GeneralStatus - status code
    StatusBuffer - status-specific additional information
    StatusBufferSize - size of the above

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;

    UNREFERENCED_PARAMETER(StatusBuffer);
    UNREFERENCED_PARAMETER(StatusBufferSize);
	
    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    DEBUGP(DL_INFO, ("Status: Open %p, Status %x\n",
            pOpenContext, GeneralStatus));

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    do
    {
        if (pOpenContext->PowerState != NetDeviceStateD0)
        {
            //
            //  The device is in a low power state.
            //
            DEBUGP(DL_INFO, ("Status: Open %p in power state %d,"
                " Status %x ignored\n", pOpenContext,
                pOpenContext->PowerState, GeneralStatus));
            //
            //  We continue and make note of status indications
            //
            // break;
            //

            //
            //  NOTE that any actions we take based on these
            //  status indications should take into account
            //  the current device power state.
            //
        }

        switch(GeneralStatus)
        {
            case NDIS_STATUS_RESET_START:
    
                NUIO_ASSERT(!NUIO_TEST_FLAGS(pOpenContext->Flags,
                                             NUIOO_RESET_FLAGS,
                                             NUIOO_RESET_IN_PROGRESS));

                NUIO_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_RESET_FLAGS,
                               NUIOO_RESET_IN_PROGRESS);

                break;

            case NDIS_STATUS_RESET_END:

                NUIO_ASSERT(NUIO_TEST_FLAGS(pOpenContext->Flags,
                                            NUIOO_RESET_FLAGS,
                                            NUIOO_RESET_IN_PROGRESS));
   
                NUIO_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_RESET_FLAGS,
                               NUIOO_NOT_RESETTING);

                break;

            case NDIS_STATUS_MEDIA_CONNECT:

                NUIO_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_MEDIA_FLAGS,
                               NUIOO_MEDIA_CONNECTED);

                break;

            case NDIS_STATUS_MEDIA_DISCONNECT:

                NUIO_SET_FLAGS(pOpenContext->Flags,
                               NUIOO_MEDIA_FLAGS,
                               NUIOO_MEDIA_DISCONNECTED);

                break;

            default:
                break;
        }
    }
    while (FALSE);
       
    NUIO_RELEASE_LOCK(&pOpenContext->Lock);
}

VOID
NdisuioStatusComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    )
/*++

Routine Description:

    Protocol entry point called by NDIS. We ignore this.

Arguments:

    ProtocolBindingContext - pointer to open context

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    return;
}


NDIS_STATUS
ndisuioQueryBinding(
    IN PUCHAR                       pBuffer,
    IN ULONG                        InputLength,
    IN ULONG                        OutputLength,
    OUT PULONG                      pBytesReturned
    )
/*++

Routine Description:

    Return information about the specified binding.

Arguments:

    pBuffer - pointer to NDISUIO_QUERY_BINDING
    InputLength - input buffer size
    OutputLength - output buffer size
    pBytesReturned - place to return copied byte count.

Return Value:

    NDIS_STATUS_SUCCESS if successful, failure code otherwise.

--*/
{
    PNDISUIO_QUERY_BINDING      pQueryBinding;
    PNDISUIO_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pEnt;
    ULONG                       Remaining;
    ULONG                       BindingIndex;
    NDIS_STATUS                 Status;

    do
    {
        if (InputLength < sizeof(NDISUIO_QUERY_BINDING))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        if (OutputLength < sizeof(NDISUIO_QUERY_BINDING))
        {
            Status = NDIS_STATUS_BUFFER_OVERFLOW;
            break;
        }

        Remaining = OutputLength - sizeof(NDISUIO_QUERY_BINDING);

        pQueryBinding = (PNDISUIO_QUERY_BINDING)pBuffer;
        BindingIndex = pQueryBinding->BindingIndex;

        Status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        pOpenContext = NULL;

        NUIO_ACQUIRE_LOCK(&Globals.GlobalLock);

        for (pEnt = Globals.OpenList.Flink;
             pEnt != &Globals.OpenList;
             pEnt = pEnt->Flink)
        {
            pOpenContext = CONTAINING_RECORD(pEnt, NDISUIO_OPEN_CONTEXT, Link);
            NUIO_STRUCT_ASSERT(pOpenContext, oc);

            NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

            //
            //  Skip if not bound.
            //
            if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
            {
                NUIO_RELEASE_LOCK(&pOpenContext->Lock);
                continue;
            }

            if (BindingIndex == 0)
            {
                //
                //  Got the binding we are looking for. Copy the device
                //  name and description strings to the output buffer.
                //
                DEBUGP(DL_INFO,
                    ("QueryBinding: found open %p\n", pOpenContext));

                pQueryBinding->DeviceNameLength = pOpenContext->DeviceName.Length + sizeof(WCHAR);
                pQueryBinding->DeviceDescrLength = pOpenContext->DeviceDescr.Length + sizeof(WCHAR);
                if (Remaining < pQueryBinding->DeviceNameLength +
                                pQueryBinding->DeviceDescrLength)
                {
                    NUIO_RELEASE_LOCK(&pOpenContext->Lock);
                    Status = NDIS_STATUS_BUFFER_OVERFLOW;
                    break;
                }

                NUIO_ZERO_MEM((PUCHAR)pBuffer + sizeof(NDISUIO_QUERY_BINDING),
                                pQueryBinding->DeviceNameLength +
                                pQueryBinding->DeviceDescrLength);

                pQueryBinding->DeviceNameOffset = sizeof(NDISUIO_QUERY_BINDING);
                NUIO_COPY_MEM((PUCHAR)pBuffer + pQueryBinding->DeviceNameOffset,
                                pOpenContext->DeviceName.Buffer,
                                pOpenContext->DeviceName.Length);
                
                pQueryBinding->DeviceDescrOffset = pQueryBinding->DeviceNameOffset +
                                                    pQueryBinding->DeviceNameLength;
                NUIO_COPY_MEM((PUCHAR)pBuffer + pQueryBinding->DeviceDescrOffset,
                                pOpenContext->DeviceDescr.Buffer,
                                pOpenContext->DeviceDescr.Length);
                
                NUIO_RELEASE_LOCK(&pOpenContext->Lock);

                *pBytesReturned = pQueryBinding->DeviceDescrOffset + pQueryBinding->DeviceDescrLength;
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            BindingIndex--;
        }

        NUIO_RELEASE_LOCK(&Globals.GlobalLock);

    }
    while (FALSE);

    return (Status);
}

PNDISUIO_OPEN_CONTEXT
ndisuioLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    )
/*++

Routine Description:

    Search our global list for an open context structure that
    has a binding to the specified device, and return a pointer
    to it.

    NOTE: we reference the open that we return.

Arguments:

    pBindingInfo - pointer to unicode device name string
    BindingInfoLength - length in bytes of the above.

Return Value:

    Pointer to the matching open context if found, else NULL

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pEnt;

    pOpenContext = NULL;

    NUIO_ACQUIRE_LOCK(&Globals.GlobalLock);

    for (pEnt = Globals.OpenList.Flink;
         pEnt != &Globals.OpenList;
         pEnt = pEnt->Flink)
    {
        pOpenContext = CONTAINING_RECORD(pEnt, NDISUIO_OPEN_CONTEXT, Link);
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        //
        //  Check if this has the name we are looking for.
        //
        if ((pOpenContext->DeviceName.Length == BindingInfoLength) &&
            NUIO_MEM_CMP(pOpenContext->DeviceName.Buffer, pBindingInfo, BindingInfoLength))
        {
            NUIO_REF_OPEN(pOpenContext);   // ref added by LookupDevice
            break;
        }

        pOpenContext = NULL;
    }

    NUIO_RELEASE_LOCK(&Globals.GlobalLock);

    return (pOpenContext);
}


NDIS_STATUS
ndisuioQueryOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    )
/*++

Routine Description:

    Query an arbitrary OID value from the miniport.

Arguments:

    pOpenContext - pointer to open context representing our binding to the miniport
    pDataBuffer - place to store the returned value
    BufferLength - length of the above
    pBytesWritten - place to return length returned

Return Value:

    NDIS_STATUS_SUCCESS if we successfully queried the OID.
    NDIS_STATUS_XXX error code otherwise.

--*/
{
    NDIS_STATUS             Status;
    PNDISUIO_QUERY_OID      pQuery;
    NDIS_OID                Oid;

    Oid = 0;

    do
    {
        if (BufferLength < sizeof(NDISUIO_QUERY_OID))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            break;
        }

        pQuery = (PNDISUIO_QUERY_OID)pDataBuffer;
        Oid = pQuery->Oid;

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            DEBUGP(DL_WARN,
                ("QueryOid: Open %p/%x is in invalid state\n",
                    pOpenContext, pOpenContext->Flags));

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Make sure the binding doesn't go away.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestQueryInformation,
                    Oid,
                    &pQuery->Data[0],
                    BufferLength - FIELD_OFFSET(NDISUIO_QUERY_OID, Data),
                    pBytesWritten);

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            *pBytesWritten += FIELD_OFFSET(NDISUIO_QUERY_OID, Data);
        }

    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("QueryOid: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
    
}

NDIS_STATUS
ndisuioSetOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    )
/*++

Routine Description:

    Set an arbitrary OID value to the miniport.

Arguments:

    pOpenContext - pointer to open context representing our binding to the miniport
    pDataBuffer - buffer that contains the value to be set
    BufferLength - length of the above

Return Value:

    NDIS_STATUS_SUCCESS if we successfully set the OID
    NDIS_STATUS_XXX error code otherwise.

--*/
{
    NDIS_STATUS             Status;
    PNDISUIO_SET_OID        pSet;
    NDIS_OID                Oid;
    ULONG                   BytesWritten;

    Oid = 0;

    do
    {
        if (BufferLength < sizeof(NDISUIO_SET_OID))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            break;
        }

        pSet = (PNDISUIO_SET_OID)pDataBuffer;
        Oid = pSet->Oid;

        //
        // We should check the OID is settable by the user mode apps
        // 
        if (!ndisuioValidOid(Oid))
        {
            DEBUGP(DL_WARN, ("SetOid: Oid %x cannot be set\n", Oid));

            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }
            

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            DEBUGP(DL_WARN,
                ("SetOid: Open %p/%x is in invalid state\n",
                    pOpenContext, pOpenContext->Flags));

            NUIO_RELEASE_LOCK(&pOpenContext->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Make sure the binding doesn't go away.
        //
        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        Status = ndisuioDoRequest(
                    pOpenContext,
                    NdisRequestSetInformation,
                    Oid,
                    &pSet->Data[0],
                    BufferLength - FIELD_OFFSET(NDISUIO_SET_OID, Data),
                    &BytesWritten);

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    }
    while (FALSE);

    DEBUGP(DL_LOUD, ("SetOid: Open %p/%x, OID %x, Status %x\n",
                pOpenContext, pOpenContext->Flags, Oid, Status));

    return (Status);
}

BOOLEAN
ndisuioValidOid(
    IN  NDIS_OID            Oid 
    )
/*++

Routine Description:

    Validate whether the given set OID is settable or not.

Arguments:

    Oid - The OID which the user tries to set.
    
Return Value:

    TRUE if the OID is allowed to set
    FALSE otherwise.

--*/
{
    UINT    i;
    UINT    NumOids;

    NumOids = sizeof(ndisuioSupportedSetOids) / sizeof(NDIS_OID);

    for (i = 0; i < NumOids; i++)
    {
        if (ndisuioSupportedSetOids[i] == Oid)
        {
            break;
        }
    }
    
    return (i < NumOids);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\uio\sys\send.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    send.c

Abstract:

    NDIS protocol entry points and utility routines to handle sending
    data.

Environment:

    Kernel mode only.

Revision History:

    arvindm     4/10/2000    Created

--*/

#include "precomp.h"

#define __FILENUMBER 'DNES'




NTSTATUS
NdisuioWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch routine to handle IRP_MJ_WRITE. 

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - Pointer to request packet

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    ULONG                   DataLength;
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDISUIO_OPEN_CONTEXT   pOpenContext;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_BUFFER            pNdisBuffer;
    NDISUIO_ETH_HEADER UNALIGNED *pEthHeader;
#ifdef NDIS51
    PVOID                   CancelId;
#endif

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pOpenContext = pIrpSp->FileObject->FsContext;

    pNdisPacket = NULL;

    do
    {
        if (pOpenContext == NULL)
        {
            DEBUGP(DL_WARN, ("Write: FileObject %p not yet associated with a device\n",
                pIrpSp->FileObject));
            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }
               
        NUIO_STRUCT_ASSERT(pOpenContext, oc);

        if (pIrp->MdlAddress == NULL)
        {
            DEBUGP(DL_FATAL, ("Write: NULL MDL address on IRP %p\n", pIrp));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        //
        // Try to get a virtual address for the MDL.
        //
#ifndef WIN9X
        pEthHeader = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);

        if (pEthHeader == NULL)
        {
            DEBUGP(DL_FATAL, ("Write: MmGetSystemAddr failed for"
                    " IRP %p, MDL %p\n",
                    pIrp, pIrp->MdlAddress));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
#else
        pEthHeader = MmGetSystemAddressForMdl(pIrp->MdlAddress);   // for Win9X
#endif

        //
        // Sanity-check the length.
        //
        DataLength = MmGetMdlByteCount(pIrp->MdlAddress);
        if (DataLength < sizeof(NDISUIO_ETH_HEADER))
        {
            DEBUGP(DL_WARN, ("Write: too small to be a valid packet (%d bytes)\n",
                DataLength));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DataLength > (pOpenContext->MaxFrameSize + sizeof(NDISUIO_ETH_HEADER)))
        {
            DEBUGP(DL_WARN, ("Write: Open %p: data length (%d)"
                    " larger than max frame size (%d)\n",
                    pOpenContext, DataLength, pOpenContext->MaxFrameSize));

            NtStatus = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        if (pEthHeader->EthType != Globals.EthType)
        {
            DEBUGP(DL_WARN, ("Write: Failing send with EthType %x\n",
                pEthHeader->EthType));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
       
        if (!NUIO_MEM_CMP(pEthHeader->SrcAddr, pOpenContext->CurrentAddress, NUIO_MAC_ADDR_LEN))
        {
            DEBUGP(DL_WARN, ("Write: Failing with invalid Source address"));
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        

        NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

        if (!NUIO_TEST_FLAGS(pOpenContext->Flags, NUIOO_BIND_FLAGS, NUIOO_BIND_ACTIVE))
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            DEBUGP(DL_FATAL, ("Write: Open %p is not bound"
            " or in low power state\n", pOpenContext));

            NtStatus = STATUS_INVALID_HANDLE;
            break;
        }

        //
        //  Allocate a send packet.
        //
        NUIO_ASSERT(pOpenContext->SendPacketPool != NULL);
        NdisAllocatePacket(
            &Status,
            &pNdisPacket,
            pOpenContext->SendPacketPool);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            NUIO_RELEASE_LOCK(&pOpenContext->Lock);

            DEBUGP(DL_FATAL, ("Write: open %p, failed to alloc send pkt\n",
                    pOpenContext));
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        //  Allocate a send buffer if necessary.
        //
        if (pOpenContext->bRunningOnWin9x)
        {
            NdisAllocateBuffer(
                &Status,
                &pNdisBuffer,
                pOpenContext->SendBufferPool,
                pEthHeader,
                DataLength);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                NUIO_RELEASE_LOCK(&pOpenContext->Lock);

                NdisFreePacket(pNdisPacket);

                DEBUGP(DL_FATAL, ("Write: open %p, failed to alloc send buf\n",
                        pOpenContext));
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }
        else
        {
            pNdisBuffer = pIrp->MdlAddress;
        }

        NdisInterlockedIncrement((PLONG)&pOpenContext->PendedSendCount);

        NUIO_REF_OPEN(pOpenContext);  // pended send

        IoMarkIrpPending(pIrp);

        //
        //  Initialize the packet ref count. This packet will be freed
        //  when this count goes to zero.
        //
        NUIO_SEND_PKT_RSVD(pNdisPacket)->RefCount = 1;

#ifdef NDIS51

        //
        //  NDIS 5.1 supports cancelling sends. We set up a cancel ID on
        //  each send packet (which maps to a Write IRP), and save the
        //  packet pointer in the IRP. If the IRP gets cancelled, we use
        //  NdisCancelSendPackets() to cancel the packet.
        //

        CancelId = NUIO_GET_NEXT_CANCEL_ID();
        NDIS_SET_PACKET_CANCEL_ID(pNdisPacket, CancelId);
        pIrp->Tail.Overlay.DriverContext[0] = (PVOID)pOpenContext;
        pIrp->Tail.Overlay.DriverContext[1] = (PVOID)pNdisPacket;

        NUIO_INSERT_TAIL_LIST(&pOpenContext->PendedWrites, &pIrp->Tail.Overlay.ListEntry);

        IoSetCancelRoutine(pIrp, NdisuioCancelWrite);

#endif // NDIS51

        NUIO_RELEASE_LOCK(&pOpenContext->Lock);

        //
        //  Set a back pointer from the packet to the IRP.
        //
        NUIO_IRP_FROM_SEND_PKT(pNdisPacket) = pIrp;

        NtStatus = STATUS_PENDING;

        pNdisBuffer->Next = NULL;
        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

#if SEND_DBG
        {
            PUCHAR      pData;

#ifndef WIN9X
            pData = MmGetSystemAddressForMdlSafe(pNdisBuffer, NormalPagePriority);
            NUIO_ASSERT(pEthHeader == pData);
#else
            pData = MmGetSystemAddressForMdl(pNdisBuffer);  // Win9x
#endif

            DEBUGP(DL_VERY_LOUD, 
                ("Write: MDL %p, MdlFlags %x, SystemAddr %p, %d bytes\n",
                    pIrp->MdlAddress, pIrp->MdlAddress->MdlFlags, pData, DataLength));

            DEBUGPDUMP(DL_VERY_LOUD, pData, MIN(DataLength, 48));
        }
#endif // SEND_DBG

        NdisSendPackets(pOpenContext->BindingHandle, &pNdisPacket, 1);

    }
    while (FALSE);

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = NtStatus;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return (NtStatus);
}


#ifdef NDIS51

VOID
NdisuioCancelWrite(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    )
/*++

Routine Description:

    Cancel a pending write IRP. This routine attempt to cancel the NDIS send.

Arguments:

    pDeviceObject - pointer to our device object
    pIrp - IRP to be cancelled

Return Value:

    None

--*/
{
    PNDISUIO_OPEN_CONTEXT       pOpenContext;
    PLIST_ENTRY                 pIrpEntry;
    PNDIS_PACKET                pNdisPacket;

    UNREFERENCED_PARAMETER(pDeviceObject);
	
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    //
    //  The NDIS packet representing this Write IRP.
    //
    pNdisPacket = NULL;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT) pIrp->Tail.Overlay.DriverContext[0];
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    //
    //  Try to locate the IRP in the pended write queue. The send completion
    //  routine may be running and might have removed it from there.
    //
    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    for (pIrpEntry = pOpenContext->PendedWrites.Flink;
         pIrpEntry != &pOpenContext->PendedWrites;
         pIrpEntry = pIrpEntry->Flink)
    {
        if (pIrp == CONTAINING_RECORD(pIrpEntry, IRP, Tail.Overlay.ListEntry))
        {
            pNdisPacket = (PNDIS_PACKET) pIrp->Tail.Overlay.DriverContext[1];

            //
            //  Place a reference on this packet so that it won't get
            //  freed/reused until we are done with it.
            //
            NUIO_REF_SEND_PKT(pNdisPacket);
            break;
        }
    }

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);

    if (pNdisPacket != NULL)
    {
        //
        //  Either the send completion routine hasn't run, or we got a peak
        //  at the IRP/packet before it had a chance to take it out of the
        //  pending IRP queue.
        //
        //  We do not complete the IRP here - note that we didn't dequeue it
        //  above. This is because we always want the send complete routine to
        //  complete the IRP. And this in turn is because the packet that was
        //  prepared from the IRP has a buffer chain pointing to data associated
        //  with this IRP. Therefore we cannot complete the IRP before the driver
        //  below us is done with the data it pointed to.
        //

        //
        //  Request NDIS to cancel this send. The result of this call is that
        //  our SendComplete handler will be called (if not already called).
        //
        DEBUGP(DL_INFO, ("CancelWrite: cancelling pkt %p on Open %p\n",
            pNdisPacket, pOpenContext));
        NdisCancelSendPackets(
            pOpenContext->BindingHandle,
            NDIS_GET_PACKET_CANCEL_ID(pNdisPacket)
            );
        
        //
        //  It is now safe to remove the reference we had placed on the packet.
        //
        NUIO_DEREF_SEND_PKT(pNdisPacket);
    }
    //
    //  else the send completion routine has already picked up this IRP.
    //
}

#endif // NDIS51


VOID
NdisuioSendComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  Status
    )
/*++

Routine Description:

    NDIS entry point called to signify completion of a packet send.
    We pick up and complete the Write IRP corresponding to this packet.

    NDIS 5.1: 

Arguments:

    ProtocolBindingContext - pointer to open context
    pNdisPacket - packet that completed send
    Status - status of send

Return Value:

    None

--*/
{
    PIRP                        pIrp;
    PIO_STACK_LOCATION          pIrpSp;
    PNDISUIO_OPEN_CONTEXT       pOpenContext;

    pOpenContext = (PNDISUIO_OPEN_CONTEXT)ProtocolBindingContext;
    NUIO_STRUCT_ASSERT(pOpenContext, oc);

    pIrp = NUIO_IRP_FROM_SEND_PKT(pNdisPacket);

    if (pOpenContext->bRunningOnWin9x)
    {
        //
        //  We would have attached our own NDIS_BUFFER. Take it out
        //  and free it.
        //
#ifndef NDIS51
        PNDIS_BUFFER                pNdisBuffer;
        PVOID                       VirtualAddr;
        UINT                        BufferLength;
        UINT                        TotalLength;
#endif

#ifdef NDIS51
        NUIO_ASSERT(FALSE); // NDIS 5.1 not on Win9X!
#else
        NdisGetFirstBufferFromPacket(
            pNdisPacket,
            &pNdisBuffer,
            &VirtualAddr,
            &BufferLength,
            &TotalLength);

        NUIO_ASSERT(pNdisBuffer != NULL);
        NdisFreeBuffer(pNdisBuffer);
#endif
    }


#ifdef NDIS51
    IoSetCancelRoutine(pIrp, NULL);

    NUIO_ACQUIRE_LOCK(&pOpenContext->Lock);

    NUIO_REMOVE_ENTRY_LIST(&pIrp->Tail.Overlay.ListEntry);

    NUIO_RELEASE_LOCK(&pOpenContext->Lock);
#endif

    //
    //  We are done with the NDIS_PACKET:
    //
    NUIO_DEREF_SEND_PKT(pNdisPacket);

    //
    //  Complete the Write IRP with the right status.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = pIrpSp->Parameters.Write.Length;
        pIrp->IoStatus.Status = STATUS_SUCCESS;
    }
    else
    {
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    }

    DEBUGP(DL_INFO, ("SendComplete: packet %p/IRP %p/Length %d "
                    "completed with status %x\n",
                    pNdisPacket, pIrp, pIrp->IoStatus.Information, pIrp->IoStatus.Status));

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisInterlockedDecrement((PLONG)&pOpenContext->PendedSendCount);

    NUIO_DEREF_OPEN(pOpenContext); // send complete - dequeued send IRP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\adfext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adfext.c

Abstract:

    This file contains the generic routines
    for debugging NBF address files.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "adfext.h"

//
// Exported Functions
//

DECLARE_API( adfs )

/*++

Routine Description:

   Print a list of address files given
   the head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;

    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    PrintAddressFileList(NULL, proxyPtr, printDetail);
}

DECLARE_API( adf )

/*++

Routine Description:

   Print the NBF Address File at a
   memory location

Arguments:

    args - 
        Pointer to the NBF Addr File
        Detail of debug information

Return Value:

    None

--*/

{
    TP_ADDRESS_FILE AddressFile;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF Address File
    if (ReadAddressFile(&AddressFile, proxyPtr) != 0)
        return;

    // Print this Address File
    PrintAddressFile(&AddressFile, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintAddressFileList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_ADDRESS_FILE AddressFile;
    LIST_ENTRY      AddressFileList;
    PLIST_ENTRY     AddressFileListPtr;
    PLIST_ENTRY     AddressFileListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numAddrFiles;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF address files
        if (!ReadMemory(proxyPtr, &AddressFileList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "AddressFile ListEntry", proxyPtr);
            return;
        }

        AddressFileListPtr = &AddressFileList;
    }
    else
    {
        AddressFileListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list 

    dprintf("Address Files:\n");

    AddressFileListProxy = (PLIST_ENTRY)proxyPtr;
    
    numAddrFiles = 0;
    
    p = AddressFileListPtr->Flink;
    while (p != AddressFileListProxy)
    {
        // Another Address File
        numAddrFiles++;

        // Get Address File Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);

        // Get NBF Address File
        if (ReadAddressFile(&AddressFile, proxyPtr) != 0)
            break;
        
        // Print the Address File
        PrintAddressFile(&AddressFile, proxyPtr, printDetail);
        
        // Go to the next one
        p = AddressFile.Linkage.Flink;

        // Free the Address File
        FreeAddressFile(&AddressFile);
    }

    if (p == AddressFileListProxy)
    {
        dprintf("Number of Address Files: %lu\n", numAddrFiles);
    }
}

//
// Local Helper Functions
//

UINT
ReadAddressFile(PTP_ADDRESS_FILE pAddrFile, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF address file
    if (!ReadMemory(proxyPtr, pAddrFile, sizeof(TP_ADDRESS_FILE), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "AddressFile", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintAddressFile(PTP_ADDRESS_FILE pAddrFile, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF address file ?
    if (pAddrFile->Type != NBF_ADDRESSFILE_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "AddressFile", proxyPtr);
        return -1;
    }

    // What detail do we print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInAddressFile(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID
FieldInAddressFile(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_ADDRESS_FILE  AddressFile;

    if (ReadAddressFile(&AddressFile, structAddr) == 0)
    {
        PrintFields(&AddressFile, structAddr, fieldName, printDetail, &AddressFileInfo);
    }
}

UINT
FreeAddressFile(PTP_ADDRESS_FILE pAddrFile)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\conext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    conext.h

Abstract:

    This file contains all declarations
    used in handling NBF connections.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __CONEXT_H
#define __CONEXT_H

//
// Constants
//

// Linkage Type
#define LINKAGE     0
#define ADDRESS     1
#define ADDFILE     2

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)         FIELD_OFFSET(TP_CONNECTION, field)

//
// Helper Prototypes
//
UINT ReadConnection(PTP_CONNECTION pConnection, ULONG proxyPtr);

UINT PrintConnection(PTP_CONNECTION pConnection, ULONG proxyPtr, ULONG printDetail);

UINT FreeConnection(PTP_CONNECTION pConnection);

VOID PrintConnectionListOnAddress(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

VOID PrintConnectionListOnAddrFile(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);


//
// Constants
//

StructAccessInfo  ConnectionInfo =
{
    "Connection",

    {
        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,  LOW   },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,  LOW   },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,  LOW   },

        {   "SpecialRefCount",
                            OFFSET(SpecialRefCount),sizeof(ULONG),          NULL,  LOW   },

#if DBG
        {   "RefTypes",     OFFSET(RefTypes), 
                                    NUMBER_OF_CREFS*sizeof(ULONG),          NULL,   LOW  },
#endif

        {   "Flags",        OFFSET(Flags),          sizeof(ULONG),          NULL,  NOR   },

        {   "Flags2",       OFFSET(Flags2),         sizeof(ULONG),          NULL,  NOR   },

        {   "Link",         OFFSET(Link),           sizeof(PTP_LINK),
                                                            PrintDlcLinkFromPtr ,  NOR   },

        {   "AddressFile",  OFFSET(AddressFile),    sizeof(PTP_ADDRESS_FILE),    
                                                                            NULL,  LOW   },

        {   "Device Context",
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,  LOW   },

        {   "@",            0,                      0,                      NULL,  LOW   },

        {   "FileObject",   OFFSET(FileObject),     sizeof(PFILE_OBJECT),   NULL,  NOR   },

        {   "@",            0,                      0,                      NULL,  LOW   },

        {   "Context",      OFFSET(Context),        sizeof(CONNECTION_CONTEXT),   
                                                                            NULL,  LOW   },

        {   "ConnectionId", OFFSET(ConnectionId),   sizeof(USHORT),         NULL,  LOW   },

        {   "SessionNumber",OFFSET(SessionNumber),  sizeof(UCHAR),          NULL,  LOW   },

        {   "CalledAddress",
                            OFFSET(CalledAddress),  sizeof(NBF_NETBIOS_ADDRESS),
                                                          PrintNbfNetbiosAddress,  LOW   },

        {   "RemoteName",   OFFSET(RemoteName),     sizeof(CHAR *),  
                                                               PrintStringofLenN,  LOW   },

        {   "InProgressRequest",
                            OFFSET(InProgressRequest),
                                                    sizeof(LIST_ENTRY),
                                                                PrintRequestList,  LOW   },
        {   "ConsecutiveReceives",        
                            OFFSET(ConsecutiveReceives),
                                                    sizeof(ULONG),          NULL,  LOW   },
                                                    
        {   "IndicationInProgress",
                            OFFSET(IndicationInProgress),
                                                    sizeof(UINT),           NULL,  LOW   },

        {   "SpecialReceiveIrp",
                            OFFSET(SpecialReceiveIrp),
                                                    sizeof(PIRP),           NULL,  LOW   },

        {   "CurrentReceiveIrp",
                            OFFSET(CurrentReceiveIrp),
                                                    sizeof(PIRP),           NULL,  LOW   },

        {   "CurrentReceiveMdl",
                            OFFSET(CurrentReceiveMdl),
                                                    sizeof(PMDL),           NULL,  LOW   },

        {   "MessageBytesReceived",
                            OFFSET(MessageBytesReceived),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "MessageBytesAcked",
                            OFFSET(MessageBytesAcked),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "MessageInitAccepted",
                            OFFSET(MessageInitAccepted),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "ReceiveByteOffset",
                            OFFSET(ReceiveByteOffset),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "ReceiveLength",
                            OFFSET(ReceiveLength),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "ReceiveBytesUnaccepted",
                            OFFSET(ReceiveBytesUnaccepted),
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "ReceiveQueue",
                            OFFSET(ReceiveQueue),
                                                    sizeof(LIST_ENTRY),     NULL,  LOW   },

        {   "@",            0,                      0,                      NULL,  LOW   },
        
        {   "ConsecutiveSends",
                            OFFSET(ConsecutiveSends),          
                                                    sizeof(ULONG),          NULL,  LOW   },

        {   "OnPacketWaitQueue",
                            OFFSET(OnPacketWaitQueue),
                                                    sizeof(UINT),           NULL,  LOW   },

        {   "PacketWaitLinkage",
                            OFFSET(PacketWaitLinkage),
                                                    sizeof(LIST_ENTRY),     NULL,  LOW   },

        {   "CloseIrp",
                            OFFSET(CloseIrp),
                                                    sizeof(PIRP),           NULL,  LOW   },

        {   "@",            0,                      0,                      NULL,  LOW   },


#if PKT_LOG
        {   "LastNRecvs",   OFFSET(LastNRecvs),     sizeof(PKT_LOG_QUE),
                                                                  PrintPktLogQue,  LOW   },

        {   "LastNSends",   OFFSET(LastNSends),     sizeof(PKT_LOG_QUE),
                                                                  PrintPktLogQue,  LOW   },
                                                                  
        {   "LastNIndcs",   OFFSET(LastNIndcs),     sizeof(PKT_IND_QUE),
                                                                  PrintPktIndQue,  LOW   },
#endif

        {   "",             0,                      0,                      NULL,  LOW   },

        0
    }
};

#endif // __CONEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\adfext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adfext.h

Abstract:

    This file contains all declarations
    used in handling NBF address files.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __ADFEXT_H
#define __ADFEXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)         FIELD_OFFSET(TP_ADDRESS_FILE, field)

//
// Helper Prototypes
//
UINT ReadAddressFile(PTP_ADDRESS_FILE pAddrFile, ULONG proxyPtr);

UINT PrintAddressFile(PTP_ADDRESS_FILE pAddrFile, ULONG proxyPtr, ULONG printDetail);

UINT FreeAddressFile(PTP_ADDRESS_FILE pAddrFile);

VOID PrintAddressFileList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

//
// Constants
//

StructAccessInfo  AddressFileInfo =
{
    "AddressFile",

    {
        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },

        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,   LOW  },

        {   "Address",      OFFSET(Address),        sizeof(PTP_ADDRESS),    NULL,   LOW  },

        {   "Device Context",
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,   LOW  },

        {   "State",        OFFSET(State),          sizeof(UCHAR),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "FileObject",   OFFSET(FileObject),     sizeof(PFILE_OBJECT),   NULL,   LOW  },

        {   "CloseIrp",
                            OFFSET(CloseIrp),
                                                    sizeof(PIRP),           NULL,  LOW   },

        {   "@",            0,                      0,                      NULL,   LOW  },
        
        {   "ConnectIndicationInProgress",
                            OFFSET(ConnectIndicationInProgress),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },
        
        {   "RegisteredConnectionHandler",
                            OFFSET(RegisteredConnectionHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },
        
        {   "ConnectionHandler",
                            OFFSET(ConnectionHandler),
                                                    sizeof(PTDI_IND_CONNECT), 
                                                              PrintClosestSymbol,   LOW  },

        {   "ConnectionHandlerContext",
                            OFFSET(ConnectionHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },
        
        {   "RegisteredDisconnectHandler",
                            OFFSET(RegisteredDisconnectHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "DisconnectHandler",
                            OFFSET(DisconnectHandler),
                                                    sizeof(PTDI_IND_DISCONNECT), 
                                                              PrintClosestSymbol,   LOW  },

        {   "DisconnectHandlerContext",
                            OFFSET(DisconnectHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "RegisteredReceiveHandler",
                            OFFSET(RegisteredReceiveHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "ReceiveHandler",
                            OFFSET(ReceiveHandler),
                                  sizeof(PTDI_IND_RECEIVE),
                                                              PrintClosestSymbol,   LOW  },
                                                              
        {   "ReceiveHandlerContext",
                            OFFSET(ReceiveHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "RegisteredReceiveDatagramHandler",
                            OFFSET(RegisteredReceiveDatagramHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "ReceiveDatagramHandler",
                            OFFSET(ReceiveDatagramHandler),
                                  sizeof(PTDI_IND_RECEIVE_DATAGRAM),
                                                              PrintClosestSymbol,   LOW  },

        {   "ReceiveDatagramHandlerContext",
                            OFFSET(ReceiveDatagramHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },
                                                    
        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "RegisteredExpeditedDataHandler",
                            OFFSET(RegisteredExpeditedDataHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "ExpeditedDataHandler",
                            OFFSET(ExpeditedDataHandler),
                                  sizeof(PTDI_IND_RECEIVE_EXPEDITED),
                                                              PrintClosestSymbol,   LOW  },

        {   "ExpeditedDataHandlerContext",
                            OFFSET(ExpeditedDataHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },
                                                    
        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "RegisteredErrorHandler",
                            OFFSET(RegisteredErrorHandler),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "ErrorHandler", OFFSET(ErrorHandler),   sizeof(PTDI_IND_ERROR), 
                                                              PrintClosestSymbol,   LOW  },

        {   "ErrorHandlerContext",
                            OFFSET(ErrorHandlerContext),
                                                    sizeof(PVOID),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "ConnectionDatabase",
                            OFFSET(ConnectionDatabase),
                                        sizeof(LIST_ENTRY),    
                                                   PrintConnectionListOnAddrFile,   NOR  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "ReceiveDatagramQueue",
                            OFFSET(ReceiveDatagramQueue),
                                        sizeof(LIST_ENTRY),
                                                       PrintIRPListFromListEntry,   LOW  },
        
        {   "",             0,                      0,                      NULL,   LOW  },

        0
    }
};

#endif // __ADFEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\cteext.h ===
#if !defined( _INCLUDED_CTEEXT_H_ )
#define _INCLUDED_CTEEXT_H_

VOID
DumpCTELock
(
    ULONG LockToDump,
    VERBOSITY Verbosity
);

VOID
DumpCTETimer
(
    ULONG TimerToDump,
    VERBOSITY Verbosity
);

VOID
DumpWorkQueueItem
(
    ULONG ItemToDump,
    VERBOSITY Verbosity
);


VOID
DumpMdlChain
(
    ULONG MdlToDump,
    VERBOSITY Verbosity
);

VOID
DumpCTEEvent
(
    ULONG _objAddr,
    VERBOSITY Verbosity
);

VOID
DumpKEvent
(
    ULONG _objAddr,
    VERBOSITY Verbosity
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\conext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    conext.c

Abstract:

    This file contains the generic routines
    for debugging NBF connections.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "conext.h"

//
// Exported Functions
//

DECLARE_API( cons )

/*++

Routine Description:

   Print a list of conections given
   the head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;
    ULONG           linkage;
    
    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu %lu", &proxyPtr, &linkage, &printDetail);
    }

    switch(linkage)
    {
        case LINKAGE:
            PrintConnectionListOnLink(NULL, proxyPtr, printDetail);
            break;
            
        case ADDRESS:
            PrintConnectionListOnAddress(NULL, proxyPtr, printDetail);
            break;
            
        case ADDFILE:
            PrintConnectionListOnAddrFile(NULL, proxyPtr, printDetail);
            break;

        default:
            break;
    }
}

DECLARE_API( con )

/*++

Routine Description:

   Print the NBF Connection at a
   memory location

Arguments:

    args - 
        Pointer to the NBF Connection
        Detail of debug information

Return Value:

    None

--*/

{
    TP_CONNECTION Connection;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF Connection
    if (ReadConnection(&Connection, proxyPtr) != 0)
        return;

    // Print this Connection
    PrintConnection(&Connection, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintConnectionListOnLink(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_CONNECTION   Connection;
    LIST_ENTRY      ConnectionList;
    PLIST_ENTRY     ConnectionListPtr;
    PLIST_ENTRY     ConnectionListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numConnects;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF connections
        if (!ReadMemory(proxyPtr, &ConnectionList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Connection ListEntry", proxyPtr);
            return;
        }

        ConnectionListPtr = &ConnectionList;
    }
    else
    {
        ConnectionListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list

    dprintf("Connections On Link:\n");

    ConnectionListProxy = (PLIST_ENTRY)proxyPtr;
    
    numConnects = 0;
    
    p = ConnectionListPtr->Flink;
    while (p != ConnectionListProxy)
    {
        // Another Connection
        numConnects++;

        // Get Connection Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_CONNECTION, LinkList);

        // Get NBF Connection
        if (ReadConnection(&Connection, proxyPtr) != 0)
            break;
        
        // Print the Connection
        PrintConnection(&Connection, proxyPtr, printDetail);
        
        // Go to the next one
        p = Connection.LinkList.Flink;

        // Free the Connection
        FreeConnection(&Connection);
    }

    if (p == ConnectionListProxy)
    {
        dprintf("Number of Connections On Link: %lu\n", numConnects);
    }
}

VOID
PrintConnectionListOnAddress(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_CONNECTION   Connection;
    LIST_ENTRY      ConnectionList;
    PLIST_ENTRY     ConnectionListPtr;
    PLIST_ENTRY     ConnectionListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numConnects;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF connections
        if (!ReadMemory(proxyPtr, &ConnectionList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Connection ListEntry", proxyPtr);
            return;
        }

        ConnectionListPtr = &ConnectionList;
    }
    else
    {
        ConnectionListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list

    dprintf("Connections On Address:\n");

    ConnectionListProxy = (PLIST_ENTRY)proxyPtr;
    
    numConnects = 0;
    
    p = ConnectionListPtr->Flink;
    while (p != ConnectionListProxy)
    {
        // Another Connection
        numConnects++;

        // Get Connection Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

        // Get NBF Connection
        if (ReadConnection(&Connection, proxyPtr) != 0)
            break;
        
        // Print the Connection
        PrintConnection(&Connection, proxyPtr, printDetail);
        
        // Go to the next one
        p = Connection.AddressList.Flink;

        // Free the Connection
        FreeConnection(&Connection);
    }

    if (p == ConnectionListProxy)
    {
        dprintf("Number of Connections On Address: %lu\n", numConnects);
    }
}

VOID
PrintConnectionListOnAddrFile(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_CONNECTION   Connection;
    LIST_ENTRY      ConnectionList;
    PLIST_ENTRY     ConnectionListPtr;
    PLIST_ENTRY     ConnectionListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numConnects;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF connections
        if (!ReadMemory(proxyPtr, &ConnectionList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Connection ListEntry", proxyPtr);
            return;
        }

        ConnectionListPtr = &ConnectionList;
    }
    else
    {
        ConnectionListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list

    dprintf("Connections On AddrFile:\n");

    ConnectionListProxy = (PLIST_ENTRY)proxyPtr;
    
    numConnects = 0;
    
    p = ConnectionListPtr->Flink;
    while (p != ConnectionListProxy)
    {
        // Another Connection
        numConnects++;

        // Get Connection Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_CONNECTION, AddressFileList);

        // Get NBF Connection
        if (ReadConnection(&Connection, proxyPtr) != 0)
            break;
        
        // Print the Connection
        PrintConnection(&Connection, proxyPtr, printDetail);
        
        // Go to the next one
        p = Connection.AddressFileList.Flink;

        // Free the Connection
        FreeConnection(&Connection);
    }

    if (p == ConnectionListProxy)
    {
        dprintf("Number of Connections On AddrFile: %lu\n", numConnects);
    }
}

//
// Local Helper Functions
//

UINT
ReadConnection(PTP_CONNECTION pConnection, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF connection
    if (!ReadMemory(proxyPtr, pConnection, sizeof(TP_CONNECTION), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Connection", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintConnection(PTP_CONNECTION pConnection, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF connection ?
    if (pConnection->Type != NBF_CONNECTION_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "Connection", proxyPtr);
        return -1;
    }

    // What detail do we have to print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInConnection(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID
FieldInConnection(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_CONNECTION  Connection;

    if (ReadConnection(&Connection, structAddr) == 0)
    {
        PrintFields(&Connection, structAddr, fieldName, printDetail, &ConnectionInfo);
    }
}

UINT
FreeConnection(PTP_CONNECTION pConnection)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\adrext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adrext.h

Abstract:

    This file contains all declarations
    used in handling NBF addresses.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __ADREXT_H
#define __ADREXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)          FIELD_OFFSET(TP_ADDRESS, field)

//
// Helper Prototypes
//
UINT ReadAddress(PTP_ADDRESS pAddr, ULONG proxyPtr);

UINT PrintAddress(PTP_ADDRESS pAddr, ULONG proxyPtr, ULONG printDetail);

UINT FreeAddress(PTP_ADDRESS pAddr);

VOID PrintAddressList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

//
// Constants
//

StructAccessInfo  AddressInfo =
{
    "Address",

    {
        {   "NetworkName",  OFFSET(NetworkName),    
                                        sizeof(PNBF_NETBIOS_ADDRESS),
                                                   PrintNbfNetbiosAddressFromPtr,   LOW  },

        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },


        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,   LOW  },
        
#if DBG
        {   "RefTypes",     OFFSET(RefTypes), 
                                    NUMBER_OF_AREFS*sizeof(ULONG),          NULL,   LOW  },
#endif
        
        {   "SpinLock",     OFFSET(SpinLock),       sizeof(KSPIN_LOCK),     NULL,   LOW  },

        {   "Flags",        OFFSET(Flags),          sizeof(ULONG),          NULL,   LOW  },

        {   "DeviceContext",     
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,   LOW  },
        
        {   "UIFramePoolHandle",     
                            OFFSET(UIFramePoolHandle),       
                                                    sizeof(NDIS_HANDLE),    NULL,   LOW  },

        {   "UIFrame",      OFFSET(UIFrame),        sizeof(PTP_UI_FRAME),   NULL,   LOW  },
        
        {   "AddressFileDatabase",
                            OFFSET(AddressFileDatabase), 
                                                    sizeof(LIST_ENTRY),    
                                                            PrintAddressFileList,   NOR  },

        {   "ConnectionDatabase",
                            OFFSET(ConnectionDatabase),
                                        sizeof(LIST_ENTRY),                 NULL,
                                                /*PrintConnectionListOnAddress,*/   NOR  },

        {   "SendFlags",    OFFSET(SendFlags),      sizeof(ULONG),          NULL,   LOW  },

        {   "SendDatagramQueue",
                            OFFSET(SendDatagramQueue),
                                        sizeof(LIST_ENTRY),
                                                       PrintIRPListFromListEntry,   LOW  },


        {   "",             0,                      0,                      NULL,   LOW  },

        0
    }
};

#endif // __ADREXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\cteext.c ===
#include "precomp.h"
#pragma hdrstop


#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Mdl
#define _objAddr    MdlToDump
#define _objType    MDL

VOID
DumpMdlChain
(
    ULONG _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read MDL structure\n", _objAddr );
        return;
    }

    PrintStartStruct();
    PrintPtr( Next );
    PrintUShort( Size );
    PrintXUShort( MdlFlags );
    PrintPtr( Process );
    PrintPtr( MappedSystemVa );
    PrintPtr( StartVa );
    PrintULong( ByteCount );
    PrintULong( ByteOffset );
    return;
}

VOID
DumpCTELock
(
    ULONG LockToDump,
    VERBOSITY Verbosity
)
{
    CTELock Lock;
    CTELock *pLock;
    ULONG result;

    pLock = ( CTELock * )LockToDump;

    if ( !ReadMemory( LockToDump,
                      &Lock,
                      sizeof( Lock ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTELock structure\n", LockToDump );
        return;
    }

    dprintf( "{ Lock = %d }", Lock );
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Timer
#define _objAddr    pItem
#define _objType    CTETimer

VOID
DumpCTETimer
(
    ULONG TimerToDump,
    VERBOSITY Verbosity
)
{
    CTETimer Timer;
    CTETimer *prTimer;
    ULONG result;

    prTimer = ( CTETimer * )TimerToDump;

    if ( !ReadMemory( TimerToDump,
                      &Timer,
                      sizeof( Timer ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTETimer structure\n", TimerToDump );
        return;
    }

    PrintStart;
    PrintULong( t_running );
    PrintLock( t_lock );
    PrintSymbolPtr( t_handler );
    PrintXULong( t_arg );
    // DPC
    // KTIMER
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Event
#define _objAddr    pItem
#define _objType    CTEEvent

VOID
DumpCTEEvent
(
    ULONG _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read CTEEvent structure\n", _objAddr );
        return;
    }

    PrintStart;
    PrintULong( ce_scheduled );
    PrintLock( ce_lock );
    PrintSymbolPtr( ce_handler );
    PrintXULong( ce_arg );
    PrintWorkQueueItem( ce_workitem );
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        KEvent
#define _objAddr    pItem
#define _objType    KEVENT

VOID
DumpKEvent
(
    ULONG _objAddr,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    ULONG result;

    if ( !ReadMemory( _objAddr,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf("%08lx: Could not read KEvent structure\n", _objAddr );
        return;
    }

    PrintStart;
    PrintUChar( Header.Type );
    PrintUChar( Header.Absolute );
    PrintUChar( Header.Size );
    PrintUChar( Header.Inserted );
    PrintXULong( Header.SignalState );
    PrintLL( Header.WaitListHead );
    PrintEnd;
    return;
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        QItem
#define _objAddr    prQItem
#define _objType    WORK_QUEUE_ITEM

VOID
DumpWorkQueueItem
(
    ULONG ItemToDump,
    VERBOSITY Verbosity
)
{
    _objType _obj;
    _objType *_objAddr;
    ULONG result;

    _objAddr = ( _objType * )ItemToDump;

    if ( !ReadMemory( ItemToDump,
                      &_obj,
                      sizeof( _obj ),
                      &result ))
    {
        dprintf( "%08lx: Could not read %s structure\n",
                 ItemToDump,
                 "WORK_QUEUE_ITEM" );
        return;
    }

    PrintStart;
    PrintLL( List );
    PrintSymbolPtr( WorkerRoutine );
    PrintXULong( Parameter );
    PrintEnd;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\adrext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adrext.c

Abstract:

    This file contains the generic routines
    for debugging NBF address structures.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "adrext.h"

//
// Exported Functions
//

DECLARE_API( adrs )

/*++

Routine Description:

   Print a list of addresses given the
   head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;

    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    PrintAddressList(NULL, proxyPtr, printDetail);
}

DECLARE_API( adr )

/*++

Routine Description:

   Print the NBF Address at a location

Arguments:

    args - 
        Pointer to the NBF Address
        Detail of debug information

Return Value:

    None

--*/

{
    TP_ADDRESS  Address;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF Address
    if (ReadAddress(&Address, proxyPtr) != 0)
        return;

    // Print this Address
    PrintAddress(&Address, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintAddressList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_ADDRESS      Address;
    LIST_ENTRY      AddressList;
    PLIST_ENTRY     AddressListPtr;
    PLIST_ENTRY     AddressListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numAddrs;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF addresses
        if (!ReadMemory(proxyPtr, &AddressList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Address ListEntry", proxyPtr);
            return;
        }

        AddressListPtr = &AddressList;
    }
    else
    {
        AddressListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list 

    dprintf("Addresses:\n");

    AddressListProxy = (PLIST_ENTRY)proxyPtr;
    
    numAddrs = 0;
    
    p = AddressListPtr->Flink;
    while (p != AddressListProxy)
    {
        // Another Address
        numAddrs++;

        // Get Address Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

        // Get NBF Address
        if (ReadAddress(&Address, proxyPtr) != 0)
            break;
        
        // Print the Address
        PrintAddress(&Address, proxyPtr, printDetail);
        
        // Go to the next one
        p = Address.Linkage.Flink;

        // Free the Address
        FreeAddress(&Address);
    }

    if (p == AddressListProxy)
    {
        dprintf("Number of Addresses: %lu\n", numAddrs);
    }
}

//
// Local Helper Functions
//

UINT
ReadAddress(PTP_ADDRESS pAddr, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF address
    if (!ReadMemory(proxyPtr, pAddr, sizeof(TP_ADDRESS), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Address", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintAddress(PTP_ADDRESS pAddr, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF address ?
    if (pAddr->Type != NBF_ADDRESS_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "Address", proxyPtr);
        return -1;
    }

    // What detail do we print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInAddress(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID
FieldInAddress(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_ADDRESS  Address;

    if (ReadAddress(&Address, structAddr) == 0)
    {
        PrintFields(&Address, structAddr, fieldName, printDetail, &AddressInfo);
    }
}

UINT
FreeAddress(PTP_ADDRESS pAddr)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\devext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    devext.c

Abstract:

    This file contains the generic routines
    for debugging NBF device contexts.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "devext.h"

//
// Exported Functions
//

DECLARE_API( devs )

/*++

Routine Description:

   Print a list of devices on the NBF's
   devices list [@ nbf!NbfDeviceList ]

Arguments:

    args - Detail of debug information
    
Return Value:

    None

--*/

{
    DEVICE_CONTEXT  DeviceContext;
    PLIST_ENTRY     NbfDeviceLPtr;
    LIST_ENTRY      NbfDeviceList;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numDevs;
    ULONG           bytesRead;
    ULONG           printDetail;

    // Get the detail of debug information needed
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%lu", &printDetail);
    }

    // Get the address corresponding to symbol
    proxyPtr = GetLocation("nbf!NbfDeviceList");
    
    // Read the list entry of NBF devices
    if (!ReadMemory(proxyPtr, &NbfDeviceList, sizeof(LIST_ENTRY), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "NbfDeviceList", proxyPtr);
        return;
    }

    // Traverse the doubly linked list 

    dprintf("Devices:\n");

    NbfDeviceLPtr = (PLIST_ENTRY)proxyPtr;
    
    numDevs = 0;
    
    p = NbfDeviceList.Flink;
    while (p != NbfDeviceLPtr)
    {
        // Another Device
        numDevs++;

        // Device Context Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, DEVICE_CONTEXT, Linkage);

        // Get Device Context
        if (ReadDeviceContext(&DeviceContext, proxyPtr) != 0)
            break;
        
        // Print the Context
        PrintDeviceContext(&DeviceContext, proxyPtr, printDetail);
        
        // Go to the next one
        p = DeviceContext.Linkage.Flink;

        // Free Device Context
        FreeDeviceContext(&DeviceContext);
    }

    if (p == NbfDeviceLPtr)
    {
        dprintf("Number of Devices: %lu\n", numDevs);
    }
}

DECLARE_API( dev )

/*++

Routine Description:

   Print the device context at an addr

Arguments:

    args - 
        Address of the device context
        Detail of debug information

Return Value:

    None

--*/

{
    DEVICE_CONTEXT  DeviceContext;
    ULONG           printDetail;
    ULONG           proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get Device Context
    if (ReadDeviceContext(&DeviceContext, proxyPtr) != 0)
        return;

    // Print the Context
    PrintDeviceContext(&DeviceContext, proxyPtr, printDetail);
}

//
// Helper Functions
//

UINT
ReadDeviceContext(PDEVICE_CONTEXT pDevCon, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current device context
    if (!ReadMemory(proxyPtr, pDevCon, sizeof(DEVICE_CONTEXT), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "DeviceContext", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintDeviceContext(PDEVICE_CONTEXT pDevCon, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF device context ?
    if (pDevCon->Type != NBF_DEVICE_CONTEXT_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "DeviceContext", proxyPtr);
        return -1;
    }

    // What detail do we have to print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInDeviceContext(proxyPtr, NULL, printDetail);

    return 0;
}

VOID
FieldInDeviceContext(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    DEVICE_CONTEXT  DeviceContext;

    if (ReadDeviceContext(&DeviceContext, structAddr) == 0)
    {
        PrintFields(&DeviceContext, structAddr, fieldName, printDetail, &DeviceContextInfo);
    }
}

UINT
FreeDeviceContext(PDEVICE_CONTEXT pDevCon)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\lnkext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    lnkext.c

Abstract:

    This file contains the generic routines
    for debugging NBF's DLC links.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "lnkext.h"

//
// Exported Functions
//

DECLARE_API( lnks )

/*++

Routine Description:

   Print a list of DLC links given
   the head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;

    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    PrintDlcLinkList(NULL, proxyPtr, printDetail);
}

DECLARE_API( lnk )

/*++

Routine Description:

   Print the NBF's DLC Link at a
   memory location

Arguments:

    args - 
        Pointer to the NBF DLC Link
        Detail of debug information

Return Value:

    None

--*/

{
    TP_LINK     DlcLink;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF DLC Link
    if (ReadDlcLink(&DlcLink, proxyPtr) != 0)
        return;

    // Print this DLC Link
    PrintDlcLink(&DlcLink, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintDlcLinkList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_LINK         DlcLink;
    LIST_ENTRY      DlcLinkList;
    PLIST_ENTRY     DlcLinkListPtr;
    PLIST_ENTRY     DlcLinkListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numDlcLinks;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF DLC links
        if (!ReadMemory(proxyPtr, &DlcLinkList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "DLC Link ListEntry", proxyPtr);
            return;
        }

        DlcLinkListPtr = &DlcLinkList;
    }
    else
    {
        DlcLinkListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list 

    dprintf("DLC Links:\n");

    DlcLinkListProxy = (PLIST_ENTRY)proxyPtr;
    
    numDlcLinks = 0;
    
    p = DlcLinkListPtr->Flink;
    while (p != DlcLinkListProxy)
    {
        // Another DLC Link
        numDlcLinks++;

        // Get DLC Link Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_LINK, Linkage);

        // Get NBF DLC Link
        if (ReadDlcLink(&DlcLink, proxyPtr) != 0)
            break;
        
        // Print the DLC Link
        PrintDlcLink(&DlcLink, proxyPtr, printDetail);
        
        // Go to the next one
        p = DlcLink.Linkage.Flink;

        // Free the DLC Link
        FreeDlcLink(&DlcLink);
    }

    if (p == DlcLinkListProxy)
    {
        dprintf("Number of DLC Links: %lu\n", numDlcLinks);
    }
}

//
// Local Helper Functions
//

UINT
ReadDlcLink(PTP_LINK pDlcLink, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF DLC link
    if (!ReadMemory(proxyPtr, pDlcLink, sizeof(TP_LINK), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "DLC Link", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintDlcLink(PTP_LINK pDlcLink, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF DLC link ?
    if (pDlcLink->Type != NBF_LINK_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "DLC Link", proxyPtr);
        return -1;
    }

    // What detail do we print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInDlcLink(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID PrintDlcLinkFromPtr(PVOID DlcLinkPtrPointer, ULONG DlcLinkPtrProxy, ULONG printDetail)
{
    ULONG                   pDlcLinkProxy;
    ULONG                   bytesRead;
    TP_LINK                 DlcLink;

    if (DlcLinkPtrPointer == NULL)
    {
        if (!ReadMemory(DlcLinkPtrProxy, &DlcLinkPtrPointer, sizeof(PVOID), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "NBF DLC Link Ptr", DlcLinkPtrProxy);
            return;
        }
    }

    pDlcLinkProxy = *(ULONG *)DlcLinkPtrPointer;
    
    dprintf("%08x (Ptr)\n", pDlcLinkProxy);

    if (pDlcLinkProxy)
    {
        if (ReadDlcLink(&DlcLink, pDlcLinkProxy) == 0)
        {
            PrintDlcLink(&DlcLink, pDlcLinkProxy, printDetail);
        }
    }
}

VOID
FieldInDlcLink(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_LINK  DlcLink;

    if (ReadDlcLink(&DlcLink, structAddr) == 0)
    {
        PrintFields(&DlcLink, structAddr, fieldName, printDetail, &DlcLinkInfo);
    }
}

UINT
FreeDlcLink(PTP_LINK pDlcLink)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\device.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    device.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"

#pragma hdrstop

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;

#define KD_OBJECT_HEADER_TO_QUOTA_INFO( roh, loh ) (POBJECT_HEADER_QUOTA_INFO) \
    ((loh)->QuotaInfoOffset == 0 ? NULL : ((PCHAR)(roh) - (loh)->QuotaInfoOffset))

#define KD_OBJECT_HEADER_TO_HANDLE_INFO( roh, loh ) (POBJECT_HEADER_HANDLE_INFO) \
    ((loh)->HandleInfoOffset == 0 ? NULL : ((PCHAR)(roh) - (loh)->HandleInfoOffset))

#define KD_OBJECT_HEADER_TO_NAME_INFO( roh, loh ) (POBJECT_HEADER_NAME_INFO) \
    ((loh)->NameInfoOffset == 0 ? NULL : ((PCHAR)(roh) - (loh)->NameInfoOffset))

#define KD_OBJECT_HEADER_TO_CREATOR_INFO( roh, loh ) (POBJECT_HEADER_CREATOR_INFO) \
    (((loh)->Flags & OB_FLAG_CREATOR_INFO) == 0 ? NULL : ((PCHAR)(roh) - sizeof(OBJECT_HEADER_CREATOR_INFO))))

VOID
DumpDevice(
    PVOID DeviceAddress,
    BOOLEAN FullDetail
    );

VOID PrintDeviceObject(PVOID fieldPtr, ULONG fieldProxy, ULONG printDetail)
{
    dprintf("Device Object @ %08x\n", fieldProxy);
    DumpDevice((PVOID)fieldProxy, TRUE);
}

VOID
DumpDevice(
    PVOID DeviceAddress,
    BOOLEAN FullDetail
    )

/*++

Routine Description:

    Displays the driver name for the device object if FullDetail == FALSE.
    Otherwise displays more information about the device and the device queue.

Arguments:

    DeviceAddress - address of device object to dump.
    FullDetail    - TRUE means the device object name, driver name, and
                    information about Irps queued to the device.

Return Value:

    None

--*/

{
    ULONG                      result;
    ULONG                      i;
    PUCHAR                     buffer;
    DEVICE_OBJECT              deviceObject;
    UNICODE_STRING             unicodeString;
    PLIST_ENTRY                nextEntry;
    PVOID                      queueAddress;
    PIRP                       irp;
    KDEVICE_QUEUE_ENTRY        queueEntry;
    POBJECT_HEADER             pObjectHeader;
    OBJECT_HEADER              objectHeader;
    POBJECT_HEADER_NAME_INFO   pNameInfo;
    OBJECT_HEADER_NAME_INFO    NameInfo;



    if ((!ReadMemory( (DWORD)DeviceAddress,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || (result < sizeof(deviceObject))) {
        dprintf("%08lx: Could not read device object\n", DeviceAddress);
        return;
    }

    if (deviceObject.Type != IO_TYPE_DEVICE) {
        dprintf("%08lx: is not a device object\n", DeviceAddress);
        return;
    }

    if (FullDetail == TRUE) {

        //
        // Dump the device name if present.
        //

        pObjectHeader = OBJECT_TO_OBJECT_HEADER(DeviceAddress);
        if (ReadMemory( (DWORD)pObjectHeader,
                          &objectHeader,
                          sizeof(objectHeader),
                          &result) && (result == sizeof(objectHeader))) {
            pNameInfo = KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &objectHeader );
            if (ReadMemory((DWORD)pNameInfo,
                           &NameInfo,
                           sizeof(NameInfo),
                           &result) && (result == sizeof(NameInfo))) {
                buffer = LocalAlloc(LPTR, NameInfo.Name.MaximumLength);
                if (buffer != NULL) {
                    unicodeString.MaximumLength = NameInfo.Name.MaximumLength;
                    unicodeString.Length = NameInfo.Name.Length;
                    unicodeString.Buffer = (PWSTR)buffer;
                    if (ReadMemory((DWORD)NameInfo.Name.Buffer,
                                   buffer,
                                   unicodeString.Length,
                                   &result) && (result == unicodeString.Length)) {
                        dprintf(" %wZ", &unicodeString);
                    }
                    LocalFree(buffer);
                }
            }
        }
    }

//  DumpDriver((PVOID) deviceObject.DriverObject, FALSE);

    if (FullDetail == TRUE) {
        //
        // Dump Irps related to driver.
        //

        dprintf("  DriverObject %08lx\n", deviceObject.DriverObject);
        dprintf("Current Irp %08lx RefCount %d Type %08lx ",
                deviceObject.CurrentIrp,
                deviceObject.ReferenceCount,
                deviceObject.DeviceType);
        if (deviceObject.AttachedDevice) {
            dprintf("AttachedDev %08lx ", deviceObject.AttachedDevice);
        }
        if (deviceObject.Vpb) {
            dprintf("Vpb %08lx ", deviceObject.Vpb);
        }

        dprintf("DevExt %08lx\n", deviceObject.DeviceExtension);

        if (deviceObject.DeviceQueue.Busy) {

            if (IsListEmpty(&deviceObject.DeviceQueue.DeviceListHead)) {
                dprintf("Device queue is busy -- Queue empty\n");
            } else {
                dprintf("DeviceQueue: ");
                nextEntry = deviceObject.DeviceQueue.DeviceListHead.Flink;
                i = 0;

                while ((PCH) nextEntry != (PCH)
                    ((PCH) DeviceAddress +
                         ((PCH) &deviceObject.DeviceQueue.DeviceListHead.Flink -
                              (PCH) &deviceObject))) {
                    queueAddress = CONTAINING_RECORD(nextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);
                    if ((!ReadMemory((DWORD)queueAddress,
                                     &queueEntry,
                                     sizeof(queueEntry),
                                     &result)) || (result < sizeof(queueEntry))) {
                        dprintf("%08lx: Could not read queue entry\n", DeviceAddress);
                        return;
                    }

                    irp = CONTAINING_RECORD(&queueEntry,
                                            IRP,
                                            Tail.Overlay.DeviceQueueEntry);

                    dprintf("%08lx%s",
                            irp,
                            (i & 0x03) == 0x03 ? "\n\t     " : " ");
                    if (CheckControlC()) {
                        break;
                    }
                }
                dprintf("\n");
            }
        } else {
            dprintf("Device queue is not busy.\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\lnkext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    linext.h

Abstract:

    This file contains all declarations
    used in handling NBF's DLC Links.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __LNKEXT_H
#define __LNKEXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)         FIELD_OFFSET(TP_LINK, field)

//
// Helper Prototypes
//
UINT ReadDlcLink(PTP_LINK pDlcLink, ULONG proxyPtr);

UINT PrintDlcLink(PTP_LINK pDlcLink, ULONG proxyPtr, ULONG printDetail);

UINT FreeDlcLink(PTP_LINK pDlcLink);

//
// Constants
//

StructAccessInfo  DlcLinkInfo =
{
    "DLC Link",

    {
        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },

        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,   LOW  },

        {   "SpecialRefCount",
                            OFFSET(SpecialRefCount), sizeof(ULONG),         NULL,   LOW  },

#if DBG
        {   "RefTypes",     OFFSET(RefTypes), 
                                    NUMBER_OF_LREFS*sizeof(ULONG),          NULL,   LOW  },
#endif

        {   "Loopback",     OFFSET(Loopback),       sizeof(BOOLEAN),        NULL,   LOW  },

        {   "HardwareAddress",
                            OFFSET(HardwareAddress),sizeof(HARDWARE_ADDRESS),
                                                                            NULL,   LOW  },

        {   "MaxFrameSize", OFFSET(MaxFrameSize),   sizeof(ULONG),          NULL,   LOW  },
                            
        {   "ActiveConnectionCount",
                            OFFSET(ActiveConnectionCount),
                                                    sizeof(ULONG),          NULL,   NOR  },
        
        {   "ConnectionDatabase",
                            OFFSET(ConnectionDatabase),
                                                    sizeof(LIST_ENTRY),     NULL,   NOR  },

        {   "Device Context",
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "Flags",        OFFSET(Flags),          sizeof(ULONG),          NULL,   NOR  },

        {   "DeferredFlags",OFFSET(DeferredFlags),  sizeof(ULONG),          NULL,   NOR  },

        {   "State",        OFFSET(State),          sizeof(ULONG),          NULL,   NOR  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "ReceiveState", OFFSET(ReceiveState),   sizeof(UCHAR),          NULL,   LOW  },

        {   "NextReceive",  OFFSET(NextReceive),    sizeof(UCHAR),          NULL,   LOW  },

        {   "LastAckSent",  OFFSET(LastAckSent),    sizeof(UCHAR),          NULL,   LOW  },

        {   "ReceiveWindowSize",
                            OFFSET(ReceiveWindowSize),
                                                    sizeof(UCHAR),          NULL,   LOW  },

        {   "ConsecutiveIFrames",
                            OFFSET(ConsecutiveIFrames),
                                                    sizeof(UCHAR),          NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "SendState",    OFFSET(SendState),      sizeof(UCHAR),          NULL,   LOW  },

        {   "NdisSendsInProgress",
                            OFFSET(NdisSendsInProgress),
                                                    sizeof(ULONG),          NULL,   LOW  },
        {   "NdisSendQueue",
                            OFFSET(NdisSendQueue),  sizeof(LIST_ENTRY),     NULL,   LOW  },

        {   "WackQ",        OFFSET(WackQ),          sizeof(LIST_ENTRY),     NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,  LOW   },
        
#if PKT_LOG
        {   "LastNRecvs",   OFFSET(LastNRecvs),     sizeof(PKT_LOG_QUE),
                                                                  PrintPktLogQue,  LOW   },

        {   "LastNSends",   OFFSET(LastNSends),     sizeof(PKT_LOG_QUE),
                                                                  PrintPktLogQue,  LOW   },
#endif

        {   "",             0,                      0,                      NULL,  LOW   },

        0
    }
};

#endif // __LNKEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\nbfcom.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nbfcom.c

Abstract:

    This file contains the generic routines
    for the kernel debugger extensions dll.

Author:

    Chaitanya Kodeboyina (Chaitk)

Environment:

    User Mode

--*/

#include "precomp.h"

#pragma hdrstop

//
// Misc Helper Routines
//

ULONG
GetLocation (
    PCHAR String
    )
{
    ULONG Location;
    
    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return Location;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    if ((!ReadMemory((DWORD)Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return Value;
}

VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
)
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement;

    GetSymbol( Pointer, SymbolName, &Displacement );

    if ( Displacement == 0 )
    {
        dprintf( "(%s)%s", SymbolName, EndOfLine );
    }
    else
    {
        dprintf( "(%s + 0x%X)%s", SymbolName, Displacement, EndOfLine );
    }
}

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
)
{
    CHAR ch;
    int index;

    for ( index = 0; index < cch; index ++ )
    {
        ch = pch[ index ];
        dprintf( "%c", ( ch >= 32 ) ? ch : '.' );
    }
}

VOID
dprint_hardware_address
(
    PUCHAR Address
)
{
    dprintf( "%02x-%02x-%02x-%02x-%02x-%02x",
             Address[ 0 ],
             Address[ 1 ],
             Address[ 2 ],
             Address[ 3 ],
             Address[ 4 ],
             Address[ 5 ] );
}

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
)
{
    while ( pEnumInfo->pszDescription != NULL )
    {
        if ( pEnumInfo->Value == Value )
        {
            dprintf( "%.40s", pEnumInfo->pszDescription );
            return( TRUE );
        }
        pEnumInfo ++;
    }

    dprintf( "Unknown enumeration value." );
    return( FALSE );
}

BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
)
{
    BOOL bFoundOne = FALSE;

    while ( pFlagInfo->pszDescription != NULL )
    {
        if ( pFlagInfo->Value & Value )
        {
            if ( bFoundOne )
            {
                dprintf( " | " );
            }
            bFoundOne = TRUE;

            dprintf( "%.15s", pFlagInfo->pszDescription );
        }
        pFlagInfo ++;
    }

    return( bFoundOne );
}

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
)
{
    CHAR Buf[ 9 ];
    ULONG nibble;
    int index;

    for ( index = 0; index < 8; index ++ )
    {
        nibble = ( Mask & 0xF0000000 );
/*
        dprintf( "#%d: nibble == %08X\n"
                 "      Mask == %08X\n"
                 "     Value == %08X\n", index, nibble, Mask, Value );

*/
        if ( nibble )
        {
            Buf[ index ] = "0123456789abcdef"[ (( nibble & Value ) >> 28) & 0xF ];
        }
        else
        {
            Buf[ index ] = ' ';
        }

        Mask <<= 4;
        Value <<= 4;
    }

    Buf[ 8 ] = '\0';

    dprintf( "%s", Buf );

    return( TRUE );
}

VOID dprint_addr_list
( 
    ULONG FirstAddress, 
    ULONG OffsetToNextPtr 
)
{
    ULONG Address;
    ULONG result;
    int index;

    Address = FirstAddress;

    if ( Address == (ULONG)NULL )
    {
        dprintf( "%08X (Empty)\n", Address );
        return;
    }

    dprintf( "{ " );

    for ( index = 0; Address != (ULONG)NULL; index ++ )
    {
        if ( index != 0 )
        {
            dprintf( ", ");
        }
        dprintf( "%08X", Address );

        if ( !ReadMemory( Address + OffsetToNextPtr,
                          &Address,
                          sizeof( Address ),
                          &result ))
        {
            dprintf( "ReadMemory() failed." );
            Address = (ULONG)NULL;
        }
    }
    dprintf( " }\n" );
}

VOID PrintStringofLenN(PVOID Pointer, ULONG PtrProxy, ULONG printDetail)
{
    dprint_nchar((CHAR *)Pointer, 16);
}

VOID PrintClosestSymbol(PVOID Pointer, ULONG PtrProxy, ULONG printDetail)
{
    dprintSymbolPtr((PVOID)(*(ULONG *)Pointer), "");
}

VOID PrintFields
( 
    PVOID   pStructure, 
    ULONG   structProxy,
    CHAR   *fieldPrefix,
    ULONG   printDetail,
    StructAccessInfo *pStructInfo
)
{
    FieldAccessInfo *pFieldInfo;
    BOOLEAN printAll;
    BOOLEAN printField;
    UINT    i, j, k;
    ULONG  *pUlong;
    ULONG   proxyPtr;
    ULONG   childDetail;

    dprintf("\n@@Struct: %s @ %08x\n", pStructInfo->Name, structProxy);
    
    if (printDetail == NULL_INFO)
    {
        return;
    }
    
    if ((fieldPrefix == NULL) || (fieldPrefix[0] == '\0'))
        printAll = TRUE;
    else
        printAll = FALSE;

    for (i = 0; i < MAX_FIELD; i++)
    {
        pFieldInfo = &pStructInfo->fieldInfo[i];

        if (pFieldInfo->Name[0] == '\0')
            break;

        printField = FALSE;
        if ((printDetail == FULL_SHAL)
                || (printDetail == FULL_DEEP)
                    || (pFieldInfo->Importance == HIG)
                            || ((printDetail != SUMM_INFO) &&
                                    (pFieldInfo->Importance > LOW)))
        {
            printField = TRUE;
        }
        
        if (pFieldInfo->Name[0] == '@')
        {
            if (printField)
            {
                dprintf("\n");
            }
            continue;
        }

        if ((printAll) || strstr(pFieldInfo->Name, fieldPrefix))
        {
            pUlong = (ULONG *)(((CHAR *)pStructure) + pFieldInfo->Offset);
            proxyPtr = (ULONG)(((CHAR *)structProxy) + pFieldInfo->Offset);

            if (pFieldInfo->PrintField)
            {
                switch (printDetail)
                {
                    case FULL_DEEP:
                    case NORM_DEEP:
                        childDetail = printDetail;
                        break;

                    case NORM_SHAL:
                    case FULL_SHAL:
                        childDetail = SUMM_INFO;
                        break;
                        
                    case SUMM_INFO:
                        childDetail = NULL_INFO;
                }

                if (printField)
                {
                    dprintf("@Field: %40s\t", pFieldInfo->Name);
    
                    dprintf("\n%08x  ", proxyPtr);

                    pFieldInfo->PrintField(pUlong, 
                                           proxyPtr, 
                                           childDetail);

                    dprintf("\n");
                }
            }
            else
            {
                if (printField)                
                {
                    dprintf("@Field: %40s\t", pFieldInfo->Name);

                    if (pFieldInfo->Size <= sizeof(ULONG))
                    {
                        dprintf("%08x ", proxyPtr);
                        j = pFieldInfo->Size;
                    }
                    else
                    {                    
                        for (k = 0, j = 4; j <= pFieldInfo->Size; j += 4)
                        {
                            if (j % 16 == 4)
                            {
                                k = (k + 1) % 8;
                                if (k == 0)
                                {
                                    dprintf("\n");
                                }

                                dprintf("\n%08x ", proxyPtr);
                                                            
                                proxyPtr += 0x10;
                            }
                            
                            dprintf(" %08x", *pUlong++);
                        }

                        j = pFieldInfo->Size - j + 4;
                    }

                    switch (j)
                    {
                        case 4:
                            dprintf(" %08x", *pUlong);
                            break;

                        case 3:
                            dprintf(" ....%04x", *(USHORT *)pUlong);
                            pUlong = (ULONG *)(((UCHAR *)pUlong) + 2);
                            dprintf(" ......%02x", *(UCHAR  *)pUlong);
                            break;

                        case 2:
                            dprintf(" ....%04x", *(USHORT *)pUlong);
                            break;

                        case 1:
                            dprintf(" ......%02x", *(UCHAR  *)pUlong);
                            break;
                    }
                    
                    dprintf("\n");
                }
            }
        }
    }
}

//
// Misc NBF Specific Helpers
//

#if PKT_LOG

VOID PrintPktLogQue(PVOID pointer, ULONG proxyPtr, ULONG printDetail)
{
    UINT         i, j;
    PKT_LOG_QUE  PktLog;
    PKT_LOG_QUE *pPktLog;
    ULONG        bytesRead;

    // Get list of logged packets & debug print level
    if (pointer == NULL)
    {
        // Read the packet log queue
        if (!ReadMemory(proxyPtr, &PktLog, sizeof(PKT_LOG_QUE), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Packet Log Queue", proxyPtr);
            return;
        }

        pPktLog = &PktLog;
    }
    else
    {
        pPktLog = (PKT_LOG_QUE *) pointer;
    }

    // Print the packet log queue
    dprintf("PktNext = %d, PktQue = %08x\n",
                pPktLog->PktNext,
               &((PKT_LOG_QUE *)proxyPtr)->PktQue);

    for (i = 0; i < PKT_QUE_SIZE; i++)
    {
        j = (pPktLog->PktNext + i) % PKT_QUE_SIZE;
        
        dprintf("P%02d: TS = %05d, BT = %5d, BS = %5d, DH = %08x, PD = %08x\n",  
                    j,
                    pPktLog->PktQue[j].TimeLogged,
                    pPktLog->PktQue[j].BytesTotal,
                    pPktLog->PktQue[j].BytesSaved,
                    *(ULONG *)pPktLog->PktQue[j].PacketData,
                   &((PKT_LOG_QUE *)proxyPtr)->PktQue[j].PacketData);
    }
}

VOID PrintPktIndQue(PVOID pointer, ULONG proxyPtr, ULONG printDetail)
{
    UINT         i, j;
    PKT_IND_QUE  PktLog;
    PKT_IND_QUE *pPktLog;
    ULONG        bytesRead;

    // Get list of logged packets & debug print level
    if (pointer == NULL)
    {
        // Read the packet log queue
        if (!ReadMemory(proxyPtr, &PktLog, sizeof(PKT_IND_QUE), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Packet Ind Queue", proxyPtr);
            return;
        }

        pPktLog = &PktLog;
    }
    else
    {
        pPktLog = (PKT_IND_QUE *) pointer;
    }

    // Print the packet log queue
    dprintf("PktNext = %d, PktQue = %08x\n",
                pPktLog->PktNext,
               &((PKT_IND_QUE *)proxyPtr)->PktQue);

    for (i = 0; i < PKT_QUE_SIZE; i++)
    {
        j = (pPktLog->PktNext + i) % PKT_QUE_SIZE;
        
        dprintf("P%02d: TS = %05d, BT = %5d, BI = %5d, BK = %5d, PD = %08x, S = %08x\n",
                    j,
                    pPktLog->PktQue[j].TimeLogged,
                    pPktLog->PktQue[j].BytesTotal,
                    pPktLog->PktQue[j].BytesIndic,
                    pPktLog->PktQue[j].BytesTaken,
                    &((PKT_LOG_QUE *)proxyPtr)->PktQue[j].PacketData,
                    pPktLog->PktQue[j].IndcnStatus);
    }
}

#endif

VOID PrintNbfNetbiosAddressFromPtr(PVOID AddressPtrPointer, ULONG AddressPtrProxy, ULONG printDetail)
{
    ULONG                   pNetbiosAddressProxy;
    ULONG                   bytesRead;

    if (AddressPtrPointer == NULL)
    {
        if (!ReadMemory(AddressPtrProxy, &AddressPtrPointer, sizeof(PVOID), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "NBF Netbios Address Ptr", AddressPtrProxy);
            return;
        }
    }

    pNetbiosAddressProxy = *(ULONG *)AddressPtrPointer;
    
    dprintf("%08x (Ptr)\n", pNetbiosAddressProxy);

    if (pNetbiosAddressProxy)
    {
        PrintNbfNetbiosAddress(NULL, *(ULONG *)AddressPtrPointer, printDetail);
    }
}

VOID PrintNbfNetbiosAddress(PVOID AddressPointer, ULONG AddressProxy, ULONG printDetail)
{
    PNBF_NETBIOS_ADDRESS    pNetbiosAddress;
    NBF_NETBIOS_ADDRESS     NetbiosAddress;
    ULONG                   bytesRead;
    CHAR                    NetbiosNameTypes[3][10] = { "UNIQUE", "GROUP", "EITHER" };

    if (AddressPointer == NULL)
    {
        if (!ReadMemory(AddressProxy, &NetbiosAddress, sizeof(NBF_NETBIOS_ADDRESS), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "NBF Netbios Address", AddressProxy);
            return;
        }
        
        pNetbiosAddress = &NetbiosAddress;
    }
    else
    {
        pNetbiosAddress = (PNBF_NETBIOS_ADDRESS) AddressPointer;
    }
    
    dprintf("Name: ");
    dprint_nchar(pNetbiosAddress->NetbiosName, 16);
    dprintf(", ");
    
    if (pNetbiosAddress->NetbiosNameType > 2)
    {
        dprintf("Type: %s\n", "UNKNOWN");
    }
    else
    {
        dprintf("Type: %s\n", 
                        NetbiosNameTypes[pNetbiosAddress->NetbiosNameType]);
    }
}

VOID PrintNbfPacketPoolListFromPtr(PVOID PacketPoolPtrPointer, ULONG PacketPoolPtrProxy, ULONG printDetail)
{
    ULONG                   pPacketPoolProxy;
    ULONG                   bytesRead;

    if (PacketPoolPtrPointer == NULL)
    {
        if (!ReadMemory(PacketPoolPtrProxy, &PacketPoolPtrPointer, sizeof(PVOID), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "NBF Packet Pool Ptr", PacketPoolPtrProxy);
            return;
        }
    }

    pPacketPoolProxy = *(ULONG *)PacketPoolPtrPointer;
    
    dprintf("%08x (Ptr)\n", pPacketPoolProxy);

    if (pPacketPoolProxy)
    {
        PrintNbfPacketPoolList(NULL, *(ULONG *)PacketPoolPtrPointer, printDetail);
    }
}

VOID PrintNbfPacketPoolList(PVOID PacketPoolPointer, ULONG PacketPoolProxy, ULONG printDetail)
{
    PNBF_POOL_LIST_DESC     pPacketPoolList;
    NBF_POOL_LIST_DESC      PacketPoolList;
    ULONG                   bytesRead;

    if (PacketPoolPointer == NULL)
    {
        if (!ReadMemory(PacketPoolProxy, &PacketPoolList, sizeof(NBF_POOL_LIST_DESC), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                                "NBF Packet Pool", PacketPoolProxy);
            return;
        }

        pPacketPoolList = &PacketPoolList;
    }
    else
    {
        pPacketPoolList = (PNBF_POOL_LIST_DESC) PacketPoolPointer;
    }

    while (pPacketPoolList)
    {
        dprintf("PoolHandle: %08x, Num: %08x, Total: %08x\n",
                    pPacketPoolList->PoolHandle,
                    pPacketPoolList->NumElements,
                    pPacketPoolList->TotalElements);

        if ((PacketPoolProxy = (ULONG) pPacketPoolList->Next) == (ULONG) NULL)
            break;
        
        if (!ReadMemory(PacketPoolProxy, &PacketPoolList, sizeof(NBF_POOL_LIST_DESC), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                                "NBF Packet Pool", PacketPoolProxy);
            return;
        }
        
        pPacketPoolList = &PacketPoolList;
    }    
}

VOID PrintListFromListEntryAndOffset(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG ListEntryOffset)
{
    PLIST_ENTRY             pListEntry;
    LIST_ENTRY              ListEntry;
    ULONG                   ListHeadProxy;
    ULONG                   bytesRead;
    ULONG                   numItems;

    if (ListEntryPointer == NULL)
    {
        if (!ReadMemory(ListEntryProxy, &ListEntry, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                                    "List Entry", ListEntryProxy);
            return;
        }

        pListEntry = &ListEntry;
    }
    else
    {
        pListEntry = (PLIST_ENTRY) ListEntryPointer;
    }

    dprintf("\n%08x  LE : %08x, %08x\n", ListEntryProxy - ListEntryOffset, 
                                            pListEntry->Flink, 
                                            pListEntry->Blink);

    ListHeadProxy = ListEntryProxy; numItems = 0;
    
    while (((ULONG) pListEntry->Flink != ListHeadProxy) && (numItems < 100))
    {
        ListEntryProxy = (ULONG) pListEntry->Flink;
        
        if (!ReadMemory(ListEntryProxy, &ListEntry, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                                    "List Entry", ListEntryProxy);
            return;
        }
    
        pListEntry = &ListEntry;

        dprintf("%08x  %02d : %08x, %08x\n", ListEntryProxy - ListEntryOffset, 
                                                numItems++, 
                                                pListEntry->Flink, 
                                                pListEntry->Blink);
    }

    if (numItems == 100)
    {
        dprintf("Looks like we have an infinite loop @ %08x\n", ListHeadProxy);
    }
}

VOID PrintListFromListEntry(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG debugDetail)
{
    PrintListFromListEntryAndOffset(ListEntryPointer, ListEntryProxy, 0);
}

VOID PrintIRPListFromListEntry(PVOID IRPListEntryPointer, ULONG IRPListEntryProxy, ULONG debugDetail)
{
    PrintListFromListEntryAndOffset(IRPListEntryPointer, IRPListEntryProxy, 
                                        FIELD_OFFSET(IRP, Tail.Overlay.ListEntry));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\hdrext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    hdrext.h

Abstract:

    This file contains all declarations
    used in handling NBF / DLC Headers.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __HDREXT_H
#define __HDREXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

//
// Helper Prototypes
//
UINT ReadNbfPktHdr(PNBF_HDR pPktHdr, ULONG proxyPtr);

UINT PrintNbfPktHdr(PNBF_HDR pPktHdr, ULONG proxyPtr, ULONG printDetail);

UINT FreeNbfPktHdr(PNBF_HDR pPktHdr);

//
// Constants
//
#ifdef OFFSET
#undef OFFSET
#endif
#define OFFSET(field)          FIELD_OFFSET(NBF_HDR_GENERIC, field)

//
// A Generic View of any NBF Header
//

StructAccessInfo  NbfGenPktHdrInfo =
{
    "Nbf Generic Packet Header",

    {
        {   "Length",       OFFSET(Length),         sizeof(USHORT),     NULL,   LOW  },

        {   "Signature",    OFFSET(Signature),      2*sizeof(UCHAR),    NULL,   LOW  },

        {   "Command",      OFFSET(Command),        sizeof(UCHAR),      NULL,   NOR  },

        {   "Data1",        OFFSET(Data1),          sizeof(UCHAR),      NULL,   LOW  },

        {   "Data2",        OFFSET(Data2),          sizeof(USHORT),     NULL,   LOW  },

        {   "TransmitCorrelator",
                            OFFSET(TransmitCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },
        {   "ResponseCorrelator",
                            OFFSET(ResponseCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },

        {   "",             0,                      0,                  NULL,   LOW  },

        0
    }
};

//
// NBF Header for a Connection-oriented data xfer
//

#ifdef OFFSET
#undef OFFSET
#endif
#define OFFSET(field)          FIELD_OFFSET(NBF_HDR_CONNECTION, field)

StructAccessInfo  NbfConnectionHdrInfo =
{
    "Nbf CO Packet Header",

    {
        {   "Length",       OFFSET(Length),         sizeof(USHORT),     NULL,   LOW  },

        {   "Signature",    OFFSET(Signature),      sizeof(USHORT),     NULL,   LOW  },

        {   "Command",      OFFSET(Command),        sizeof(UCHAR),      NULL,   NOR  },

        {   "Data1",        OFFSET(Data1),          sizeof(UCHAR),      NULL,   LOW  },

        {   "Data2Low",     OFFSET(Data2Low),       sizeof(UCHAR),      NULL,   LOW  },

        {   "Data2High",    OFFSET(Data2High),      sizeof(UCHAR),      NULL,   LOW  },

        {   "TransmitCorrelator",
                            OFFSET(TransmitCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },
        {   "ResponseCorrelator",
                            OFFSET(ResponseCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },

        {   "DestinationSessionNumber",
                            OFFSET(DestinationSessionNumber),
                                                    sizeof(UCHAR),      NULL,   LOW  },

        {   "SourceSessionNumber",
                            OFFSET(SourceSessionNumber),
                                                    sizeof(UCHAR),      NULL,   LOW  },

        {   "",             0,                      0,                  NULL,   LOW  },

        0
    }
};

//
// NBF Header for a Connection-less data xfer
//

#ifdef OFFSET
#undef OFFSET
#endif
#define OFFSET(field)          FIELD_OFFSET(NBF_HDR_CONNECTIONLESS, field)

StructAccessInfo  NbfConnectionLessHdrInfo =
{
    "Nbf CL Packet Header",

    {
        {   "Length",       OFFSET(Length),         sizeof(USHORT),     NULL,   LOW  },

        {   "Signature",    OFFSET(Signature),      sizeof(USHORT),     NULL,   LOW  },

        {   "Command",      OFFSET(Command),        sizeof(UCHAR),      NULL,   NOR  },

        {   "Data1",        OFFSET(Data1),          sizeof(UCHAR),      NULL,   LOW  },

        {   "Data2Low",     OFFSET(Data2Low),       sizeof(UCHAR),      NULL,   LOW  },

        {   "Data2High",    OFFSET(Data2High),      sizeof(UCHAR),      NULL,   LOW  },

        {   "TransmitCorrelator",
                            OFFSET(TransmitCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },
        {   "ResponseCorrelator",
                            OFFSET(ResponseCorrelator),
                                                    sizeof(USHORT),     NULL,   LOW  },

        {   "DestinationName",
                            OFFSET(DestinationName),
                              NETBIOS_NAME_LENGTH * sizeof(UCHAR),      NULL,   LOW  },

        {   "SourceName",
                            OFFSET(SourceName),
                              NETBIOS_NAME_LENGTH * sizeof(UCHAR),      NULL,   LOW  },

        {   "",             0,                      0,                  NULL,   LOW  },

        0
    }
};

#endif // __HDREXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\devext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    devext.h

Abstract:

    This file contains all declarations
    used in handling device contexts.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __DEVEXT_H
#define __DEVEXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)          FIELD_OFFSET(DEVICE_CONTEXT, field)

//
// Helper Prototypes
//
UINT ReadDeviceContext(PDEVICE_CONTEXT pDevCon, ULONG proxyPtr);

UINT PrintDeviceContext(PDEVICE_CONTEXT pDevCon, ULONG proxyPtr, ULONG printDetail);

UINT FreeDeviceContext(PDEVICE_CONTEXT pDevCon);

//
// Constants
//

StructAccessInfo  DeviceContextInfo =
{
    "DeviceContext",

    {
        {   "DeviceObject", OFFSET(DeviceObject),   sizeof(DEVICE_OBJECT),
                                                                 PrintDeviceObject, HIG  },

        {   "State",        OFFSET(State),          sizeof(UCHAR),          NULL,   HIG  },

        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },

        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },

#if DBG
        {   "RefTypes",     OFFSET(RefTypes), 
                                    NUMBER_OF_DCREFS*sizeof(ULONG),         NULL,   LOW  },
#endif

        {   "NdisBindingHandle",
                            OFFSET(NdisBindingHandle),
                                                    sizeof(NDIS_HANDLE),    NULL,   LOW  },
        {   "LocalAddress",
                            OFFSET(LocalAddress),
                                                    sizeof(HARDWARE_ADDRESS),
                                                                            NULL,   LOW  },
        {   "NetBIOSAddress",
                            OFFSET(NetBIOSAddress),
                                                    sizeof(HARDWARE_ADDRESS),
                                                                            NULL,   LOW  },

        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },

        {   "LinkPool",     OFFSET(LinkPool),       sizeof(LIST_ENTRY),     NULL
                                                          /* PrintDlcLinkList */,   LOW  },

        {   "LinkDeferred", OFFSET(LinkDeferred),   sizeof(LIST_ENTRY),     NULL
                                                          /* PrintDlcLinkList */,   LOW  },

        {   "LoopbackLinks",OFFSET(LoopbackLinks),2*sizeof(PTP_LINK),       NULL,   LOW  },

        {   "IndicationQueuesInUse",
                            OFFSET(IndicationQueuesInUse),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "AddressDatabase",
                            OFFSET(AddressDatabase), sizeof(LIST_ENTRY),
                                                                 PrintAddressList,  NOR  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "MacInfo",      OFFSET(MacInfo),        sizeof(NBF_NDIS_IDENTIFICATION),
                                                                            NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "ReservedAddressHandle",
                            OFFSET(ReservedAddressHandle),
                                                    sizeof(HANDLE),         NULL,   LOW  },

        {   "ReservedNetBIOSAddress",
                            OFFSET(ReservedNetBIOSAddress),
                                 NETBIOS_NAME_LENGTH *sizeof(CHAR),         NULL,   LOW  },
                                                    

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "MaxConsecutiveIFrames",
                            OFFSET(MaxConsecutiveIFrames),
                                                     sizeof(UCHAR),         NULL,   LOW  },
        
        {   "TempIFramesReceived",     
                            OFFSET(TempIFramesReceived), 
                                                     sizeof(ULONG),         NULL,   LOW  },
                                                     
        {   "TempIFrameBytesReceived",     
                            OFFSET(TempIFrameBytesReceived), 
                                                     sizeof(ULONG),         NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "SendPacketPoolDesc",
                            OFFSET(SendPacketPoolDesc),
                                                    sizeof(PNBF_POOL_LIST_DESC),
                                                   PrintNbfPacketPoolListFromPtr,   LOW  },

        {   "SendPacketPoolSize",
                            OFFSET(SendPacketPoolSize),
                                                    sizeof(ULONG),          NULL,   LOW  },

        {   "ReceivePacketPoolDesc",
                            OFFSET(ReceivePacketPoolDesc),
                                                    sizeof(PNBF_POOL_LIST_DESC),
                                                   PrintNbfPacketPoolListFromPtr,   LOW  },

        {   "ReceivePacketPoolSize",
                            OFFSET(ReceivePacketPoolSize),
                                                    sizeof(ULONG),          NULL,   LOW  },

        {   "NdisBufferPool",
                            OFFSET(NdisBufferPool), sizeof(NDIS_HANDLE),    NULL,   LOW  },

        {   "@",            0,                      0,                      NULL,   LOW  },

        {   "LinkSpinLock", OFFSET(LinkSpinLock),   sizeof(KSPIN_LOCK),     NULL,   LOW  },

        {   "LastLink",     OFFSET(LastLink),       sizeof(PTP_LINK),       NULL,   LOW  },

        {   "LinkTreeRoot", OFFSET(LinkTreeRoot),   sizeof(PRTL_SPLAY_LINKS),     
                                                                            NULL,   LOW  },
        {   "LinkTreeElements",
                            OFFSET(LinkTreeElements),
                                                    sizeof(ULONG),          NULL,   LOW  },

        {   "LinkDeferred", OFFSET(LinkDeferred),   sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "",             0,                      0,                      NULL,   LOW  },

        0
    }
};

#endif // __DEVEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\hdrext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    hdrext.c

Abstract:

    This file contains the generic routines
    for debugging NBF / DLC Headers.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "hdrext.h"

//
// Exported Functions
//

DECLARE_API( nhdr )

/*++

Routine Description:

   Print an NBF packet header at an addr

Arguments:

    args - 
        Address of the packet header
        Detail of debug information

Return Value:

    None

--*/

{
    NBF_HDR         NbfPktHdr;
    ULONG           printDetail;
    ULONG           proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF header
    if (ReadNbfPktHdr(&NbfPktHdr, proxyPtr) != 0)
        return;

    // Print the header
    PrintNbfPktHdr(&NbfPktHdr, proxyPtr, printDetail);
}

//
// Helper Functions
//

UINT
ReadNbfPktHdr(PNBF_HDR pPktHdr, ULONG proxyPtr)
{
    USHORT          hdrlen;
    ULONG           bytesRead;

    // Read the current packet header length
    if (!ReadMemory(proxyPtr, &hdrlen, sizeof(USHORT), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Packet Header", proxyPtr);
        return -1;
    }

    // Validate the length of the NBF header
    switch (hdrlen)
    {
        case sizeof(NBF_HDR_CONNECTION):
            // dprintf("Connection Oriented: \n");
            break;

        case sizeof(NBF_HDR_CONNECTIONLESS):
            // dprintf("Connection Less: \n");
            break;

        case sizeof(NBF_HDR_GENERIC):
            // dprintf("Generic Header: \n");
            break;

        default:
            dprintf("%s @ %08x: Improper len = %08x\n",
                        "Packet Header", proxyPtr, hdrlen);
            return -1;
    }

    // Read the current packet header
    if (!ReadMemory(proxyPtr, pPktHdr, hdrlen, &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Packet Header", proxyPtr);
        return -1;
    }
    return 0;
}

UINT
PrintNbfPktHdr(PNBF_HDR pPktHdr, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF packet header ?
    if (HEADER_SIGNATURE(&pPktHdr->Generic) != NETBIOS_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "Packet Header", proxyPtr);
        return -1;
    }

    // What detail do we have to print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInNbfPktHdr(proxyPtr, NULL, printDetail);

    return 0;
}

VOID
FieldInNbfPktHdr(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    NBF_HDR             NbfHdr;
    StructAccessInfo   *StInfo;

    if (ReadNbfPktHdr(&NbfHdr, structAddr) == 0)
    {
        switch (NbfHdr.Generic.Length)
        {
            case sizeof(NBF_HDR_CONNECTION):
                StInfo = &NbfConnectionHdrInfo;
                break;

            case sizeof(NBF_HDR_CONNECTIONLESS):
                StInfo = &NbfConnectionLessHdrInfo;
                break;

            case sizeof(NBF_HDR_GENERIC):
                StInfo = &NbfGenPktHdrInfo;
                break;

            default:
                return;
        }

        PrintFields(&NbfHdr, structAddr, fieldName, printDetail, StInfo);
    }
}

UINT
FreeNbfPktHdr(PNBF_HDR pPktHdr)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\nbfcom.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nbfcom.h

Abstract:

    This file is a common header file for nbfext.dll

Author:

    Chaitanya Kodeboyina (Chaitk)

Environment:

    User Mode

--*/

#ifndef __NBFCOM_H
#define __NBFCOM_H

#define ITEMSIZE    25

typedef struct
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

#define EnumString( Value ) { Value, #Value }

extern ENUM_INFO EnumStructureType[];

//#define EOL ( (Item++ & 1) ? "\n":"" )
typedef enum
{
    VERBOSITY_ONE_LINER = 0,
    VERBOSITY_NORMAL,
    VERBOSITY_FULL
} VERBOSITY;

#define PrintStart Item = 0;

extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange( cch ) { IndentBuf[_Indent]=' '; _Indent += ( cch ); IndentBuf[_Indent]='\0';}
#define Indent( cch ) IndentChange( cch )
#define Outdent( cch ) IndentChange( -( cch ) )

#define PrintStartStruct()  { PrintStart; dprintf( "%s{\n", IndentBuf ); Indent( 2 );  }

#define PrintStartNamedStruct( _name )  { PrintStart; dprintf( "%s%s {\n", IndentBuf, _name ); Indent( 2 );  }

static PCHAR pchEol = "\n";
static PCHAR pchBlank = "";
static PCHAR * ppchCurrentEol = &pchEol;
static PCHAR * ppchTempEol = &pchEol;

#define PrintJoin() { ppchCurrentEol = &pchBlank; }

#define EOL (( ppchTempEol = ppchCurrentEol ), ( ppchCurrentEol = &pchEol ), ( *ppchTempEol ))

VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
);

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
);

VOID
dprint_hardware_address
(
    PUCHAR Address
);

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
);


BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
);

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
);

VOID
dprint_addr_list(
    ULONG FirstAddress,
    ULONG OffsetToNextPtr
);

ULONG
GetUlongValue (
    PCHAR String
);

/*
#define PrintEnd   \
        dprintf( "%s", EOL ); \
        Item = 0;
*/

#define PrintEnd   \
        Item = 0;

#define PrintEndStruct()  { Outdent( 2 ); PrintEnd; dprintf( "%s}\n", IndentBuf ); }

#define PrintFlushLeft() PrintEnd

#define PRINTBOOL(var)  ( (var) ? "True" : "False")

#define PrintFieldName(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s = ",IndentBuf,_fieldName );                                        \
        }

#define PrintFieldNameAt(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s @ ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s @ ",IndentBuf,_fieldName );                                        \
        }

#define PrintListTcpFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s q_next = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s q_next = ",IndentBuf,_fieldName );                                        \
        }

#define PrintListFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s FLink = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s FLink = ",IndentBuf,_fieldName );                                        \
        }

#define PrintIndent()   dprintf( "%s", IndentBuf );
/* #define PrintFieldName(_fieldName) \
        dprintf(" %-25.25s = ",_fieldName );*/

#define PrintRawBool( _bValue ) \
            dprintf("%-10s%s", (_obj._bValue) ? "True" : "False", EOL)

#define PrintBool(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10s%s", (_obj._field) ? "True" : "False", EOL)

#define PrintULong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", _obj._field, EOL)

#define PrintXULong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08lx%s", _obj._field, EOL)

#define PrintUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", _obj._field, EOL)

#define PrintHTONUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", htons(_obj._field), EOL)

#define PrintXUShort(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%04hx%s", _obj._field, EOL)

#define PrintNChar( _field, count )        \
            PrintFieldName(#_field)  \
            dprint_nchar( ( PCHAR )_obj._field, count ); \
            dprintf("%s", EOL)

#define PrintUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", (ULONG) _obj._field, EOL)

#define PrintXUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("0x%-8lx%s", (ULONG) _obj._field, EOL)

#define PrintPtr(_field)            \
            PrintFieldName(#_field)  \
            dprintf("%-10lx%s", _obj._field, EOL)

#define PrintSymbolPtr( _field )    \
            PrintFieldName(#_field)  \
            dprintSymbolPtr( (( PVOID )_obj._field), EOL );

#define AddressOf( _field ) ((( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ))

#define PrintAddr(_field)               \
            PrintFieldNameAt(#_field)   \
            dprintf("%-10lx%s", AddressOf( _field ), EOL)

#define PrintL(_field) \
            PrintFieldName(#_field##".Next")  \
            dprintf("%-10lx%s",  _obj._field.Next, EOL )

#define PrintLL(_field)                                     \
            PrintEnd;                                       \
            PrintListFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.Flink );         \
            dprintf("Blink = %-10lx",  _obj._field.Blink );         \
            dprintf("%s\n", ( _obj._field.Flink == _obj._field.Blink ) ? " (Empty)" : "" );

#define PrintLLTcp(_field)                                     \
            PrintEnd;                                       \
            PrintListTcpFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.q_next );         \
            dprintf("q_prev = %-10lx",  _obj._field.q_prev );         \
            dprintf("%s\n", ( _obj._field.q_next == _obj._field.q_prev ) ? " (Empty)" : "" );

#define PrintIrpQ(_field) \
            PrintEnd;   \
            PrintFieldName(#_field##".Head");                 \
            dprintf("%-10lx",  _obj._field.Head );            \
            PrintFieldName(#_field##".Tail");                 \
            dprintf("%-10lx\n",  _obj._field.Tail );

#define PrintFlags( _field, _pFlagStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );     \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintFlagsMask( _field, _pFlagStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintEnum( _field, _pEnumStruct )                   \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("%lu (", (ULONG) _obj._field );         \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnum( _field, _pEnumStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );    \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnumMask( _field, _pEnumStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_enum_name((ULONG) _obj._field & _Mask, _pEnumStruct );  \
            dprintf( ")\n" );


#define PrintHardwareAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_hardware_address( _obj._field.Address ); \
            dprintf( "%s", EOL );

#define PrintIpxLocalTarget( _field )                       \
            PrintStartNamedStruct( #_field );               \
            PrintFieldName( "NicId" );                      \
            dprintf("%-10u%s", _obj._field.NicId, EOL);    \
            PrintFieldName( "MacAddress" );                 \
            dprint_hardware_address( _obj._field.MacAddress ); \
            dprintf( "%s", EOL );                           \
            PrintEndStruct();

#define PrintIPAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_IP_address( _obj._field ); \
            dprintf( "%s", EOL );


#define PrintLock(_field) \
            PrintFieldName(#_field)  \
            dprintf("( 0x%08lx ) %-10s%s", (_obj._field), (_obj._field) ? "Locked" : "UnLocked", EOL)

#define PrintTDIAddress( _field )                           \
            PrintFieldName( #_field );                      \
            dprintf( "{ NetworkAddress = %X, NodeAddress = ", _obj._field.NetworkAddress );\
            dprint_hardware_address( _obj._field.NodeAddress );\
            dprintf( ", Socket = %d }%s", _obj._field.Socket, EOL );

#define PrintCTETimer( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTETimer ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintCTEEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTEEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintKEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpKEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintWorkQueueItem( _field )                        \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpWorkQueueItem ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();


extern  BOOLEAN ChkTarget;
extern  INT     Item;

#define CHECK_SIGNATURE( _field, _signature )   \
    if ( _obj._field != _signature )            \
    {                                           \
        dprintf( "Object at %08X doesn't have signature %s at %08X\n",   \
                 _objAddr,                                              \
                 #_signature,                                           \
                 (( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ));\
    }

//
// Constants
//

#define MAX_SYMBOL_LEN   80
#define MAX_FIELD       256

enum PRINT_DETAIL { 
                    NULL_INFO,  // 0
                    SUMM_INFO,  // 1
                    NORM_SHAL,  // 2
                    FULL_SHAL,  // 3
                    NORM_DEEP,  // 4
                    FULL_DEEP   // 5
                  };

#define MIN_DETAIL  NULL_INFO
#define MAX_DETAIL  FULL_DEEP

enum FIELD_IMPORTANCE
                  {
                    LOW,        // 0
                    NOR,        // 1
                    HIG         // 2
                  };

//
// Structures
//

typedef VOID (*funcPrintField) (PVOID fieldPtr, ULONG fieldProxy, ULONG printDetail);

typedef struct _FieldAccessInfo
{
    CHAR            Name[MAX_SYMBOL_LEN];
    ULONG           Offset;
    ULONG           Size;
    funcPrintField  PrintField;
    ULONG           Importance;
} FieldAccessInfo;

typedef struct _StructAccessInfo
{
    CHAR            Name[MAX_SYMBOL_LEN];
    FieldAccessInfo fieldInfo[MAX_FIELD];
} StructAccessInfo;

//
// Common Prototypes
//

ULONG GetLocation(PCHAR String);

VOID  PrintClosestSymbol(PVOID Pointer, ULONG PtrProxy, ULONG printDetail);

VOID  PrintFields(PVOID pStructure, ULONG structProxy, CHAR *fieldPrefix, 
                         ULONG printDetail, StructAccessInfo *pStructInfo);

VOID  PrintListFromListEntryAndOffset(PVOID ListEntryPointer, 
                              ULONG ListEntryProxy, ULONG ListEntryOffset);

//
// Global Prototypes
//

// Device Context Helpers
VOID FieldInDeviceContext(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

// Address Helpers
VOID FieldInAddress(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

VOID PrintAddressList(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

// Address File Helpers
VOID FieldInAddressFile(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

VOID PrintAddressFileList(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

// Connection Helpers
VOID FieldInConnection(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

VOID PrintConnectionListOnLink(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

VOID PrintConnectionListOnAddress(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

VOID PrintConnectionListOnAddrFile(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

// DLC Link Helpers
VOID FieldInDlcLink(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

UINT PrintDlcLink(PTP_LINK DlcLinkPointer, ULONG DlcLinkProxy, ULONG printDetail);

VOID PrintDlcLinkList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

VOID PrintDlcLinkFromPtr(PVOID DlcLinkPtrPointer, ULONG DlcLinkPtrProxy, ULONG printDetail);

// Request Helpers
VOID FieldInRequest(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

VOID PrintRequestList(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

// Packet Helpers
VOID FieldInPacket(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

VOID PrintPacketList(PVOID ListEntryPtr, ULONG ListEntryProxy, ULONG printDetail);

// Packet Header Helpers
VOID FieldInNbfPktHdr(ULONG structAddr, CHAR *fieldName, ULONG printDetail);

// Device Helpers
VOID PrintDeviceObject(PVOID fieldPtr, ULONG fieldProxy, ULONG printDetail);

// Packet Log Helpers
VOID PrintPktLogQue(PVOID pPktLog, ULONG proxyPtr, ULONG printDetail);

VOID PrintPktIndQue(PVOID pPktLog, ULONG proxyPtr, ULONG printDetail);

// Miscellaneous Helpers
VOID PrintStringofLenN(PVOID Pointer, ULONG PtrProxy, ULONG printDetail);

VOID PrintNbfPacketPoolList(PVOID Pointer, ULONG PtrProxy, ULONG printDetail);

VOID PrintNbfPacketPoolListFromPtr(PVOID PacketPoolPtrPointer, ULONG PacketPoolPtrProxy, ULONG printDetail);

VOID PrintNbfNetbiosAddress(PVOID AddressPointer, ULONG AddressProxy, ULONG printDetail);

VOID PrintNbfNetbiosAddressFromPtr(PVOID AddressPtrPointer, ULONG AddressPtrProxy, ULONG printDetail);

VOID PrintListFromListEntry(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

VOID PrintIRPListFromListEntry(PVOID IRPListEntryPointer, ULONG IRPListEntryProxy, ULONG debugDetail);

#endif // __NBFCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\nbfext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nbfext.h

Abstract:

    This file is a common header file for nbfext.dll

Author:

    Chaitanya Kodeboyina (Chaitk)

Environment:

    User Mode

--*/

#ifndef __NBFEXT_H
#define __NBFEXT_H

#define DUMMY   0

#endif // __NBFEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\precomp.h ===
#define ISN_NT 1

//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>

#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <nb30.h>
#include <cxport.h>
#include <ndis.h>
#include <tdikrnl.h>

#include "nbfconst.h"
#include "nbfmac.h"
#include "nbfhdrs.h"
#include "nbfcnfg.h"
#include "nbftypes.h"
#include "nbfprocs.h"

#include "nbfcom.h"
#include "traverse.h"
#include "cteext.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\pktext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pktext.h

Abstract:

    This file contains all declarations
    used in handling NBF packets.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __PKTEXT_H
#define __PKTEXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)          FIELD_OFFSET(TP_PACKET, field)

//
// Helper Prototypes
//
UINT ReadPacket(PTP_PACKET pPkt, ULONG proxyPtr);

UINT PrintPacket(PTP_PACKET pPkt, ULONG proxyPtr, ULONG printDetail);

UINT FreePacket(PTP_PACKET pPkt);

VOID PrintPacketList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

//
// Constants
//

StructAccessInfo  PacketInfo =
{
    "Packet",

    {
        {   "NdisPacket",   OFFSET(NdisPacket),     sizeof(PNDIS_PACKET),   NULL,   LOW  },

        {   "NdisIFrameLength",
                            OFFSET(NdisIFrameLength),
                                                    sizeof(ULONG),          NULL,   LOW  },
                                                    
        {   "Owner",        OFFSET(Owner),          sizeof(PVOID),          NULL,   LOW  },
        
        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },


        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,   LOW  },

        {   "PacketSent",   OFFSET(PacketSent),     sizeof(BOOLEAN),        NULL,   LOW  },

        {   "PacketNoNdisBuffer",
                            OFFSET(PacketNoNdisBuffer),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "Action",       OFFSET(Action),         sizeof(UCHAR),          NULL,   LOW  },

        {   "PacketizeConnection",
                            OFFSET(PacketizeConnection),
                                                    sizeof(BOOLEAN),        NULL,   LOW  },

        {   "Link",         OFFSET(Link),           sizeof(PTP_LINK),       NULL,   LOW  },

        {   "DeviceContext",     
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,   LOW  },

        {   "ProviderInterlock",
                            OFFSET(ProviderInterlock),
                                                    sizeof(PKSPIN_LOCK),    NULL,   LOW  },

        {   "Header",       OFFSET(Header),         sizeof(UCHAR),          NULL,   LOW  },
        
        {   "",             0,                      0,                      NULL,   LOW  },

        0
    }
};

#endif // __PKTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\nbfext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    nbfext.c

Abstract:

    This file contains some standard functions
    for the NBF kernel debugger extensions dll.

Author:

    Chaitanya Kodeboyina (Chaitk)

Environment:

    User Mode

--*/

#include "precomp.h"

#pragma hdrstop

#include "nbfext.h"

//
// Globals
//


EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;
INT                    Item;

HANDLE                _hInstance;
HANDLE                _hAdditionalReference;
HANDLE                _hProcessHeap;

int                   _Indent = 0;
char                   IndentBuf[ 80 ]={"\0                                                                      "};

//
// Standard Functions
//

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason)
    {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            _hInstance = hModule;
            _hAdditionalReference = NULL;
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{

    return;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Exported functions
//

DECLARE_API( help )

/*++

Routine Description:

    Command help for NBF debugger extensions.

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("NBF debugger extension commands:\n\n");
    
    dprintf("\t devs       <dbg>    - Dump global list of NBF devices\n");
    dprintf("\t dev  <ptr> <dbg>    - Dump an NBF Device Extension\n");
    dprintf("\t adrs <ptr> <dbg>    - Dump an NBF Address List\n");
    dprintf("\t adr  <ptr> <dbg>    - Dump an NBF Address\n");
    dprintf("\t adfs <ptr> <dbg>    - Dump an NBF Address File List\n");
    dprintf("\t adf  <ptr> <dbg>    - Dump an NBF Address File\n");
    dprintf("\t cons <ptr> <lin> <dbg> - Dump an NBF Connection List\n");
    dprintf("\t con  <ptr> <dbg>    - Dump an NBF Connection\n");
    dprintf("\t lnks <ptr> <dbg>    - Dump an NBF DLC Link List\n");
    dprintf("\t lnk  <ptr> <dbg>    - Dump an NBF Link\n");
    dprintf("\t req  <ptr> <dbg>    - Dump an NBF Request\n");
    dprintf("\t pkt  <ptr> <dbg>    - Dump an NBF Packet Object\n");
    dprintf("\t nhdr <ptr> <dbg>    - Dump an NBF Packet Header\n");
/*
    dprintf("\t spt  <ptr> <dbg>    - Dump an NBF Send Packet Tag\n");
    dprintf("\t rpt  <ptr> <dbg>    - Dump an NBF Recv Packet Tag\n");
*/
    dprintf("\t dlst <ptr>          - Dump a d-list from a list entry\n");
    dprintf("\t field <struct-code> <struct-addr> <field-prefix> <dbg> \n"
            "\t                     - Dump a field in an NBF structure\n");
    dprintf("\n");
    dprintf("\t <dbg> - 0 (Validate), 1 (Summary), 2 (Normal Shallow),\n");
    dprintf("\t         3(Full Shallow), 4(Normal Deep), 5(Full Deep) \n");
    dprintf("\n");
    dprintf( "Compiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}


DECLARE_API( field )

/**

Routine Description:

    Command that print a specified field
    in a structure at a particular locn.

Arguments:

    args - 
        Memory location of the structure
        Name of the structure
        Name of the field

Return Value:

    None

--*/

{
    CHAR    structName[MAX_SYMBOL_LEN];
    CHAR    fieldName[MAX_SYMBOL_LEN];
    ULONG   structAddr;
    ULONG   printDetail;

    // Initialize arguments to some defaults
    structName[0]   = 0;
    structAddr      = 0;
    fieldName[0]    = 0; 
    printDetail     = NORM_SHAL;

    // Get the arguments and direct control
    if (*args)
    {
        sscanf(args, "%s %x %s %lu", structName, &structAddr, fieldName, &printDetail);
    }

    if (!_stricmp(structName, "dev"))
    {
        FieldInDeviceContext(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "adr"))
    {
        FieldInAddress(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "adf"))
    {
        FieldInAddressFile(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "con"))
    {
        FieldInConnection(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "lnk"))
    {
        FieldInDlcLink(structAddr, fieldName, printDetail);
    }  
    else
    if (!_stricmp(structName, "req"))
    {
        FieldInRequest(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "pkt"))
    {
        FieldInPacket(structAddr, fieldName, printDetail);
    }
    else
    if (!_stricmp(structName, "nhdr"))
    {
        FieldInNbfPktHdr(structAddr, fieldName, printDetail);
    }
/*
    if (!_stricmp(structName, "spt"))
    {
        FieldInSendPacketTag(structAddr, fieldName, printDetail);
    }
    if (!_stricmp(structName, "rpt"))
    {
        FieldInRecvPacketTag(structAddr, fieldName, printDetail);
    }
*/  
    else
    {
        dprintf("Unable to understand structure\n");
    }
}

DECLARE_API( dlst )

/**

Routine Description:

    Print a doubly linked list given list entry

Arguments:

    args - 
        Memory location of the list entry
        Offset of the list entry in struct

Return Value:

    None

--*/

{
    ULONG   listHead = 0;
    ULONG   leOffset = 0;
    
    // Get the arguments and direct control
    if (*args)
    {
        sscanf(args, "%x %x", &listHead, &leOffset);
    }

    PrintListFromListEntry(NULL, listHead, FULL_DEEP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\pktext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pktext.c

Abstract:

    This file contains the generic routines
    for debugging NBF packet structures.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "pktext.h"

//
// Exported Functions
//

DECLARE_API( pkts )

/*++

Routine Description:

   Print a list of packets given the
   head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;

    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    PrintPacketList(NULL, proxyPtr, printDetail);
}

DECLARE_API( pkt )

/*++

Routine Description:

   Print the NBF Packet at a location

Arguments:

    args - 
        Pointer to the NBF Packet
        Detail of debug information

Return Value:

    None

--*/

{
    TP_PACKET   Packet;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF Packet
    if (ReadPacket(&Packet, proxyPtr) != 0)
        return;

    // Print this Packet
    PrintPacket(&Packet, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintPacketList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_PACKET       Packet;
    LIST_ENTRY      PacketList;
    PLIST_ENTRY     PacketListPtr;
    PLIST_ENTRY     PacketListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numPkts;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF packets
        if (!ReadMemory(proxyPtr, &PacketList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Packet ListEntry", proxyPtr);
            return;
        }

        PacketListPtr = &PacketList;
    }
    else
    {
        PacketListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list 

    dprintf("Packets:\n");

    PacketListProxy = (PLIST_ENTRY)proxyPtr;
    
    numPkts = 0;
    
    p = PacketListPtr->Flink;
    while (p != PacketListProxy)
    {
        // Another Packet
        numPkts++;

        // Get Packet Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_PACKET, Linkage);

        // Get NBF Packet
        if (ReadPacket(&Packet, proxyPtr) != 0)
            break;
        
        // Print the Packet
        PrintPacket(&Packet, proxyPtr, printDetail);
        
        // Go to the next one
        p = Packet.Linkage.Flink;

        // Free the Packet
        FreePacket(&Packet);
    }

    if (p == PacketListProxy)
    {
        dprintf("Number of Packets: %lu\n", numPkts);
    }
}

//
// Local Helper Functions
//

UINT
ReadPacket(PTP_PACKET pPkt, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF packet
    if (!ReadMemory(proxyPtr, pPkt, sizeof(TP_PACKET), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Packet", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintPacket(PTP_PACKET pPkt, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF packet ?
    if (pPkt->Type != NBF_PACKET_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "Packet", proxyPtr);
        return -1;
    }

    // What detail do we print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInPacket(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID
FieldInPacket(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_PACKET  Packet;

    if (ReadPacket(&Packet, structAddr) == 0)
    {
        PrintFields(&Packet, structAddr, fieldName, printDetail, &PacketInfo);
    }
}

UINT
FreePacket(PTP_PACKET pPkt)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\reqext.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    reqext.h

Abstract:

    This file contains all declarations
    used in handling NBF requests.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#ifndef __REQEXT_H
#define __REQEXT_H

//
// Macros
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif//FIELD_OFFSET

#define OFFSET(field)          FIELD_OFFSET(TP_REQUEST, field)

//
// Helper Prototypes
//
UINT ReadRequest(PTP_REQUEST pReq, ULONG proxyPtr);

UINT PrintRequest(PTP_REQUEST pReq, ULONG proxyPtr, ULONG printDetail);

UINT FreeRequest(PTP_REQUEST pReq);

VOID PrintRequestList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail);

//
// Constants
//

StructAccessInfo  RequestInfo =
{
    "Request",

    {
        {   "IoRequestPacket",
                            OFFSET(IoRequestPacket),          
                                                    sizeof(PIRP),           NULL,   LOW  },
    
        {   "Owner",        OFFSET(Owner),          sizeof(REQUEST_OWNER),  NULL,   LOW  },

        {   "Context",      OFFSET(Context),        sizeof(PVOID),          NULL,   LOW  },

        {   "Type",         OFFSET(Type),           sizeof(CSHORT),         NULL,   LOW  },
        
        {   "Size",         OFFSET(Size),           sizeof(USHORT),         NULL,   LOW  },


        {   "Linkage",      OFFSET(Linkage),        sizeof(LIST_ENTRY),     NULL,   LOW  },
        
        {   "ReferenceCount",
                            OFFSET(ReferenceCount), sizeof(ULONG),          NULL,   LOW  },
        
#if DBG
        {   "RefTypes",     OFFSET(RefTypes), 
                                    NUMBER_OF_RREFS*sizeof(ULONG),          NULL,   LOW  },
#endif
        
        {   "SpinLock",     OFFSET(SpinLock),       sizeof(KSPIN_LOCK),     NULL,   LOW  },

        {   "Flags",        OFFSET(Flags),          sizeof(ULONG),          NULL,   LOW  },

        {   "DeviceContext",     
                            OFFSET(Provider),       sizeof(PDEVICE_CONTEXT),NULL,   LOW  },

        {   "",             0,                      0,                      NULL,   LOW  },

        0
    }
};

#endif // __REQEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\reqext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    reqext.c

Abstract:

    This file contains the generic routines
    for debugging NBF request structures.

Author:

    Chaitanya Kodeboyina

Environment:

    User Mode

--*/
#include "precomp.h"
#pragma hdrstop

#include "reqext.h"

//
// Exported Functions
//

DECLARE_API( reqs )

/*++

Routine Description:

   Print a list of requests given the
   head LIST_ENTRY.

Arguments:

    args - Address of the list entry, &
           Detail of debug information
    
Return Value:

    None

--*/

{
    ULONG           proxyPtr;
    ULONG           printDetail;

    // Get list-head address & debug print level
    printDetail = SUMM_INFO;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    PrintRequestList(NULL, proxyPtr, printDetail);
}

DECLARE_API( req )

/*++

Routine Description:

   Print the NBF Request at a location

Arguments:

    args - 
        Pointer to the NBF Request
        Detail of debug information

Return Value:

    None

--*/

{
    TP_REQUEST  Request;
    ULONG       printDetail;
    ULONG       proxyPtr;

    // Get the detail of debug information needed
    printDetail = NORM_SHAL;
    if (*args)
    {
        sscanf(args, "%x %lu", &proxyPtr, &printDetail);
    }

    // Get the NBF Request
    if (ReadRequest(&Request, proxyPtr) != 0)
        return;

    // Print this Request
    PrintRequest(&Request, proxyPtr, printDetail);
}

//
// Global Helper Functions
//
VOID
PrintRequestList(PVOID ListEntryPointer, ULONG ListEntryProxy, ULONG printDetail)
{
    TP_REQUEST      Request;
    LIST_ENTRY      RequestList;
    PLIST_ENTRY     RequestListPtr;
    PLIST_ENTRY     RequestListProxy;
    PLIST_ENTRY     p, q;
    ULONG           proxyPtr;
    ULONG           numReqs;
    ULONG           bytesRead;

    // Get list-head address & debug print level
    proxyPtr    = ListEntryProxy;

    if (ListEntryPointer == NULL)
    {
        // Read the list entry of NBF requests
        if (!ReadMemory(proxyPtr, &RequestList, sizeof(LIST_ENTRY), &bytesRead))
        {
            dprintf("%s @ %08x: Could not read structure\n", 
                            "Request ListEntry", proxyPtr);
            return;
        }

        RequestListPtr = &RequestList;
    }
    else
    {
        RequestListPtr = ListEntryPointer;
    }

    // Traverse the doubly linked list 

    dprintf("Requests:\n");

    RequestListProxy = (PLIST_ENTRY)proxyPtr;
    
    numReqs = 0;
    
    p = RequestListPtr->Flink;
    while (p != RequestListProxy)
    {
        // Another Request
        numReqs++;

        // Get Request Ptr
        proxyPtr = (ULONG) CONTAINING_RECORD (p, TP_REQUEST, Linkage);

        // Get NBF Request
        if (ReadRequest(&Request, proxyPtr) != 0)
            break;
        
        // Print the Request
        PrintRequest(&Request, proxyPtr, printDetail);
        
        // Go to the next one
        p = Request.Linkage.Flink;

        // Free the Request
        FreeRequest(&Request);
    }

    if (p == RequestListProxy)
    {
        dprintf("Number of Requests: %lu\n", numReqs);
    }
}

//
// Local Helper Functions
//

UINT
ReadRequest(PTP_REQUEST pReq, ULONG proxyPtr)
{
    ULONG           bytesRead;

    // Read the current NBF request
    if (!ReadMemory(proxyPtr, pReq, sizeof(TP_REQUEST), &bytesRead))
    {
        dprintf("%s @ %08x: Could not read structure\n", 
                        "Request", proxyPtr);
        return -1;
    }
    
    return 0;
}

UINT
PrintRequest(PTP_REQUEST pReq, ULONG proxyPtr, ULONG printDetail)
{
    // Is this a valid NBF request ?
    if (pReq->Type != NBF_REQUEST_SIGNATURE)
    {
        dprintf("%s @ %08x: Could not match signature\n", 
                        "Request", proxyPtr);
        return -1;
    }

    // What detail do we print at ?
    if (printDetail > MAX_DETAIL)
        printDetail = MAX_DETAIL;

    // Print Information at reqd detail
    FieldInRequest(proxyPtr, NULL, printDetail);
    
    return 0;
}

VOID
FieldInRequest(ULONG structAddr, CHAR *fieldName, ULONG printDetail)
{
    TP_REQUEST  Request;

    if (ReadRequest(&Request, structAddr) == 0)
    {
        PrintFields(&Request, structAddr, fieldName, printDetail, &RequestInfo);
    }
}

UINT
FreeRequest(PTP_REQUEST pReq)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\traverse.h ===
#if !defined( INCLUDED_TRAVERSE_H )
#define INCLUDED_TRAVERSE_H 

#define MAX_LIST_VARIABLE_NAME_LENGTH 200

typedef struct
{
    int StructureIndex;
    int MemberIndex;
    
    ULONG prHeadContainingObject;
    ULONG prHeadLinkage;
    ULONG prCurrentLinkage;
    int   cCurrentElement;
} MEMBER_VARIABLE_INFO, *PMEMBER_VARIABLE_INFO;

typedef VOID (*pfDumpStructure)( ULONG , VERBOSITY );
typedef BOOL (*pfNextStructure)( ULONG Current, PULONG Next );
typedef BOOL (*pfPrevStructure)( ULONG Current, PULONG Prev );

typedef struct
{
    PCHAR pchMemberName;

    LONG  cbOffsetToHead;

    pfDumpStructure DumpStructure;
    pfNextStructure Next;
    pfPrevStructure Prev;
    LONG  cbOffsetToLink;
    
} MEMBER_TABLE, *PMEMBER_TABLE;

typedef struct
{
    PCHAR pchStructName;
    PMEMBER_TABLE pMemberTable;

    pfDumpStructure DumpStructure;
} STRUCTURE_TABLE, *PSTRUCTURE_TABLE;

BOOL ReadArgsForTraverse( const char *args, char *VarName );
BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo );
BOOL LocateMemberVariable( PCHAR pchStructName, PCHAR pchMemberName, PVOID pvStructure, PMEMBER_VARIABLE_INFO pMemberInfo );


DECLARE_API( next );
DECLARE_API( prev );

extern BOOL NextListEntry( ULONG Current, PULONG Next );
extern BOOL PrevListEntry( ULONG Current, PULONG Prev );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\autodial.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    This module contains code that interacts with the
    automatic connection driver (rasacd.sys):

        o   NbfNoteNewConnection
        o   NbfAcdBind
        o   NbfAcdUnbind

Author:

    Anthony Discolo (adiscolo) 6 September 1995

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef RASAUTODIAL

#include <acd.h>
#include <acdapi.h>

//
// Global variables.
//
BOOLEAN fAcdLoadedG;
ACD_DRIVER AcdDriverG;
ULONG ulDriverIdG = 'Nbf ';



BOOLEAN
NbfCancelAutoDialRequest(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
    if (nArgs != 1)
        return FALSE;

    return (pArgs[0] == pArg);
} // NbfCancelAutoDialRequest



VOID
NbfRetryTdiConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    )

/*++

Routine Description:

    This routine is called indirectly by the automatic
    connection driver to continue the connection process
    after an automatic connection has been made.

Arguments:

    fSuccess - TRUE if the connection attempt was successful.

    pArgs - a pointer to the argument vector

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION pConnection = pArgs[0];
    KIRQL irql;
    BOOL fStopping;

    //
    // Check for a destroyed connection.
    //
    if (pConnection == NULL)
        return;
    status = NbfVerifyConnectionObject(pConnection);
    if (status != STATUS_SUCCESS) {
        DbgPrint(
          "NbfRetryTdiConnect: NbfVerifyConnectionObject failed (status=0x%x)\n",
          status);
        return;
    }
#ifdef notdef // DBG
    DbgPrint(
      "NbfRetryTdiConnect: fSuccess=%d, pConnection=0x%x, STOPPING=%d\n",
      fSuccess,
      pConnection,
      pConnection->Flags2 & CONNECTION_FLAGS2_STOPPING);
#endif
    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    //
    // Check to see if the connection
    // is closing.
    //
    ACQUIRE_DPC_SPIN_LOCK(&pConnection->SpinLock);
    fStopping = (pConnection->Flags2 & CONNECTION_FLAGS2_STOPPING);
    //
    // Clear the automatic connection
    // in-progress flag, and set the
    // autoconnected flag.
    //
    pConnection->Flags2 &= ~CONNECTION_FLAGS2_AUTOCONNECTING;
    pConnection->Flags2 |= CONNECTION_FLAGS2_AUTOCONNECTED;
    RELEASE_DPC_SPIN_LOCK(&pConnection->SpinLock);
    if (!fStopping) {
        if (fSuccess) {
            //
            // Restart the name query.
            //
            pConnection->Retries =
              (USHORT)pConnection->Provider->NameQueryRetries;
            NbfSendNameQuery (
                pConnection,
                TRUE);
            NbfStartConnectionTimer (
                pConnection,
                ConnectionEstablishmentTimeout,
                pConnection->Provider->NameQueryTimeout);
        }
        else {
            //
            // Terminate the connection with an error.
            //
            NbfStopConnection(pConnection, STATUS_BAD_NETWORK_PATH);
        }
    }
    KeLowerIrql(irql);
    NbfDereferenceConnection ("NbfRetryTdiConnect", pConnection, CREF_BY_ID);
} /* NbfRetryTdiConnect */



BOOLEAN
NbfCancelTdiConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

DESCRIPTION
    This routine is called by the I/O system to cancel a connection
    when we are attempting to restore an automatic connection.

ARGUMENTS
    pDeviceObject: a pointer to the device object for this driver

    pIrp: a pointer to the irp to be cancelled

RETURN VALUE
    TRUE if the request was canceled; FALSE otherwise.

--*/

{
    PIO_STACK_LOCATION pIrpSp;
    PTP_CONNECTION pConnection;
    ACD_ADDR addr;

    UNREFERENCED_PARAMETER(pDeviceObject);
    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnection = pIrpSp->FileObject->FsContext;
    if (pConnection == NULL)
        return FALSE;
#ifdef notdef // DBG
    DbgPrint(
      "NbfCancelTdiConnect: pIrp=0x%x, pConnection=0x%x\n",
      pIrp,
      pConnection);
#endif
    //
    // Get the address of the connection.
    //
    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->CalledAddress.NetbiosName, 15);
    //
    // Cancel the autodial request.
    //
    return (*AcdDriverG.lpfnCancelConnection)(
              ulDriverIdG,
              &addr,
              NbfCancelAutoDialRequest,
              pConnection);
} // NbfCancelTdiConnect



BOOLEAN
NbfAttemptAutoDial(
    IN PTP_CONNECTION         pConnection,
    IN ULONG                  ulFlags,
    IN ACD_CONNECT_CALLBACK   pProc,
    IN PVOID                  pArg
    )

/*++

Routine Description:

    Call the automatic connection driver to attempt an
    automatic connection.

Arguments:

    pConnection - a pointer to the TP_CONNECTION block for this connection

    ulFlags - connection flags to pass to the automatic
        connection driver

    pProc - a callback procedure when the automatic connection completes

    pArg - the single parameter to the callback procedure

Return Value:

    TRUE if the automatic connection was started successfully,
    FALSE otherwise.

--*/

{
    ACD_ADDR addr;
    PVOID pArgs[1];
    BOOLEAN bSuccess;

    //
    // If we've already attempted an automatic
    // connection on this connection, then
    // don't try again.
    //
    if (pConnection->Flags2 & CONNECTION_FLAGS2_AUTOCONNECTED)
        return FALSE;
    //
    // Get the address of the connection.
    //
    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->CalledAddress.NetbiosName, 15);
#ifdef notdef // DBG
    DbgPrint("NbfAttemptAutoDial: szAddr=%15.15s\n", addr.cNetbios);
#endif
    //
    // Attempt to start the connection.
    // NbfRetryTdiConnect() will be called
    // when the connection process has completed.
    //
    pArgs[0] = pArg;
    bSuccess = (*AcdDriverG.lpfnStartConnection)(
                   ulDriverIdG,
                   &addr,
                   ulFlags,
                   pProc,
                   1,
                   pArgs);
    if (bSuccess) {
        //
        // Set the CONNECTION_FLAGS2_AUTOCONNECTING flag on
        // the connection.  This will prevent it from being
        // aborted during the automatic connection process.
        //
        pConnection->Flags2 |= CONNECTION_FLAGS2_AUTOCONNECTING;
    }

    return bSuccess;
} // NbfAttemptAutoDial



VOID
NbfNoteNewConnection(
    PTP_CONNECTION pConnection,
    PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:
    Inform the automatic connection driver of a successful
    new connection.

Arguments:
    Connection - a pointer to a connection object

    DeviceContext - a pointer to the device context

Return Value:
    None.

--*/

{
    KIRQL irql;
    ACD_ADDR addr;
    ACD_ADAPTER adapter;
    ULONG ulcChars;

    addr.fType = ACD_ADDR_NB;
    RtlCopyMemory(&addr.cNetbios, pConnection->CalledAddress.NetbiosName, 15);
#ifdef notdef // DBG
    DbgPrint("NbfNoteNewConnection: szAddr=%15.15s\n", addr.cNetbios);
#endif
    //
    // Eliminate the "/Device/Nbf_" prefix when
    // copying the adapter name.
    //
    adapter.fType = ACD_ADAPTER_NAME;
    ulcChars = DeviceContext->DeviceNameLength / sizeof(WCHAR) - 1 - 12;
    if (ulcChars >= ACD_ADAPTER_NAME_LEN)
        ulcChars = ACD_ADAPTER_NAME_LEN - 1;
    RtlCopyMemory(
      adapter.szName,
      &DeviceContext->DeviceName[12],
      ulcChars * sizeof (WCHAR));
    adapter.szName[ulcChars] = L'\0';
    //
    // Simply notify the automatic connection driver
    // that a successful connection has been made.
    //
    (*AcdDriverG.lpfnNewConnection)(
        &addr,
        &adapter);
} // NbfNoteNewConnection



VOID
NbfAcdBind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Initialize our part of the ACD_DRIVER
    // structure.
    //
    KeInitializeSpinLock(&AcdDriverG.SpinLock);
    AcdDriverG.ulDriverId = ulDriverIdG;
    AcdDriverG.fEnabled = FALSE;
    //
    // Build a request to get the automatic
    // connection driver entry points.
    //
    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_BIND,
             pAcdDeviceObject,
             (PVOID)&pDriver,
             sizeof (pDriver),
             NULL,
             0,
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    fAcdLoadedG = (status == STATUS_SUCCESS);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbfAcdBind



VOID
NbfAcdUnbind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Don't bother to unbind if we
    // didn't successfully bind in the
    // first place.
    //
    if (!fAcdLoadedG)
        return;
    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Build a request to unbind from
    // the automatic connection driver.
    //
    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_UNBIND,
             pAcdDeviceObject,
             (PVOID)&pDriver,
             sizeof (pDriver),
             NULL,
             0,
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbfAcdUnbind

#endif // RASAUTODIAL


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\address.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which implements the TP_ADDRESS object.
    Routines are provided to create, destroy, reference, and dereference,
    transport address objects.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG
#define NbfDbgShowAddr(TNA)\
    { \
        if ((TNA) == NULL) { \
            NbfPrint0("<NetBios broadcast>\n"); \
        } else { \
            NbfPrint6("%c %c %c %c %d (%c)\n", \
                (TNA)->NetbiosName[0], \
                (TNA)->NetbiosName[1], \
                (TNA)->NetbiosName[4], \
                (TNA)->NetbiosName[6], \
                (TNA)->NetbiosName[15], \
                (TNA)->NetbiosNameType + 'A'); \
        } \
    }
#else
#define NbfDbgShowAddr(TNA)
#endif

//
// Map all generic accesses to the same one.
//

STATIC GENERIC_MAPPING AddressGenericMapping =
       { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };


VOID
AddressTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is executed as a DPC at DISPATCH_LEVEL when the timeout
    period for the ADD_NAME_QUERY/ADD_NAME_RECOGNIZED protocol expires.
    The retry count in the Address object is decremented, and if it reaches 0,
    the address is registered.  If the retry count has not reached zero,
    then the ADD NAME QUERY is retried.

Arguments:

    Dpc - Pointer to a system DPC object.

    DeferredContext - Pointer to the TP_ADDRESS block representing the
        address that is being registered.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    none.

--*/

{
    PTP_ADDRESS_FILE addressFile;
    PTP_ADDRESS address;
    PDEVICE_CONTEXT DeviceContext;
    PLIST_ENTRY p;
    LARGE_INTEGER timeout;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;


    address = (PTP_ADDRESS)DeferredContext;
    DeviceContext = address->Provider;

    //
    // We are waiting for an ADD_NAME_RECOGNIZED indicating that there is a
    // conflict.  Decrement the retry count, and if it dropped to zero,
    // then we've waited a sufficiently long time. If there was no conflict,
    // complete all waiting file opens for the address.
    //

    ACQUIRE_DPC_SPIN_LOCK (&address->SpinLock);

    if ((address->Flags & ADDRESS_FLAGS_QUICK_REREGISTER) != 0) {

        BOOLEAN DuplicateName;
        PTP_CONNECTION Connection;

        DuplicateName = ((address->Flags & (ADDRESS_FLAGS_DUPLICATE_NAME|ADDRESS_FLAGS_CONFLICT)) != 0);

        for (p=address->ConnectionDatabase.Flink;
             p != &address->ConnectionDatabase;
             p=p->Flink) {

            Connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

            if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {
                continue;
            }

            RELEASE_DPC_SPIN_LOCK (&address->SpinLock);

            if ((Connection->Flags2 & CONNECTION_FLAGS2_W_ADDRESS) != 0) {

                if (DuplicateName) {

                    NbfStopConnection (Connection, STATUS_DUPLICATE_NAME);

                } else {

                    //
                    // Continue with the connection attempt.
                    //
                    ULONG NameQueryTimeout;

                    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                    Connection->Flags2 &= ~CONNECTION_FLAGS2_W_ADDRESS;
                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                    KeQueryTickCount (&Connection->ConnectStartTime);

                    NameQueryTimeout = Connection->Provider->NameQueryTimeout;
                    if (Connection->Provider->MacInfo.MediumAsync &&
                        !Connection->Provider->MediumSpeedAccurate) {
                        NameQueryTimeout = NAME_QUERY_TIMEOUT / 10;
                    }

                    NbfSendNameQuery (
                        Connection,
                        TRUE);

                    NbfStartConnectionTimer (
                        Connection,
                        ConnectionEstablishmentTimeout,
                        NameQueryTimeout);
                }

            }

            ACQUIRE_DPC_SPIN_LOCK (&address->SpinLock);

        }

        address->Flags &= ~ADDRESS_FLAGS_QUICK_REREGISTER;

        RELEASE_DPC_SPIN_LOCK (&address->SpinLock);
        NbfDereferenceAddress ("Timer, registered", address, AREF_TIMER);

    } else if ((address->Flags & (ADDRESS_FLAGS_DUPLICATE_NAME|ADDRESS_FLAGS_CONFLICT)) != 0) {

        PIRP irp;

        //
        // the address registration has failed. We signal the user in
        // the normal way (by failing the open of the address). Now clean up
        // the transport's data structures.
        //

        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1 ("AddressTimeoutHandler %lx: duplicate\n", address);
        }

        address->Flags &= ~ADDRESS_FLAGS_REGISTERING;
//        address->Flags |= ADDRESS_FLAGS_STOPPING;

        //
        // This is probably all overkill, the
        // uframes handler will already have called
        // NbfStopAddress, which will tear off all
        // the address files etc., and set the
        // STOPPING flag which prevents further opens.
        //

        p = address->AddressFileDatabase.Flink;
        while (p != &address->AddressFileDatabase) {
            addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
            p = p->Flink;

            if (addressFile->Irp != NULL) {
                irp = addressFile->Irp;
                addressFile->Irp = NULL;
                RELEASE_DPC_SPIN_LOCK (&address->SpinLock);
                irp->IoStatus.Information = 0;
                irp->IoStatus.Status = STATUS_DUPLICATE_NAME;
                LEAVE_NBF;
                IoCompleteRequest (irp, IO_NETWORK_INCREMENT);
                ENTER_NBF;

                NbfStopAddressFile (addressFile, address);

                ACQUIRE_DPC_SPIN_LOCK (&address->SpinLock);
            }

        }

        RELEASE_DPC_SPIN_LOCK (&address->SpinLock);

        //
        // There will be no more timer events happening, so we dereference the
        // address to account for the timer.
        //

        NbfStopAddress (address);
        NbfDereferenceAddress ("Timer, dup address", address, AREF_TIMER);

    } else {

        //
        // has the address registration succeeded?
        //

        if (--(address->Retries) <= 0) {            // if retry count exhausted.
            PIRP irp;

            IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                NbfPrint1 ("AddressTimeoutHandler %lx: successful.\n", address);
            }

            address->Flags &= ~ADDRESS_FLAGS_REGISTERING;

            p = address->AddressFileDatabase.Flink;

            while (p != &address->AddressFileDatabase) {
                addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
                p = p->Flink;

                IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                    NbfPrint3 ("AddressTimeoutHandler %lx: Completing IRP %lx for file %lx\n",
                        address,
                        addressFile->Irp,
                        addressFile);
                }

                if (addressFile->Irp != NULL) {
                    irp = addressFile->Irp;
                    addressFile->Irp = NULL;
                    addressFile->State = ADDRESSFILE_STATE_OPEN;
                    RELEASE_DPC_SPIN_LOCK (&address->SpinLock);
                    irp->IoStatus.Information = 0;
                    irp->IoStatus.Status = STATUS_SUCCESS;

                    LEAVE_NBF;
                    IoCompleteRequest (irp, IO_NETWORK_INCREMENT);
                    ENTER_NBF;

                    ACQUIRE_DPC_SPIN_LOCK (&address->SpinLock);
                }

            }

            RELEASE_DPC_SPIN_LOCK (&address->SpinLock);

            //
            // Dereference the address if we're all done.
            //

            NbfDereferenceAddress ("Timer, registered", address, AREF_TIMER);

        } else {

            IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                NbfPrint2 ("AddressTimeoutHandler %lx: step %x.\n",
                     address,
                     DeviceContext->AddNameQueryRetries - address->Retries);
            }

            //
            // restart the timer if we haven't yet completed registration
            //

            RELEASE_DPC_SPIN_LOCK (&address->SpinLock);

            timeout.LowPart = (ULONG)(-(LONG)DeviceContext->AddNameQueryTimeout);
            timeout.HighPart = -1;
            KeSetTimer (&address->Timer,*(PTIME)&timeout, &address->Dpc);
            (VOID)NbfSendAddNameQuery (address);         // send another ADD_NAME_QUERY.
        }

    }

    LEAVE_NBF;
    return;

} /* AddressTimeoutHandler */


TDI_ADDRESS_NETBIOS *
NbfParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN BOOLEAN BroadcastAddressOk
)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_NETBIOS.

Arguments:

    Transport - The generic TDI address.

    BroadcastAddressOk - TRUE if we should return the broadcast
        address if found. If so, a value of (PVOID)-1 indicates
        the broadcast address.

Return Value:

    A pointer to the Netbios address, or NULL if none is found,
    or (PVOID)-1 if the broadcast address is found.

--*/

{
    TA_ADDRESS * addressName;
    INT i;

    addressName = &TransportAddress->Address[0];

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the Netbios one.
    //

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->AddressType == TDI_ADDRESS_TYPE_NETBIOS) {
            if ((addressName->AddressLength == 0) &&
                BroadcastAddressOk) {
                return (PVOID)-1;
            } else if (addressName->AddressLength == 
                        sizeof(TDI_ADDRESS_NETBIOS)) {
                return((TDI_ADDRESS_NETBIOS *)(addressName->Address));
            }
        }

        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }
    return NULL;

}   /* NbfParseTdiAddress */


BOOLEAN
NbfValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
)

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount)) {
        NbfPrint0 ("NbfValidateTdiAddress: runt address\n");
        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->Address > AddressEnd) {
            NbfPrint0 ("NbfValidateTdiAddress: address too short\n");
            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd) {
        NbfPrint0 ("NbfValidateTdiAddress: address too short\n");
        return FALSE;
    }
    return TRUE;

}   /* NbfValidateTdiAddress */


NTSTATUS
NbfOpenAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine opens a file that points to an existing address object, or, if
    the object doesn't exist, creates it (note that creation of the address
    object includes registering the address, and may take many seconds to
    complete, depending upon system configuration).

    If the address already exists, and it has an ACL associated with it, the
    ACL is checked for access rights before allowing creation of the address.

Arguments:

    DeviceObject - pointer to the device object describing the NBF transport.

    Irp - a pointer to the Irp used for the creation of the address.

    IrpSp - a pointer to the Irp stack location.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    NTSTATUS status;
    PTP_ADDRESS address;
    PTP_ADDRESS_FILE addressFile;
    PNBF_NETBIOS_ADDRESS networkName;    // Network name string.
    PFILE_FULL_EA_INFORMATION ea;
    TRANSPORT_ADDRESS UNALIGNED *name;
    TDI_ADDRESS_NETBIOS *netbiosName;
    ULONG DesiredShareAccess;
    KIRQL oldirql;
    PACCESS_STATE AccessState;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AccessAllowed;
    BOOLEAN QuickAdd = FALSE;

    DeviceContext = (PDEVICE_CONTEXT)DeviceObject;

    //
    // The network name is in the EA, passed in AssociatedIrp.SystemBuffer
    //

    ea = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
    if (ea == NULL) {
        NbfPrint1("OpenAddress: IRP %lx has no EA\n", Irp);
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // this may be a valid name; parse the name from the EA and use it if OK.
    //

    name = (TRANSPORT_ADDRESS UNALIGNED *)&ea->EaName[ea->EaNameLength+1];

    if (!NbfValidateTdiAddress(name, ea->EaValueLength)) {
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // The name can have with multiple entries; we'll use the Netbios one.
    // This call returns NULL if not Netbios address is found, (PVOID)-1
    // if it is the broadcast address, and a pointer to a Netbios
    // address otherwise.
    //

    netbiosName = NbfParseTdiAddress(name, TRUE);

    if (netbiosName != NULL) {
        if (netbiosName != (PVOID)-1) {
            networkName = (PNBF_NETBIOS_ADDRESS)ExAllocatePoolWithTag (
                                                NonPagedPool,
                                                sizeof (NBF_NETBIOS_ADDRESS),
                                                NBF_MEM_TAG_NETBIOS_NAME);
            if (networkName == NULL) {
                PANIC ("NbfOpenAddress: PANIC! could not allocate networkName!\n");
                NbfWriteResourceErrorLog(
                    DeviceContext,
                    EVENT_TRANSPORT_RESOURCE_POOL,
                    1,
                    sizeof(TA_NETBIOS_ADDRESS),
                    ADDRESS_RESOURCE_ID);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // get the name to local storage
            //

            if ((netbiosName->NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_GROUP) ||
                (netbiosName->NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP)) {
                networkName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            } else {
                networkName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            }
            RtlCopyMemory (networkName->NetbiosName, netbiosName->NetbiosName, 16);

            if ((netbiosName->NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE) ||
                (netbiosName->NetbiosNameType == TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP)) {
                    QuickAdd = TRUE;
            }
        } else {
            networkName = NULL;
        }

    } else {
        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1("OpenAddress: IRP %lx has no NETBIOS address\n", Irp);
        }
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
        NbfPrint1 ("OpenAddress %s: ",
            ((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
             (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                   "shared" : "exclusive");
        NbfDbgShowAddr (networkName);
    }

    //
    // get an address file structure to represent this address.
    //

    status = NbfCreateAddressFile (DeviceContext, &addressFile);

    if (!NT_SUCCESS (status)) {
        if (networkName != NULL) {
            ExFreePool (networkName);
        }
        return status;
    }

    //
    // See if this address is already established.  This call automatically
    // increments the reference count on the address so that it won't disappear
    // from underneath us after this call but before we have a chance to use it.
    //
    // To ensure that we don't create two address objects for the
    // same address, we hold the device context AddressResource until
    // we have found the address or created a new one.
    //

    ACQUIRE_RESOURCE_EXCLUSIVE (&DeviceContext->AddressResource, TRUE);

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    address = NbfLookupAddress (DeviceContext, networkName);

    if (address == NULL) {

        //
        // This address doesn't exist. Create it, and start the process of
        // registering it.
        //

        status = NbfCreateAddress (
                    DeviceContext,
                    networkName,
                    &address);

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        if (NT_SUCCESS (status)) {

            //
            // Initialize the shared access now. We use read access
            // to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            IoSetShareAccess(
                FILE_READ_DATA,
                DesiredShareAccess,
                IrpSp->FileObject,
                &address->u.ShareAccess);


            //
            // Assign the security descriptor (need to do this with
            // the spinlock released because the descriptor is not
            // mapped. Need to synchronize Assign and Access).
            //

            AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

            status = SeAssignSecurity(
                         NULL,                       // parent descriptor
                         AccessState->SecurityDescriptor,
                         &address->SecurityDescriptor,
                         FALSE,                      // is directory
                         &AccessState->SubjectSecurityContext,
                         &AddressGenericMapping,
                         PagedPool);

            IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                NbfPrint3 ("Assign security A %lx AF %lx, status %lx\n",
                               address,
                               addressFile,
                               status);
            }

            if (!NT_SUCCESS(status)) {

                //
                // Error, return status.
                //
                IoRemoveShareAccess (IrpSp->FileObject, &address->u.ShareAccess);

                // Mark as stopping so that someone does not ref it again
                ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);
                address->Flags |= ADDRESS_FLAGS_STOPPING;
                RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

                RELEASE_RESOURCE (&DeviceContext->AddressResource);
                NbfDereferenceAddress ("Device context stopping", address, AREF_TEMP_CREATE);
                NbfDereferenceAddressFile (addressFile);
                return status;

            }

            RELEASE_RESOURCE (&DeviceContext->AddressResource);

            //
            // if the adapter isn't ready, we can't do any of this; get out
            //

            if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {

                IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                    NbfPrint3("OpenAddress A %lx AF %lx: DeviceContext %lx not open\n",
                        address,
                        addressFile,
                        DeviceContext);
                }
                NbfDereferenceAddressFile (addressFile);
                status = STATUS_DEVICE_NOT_READY;

            } else {

                IrpSp->FileObject->FsContext = (PVOID)addressFile;
                IrpSp->FileObject->FsContext2 =
                                    (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
                addressFile->FileObject = IrpSp->FileObject;
                addressFile->Irp = Irp;
                addressFile->Address = address;

                NbfReferenceAddress("Opened new", address, AREF_OPEN);

                IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                    NbfPrint2("OpenAddress A %lx AF %lx: created.\n",
                        address,
                        addressFile);
                }

                ExInterlockedInsertTailList(
                    &address->AddressFileDatabase,
                    &addressFile->Linkage,
                    &address->SpinLock);


                //
                // Begin address registration unless this is the broadcast
                // address (which is a "fake" address with no corresponding
                // Netbios address) or the reserved address, which we know
                // is unique since it is based on the adapter address.
                //
                // Also, for "quick" add names, do not register.
                //

                if ((networkName != NULL) &&
                    (!RtlEqualMemory (networkName->NetbiosName,
                                      DeviceContext->ReservedNetBIOSAddress,
                                      NETBIOS_NAME_LENGTH)) &&
                    (!QuickAdd)) {

                    NbfRegisterAddress (address);    // begin address registration.
                    status = STATUS_PENDING;

                } else {

                    address->Flags &= ~ADDRESS_FLAGS_NEEDS_REG;
                    addressFile->Irp = NULL;
                    addressFile->State = ADDRESSFILE_STATE_OPEN;
                    status = STATUS_SUCCESS;

                }

            }

            NbfDereferenceAddress("temp create", address, AREF_TEMP_CREATE);

        } else {

            RELEASE_RESOURCE (&DeviceContext->AddressResource);

            //
            // If the address could not be created, and is not in the process of
            // being created, then we can't open up an address.
            //

            if (networkName != NULL) {
                ExFreePool (networkName);
            }

            NbfDereferenceAddressFile (addressFile);

        }

    } else {

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        //
        // The address already exists.  Check the ACL and see if we
        // can access it.  If so, simply use this address as our address.
        //

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

        AccessAllowed = SeAccessCheck(
                            address->SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,                  // lock tokens
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                            (ACCESS_MASK)0,         // previously granted
                            NULL,                   // privileges
                            &AddressGenericMapping,
                            Irp->RequestorMode,
                            &GrantedAccess,
                            &status);
                            
        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint4 ("Access check A %lx AF %lx, %s (%lx)\n",
                           address,
                           addressFile,
                           AccessAllowed ? "allowed" : "not allowed",
                           status);
        }

        if (AccessAllowed) {

            //
            // Access was successful, make sure Status is right.
            //

            status = STATUS_SUCCESS;

            // Transfer the access masks from what is desired to what is granted
            AccessState->PreviouslyGrantedAccess |= GrantedAccess;
            AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);

            //
            // Compare DesiredAccess to GrantedAccess?
            //


            //
            // Check that the name is of the correct type (unique vs. group)
            // We don't need to check this for the broadcast address.
            //
            // This code is structured funny, the only reason
            // this is inside this if is to avoid indenting too much.
            //

            if (networkName != NULL) {
                if (address->NetworkName->NetbiosNameType !=
                    networkName->NetbiosNameType) {

                    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                        NbfPrint2 ("Address types differ: old %c, new %c\n",
                            address->NetworkName->NetbiosNameType + 'A',
                            networkName->NetbiosNameType + 'A');
                    }

                    status = STATUS_DUPLICATE_NAME;

                }
            }

        }


        if (!NT_SUCCESS (status)) {

            RELEASE_RESOURCE (&DeviceContext->AddressResource);

            IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                NbfPrint2("OpenAddress A %lx AF %lx: ACL bad.\n",
                    address,
                    addressFile);
            }

            NbfDereferenceAddressFile (addressFile);

        } else {

            //
            // Now check that we can obtain the desired share
            // access. We use read access to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            status = IoCheckShareAccess(
                         FILE_READ_DATA,
                         DesiredShareAccess,
                         IrpSp->FileObject,
                         &address->u.ShareAccess,
                         TRUE);

            if (!NT_SUCCESS (status)) {

                RELEASE_RESOURCE (&DeviceContext->AddressResource);

                IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                    NbfPrint2("OpenAddress A %lx AF %lx: ShareAccess problem.\n",
                        address,
                        addressFile);
                }

                NbfDereferenceAddressFile (addressFile);

            } else {

                RELEASE_RESOURCE (&DeviceContext->AddressResource);

                ACQUIRE_SPIN_LOCK (&address->SpinLock, &oldirql);

                //
                // now, if the address registered, we simply return success after
                // pointing the file object at the address file (which points to
                // the address). If the address registration is pending, we mark
                // the registration pending and let the registration completion
                // routine complete the open. If the address is bad, we simply
                // fail the open.
                //

                if ((address->Flags &
                       (ADDRESS_FLAGS_CONFLICT |
                        ADDRESS_FLAGS_REGISTERING |
                        ADDRESS_FLAGS_DEREGISTERING |
                        ADDRESS_FLAGS_DUPLICATE_NAME |
                        ADDRESS_FLAGS_NEEDS_REG |
                        ADDRESS_FLAGS_STOPPING |
                        ADDRESS_FLAGS_BAD_ADDRESS |
                        ADDRESS_FLAGS_CLOSED)) == 0) {

                    InsertTailList (
                        &address->AddressFileDatabase,
                        &addressFile->Linkage);

                    addressFile->Irp = NULL;
                    addressFile->Address = address;
                    addressFile->FileObject = IrpSp->FileObject;
                    addressFile->State = ADDRESSFILE_STATE_OPEN;

                    NbfReferenceAddress("open ready", address, AREF_OPEN);

                    IrpSp->FileObject->FsContext = (PVOID)addressFile;
                    IrpSp->FileObject->FsContext2 =
                                            (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

                    RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

                    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                        NbfPrint2("OpenAddress A %lx AF %lx: address ready.\n",
                            address,
                            addressFile);
                    }

                    status = STATUS_SUCCESS;

                } else {

                    //
                    // if the address is still registering, make the open pending.
                    //

                    if ((address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_NEEDS_REG)) != 0) {

                        InsertTailList (
                            &address->AddressFileDatabase,
                            &addressFile->Linkage);

                        addressFile->Irp = Irp;
                        addressFile->Address = address;
                        addressFile->FileObject = IrpSp->FileObject;

                        NbfReferenceAddress("open registering", address, AREF_OPEN);

                        IrpSp->FileObject->FsContext = (PVOID)addressFile;
                        IrpSp->FileObject->FsContext2 =
                                    (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

                        RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

                        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                            NbfPrint2("OpenAddress A %lx AF %lx: address registering.\n",
                                address,
                                addressFile);
                        }

                        status = STATUS_PENDING;

                    } else {

                        if ((address->Flags & ADDRESS_FLAGS_CONFLICT) != 0) {
                            status = STATUS_DUPLICATE_NAME;
                        } else {
                            status = STATUS_DRIVER_INTERNAL_ERROR;
                        }

                        RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

                        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
                            NbfPrint3("OpenAddress A %lx AF %lx: address flags %lx.\n",
                                address,
                                addressFile,
                                address->Flags);
                        }

                        NbfDereferenceAddressFile (addressFile);

                    }
                }
            }
        }


        //
        // This isn't needed since it was not used in the
        // creation of the address.
        //

        if (networkName != NULL) {
            ExFreePool (networkName);
        }

        //
        // Remove the reference from NbfLookupAddress.
        //

        NbfDereferenceAddress ("Done opening", address, AREF_LOOKUP);
    }

    return status;
} /* NbfOpenAddress */


VOID
NbfAllocateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS *TransportAddress
    )

/*++

Routine Description:

    This routine allocates storage for a transport address. Some minimal
    initialization is done on the address.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    Address - Pointer to a place where this routine will return a pointer
        to a transport address structure. Returns NULL if no storage
        can be allocated.

Return Value:

    None.

--*/

{
    PTP_ADDRESS Address;
    PSEND_PACKET_TAG SendTag;
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET NdisPacket;
    PNDIS_BUFFER NdisBuffer;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + sizeof(TP_ADDRESS)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate address: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            101,
            sizeof(TP_ADDRESS),
            ADDRESS_RESOURCE_ID);
        *TransportAddress = NULL;
        return;
    }

    Address = (PTP_ADDRESS)ExAllocatePoolWithTag (
                               NonPagedPool,
                               sizeof (TP_ADDRESS),
                               NBF_MEM_TAG_TP_ADDRESS);
    if (Address == NULL) {
        PANIC("NBF: Could not allocate address: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            201,
            sizeof(TP_ADDRESS),
            ADDRESS_RESOURCE_ID);
        *TransportAddress = NULL;
        return;
    }
    RtlZeroMemory (Address, sizeof(TP_ADDRESS));

    // To track packet pools in NDIS allocated on NBF's behalf
#if NDIS_POOL_TAGGING
    Address->UIFramePoolHandle = (NDIS_HANDLE) NDIS_PACKET_POOL_TAG_FOR_NBF;
#endif

    NdisAllocatePacketPoolEx (
        &NdisStatus,
        &Address->UIFramePoolHandle,
        1,
        0,
        sizeof(SEND_PACKET_TAG));

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PANIC("NBF: Could not allocate address UI frame pool: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            311,
            sizeof(SEND_PACKET_TAG),
            ADDRESS_RESOURCE_ID);
        ExFreePool (Address);
        *TransportAddress = NULL;
        return;
    }
    
    NdisSetPacketPoolProtocolId (Address->UIFramePoolHandle, NDIS_PROTOCOL_ID_NBF);

    //
    // This code is similar to NbfAllocateUIFrame.
    //

    Address->UIFrame = (PTP_UI_FRAME) ExAllocatePoolWithTag (
                                          NonPagedPool,
                                          DeviceContext->UIFrameLength,
                                          NBF_MEM_TAG_TP_UI_FRAME);
    if (Address->UIFrame == NULL) {
        PANIC("NBF: Could not allocate address UI frame: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            411,
            DeviceContext->UIFrameLength,
            ADDRESS_RESOURCE_ID);
        NdisFreePacketPool (Address->UIFramePoolHandle);
        ExFreePool (Address);
        *TransportAddress = NULL;
        return;
    }
    RtlZeroMemory (Address->UIFrame, DeviceContext->UIFrameLength);


    NdisAllocatePacket (
        &NdisStatus,
        &NdisPacket,
        Address->UIFramePoolHandle);

    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

    Address->UIFrame->NdisPacket = NdisPacket;
    Address->UIFrame->DataBuffer = NULL;
    SendTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;
    SendTag->Type = TYPE_ADDRESS_FRAME;
    SendTag->Owner = (PVOID)Address;
    SendTag->Frame = Address->UIFrame;

    //
    // Make the packet header known to the packet descriptor
    //

     NdisAllocateBuffer(
        &NdisStatus,
        &NdisBuffer,
        DeviceContext->NdisBufferPool,
        Address->UIFrame->Header,
        DeviceContext->UIFrameHeaderLength);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {

        PANIC("NBF: Could not allocate address UI frame buffer: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_SPECIFIC,
            511,
            0,
            UI_FRAME_RESOURCE_ID);
        ExFreePool (Address->UIFrame);
		NdisFreePacket (Address->UIFrame->NdisPacket);
        NdisFreePacketPool (Address->UIFramePoolHandle);
        ExFreePool (Address);
        *TransportAddress = NULL;
        return;
    }

    NdisChainBufferAtFront (NdisPacket, NdisBuffer);

    DeviceContext->MemoryUsage +=
        sizeof(TP_ADDRESS) +
        sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG) +
        DeviceContext->UIFrameLength;
    ++DeviceContext->AddressAllocated;

    Address->Type = NBF_ADDRESS_SIGNATURE;
    Address->Size = sizeof (TP_ADDRESS);

    Address->Provider = DeviceContext;
    KeInitializeSpinLock (&Address->SpinLock);
//      KeInitializeSpinLock (&Address->Interlock);

    InitializeListHead (&Address->ConnectionDatabase);
    InitializeListHead (&Address->AddressFileDatabase);
    InitializeListHead (&Address->SendDatagramQueue);

    KeInitializeDpc (&Address->Dpc, AddressTimeoutHandler, (PVOID)Address);
    KeInitializeTimer (&Address->Timer);

    //
    // For each address, allocate a receive packet and a receive buffer.
    //

    NbfAddReceivePacket (DeviceContext);
    NbfAddReceiveBuffer (DeviceContext);

    *TransportAddress = Address;

}   /* NbfAllocateAddress */


VOID
NbfDeallocateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS TransportAddress
    )

/*++

Routine Description:

    This routine frees storage for a transport address.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    Address - Pointer to a transport address structure.

Return Value:

    None.

--*/

{
    PNDIS_BUFFER NdisBuffer;

    NdisUnchainBufferAtFront (TransportAddress->UIFrame->NdisPacket, &NdisBuffer);
    if (NdisBuffer != NULL) {
        NdisFreeBuffer (NdisBuffer);
    }
    NdisFreePacket(TransportAddress->UIFrame->NdisPacket);
    ExFreePool (TransportAddress->UIFrame);
    NdisFreePacketPool (TransportAddress->UIFramePoolHandle);

    ExFreePool (TransportAddress);
    --DeviceContext->AddressAllocated;

    DeviceContext->MemoryUsage -=
        sizeof(TP_ADDRESS) +
        sizeof(NDIS_PACKET) + sizeof(SEND_PACKET_TAG) +
        DeviceContext->UIFrameLength;

    //
    // Remove the resources which allocating this caused.
    //

    NbfRemoveReceivePacket (DeviceContext);
    NbfRemoveReceiveBuffer (DeviceContext);

}   /* NbfDeallocateAddress */


NTSTATUS
NbfCreateAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNBF_NETBIOS_ADDRESS NetworkName,
    OUT PTP_ADDRESS *Address
    )

/*++

Routine Description:

    This routine creates a transport address and associates it with
    the specified transport device context.  The reference count in the
    address is automatically set to 1, and the reference count of the
    device context is incremented.

    NOTE: This routine must be called with the DeviceContext
    spinlock held.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    NetworkName - Pointer to an NBF_NETBIOS_ADDRESS type containing the network
        name to be associated with this address, if any.
        NOTE: This has only the basic NetbiosNameType values, not the
              QUICK_ ones.

    Address - Pointer to a place where this routine will return a pointer
        to a transport address structure.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_ADDRESS pAddress;
    PLIST_ENTRY p;


    p = RemoveHeadList (&DeviceContext->AddressPool);
    if (p == &DeviceContext->AddressPool) {

        if ((DeviceContext->AddressMaxAllocated == 0) ||
            (DeviceContext->AddressAllocated < DeviceContext->AddressMaxAllocated)) {

            NbfAllocateAddress (DeviceContext, &pAddress);
            IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
                NbfPrint1 ("NBF: Allocated address at %lx\n", pAddress);
            }

        } else {

            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_SPECIFIC,
                401,
                sizeof(TP_ADDRESS),
                ADDRESS_RESOURCE_ID);
            pAddress = NULL;

        }

        if (pAddress == NULL) {
            ++DeviceContext->AddressExhausted;
            PANIC ("NbfCreateAddress: Could not allocate address object!\n");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        pAddress = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

    }

    ++DeviceContext->AddressInUse;
    if (DeviceContext->AddressInUse > DeviceContext->AddressMaxInUse) {
        ++DeviceContext->AddressMaxInUse;
    }

    DeviceContext->AddressTotal += DeviceContext->AddressInUse;
    ++DeviceContext->AddressSamples;


    IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_UFRAMES) {
        NbfPrint1 ("NbfCreateAddress %lx: ", pAddress);
        NbfDbgShowAddr (NetworkName);
    }

    //
    // Initialize all of the static data for this address.
    //

    pAddress->ReferenceCount = 1;

#if DBG
    {
        UINT Counter;
        for (Counter = 0; Counter < NUMBER_OF_AREFS; Counter++) {
            pAddress->RefTypes[Counter] = 0;
        }

        // This reference is removed by the caller.

        pAddress->RefTypes[AREF_TEMP_CREATE] = 1;
    }
#endif

    pAddress->Flags = ADDRESS_FLAGS_NEEDS_REG;
    InitializeListHead (&pAddress->AddressFileDatabase);

    pAddress->NetworkName = NetworkName;
    if ((NetworkName != (PNBF_NETBIOS_ADDRESS)NULL) &&
        (NetworkName->NetbiosNameType ==
           TDI_ADDRESS_NETBIOS_TYPE_GROUP)) {

        pAddress->Flags |= ADDRESS_FLAGS_GROUP;

    }

    if (NetworkName != (PNBF_NETBIOS_ADDRESS)NULL) {
        ++DeviceContext->AddressCounts[NetworkName->NetbiosName[0]];
    }

    //
    // Now link this address into the specified device context's
    // address database.  To do this, we need to acquire the spin lock
    // on the device context.
    //

    InsertTailList (&DeviceContext->AddressDatabase, &pAddress->Linkage);
    pAddress->Provider = DeviceContext;
    NbfReferenceDeviceContext ("Create Address", DeviceContext, DCREF_ADDRESS);   // count refs to the device context.

    *Address = pAddress;                // return the address.
    return STATUS_SUCCESS;              // not finished yet.
} /* NbfCreateAddress */


VOID
NbfRegisterAddress(
    PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine starts the registration process of the transport address
    specified, if it has not already been started.

Arguments:

    Address - Pointer to a transport address object to begin registering
        on the network.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    LARGE_INTEGER Timeout;

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);
    if (!(Address->Flags & ADDRESS_FLAGS_NEEDS_REG)) {
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1 ("NbfRegisterAddress %lx: NEEDS_REG 0.\n", Address);
        }

        return;
    }

    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
        NbfPrint1 ("NbfRegisterAddress %lx: registering.\n", Address);
    }


    Address->Flags &= ~ADDRESS_FLAGS_NEEDS_REG;
    Address->Flags |= ADDRESS_FLAGS_REGISTERING;

    RtlZeroMemory (Address->UniqueResponseAddress, 6);

    //
    // Keep a reference on this address until the registration process
    // completes or is aborted.  It will be aborted in UFRAMES.C, in
    // either the NAME_IN_CONFLICT or ADD_NAME_RESPONSE frame handlers.
    //

    NbfReferenceAddress ("start registration", Address, AREF_TIMER);
    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    //
    // Now start registration process by starting up a retransmission timer
    // and begin sending ADD_NAME_QUERY NetBIOS frames.
    //
    // On an async line that is disconnected, we only send one packet
    // with a short timeout.
    //

    if (Address->Provider->MacInfo.MediumAsync && !Address->Provider->MediumSpeedAccurate) {
        Address->Retries = 1;
        Timeout.LowPart = (ULONG)(-(ADD_NAME_QUERY_TIMEOUT / 10));
    } else {
        Address->Retries = Address->Provider->AddNameQueryRetries;
        Timeout.LowPart = (ULONG)(-(LONG)Address->Provider->AddNameQueryTimeout);
    }
    Timeout.HighPart = -1;
    KeSetTimer (&Address->Timer, *(PTIME)&Timeout, &Address->Dpc);

    (VOID)NbfSendAddNameQuery (Address); // send first ADD_NAME_QUERY.
} /* NbfRegisterAddress */


NTSTATUS
NbfVerifyAddressObject (
    IN PTP_ADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:

    AddressFile - potential pointer to a TP_ADDRESS_FILE object

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_ADDRESS otherwise

--*/

{
    KIRQL oldirql;
    NTSTATUS status = STATUS_SUCCESS;
    PTP_ADDRESS address;

    //
    // try to verify the address file signature. If the signature is valid,
    // verify the address pointed to by it and get the address spinlock.
    // check the address's state, and increment the reference count if it's
    // ok to use it. Note that the only time we return an error for state is
    // if the address is closing.
    //

    try {

        if ((AddressFile != (PTP_ADDRESS_FILE)NULL) &&
            (AddressFile->Size == sizeof (TP_ADDRESS_FILE)) &&
            (AddressFile->Type == NBF_ADDRESSFILE_SIGNATURE) ) {
//            (AddressFile->State != ADDRESSFILE_STATE_CLOSING) ) {

            address = AddressFile->Address;

            if ((address != (PTP_ADDRESS)NULL) &&
                (address->Size == sizeof (TP_ADDRESS)) &&
                (address->Type == NBF_ADDRESS_SIGNATURE)    ) {

                ACQUIRE_SPIN_LOCK (&address->SpinLock, &oldirql);

                if ((address->Flags & ADDRESS_FLAGS_STOPPING) == 0) {

                    NbfReferenceAddress ("verify", address, AREF_VERIFY);

                } else {

                    NbfPrint1("NbfVerifyAddress: A %lx closing\n", address);
                    status = STATUS_INVALID_ADDRESS;
                }

                RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

            } else {

                NbfPrint1("NbfVerifyAddress: A %lx bad signature\n", address);
                status = STATUS_INVALID_ADDRESS;
            }

        } else {

            NbfPrint1("NbfVerifyAddress: AF %lx bad signature\n", AddressFile);
            status = STATUS_INVALID_ADDRESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         NbfPrint1("NbfVerifyAddress: AF %lx exception\n", address);
         return GetExceptionCode();
    }

    return status;

}

VOID
NbfDestroyAddress(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine destroys a transport address and removes all references
    made by it to other objects in the transport.  The address structure
    is returned to nonpaged system pool or our lookaside list. It is assumed
    that the caller has already removed all addressfile structures associated
    with this address.

    The routine is called from a worker thread so that the security
    descriptor can be accessed.

    This worked thread is only queued by NbfDerefAddress.  The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    Address - Pointer to a transport address structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PDEVICE_CONTEXT DeviceContext;
    PTP_ADDRESS Address = (PTP_ADDRESS)Parameter;

    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
        NbfPrint1 ("NbfDestroyAddress %lx:.\n", Address);
    }

    DeviceContext = Address->Provider;

    SeDeassignSecurity (&Address->SecurityDescriptor);

    //
    // Delink this address from its associated device context's address
    // database.  To do this we must spin lock on the device context object,
    // not on the address.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    if (Address->NetworkName) {
        --DeviceContext->AddressCounts[Address->NetworkName->NetbiosName[0]];
    }

    RemoveEntryList (&Address->Linkage);

    if (Address->NetworkName != NULL) {
        ExFreePool (Address->NetworkName);
        Address->NetworkName = NULL;
    }

    //
    // Now we can deallocate the transport address object.
    //

    DeviceContext->AddressTotal += DeviceContext->AddressInUse;
    ++DeviceContext->AddressSamples;
    --DeviceContext->AddressInUse;

    if ((DeviceContext->AddressAllocated - DeviceContext->AddressInUse) >
            DeviceContext->AddressInitAllocated) {
        NbfDeallocateAddress (DeviceContext, Address);
        IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
            NbfPrint1 ("NBF: Deallocated address at %lx\n", Address);
        }
    } else {
        InsertTailList (&DeviceContext->AddressPool, &Address->Linkage);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
    NbfDereferenceDeviceContext ("Destroy Address", DeviceContext, DCREF_ADDRESS);  // just housekeeping.

} /* NbfDestroyAddress */


#if DBG
VOID
NbfRefAddress(
    IN PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    ASSERT (Address->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement (&Address->ReferenceCount);

} /* NbfRefAddress */
#endif


VOID
NbfDerefAddress(
    IN PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbfDestroyAddress to remove it from the system.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Address->ReferenceCount);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    ASSERT (result >= 0);

    if (result == 0) {

        ASSERT ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0);
        
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            NbfDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
    }
} /* NbfDerefAddress */



VOID
NbfAllocateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS_FILE *TransportAddressFile
    )

/*++

Routine Description:

    This routine allocates storage for an address file. Some
    minimal initialization is done on the object.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    TransportAddressFile - Pointer to a place where this routine will return
        a pointer to a transport address file structure. It returns NULL if no
        storage can be allocated.

Return Value:

    None.

--*/

{

    PTP_ADDRESS_FILE AddressFile;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + sizeof(TP_ADDRESS_FILE)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate address file: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            102,
            sizeof(TP_ADDRESS_FILE),
            ADDRESS_FILE_RESOURCE_ID);
        *TransportAddressFile = NULL;
        return;
    }

    AddressFile = (PTP_ADDRESS_FILE)ExAllocatePoolWithTag (
                                        NonPagedPool,
                                        sizeof (TP_ADDRESS_FILE),
                                        NBF_MEM_TAG_TP_ADDRESS_FILE);
    if (AddressFile == NULL) {
        PANIC("NBF: Could not allocate address file: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            202,
            sizeof(TP_ADDRESS_FILE),
            ADDRESS_FILE_RESOURCE_ID);
        *TransportAddressFile = NULL;
        return;
    }
    RtlZeroMemory (AddressFile, sizeof(TP_ADDRESS_FILE));

    DeviceContext->MemoryUsage += sizeof(TP_ADDRESS_FILE);
    ++DeviceContext->AddressFileAllocated;

    AddressFile->Type = NBF_ADDRESSFILE_SIGNATURE;
    AddressFile->Size = sizeof (TP_ADDRESS_FILE);

    InitializeListHead (&AddressFile->ReceiveDatagramQueue);
    InitializeListHead (&AddressFile->ConnectionDatabase);

    *TransportAddressFile = AddressFile;

}   /* NbfAllocateAddressFile */


VOID
NbfDeallocateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS_FILE TransportAddressFile
    )

/*++

Routine Description:

    This routine frees storage for an address file.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    TransportAddressFile - Pointer to a transport address file structure.

Return Value:

    None.

--*/

{

    ExFreePool (TransportAddressFile);
    --DeviceContext->AddressFileAllocated;
    DeviceContext->MemoryUsage -= sizeof(TP_ADDRESS_FILE);

}   /* NbfDeallocateAddressFile */


NTSTATUS
NbfCreateAddressFile(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_ADDRESS_FILE * AddressFile
    )

/*++

Routine Description:

    This routine creates an address file from the pool of ther
    specified device context. The reference count in the
    address is automatically set to 1.

Arguments:

    DeviceContext - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    AddressFile - Pointer to a place where this routine will return a pointer
        to a transport address file structure.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PLIST_ENTRY p;
    PTP_ADDRESS_FILE addressFile;

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    p = RemoveHeadList (&DeviceContext->AddressFilePool);
    if (p == &DeviceContext->AddressFilePool) {

        if ((DeviceContext->AddressFileMaxAllocated == 0) ||
            (DeviceContext->AddressFileAllocated < DeviceContext->AddressFileMaxAllocated)) {

            NbfAllocateAddressFile (DeviceContext, &addressFile);
            IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
                NbfPrint1 ("NBF: Allocated address file at %lx\n", addressFile);
            }

        } else {

            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_SPECIFIC,
                402,
                sizeof(TP_ADDRESS_FILE),
                ADDRESS_FILE_RESOURCE_ID);
            addressFile = NULL;

        }

        if (addressFile == NULL) {
            ++DeviceContext->AddressFileExhausted;
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
            PANIC ("NbfCreateAddressFile: Could not allocate address file object!\n");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);

    }

    ++DeviceContext->AddressFileInUse;
    if (DeviceContext->AddressFileInUse > DeviceContext->AddressFileMaxInUse) {
        ++DeviceContext->AddressFileMaxInUse;
    }

    DeviceContext->AddressFileTotal += DeviceContext->AddressFileInUse;
    ++DeviceContext->AddressFileSamples;

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);


    InitializeListHead (&addressFile->ConnectionDatabase);
    addressFile->Address = NULL;
    addressFile->FileObject = NULL;
    addressFile->Provider = DeviceContext;
    addressFile->State = ADDRESSFILE_STATE_OPENING;
    addressFile->ConnectIndicationInProgress = FALSE;
    addressFile->ReferenceCount = 1;
    addressFile->CloseIrp = (PIRP)NULL;

    //
    // Initialize the request handlers.
    //

    addressFile->RegisteredConnectionHandler = FALSE;
    addressFile->ConnectionHandler = TdiDefaultConnectHandler;
    addressFile->ConnectionHandlerContext = NULL;
    addressFile->RegisteredDisconnectHandler = FALSE;
    addressFile->DisconnectHandler = TdiDefaultDisconnectHandler;
    addressFile->DisconnectHandlerContext = NULL;
    addressFile->RegisteredReceiveHandler = FALSE;
    addressFile->ReceiveHandler = TdiDefaultReceiveHandler;
    addressFile->ReceiveHandlerContext = NULL;
    addressFile->RegisteredReceiveDatagramHandler = FALSE;
    addressFile->ReceiveDatagramHandler = TdiDefaultRcvDatagramHandler;
    addressFile->ReceiveDatagramHandlerContext = NULL;
    addressFile->RegisteredExpeditedDataHandler = FALSE;
    addressFile->ExpeditedDataHandler = TdiDefaultRcvExpeditedHandler;
    addressFile->ExpeditedDataHandlerContext = NULL;
    addressFile->RegisteredErrorHandler = FALSE;
    addressFile->ErrorHandler = TdiDefaultErrorHandler;
    addressFile->ErrorHandlerContext = NULL;


    *AddressFile = addressFile;
    return STATUS_SUCCESS;

} /* NbfCreateAddress */


NTSTATUS
NbfDestroyAddressFile(
    IN PTP_ADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine destroys an address file and removes all references
    made by it to other objects in the transport.

    This routine is only called by NbfDereferenceAddressFile. The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address file object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    AddressFile Pointer to a transport address file structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql, oldirql1;
    PTP_ADDRESS address;
    PDEVICE_CONTEXT DeviceContext;
    PIRP CloseIrp;


    address = AddressFile->Address;
    DeviceContext = AddressFile->Provider;

    if (address) {

        //
        // This addressfile was associated with an address.
        //

        ACQUIRE_SPIN_LOCK (&address->SpinLock, &oldirql);

        //
        // remove this addressfile from the address list and disassociate it from
        // the file handle.
        //

        RemoveEntryList (&AddressFile->Linkage);
        InitializeListHead (&AddressFile->Linkage);

        if (address->AddressFileDatabase.Flink == &address->AddressFileDatabase) {

            //
            // This is the last open of this address, it will close
            // due to normal dereferencing but we have to set the
            // CLOSING flag too to stop further references.
            //

            ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql1);
            address->Flags |= ADDRESS_FLAGS_STOPPING;
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql1);

        }

        AddressFile->Address = NULL;

        AddressFile->FileObject->FsContext = NULL;
        AddressFile->FileObject->FsContext2 = NULL;

        RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

        //
        // We will already have been removed from the ShareAccess
        // of the owning address.
        //

        //
        // Now dereference the owning address.
        //

        NbfDereferenceAddress ("Close", address, AREF_OPEN);    // remove the creation hold

    }

    //
    // Save this for later completion.
    //

    CloseIrp = AddressFile->CloseIrp;

    //
    // return the addressFile to the pool of address files
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    DeviceContext->AddressFileTotal += DeviceContext->AddressFileInUse;
    ++DeviceContext->AddressFileSamples;
    --DeviceContext->AddressFileInUse;

    if ((DeviceContext->AddressFileAllocated - DeviceContext->AddressFileInUse) >
            DeviceContext->AddressFileInitAllocated) {
        NbfDeallocateAddressFile (DeviceContext, AddressFile);
        IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
            NbfPrint1 ("NBF: Deallocated address file at %lx\n", AddressFile);
        }
    } else {
        InsertTailList (&DeviceContext->AddressFilePool, &AddressFile->Linkage);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);


    if (CloseIrp != (PIRP)NULL) {
        CloseIrp->IoStatus.Information = 0;
        CloseIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest (CloseIrp, IO_NETWORK_INCREMENT);
    }

    return STATUS_SUCCESS;

} /* NbfDestroyAddressFile */


VOID
NbfReferenceAddressFile(
    IN PTP_ADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    ASSERT (AddressFile->ReferenceCount > 0);   // not perfect, but...

    (VOID)InterlockedIncrement (&AddressFile->ReferenceCount);

} /* NbfReferenceAddressFile */


VOID
NbfDereferenceAddressFile(
    IN PTP_ADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbfDestroyAddressFile to remove it from the system.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&AddressFile->ReferenceCount);

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    ASSERT (result >= 0);

    if (result == 0) {
        NbfDestroyAddressFile (AddressFile);
    }
} /* NbfDerefAddressFile */


PTP_ADDRESS
NbfLookupAddress(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNBF_NETBIOS_ADDRESS NetworkName
    )

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NETWORK
    NAME values.  If an exact match is found, then a pointer to the
    TP_ADDRESS object is returned, and as a side effect, the reference
    count to the address object is incremented.  If the address is not
    found, then NULL is returned.

    NOTE: This routine must be called with the DeviceContext
    spinlock held.

Arguments:

    DeviceContext - Pointer to the device object and its extension.
    NetworkName - Pointer to an NBF_NETBIOS_ADDRESS structure containing the
                    network name.

Return Value:

    Pointer to the TP_ADDRESS object found, or NULL if not found.

--*/

{
    PTP_ADDRESS address;
    PLIST_ENTRY p;
    ULONG i;


    p = DeviceContext->AddressDatabase.Flink;

    for (p = DeviceContext->AddressDatabase.Flink;
         p != &DeviceContext->AddressDatabase;
         p = p->Flink) {

        address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);

        if ((address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        //
        // If the network name is specified and the network names don't match,
        // then the addresses don't match.
        //

        i = NETBIOS_NAME_LENGTH;        // length of a Netbios name

        if (address->NetworkName != NULL) {
            if (NetworkName != NULL) {
                if (!RtlEqualMemory (
                        address->NetworkName->NetbiosName,
                        NetworkName->NetbiosName,
                        i)) {
                    continue;
                }
            } else {
                continue;
            }

        } else {
            if (NetworkName != NULL) {
                continue;
            }
        }

        //
        // We found the match.  Bump the reference count on the address, and
        // return a pointer to the address object for the caller to use.
        //

        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint2 ("NbfLookupAddress DC %lx: found %lx ", DeviceContext, address);
            NbfDbgShowAddr (NetworkName);
        }

        NbfReferenceAddress ("lookup", address, AREF_LOOKUP);
        return address;

    } /* for */

    //
    // The specified address was not found.
    //

    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
        NbfPrint1 ("NbfLookupAddress DC %lx: did not find ", address);
        NbfDbgShowAddr (NetworkName);
    }

    return NULL;

} /* NbfLookupAddress */


PTP_CONNECTION
NbfLookupRemoteName(
    IN PTP_ADDRESS Address,
    IN PUCHAR RemoteName,
    IN UCHAR RemoteSessionNumber
    )

/*++

Routine Description:


    This routine scans the connections associated with the
    given address, and determines if there is an connection
    associated with the specific remote address and session
    number which is becoming active. This is used
    in determining whether name queries should be processed,
    or ignored as duplicates.

Arguments:

    Address - Pointer to the address object.

    RemoteName - The 16-character Netbios name of the remote.

    RemoteSessionNumber - The session number assigned to this
      connection by the remote.

Return Value:

    The connection if one is found, NULL otherwise.

--*/

{
    KIRQL oldirql, oldirql1;
    PLIST_ENTRY p;
    PTP_CONNECTION connection;
    BOOLEAN Found = FALSE;


    //
    // Hold the spinlock so the connection database doesn't
    // change.
    //

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    for (p=Address->ConnectionDatabase.Flink;
         p != &Address->ConnectionDatabase;
         p=p->Flink) {

        connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

        try {

            ACQUIRE_C_SPIN_LOCK (&connection->SpinLock, &oldirql1);

            if (((connection->Flags2 & CONNECTION_FLAGS2_REMOTE_VALID) != 0) &&
                ((connection->Flags & CONNECTION_FLAGS_READY) == 0)) {

                RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql1);

                //
                // If the remote names match, and the connection's RSN is
                // the same (or zero, which is a temporary condition where
                // we should err on the side of caution), then return the
                // connection, which will cause the NAME_QUERY to be ignored.
                //

                if ((RtlEqualMemory(RemoteName, connection->RemoteName, NETBIOS_NAME_LENGTH)) &&
                    ((connection->Rsn == RemoteSessionNumber) || (connection->Rsn == 0))) {

                    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
                    NbfReferenceConnection ("Lookup found", connection, CREF_LISTENING);
                    Found = TRUE;

                }

            } else {

                RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql1);

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            DbgPrint ("NBF: Got exception in NbfLookupRemoteName\n");
            DbgBreakPoint();

            RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql1);

            return (PTP_CONNECTION)NULL;
        }

        if (Found) {
            return connection;
        }

    }

    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    return (PTP_CONNECTION)NULL;

}


BOOLEAN
NbfMatchNetbiosAddress(
    IN PTP_ADDRESS Address,
    IN UCHAR NameType,
    IN PUCHAR NetBIOSName
    )

/*++

Routine Description:

    This routine is called to compare the addressing information in a
    TP_ADDRESS object with the 16-byte NetBIOS name in a frame header.
    If they match, then this routine returns TRUE, else it returns FALSE.

Arguments:

    Address - Pointer to a TP_ADDRESS object.

    NameType - One of NETBIOS_NAME_TYPE_GROUP, NETBIOS_NAME_TYPE_UNIQUE,
        or NETBIOS_NAME_TYPE_EITHER. Controls what type we are matching
        on, if it matters.

    NetBIOSName - Pointer to a 16-byte character string (non-terminated),
                  or NULL if this is a received broadcast address.

Return Value:

    BOOLEAN, TRUE if match, FALSE if not.

--*/

{

    PULONG AddressNamePointer;
    ULONG UNALIGNED * NetbiosNamePointer;

    //
    // If this is address is the Netbios broadcast address, the comparison
    // succeeds only if the passed in address is also NULL.
    //

    if (Address->NetworkName == NULL) {

        if (NetBIOSName == NULL) {
            return TRUE;
        } else {
            return FALSE;
        }

    } else if (NetBIOSName == NULL) {

        return FALSE;

    }

    //
    // Do a quick check of the first character in the names.
    //

    if (Address->NetworkName->NetbiosName[0] != NetBIOSName[0]) {
        return FALSE;
    }

    //
    // If name type is important and it doesn't match
    // this address' type, fail.
    //

    if (NameType != NETBIOS_NAME_TYPE_EITHER) {

        if (Address->NetworkName->NetbiosNameType != (USHORT)NameType) {

            return FALSE;
        }
    }

    IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
        NbfPrint2 ("MatchNetbiosAddress %lx: compare %.16s to ", Address, NetBIOSName);
        NbfDbgShowAddr (Address->NetworkName);
    }

    //
    // Now compare the 16-character Netbios names as ULONGs
    // for speed. We know the one stored in the address
    // structure is aligned.
    //

    AddressNamePointer = (PULONG)(Address->NetworkName->NetbiosName);
    NetbiosNamePointer = (ULONG UNALIGNED *)NetBIOSName;

    if ((AddressNamePointer[0] == NetbiosNamePointer[0]) &&
        (AddressNamePointer[1] == NetbiosNamePointer[1]) &&
        (AddressNamePointer[2] == NetbiosNamePointer[2]) &&
        (AddressNamePointer[3] == NetbiosNamePointer[3])) {
        return TRUE;
    } else {
        return FALSE;
    }

} /* NbfMatchNetbiosAddress */


VOID
NbfStopAddress(
    IN PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an address and
    destroy the object.  This is done in a graceful manner; i.e., all
    outstanding addressfiles are removed from the addressfile database, and
    all their activities are shut down.

Arguments:

    Address - Pointer to a TP_ADDRESS object.

Return Value:

    none.

--*/

{
    KIRQL oldirql, oldirql1;
    PTP_ADDRESS_FILE addressFile;
    PLIST_ENTRY p;
    PDEVICE_CONTEXT DeviceContext;

    DeviceContext = Address->Provider;

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    //
    // If we're already stopping this address, then don't try to do it again.
    //

    if (!(Address->Flags & ADDRESS_FLAGS_STOPPING)) {

        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1 ("NbfStopAddress %lx: stopping\n", Address);
        }

        NbfReferenceAddress ("Stopping", Address, AREF_TEMP_STOP);

        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql1);
        Address->Flags |= ADDRESS_FLAGS_STOPPING;
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql1);

        //
        // Run down all addressfiles on this address. This
        // will leave the address with no references
        // potentially, but we don't need a temp one
        // because every place that calls NbfStopAddress
        // already has a temp reference.
        //

        while (!IsListEmpty (&Address->AddressFileDatabase)) {
            p = RemoveHeadList (&Address->AddressFileDatabase);
            addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);

            addressFile->Address = NULL;
#if 0
            addressFile->FileObject->FsContext = NULL;
            addressFile->FileObject->FsContext2 = NULL;
#endif

            RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

            //
            // Run-down this addressFile without the lock on.
            // We don't care about removing ourselves from
            // the address' ShareAccess because we are
            // tearing it down.
            //

            NbfStopAddressFile (addressFile, Address);

            //
            // return the addressFile to the pool of address files
            //

            NbfDereferenceAddressFile (addressFile);

            NbfDereferenceAddress ("stop address", Address, AREF_OPEN);

            ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);
        }

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        NbfDereferenceAddress ("Stopping", Address, AREF_TEMP_STOP);

    } else {

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1 ("NbfStopAddress %lx: already stopping\n", Address);
        }

    }

} /* NbfStopAddress */


NTSTATUS
NbfStopAddressFile(
    IN PTP_ADDRESS_FILE AddressFile,
    IN PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an AddressFile and
    destroy the object.  We remove every connection and datagram associated
    with this addressfile from the address database and terminate their
    activity. Then, if there are no other outstanding addressfiles open on
    this address, the address will go away.

Arguments:

    AddressFile - pointer to the addressFile to be stopped

    Address - the owning address for this addressFile (we do not depend upon
        the pointer in the addressFile because we want this routine to be safe)

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the Irp does not
    point to a real address.

--*/

{
    KIRQL oldirql, oldirql1;
    LIST_ENTRY localIrpList;
    PLIST_ENTRY p, pFlink;
    PIRP irp;
    PTP_CONNECTION connection;
    ULONG fStopping;

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    if (AddressFile->State == ADDRESSFILE_STATE_CLOSING) {
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
        IF_NBFDBG (NBF_DEBUG_ADDRESS) {
            NbfPrint1 ("NbfStopAddressFile %lx: already closing.\n", AddressFile);
        }
        return STATUS_SUCCESS;
    }

    IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_PNP) {
        NbfPrint1 ("NbfStopAddressFile %lx: closing.\n", AddressFile);
    }


    AddressFile->State = ADDRESSFILE_STATE_CLOSING;
    InitializeListHead (&localIrpList);

    //
    // Run down all connections on this addressfile, and
    // preform the equivalent of NbfDestroyAssociation
    // on them.
    //

    while (!IsListEmpty (&AddressFile->ConnectionDatabase)) {
    
        p = RemoveHeadList (&AddressFile->ConnectionDatabase);
        connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressFileList);

        ACQUIRE_C_SPIN_LOCK (&connection->SpinLock, &oldirql1);

        if ((connection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) == 0) {

            //
            // It is in the process of being disassociated already.
            //

            RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql1);
            continue;
        }

        connection->Flags2 &= ~CONNECTION_FLAGS2_ASSOCIATED;
        connection->Flags2 |= CONNECTION_FLAGS2_DESTROY;    // Is this needed?
        RemoveEntryList (&connection->AddressList);
        InitializeListHead (&connection->AddressList);
        InitializeListHead (&connection->AddressFileList);
        connection->AddressFile = NULL;

        fStopping = connection->Flags2 & CONNECTION_FLAGS2_STOPPING;

#if _DBG_
        DbgPrint("conn = %p, Flags2 = %08x, fStopping = %08x\n", 
                        connection, 
                        connection->Flags2,
                        fStopping);
#endif

        if (!fStopping) {

#if _DBG_
            DbgPrint("Refing BEG\n");
#endif
            NbfReferenceConnection ("Close AddressFile", connection, CREF_STOP_ADDRESS);
#if _DBG_
            DbgPrint("Refing END\n");
#endif
        }

        RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql1);
            
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

#if DBG
        if (NbfDisconnectDebug) {
            STRING remoteName, localName;
            remoteName.Length = NETBIOS_NAME_LENGTH - 1;
            remoteName.Buffer = connection->RemoteName;
            localName.Length = NETBIOS_NAME_LENGTH - 1;
            localName.Buffer = AddressFile->Address->NetworkName->NetbiosName;
            NbfPrint2( "TpStopEndpoint stopping connection to %S from %S\n",
                &remoteName, &localName );
        }
#endif

        if (!fStopping) {
#if _DBG_
            DbgPrint("Stopping BEG\n");
#endif
            KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);
            NbfStopConnection (connection, STATUS_LOCAL_DISCONNECT);
            KeLowerIrql (oldirql1);
#if _DBG_
            DbgPrint("Stopping END\n");
            DbgPrint("Derefing BEG\n");
#endif
            NbfDereferenceConnection ("Close AddressFile", connection, CREF_STOP_ADDRESS);
#if _DBG_
            DbgPrint("Derefing END\n");
#endif
        }

        NbfDereferenceAddress ("Destroy association", Address, AREF_CONNECTION);

        ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);
    }

    //
    // now remove all of the datagrams owned by this addressfile
    //

    //
    // If the address has a datagram send in progress, skip the
    // first one, it will complete when the NdisSend completes.
    //

    p = Address->SendDatagramQueue.Flink;
    if (Address->Flags & ADDRESS_FLAGS_SEND_IN_PROGRESS) {
        ASSERT (p != &Address->SendDatagramQueue);
        p = p->Flink;
    }

    for ( ;
         p != &Address->SendDatagramQueue;
         p = pFlink ) {

        pFlink = p->Flink;
        irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        if (IoGetCurrentIrpStackLocation(irp)->FileObject->FsContext == AddressFile) {
            RemoveEntryList (p);
            InitializeListHead (p);
            InsertTailList (&localIrpList, p);
        }

    }

    for (p = AddressFile->ReceiveDatagramQueue.Flink;
         p != &AddressFile->ReceiveDatagramQueue;
         p = pFlink ) {

         pFlink = p->Flink;
         RemoveEntryList (p);
         InitializeListHead (p);
         InsertTailList (&localIrpList, p);
    }

    //
    // and finally, signal failure if the address file was waiting for a
    // registration to complete (Irp is set to NULL when this succeeds).
    //

    if (AddressFile->Irp != NULL) {
        PIRP irp=AddressFile->Irp;
#if DBG
        if ((Address->Flags & ADDRESS_FLAGS_DUPLICATE_NAME) == 0) {
            DbgPrint ("NBF: AddressFile %lx closed while opening!!\n", AddressFile);
            DbgBreakPoint();
        }
#endif
        AddressFile->Irp = NULL;
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_DUPLICATE_NAME;

        LEAVE_NBF;
        IoCompleteRequest (irp, IO_NETWORK_INCREMENT);
        ENTER_NBF;

    } else {

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
    }

    //
    // cancel all the datagrams on this address file
    //

    while (!IsListEmpty (&localIrpList)) {
        KIRQL cancelIrql;

        p = RemoveHeadList (&localIrpList);
        irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_NETWORK_NAME_DELETED;
        IoCompleteRequest (irp, IO_NETWORK_INCREMENT);

        NbfDereferenceAddress ("Datagram aborted", Address, AREF_REQUEST);
    }

    return STATUS_SUCCESS;
    
} /* NbfStopAddressFile */


NTSTATUS
NbfCloseAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to close the addressfile pointed to by a file
    object. If there is any activity to be run down, we will run it down
    before we terminate the addressfile. We remove every connection and
    datagram associated with this addressfile from the address database
    and terminate their activity. Then, if there are no other outstanding
    addressfiles open on this address, the address will go away.

Arguments:

    Irp - the Irp Address - Pointer to a TP_ADDRESS object.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the Irp does not
    point to a real address.

--*/

{
    PTP_ADDRESS address;
    PTP_ADDRESS_FILE addressFile;

    addressFile  = IrpSp->FileObject->FsContext;

    IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_PNP) {
        NbfPrint1 ("NbfCloseAddress AF %lx:\n", addressFile);
    }

    addressFile->CloseIrp = Irp;

    //
    // We assume that addressFile has already been verified
    // at this point.
    //

    address = addressFile->Address;
    ASSERT (address);

    //
    // Remove us from the access info for this address.
    //

    ACQUIRE_RESOURCE_EXCLUSIVE (&addressFile->Provider->AddressResource, TRUE);
    IoRemoveShareAccess (addressFile->FileObject, &address->u.ShareAccess);
    RELEASE_RESOURCE (&addressFile->Provider->AddressResource);


    NbfStopAddressFile (addressFile, address);
    NbfDereferenceAddressFile (addressFile);

    //
    // This removes a reference added by our caller.
    //

    NbfDereferenceAddress ("IRP_MJ_CLOSE", address, AREF_VERIFY);

    return STATUS_PENDING;

} /* NbfCloseAddress */


NTSTATUS
NbfSendDatagramsOnAddress(
    PTP_ADDRESS Address
    )

/*++

Routine Description:

    This routine attempts to acquire a hold on the SendDatagramQueue of
    the specified address, prepare the next datagram for shipment, and
    call NbfSendUIMdlFrame to actually do the work.  When NbfSendUIMdlFrame
    is finished, it will cause an I/O completion routine in UFRAMES.C to
    be called, at which time this routine is called again to handle the
    next datagram in the pipeline.

    NOTE: This routine must be called at a point where the address
    has another reference that will keep it around.

Arguments:

    Address - a pointer to the address object to send the datagram on.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PLIST_ENTRY p;
    PIRP Irp;
    TDI_ADDRESS_NETBIOS * remoteAddress;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CONTEXT DeviceContext;
    PUCHAR SingleSR;
    UINT SingleSRLength;
    UINT HeaderLength;
    PUCHAR LocalName;

    IF_NBFDBG (NBF_DEBUG_ADDRESS) {
        NbfPrint1 ("NbfSendDatagramsOnAddress %lx:\n", Address);
    }

    DeviceContext = Address->Provider;

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    if (!(Address->Flags & ADDRESS_FLAGS_SEND_IN_PROGRESS)) {

        //
        // If the queue is empty, don't do anything.
        //

        if (IsListEmpty (&Address->SendDatagramQueue)) {
            RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
            return STATUS_SUCCESS;
        }

        //
        // Mark the address's send datagram queue as held so that the
        // MDL and NBF header will not be used for two requests at the
        // same time.
        //

        Address->Flags |= ADDRESS_FLAGS_SEND_IN_PROGRESS;

        //
        // We own the hold, and we've released the spinlock.  So pick off the
        // next datagram to be sent, and ship it.
        //

        p = Address->SendDatagramQueue.Flink;
        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

        //
        // If there is no remote Address specified (the Address specified has
        // length 0), this is a broadcast datagram. If anything is specified, it
        // will be used as a netbios address.
        //

        irpSp = IoGetCurrentIrpStackLocation (Irp);

        remoteAddress = NbfParseTdiAddress (
                            ((PTDI_REQUEST_KERNEL_SENDDG)(&irpSp->Parameters))->
                                 SendDatagramInformation->RemoteAddress,
                            TRUE);
        ASSERT (remoteAddress != NULL);

        //
        // Build the MAC header. DATAGRAM frames go out as
        // single-route source routing.
        //

        MacReturnSingleRouteSR(
            &DeviceContext->MacInfo,
            &SingleSR,
            &SingleSRLength);

        MacConstructHeader (
            &DeviceContext->MacInfo,
            Address->UIFrame->Header,
            DeviceContext->NetBIOSAddress.Address,
            DeviceContext->LocalAddress.Address,
            sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS) +
                (ULONG)Irp->IoStatus.Information,
            SingleSR,
            SingleSRLength,
            &HeaderLength);


        //
        // Build the DLC UI frame header.
        //

        NbfBuildUIFrameHeader(&(Address->UIFrame->Header[HeaderLength]));
        HeaderLength += sizeof(DLC_FRAME);


        //
        // Build the correct Netbios header.
        //

        if (Address->NetworkName != NULL) {
            LocalName = Address->NetworkName->NetbiosName;
        } else {
            LocalName = DeviceContext->ReservedNetBIOSAddress;
        }

        if (remoteAddress == (PVOID)-1) {

            ConstructDatagramBroadcast (
                (PNBF_HDR_CONNECTIONLESS)&(Address->UIFrame->Header[HeaderLength]),
                LocalName);

        } else {

            ConstructDatagram (
                (PNBF_HDR_CONNECTIONLESS)&(Address->UIFrame->Header[HeaderLength]),
                (PNAME)remoteAddress->NetbiosName,
                LocalName);

        }

        HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


        //
        // Update our statistics for this datagram.
        //

        ++DeviceContext->Statistics.DatagramsSent;
        ADD_TO_LARGE_INTEGER(
            &DeviceContext->Statistics.DatagramBytesSent,
            Irp->IoStatus.Information);


        //
        // Munge the packet length, append the data, and send it.
        //

        NbfSetNdisPacketLength(Address->UIFrame->NdisPacket, HeaderLength);

        if (Irp->MdlAddress) {
            NdisChainBufferAtBack (Address->UIFrame->NdisPacket, (PNDIS_BUFFER)Irp->MdlAddress);
        }

        NbfSendUIMdlFrame (
            Address);


        //
        // The hold will be released in the I/O completion handler in
        // UFRAMES.C.  At that time, if there is another outstanding datagram
        // to send, it will reset the hold and call this routine again.
        //


    } else {

        RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
    }

    return STATUS_SUCCESS;
} /* NbfSendDatagramsOnAddress */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\kdext\traverse.c ===
#include "precomp.h"
#pragma hdrstop

MEMBER_VARIABLE_INFO _MemberInfo;


#define STATE_FILENAME "tcpipext.state"

STRUCTURE_TABLE StructureTable[] =
{
    { NULL }
};

BOOL NextListEntry( ULONG Current, PULONG Next );
BOOL PrevListEntry( ULONG Current, PULONG Prev );

VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo );
VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo );


BOOL
LocateMemberVariable
(
    PCHAR pchStructName,
    PCHAR pchMemberName,
    PVOID pvStructure,
    PMEMBER_VARIABLE_INFO pMemberInfo
)
{
    BOOL bMatch;
    int index;
    PMEMBER_TABLE pMemberTable;
    CHAR pchCurrent[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchStructName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];
    CHAR _pchMemberName[ MAX_LIST_VARIABLE_NAME_LENGTH + 1 ];

    dprintf( "LocateMemberVariable( \"%s\", \"%s\", 0x%08X )\n", pchStructName, pchMemberName, pMemberInfo );

    strcpy( _pchStructName, pchStructName );
    strcpy( _pchMemberName, pchMemberName );

    _strupr( _pchStructName );
    _strupr( _pchMemberName );

    pMemberInfo->StructureIndex = 0;
    pMemberInfo->MemberIndex = 0;

    bMatch = FALSE;

    for ( index = 0; StructureTable[ index ].pchStructName != NULL; index ++ )
    {
        strcpy( pchCurrent, StructureTable[ index ].pchStructName );
        _strupr( pchCurrent );

        if ( strstr( pchCurrent, _pchStructName ))
        {
            if ( bMatch )
            {
                dprintf( "The specified structure name is ambiguous.\n" );
                return( FALSE );
            }

            pMemberInfo->StructureIndex = index;

            bMatch = TRUE;
        }
    }

    if ( !bMatch )
    {
        dprintf( "No matching structure name was found.\n" );
        return( FALSE );
    }

    pMemberTable = StructureTable[ pMemberInfo->StructureIndex ].pMemberTable;

    bMatch = FALSE;

    for ( index = 0; pMemberTable[ index ].pchMemberName != NULL; index ++ )
    {
        strcpy( pchCurrent, pMemberTable[ index ].pchMemberName );
        _strupr( pchCurrent );

        if ( strstr( pchCurrent, _pchMemberName ))
        {
            if ( bMatch )
            {
                dprintf( "The variable specified is ambiguous.\n" );
                return( FALSE );
            }

            pMemberInfo->MemberIndex = index;

            bMatch = TRUE;
        }
    }

    if ( !bMatch )
    {
        dprintf( "No matching member name was found in the %s structure.\n", pchStructName );
        return( FALSE );
    }

    pMemberInfo->prHeadContainingObject = ( ULONG )pvStructure;
    pMemberInfo->prHeadLinkage = (( ULONG )pvStructure ) + pMemberTable[ pMemberInfo->MemberIndex ].cbOffsetToHead;
    pMemberInfo->prCurrentLinkage = pMemberInfo->prHeadLinkage;
    pMemberInfo->cCurrentElement = 0;

    return( TRUE );
}

BOOL WriteMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwWritten;

    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't create state file\n" );
        return( FALSE );
    }

    if ( !WriteFile( hStateFile,
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwWritten,
                     NULL ) || ( dwWritten != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't write to state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }

    CloseHandle( hStateFile );

    return( TRUE );
}

BOOL ReadMemberInfo( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    HANDLE hStateFile;
    DWORD dwRead;

    hStateFile = CreateFile( STATE_FILENAME,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if ( hStateFile == INVALID_HANDLE_VALUE )
    {
        dprintf( "Can't open state file\n" );
        return( FALSE );
    }

    if ( !ReadFile( hStateFile,
                     pMemberInfo,
                     sizeof( MEMBER_VARIABLE_INFO ),
                     &dwRead,
                     NULL ) || ( dwRead != sizeof( MEMBER_VARIABLE_INFO )))
    {
        dprintf( "Can't read from state file\n" );
        CloseHandle( hStateFile );
        return( FALSE );
    }

    CloseHandle( hStateFile );
    return( TRUE );
}


DECLARE_API( next )
{
    MEMBER_VARIABLE_INFO MemberInfo;

    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }

    NextElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}

DECLARE_API( prev )
{
    MEMBER_VARIABLE_INFO MemberInfo;

    if ( !ReadMemberInfo( &MemberInfo ) )
    {
        return;
    }

    PrevElement( &MemberInfo );
    DumpListItem( &MemberInfo );
    WriteMemberInfo( &MemberInfo );
}


VOID DumpListItem( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    PBYTE pbObject;
    PMEMBER_TABLE pMemberTable;

    dprintf( "Focus is on: %s.%s, element # %d\n",
             StructureTable[ pMemberInfo->StructureIndex ].pchStructName,
             StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ].pchMemberName,
             pMemberInfo->cCurrentElement );

    pMemberTable = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        //
        // Rather than dumping the head list item, dump all the items on the list,
        // in summary form.
        //

        do
        {
            NextElement( pMemberInfo );

            if ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage )
            {
                pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                           - pMemberTable->cbOffsetToLink;

                pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_ONE_LINER );
                dprintf( "\n" );
            }
        } while ( pMemberInfo->prCurrentLinkage != pMemberInfo->prHeadLinkage );
    }
    else
    {
        pbObject =   (( PBYTE )pMemberInfo->prCurrentLinkage )
                   - pMemberTable->cbOffsetToLink;

        pMemberTable->DumpStructure( ( ULONG )pbObject, VERBOSITY_NORMAL );
    }
}


VOID NextElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG NextLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Next( pMemberInfo->prCurrentLinkage, &NextLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = NextLinkage;
    pMemberInfo->cCurrentElement++;

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL NextListEntry( ULONG Current, PULONG Next )
{
    ULONG result;
    ULONG prNextEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY NextEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prNextEntry = ( ULONG )Entry.Flink;

    if ( !ReadMemory( prNextEntry,
                      &NextEntry,
                      sizeof( NextEntry ),
                      &result ))
    {
        dprintf( "Couldn't read next list entry at 0x%08X.\n", prNextEntry );
        return( FALSE );
    }

    if ( ( ULONG )NextEntry.Blink != Current )
    {
        dprintf( "Next entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Next = prNextEntry;
    return( TRUE );
}

VOID PrevElement( PMEMBER_VARIABLE_INFO pMemberInfo )
{
    ULONG PrevLinkage;
    PMEMBER_TABLE pMember;

    pMember = &StructureTable[ pMemberInfo->StructureIndex ].pMemberTable[ pMemberInfo->MemberIndex ];

    if ( !pMember->Prev( pMemberInfo->prCurrentLinkage, &PrevLinkage ))
    {
        dprintf( "Command failed.\n" );
        return;
    }

    pMemberInfo->prCurrentLinkage = PrevLinkage;
    pMemberInfo->cCurrentElement++;

    if ( pMemberInfo->prCurrentLinkage == pMemberInfo->prHeadLinkage )
    {
        pMemberInfo->cCurrentElement = 0;
    }
}

BOOL PrevListEntry( ULONG Current, PULONG Prev )
{
    ULONG result;
    ULONG prPrevEntry;
    LIST_ENTRY Entry;
    LIST_ENTRY PrevEntry;

    if ( !ReadMemory( Current,
                      &Entry,
                      sizeof( Entry ),
                      &result ))
    {
        dprintf( "Couldn't read current list entry at 0x%08X.\n", Current );
        return( FALSE );
    }

    prPrevEntry = ( ULONG )Entry.Blink;

    if ( !ReadMemory( prPrevEntry,
                      &PrevEntry,
                      sizeof( PrevEntry ),
                      &result ))
    {
        dprintf( "Couldn't read previous list entry at 0x%08X.\n", prPrevEntry );
        return( FALSE );
    }

    if ( ( ULONG )PrevEntry.Blink != Current )
    {
        dprintf( "Previous entry's Blink doesn't match current entry's address.\n" );
        dprintf( "The list might be corrupt, or you may be using traversal state saved before the list changed.\n" );
        return( FALSE );
    }

    *Prev = prPrevEntry;
    return( TRUE );
}

BOOL ReadArgsForTraverse( const char *args, char *VarName )
{
    PCHAR pchListVar;
    int index;
    BOOL bRetval = FALSE;

    pchListVar = strstr( args, "-l" );

    if ( pchListVar )
    {
        pchListVar += 2;

        while ( *pchListVar == ' ' )
        {
            pchListVar ++;
        }

        if ( *pchListVar == '\0' )
        {
            dprintf( "NOT IMPLEMENTED: usage on -l\n" );
            return( bRetval );
        }

        for ( index = 0; index < MAX_LIST_VARIABLE_NAME_LENGTH; index ++ )
        {
            VarName[ index ] = *pchListVar;

            if ( *pchListVar == ' ' || *pchListVar == '\0' )
            {
                VarName[ index ] = '\0';
                break;
            }

            VarName[ index + 1 ] = '\0';

            pchListVar ++;
        }

        bRetval = TRUE;
    }

    return( bRetval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\connect.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiAccept
        o   TdiListen
        o   TdiConnect
        o   TdiDisconnect
        o   TdiAssociateAddress
        o   TdiDisassociateAddress
        o   OpenConnection
        o   CloseConnection

Author:

    David Beaver (dbeaver) 1 July 1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef notdef // RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL

#ifdef notdef // RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

//
// Imported functions.
//
VOID
NbfRetryPreTdiConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

BOOLEAN
NbfAttemptAutoDial(
    IN PTP_CONNECTION         Connection,
    IN ULONG                  ulFlags,
    IN ACD_CONNECT_CALLBACK   pProc,
    IN PVOID                  pArg
    );

VOID
NbfCancelPreTdiConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );
#endif // RASAUTODIAL

NTSTATUS
NbfTdiConnectCommon(
    IN PIRP Irp
    );



NTSTATUS
NbfTdiAccept(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiAccept request for the transport provider.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_CONNECTION connection;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldirql;
    NTSTATUS status;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("NbfTdiAccept: Entered.\n");
    }

    //
    // Get the connection this is associated with; if there is none, get out.
    // This adds a connection reference of type BY_ID if successful.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection = irpSp->FileObject->FsContext;

    //
    // This adds a connection reference of type BY_ID if successful.
    //

    status = NbfVerifyConnectionObject (connection);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    //
    // just set the connection flags to allow reads and writes to proceed.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    //
    // Turn off the stopping flag for this connection.
    //

    connection->Flags2 &= ~CONNECTION_FLAGS2_STOPPING;
    connection->Status = STATUS_PENDING;

    connection->Flags2 |= CONNECTION_FLAGS2_ACCEPTED;


    if (connection->AddressFile->ConnectIndicationInProgress) {
        connection->Flags2 |= CONNECTION_FLAGS2_INDICATING;
    }

    if ((connection->Flags2 & CONNECTION_FLAGS2_WAITING_SC) != 0) {

        //
        // We previously completed a listen, now the user is
        // coming back with an accept, Set this flag to allow
        // the connection to proceed.
        //
        // If the connection has gone down in the
        // meantime, we have just reenabled it.
        //

        ACQUIRE_DPC_SPIN_LOCK (connection->LinkSpinLock);
        connection->Flags |= CONNECTION_FLAGS_READY;
        RELEASE_DPC_SPIN_LOCK (connection->LinkSpinLock);

        INCREMENT_COUNTER (connection->Provider, OpenConnections);

        //
        // Set this flag to enable disconnect indications; once
        // the client has accepted he expects those.
        //

        connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        NbfSendSessionConfirm (connection);

    } else {

        //
        // This accept is being called at some point before
        // the link is up; directly from the connection handler
        // or at some point slightly later. We don't set
        // FLAGS2_REQ_COMPLETED now because the reference
        // count is not high enough; we set it when we get
        // the session initialize.
        //
        // If the connection goes down in the meantime,
        // we won't indicate the disconnect.
        //

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    }

    NbfDereferenceConnection ("Temp TdiAccept", connection, CREF_BY_ID);

    KeLowerIrql (oldirql);

    return STATUS_SUCCESS;

} /* NbfTdiAccept */


NTSTATUS
NbfTdiAssociateAddress(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the association of the connection and the address for
    the user.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PTP_ADDRESS_FILE addressFile;
    PTP_ADDRESS oldAddress;
    PTP_CONNECTION connection;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_ASSOCIATE parameters;
    PDEVICE_CONTEXT deviceContext;

    KIRQL oldirql, oldirql2;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("TdiAssociateAddress: Entered.\n");
    }

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // verify that the operation is taking place on a connection. At the same
    // time we do this, we reference the connection. This ensures it does not
    // get removed out from under us. Note also that we do the connection
    // lookup within a try/except clause, thus protecting ourselves against
    // really bogus handles
    //

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection  = irpSp->FileObject->FsContext;
    
    status = NbfVerifyConnectionObject (connection);
    if (!NT_SUCCESS (status)) {
        return status;
    }


    //
    // Make sure this connection is ready to be associated.
    //

    oldAddress = (PTP_ADDRESS)NULL;

    try {

        ACQUIRE_C_SPIN_LOCK (&connection->SpinLock, &oldirql2);

        if ((connection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) &&
            ((connection->Flags2 & CONNECTION_FLAGS2_DISASSOCIATED) == 0)) {

            //
            // The connection is already associated with
            // an active connection...bad!
            //

            RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql2);
            NbfDereferenceConnection ("Temp Ref Associate", connection, CREF_BY_ID);

            return STATUS_INVALID_CONNECTION;

        } else {

            //
            // See if there is an old association hanging around...
            // this happens if the connection has been disassociated,
            // but not closed.
            //

            if (connection->Flags2 & CONNECTION_FLAGS2_DISASSOCIATED) {

                IF_NBFDBG (NBF_DEBUG_CONNECT) {
                    NbfPrint0 ("NbfTdiAssociateAddress: removing association.\n");
                }

                //
                // Save this; since it is non-null this address
                // will be dereferenced after the connection
                // spinlock is released.
                //

                oldAddress = connection->AddressFile->Address;

                //
                // Remove the old association.
                //

                connection->Flags2 &= ~CONNECTION_FLAGS2_ASSOCIATED;
                RemoveEntryList (&connection->AddressList);
                RemoveEntryList (&connection->AddressFileList);
                InitializeListHead (&connection->AddressList);
                InitializeListHead (&connection->AddressFileList);
                connection->AddressFile = NULL;

            }

        }

        RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql2);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("NBF: Got exception 1 in NbfTdiAssociateAddress\n");
        DbgBreakPoint();

        RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql2);
        NbfDereferenceConnection ("Temp Ref Associate", connection, CREF_BY_ID);
        return GetExceptionCode();
    }


    //
    // If we removed an old association, dereference the
    // address.
    //

    if (oldAddress != (PTP_ADDRESS)NULL) {

        NbfDereferenceAddress("Removed old association", oldAddress, AREF_CONNECTION);

    }


    deviceContext = connection->Provider;

    parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)&irpSp->Parameters;

    //
    // get a pointer to the address File Object, which points us to the
    // transport's address object, which is where we want to put the
    // connection.
    //

    status = ObReferenceObjectByHandle (
                parameters->AddressHandle,
                0L,
                *IoFileObjectType,
                Irp->RequestorMode,
                (PVOID *) &fileObject,
                NULL);

    if (NT_SUCCESS(status)) {

        if (fileObject->DeviceObject == &deviceContext->DeviceObject) {

            //
            // we might have one of our address objects; verify that.
            //

            addressFile = fileObject->FsContext;

            IF_NBFDBG (NBF_DEBUG_CONNECT) {
                NbfPrint3 ("NbfTdiAssociateAddress: Connection %lx Irp %lx AddressFile %lx \n",
                    connection, Irp, addressFile);
            }
            
            if ((fileObject->FsContext2 == (PVOID) TDI_TRANSPORT_ADDRESS_FILE) &&
                (NT_SUCCESS (NbfVerifyAddressObject (addressFile)))) {

                //
                // have an address and connection object. Add the connection to the
                // address object database. Also add the connection to the address
                // file object db (used primarily for cleaning up). Reference the
                // address to account for one more reason for it staying open.
                //

                ACQUIRE_SPIN_LOCK (&addressFile->Address->SpinLock, &oldirql);
                if ((addressFile->Address->Flags & ADDRESS_FLAGS_STOPPING) == 0) {

                    IF_NBFDBG (NBF_DEBUG_CONNECT) {
                        NbfPrint2 ("NbfTdiAssociateAddress: Valid Address %lx %lx\n",
                            addressFile->Address, addressFile);
                    }

                    try {

                        ACQUIRE_C_SPIN_LOCK (&connection->SpinLock, &oldirql2);

                        if ((connection->Flags2 & CONNECTION_FLAGS2_CLOSING) == 0) {

                            NbfReferenceAddress (
                                "Connection associated",
                                addressFile->Address,
                                AREF_CONNECTION);

#if DBG
                            if (!(IsListEmpty(&connection->AddressList))) {
                                DbgPrint ("NBF: C %lx, new A %lx, in use\n",
                                    connection, addressFile->Address);
                                DbgBreakPoint();
                            }
#endif
                            InsertTailList (
                                &addressFile->Address->ConnectionDatabase,
                                &connection->AddressList);

#if DBG
                            if (!(IsListEmpty(&connection->AddressFileList))) {
                                DbgPrint ("NBF: C %lx, new AF %lx, in use\n",
                                    connection, addressFile);
                                DbgBreakPoint();
                            }
#endif
                            InsertTailList (
                                &addressFile->ConnectionDatabase,
                                &connection->AddressFileList);

                            connection->AddressFile = addressFile;
                            connection->Flags2 |= CONNECTION_FLAGS2_ASSOCIATED;
                            connection->Flags2 &= ~CONNECTION_FLAGS2_DISASSOCIATED;

                            if (addressFile->ConnectIndicationInProgress) {
                                connection->Flags2 |= CONNECTION_FLAGS2_INDICATING;
                            }

                            status = STATUS_SUCCESS;

                        } else {

                            //
                            // The connection is closing, stop the
                            // association.
                            //

                            status = STATUS_INVALID_CONNECTION;

                        }

                        RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql2);

                    } except(EXCEPTION_EXECUTE_HANDLER) {

                        DbgPrint ("NBF: Got exception 2 in NbfTdiAssociateAddress\n");
                        DbgBreakPoint();

                        RELEASE_C_SPIN_LOCK (&connection->SpinLock, oldirql2);

                        status = GetExceptionCode();
                    }

                } else {

                    status = STATUS_INVALID_HANDLE; //should this be more informative?
                }

                RELEASE_SPIN_LOCK (&addressFile->Address->SpinLock, oldirql);

                NbfDereferenceAddress ("Temp associate", addressFile->Address, AREF_VERIFY);

            } else {

                status = STATUS_INVALID_HANDLE;
            }
        } else {

            status = STATUS_INVALID_HANDLE;
        }

        //
        // Note that we don't keep a reference to this file object around.
        // That's because the IO subsystem manages the object for us; we simply
        // want to keep the association. We only use this association when the
        // IO subsystem has asked us to close one of the file object, and then
        // we simply remove the association.
        //

        ObDereferenceObject (fileObject);
            
    } else {
        status = STATUS_INVALID_HANDLE;
    }

    NbfDereferenceConnection ("Temp Ref Associate", connection, CREF_BY_ID);

    return status;

} /* TdiAssociateAddress */


NTSTATUS
NbfTdiDisassociateAddress(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine performs the disassociation of the connection and the address
    for the user. If the connection has not been stopped, it will be stopped
    here.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{

    KIRQL oldirql;
    PIO_STACK_LOCATION irpSp;
    PTP_CONNECTION connection;
    NTSTATUS status;
//    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("TdiDisassociateAddress: Entered.\n");
    }

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection  = irpSp->FileObject->FsContext;

    //
    // If successful this adds a reference of type BY_ID.
    //

    status = NbfVerifyConnectionObject (connection);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    if ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        NbfStopConnection (connection, STATUS_LOCAL_DISCONNECT);
    } else {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    }

    //
    // and now we disassociate the address. This only removes
    // the appropriate reference for the connection, the
    // actually disassociation will be done later.
    //
    // The DISASSOCIATED flag is used to make sure that
    // only one person removes this reference.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    if ((connection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) &&
            ((connection->Flags2 & CONNECTION_FLAGS2_DISASSOCIATED) == 0)) {
        connection->Flags2 |= CONNECTION_FLAGS2_DISASSOCIATED;
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    } else {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    }

    KeLowerIrql (oldirql);

    NbfDereferenceConnection ("Temp use in Associate", connection, CREF_BY_ID);

    return STATUS_SUCCESS;

} /* TdiDisassociateAddress */



NTSTATUS
NbfTdiConnect(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiConnect request for the transport provider.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION connection;
    KIRQL oldirql;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL parameters;
    TDI_ADDRESS_NETBIOS * RemoteAddress;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("NbfTdiConnect: Entered.\n");
    }

    //
    // is the file object a connection?
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection  = irpSp->FileObject->FsContext;

    //
    // If successful this adds a reference of type BY_ID.
    //

    status = NbfVerifyConnectionObject (connection);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    parameters = (PTDI_REQUEST_KERNEL)(&irpSp->Parameters);

    //
    // Check that the remote is a Netbios address.
    //

    if (!NbfValidateTdiAddress(
             parameters->RequestConnectionInformation->RemoteAddress,
             parameters->RequestConnectionInformation->RemoteAddressLength)) {

        NbfDereferenceConnection ("Invalid Address", connection, CREF_BY_ID);
        return STATUS_BAD_NETWORK_PATH;
    }

    RemoteAddress = NbfParseTdiAddress((PTRANSPORT_ADDRESS)(parameters->RequestConnectionInformation->RemoteAddress), FALSE);

    if (RemoteAddress == NULL) {

        NbfDereferenceConnection ("Not Netbios", connection, CREF_BY_ID);
        return STATUS_BAD_NETWORK_PATH;

    }

    //
    // copy the called address someplace we can use it.
    //

    connection->CalledAddress.NetbiosNameType =
        RemoteAddress->NetbiosNameType;

    RtlCopyMemory(
        connection->CalledAddress.NetbiosName,
        RemoteAddress->NetbiosName,
        16);

#ifdef notdef // RASAUTODIAL
    if (fAcdLoadedG) {
        KIRQL adirql;
        BOOLEAN fEnabled;

        //
        // See if the automatic connection driver knows
        // about this address before we search the
        // network.  If it does, we return STATUS_PENDING,
        // and we will come back here via NbfRetryTdiConnect().
        //
        ACQUIRE_SPIN_LOCK(&AcdDriverG.SpinLock, &adirql);
        fEnabled = AcdDriverG.fEnabled;
        RELEASE_SPIN_LOCK(&AcdDriverG.SpinLock, adirql);
        if (fEnabled && NbfAttemptAutoDial(
                          connection,
                          ACD_NOTIFICATION_PRECONNECT,
                          NbfRetryPreTdiConnect,
                          Irp))
        {
            ACQUIRE_SPIN_LOCK(&connection->SpinLock, &oldirql);
            connection->Flags2 |= CONNECTION_FLAGS2_AUTOCONNECT;
            connection->Status = STATUS_PENDING;
            RELEASE_SPIN_LOCK(&connection->SpinLock, oldirql);
            NbfDereferenceConnection ("Automatic connection", connection, CREF_BY_ID);
            //
            // Set a special cancel routine on the irp
            // in case we get cancelled during the
            // automatic connection.
            //
            IoSetCancelRoutine(Irp, NbfCancelPreTdiConnect);
            return STATUS_PENDING;
        }
    }
#endif // RASAUTODIAL

    return NbfTdiConnectCommon(Irp);
} // NbfTdiConnect



NTSTATUS
NbfTdiConnectCommon(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiConnect request for the transport provider.
    Note: the caller needs to call NbfVerifyConnectionObject(pConnection)
    before calling this routine.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION connection;
    LARGE_INTEGER timeout = {0,0};
    KIRQL oldirql, cancelirql;
    PTP_REQUEST tpRequest;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL parameters;
    TDI_ADDRESS_NETBIOS * RemoteAddress;
    ULONG NameQueryTimeout;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("NbfTdiConnectCommon: Entered.\n");
    }

    //
    // is the file object a connection?
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    connection  = irpSp->FileObject->FsContext;
    parameters = (PTDI_REQUEST_KERNEL)(&irpSp->Parameters);

    //
    // fix up the timeout if required; no connect request should take more
    // than 15 seconds if there is someone out there. We'll assume that's
    // what the user wanted if they specify -1 as the timer length.
    //

    if (parameters->RequestSpecific != NULL) {
        if ((((PLARGE_INTEGER)(parameters->RequestSpecific))->LowPart == -1) &&
             (((PLARGE_INTEGER)(parameters->RequestSpecific))->HighPart == -1)) {

            IF_NBFDBG (NBF_DEBUG_RESOURCE) {
                NbfPrint1 ("TdiConnect: Modifying user timeout to %lx seconds.\n",
                    TDI_TIMEOUT_CONNECT);
            }

            timeout.LowPart = (ULONG)(-TDI_TIMEOUT_CONNECT * 10000000L);    // n * 10 ** 7 => 100ns units
            if (timeout.LowPart != 0) {
                timeout.HighPart = -1L;
            } else {
                timeout.HighPart = 0;
            }

        } else {

            timeout.LowPart = ((PLARGE_INTEGER)(parameters->RequestSpecific))->LowPart;
            timeout.HighPart = ((PLARGE_INTEGER)(parameters->RequestSpecific))->HighPart;
        }
    }

    //
    // We need a request object to keep track of this TDI request.
    // Attach this request to the new connection object.
    //

    status = NbfCreateRequest (
                 Irp,                           // IRP for this request.
                 connection,                    // context.
                 REQUEST_FLAGS_CONNECTION,      // partial flags.
                 NULL,
                 0,
                 timeout,
                 &tpRequest);

    if (!NT_SUCCESS (status)) {                    // couldn't make the request.
        NbfDereferenceConnection ("Throw away", connection, CREF_BY_ID);
        return status;                          // return with failure.
    } else {

        // Reference the connection since NbfDestroyRequest derefs it.

        NbfReferenceConnection("For connect request", connection, CREF_REQUEST);

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

        tpRequest->Owner = ConnectionType;
        IoAcquireCancelSpinLock (&cancelirql);
        ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        if ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {
            RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
            IoReleaseCancelSpinLock (cancelirql);
            NbfCompleteRequest (
                tpRequest,
                connection->Status,
                0);
            KeLowerIrql (oldirql);
            NbfDereferenceConnection("Temporary Use 1", connection, CREF_BY_ID);
            return STATUS_PENDING;
        } else {
            InsertTailList (&connection->InProgressRequest,&tpRequest->Linkage);

            //
            // Initialize this now, we cut these down on an async medium
            // that is disconnected.
            //

            connection->Retries = (USHORT)connection->Provider->NameQueryRetries;
            NameQueryTimeout = connection->Provider->NameQueryTimeout;

            if (connection->Provider->MacInfo.MediumAsync) {

                //
                // If we are on an async medium, then we need to send out
                // a committed NAME_QUERY frame right from the start, since
                // the FIND_NAME frames are not forwarded by the gateway.
                //

                connection->Flags2 |= (CONNECTION_FLAGS2_CONNECTOR | // we're the initiator.
                                       CONNECTION_FLAGS2_WAIT_NR); // wait for NAME_RECOGNIZED.

                //
                // Because we may call NbfTdiConnect twice
                // via an automatic connection, check to see
                // if an LSN has already been assigned.
                //
                if (!(connection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN)) {
                    connection->Flags2 |= CONNECTION_FLAGS2_GROUP_LSN;

                    if (NbfAssignGroupLsn(connection) != STATUS_SUCCESS) {

                        //
                        // Could not find an empty LSN; have to fail.
                        //
                        RemoveEntryList(&tpRequest->Linkage);
                        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
                        IoReleaseCancelSpinLock (cancelirql);
                        NbfCompleteRequest (
                            tpRequest,
                            connection->Status,
                            0);
                        KeLowerIrql (oldirql);
                        NbfDereferenceConnection("Temporary Use 1", connection, CREF_BY_ID);
                        return STATUS_PENDING;

                    }
                }

                if (!connection->Provider->MediumSpeedAccurate) {

                    //
                    // The link is not up, so we cut our timeouts down.
                    // We still send one frame so that loopback works.
                    //

                    connection->Retries = 1;
                    NameQueryTimeout = NAME_QUERY_TIMEOUT / 10;

                }

            } else {

                //
                // Normal connection, we send out a FIND_NAME first.
                //

                connection->Flags2 |= (CONNECTION_FLAGS2_CONNECTOR | // we're the initiator.
                                       CONNECTION_FLAGS2_WAIT_NR_FN); // wait for NAME_RECOGNIZED.

            }

            connection->Flags2 &= ~(CONNECTION_FLAGS2_STOPPING |
                                    CONNECTION_FLAGS2_INDICATING);
            connection->Status = STATUS_PENDING;

            RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

            //
            // Check if the IRP has been cancelled.
            //

            if (Irp->Cancel) {
                Irp->CancelIrql = cancelirql;
                NbfCancelConnection((PDEVICE_OBJECT)(connection->Provider), Irp);
                KeLowerIrql (oldirql);
                NbfDereferenceConnection ("IRP cancelled", connection, CREF_BY_ID);   // release lookup hold.
                return STATUS_PENDING;
            }

            IoSetCancelRoutine(Irp, NbfCancelConnection);
            IoReleaseCancelSpinLock(cancelirql);

        }
    }


    //
    // On "easily disconnected" networks, quick reregister
    // (one ADD_NAME_QUERY) the address if NEED_REREGISTER
    // is set (happens when we get a five-second period
    // with no multicast activity). If we are currently
    // quick reregistering, wait for it to complete.
    //

    if (connection->Provider->EasilyDisconnected) {

        PTP_ADDRESS Address;
        LARGE_INTEGER Timeout;

        //
        // If the address needs (or is) reregistering, then do wait,
        // setting a flag so the connect will be resumed when the
        // reregistration times out.
        //

        Address = connection->AddressFile->Address;

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

        if ((Address->Flags &
            (ADDRESS_FLAGS_NEED_REREGISTER | ADDRESS_FLAGS_QUICK_REREGISTER)) != 0) {

            connection->Flags2 |= CONNECTION_FLAGS2_W_ADDRESS;

            if (Address->Flags & ADDRESS_FLAGS_NEED_REREGISTER) {

                Address->Flags &= ~ADDRESS_FLAGS_NEED_REREGISTER;
                Address->Flags |= ADDRESS_FLAGS_QUICK_REREGISTER;

                NbfReferenceAddress ("start registration", Address, AREF_TIMER);
                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

                //
                // Now start reregistration process by starting up a retransmission timer
                // and begin sending ADD_NAME_QUERY NetBIOS frames.
                //

                Address->Retries = 1;
                Timeout.LowPart = (ULONG)(-(LONG)Address->Provider->AddNameQueryTimeout);
                Timeout.HighPart = -1;
                KeSetTimer (&Address->Timer, *(PTIME)&Timeout, &Address->Dpc);

                (VOID)NbfSendAddNameQuery (Address); // send first ADD_NAME_QUERY.

            } else {

                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            }
            KeLowerIrql (oldirql);

            NbfDereferenceConnection("Temporary Use 4", connection, CREF_BY_ID);

            return STATUS_PENDING;                      // things are started.

        } else {

            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

        }

    }

    //
    // Send the NAME_QUERY frame as a FIND.NAME to get a NAME_RECOGNIZED
    // frame back.  The first time we send this frame, we are just looking
    // for the data link information to decide whether we already have
    // a link with the remote NetBIOS name.  If we do, we can reuse it.
    // If we don't, then we make one first, and then use it.  A consequence
    // of this is that we really engage in an extra non-committal NQ/NR
    // exchange up front to locate the remote guy, and then commit to an actual
    // LSN with a second NQ/NR sequence to establish the transport connection
    //

    NbfSendNameQuery (
        connection,
        TRUE);

    //
    // Start the connection timer (do this at the end, so that
    // if we get delayed in this routine the connection won't
    // get into an unexpected state).
    //

    NbfStartConnectionTimer (
        connection,
        ConnectionEstablishmentTimeout,
        NameQueryTimeout);

    KeLowerIrql (oldirql);

    NbfDereferenceConnection("Temporary Use 3", connection, CREF_BY_ID);

    return STATUS_PENDING;                      // things are started.

} /* TdiConnect */



NTSTATUS
NbfTdiDisconnect(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiDisconnect request for the transport provider.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_CONNECTION connection;
    LARGE_INTEGER timeout;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL parameters;
    KIRQL oldirql;
    NTSTATUS status;


    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("TdiDisconnect: Entered.\n");
    }

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection  = irpSp->FileObject->FsContext;

    //
    // If successful this adds a reference of type BY_ID.
    //

    status = NbfVerifyConnectionObject (connection);
    if (!NT_SUCCESS (status)) {
        return status;
    }

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

#if DBG
    if (NbfDisconnectDebug) {
        STRING remoteName;
        STRING localName;
        remoteName.Length = NETBIOS_NAME_LENGTH - 1;
        remoteName.Buffer = connection->RemoteName;
        localName.Length = NETBIOS_NAME_LENGTH - 1;
        localName.Buffer = connection->AddressFile->Address->NetworkName->NetbiosName;
        NbfPrint2( "TdiDisconnect entered for connection to %S from %S\n",
            &remoteName, &localName );
    }
#endif

    //
    // if the connection is currently stopping, there's no reason to blow
    // it away...
    //

    if ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {
#if 0
        NbfPrint2 ("TdiDisconnect: ignoring disconnect %lx, connection stopping (%lx)\n",
            connection, connection->Status);
#endif

        //
        // In case a connect indication is in progress.
        //

        connection->Flags2 |= CONNECTION_FLAGS2_DISCONNECT;

        //
        // If possible, queue the disconnect. This flag is cleared
        // when the indication is about to be done.
        //

        if ((connection->Flags2 & CONNECTION_FLAGS2_REQ_COMPLETED) &&
            (connection->Flags2 & CONNECTION_FLAGS2_LDISC) == 0) {
#if DBG
            DbgPrint ("NBF: Queueing disconnect irp %lx\n", Irp);
#endif
            connection->Flags2 |= CONNECTION_FLAGS2_LDISC;
            status = STATUS_SUCCESS;
        } else {
            status = connection->Status;
        }

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        KeLowerIrql (oldirql);
        NbfDereferenceConnection ("Ignoring disconnect", connection, CREF_BY_ID);       // release our lookup reference.
        return status;

    }

    connection->Flags2 &= ~ (CONNECTION_FLAGS2_ACCEPTED |
                             CONNECTION_FLAGS2_PRE_ACCEPT |
                             CONNECTION_FLAGS2_WAITING_SC);

    connection->Flags2 |= CONNECTION_FLAGS2_DISCONNECT;
    connection->Flags2 |= CONNECTION_FLAGS2_LDISC;

    //
    // Set this flag so the disconnect IRP is completed.
    //
    // If the connection goes down before we can
    // call NbfStopConnection with STATUS_LOCAL_DISCONNECT,
    // the disconnect IRP won't get completed.
    //

    connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

//    connection->DisconnectIrp = Irp;

    //
    // fix up the timeout if required; no disconnect request should take very
    // long. However, the user can cause the timeout to not happen if they
    // desire that.
    //

    parameters = (PTDI_REQUEST_KERNEL)(&irpSp->Parameters);

    //
    // fix up the timeout if required; no disconnect request should take more
    // than 15 seconds. We'll assume that's what the user wanted if they
    // specify -1 as the timer.
    //

    if (parameters->RequestSpecific != NULL) {
        if ((((PLARGE_INTEGER)(parameters->RequestSpecific))->LowPart == -1) &&
             (((PLARGE_INTEGER)(parameters->RequestSpecific))->HighPart == -1)) {

            IF_NBFDBG (NBF_DEBUG_RESOURCE) {
                NbfPrint1 ("TdiDisconnect: Modifying user timeout to %lx seconds.\n",
                    TDI_TIMEOUT_CONNECT);
            }

            timeout.LowPart = (ULONG)(-TDI_TIMEOUT_DISCONNECT * 10000000L);    // n * 10 ** 7 => 100ns units
            if (timeout.LowPart != 0) {
                timeout.HighPart = -1L;
            } else {
                timeout.HighPart = 0;
            }

        } else {
            timeout.LowPart = ((PLARGE_INTEGER)(parameters->RequestSpecific))->LowPart;
            timeout.HighPart = ((PLARGE_INTEGER)(parameters->RequestSpecific))->HighPart;
        }
    }

    //
    // Now the reason for the disconnect
    //

    if ((ULONG)(parameters->RequestFlags) & (ULONG)TDI_DISCONNECT_RELEASE) {
        connection->Flags2 |= CONNECTION_FLAGS2_DESTROY;
    } else if ((ULONG)(parameters->RequestFlags) & (ULONG)TDI_DISCONNECT_ABORT) {
        connection->Flags2 |= CONNECTION_FLAGS2_ABORT;
    } else if ((ULONG)(parameters->RequestFlags) & (ULONG)TDI_DISCONNECT_WAIT) {
        connection->Flags2 |= CONNECTION_FLAGS2_ORDREL;
    }

    RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
        NbfPrint1 ("TdiDisconnect calling NbfStopConnection %lx\n", connection);
    }

    //
    // This will get passed to IoCompleteRequest during TdiDestroyConnection
    //

    NbfStopConnection (connection, STATUS_LOCAL_DISCONNECT);              // starts the abort sequence.

    KeLowerIrql (oldirql);

    NbfDereferenceConnection ("Disconnecting", connection, CREF_BY_ID);       // release our lookup reference.

    //
    // This request will be completed by TdiDestroyConnection once
    // the connection reference count drops to 0.
    //

    return STATUS_SUCCESS;
} /* TdiDisconnect */


NTSTATUS
NbfTdiListen(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiListen request for the transport provider.

Arguments:

    Irp - Pointer to the I/O Request Packet for this request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION connection;
    LARGE_INTEGER timeout = {0,0};
    KIRQL oldirql, cancelirql;
    PTP_REQUEST tpRequest;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_LISTEN parameters;
    PTDI_CONNECTION_INFORMATION ListenInformation;
    TDI_ADDRESS_NETBIOS * ListenAddress;
    PVOID RequestBuffer2;
    ULONG RequestBuffer2Length;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("TdiListen: Entered.\n");
    }

    //
    // validate this connection

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (irpSp->FileObject->FsContext2 != (PVOID) TDI_CONNECTION_FILE) {
        return STATUS_INVALID_CONNECTION;
    }

    connection  = irpSp->FileObject->FsContext;

    //
    // If successful this adds a reference of type BY_ID.
    //

    status = NbfVerifyConnectionObject (connection);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    parameters = (PTDI_REQUEST_KERNEL_LISTEN)&irpSp->Parameters;

    //
    // Record the remote address if there is one.
    //

    ListenInformation = parameters->RequestConnectionInformation;

    if ((ListenInformation != NULL) &&
        (ListenInformation->RemoteAddress != NULL)) {

        if ((NbfValidateTdiAddress(
             ListenInformation->RemoteAddress,
             ListenInformation->RemoteAddressLength)) &&
            ((ListenAddress = NbfParseTdiAddress(ListenInformation->RemoteAddress, FALSE)) != NULL)) {

            RequestBuffer2 = (PVOID)ListenAddress->NetbiosName,
            RequestBuffer2Length = NETBIOS_NAME_LENGTH;

        } else {

            IF_NBFDBG (NBF_DEBUG_CONNECT) {
                NbfPrint0 ("TdiListen: Create Request Failed, bad address.\n");
            }

            NbfDereferenceConnection ("Bad address", connection, CREF_BY_ID);
            return STATUS_BAD_NETWORK_PATH;
        }

    } else {

        RequestBuffer2 = NULL;
        RequestBuffer2Length = 0;
    }

    //
    // We need a request object to keep track of this TDI request.
    // Attach this request to the new connection object.
    //

    status = NbfCreateRequest (
                 Irp,                           // IRP for this request.
                 connection,                    // context.
                 REQUEST_FLAGS_CONNECTION,      // partial flags.
                 RequestBuffer2,
                 RequestBuffer2Length,
                 timeout,                       // timeout value (can be 0).
                 &tpRequest);


    if (!NT_SUCCESS (status)) {                    // couldn't make the request.
        IF_NBFDBG (NBF_DEBUG_CONNECT) {
            NbfPrint1 ("TdiListen: Create Request Failed, reason: %lx.\n", status);
        }

        NbfDereferenceConnection ("For create", connection, CREF_BY_ID);
        return status;                          // return with failure.
    }

    // Reference the connection since NbfDestroyRequest derefs it.

    IoAcquireCancelSpinLock (&cancelirql);
    ACQUIRE_C_SPIN_LOCK (&connection->SpinLock, &oldirql);
    tpRequest->Owner = ConnectionType;

    NbfReferenceConnection("For listen request", connection, CREF_REQUEST);

    if ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {

        RELEASE_C_SPIN_LOCK (&connection->SpinLock,oldirql);
        IoReleaseCancelSpinLock(cancelirql);

        NbfCompleteRequest (
            tpRequest,
            connection->Status,
            0);
        NbfDereferenceConnection("Temp create", connection, CREF_BY_ID);
        return STATUS_PENDING;

    } else {

        InsertTailList (&connection->InProgressRequest,&tpRequest->Linkage);
        connection->Flags2 |= (CONNECTION_FLAGS2_LISTENER |   // we're the passive one.
                               CONNECTION_FLAGS2_WAIT_NQ);     // wait for NAME_QUERY.
        connection->Flags2 &= ~(CONNECTION_FLAGS2_INDICATING |
                                CONNECTION_FLAGS2_STOPPING);
        connection->Status = STATUS_PENDING;

        //
        // If TDI_QUERY_ACCEPT is not set, then we set PRE_ACCEPT to
        // indicate that when the listen completes we do not have to
        // wait for a TDI_ACCEPT to continue.
        //

        if ((parameters->RequestFlags & TDI_QUERY_ACCEPT) == 0) {
            connection->Flags2 |= CONNECTION_FLAGS2_PRE_ACCEPT;
        }

        RELEASE_C_SPIN_LOCK (&connection->SpinLock,oldirql);

        //
        // Check if the IRP has been cancelled.
        //

        if (Irp->Cancel) {
            Irp->CancelIrql = cancelirql;
            NbfCancelConnection((PDEVICE_OBJECT)(connection->Provider), Irp);
            NbfDereferenceConnection ("IRP cancelled", connection, CREF_BY_ID);   // release lookup hold.
            return STATUS_PENDING;
        }

        IoSetCancelRoutine(Irp, NbfCancelConnection);
        IoReleaseCancelSpinLock(cancelirql);

    }

    //
    // Wait for an incoming NAME_QUERY frame.  The remainder of the
    // connectionless protocol to set up a connection is processed
    // in the NAME_QUERY frame handler.
    //

    NbfDereferenceConnection("Temp create", connection, CREF_BY_ID);

    return STATUS_PENDING;                      // things are started.
} /* TdiListen */


NTSTATUS
NbfOpenConnection (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to open a connection. Note that the connection that
    is open is of little use until associated with an address; until then,
    the only thing that can be done with it is close it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    NTSTATUS status;
    PTP_CONNECTION connection;
    PFILE_FULL_EA_INFORMATION ea;

    UNREFERENCED_PARAMETER (Irp);

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint0 ("NbfOpenConnection: Entered.\n");
    }

    DeviceContext = (PDEVICE_CONTEXT)DeviceObject;


    // Make sure we have a connection context specified in the EA info
    ea = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    if (ea->EaValueLength < sizeof(PVOID)) {
        return STATUS_INVALID_PARAMETER;
    }

    // Then, try to make a connection object to represent this pending
    // connection.  Then fill in the relevant fields.
    // In addition to the creation, if successful NbfCreateConnection
    // will create a second reference which is removed once the request
    // references the connection, or if the function exits before that.

    status = NbfCreateConnection (DeviceContext, &connection);
    if (!NT_SUCCESS (status)) {
        return status;                          // sorry, we couldn't make one.
    }

    //
    // set the connection context so we can connect the user to this data
    // structure
    //

    RtlCopyMemory (
        &connection->Context,
        &ea->EaName[ea->EaNameLength+1],
        sizeof (PVOID));

    //
    // let file object point at connection and connection at file object
    //

    IrpSp->FileObject->FsContext = (PVOID)connection;
    IrpSp->FileObject->FsContext2 = (PVOID)TDI_CONNECTION_FILE;
    connection->FileObject = IrpSp->FileObject;

    IF_NBFDBG (NBF_DEBUG_CONNECT) {
        NbfPrint1 ("NBFOpenConnection: Opened Connection %lx.\n",
              connection);
    }

    return status;

} /* NbfOpenConnection */

#if DBG
VOID
ConnectionCloseTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    Connection = (PTP_CONNECTION)DeferredContext;

    DbgPrint ("NBF: Close of connection %lxpending for 2 minutes\n", 
               Connection);
}
#endif


NTSTATUS
NbfCloseConnection (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to close a connection. There may be actions in
    progress on this connection, so we note the closing IRP, mark the
    connection as closing, and complete it somewhere down the road (when all
    references have been removed).

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS status;
    KIRQL oldirql;
    PTP_CONNECTION connection;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    //
    // is the file object a connection?
    //

    connection  = IrpSp->FileObject->FsContext;

    IF_NBFDBG (NBF_DEBUG_CONNECT | NBF_DEBUG_PNP) {
        NbfPrint1 ("NbfCloseConnection CO %lx:\n",connection);
    }

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    //
    // We duplicate the code from VerifyConnectionObject,
    // although we don't actually call that since it does
    // a reference, which we don't want (to avoid bouncing
    // the reference count up from 0 if this is a dead
    // link).
    //

    try {

        if ((connection->Size == sizeof (TP_CONNECTION)) &&
            (connection->Type == NBF_CONNECTION_SIGNATURE)) {

            ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

            if ((connection->Flags2 & CONNECTION_FLAGS2_CLOSING) == 0) {

                status = STATUS_SUCCESS;

            } else {

                status = STATUS_INVALID_CONNECTION;
            }

            RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        } else {

            status = STATUS_INVALID_CONNECTION;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        KeLowerIrql (oldirql);
        return GetExceptionCode();
    }

    if (!NT_SUCCESS (status)) {
        KeLowerIrql (oldirql);
        return status;
    }

    //
    // We recognize it; is it closing already?
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

    if ((connection->Flags2 & CONNECTION_FLAGS2_CLOSING) != 0) {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        KeLowerIrql (oldirql);
#if DBG
        NbfPrint1("Closing already-closing connection %lx\n", connection);
#endif
        return STATUS_INVALID_CONNECTION;
    }

    connection->Flags2 |= CONNECTION_FLAGS2_CLOSING;

    //
    // if there is activity on the connection, tear it down.
    //

    if ((connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
        NbfStopConnection (connection, STATUS_LOCAL_DISCONNECT);
        ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    }

    //
    // If the connection is still associated, disassociate it.
    //

    if ((connection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) &&
            ((connection->Flags2 & CONNECTION_FLAGS2_DISASSOCIATED) == 0)) {
        connection->Flags2 |= CONNECTION_FLAGS2_DISASSOCIATED;
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    } else {
        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);
    }

    //
    // Save this to complete the IRP later.
    //

    connection->CloseIrp = Irp;

#if 0
    //
    // make it impossible to use this connection from the file object
    //

    IrpSp->FileObject->FsContext = NULL;
    IrpSp->FileObject->FsContext2 = NULL;
    connection->FileObject = NULL;
#endif

#if DBG
    {
        LARGE_INTEGER Timeout;
        BOOLEAN AlreadyInserted;

        Timeout.LowPart = (ULONG)(-(120*SECONDS));
        Timeout.HighPart = -1;

        ACQUIRE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        AlreadyInserted = KeCancelTimer (&connection->Timer);

        KeInitializeDpc (
            &connection->Dpc,
            ConnectionCloseTimeout,
            (PVOID)connection);

        KeSetTimer (
            &connection->Timer,
            Timeout,
            &connection->Dpc);

        RELEASE_DPC_C_SPIN_LOCK (&connection->SpinLock);

        if (AlreadyInserted) {
            DbgPrint ("NBF: Cancelling connection timer for debug %lx\n", connection);
            NbfDereferenceConnection ("debug", connection, CREF_TIMER);
        }

    }
#endif

    KeLowerIrql (oldirql);

    //
    // dereference for the creation. Note that this dereference
    // here won't have any effect until the regular reference count
    // hits zero.
    //

    NbfDereferenceConnectionSpecial (" Closing Connection", connection, CREF_SPECIAL_CREATION);

    return STATUS_PENDING;

} /* NbfCloseConnection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\devctx.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    devctx.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.
    Routines are provided to reference, and dereference transport device
    context objects.  Currently, there is no need to create them or destroy
    them, as this is handled at configuration time.  If it is later required
    to dynamically load/unload the transport provider's device object and
    associated context, then we can add the create and destroy functions.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Author:

    David Beaver (dbeaver) 1 -July 1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NbfCreateDeviceContext)
#endif


VOID
NbfRefDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    DeviceContext - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_DEVCTX) {
        NbfPrint0 ("NbfRefDeviceContext:  Entered.\n");
    }

    ASSERT (DeviceContext->ReferenceCount >= 0);    // not perfect, but...

    (VOID)InterlockedIncrement (&DeviceContext->ReferenceCount);

} /* NbfRefDeviceContext */


VOID
NbfDerefDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    DeviceContext - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_DEVCTX) {
        NbfPrint0 ("NbfDerefDeviceContext:  Entered.\n");
    }

    result = InterlockedDecrement (&DeviceContext->ReferenceCount);

    ASSERT (result >= 0);

    if (result == 0) {
        NbfDestroyDeviceContext (DeviceContext);
    }

} /* NbfDerefDeviceContext */



NTSTATUS
NbfCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    DeviceContext - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_CONTEXT deviceContext;
    USHORT i;


    //
    // Create the device object for NETBEUI.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof (DEVICE_CONTEXT) - sizeof (DEVICE_OBJECT) +
                     (DeviceName->Length + sizeof(UNICODE_NULL)),
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    deviceContext = (PDEVICE_CONTEXT)deviceObject;

    //
    // Initialize our part of the device context.
    //

    RtlZeroMemory(
        ((PUCHAR)deviceContext) + sizeof(DEVICE_OBJECT),
        sizeof(DEVICE_CONTEXT) - sizeof(DEVICE_OBJECT));

    //
    // Copy over the device name.
    //

    deviceContext->DeviceNameLength = DeviceName->Length + sizeof(WCHAR);
    deviceContext->DeviceName = (PWCHAR)(deviceContext+1);
    RtlCopyMemory(
        deviceContext->DeviceName,
        DeviceName->Buffer,
        DeviceName->Length);
    deviceContext->DeviceName[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Initialize device context fields.
    //

    deviceContext->NetmanVariables = NULL;      // no variables yet.

    //
    // Initialize the reference count.
    //

    deviceContext->ReferenceCount = 1;

#if DBG
    {
        UINT Counter;
        for (Counter = 0; Counter < NUMBER_OF_DCREFS; Counter++) {
            deviceContext->RefTypes[Counter] = 0;
        }

        // This reference is removed by the caller.

        deviceContext->RefTypes[DCREF_CREATION] = 1;
    }
#endif

    deviceContext->CreateRefRemoved = FALSE;

    //
    // initialize the various fields in the device context
    //

    InitializeListHead(&deviceContext->Linkage);

    KeInitializeSpinLock (&deviceContext->Interlock);
    KeInitializeSpinLock (&deviceContext->SpinLock);
    KeInitializeSpinLock (&deviceContext->LinkSpinLock);
    KeInitializeSpinLock (&deviceContext->TimerSpinLock);
    KeInitializeSpinLock (&deviceContext->LoopbackSpinLock);
    KeInitializeSpinLock (&deviceContext->SendPoolListLock);
    KeInitializeSpinLock (&deviceContext->RcvPoolListLock);

    deviceContext->LinkTreeRoot = NULL;
    deviceContext->LastLink = NULL;
    deviceContext->LinkTreeElements = 0;

    deviceContext->LoopbackLinks[0] = NULL;
    deviceContext->LoopbackLinks[1] = NULL;
    deviceContext->LoopbackInProgress = FALSE;
    KeInitializeDpc(
        &deviceContext->LoopbackDpc,
        NbfProcessLoopbackQueue,
        (PVOID)deviceContext
        );

    deviceContext->WanThreadQueued = FALSE;
    ExInitializeWorkItem(
        &deviceContext->WanDelayedQueueItem,
        NbfProcessWanDelayedQueue,
        (PVOID)deviceContext);


    deviceContext->UniqueIdentifier = 1;
    deviceContext->ControlChannelIdentifier = 1;

    InitializeListHead (&deviceContext->ConnectionPool);
    InitializeListHead (&deviceContext->AddressPool);
    InitializeListHead (&deviceContext->AddressFilePool);
    InitializeListHead (&deviceContext->AddressDatabase);
    InitializeListHead (&deviceContext->LinkPool);
    InitializeListHead (&deviceContext->LinkDeferred);
    InitializeListHead (&deviceContext->PacketWaitQueue);
    InitializeListHead (&deviceContext->PacketizeQueue);
    InitializeListHead (&deviceContext->DataAckQueue);
    InitializeListHead (&deviceContext->DeferredRrQueue);
    InitializeListHead (&deviceContext->RequestPool);
    InitializeListHead (&deviceContext->UIFramePool);
    deviceContext->PacketPool.Next = NULL;
    deviceContext->RrPacketPool.Next = NULL;
    deviceContext->ReceivePacketPool.Next = NULL;
    deviceContext->ReceiveBufferPool.Next = NULL;
    InitializeListHead (&deviceContext->ReceiveInProgress);
    InitializeListHead (&deviceContext->ShortList);
    InitializeListHead (&deviceContext->LongList);
    InitializeListHead (&deviceContext->PurgeList);
    InitializeListHead (&deviceContext->LoopbackQueue);
    InitializeListHead (&deviceContext->FindNameQueue);
    InitializeListHead (&deviceContext->StatusQueryQueue);
    InitializeListHead (&deviceContext->IrpCompletionQueue);

    InitializeListHead (&deviceContext->QueryIndicationQueue);
    InitializeListHead (&deviceContext->DatagramIndicationQueue);
    deviceContext->IndicationQueuesInUse = FALSE;

    //
    // Equivalent to setting ShortListActive, DataAckQueueActive,
    // and LinkDeferredActive to FALSE.
    //

    deviceContext->a.AnyActive = 0;

    deviceContext->ProcessingShortTimer = FALSE;
    deviceContext->DataAckQueueChanged = FALSE;
    deviceContext->StalledConnectionCount = (USHORT)0;

    deviceContext->EasilyDisconnected = FALSE;

    //
    // Initialize provider statistics.
    //

    deviceContext->Statistics.Version = 0x0100;

#if 0
    deviceContext->Information.Version = 2;
    deviceContext->Information.MaxTsduSize = NBF_MAX_TSDU_SIZE;
    deviceContext->Information.MaxDatagramSize = NBF_MAX_DATAGRAM_SIZE;
    deviceContext->Information.MaxConnectionUserData = NBF_MAX_CONNECTION_USER_DATA;
    deviceContext->Information.ServiceFlags = NBF_SERVICE_FLAGS;
    deviceContext->Information.TransmittedTsdus = 0;
    deviceContext->Information.ReceivedTsdus = 0;
    deviceContext->Information.TransmissionErrors = 0;
    deviceContext->Information.ReceiveErrors = 0;
    deviceContext->Information.MinimumLookaheadData = NBF_MIN_LOOKAHEAD_DATA;
    deviceContext->Information.MaximumLookaheadData = NBF_MAX_LOOKAHEAD_DATA;
    deviceContext->Information.DiscardedFrames = 0;
    deviceContext->Information.OversizeTsdusReceived = 0;
    deviceContext->Information.UndersizeTsdusReceived = 0;
    deviceContext->Information.MulticastTsdusReceived = 0;
    deviceContext->Information.BroadcastTsdusReceived = 0;
    deviceContext->Information.MulticastTsdusTransmitted = 0;
    deviceContext->Information.BroadcastTsdusTransmitted = 0;
    deviceContext->Information.SendTimeouts = 0;
    deviceContext->Information.ReceiveTimeouts = 0;
    deviceContext->Information.ConnectionIndicationsReceived = 0;
    deviceContext->Information.ConnectionIndicationsAccepted = 0;
    deviceContext->Information.ConnectionsInitiated = 0;
    deviceContext->Information.ConnectionsAccepted = 0;
#endif

    deviceContext->State = DEVICECONTEXT_STATE_OPENING;

    //
    // Loopback buffer is not allocated.
    //

    deviceContext->LookaheadContiguous = NULL;

    //
    // Initialize the resource that guards address ACLs.
    //

    ExInitializeResourceLite (&deviceContext->AddressResource);

    //
    // No LSNs are in use.
    //

    for (i=0; i<(NETBIOS_SESSION_LIMIT+1); i++) {
        deviceContext->LsnTable[i] = 0;
    }
    deviceContext->NextLsnStart = 1;

    //
    // No addresses are in use.
    //

    for (i=0; i<256; i++) {
        deviceContext->AddressCounts[i] = 0;
    }

    //
    // No timers in use at present
    //

    INITIALIZE_TIMER_STATE(deviceContext);

    //
    // set the netbios multicast address for this network type
    //

    for (i=0; i<HARDWARE_ADDRESS_LENGTH; i++) {
        deviceContext->LocalAddress.Address [i] = 0; // set later
        deviceContext->NetBIOSAddress.Address [i] = 0;
    }

     deviceContext->Type = NBF_DEVICE_CONTEXT_SIGNATURE;
     deviceContext->Size = sizeof (DEVICE_CONTEXT);

    *DeviceContext = deviceContext;
    return STATUS_SUCCESS;
}


VOID
NbfDestroyDeviceContext(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    DeviceContext - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    KIRQL       oldIrql;

    ACQUIRE_DEVICES_LIST_LOCK();

    // Is ref count zero - or did a new rebind happen now
    // See rebind happen in NbfReInitializeDeviceContext
    if (DeviceContext->ReferenceCount != 0)
    {
        // A rebind happened while we waited for the lock
        RELEASE_DEVICES_LIST_LOCK();
        return;
    }

    // Splice this adapter of the list of device contexts
    RemoveEntryList (&DeviceContext->Linkage);
    
    RELEASE_DEVICES_LIST_LOCK();

    // Mark the adapter as going away to prevent activity
    DeviceContext->State = DEVICECONTEXT_STATE_STOPPING;

    // Free the packet pools, etc. and close the adapter.
    NbfCloseNdis (DeviceContext);

    // Remove all the storage associated with the device.
    NbfFreeResources (DeviceContext);

    // Cleanup any kernel resources
    ExDeleteResourceLite (&DeviceContext->AddressResource);

    // Delete device from IO space
    IoDeleteDevice ((PDEVICE_OBJECT)DeviceContext);
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\connobj.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    connobj.c

Abstract:

    This module contains code which implements the TP_CONNECTION object.
    Routines are provided to create, destroy, reference, and dereference,
    transport connection objects.

    A word about connection reference counts:

    With TDI version 2, connections live on even after they have been stopped.
    This necessitated changing the way NBF handles connection reference counts,
    making the stopping of a connection only another way station in the life
    of a connection, rather than its demise. Reference counts now work like
    this:

    Connection State         Reference Count     Flags
   ------------------       -----------------   --------
    Opened, no activity             1              0
    Open, Associated                2            FLAGS2_ASSOCIATED
    Open, Assoc., Connected         3            FLAGS_READY
     Above + activity              >3            varies
    Open, Assoc., Stopping         >3            FLAGS_STOPPING
    Open, Assoc., Stopped           3            FLAGS_STOPPING
    Open, Disassoc. Complete        2            FLAGS_STOPPING
                                                 FLAGS2_ASSOCIATED == 0
    Closing                         1            FLAGS2_CLOSING
    Closed                          0            FLAGS2_CLOSING

    Note that keeping the stopping flag set when the connection has fully
    stopped avoids using the connection until it is connected again; the
    CLOSING flag serves the same purpose. This allows a connection to run
    down in its own time.


Author:

    David Beaver (dbeaver) 1 July 1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL

#ifdef RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

//
// Imported routines
//
BOOLEAN
NbfAttemptAutoDial(
    IN PTP_CONNECTION         Connection,
    IN ULONG                  ulFlags,
    IN ACD_CONNECT_CALLBACK   pProc,
    IN PVOID                  pArg
    );

VOID
NbfRetryTdiConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

BOOLEAN
NbfCancelTdiConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );
#endif // RASAUTODIAL



VOID
ConnectionEstablishmentTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is executed as a DPC at DISPATCH_LEVEL when the timeout
    period for the NAME_QUERY/NAME_RECOGNIZED protocol expires.  The retry
    count in the Connection object is decremented, and if it reaches 0,
    the connection is aborted.  If the retry count has not reached zero,
    then the NAME QUERY is retried.  The following cases are covered by
    this routine:

    1.  Initial NAME_QUERY timeout for find_name portion of connection setup.

        NQ(find_name)   ------------------->
        [TIMEOUT]
        NQ(find_name)   ------------------->
                        <------------------- NR(find_name)

    2.  Secondary NAME_QUERY timeout for connection setup.

        NQ(connection)  ------------------->
        [TIMEOUT]
        NQ(connection)  ------------------->
                        <------------------- NR(connection)

    There is another case where the data link connection does not get
    established within a reasonable amount of time.  This is handled by
    the link layer routines.

Arguments:

    Dpc - Pointer to a system DPC object.

    DeferredContext - Pointer to the TP_CONNECTION block representing the
        request that has timed out.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    none.

--*/

{
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    Connection = (PTP_CONNECTION)DeferredContext;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint1 ("ConnectionEstablishmentTimeout:  Entered for connection %lx.\n",
                    Connection);
    }

    //
    // If this connection is being run down, then we can't do anything.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if (Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) {
        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
        NbfDereferenceConnection ("Connect timed out", Connection, CREF_TIMER);
        LEAVE_NBF;
        return;
    }


    if (Connection->Flags2 & (CONNECTION_FLAGS2_WAIT_NR_FN | CONNECTION_FLAGS2_WAIT_NR)) {

        //
        // We are waiting for a commital or non-commital NAME_RECOGNIZED frame.
        // Decrement the retry count, and possibly resend the NAME_QUERY.
        //

        if (--(Connection->Retries) == 0) {     // if retry count exhausted.

            NTSTATUS StopStatus;

            //
            // See if we got a no listens response, or just
            // nothing.
            //

            if ((Connection->Flags2 & CONNECTION_FLAGS2_NO_LISTEN) != 0) {

                Connection->Flags2 &= ~CONNECTION_FLAGS2_NO_LISTEN;
                StopStatus = STATUS_REMOTE_NOT_LISTENING;  // no listens

            } else {

                StopStatus = STATUS_BAD_NETWORK_PATH; // name not found.

            }

#ifdef RASAUTODIAL
            //
            // If this is a connect operation that has
            // returned with STATUS_BAD_NETWORK_PATH, then
            // attempt to create an automatic connection.
            //
            if (fAcdLoadedG &&
                StopStatus == STATUS_BAD_NETWORK_PATH)
            {
                KIRQL adirql;
                BOOLEAN fEnabled;

                ACQUIRE_SPIN_LOCK(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                RELEASE_SPIN_LOCK(&AcdDriverG.SpinLock, adirql);
                if (fEnabled && NbfAttemptAutoDial(
                                  Connection,
                                  0,
                                  NbfRetryTdiConnect,
                                  Connection))
                {
                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                    goto done;
                }
            }
#endif // RASAUTODIAL

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            NbfStopConnection (Connection, StopStatus);

        } else {

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            //
            // We make source routing optional on every second
            // name query (whenever Retries is even).
            //

            NbfSendNameQuery (
                Connection,
                (BOOLEAN)((Connection->Retries & 1) ? FALSE : TRUE));

            NbfStartConnectionTimer (
                Connection,
                ConnectionEstablishmentTimeout,
                Connection->Provider->NameQueryTimeout);

        }

    } else {

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    }


    //
    // Dereference the connection, to account for the fact that the
    // timer went off.  Note that if we restarted the timer using
    // NbfStartConnectionTimer, the reference count has already been
    // incremented to account for the new timer.
    //

done:
    NbfDereferenceConnection ("Timer timed out",Connection, CREF_TIMER);

    LEAVE_NBF;
    return;

} /* ConnectionEstablishmentTimeout */


VOID
NbfAllocateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_CONNECTION *TransportConnection
    )

/*++

Routine Description:

    This routine allocates storage for a transport connection. Some
    minimal initialization is done.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - the device context for this connection to be
        associated with.

    TransportConnection - Pointer to a place where this routine will
        return a pointer to a transport connection structure. Returns
        NULL if the storage cannot be allocated.

Return Value:

    None.

--*/

{

    PTP_CONNECTION Connection;

    if ((DeviceContext->MemoryLimit != 0) &&
            ((DeviceContext->MemoryUsage + sizeof(TP_CONNECTION)) >
                DeviceContext->MemoryLimit)) {
        PANIC("NBF: Could not allocate connection: limit\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_LIMIT,
            103,
            sizeof(TP_CONNECTION),
            CONNECTION_RESOURCE_ID);
        *TransportConnection = NULL;
        return;
    }

    Connection = (PTP_CONNECTION)ExAllocatePoolWithTag (
                                     NonPagedPool,
                                     sizeof (TP_CONNECTION),
                                     NBF_MEM_TAG_TP_CONNECTION);
    if (Connection == NULL) {
        PANIC("NBF: Could not allocate connection: no pool\n");
        NbfWriteResourceErrorLog(
            DeviceContext,
            EVENT_TRANSPORT_RESOURCE_POOL,
            203,
            sizeof(TP_CONNECTION),
            CONNECTION_RESOURCE_ID);
        *TransportConnection = NULL;
        return;
    }
    RtlZeroMemory (Connection, sizeof(TP_CONNECTION));

    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint1 ("ExAllocatePool Connection %08x\n", Connection);
    }

    DeviceContext->MemoryUsage += sizeof(TP_CONNECTION);
    ++DeviceContext->ConnectionAllocated;

    Connection->Type = NBF_CONNECTION_SIGNATURE;
    Connection->Size = sizeof (TP_CONNECTION);

    Connection->Provider = DeviceContext;
    Connection->ProviderInterlock = &DeviceContext->Interlock;
    KeInitializeSpinLock (&Connection->SpinLock);
    KeInitializeDpc (
        &Connection->Dpc,
        ConnectionEstablishmentTimeout,
        (PVOID)Connection);
    KeInitializeTimer (&Connection->Timer);


    InitializeListHead (&Connection->LinkList);
    InitializeListHead (&Connection->AddressFileList);
    InitializeListHead (&Connection->AddressList);
    InitializeListHead (&Connection->PacketWaitLinkage);
    InitializeListHead (&Connection->PacketizeLinkage);
    InitializeListHead (&Connection->SendQueue);
    InitializeListHead (&Connection->ReceiveQueue);
    InitializeListHead (&Connection->InProgressRequest);
    InitializeListHead (&Connection->DeferredQueue);

    NbfAddSendPacket (DeviceContext);
    NbfAddSendPacket (DeviceContext);
    NbfAddUIFrame (DeviceContext);

    *TransportConnection = Connection;

}   /* NbfAllocateConnection */


VOID
NbfDeallocateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine frees storage for a transport connection.

    NOTE: This routine is called with the device context spinlock
    held, or at such a time as synchronization is unnecessary.

Arguments:

    DeviceContext - the device context for this connection to be
        associated with.

    TransportConnection - Pointer to a transport connection structure.

Return Value:

    None.

--*/

{
    IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
        NbfPrint1 ("ExFreePool Connection: %08x\n", TransportConnection);
    }

    ExFreePool (TransportConnection);
    --DeviceContext->ConnectionAllocated;
    DeviceContext->MemoryUsage -= sizeof(TP_CONNECTION);

    NbfRemoveSendPacket (DeviceContext);
    NbfRemoveSendPacket (DeviceContext);
    NbfRemoveUIFrame (DeviceContext);

}   /* NbfDeallocateConnection */


NTSTATUS
NbfCreateConnection(
    IN PDEVICE_CONTEXT DeviceContext,
    OUT PTP_CONNECTION *TransportConnection
    )

/*++

Routine Description:

    This routine creates a transport connection. The reference count in the
    connection is automatically set to 1, and the reference count in the
    DeviceContext is incremented.

Arguments:

    Address - the address for this connection to be associated with.

    TransportConnection - Pointer to a place where this routine will
        return a pointer to a transport connection structure.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_CONNECTION Connection;
    KIRQL oldirql;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint0 ("NbfCreateConnection:  Entered.\n");
    }

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    p = RemoveHeadList (&DeviceContext->ConnectionPool);
    if (p == &DeviceContext->ConnectionPool) {

        if ((DeviceContext->ConnectionMaxAllocated == 0) ||
            (DeviceContext->ConnectionAllocated < DeviceContext->ConnectionMaxAllocated)) {

            NbfAllocateConnection (DeviceContext, &Connection);
            IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
                NbfPrint1 ("NBF: Allocated connection at %lx\n", Connection);
            }

        } else {

            NbfWriteResourceErrorLog(
                DeviceContext,
                EVENT_TRANSPORT_RESOURCE_SPECIFIC,
                403,
                sizeof(TP_CONNECTION),
                CONNECTION_RESOURCE_ID);
            Connection = NULL;

        }

        if (Connection == NULL) {
            ++DeviceContext->ConnectionExhausted;
            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
            PANIC ("NbfCreateConnection: Could not allocate connection object!\n");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);
#if DBG
        InitializeListHead (p);
#endif

    }

    ++DeviceContext->ConnectionInUse;
    if (DeviceContext->ConnectionInUse > DeviceContext->ConnectionMaxInUse) {
        ++DeviceContext->ConnectionMaxInUse;
    }

    DeviceContext->ConnectionTotal += DeviceContext->ConnectionInUse;
    ++DeviceContext->ConnectionSamples;

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);


    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
        NbfPrint1 ("NbfCreateConnection:  Connection at %lx.\n", Connection);
    }

    //
    // We have two references; one is for creation, and the
    // other is a temporary one so that the connection won't
    // go away before the creator has a chance to access it.
    //

    Connection->SpecialRefCount = 1;
    Connection->ReferenceCount = -1;   // this is -1 based

#if DBG
    {
        UINT Counter;
        for (Counter = 0; Counter < NUMBER_OF_CREFS; Counter++) {
            Connection->RefTypes[Counter] = 0;
        }

        // This reference is removed by NbfCloseConnection

        Connection->RefTypes[CREF_SPECIAL_CREATION] = 1;
    }
#endif

    //
    // Initialize the request queues & components of this connection.
    //

    InitializeListHead (&Connection->SendQueue);
    InitializeListHead (&Connection->ReceiveQueue);
    InitializeListHead (&Connection->InProgressRequest);
    InitializeListHead (&Connection->AddressList);
    InitializeListHead (&Connection->AddressFileList);
    Connection->SpecialReceiveIrp = (PIRP)NULL;
    Connection->Flags = 0;
    Connection->Flags2 = 0;
    Connection->DeferredFlags = 0;
    Connection->Lsn = 0;
    Connection->Rsn = 0;
    Connection->Retries = 0;                        // no retries yet.
    Connection->MessageBytesReceived = 0;           // no data yet
    Connection->MessageBytesAcked = 0;
    Connection->MessageInitAccepted = 0;
    Connection->ReceiveBytesUnaccepted = 0;
    Connection->CurrentReceiveAckQueueable = FALSE;
    Connection->CurrentReceiveSynchronous = FALSE;
    Connection->ConsecutiveSends = 0;
    Connection->ConsecutiveReceives = 0;
    Connection->Link = NULL;                    // no datalink connection yet.
    Connection->LinkSpinLock = NULL;
    Connection->Context = NULL;                 // no context yet.
    Connection->Status = STATUS_PENDING;        // default NbfStopConnection status.
    Connection->SendState = CONNECTION_SENDSTATE_IDLE;
    Connection->CurrentReceiveIrp = (PIRP)NULL;
    Connection->DisconnectIrp = (PIRP)NULL;
    Connection->CloseIrp = (PIRP)NULL;
    Connection->AddressFile = NULL;
    Connection->IndicationInProgress = FALSE;
    Connection->OnDataAckQueue = FALSE;
    Connection->OnPacketWaitQueue = FALSE;
    Connection->TransferBytesPending = 0;
    Connection->TotalTransferBytesPending = 0;

    RtlZeroMemory (&Connection->NetbiosHeader, sizeof(NBF_HDR_CONNECTION));

#if PKT_LOG
    RtlZeroMemory (&Connection->LastNRecvs, sizeof(PKT_LOG_QUE));
    RtlZeroMemory (&Connection->LastNSends, sizeof(PKT_LOG_QUE));
    RtlZeroMemory (&Connection->LastNIndcs, sizeof(PKT_IND_QUE));
#endif // PKT_LOG

#if DBG
    Connection->Destroyed = FALSE;
    Connection->TotalReferences = 0;
    Connection->TotalDereferences = 0;
    Connection->NextRefLoc = 0;
    ExInterlockedInsertHeadList (&NbfGlobalConnectionList, &Connection->GlobalLinkage, &NbfGlobalInterlock);
    StoreConnectionHistory (Connection, TRUE);
#endif

    //
    // Now assign this connection an ID. This is used later to identify the
    // connection across multiple processes.
    //
    // The high bit of the ID is not user, it is off for connection
    // initiating NAME.QUERY frames and on for ones that are the result
    // of a FIND.NAME request.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    Connection->ConnectionId = DeviceContext->UniqueIdentifier;
    ++DeviceContext->UniqueIdentifier;
    if (DeviceContext->UniqueIdentifier == 0x8000) {
        DeviceContext->UniqueIdentifier = 1;
    }

    NbfReferenceDeviceContext ("Create Connection", DeviceContext, DCREF_CONNECTION);
    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    *TransportConnection = Connection;  // return the connection.

    return STATUS_SUCCESS;
} /* NbfCreateConnection */


NTSTATUS
NbfVerifyConnectionObject (
    IN PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid connection object.

Arguments:

    Connection - potential pointer to a TP_CONNECTION object.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_CONNECTION otherwise

--*/

{
    KIRQL oldirql;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // try to verify the connection signature. If the signature is valid,
    // get the connection spinlock, check its state, and increment the
    // reference count if it's ok to use it. Note that being in the stopping
    // state is an OK place to be and reference the connection; we can
    // disassociate the address while running down.
    //

    try {

        if ((Connection != (PTP_CONNECTION)NULL) &&
            (Connection->Size == sizeof (TP_CONNECTION)) &&
            (Connection->Type == NBF_CONNECTION_SIGNATURE)) {

            ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql);

            if ((Connection->Flags2 & CONNECTION_FLAGS2_CLOSING) == 0) {

                NbfReferenceConnection ("Verify Temp Use", Connection, CREF_BY_ID);

            } else {

                status = STATUS_INVALID_CONNECTION;
            }

            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql);

        } else {

            status = STATUS_INVALID_CONNECTION;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         return GetExceptionCode();
    }

    return status;

}


NTSTATUS
NbfDestroyAssociation(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine destroys the association between a transport connection and
    the address it was formerly associated with. The only action taken is
    to disassociate the address and remove the connection from all address
    queues.

    This routine is only called by NbfDereferenceConnection.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same connection object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    TransportConnection - Pointer to a transport connection structure to
        be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql, oldirql2;
    PTP_ADDRESS address;
    PTP_ADDRESS_FILE addressFile;
    BOOLEAN NotAssociated = FALSE;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint1 ("NbfDestroyAssociation:  Entered for connection %lx.\n",
                    TransportConnection);
    }

    try {

        ACQUIRE_C_SPIN_LOCK (&TransportConnection->SpinLock, &oldirql2);
        if ((TransportConnection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) == 0) {

#if DBG
            if (!(IsListEmpty(&TransportConnection->AddressList)) ||
                !(IsListEmpty(&TransportConnection->AddressFileList))) {
                DbgPrint ("NBF: C %lx, AF %lx, freed while still queued\n",
                    TransportConnection, TransportConnection->AddressFile);
                DbgBreakPoint();
            }
#endif
            RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql2);
            NotAssociated = TRUE;
        } else {
            TransportConnection->Flags2 &= ~CONNECTION_FLAGS2_ASSOCIATED;
            RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql2);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("NBF: Got exception 1 in NbfDestroyAssociation\n");
        DbgBreakPoint();

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql2);
    }

    if (NotAssociated) {
        return STATUS_SUCCESS;
    }

    addressFile = TransportConnection->AddressFile;

    address = addressFile->Address;

    //
    // Delink this connection from its associated address connection
    // database.  To do this we must spin lock on the address object as
    // well as on the connection,
    //

    ACQUIRE_SPIN_LOCK (&address->SpinLock, &oldirql);

    try {

        ACQUIRE_C_SPIN_LOCK (&TransportConnection->SpinLock, &oldirql2);
        RemoveEntryList (&TransportConnection->AddressFileList);
        RemoveEntryList (&TransportConnection->AddressList);

        InitializeListHead (&TransportConnection->AddressList);
        InitializeListHead (&TransportConnection->AddressFileList);

        //
        // remove the association between the address and the connection.
        //

        TransportConnection->AddressFile = NULL;

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql2);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("NBF: Got exception 2 in NbfDestroyAssociation\n");
        DbgBreakPoint();

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql2);
    }

    RELEASE_SPIN_LOCK (&address->SpinLock, oldirql);

    //
    // and remove a reference to the address
    //

    NbfDereferenceAddress ("Destroy association", address, AREF_CONNECTION);


    return STATUS_SUCCESS;

} /* NbfDestroyAssociation */


NTSTATUS
NbfIndicateDisconnect(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine indicates a remote disconnection on this connection if it
    is necessary to do so. No other action is taken here.

    This routine is only called by NbfDereferenceConnection.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same connection object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    TransportConnection - Pointer to a transport connection structure to
        be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_ADDRESS_FILE addressFile;
    PDEVICE_CONTEXT DeviceContext;
    ULONG DisconnectReason;
    PIRP DisconnectIrp;
    KIRQL oldirql;
    ULONG Lflags2;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint1 ("NbfIndicateDisconnect:  Entered for connection %lx.\n",
                    TransportConnection);
    }

    try {

        ACQUIRE_C_SPIN_LOCK (&TransportConnection->SpinLock, &oldirql);

        if (((TransportConnection->Flags2 & CONNECTION_FLAGS2_REQ_COMPLETED) != 0)) {

            ASSERT (TransportConnection->Lsn == 0);

            //
            // Turn off all but the still-relevant bits in the flags.
            //

            Lflags2 = TransportConnection->Flags2;
            TransportConnection->Flags2 &=
                (CONNECTION_FLAGS2_ASSOCIATED |
                 CONNECTION_FLAGS2_DISASSOCIATED |
                 CONNECTION_FLAGS2_CLOSING);
            TransportConnection->Flags2 |= CONNECTION_FLAGS2_STOPPING;

            //
            // Clean up other stuff -- basically everything gets
            // done here except for the flags and the status, since
            // they are used to block other requests. When the connection
            // is given back to us (in Accept, Connect, or Listen)
            // they are cleared.
            //

            TransportConnection->NetbiosHeader.TransmitCorrelator = 0;
            TransportConnection->Retries = 0;                        // no retries yet.
            TransportConnection->MessageBytesReceived = 0;           // no data yet
            TransportConnection->MessageBytesAcked = 0;
            TransportConnection->MessageInitAccepted = 0;
            TransportConnection->ReceiveBytesUnaccepted = 0;
            TransportConnection->ConsecutiveSends = 0;
            TransportConnection->ConsecutiveReceives = 0;
            TransportConnection->SendState = CONNECTION_SENDSTATE_IDLE;

            TransportConnection->TransmittedTsdus = 0;
            TransportConnection->ReceivedTsdus = 0;

            TransportConnection->CurrentReceiveIrp = (PIRP)NULL;

            DisconnectIrp = TransportConnection->DisconnectIrp;
            TransportConnection->DisconnectIrp = (PIRP)NULL;

            if ((TransportConnection->Flags2 & CONNECTION_FLAGS2_ASSOCIATED) != 0) {
                addressFile = TransportConnection->AddressFile;
            } else {
                addressFile = NULL;
            }

            RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);


            DeviceContext = TransportConnection->Provider;


            //
            // If this connection was stopped by a call to TdiDisconnect,
            // we have to complete that. We save the Irp so we can return
            // the connection to the pool before we complete the request.
            //


            if (DisconnectIrp != (PIRP)NULL ||
                (Lflags2 & CONNECTION_FLAGS2_LDISC) != 0) {

                if (DisconnectIrp != (PIRP)NULL) {
                    IF_NBFDBG (NBF_DEBUG_SETUP) {
                        NbfPrint1("IndicateDisconnect %lx, complete IRP\n", TransportConnection);
                    }

                    //
                    // Now complete the IRP if needed. This will be non-null
                    // only if TdiDisconnect was called, and we have not
                    // yet completed it.
                    //

                    DisconnectIrp->IoStatus.Information = 0;
                    DisconnectIrp->IoStatus.Status = STATUS_SUCCESS;
                    IoCompleteRequest (DisconnectIrp, IO_NETWORK_INCREMENT);
                }

            } else if ((TransportConnection->Status != STATUS_LOCAL_DISCONNECT) &&
                    (addressFile != NULL) &&
                    (addressFile->RegisteredDisconnectHandler == TRUE)) {

                //
                // This was a remotely spawned disconnect, so indicate that
                // to our client. Note that in the comparison above we
                // check the status first, since if it is LOCAL_DISCONNECT
                // addressFile may be NULL (This is sort of a hack
                // for PDK2, we should really indicate the disconnect inside
                // NbfStopConnection, where we know addressFile is valid).
                //

                IF_NBFDBG (NBF_DEBUG_SETUP) {
                    NbfPrint1("IndicateDisconnect %lx, indicate\n", TransportConnection);
                }

                //
                // if the disconnection was remotely spawned, then indicate
                // disconnect. In the case that a disconnect was issued at
                // the same time as the connection went down remotely, we
                // won't do this because DisconnectIrp will be non-NULL.
                //

                IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                    NbfPrint1 ("NbfIndicateDisconnect calling DisconnectHandler, refcnt=%ld\n",
                                TransportConnection->ReferenceCount);
                }

                //
                // Invoke the user's disconnection event handler, if any. We do this here
                // so that any outstanding sends will complete before we tear down the
                // connection.
                //

                DisconnectReason = 0;
                if (TransportConnection->Flags2 & CONNECTION_FLAGS2_ABORT) {
                    DisconnectReason |= TDI_DISCONNECT_ABORT;
                }
                if (TransportConnection->Flags2 & CONNECTION_FLAGS2_DESTROY) {
                    DisconnectReason |= TDI_DISCONNECT_RELEASE;
                }

                (*addressFile->DisconnectHandler)(
                        addressFile->DisconnectHandlerContext,
                        TransportConnection->Context,
                        0,
                        NULL,
                        0,
                        NULL,
                        TDI_DISCONNECT_ABORT);

#if MAGIC
                if (NbfEnableMagic) {
                    extern VOID NbfSendMagicBullet (PDEVICE_CONTEXT, PTP_LINK);
                    NbfSendMagicBullet (DeviceContext, NULL);
                }
#endif
            }

        } else {

            //
            // The client does not yet think that this connection
            // is up...generally this happens due to request count
            // fluctuation during connection setup.
            //

            RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);

        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("NBF: Got exception in NbfIndicateDisconnect\n");
        DbgBreakPoint();

        RELEASE_C_SPIN_LOCK (&TransportConnection->SpinLock, oldirql);
    }


    return STATUS_SUCCESS;

} /* NbfIndicateDisconnect */


NTSTATUS
NbfDestroyConnection(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine destroys a transport connection and removes all references
    made by it to other objects in the transport.  The connection structure
    is returned to our lookaside list.  It is assumed that the caller
    has removed all IRPs from the connections's queues first.

    This routine is only called by NbfDereferenceConnection.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same connection object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    TransportConnection - Pointer to a transport connection structure to
        be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql;
    PDEVICE_CONTEXT DeviceContext;
    PIRP CloseIrp;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint1 ("NbfDestroyConnection:  Entered for connection %lx.\n",
                    TransportConnection);
    }

#if DBG
    if (TransportConnection->Destroyed) {
        NbfPrint1 ("attempt to destroy already-destroyed connection 0x%lx\n", TransportConnection);
        DbgBreakPoint ();
    }
    if (!(TransportConnection->Flags2 & CONNECTION_FLAGS2_STOPPING)) {
        NbfPrint1 ("attempt to destroy unstopped connection 0x%lx\n", TransportConnection);
        DbgBreakPoint ();
    }
    TransportConnection->Destroyed = TRUE;
    ACQUIRE_SPIN_LOCK (&NbfGlobalInterlock, &oldirql);
    RemoveEntryList (&TransportConnection->GlobalLinkage);
    RELEASE_SPIN_LOCK (&NbfGlobalInterlock, oldirql);
#endif

    DeviceContext = TransportConnection->Provider;

    //
    // Destroy any association that this connection has.
    //

    NbfDestroyAssociation (TransportConnection);

    //
    // Clear out any associated nasties hanging around the connection. Note
    // that the current flags are set to STOPPING; this way anyone that may
    // maliciously try to use the connection after it's dead and gone will
    // just get ignored.
    //

    ASSERT (TransportConnection->Lsn == 0);

    TransportConnection->Flags = 0;
    TransportConnection->Flags2 = CONNECTION_FLAGS2_CLOSING;
    TransportConnection->NetbiosHeader.TransmitCorrelator = 0;
    TransportConnection->Retries = 0;                        // no retries yet.
    TransportConnection->MessageBytesReceived = 0;           // no data yet
    TransportConnection->MessageBytesAcked = 0;
    TransportConnection->MessageInitAccepted = 0;
    TransportConnection->ReceiveBytesUnaccepted = 0;


    //
    // Now complete the close IRP. This will be set to non-null
    // when CloseConnection was called.
    //

    CloseIrp = TransportConnection->CloseIrp;

    if (CloseIrp != (PIRP)NULL) {

        TransportConnection->CloseIrp = (PIRP)NULL;
        CloseIrp->IoStatus.Information = 0;
        CloseIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest (CloseIrp, IO_NETWORK_INCREMENT);

    } else {

#if DBG
        NbfPrint1("Connection %x destroyed, no CloseIrp!!\n", TransportConnection);
#endif

    }

    //
    // Return the connection to the provider's pool.
    //

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    DeviceContext->ConnectionTotal += DeviceContext->ConnectionInUse;
    ++DeviceContext->ConnectionSamples;
    --DeviceContext->ConnectionInUse;

    if ((DeviceContext->ConnectionAllocated - DeviceContext->ConnectionInUse) >
            DeviceContext->ConnectionInitAllocated) {
        NbfDeallocateConnection (DeviceContext, TransportConnection);
        IF_NBFDBG (NBF_DEBUG_DYNAMIC) {
            NbfPrint1 ("NBF: Deallocated connection at %lx\n", TransportConnection);
        }
    } else {
        InsertTailList (&DeviceContext->ConnectionPool, &TransportConnection->LinkList);
    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

    NbfDereferenceDeviceContext ("Destroy Connection", DeviceContext, DCREF_CONNECTION);

    return STATUS_SUCCESS;

} /* NbfDestroyConnection */


#if DBG
VOID
NbfRefConnection(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine increments the reference count on a transport connection.

Arguments:

    TransportConnection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint2 ("NbfReferenceConnection: entered for connection %lx, "
                    "current level=%ld.\n",
                    TransportConnection,
                    TransportConnection->ReferenceCount);
    }

#if DBG
    StoreConnectionHistory( TransportConnection, TRUE );
#endif

    result = InterlockedIncrement (&TransportConnection->ReferenceCount);

    if (result == 0) {

        //
        // The first increment causes us to increment the
        // "ref count is not zero" special ref.
        //

        ExInterlockedAddUlong(
            (PULONG)(&TransportConnection->SpecialRefCount),
            1,
            TransportConnection->ProviderInterlock);

#if DBG
        ++TransportConnection->RefTypes[CREF_SPECIAL_TEMP];
#endif

    }

    ASSERT (result >= 0);

} /* NbfRefConnection */
#endif


VOID
NbfDerefConnection(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine dereferences a transport connection by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    NbfDestroyConnection to remove it from the system.

Arguments:

    TransportConnection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    LONG result;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint2 ("NbfDereferenceConnection: entered for connection %lx, "
                    "current level=%ld.\n",
                    TransportConnection,
                    TransportConnection->ReferenceCount);
    }

#if DBG
    StoreConnectionHistory( TransportConnection, FALSE );
#endif

    result = InterlockedDecrement (&TransportConnection->ReferenceCount);

    //
    // If all the normal references to this connection are gone, then
    // we can remove the special reference that stood for
    // "the regular ref count is non-zero".
    //

    if (result < 0) {

        //
        // If the refcount is -1, then we need to disconnect from
        // the link and indicate disconnect. However, we need to
        // do this before we actually do the special deref, since
        // otherwise the connection might go away while we
        // are doing that.
        //
        // Note that both these routines are protected in that if they
        // are called twice, the second call will have no effect.
        //


        //
        // If both the connection and its link are active, then they have
        // mutual references to each other. We remove the link's
        // reference to the connection in NbfStopConnection, now
        // the reference count has fallen enough that we know it
        // is okay to remove the connection's reference to the
        // link.
        //

        if (NbfDisconnectFromLink (TransportConnection, TRUE)) {

            //
            // if the reference count goes to one, we can safely indicate the
            // user about disconnect states. That reference should
            // be for the connection's creation.
            //

            NbfIndicateDisconnect (TransportConnection);

        }

        //
        // Now it is OK to let the connection go away.
        //

        NbfDereferenceConnectionSpecial ("Regular ref gone", TransportConnection, CREF_SPECIAL_TEMP);

    }

} /* NbfDerefConnection */


VOID
NbfDerefConnectionSpecial(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routines completes the dereferencing of a connection.
    It may be called any time, but it does not do its work until
    the regular reference count is also 0.

Arguments:

    TransportConnection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    KIRQL oldirql;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint3 ("NbfDereferenceConnectionSpecial: entered for connection %lx, "
                    "current level=%ld (%ld).\n",
                    TransportConnection,
                    TransportConnection->ReferenceCount,
                    TransportConnection->SpecialRefCount);
    }

#if DBG
    StoreConnectionHistory( TransportConnection, FALSE );
#endif


    ACQUIRE_SPIN_LOCK (TransportConnection->ProviderInterlock, &oldirql);

    --TransportConnection->SpecialRefCount;

    if ((TransportConnection->SpecialRefCount == 0) &&
        (TransportConnection->ReferenceCount == -1)) {

        //
        // If we have deleted all references to this connection, then we can
        // destroy the object.  It is okay to have already released the spin
        // lock at this point because there is no possible way that another
        // stream of execution has access to the connection any longer.
        //

#if DBG
        {
            BOOLEAN TimerCancelled;
            TimerCancelled = KeCancelTimer (&TransportConnection->Timer);
            // ASSERT (TimerCancelled);
        }
#endif

        RELEASE_SPIN_LOCK (TransportConnection->ProviderInterlock, oldirql);

        NbfDestroyConnection (TransportConnection);

    } else {

        RELEASE_SPIN_LOCK (TransportConnection->ProviderInterlock, oldirql);

    }

} /* NbfDerefConnectionSpecial */


VOID
NbfClearConnectionLsn(
    IN PTP_CONNECTION TransportConnection
    )

/*++

Routine Description:

    This routine clears the LSN field in a connection. To do this is
    acquires the device context lock, and modifies the table value
    for that LSN depending on the type of the connection.

    NOTE: This routine is called with the connection spinlock held,
        or in a state where nobody else will be accessing the
        connection.

Arguments:

    TransportConnection - Pointer to a transport connection object.

Return Value:

    none.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    KIRQL oldirql;

    DeviceContext = TransportConnection->Provider;

    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    if (TransportConnection->Lsn != 0) {

        if (TransportConnection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) {

            //
            // It was to a group address; the count should be
            // LSN_TABLE_MAX.
            //

            ASSERT(DeviceContext->LsnTable[TransportConnection->Lsn] == LSN_TABLE_MAX);

            DeviceContext->LsnTable[TransportConnection->Lsn] = 0;

            TransportConnection->Flags2 &= ~CONNECTION_FLAGS2_GROUP_LSN;

        } else {

            ASSERT(DeviceContext->LsnTable[TransportConnection->Lsn] > 0);

            --(DeviceContext->LsnTable[TransportConnection->Lsn]);

        }

        TransportConnection->Lsn = 0;

    }

    RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

}


PTP_CONNECTION
NbfLookupConnectionById(
    IN PTP_ADDRESS Address,
    IN USHORT ConnectionId
    )

/*++

Routine Description:

    This routine accepts a connection identifier and an address and
    returns a pointer to the connection object, TP_CONNECTION.  If the
    connection identifier is not found on the address, then NULL is returned.
    This routine automatically increments the reference count of the
    TP_CONNECTION structure if it is found.  It is assumed that the
    TP_ADDRESS structure is already held with a reference count.

Arguments:

    Address - Pointer to a transport address object.

    ConnectionId - Identifier of the connection for this address.

Return Value:

    A pointer to the connection we found

--*/

{
    KIRQL oldirql, oldirql1;
    PLIST_ENTRY p;
    PTP_CONNECTION Connection;
    BOOLEAN Found = FALSE;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint2 ("NbfLookupConnectionById: entered, Address: %lx ID: %lx\n",
            Address, ConnectionId);
    }

    //
    // Currently, this implementation is inefficient, but brute force so
    // that a system can get up and running.  Later, a cache of the mappings
    // of popular connection id's and pointers to their TP_CONNECTION structures
    // will be searched first.
    //

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    for (p=Address->ConnectionDatabase.Flink;
         p != &Address->ConnectionDatabase;
         p=p->Flink) {


        Connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

        try {

            ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql1);

            if (((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) &&
                (Connection->ConnectionId == ConnectionId)) {

                // This reference is removed by the calling function
                NbfReferenceConnection ("Lookup up for request", Connection, CREF_BY_ID);
                Found = TRUE;
            }

            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            DbgPrint ("NBF: Got exception in NbfLookupConnectionById\n");
            DbgBreakPoint();

            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
        }

        if (Found) {
            RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
            return Connection;
        }


    }

    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    return NULL;

} /* NbfLookupConnectionById */


PTP_CONNECTION
NbfLookupConnectionByContext(
    IN PTP_ADDRESS Address,
    IN CONNECTION_CONTEXT ConnectionContext
    )

/*++

Routine Description:

    This routine accepts a connection identifier and an address and
    returns a pointer to the connection object, TP_CONNECTION.  If the
    connection identifier is not found on the address, then NULL is returned.
    This routine automatically increments the reference count of the
    TP_CONNECTION structure if it is found.  It is assumed that the
    TP_ADDRESS structure is already held with a reference count.

    Should the ConnectionDatabase go in the address file?

Arguments:

    Address - Pointer to a transport address object.

    ConnectionContext - Connection Context for this address.

Return Value:

    A pointer to the connection we found

--*/

{
    KIRQL oldirql, oldirql1;
    PLIST_ENTRY p;
    BOOLEAN Found = FALSE;
    PTP_CONNECTION Connection;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint2 ("NbfLookupConnectionByContext: entered, Address: %lx Context: %lx\n",
            Address, ConnectionContext);
    }

    //
    // Currently, this implementation is inefficient, but brute force so
    // that a system can get up and running.  Later, a cache of the mappings
    // of popular connection id's and pointers to their TP_CONNECTION structures
    // will be searched first.
    //

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    for (p=Address->ConnectionDatabase.Flink;
         p != &Address->ConnectionDatabase;
         p=p->Flink) {

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

        try {

            ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql1);

            if (Connection->Context == ConnectionContext) {
                // This reference is removed by the calling function
                NbfReferenceConnection ("Lookup up for request", Connection, CREF_LISTENING);
                Found = TRUE;
            }

            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            DbgPrint ("NBF: Got exception in NbfLookupConnectionById\n");
            DbgBreakPoint();

            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
        }

        if (Found) {
            RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
            return Connection;
        }


    }

    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    return NULL;

} /* NbfLookupConnectionByContext */


PTP_CONNECTION
NbfLookupListeningConnection(
    IN PTP_ADDRESS Address,
    IN PUCHAR RemoteName
    )

/*++

Routine Description:

    This routine scans the connection database on an address to find
    a TP_CONNECTION object which has LSN=0 and CONNECTION_FLAGS_WAIT_NQ
    flag set.   It returns a pointer to the found connection object (and
    simultaneously resets the flag) or NULL if it could not be found.
    The reference count is also incremented atomically on the connection.

    The list is scanned for listens posted to this specific remote
    name, or to those with no remote name specified.

Arguments:

    Address - Pointer to a transport address object.

    RemoteName - The name of the remote.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    KIRQL oldirql, oldirql1;
    PTP_CONNECTION Connection;
    PLIST_ENTRY p, q;
    PTP_REQUEST ListenRequest;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint0 ("NbfLookupListeningConnection: Entered.\n");
    }

    //
    // Currently, this implementation is inefficient, but brute force so
    // that a system can get up and running.  Later, a cache of the mappings
    // of popular connection id's and pointers to their TP_CONNECTION structures
    // will be searched first.
    //

    ACQUIRE_SPIN_LOCK (&Address->SpinLock, &oldirql);

    for (p=Address->ConnectionDatabase.Flink;
         p != &Address->ConnectionDatabase;
         p=p->Flink) {

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, AddressList);

        ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql1);

        if ((Connection->Lsn == 0) &&
            (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NQ)) {

            q = Connection->InProgressRequest.Flink;
            if (q != &Connection->InProgressRequest) {
                ListenRequest = CONTAINING_RECORD (q, TP_REQUEST, Linkage);
                if ((ListenRequest->Buffer2 != NULL) &&
                    (!RtlEqualMemory(
                         ListenRequest->Buffer2,
                         RemoteName,
                         NETBIOS_NAME_LENGTH))) {

                    RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
                    continue;
                }
            } else {

                RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
                continue;
            }
            // This reference is removed by the calling function
            NbfReferenceConnection ("Found Listening", Connection, CREF_LISTENING);
            Connection->Flags2 &= ~CONNECTION_FLAGS2_WAIT_NQ;
            RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
            RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);
            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint1 ("NbfLookupListeningConnection: Found Connection %lx\n",Connection);
            }
            return Connection;
        }

        RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql1);
    }

    RELEASE_SPIN_LOCK (&Address->SpinLock, oldirql);

    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
        NbfPrint0 ("NbfLookupListeningConnection: Found No Connection!\n");
    }

    return NULL;

} /* NbfLookupListeningConnection */


VOID
NbfStopConnection(
    IN PTP_CONNECTION Connection,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is called to terminate all activity on a connection and
    destroy the object.  This is done in a graceful manner; i.e., all
    outstanding requests are terminated by cancelling them, etc.  It is
    assumed that the caller has a reference to this connection object,
    but this routine will do the dereference for the one issued at creation
    time.

    Orderly release is a function of this routine, but it is not a provided
    service of this transport provider, so there is no code to do it here.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Status - The status that caused us to stop the connection. This
        will determine what status pending requests are aborted with,
        and also how we proceed during the stop (whether to send a
        session end, and whether to indicate disconnect).

Return Value:

    none.

--*/

{
    KIRQL cancelirql;
    PLIST_ENTRY p;
    PIRP Irp;
    PTP_REQUEST Request;
    BOOLEAN TimerWasCleared;
    ULONG DisconnectReason;
    PULONG StopCounter;
    PDEVICE_CONTEXT DeviceContext;

    IF_NBFDBG (NBF_DEBUG_TEARDOWN | NBF_DEBUG_PNP) {
        NbfPrint3 ("NbfStopConnection: Entered for connection %lx LSN %x RSN %x.\n",
                    Connection, Connection->Lsn, Connection->Rsn);
    }

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceContext = Connection->Provider;

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if (!(Connection->Flags2 & CONNECTION_FLAGS2_STOPPING)) {

        //
        // We are stopping the connection, record statistics
        // about it.
        //

        if (Connection->Flags & CONNECTION_FLAGS_READY) {
            DECREMENT_COUNTER (DeviceContext, OpenConnections);
        }

        Connection->Flags2 |= CONNECTION_FLAGS2_STOPPING;
        Connection->Flags2 &= ~CONNECTION_FLAGS2_REMOTE_VALID;
        Connection->Status = Status;

        if (Connection->Link != NULL) {

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Connection->Flags &= ~(CONNECTION_FLAGS_READY|
                                   CONNECTION_FLAGS_WAIT_SI|
                                   CONNECTION_FLAGS_WAIT_SC);        // no longer open for business
            Connection->SendState = CONNECTION_SENDSTATE_IDLE;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        //
        // If this flag was on, turn it off.
        //
        Connection->Flags &= ~CONNECTION_FLAGS_W_RESYNCH;

        //
        // Stop the timer if it was running.
        //

        TimerWasCleared = KeCancelTimer (&Connection->Timer);
        IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
            NbfPrint2 ("NbfStopConnection:  Timer for connection %lx "
                        "%s canceled.\n", Connection,
                        TimerWasCleared ? "was" : "was NOT" );
            }


        switch (Status) {

        case STATUS_LOCAL_DISCONNECT:
            StopCounter = &DeviceContext->Statistics.LocalDisconnects;
            break;
        case STATUS_REMOTE_DISCONNECT:
            StopCounter = &DeviceContext->Statistics.RemoteDisconnects;
            break;
        case STATUS_LINK_FAILED:
            StopCounter = &DeviceContext->Statistics.LinkFailures;
            break;
        case STATUS_IO_TIMEOUT:
            StopCounter = &DeviceContext->Statistics.SessionTimeouts;
            break;
        case STATUS_CANCELLED:
            StopCounter = &DeviceContext->Statistics.CancelledConnections;
            break;
        case STATUS_REMOTE_RESOURCES:
            StopCounter = &DeviceContext->Statistics.RemoteResourceFailures;
            break;
        case STATUS_INSUFFICIENT_RESOURCES:
            StopCounter = &DeviceContext->Statistics.LocalResourceFailures;
            break;
        case STATUS_BAD_NETWORK_PATH:
            StopCounter = &DeviceContext->Statistics.NotFoundFailures;
            break;
        case STATUS_REMOTE_NOT_LISTENING:
            StopCounter = &DeviceContext->Statistics.NoListenFailures;
            break;

        default:
            StopCounter = NULL;
            break;

        }

        if (StopCounter != NULL) {
            (*StopCounter)++;
        }

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        //
        // Run down all TdiConnect/TdiDisconnect/TdiListen requests.
        //

        IoAcquireCancelSpinLock(&cancelirql);
        ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        while (TRUE) {
            p = RemoveHeadList (&Connection->InProgressRequest);
            if (p == &Connection->InProgressRequest) {
                break;
            }
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
            Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
            IoSetCancelRoutine(Request->IoRequestPacket, NULL);
            IoReleaseCancelSpinLock(cancelirql);
#if DBG
            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                LARGE_INTEGER MilliSeconds, Time;
                ULONG junk;
                KeQuerySystemTime (&Time);
                MilliSeconds.LowPart = Time.LowPart;
                MilliSeconds.HighPart = Time.HighPart;
                MilliSeconds.QuadPart = MilliSeconds.QuadPart -
                                                            (Request->Time).QuadPart;
                MilliSeconds = RtlExtendedLargeIntegerDivide (MilliSeconds, 10000L, &junk);
                NbfPrint3 ("NbfStopConnection: Canceling pending CONNECT, Irp: %lx Time Pending: %ld%ld msec\n",
                        Request->IoRequestPacket, MilliSeconds.HighPart, MilliSeconds.LowPart);
            }
#endif

            NbfCompleteRequest (Request, Connection->Status, 0);

            IoAcquireCancelSpinLock(&cancelirql);
            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
        }


        if (Connection->Link == NULL) {

            //
            // We are stopping early on.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
            IoReleaseCancelSpinLock (cancelirql);

            if (TimerWasCleared) {
                NbfDereferenceConnection ("Stopping timer", Connection, CREF_TIMER);   // account for timer reference.
            }


            ASSERT (Connection->SendState == CONNECTION_SENDSTATE_IDLE);
            ASSERT (!Connection->OnPacketWaitQueue);
            ASSERT (!Connection->OnDataAckQueue);
            ASSERT (!(Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK));
            ASSERT (IsListEmpty(&Connection->SendQueue));
            ASSERT (IsListEmpty(&Connection->ReceiveQueue));

            return;

        }

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
        IoReleaseCancelSpinLock (cancelirql);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // If this connection is waiting to packetize,
        // remove it from the device context queue it is on.
        //
        // NOTE: If the connection is currently in the
        // packetize queue, it will eventually go to get
        // packetized and at that point it will get
        // removed.
        //

        if (Connection->OnPacketWaitQueue) {

            IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
                NbfPrint1("Stop waiting connection, flags %lx\n",
                            Connection->Flags);
            }

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
            Connection->OnPacketWaitQueue = FALSE;
            ASSERT ((Connection->Flags & CONNECTION_FLAGS_SEND_SE) == 0);
            Connection->Flags &= ~(CONNECTION_FLAGS_STARVED|CONNECTION_FLAGS_W_PACKETIZE);
            RemoveEntryList (&Connection->PacketWaitLinkage);
            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
        }


        //
        // If we are on the data ack queue, then take ourselves off.
        //

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        if (Connection->OnDataAckQueue) {
            RemoveEntryList (&Connection->DataAckLinkage);
            Connection->OnDataAckQueue = FALSE;
            DeviceContext->DataAckQueueChanged = TRUE;
        }
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // If this connection is waiting to send a piggyback ack,
        // remove it from the device context queue for that, and
        // send a data ack (which will get there before the
        // SessionEnd).
        //

        if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {

#if DBG
            {
                extern ULONG NbfDebugPiggybackAcks;
                if (NbfDebugPiggybackAcks) {
                    NbfPrint1("Stop waiting connection, deferred flags %lx\n",
                                Connection->DeferredFlags);
                }
            }
#endif

            Connection->DeferredFlags &=
                ~(CONNECTION_FLAGS_DEFERRED_ACK | CONNECTION_FLAGS_DEFERRED_NOT_Q);

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfSendDataAck (Connection);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        if (TimerWasCleared) {
            NbfDereferenceConnection ("Stopping timer", Connection, CREF_TIMER);   // account for timer reference.
        }


        IoAcquireCancelSpinLock(&cancelirql);
        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);


        //
        // Run down all TdiSend requests on this connection.
        //

        while (TRUE) {
            p = RemoveHeadList (&Connection->SendQueue);
            if (p == &Connection->SendQueue) {
                break;
            }
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, NULL);
            IoReleaseCancelSpinLock(cancelirql);
#if DBG
            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint1("NbfStopConnection: Canceling pending SEND, Irp: %lx\n",
                        Irp);
            }
#endif
            NbfCompleteSendIrp (Irp, Connection->Status, 0);
            IoAcquireCancelSpinLock(&cancelirql);
            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            ++Connection->TransmissionErrors;
        }

        //
        // NOTE: We hold the connection spinlock AND the
        // cancel spinlock here.
        //

        Connection->Flags &= ~CONNECTION_FLAGS_ACTIVE_RECEIVE;

        //
        // Run down all TdiReceive requests on this connection.
        //

        while (TRUE) {
            p = RemoveHeadList (&Connection->ReceiveQueue);
            if (p == &Connection->ReceiveQueue) {
                break;
            }
            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, NULL);
#if DBG
            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint1 ("NbfStopConnection: Canceling pending RECEIVE, Irp: %lx\n",
                        Irp);
            }
#endif

            //
            // It is OK to call this with the locks held.
            //
            NbfCompleteReceiveIrp (Irp, Connection->Status, 0);

            ++Connection->ReceiveErrors;
        }


        //
        // NOTE: We hold the connection spinlock AND the
        // cancel spinlock here.
        //

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        IoReleaseCancelSpinLock(cancelirql);

        //
        // If we aren't DESTROYing the link, then send a SESSION_END frame
        // to the remote side.  When the SESSION_END frame is acknowleged,
        // we will decrement the connection's reference count by one, removing
        // its creation reference.  This will cause the connection object to
        // be disposed of, and will begin running down the link.
        // DGB: add logic to avoid blowing away link if one doesn't exist yet.
        //

        ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        DisconnectReason = 0;
        if (Connection->Flags2 & CONNECTION_FLAGS2_ABORT) {
            DisconnectReason |= TDI_DISCONNECT_ABORT;
        }
        if (Connection->Flags2 & CONNECTION_FLAGS2_DESTROY) {
            DisconnectReason |= TDI_DISCONNECT_RELEASE;
        }

        if (Connection->Link != NULL) {

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            if ((Status == STATUS_LOCAL_DISCONNECT) ||
                (Status == STATUS_CANCELLED)) {

                //
                // (note that a connection should only get stopped
                // with STATUS_INSUFFICIENT_RESOURCES if it is not
                // yet connected to the remote).
                //

                //
                // If this is done, when this packet is destroyed
                // it will dereference the connection for CREF_LINK.
                //

                NbfSendSessionEnd (
                    Connection,
                    (BOOLEAN)((DisconnectReason & TDI_DISCONNECT_ABORT) != 0));

            } else {

                //
                // Not attached to the link anymore; this dereference
                // will allow our reference to fall below 3, which
                // will cause NbfDisconnectFromLink to be called.
                //

                NbfDereferenceConnection("Stopped", Connection, CREF_LINK);

            }

        } else {

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        }


        //
        // Note that we've blocked all new requests being queued during the
        // time we have been in this teardown code; NbfDestroyConnection also
        // sets the connection flags to STOPPING when returning the
        // connection to the queue. This avoids lingerers using non-existent
        // connections.
        //

    } else {

        //
        // The connection was already stopping; it may have a
        // SESSION_END pending in which case we should kill
        // it.
        //

        if ((Status != STATUS_LOCAL_DISCONNECT) &&
            (Status != STATUS_CANCELLED)) {

            if (Connection->Flags & CONNECTION_FLAGS_SEND_SE) {

                ASSERT (Connection->Link != NULL);

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                Connection->Flags &= ~CONNECTION_FLAGS_SEND_SE;

                if (Connection->OnPacketWaitQueue) {
                    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
#if DBG
                    DbgPrint ("NBF: Removing connection %lx from PacketWait for SESSION_END\n", Connection);
#endif
                    Connection->OnPacketWaitQueue = FALSE;
                    RemoveEntryList (&Connection->PacketWaitLinkage);
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
                }

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                NbfDereferenceConnection("Stopped again", Connection, CREF_LINK);
                return;

            }
        }

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
    }
} /* NbfStopConnection */


VOID
NbfCancelConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a connect
    or a listen. It is simple since there can only be one of these
    active on a connection; we just stop the connection, the IRP
    will get completed as part of normal session teardown.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PIO_STACK_LOCATION IrpSp;
    PTP_CONNECTION Connection;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    BOOLEAN fCanceled = TRUE;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_CONNECT || IrpSp->MinorFunction == TDI_LISTEN));

    Connection = IrpSp->FileObject->FsContext;

    //
    // Since this IRP is still in the cancellable state, we know
    // that the connection is still around (although it may be in
    // the process of being torn down).
    //

    ACQUIRE_C_SPIN_LOCK (&Connection->SpinLock, &oldirql);
    NbfReferenceConnection ("Cancelling Send", Connection, CREF_TEMP);

    p = RemoveHeadList (&Connection->InProgressRequest);
    ASSERT (p != &Connection->InProgressRequest);

    RELEASE_C_SPIN_LOCK (&Connection->SpinLock, oldirql);

    Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
    ASSERT (Request->IoRequestPacket == Irp);
#ifdef RASAUTODIAL
    //
    // If there's an automatic connection in
    // progress, cancel it.
    //
    if (Connection->Flags2 & CONNECTION_FLAGS2_AUTOCONNECTING)
        fCanceled = NbfCancelTdiConnect(NULL, Irp);
#endif // RASAUTODIAL

    if (fCanceled)
        IoSetCancelRoutine(Request->IoRequestPacket, NULL);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (fCanceled) {
        IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
            NbfPrint2("NBF: Cancelled in-progress connect/listen %lx on %lx\n",
                    Request->IoRequestPacket, Connection);
        }

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql);
        NbfCompleteRequest (Request, STATUS_CANCELLED, 0);
        NbfStopConnection (Connection, STATUS_LOCAL_DISCONNECT);   // prevent indication to clients
        KeLowerIrql (oldirql);
    }

    NbfDereferenceConnection ("Cancel done", Connection, CREF_TEMP);

}

#if 0
VOID
NbfWaitConnectionOnLink(
    IN PTP_CONNECTION Connection,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to suspend a connection's activities because
    the specified session-oriented frame could not be sent due to link
    problems.  Routines in FRAMESND.C call this.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Flags - Field containing bitflag set to indicate starved frame to be sent.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint0 ("NbfWaitConnectionOnLink:  Entered.\n");
    }

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if (((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) ||
        (Flags == CONNECTION_FLAGS_SEND_SE)) {

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        Connection->Flags |= Flags;
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    }

    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
} /* NbfWaitConnectionOnLink */
#endif


VOID
NbfStartConnectionTimer(
    IN PTP_CONNECTION Connection,
    IN PKDEFERRED_ROUTINE TimeoutFunction,
    IN ULONG WaitTime
    )

/*++

Routine Description:

    This routine is called to start a timeout on NAME_QUERY/NAME_RECOGNIZED
    activities on a connection.

Arguments:

    TransportConnection - Pointer to a TP_CONNECTION object.

    TimeoutFunction - The function to call when the timer fires.

    WaitTime - a longword containing the low order time to wait.

Return Value:

    none.

--*/

{
    LARGE_INTEGER Timeout;
    BOOLEAN AlreadyInserted;

    IF_NBFDBG (NBF_DEBUG_CONNOBJ) {
        NbfPrint1 ("NbfStartConnectionTimer:  Entered for connection %lx.\n",
                    Connection );
    }

    //
    // Start the timer.  Unlike the link timers, this is simply a kernel-
    // managed object.
    //

    Timeout.LowPart = (ULONG)(-(LONG)WaitTime);
    Timeout.HighPart = -1;

    //
    // Take the lock so we synchronize the cancelling with
    // restarting the timer. This is so two threads won't
    // both fail to cancel and then start the timer at the
    // same time (it messes up the reference count).
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    AlreadyInserted = KeCancelTimer (&Connection->Timer);

    KeInitializeDpc (
        &Connection->Dpc,
        TimeoutFunction,
        (PVOID)Connection);

    KeSetTimer (
     &Connection->Timer,
     Timeout,
     &Connection->Dpc);

    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    //
    // If the timer wasn't already running, reference the connection to
    // account for the new timer.  If the timer was already started,
    // then KeCancelTimer will have returned TRUE.  In this
    // case, the prior call to NbfStartConnectionTimer referenced the
    // connection, so we don't do it again here.
    //

    if ( !AlreadyInserted ) {

        // This reference is removed in ConnectionEstablishmentTimeout,
        // or when the timer is cancelled.

        NbfReferenceConnection ("starting timer", Connection, CREF_TIMER);
    }

} /* NbfStartConnectionTimer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\action.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    action.c

Abstract:

    This module contains support for the TdiAction handler.

Author:

    David Beaver (dbeaver) 2-July-1991

Environment:

    Kernel mode

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


typedef struct _QUERY_INDICATION {
    UCHAR Command;
    USHORT Data2;
    UCHAR DestinationName[16];
    UCHAR SourceName[16];
} QUERY_INDICATION, *PQUERY_INDICATION;

typedef struct _ACTION_QUERY_INDICATION {
    TDI_ACTION_HEADER Header;
    QUERY_INDICATION QueryIndication;
} ACTION_QUERY_INDICATION, *PACTION_QUERY_INDICATION;


typedef struct _DATAGRAM_INDICATION {
    UCHAR DestinationName[16];
    UCHAR SourceName[16];
    USHORT DatagramBufferLength;
    UCHAR DatagramBuffer[1];
} DATAGRAM_INDICATION, *PDATAGRAM_INDICATION;

typedef struct _ACTION_DATAGRAM_INDICATION {
    TDI_ACTION_HEADER Header;
    DATAGRAM_INDICATION DatagramIndication;
} ACTION_DATAGRAM_INDICATION, *PACTION_DATAGRAM_INDICATION;


#define QUERY_INDICATION_CODE 1
#define DATAGRAM_INDICATION_CODE 2



VOID
NbfCancelAction(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
NbfTdiAction(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the TdiAction request for the transport
    provider.

Arguments:

    DeviceContext - The device context for the operation

    Irp - the Irp for the requested operation.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PTDI_ACTION_HEADER ActionHeader;
    LARGE_INTEGER timeout = {0,0};
    PTP_REQUEST tpRequest;
    KIRQL oldirql, cancelirql;
    ULONG BytesRequired;

    //
    // what type of status do we want?
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if ((!Irp->MdlAddress) || 
             (MmGetMdlByteCount(Irp->MdlAddress) < sizeof(TDI_ACTION_HEADER))) {
        return STATUS_INVALID_PARAMETER;
    }

    ActionHeader = (PTDI_ACTION_HEADER)MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);

    if (!ActionHeader) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure we have required number of bytes for this type of request
    //

    switch (ActionHeader->ActionCode) {

        case QUERY_INDICATION_CODE:
            BytesRequired = sizeof(ACTION_QUERY_INDICATION);
            break;

        case DATAGRAM_INDICATION_CODE:
            BytesRequired = sizeof(ACTION_DATAGRAM_INDICATION);
            break;

        default:
            return STATUS_NOT_IMPLEMENTED;
    }

    if (MmGetMdlByteCount(Irp->MdlAddress) < BytesRequired) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Here the request is one of QUERY_INDICATION or DATAGRAM_INDICATION
    //
    
    //
    // These two requests are sent by RAS to "MABF"
    //

    if (!RtlEqualMemory ((PVOID)(&ActionHeader->TransportId), "MABF", 4)) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // They should be sent on the control channel
    //

    if (irpSp->FileObject->FsContext2 != UlongToPtr(NBF_FILE_TYPE_CONTROL)) {
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Create a request to describe this.
    //

    status = NbfCreateRequest (
                 Irp,                           // IRP for this request.
                 DeviceContext,                 // context.
                 REQUEST_FLAGS_DC,              // partial flags.
                 Irp->MdlAddress,
                 MmGetMdlByteCount(Irp->MdlAddress),
                 timeout,
                 &tpRequest);

    if (NT_SUCCESS (status)) {

        NbfReferenceDeviceContext ("Action", DeviceContext, DCREF_REQUEST);
        tpRequest->Owner = DeviceContextType;
        tpRequest->FrameContext = (USHORT)irpSp->FileObject->FsContext;

        IoAcquireCancelSpinLock(&cancelirql);
        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock,&oldirql);

        //
        // Disallow these requests on a stopping device.
        //

        if (DeviceContext->State != DEVICECONTEXT_STATE_OPEN) {

            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock,oldirql);
            IoReleaseCancelSpinLock(cancelirql);
            NbfCompleteRequest (tpRequest, STATUS_DEVICE_NOT_READY, 0);

        } else {

            if (ActionHeader->ActionCode == QUERY_INDICATION_CODE) {

                InsertTailList (
                    &DeviceContext->QueryIndicationQueue,
                    &tpRequest->Linkage);

            } else {

                InsertTailList (
                    &DeviceContext->DatagramIndicationQueue,
                    &tpRequest->Linkage);

            }

            DeviceContext->IndicationQueuesInUse = TRUE;


            //
            // If this IRP has been cancelled, then call the
            // cancel routine.
            //

            if (Irp->Cancel) {
                RELEASE_SPIN_LOCK (&DeviceContext->SpinLock,oldirql);
                Irp->CancelIrql = cancelirql;
                NbfCancelAction((PDEVICE_OBJECT)DeviceContext, Irp);
                return STATUS_PENDING;
            }

            IoSetCancelRoutine(Irp, NbfCancelAction);

            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock,oldirql);
            IoReleaseCancelSpinLock(cancelirql);

        }

        status = STATUS_PENDING;

    }

    return status;

}


VOID
NbfCancelAction(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel an Action.
    What is done to cancel it is specific to each action.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql;
    PIO_STACK_LOCATION IrpSp;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    BOOLEAN Found;
    PTDI_ACTION_HEADER ActionHeader;
    PLIST_ENTRY QueueHead, QueueEnd;

    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)DeviceObject;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_ACTION));

    ActionHeader = (PTDI_ACTION_HEADER)MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);

    if (!ActionHeader) {
        return;
    }

    switch (ActionHeader->ActionCode) {

    case QUERY_INDICATION_CODE:
    case DATAGRAM_INDICATION_CODE:

        //
        // Scan through the appropriate queue, looking for this IRP.
        // If we find it, we just remove it from the queue; there
        // is nothing else involved in cancelling.
        //

        ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

        if (ActionHeader->ActionCode == QUERY_INDICATION_CODE) {
            QueueHead = DeviceContext->QueryIndicationQueue.Flink;
            QueueEnd = &DeviceContext->QueryIndicationQueue;
        } else {
            QueueHead = DeviceContext->DatagramIndicationQueue.Flink;
            QueueEnd = &DeviceContext->DatagramIndicationQueue;
        }

        Found = FALSE;
        for (p = QueueHead; p != QueueEnd; p = p->Flink) {

            Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
            if (Request->IoRequestPacket == Irp) {

                //
                // Found it, remove it from the list here.
                //

                RemoveEntryList (p);

                Found = TRUE;
                break;

            }

        }

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        if (Found) {

            NbfCompleteRequest (Request, STATUS_CANCELLED, 0);

        } else {

#if DBG
            DbgPrint("NBF: Tried to cancel action %lx on %lx, not found\n",
                    Irp, DeviceContext);
#endif
        }

        break;

    default:

        IoReleaseCancelSpinLock (Irp->CancelIrql);
        break;

    }


}


VOID
NbfStopControlChannel(
    IN PDEVICE_CONTEXT DeviceContext,
    IN USHORT ChannelIdentifier
    )

/*++

Routine Description:

    This routine is called when an MJ_CLEANUP IRP is received
    on a control channel. It walks the device context's list of
    pending action requests and cancels those associated with
    this channel (as identified by ChannelIdentifier.

Arguments:

    DeviceContext - Pointer to our device context.

    ChannelIdentifier - The identifier for this open of the control
        channel, which is stored in Request->FrameContext for requests
        made on this channel.

Return Value:

    None

--*/

{

    KIRQL oldirql, cancelirql;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    UINT i;
    BOOLEAN FoundRequest;
    PLIST_ENTRY QueueHead, QueueEnd;


    //
    // Scan both queues, looking for requests. Since the list
    // may change, we scan until we find one, then remove it
    // and complete it. We then start scanning at the beginning
    // again. We continue until we find none on the queue that
    // belong to this control channel.
    //
    // The outer loop only runs twice; the first time it
    // processes QueryIndicationQueue, the second time
    // DatagramIndicationQueue.
    //

    for (i = 0; i < 2; i++) {

        do {

            //
            // Loop until we do not find a request on this
            // pass through the queue.
            //

            FoundRequest = FALSE;

            IoAcquireCancelSpinLock(&cancelirql);
            ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

            if (i == 0) {
                QueueHead = DeviceContext->QueryIndicationQueue.Flink;
                QueueEnd = &DeviceContext->QueryIndicationQueue;
            } else {
                QueueHead = DeviceContext->DatagramIndicationQueue.Flink;
                QueueEnd = &DeviceContext->DatagramIndicationQueue;
            }


            //
            // Scan the appropriate queue for a request on this
            // channel.
            //

            for (p = QueueHead; p != QueueEnd; p = p->Flink) {

                Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
                if (Request->FrameContext == ChannelIdentifier) {

                    //
                    // Found it, remove it from the list here.
                    //

                    IoSetCancelRoutine(Request->IoRequestPacket, NULL);
                    RemoveEntryList (p);

                    FoundRequest = TRUE;
                    break;

                }

            }

            RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
            IoReleaseCancelSpinLock(cancelirql);

            //
            // If we found a request, then complete it and loop
            // back to the top of the while loop to rescan the
            // list. If not, then we will exit the while loop
            // now.
            //

            if (FoundRequest) {

                NbfCompleteRequest (Request, STATUS_CANCELLED, 0);

            }

        } while (FoundRequest);

    }

}


VOID
NbfActionQueryIndication(
     IN PDEVICE_CONTEXT DeviceContext,
     IN PNBF_HDR_CONNECTIONLESS UiFrame
     )

/*++

Routine Description:

    This routine is called after a UI frame of type NAME_QUERY,
    ADD_NAME_QUERY, or ADD_GROUP_NAME_QUERY has been processed.
    It checks if there is a QUERY.INDICATION IRP waiting to
    be completed, and if so completes it.

Arguments:

    DeviceContext - Pointer to our device context.

    UiFrame - Pointer to the incoming frame. The first byte of
        information is the first byte of the NetBIOS connectionless
        header.

Return Value:

    None

--*/

{
    KIRQL oldirql, cancelirql;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    PMDL Mdl;
    PACTION_QUERY_INDICATION ActionHeader;
    PQUERY_INDICATION QueryIndication;


    IoAcquireCancelSpinLock (&cancelirql);
    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    if (!IsListEmpty (&DeviceContext->QueryIndicationQueue)) {

        p = RemoveHeadList (&DeviceContext->QueryIndicationQueue);
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        IoSetCancelRoutine(Request->IoRequestPacket,NULL);
        IoReleaseCancelSpinLock(cancelirql);

        Mdl = Request->Buffer2;
        ActionHeader = (PACTION_QUERY_INDICATION)
                            (MmGetSystemAddressForMdl(Mdl));
        QueryIndication = &ActionHeader->QueryIndication;

        //
        // Copy over data from frame (note that dest and source
        // address are copied with one call).
        //

        QueryIndication->Command = UiFrame->Command;
        RtlCopyMemory ((PUCHAR)(&QueryIndication->Data2), (PUCHAR)(&UiFrame->Data2Low), 2);
        RtlCopyMemory ((PUCHAR)(QueryIndication->DestinationName),
                       (PUCHAR)(UiFrame->DestinationName),
                       2 * NETBIOS_NAME_LENGTH);

        NbfCompleteRequest (Request, STATUS_SUCCESS, sizeof(ACTION_QUERY_INDICATION));

    } else {

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        IoReleaseCancelSpinLock(cancelirql);

    }
}


VOID
NbfActionDatagramIndication(
     IN PDEVICE_CONTEXT DeviceContext,
     IN PNBF_HDR_CONNECTIONLESS UiFrame,
     IN ULONG Length
     )

/*++

Routine Description:

    This routine is called after a datagram frame has been
    received. It checks if there is a DATAGRAM.INDICATION IRP
    waiting to be completed, and if so completes it.

Arguments:

    DeviceContext - Pointer to our device context.

    UiFrame - Pointer to the incoming frame. The first byte of
        information is the first byte of the NetBIOS connectionless
        header.

    Length - The length of the frame starting at UiFrame.

Return Value:

    None

--*/

{
    KIRQL oldirql, cancelirql;
    PTP_REQUEST Request;
    PLIST_ENTRY p;
    PACTION_DATAGRAM_INDICATION ActionHeader;
    PDATAGRAM_INDICATION DatagramIndication;
    ULONG CopyLength;
    PMDL Mdl;
    NTSTATUS Status;


    IoAcquireCancelSpinLock (&cancelirql);
    ACQUIRE_SPIN_LOCK (&DeviceContext->SpinLock, &oldirql);

    if (!IsListEmpty (&DeviceContext->DatagramIndicationQueue)) {

        p = RemoveHeadList (&DeviceContext->DatagramIndicationQueue);
        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);

        Request = CONTAINING_RECORD (p, TP_REQUEST, Linkage);
        IoSetCancelRoutine(Request->IoRequestPacket, NULL);
        IoReleaseCancelSpinLock(cancelirql);

        Mdl = Request->Buffer2;
        ActionHeader = (PACTION_DATAGRAM_INDICATION)
                            (MmGetSystemAddressForMdl(Mdl));
        DatagramIndication = &ActionHeader->DatagramIndication;

        //
        // Copy over data from frame (note that dest and source
        // address are copied with one call).
        //

        RtlCopyMemory ((PUCHAR)(DatagramIndication->DestinationName),
                       (PUCHAR)(UiFrame->DestinationName),
                       2 * NETBIOS_NAME_LENGTH);

        if ((Length-sizeof(NBF_HDR_CONNECTIONLESS)) <=
            (ULONG)DatagramIndication->DatagramBufferLength) {

             CopyLength = Length - sizeof(NBF_HDR_CONNECTIONLESS);
             Status = STATUS_SUCCESS;

        } else {

             CopyLength = DatagramIndication->DatagramBufferLength;
             Status = STATUS_BUFFER_OVERFLOW;

        }


        RtlCopyMemory(
            (PUCHAR)DatagramIndication->DatagramBuffer,
            ((PUCHAR)UiFrame) + sizeof(NBF_HDR_CONNECTIONLESS),
            CopyLength);
        DatagramIndication->DatagramBufferLength = (USHORT)CopyLength;

        NbfCompleteRequest (Request, Status, CopyLength +
            FIELD_OFFSET (ACTION_DATAGRAM_INDICATION, DatagramIndication.DatagramBuffer[0]));

    } else {

        RELEASE_SPIN_LOCK (&DeviceContext->SpinLock, oldirql);
        IoReleaseCancelSpinLock(cancelirql);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbeui\sys\dlc.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    dlc.c

Abstract:

    This module contains code which implements the data link layer for the
    transport provider.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

// Macros


//
// These two functions are used by the loopback indicator.
//

STATIC
VOID
NbfCopyFromPacketToBuffer(
    IN PNDIS_PACKET Packet,
    IN UINT Offset,
    IN UINT BytesToCopy,
    OUT PCHAR Buffer,
    OUT PUINT BytesCopied
    );


VOID
NbfProcessSabme(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header,
    IN PVOID MacHeader,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine processes a received SABME frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

    MacHeader - Pointer to the MAC header of the packet.

    DeviceContext - The device context of this adapter.

Return Value:

    none.

--*/

{
    PUCHAR SourceRouting;
    UINT SourceRoutingLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;

#if DBG
    UCHAR *s;
#endif

    Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessSabme:  Entered.\n");
    }

    //
    // Format must be:  SABME-c/x, on a real link object.
    //

    if (!Command || (Link == NULL)) {
        return;
    }

    //
    // Build response routing information.  We do this on the SABME, even
    // though we already did in on the Name Query, because the client may
    // choose a different route (if there were multiple routes) than we
    // did.
    //

    MacReturnSourceRouting(
        &DeviceContext->MacInfo,
        MacHeader,
        &SourceRouting,
        &SourceRoutingLength);

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    MacConstructHeader (
        &DeviceContext->MacInfo,
        Link->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        0,                                 // PacketLength, filled in later
        ResponseSR,
        SourceRoutingLength,
        (PUINT)&(Link->HeaderLength));

    //
    // We optimize for fourteen-byte headers by putting
    // the correct Dsap/Ssap at the end, so we can fill
    // in new packets as one 16-byte move.
    //

    if (Link->HeaderLength <= 14) {
        Link->Header[Link->HeaderLength] = DSAP_NETBIOS_OVER_LLC;
        Link->Header[Link->HeaderLength+1] = DSAP_NETBIOS_OVER_LLC;
    }

    //
    // Process the SABME.
    //

    Link->LinkBusy = FALSE;             // he's cleared his busy condition.

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // Remote station is initiating this link.  Send UA and wait for
            // his checkpoint before setting READY state.
            //

            // Moving out of ADM, add special reference
            NbfReferenceLinkSpecial("Waiting for Poll", Link, LREF_NOT_ADM);

            Link->State = LINK_STATE_W_POLL;    // wait for RR-c/p.

            // Don't start T1, but prepare for timing the response
            FakeStartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));

            NbfResetLink (Link);
            NbfSendUa (Link, PollFinal);     // releases lock
            IF_NBFDBG (NBF_DEBUG_SETUP) {
                NbfPrint4("ADM SABME on %lx %x-%x-%x\n",
                    Link,
                    Link->HardwareAddress.Address[3],
                    Link->HardwareAddress.Address[4],
                    Link->HardwareAddress.Address[5]);
            }
            StartTi (Link);
#if DBG
            s = "ADM";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and are waiting for a UA.  He's sent a
            // SABME at the same time, so we tried to do it at the same time.
            // The only balanced thing we can do at this time is to respond
            // with UA and duplicate the effort.  To not send anything would
            // be bad because the link would never complete.
            //

            //
            // What about timers here?
            //

            Link->State = LINK_STATE_W_POLL;    // wait for RR-c/p.
            NbfSendUa (Link, PollFinal);    // releases lock
            StartTi (Link);
#if DBG
            s = "CONNECTING";
#endif
            break;

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  Instead, we
            // got a SABME, so this is really a link reset.
            //
            // Unfortunately, if we happen to get two SABMEs
            // and respond to the second one with another UA
            // (when he has sent the RR-c/p and is expecting
            // an RR-r/f), he will send a FRMR. So, we ignore
            // this frame.
            //

            // Link->State = LINK_STATE_W_POLL;    // wait for RR-c/p.
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            StartTi(Link);
#if DBG
            s = "W_POLL";
#endif
            break;

        case LINK_STATE_READY:

            //
            // Link is already balanced.  He's resetting the link.
            //

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy but instead
            // he sent this SABME.  We have to assume he wants to reset the link.
            //

        case LINK_STATE_W_DISC_RSP:

            //
            // We're waiting for a response from our DISC-c/p but instead of
            // a UA-r/f, we got this SABME.  He wants to initiate the link
            // again because a transport connection has been initiated while
            // we were taking the link down.
            //

            Link->State = LINK_STATE_W_POLL;    // wait for RR-c/p.

            // Don't start T1, but prepare for timing the response
            FakeStartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));

            NbfResetLink (Link);      // reset this connection.
            NbfSendUa (Link, PollFinal);  // releases lock.
            StartTi(Link);
#if DBG
            s = "READY/W_FINAL/W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

#if DBG
    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint1 ("   NbfProcessSabme:  Processed, State was %s.\n", s);
    }
#endif

} /* NbfProcessSabme */


VOID
NbfProcessUa(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received UA frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
#if DBG
    UCHAR *s;
#endif

    PollFinal, Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessUa:  Entered.\n");
    }

    //
    // Format must be:  UA-r/x, on a real link object.
    //

    if (Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    Link->LinkBusy = FALSE;             // he's cleared his busy condition.

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // Received an unnumbered acknowlegement while in ADM.  Somehow
            // the remote station is confused, so tell him we're disconnected.
            //

            NbfSendDm (Link, FALSE);  // indicate we're disconnected, release lock
#if DBG
            s = "ADM";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and have just received the UA.
            //

            UpdateBaseT1Timeout (Link);         // got response to poll.

            Link->State = LINK_STATE_W_FINAL;   // wait for RR-r/f.
            Link->SendRetries = (UCHAR)Link->LlcRetries;
            NbfSendRr (Link, TRUE, TRUE);  // send RR-c/p, StartT1, release lock
#if DBG
            s = "CONNECTING";
#endif
            break;

        case LINK_STATE_READY:

            //
            // Link is already balanced.  He's confused; throw it away.
            //

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  Instead, we
            // got a UA, so he is confused.  Throw it away.
            //

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy but instead
            // he sent this UA.  He is confused.  Throw it away.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "READY/W_POLL/W_FINAL";
#endif
            break;

        case LINK_STATE_W_DISC_RSP:

            //
            // We've sent a DISC-c/p and have received the correct response.
            // Disconnect this link.
            //

            Link->State = LINK_STATE_ADM;       // completed disconnection.

            //
            // This is the normal "clean" disconnect path, so we stop
            // all the timers here since we won't call NbfStopLink.
            //

            StopT1 (Link);
            StopT2 (Link);
            StopTi (Link);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            // Moving to ADM, dereference link
            NbfDereferenceLinkSpecial ("Got UA for DISC", Link, LREF_NOT_ADM);           // decrement link's last ref.

#if DBG
            s = "W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

} /* NbfProcessUa */


VOID
NbfProcessDisc(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received DISC frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
#if DBG
    UCHAR *s;
#endif

    Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessDisc:  Entered.\n");
    }

    //
    // Format must be:  DISC-c/x, on a real link object.
    //

    if (!Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    Link->LinkBusy = FALSE;             // he's cleared his busy condition.

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // Received a DISC while in ADM.  Simply report disconnected mode.
            //

#if DBG
            s = "ADM";
#endif
            NbfSendDm (Link, PollFinal);  // indicate we're disconnected, release lock
            break;

        case LINK_STATE_READY:

            //
            // Link is balanced.  Kill the link.
            //

            Link->State = LINK_STATE_ADM;       // we're reset now.
            NbfSendUa (Link, PollFinal);   // Send UA-r/x, release lock
#if DBG
            if (NbfDisconnectDebug) {
                NbfPrint0( "NbfProcessDisc calling NbfStopLink\n" );
            }
#endif
            NbfStopLink (Link);                  // say goodnight, gracie

            // Moving to ADM, remove reference
            NbfDereferenceLinkSpecial("Stopping link", Link, LREF_NOT_ADM);

#if DBG
            s = "READY";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and have just received a DISC.  That means
            // we have crossed a disconnection and reconnection.  Throw away
            // the disconnect.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "CONNECTING";
#endif
            break;

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  Instead, we
            // got a DISC, so he wants to drop the link.
            //

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy but instead
            // he sent DISC, so he wants to drop the link.
            //

        case LINK_STATE_W_DISC_RSP:

            //
            // We've sent a DISC-c/p and have received a DISC from him as well.
            // Disconnect this link.
            //

            Link->State = LINK_STATE_ADM;       // we're reset now.
            NbfSendUa (Link, PollFinal);  // Send UA-r/x, release lock.

            NbfStopLink (Link);

            // moving to ADM, remove reference
            NbfDereferenceLinkSpecial ("Got DISC on W_DIS_RSP", Link, LREF_NOT_ADM);           // remove its "alive" ref.

#if DBG
            s = "W_POLL/W_FINAL/W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

} /* NbfProcessDisc */


VOID
NbfProcessDm(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received DM frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
#if DBG
    UCHAR *s;
#endif

    Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessDm:  Entered.\n");
    }

    //
    // Format must be:  DM-r/x, on a real link object.
    //

    if (Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    Link->LinkBusy = FALSE;             // he's cleared his busy condition.

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // Received a DM while in ADM.  Do nothing.
            //

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and have just received a DM.  That means
            // we have crossed a disconnection and reconnection.  Throw away
            // the disconnect mode indicator, we will reconnect in time.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "ADM/CONNECTING";
#endif
            break;

        case LINK_STATE_READY:

            //
            // Link is balanced and he is in ADM, so we have to shut down.
            //

#if DBG
            if (NbfDisconnectDebug) {
                NbfPrint0( "NbfProcessDm calling NbfStopLink\n" );
            }
#endif

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  Instead, we
            // got a DM, so he has dropped the link.
            //

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy but instead
            // he sent DM, so he has already dropped the link.
            //

        case LINK_STATE_W_DISC_RSP:

            //
            // We've sent a DISC-c/p and have received a DM from him, indicating
            // that he is now in ADM.  While technically not what we expected,
            // this protocol is commonly used in place of UA-r/f, so just treat
            // as though we got a UA-r/f.  Disconnect the link normally.
            //

            Link->State = LINK_STATE_ADM;       // we're reset now.
            NbfSendDm (Link, FALSE);   // indicate disconnected, release lock

            NbfStopLink (Link);

            // moving to ADM, remove reference
            NbfDereferenceLinkSpecial ("Got DM in W_DISC_RSP", Link, LREF_NOT_ADM);           // remove its "alive" ref.

#if DBG
            s = "READY/W_FINAL/W_POLL/W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

} /* NbfProcessDm */


VOID
NbfProcessFrmr(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received FRMR response frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
#if DBG
    UCHAR *s;
#endif
    ULONG DumpData[8];

    PollFinal, Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessFrmr:  Entered.\n");
    }

    //
    // Log an error, this shouldn't happen.
    //

    // Some state from Link and Packet Header
    DumpData[0] = Link->State;
    DumpData[1] = Link->Flags;
    DumpData[2] = (Header->Information.FrmrInfo.Command << 8) +
                  (Header->Information.FrmrInfo.Ctrl);
    DumpData[3] = (Header->Information.FrmrInfo.Vs << 16) +
                  (Header->Information.FrmrInfo.Vr << 8) +
                  (Header->Information.FrmrInfo.Reason);
    DumpData[4] = (Link->SendState << 24) +
                  (Link->NextSend << 16) +
                  (Link->LastAckReceived << 8) +
                  (Link->SendWindowSize);
    DumpData[5] = (Link->ReceiveState << 24) +
                  (Link->NextReceive << 16) +
                  (Link->LastAckSent << 8) +
                  (Link->ReceiveWindowSize);


    // Log if this is a loopback link & loopback index
    // Also log the remote MAC address for this link
    DumpData[6] = (Link->Loopback << 24) +
                  (Link->LoopbackDestinationIndex << 16) +
                  (Link->HardwareAddress.Address[0] <<  8) +
                  (Link->HardwareAddress.Address[1]);
                  
    DumpData[7] = (Link->HardwareAddress.Address[2] << 24) +
                  (Link->HardwareAddress.Address[3] << 16) +
                  (Link->HardwareAddress.Address[4] <<  8) +
                  (Link->HardwareAddress.Address[5]);

    NbfWriteGeneralErrorLog(
        Link->Provider,
        EVENT_TRANSPORT_BAD_PROTOCOL,
        1,
        STATUS_LINK_FAILED,
        L"FRMR",
        8,
        DumpData);


    ++Link->Provider->FrmrReceived;

    //
    // Format must be:  FRMR-r/x, on a real link object.
    //

    if (Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // Received a FRMR while in ADM.  Report disconnected mode.
            //

#if DBG
            s = "ADM";
#endif
            NbfSendDm (Link, FALSE);  // indicate disconnected, release lock
            break;

        case LINK_STATE_READY:

            //
            // Link is balanced and he reported a protocol error.
            //
#if 0
            // We want to reset the link, but not quite as fully
            // as NbfResetLink. This code is the same as what
            // is in there, except for:
            //
            // - resetting the send/receive numbers
            // - removing packets from the WackQ
            //

            StopT1 (Link);
            StopT2 (Link);
            Link->Flags &= LINK_FLAGS_DEFERRED_MASK;  // keep deferred operations

            Link->SendWindowSize = 1;
            Link->LinkBusy = FALSE;

            Link->ReceiveWindowSize = 1;
            Link->WindowErrors = 0;
            Link->BestWindowSize = 1;
            Link->WorstWindowSize = Link->MaxWindowSize;
            Link->Flags |= LINK_FLAGS_JUMP_START;

            Link->CurrentT1Timeout = Link->Provider->DefaultT1Timeout;
            Link->BaseT1Timeout = Link->Provider->DefaultT1Timeout << DLC_TIMER_ACCURACY;
            Link->CurrentPollRetransmits = 0;
            Link->CurrentPollOutstanding = FALSE;
            Link->T2Timeout = Link->Provider->DefaultT2Timeout;
            Link->TiTimeout = Link->Provider->DefaultTiTimeout;
            Link->LlcRetries = Link->Provider->LlcRetries;
            Link->MaxWindowSize = Link->Provider->LlcMaxWindowSize;

            //
            // The rest is similar to NbfActivateLink
            //

            Link->State = LINK_STATE_CONNECTING;
            Link->SendState = SEND_STATE_DOWN;
            Link->ReceiveState = RECEIVE_STATE_DOWN;
            Link->SendRetries = (UCHAR)Link->LlcRetries;

            NbfSendSabme (Link, TRUE);   // send SABME/p, StartT1, release lock
#else
            Link->State = LINK_STATE_ADM;        // we're reset now.
            NbfSendDm (Link, FALSE);    // indicate disconnected, release lock

            NbfStopLink (Link);

            // moving to ADM, remove reference
            NbfDereferenceLinkSpecial("Got DM in W_POLL", Link, LREF_NOT_ADM);
#endif

#if DBG
            NbfPrint1("Received FRMR on link %lx\n", Link);
#endif

#if DBG
            s = "READY";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and have just received a FRMR.
            //

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  Instead, we
            // got a FRMR.
            //

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy but instead
            // he sent FRMR.
            //

        case LINK_STATE_W_DISC_RSP:

            //
            // We've sent a DISC-c/p and have received a FRMR.
            //

            Link->State = LINK_STATE_ADM;       // we're reset now.
            NbfSendDm (Link, FALSE);   // indicate disconnected, release lock

            // moving to ADM, remove reference
            NbfDereferenceLinkSpecial("Got DM in W_POLL", Link, LREF_NOT_ADM);

#if DBG
            s = "CONN/W_POLL/W_FINAL/W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

} /* NbfProcessFrmr */


VOID
NbfProcessTest(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received TEST frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
    Header, PollFinal; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessTest:  Entered.\n");
    }

    //
    // Process only:  TEST-c/x.
    //

    // respond to TEST on a link that is NULL.

    if (!Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable
    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);


#if DBG
    PANIC ("NbfSendTest: Received Test Packet, not processing....\n");
#endif
    //NbfSendTest (Link, FALSE, PollFinal, Psdu);

} /* NbfProcessTest */


VOID
NbfProcessXid(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_U_FRAME Header
    )

/*++

Routine Description:

    This routine processes a received XID frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC U-type frame.

Return Value:

    none.

--*/

{
    Header; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 ("   NbfProcessXid:  Entered.\n");
    }

    //
    // Process only:  XID-c/x.
    //

    // respond to XID with a link that is NULL.

    if (!Command || (Link == NULL)) {
        return;
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    NbfSendXid (Link, FALSE, PollFinal);    // releases lock

} /* NbfProcessXid */


VOID
NbfProcessSFrame(
    IN BOOLEAN Command,
    IN BOOLEAN PollFinal,
    IN PTP_LINK Link,
    IN PDLC_S_FRAME Header,
    IN UCHAR CommandByte
    )

/*++

Routine Description:

    This routine processes a received RR, RNR, or REJ frame.

Arguments:

    Command - Boolean set to TRUE if command, else FALSE if response.

    PollFinal - Boolean set to TRUE if Poll or Final.

    Link - Pointer to a transport link object.

    Header - Pointer to a DLC S-type frame.

    CommandByte - The command byte of the frame (RR, RNR, or REJ).

Return Value:

    none.

--*/

{
#if DBG
    UCHAR *s;
#endif
    BOOLEAN Resend;
    BOOLEAN AckedPackets;
    UCHAR AckSequenceNumber;
    UCHAR OldLinkSendRetries;

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint2 ("   NbfProcessSFrame %s:  Entered, Link: %lx\n", Link,
            Command == DLC_CMD_RR ? "RR" : (Command == DLC_CMD_RNR ? "RNR" : "REJ"));
    }

    //
    // Process any of:  RR-x/x, RNR-x/x, REJ-x/x
    //

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);       // keep state stable

    if (CommandByte == DLC_CMD_RNR) {
        Link->LinkBusy = TRUE;     // he's set a busy condition.
    } else {
        Link->LinkBusy = FALSE;    // busy condition cleared.
    }

    switch (Link->State) {

        case LINK_STATE_ADM:

            //
            // We're disconnected.  Tell him.
            //

#if DBG
            s = "ADM";
#endif
            NbfSendDm (Link, PollFinal);    // releases lock
            break;

        case LINK_STATE_READY:

            //
            // Link is balanced. Note that the sections below surrounded by
            // if (Command && PollFinal) variants are all disjoint sets.
            // That's the only reason the Spinlock stuff works right. DO NOT
            // attempt to fiddle this unless you figure out the locking first!
            //

            //
            // If the AckSequenceNumber is not valid, ignore it. The
            // number should be between the first packet on the WackQ
            // and one more than the last packet. These correspond to
            // Link->LastAckReceived and Link->NextSend.
            //

            AckSequenceNumber = (UCHAR)(Header->RcvSeq >> 1);

            if (Link->NextSend >= Link->LastAckReceived) {

                //
                // There is no 127 -> 0 wrap between the two...
                //

                if ((AckSequenceNumber < Link->LastAckReceived) ||
                    (AckSequenceNumber > Link->NextSend)) {

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                    DbgPrint("NbfResendLlcPackets: %.2x-%.2x-%.2x-%.2x-%.2x-%.2x Unexpected N(R) %d, LastAck %d NextSend %d\n",
                        Link->HardwareAddress.Address[0],
                        Link->HardwareAddress.Address[1],
                        Link->HardwareAddress.Address[2],
                        Link->HardwareAddress.Address[3],
                        Link->HardwareAddress.Address[4],
                        Link->HardwareAddress.Address[5],
                        AckSequenceNumber, Link->LastAckReceived, Link->NextSend);
#endif
                    break;

                }

            } else {

                //
                // There is a 127 -> 0 wrap between the two...
                //

                if ((AckSequenceNumber < Link->LastAckReceived) &&
                    (AckSequenceNumber > Link->NextSend)) {

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                    DbgPrint("NbfResendLlcPackets: %.2x-%.2x-%.2x-%.2x-%.2x-%.2x Unexpected N(R) %d, LastAck %d NextSend %d\n",
                        Link->HardwareAddress.Address[0],
                        Link->HardwareAddress.Address[1],
                        Link->HardwareAddress.Address[2],
                        Link->HardwareAddress.Address[3],
                        Link->HardwareAddress.Address[4],
                        Link->HardwareAddress.Address[5],
                        AckSequenceNumber, Link->LastAckReceived, Link->NextSend);
#endif
                    break;

                }

            }


            //
            // We always resend on a REJ, and never on an RNR;
            // for an RR we may change Resend to TRUE below.
            // If we get a REJ on a WAN line (T1 is more than
            // five seconds) then we pretend this was a final
            // so we will resend even if a poll was outstanding.
            //

            if (CommandByte == DLC_CMD_REJ) {
                Resend = TRUE;
                if (Link->CurrentT1Timeout >= ((5 * SECONDS) / SHORT_TIMER_DELTA)) {
                    PollFinal = TRUE;
                }
                OldLinkSendRetries = (UCHAR)Link->SendRetries;
            } else {
                Resend = FALSE;
            }


#if 0
            //
            // If we've got a request with no poll, must have fired T2 on
            // the other side (or, if the other side is OS/2, he lost a
            // packet and knows it or is telling me to lower the window size).
            // In the T2 case, we've Acked current stuff, mark the window as
            // needing adjustment at some future time. In the OS/2 cases, this
            // is also the right thing to do.
            //

            if ((!Command) && (!PollFinal)) {
                ;
            }
#endif

            if (PollFinal) {

                if (Command) {

                    //
                    // If he is checkpointing, then we must respond with RR-r/f to
                    // update him on the status of our reception of his I-frames.
                    //

                    StopT2 (Link);                  // we acked some I-frames.
                    NbfSendRr (Link, FALSE, PollFinal);  // releases lock
                    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

                } else {

                    //
                    // If we were checkpointing, and he has sent an RR-r/f, we
                    // can clear the checkpoint condition.  Any packets which
                    // are still waiting for acknowlegement at this point must
                    // now be resent.
                    //

                    IF_NBFDBG (NBF_DEBUG_DLC) {
                        NbfPrint0 ("   NbfProcessRr: he's responded to our checkpoint.\n");
                    }
                    if (Link->SendState != SEND_STATE_CHECKPOINTING) {
                        IF_NBFDBG (NBF_DEBUG_DLC) {
                            NbfPrint0 ("   NbfProcessRr: not ckpting, but final received.\n");
                        }
                    } else if (CommandByte == DLC_CMD_RR) {
                        OldLinkSendRetries = (UCHAR)Link->SendRetries;
                        Resend = TRUE;
                        UpdateBaseT1Timeout (Link);     // gor response to poll
                    }
                    StopT1 (Link);                  // checkpointing finished.
                    Link->SendRetries = (UCHAR)Link->LlcRetries;
                    Link->SendState = SEND_STATE_READY;
                    StartTi (Link);
                }
            }

            //
            // NOTE: The link spinlock is held here.
            //

            //
            // The N(R) in this frame acknowleges some (or all) of our packets.
            // We'll ack packets on our send queue if this is a final when we
            // call Resend. This call must come after the checkpoint
            // acknowlegement check so that an RR-r/f is always sent BEFORE
            // any new I-frames.  This allows us to always send I-frames as
            // commands.
            //

            if (Link->WackQ.Flink != &Link->WackQ) {

                //
                // NOTE: ResendLlcPackets may release and reacquire
                // the link spinlock.
                //

                AckedPackets = ResendLlcPackets(
                                   Link,
                                   AckSequenceNumber,
                                   Resend);

                if (Resend && (!AckedPackets) && (Link->State == LINK_STATE_READY)) {

                    //
                    // To prevent stalling, pretend this RR wasn't
                    // received.
                    //

                    if (OldLinkSendRetries == 1) {

                        CancelT1Timeout (Link);      // we are stopping a polling state

                        Link->State = LINK_STATE_W_DISC_RSP;        // we are awaiting a DISC/f.
                        Link->SendState = SEND_STATE_DOWN;
                        Link->ReceiveState = RECEIVE_STATE_DOWN;
                        Link->SendRetries = (UCHAR)Link->LlcRetries;

#if DBG
                        DbgPrint ("NBF: No ack teardown of %lx\n", Link);
#endif
                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                        NbfStopLink (Link);

                        StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
                        NbfSendDisc (Link, TRUE);  // send DISC-c/p.

                    } else {

                        StopTi (Link);
                        Link->SendRetries = OldLinkSendRetries-1;

                        if (Link->SendState != SEND_STATE_CHECKPOINTING) {
                            Link->SendState = SEND_STATE_CHECKPOINTING;
                            NbfSendRr (Link, TRUE, TRUE);// send RR-c/p, StartT1, release lock
                        } else {
                            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                        }

                    }
#if DBG
                    s = "READY";
#endif
                    break;    // No need to RestartLinkTraffic

                } else if (AckedPackets) {

                    Link->SendRetries = (UCHAR)Link->LlcRetries;

                }

            }


            //
            // If the link send state is READY, get the link going
            // again.
            //
            // NOTE: RestartLinkTraffic releases the link spinlock.
            //

            if (Link->SendState == SEND_STATE_READY) {
                RestartLinkTraffic (Link);
            } else {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            }
#if DBG
            s = "READY";
#endif
            break;

        case LINK_STATE_CONNECTING:

            //
            // We've sent a SABME and are waiting for a UA.  He's sent a
            // RR too early, so just let the SABME timeout.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "CONNECTING";
#endif
            break;

        case LINK_STATE_W_POLL:

            //
            // We're waiting for his initial poll on a RR-c/p.  If he just
            // sends something without a poll, we'll let that get by.
            //

            if (!Command) {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                s = "W_POLL";
#endif
                break;                          // don't allow this protocol.
            }
            Link->State = LINK_STATE_READY;     // we're up!

            FakeUpdateBaseT1Timeout (Link);
            NbfSendRr (Link, FALSE, PollFinal);  // send RR-r/x, release lock
            NbfCompleteLink (Link);              // fire up the connections.
            IF_NBFDBG (NBF_DEBUG_SETUP) {
                NbfPrint4("W_POLL RR on %lx %x-%x-%x\n",
                    Link,
                    Link->HardwareAddress.Address[3],
                    Link->HardwareAddress.Address[4],
                    Link->HardwareAddress.Address[5]);
            }
            StartTi (Link);

#if DBG
            s = "W_POLL";
#endif
            break;

        case LINK_STATE_W_FINAL:

            //
            // We're waiting for a RR-r/f from the remote guy.
            //

            if (Command || !PollFinal) {        // wait for final.
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
                s = "W_FINAL";
#endif
                break;                          // we sent RR-c/p.
            }
            Link->State = LINK_STATE_READY;     // we're up.
            StopT1 (Link);                      // poll was acknowleged.
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            NbfCompleteLink (Link);              // fire up the connections.
            StartTi (Link);
#if DBG
            s = "W_FINAL";
#endif
            break;

        case LINK_STATE_W_DISC_RSP:

            //
            // We're waiting for a response from our DISC-c/p but instead of
            // a UA-r/f, we got this RR.  Throw the packet away.
            //

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "W_DISC_RSP";
#endif
            break;

        default:

            ASSERT (FALSE);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
            s = "Unknown link state";
#endif

    } /* switch */

#if DBG
    if (CommandByte == DLC_CMD_REJ) {
        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint1 ("   NbfProcessRej: (%s) REJ received.\n", s);
        }
    }
#endif

} /* NbfProcessSFrame */


VOID
NbfInsertInLoopbackQueue (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PNDIS_PACKET NdisPacket,
    IN UCHAR LinkIndex
    )

/*++

Routine Description:

    This routine places a packet on the loopback queue, and
    queues a DPC to do the indication if needed.

Arguments:

    DeviceContext - The device context in question.

    NdisPacket - The packet to place on the loopback queue.

    LinkIndex - The index of the loopback link to indicate to.

Return Value:

    None:

--*/

{
    PSEND_PACKET_TAG SendPacketTag;
    KIRQL oldirql;

    SendPacketTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;
    SendPacketTag->OnLoopbackQueue = TRUE;

    SendPacketTag->LoopbackLinkIndex = LinkIndex;

    ACQUIRE_SPIN_LOCK(&DeviceContext->LoopbackSpinLock, &oldirql);

    InsertTailList(&DeviceContext->LoopbackQueue, &SendPacketTag->Linkage);

    if (!DeviceContext->LoopbackInProgress) {

        KeInsertQueueDpc(&DeviceContext->LoopbackDpc, NULL, NULL);
        DeviceContext->LoopbackInProgress = TRUE;

    }

    RELEASE_SPIN_LOCK (&DeviceContext->LoopbackSpinLock, oldirql);

}


VOID
NbfProcessLoopbackQueue (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the DPC routine which processes items on the
    loopback queue. It processes a single request off the
    queue (if there is one), then if there is another request
    it requeues itself.

Arguments:

    Dpc - The system DPC object.

    DeferredContext - A pointer to the device context.

    SystemArgument1, SystemArgument2 - Not used.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    PNDIS_PACKET NdisPacket;
    PNDIS_BUFFER FirstBuffer;
    PVOID LookaheadBuffer;
    UINT LookaheadBufferSize;
    UINT BytesCopied;
    UINT PacketSize;
    ULONG HeaderLength;
    PTP_LINK Link;
    PSEND_PACKET_TAG SendPacketTag;
    PLIST_ENTRY p;


    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);


    DeviceContext = (PDEVICE_CONTEXT)DeferredContext;

    ACQUIRE_DPC_SPIN_LOCK(&DeviceContext->LoopbackSpinLock);

    if (!IsListEmpty(&DeviceContext->LoopbackQueue)) {

        p = RemoveHeadList(&DeviceContext->LoopbackQueue);

        //
        // This depends on the fact that the Linkage field is
        // the first one in ProtocolReserved.
        //

        NdisPacket = CONTAINING_RECORD(p, NDIS_PACKET, ProtocolReserved[0]);

        SendPacketTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;
        SendPacketTag->OnLoopbackQueue = FALSE;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LoopbackSpinLock);


        //
        // Determine the data needed to indicate. We don't guarantee
        // that we will have the correct lookahead length, but since
        // we know that any header we prepend is a single piece,
        // and that's all we'll have to look at in an indicated packet,
        // that's not a concern.
        //
        // Unfortunately that last paragraph is bogus since for
        // indications to our client we need more data...
        //

        NdisQueryPacket(NdisPacket, NULL, NULL, &FirstBuffer, &PacketSize);

        NdisQueryBuffer(FirstBuffer, &LookaheadBuffer, &LookaheadBufferSize);

        if ((LookaheadBufferSize != PacketSize) &&
            (LookaheadBufferSize < NBF_MAX_LOOPBACK_LOOKAHEAD)) {

            //
            // There is not enough contiguous data in the
            // packet's first buffer, so we merge it into
            // DeviceContext->LookaheadContiguous.
            //

            if (PacketSize > NBF_MAX_LOOPBACK_LOOKAHEAD) {
                LookaheadBufferSize = NBF_MAX_LOOPBACK_LOOKAHEAD;
            } else {
                LookaheadBufferSize = PacketSize;
            }

            NbfCopyFromPacketToBuffer(
                NdisPacket,
                0,
                LookaheadBufferSize,
                DeviceContext->LookaheadContiguous,
                &BytesCopied);

            ASSERT (BytesCopied == LookaheadBufferSize);

            LookaheadBuffer = DeviceContext->LookaheadContiguous;

        }


        //
        // Now determine which link to loop it back to;
        // UI frames are not indicated on any link.
        //

        SendPacketTag = (PSEND_PACKET_TAG)NdisPacket->ProtocolReserved;

        //
        // Hold DeviceContext->LinkSpinLock until we get a
        // reference.
        //

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        switch (SendPacketTag->LoopbackLinkIndex) {

            case LOOPBACK_TO_CONNECTOR:

                Link = DeviceContext->LoopbackLinks[CONNECTOR_LINK];
                break;

            case LOOPBACK_TO_LISTENER:

                Link = DeviceContext->LoopbackLinks[LISTENER_LINK];
                break;

            case LOOPBACK_UI_FRAME:
            default:

                Link = (PTP_LINK)NULL;
                break;

        }

        //
        // For non-null links, we have to reference them.
        // We use LREF_TREE since that is what
        // NbfGeneralReceiveHandler expects.
        //

        if (Link != (PTP_LINK)NULL) {
            NbfReferenceLink("loopback indication", Link, LREF_TREE);
        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        MacReturnHeaderLength(
            &DeviceContext->MacInfo,
            LookaheadBuffer,
            &HeaderLength);

        DeviceContext->LoopbackHeaderLength = HeaderLength;

        //
        // Process the receive like any other. We don't have to
        // worry about frame padding since we construct the
        // frame ourselves.
        //

        NbfGeneralReceiveHandler(
            DeviceContext,
            (NDIS_HANDLE)NdisPacket,
            &DeviceContext->LocalAddress,         // since it is loopback
            Link,
            LookaheadBuffer,                      // header
            PacketSize - HeaderLength,            // total packet size
            (PDLC_FRAME)((PUCHAR)LookaheadBuffer + HeaderLength),   // l/a data
            LookaheadBufferSize - HeaderLength,   // lookahead data length
            TRUE
            );


        //
        // Now complete the send.
        //

        NbfSendCompletionHandler(
            DeviceContext->NdisBindingHandle,
            NdisPacket,
            NDIS_STATUS_SUCCESS
            );


        ACQUIRE_DPC_SPIN_LOCK(&DeviceContext->LoopbackSpinLock);

        if (!IsListEmpty(&DeviceContext->LoopbackQueue)) {

            KeInsertQueueDpc(&DeviceContext->LoopbackDpc, NULL, NULL);

            //
            // Remove these two lines if it is decided thet
            // NbfReceiveComplete should be called after every
            // loopback indication.
            //

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->LoopbackSpinLock);
            return;

        } else {

            DeviceContext->LoopbackInProgress = FALSE;

        }

    } else {

        //
        // This shouldn't happen!
        //

        DeviceContext->LoopbackInProgress = FALSE;

#if DBG
        NbfPrint1("Loopback queue empty for device context %x\n", DeviceContext);
#endif

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->LoopbackSpinLock);

    NbfReceiveComplete(
        (NDIS_HANDLE)DeviceContext
        );

}   /* NbfProcessLoopbackQueue */


NDIS_STATUS
NbfReceiveIndication (
    IN NDIS_HANDLE BindingContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PVOID HeaderBuffer,
    IN UINT HeaderBufferSize,
    IN PVOID LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT PacketSize
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a frame has been received on the physical link.
    This routine is time critical, so we only allocate a
    buffer and copy the packet into it. We also perform minimal
    validation on this packet. It gets queued to the device context
    to allow for processing later.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

    ReceiveContext - A magic cookie for the MAC.

    HeaderBuffer - pointer to a buffer containing the packet header.

    HeaderBufferSize - the size of the header.

    LookaheadBuffer - pointer to a buffer containing the negotiated minimum
        amount of buffer I get to look at (not including header).

    LookaheadBufferSize - the size of the above. May be less than asked
        for, if that's all there is.

    PacketSize - Overall size of the packet (not including header).

Return Value:

    NDIS_STATUS - status of operation, one of:

                 NDIS_STATUS_SUCCESS if packet accepted,
                 NDIS_STATUS_NOT_RECOGNIZED if not recognized by protocol,
                 NDIS_any_other_thing if I understand, but can't handle.

--*/
{
    PDEVICE_CONTEXT DeviceContext;
    KIRQL oldirql;
    PTP_LINK Link;
    HARDWARE_ADDRESS SourceAddressBuffer;
    PHARDWARE_ADDRESS SourceAddress;
    UINT RealPacketSize;
    PDLC_FRAME DlcHeader;
    BOOLEAN Multicast;

    ENTER_NBF;

    IF_NBFDBG (NBF_DEBUG_NDIS) {
        PUCHAR p;
        SHORT i;
        NbfPrint2 ("NbfReceiveIndication: Packet, Size: 0x0%lx LookaheadSize: 0x0%lx\n 00:",
            PacketSize, LookaheadBufferSize);
        p = (PUCHAR)LookaheadBuffer;
        for (i=0;i<25;i++) {
            NbfPrint1 (" %2x",p[i]);
        }
        NbfPrint0 ("\n");
    }

    DeviceContext = (PDEVICE_CONTEXT)BindingContext;

    RealPacketSize = 0;

    //
    // Obtain the packet length; this may optionally adjust
    // the lookahead buffer forward if the header we wish
    // to remove spills over into what the MAC considers
    // data. If it determines that the header is not
    // valid, it keeps RealPacketSize at 0.
    //

    MacReturnPacketLength(
        &DeviceContext->MacInfo,
        HeaderBuffer,
        HeaderBufferSize,
        PacketSize,
        &RealPacketSize,
        &LookaheadBuffer,
        &LookaheadBufferSize
        );

    if (RealPacketSize < 2) {
        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint1 ("NbfReceiveIndication: Discarding packet, bad length %lx\n",
                HeaderBuffer);
        }
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    //
    // We've negotiated at least a contiguous DLC header passed back in the
    // lookahead buffer. Check it to see if we want this packet.
    //

    DlcHeader = (PDLC_FRAME)LookaheadBuffer;

    if (((*(USHORT UNALIGNED *)(&DlcHeader->Dsap)) &
         (USHORT)((DLC_SSAP_MASK << 8) | DLC_DSAP_MASK)) !=
             (USHORT)((DSAP_NETBIOS_OVER_LLC << 8) | DSAP_NETBIOS_OVER_LLC)) {

        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint1 ("NbfReceiveIndication: Discarding lookahead data, not NetBIOS: %lx\n",
                LookaheadBuffer);
        }
        LEAVE_NBF;
        return NDIS_STATUS_NOT_RECOGNIZED;        // packet was processed.
    }


    //
    // Check that the packet is not too long.
    //

    if (PacketSize > DeviceContext->MaxReceivePacketSize) {
#if DBG
        NbfPrint2("NbfReceiveIndication: Ignoring packet length %d, max %d\n",
            PacketSize, DeviceContext->MaxReceivePacketSize);
#endif
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    MacReturnSourceAddress(
        &DeviceContext->MacInfo,
        HeaderBuffer,
        &SourceAddressBuffer,
        &SourceAddress,
        &Multicast
        );

    //
    // Record how many multicast packets we get, to monitor
    // general network activity.
    //

    if (Multicast) {
        ++DeviceContext->MulticastPacketCount;
    }


    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);

    //
    // Unless this is a UI frame find the Link this packet belongs to.
    // If there is not a recognized link, pass the frame on to be handled
    // by the receive complete code.
    //

    if ((((PDLC_U_FRAME)LookaheadBuffer)->Command) != DLC_CMD_UI) {

        // This adds a link reference if it is found

        Link = NbfFindLink (DeviceContext, SourceAddress->Address);

        if (Link != NULL) {

            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint1 ("NbfReceiveIndication: Found link, Link: %lx\n", Link);
            }

        }

    } else {

        Link = NULL;

    }


    NbfGeneralReceiveHandler(
        DeviceContext,
        ReceiveContext,
        SourceAddress,
        Link,
        HeaderBuffer,                  // header
        RealPacketSize,                // total data length in packet
        (PDLC_FRAME)LookaheadBuffer,   // lookahead data
        LookaheadBufferSize,           // lookahead data length
        FALSE                          // not loopback
        );

    KeLowerIrql (oldirql);

    return STATUS_SUCCESS;

}   /* NbfReceiveIndication */


VOID
NbfGeneralReceiveHandler (
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PTP_LINK Link,
    IN PVOID HeaderBuffer,
    IN UINT PacketSize,
    IN PDLC_FRAME DlcHeader,
    IN UINT DlcSize,
    IN BOOLEAN Loopback
    )

/*++

Routine Description:

    This routine receives control from either NbfReceiveIndication
    or NbfProcessLoopbackQueue. It continues the processing of
    indicated data once the link has been determined.

    This routine is time critical, so we only allocate a
    buffer and copy the packet into it. We also perform minimal
    validation on this packet. It gets queued to the device context
    to allow for processing later.

Arguments:

    DeviceContext - The device context of this adapter.

    ReceiveContext - A magic cookie for the MAC.

    SourceAddress - The source address of the packet.

    Link - The link that this packet was received on, may be NULL
        if the link was not found. If not NULL, Link will have
        a reference of type LREF_TREE.

    HeaderBuffer - pointer to the packet header.

    PacketSize - Overall size of the packet (not including header).

    DlcHeader - Points to the DLC header of the packet.

    DlcSize - The length of the packet indicated, starting from DlcHeader.

    Loopback - TRUE if this was called by NbfProcessLoopbackQueue;
        used to determine whether to call NdisTransferData or
        NbfTransferLoopbackData.

Return Value:

    None.

--*/
{

    PNDIS_PACKET NdisPacket;
    NTSTATUS Status;
    PNDIS_BUFFER NdisBuffer;
    NDIS_STATUS NdisStatus;
    PSINGLE_LIST_ENTRY linkage;
    UINT BytesTransferred;
    BOOLEAN Command;
    BOOLEAN PollFinal;
    PRECEIVE_PACKET_TAG ReceiveTag;
    PBUFFER_TAG BufferTag;
    PUCHAR SourceRouting;
    UINT SourceRoutingLength;
    PDLC_I_FRAME IHeader;
    PDLC_U_FRAME UHeader;
    PDLC_S_FRAME SHeader;
    PTP_ADDRESS DatagramAddress;
    UINT NdisBufferLength;
    PVOID BufferPointer;

    ENTER_NBF;


    INCREMENT_COUNTER (DeviceContext, PacketsReceived);

    Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);

    if (Link == (PTP_LINK)NULL) {
        UHeader = (PDLC_U_FRAME)DlcHeader;
        if (((UHeader->Command & ~DLC_U_PF) == DLC_CMD_UI) && Command) {
            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint0 (" NbfGeneralReceiveHandler: Processing packet as UI frame.\n");
            }

            MacReturnSourceRouting(
                &DeviceContext->MacInfo,
                HeaderBuffer,
                &SourceRouting,
                &SourceRoutingLength);

            if (SourceRoutingLength > MAX_SOURCE_ROUTING) {
                Status = STATUS_ABANDONED;
            } 
            else {
                Status = NbfProcessUi (
                             DeviceContext,
                             SourceAddress,
                             HeaderBuffer,
                             (PUCHAR)UHeader,
                             DlcSize,
                             SourceRouting,
                             SourceRoutingLength,
                             &DatagramAddress);
            }
        } else {

            //
            // or drop on the floor. (Note that state tables say that
            // we'll always handle a DM with a DM response. This should change.)
            //

            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint0 (" NbfReceiveIndication: it's not a UI frame!\n");
            }
            Status = STATUS_SUCCESS;
        }

        if (Status != STATUS_MORE_PROCESSING_REQUIRED) {

            LEAVE_NBF;
            return;

        } else if (((PNBF_HDR_CONNECTIONLESS)((PUCHAR)UHeader + 3))->Command ==
                NBF_CMD_STATUS_RESPONSE) {

            (VOID)NbfProcessStatusResponse(
                       DeviceContext,
                       ReceiveContext,
                       (PNBF_HDR_CONNECTIONLESS)((PUCHAR)UHeader + 3),
                       SourceAddress,
                       SourceRouting,
                       SourceRoutingLength);
            return;

        } else {
            goto HandleAtComplete;      // only datagrams will get through this
        }
    }


    //
    // At this point we have a link reference count of type LREF_TREE
    //

    ++Link->PacketsReceived;

    //
    // deal with I-frames first; they are what we expect the most of...
    //

    if (!(DlcHeader->Byte1 & DLC_I_INDICATOR)) {

        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint0 ("NbfReceiveIndication: I-frame encountered.\n");
        }
        if (DlcSize >= 4 + sizeof (NBF_HDR_CONNECTION)) {
            IHeader = (PDLC_I_FRAME)DlcHeader;
            NbfProcessIIndicate (
                Command,
                (BOOLEAN)(IHeader->RcvSeq & DLC_I_PF),
                Link,
                (PUCHAR)DlcHeader,
                DlcSize,
                PacketSize,
                ReceiveContext,
                Loopback);
        } else {
#if DBG
//            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint0 ("NbfReceiveIndication: Runt I-frame, discarded!\n");
//            }
#endif
            ;
        }

    } else if (((DlcHeader->Byte1 & DLC_U_INDICATOR) == DLC_U_INDICATOR)) {

        //
        // different case switches for S and U frames, because structures
        // are different.
        //

        IF_NBFDBG (NBF_DEBUG_NDIS) {
            NbfPrint0 ("NbfReceiveIndication: U-frame encountered.\n");
        }

#if PKT_LOG
        // We have the connection here, log the packet for debugging
        NbfLogRcvPacket(NULL,
                        Link,
                        (PUCHAR)DlcHeader,
                        PacketSize,
                        DlcSize);
#endif // PKT_LOG

        UHeader = (PDLC_U_FRAME)DlcHeader;
        PollFinal = (BOOLEAN)(UHeader->Command & DLC_U_PF);
        switch (UHeader->Command & ~DLC_U_PF) {

            case DLC_CMD_SABME:
                NbfProcessSabme (Command, PollFinal, Link, UHeader,
                                 HeaderBuffer, SourceAddress, DeviceContext);
                break;

            case DLC_CMD_DISC:
                NbfProcessDisc (Command, PollFinal, Link, UHeader);
                break;

            case DLC_CMD_UA:
                NbfProcessUa (Command, PollFinal, Link, UHeader);
                break;

            case DLC_CMD_DM:
                NbfProcessDm (Command, PollFinal, Link, UHeader);
                break;

            case DLC_CMD_FRMR:
                NbfProcessFrmr (Command, PollFinal, Link, UHeader);
                break;

            case DLC_CMD_UI:

                ASSERT (FALSE);
                break;

            case DLC_CMD_XID:
                PANIC ("ReceiveIndication: XID!\n");
                NbfProcessXid (Command, PollFinal, Link, UHeader);
                break;

            case DLC_CMD_TEST:
                PANIC ("NbfReceiveIndication: TEST!\n");
                NbfProcessTest (Command, PollFinal, Link, UHeader);
                break;

            default:
                PANIC ("NbfReceiveIndication: bad U-frame, packet dropped.\n");

        } /* switch */

    } else {

        //
        // We have an S-frame.
        //

        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint0 ("NbfReceiveIndication: S-frame encountered.\n");
        }

#if PKT_LOG
        // We have the connection here, log the packet for debugging
        NbfLogRcvPacket(NULL,
                        Link,
                        (PUCHAR)DlcHeader,
                        PacketSize,
                        DlcSize);
#endif // PKT_LOG

        SHeader = (PDLC_S_FRAME)DlcHeader;
        PollFinal = (BOOLEAN)(SHeader->RcvSeq & DLC_S_PF);
        switch (SHeader->Command) {

            case DLC_CMD_RR:
            case DLC_CMD_RNR:
            case DLC_CMD_REJ:
                NbfProcessSFrame (Command, PollFinal, Link, SHeader, SHeader->Command);
                break;

            default:
                IF_NBFDBG (NBF_DEBUG_DLC) {
                    NbfPrint0 ("  NbfReceiveIndication: bad S-frame.\n");
                }

        } /* switch */

    } // if U-frame or S-frame

    //
    // If we reach here, the packet has been processed. If it needs
    // to be copied, we will jump to HandleAtComplete.
    //

    NbfDereferenceLinkMacro ("Done with Indicate frame", Link, LREF_TREE);
    LEAVE_NBF;
    return;

HandleAtComplete:;

    //
    // At this point we DO NOT have any link references added in
    // this function.
    //

    linkage = ExInterlockedPopEntryList(
        &DeviceContext->ReceivePacketPool,
        &DeviceContext->Interlock);

    if (linkage != NULL) {
        NdisPacket = CONTAINING_RECORD( linkage, NDIS_PACKET, ProtocolReserved[0] );
    } else {
        // PANIC ("NbfReceiveIndicate: Discarding Packet, no receive packets.\n");
        DeviceContext->ReceivePacketExhausted++;
        LEAVE_NBF;
        return;
    }
    ReceiveTag = (PRECEIVE_PACKET_TAG)(NdisPacket->ProtocolReserved);

    linkage = ExInterlockedPopEntryList(
       &DeviceContext->ReceiveBufferPool,
       &DeviceContext->Interlock);

    if (linkage != NULL) {
        BufferTag = CONTAINING_RECORD( linkage, BUFFER_TAG, Linkage);
    } else {
        ExInterlockedPushEntryList(
            &DeviceContext->ReceivePacketPool,
            &ReceiveTag->Linkage,
            &DeviceContext->Interlock);
        // PANIC ("NbfReceiveIndicate: Discarding Packet, no receive buffers.\n");
        DeviceContext->ReceiveBufferExhausted++;
        LEAVE_NBF;
        return;
    }

    NdisAdjustBufferLength (BufferTag->NdisBuffer, PacketSize);
    NdisChainBufferAtFront (NdisPacket, BufferTag->NdisBuffer);

    //
    // DatagramAddress has a reference of type AREF_PROCESS_DATAGRAM,
    // unless this is a datagram intended for RAS only, in which case
    // it is NULL.
    //

    BufferTag->Address = DatagramAddress;

    //
    // set up async return status so we can tell when it has happened;
    // can never get return of NDIS_STATUS_PENDING in synch completion routine
    // for NdisTransferData, so we know it has completed when this status
    // changes
    //

    BufferTag->NdisStatus = NDIS_STATUS_PENDING;
    ReceiveTag->PacketType = TYPE_AT_COMPLETE;

    ExInterlockedInsertTailList(
        &DeviceContext->ReceiveInProgress,
        &BufferTag->Linkage,
        &DeviceContext->SpinLock);

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint1 ("NbfReceiveIndicate: Packet on Queue: %lx\n",NdisPacket);
    }

    //
    // receive packet is mapped at initalize
    //

    //
    // Determine how to handle the data transfer.
    //

    if (Loopback) {

        NbfTransferLoopbackData(
            &NdisStatus,
            DeviceContext,
            ReceiveContext,
            DeviceContext->MacInfo.TransferDataOffset,
            PacketSize,
            NdisPacket,
            &BytesTransferred
            );

    } else {

        if (DeviceContext->NdisBindingHandle) {
        
            NdisTransferData (
                &NdisStatus,
                DeviceContext->NdisBindingHandle,
                ReceiveContext,
                DeviceContext->MacInfo.TransferDataOffset,
                PacketSize,
                NdisPacket,
                &BytesTransferred);
        }
        else {
            NdisStatus = STATUS_INVALID_DEVICE_STATE;
        }
    }

    //
    // handle the various error codes
    //

    switch (NdisStatus) {
    case NDIS_STATUS_SUCCESS: // received packet
        BufferTag->NdisStatus = NDIS_STATUS_SUCCESS;

        if (BytesTransferred == PacketSize) {  // Did we get the entire packet?
            ReceiveTag->PacketType = TYPE_AT_INDICATE;
            NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
            ExInterlockedPushEntryList(
                &DeviceContext->ReceivePacketPool,
                &ReceiveTag->Linkage,
                &DeviceContext->Interlock);
            LEAVE_NBF;
            return;
        }
        IF_NBFDBG (NBF_DEBUG_DLC) {
            NbfPrint2 ("NbfReceiveIndicate: Discarding Packet, Partial transfer: 0x0%lx of 0x0%lx transferred\n",
                BytesTransferred, PacketSize);
        }
        break;

    case NDIS_STATUS_PENDING:   // waiting async complete from NdisTransferData
        LEAVE_NBF;
        return;
        break;

    default:    // something broke; certainly we'll never get NdisTransferData
                // asynch completion with this error status...
        break;
    }

    //
    // receive failed, for some reason; cleanup and fail return
    //

#if DBG
    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint1 ("NbfReceiveIndicate: Discarding Packet, transfer failed: %s\n",
            NbfGetNdisStatus (NdisStatus));
    }
#endif

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
    RemoveEntryList (&BufferTag->Linkage);
    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    ReceiveTag->PacketType = TYPE_AT_INDICATE;

    NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
    ExInterlockedPushEntryList(
        &DeviceContext->ReceivePacketPool,
        &ReceiveTag->Linkage,
        &DeviceContext->Interlock);

    NdisQueryBuffer (NdisBuffer, &BufferPointer, &NdisBufferLength);
    BufferTag = CONTAINING_RECORD (
                    BufferPointer,
                    BUFFER_TAG,
                    Buffer[0]
                    );
    NdisAdjustBufferLength (NdisBuffer, BufferTag->Length); // reset to good value

    ExInterlockedPushEntryList(
        &DeviceContext->ReceiveBufferPool,
        (PSINGLE_LIST_ENTRY)&BufferTag->Linkage,
        &DeviceContext->Interlock);

    if (DatagramAddress) {
        NbfDereferenceAddress ("DG TransferData failed", DatagramAddress, AREF_PROCESS_DATAGRAM);
    }

    LEAVE_NBF;
    return;

}   /* NbfGeneralReceiveHandler */



VOID
NbfTransferDataComplete (
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT BytesTransferred
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that an NdisTransferData has completed. We use this indication
    to start stripping buffers from the receive queue.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.

    NdisPacket/RequestHandle - An identifier for the request that completed.

    NdisStatus - The completion status for the request.

    BytesTransferred - Number of bytes actually transferred.


Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = (PDEVICE_CONTEXT)BindingContext;
    PRECEIVE_PACKET_TAG ReceiveTag;
    PTP_CONNECTION Connection;
    KIRQL oldirql1;
    PTP_REQUEST Request;
    PNDIS_BUFFER NdisBuffer;
    UINT NdisBufferLength;
    PVOID BufferPointer;
    PBUFFER_TAG BufferTag;

    //
    // Put the NDIS status into a place we can use in packet processing.
    // Note that this complete indication may be occuring during the call
    // to NdisTransferData in the receive indication.
    //

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint2 (" NbfTransferDataComplete: Entered, Packet: %lx bytes transferred: 0x0%x\n",
            NdisPacket, BytesTransferred);
    }
    ReceiveTag = (PRECEIVE_PACKET_TAG)(NdisPacket->ProtocolReserved);

    //
    // note that the processing below depends on having only one packet
    // transfer outstanding at a time. NDIS is supposed to guarentee this.
    //

    switch (ReceiveTag->PacketType) {

    case TYPE_AT_COMPLETE:          // datagrams

        NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
        NdisQueryBuffer (NdisBuffer, &BufferPointer, &NdisBufferLength);
        BufferTag = CONTAINING_RECORD( BufferPointer, BUFFER_TAG, Buffer[0]);
        BufferTag->NdisStatus = NdisStatus;

        ReceiveTag->PacketType = TYPE_AT_INDICATE;

        ExInterlockedPushEntryList(
            &DeviceContext->ReceivePacketPool,
            &ReceiveTag->Linkage,
            &DeviceContext->Interlock);

        break;

    case TYPE_AT_INDICATE:          // I-frames

        //
        // The transfer for this packet is complete. Was it successful??
        //

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

        Connection = ReceiveTag->Connection;

        //
        // rip all of the NDIS_BUFFERs we've used off the chain and return them.
        //

        if (ReceiveTag->AllocatedNdisBuffer) {
            NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
            while (NdisBuffer != NULL) {
                NdisFreeBuffer (NdisBuffer);
                NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
            }
        } else {
            NdisReinitializePacket (NdisPacket);
        }


        if ((NdisStatus != NDIS_STATUS_SUCCESS) ||
            (!DeviceContext->MacInfo.SingleReceive)) {

            if (NdisStatus != NDIS_STATUS_SUCCESS) {

                ULONG DumpData[2];
                DumpData[0] = BytesTransferred;
                DumpData[1] = ReceiveTag->BytesToTransfer;

                NbfWriteGeneralErrorLog(
                    DeviceContext,
                    EVENT_TRANSPORT_TRANSFER_DATA,
                    603,
                    NdisStatus,
                    NULL,
                    2,
                    DumpData);

                // Drop the packet.
#if DBG
                NbfPrint1 ("NbfTransferDataComplete: status %s\n",
                    NbfGetNdisStatus (NdisStatus));
#endif
                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                Connection->Flags |= CONNECTION_FLAGS_TRANSFER_FAIL;

            } else {

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            }

            Connection->TransferBytesPending -= ReceiveTag->BytesToTransfer;

            if ((Connection->TransferBytesPending == 0) &&
                (Connection->Flags & CONNECTION_FLAGS_TRANSFER_FAIL)) {

                Connection->CurrentReceiveMdl = Connection->SavedCurrentReceiveMdl;
                Connection->ReceiveByteOffset = Connection->SavedReceiveByteOffset;
                Connection->MessageBytesReceived -= Connection->TotalTransferBytesPending;
                Connection->Flags &= ~CONNECTION_FLAGS_TRANSFER_FAIL;
                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                if ((Connection->Flags & CONNECTION_FLAGS_VERSION2) == 0) {
                    NbfSendNoReceive (Connection);
                }
                NbfSendReceiveOutstanding (Connection);

                ReceiveTag->CompleteReceive = FALSE;

            } else {

                //
                // If we have more data outstanding, this can't
                // be the last piece; i.e. we can't handle having
                // the last piece complete asynchronously before
                // an earlier piece.
                //
#if DBG
                if (Connection->TransferBytesPending > 0) {
                    ASSERT (!ReceiveTag->CompleteReceive);
                }
#endif

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            }

            if (!Connection->CurrentReceiveSynchronous) {
                NbfDereferenceReceiveIrp ("TransferData complete", IoGetCurrentIrpStackLocation(Connection->CurrentReceiveIrp), RREF_RECEIVE);
            }


            //
            // dereference the connection to say we've done the I frame processing.
            // This reference was done before calling NdisTransferData.
            //

            if (ReceiveTag->TransferDataPended) {
                NbfDereferenceConnection("TransferData done", Connection, CREF_TRANSFER_DATA);
            }


        } else {

            ASSERT (NdisStatus == STATUS_SUCCESS);
            ASSERT (!ReceiveTag->TransferDataPended);
            ASSERT (Connection->CurrentReceiveSynchronous);

            if (!Connection->SpecialReceiveIrp) {
                Connection->CurrentReceiveIrp->IoStatus.Information += BytesTransferred;
            }

        }


        //
        // see if we've completed the current receive. If so, move to the next one.
        //

        if (ReceiveTag->CompleteReceive) {
            CompleteReceive (Connection, ReceiveTag->EndOfMessage, (ULONG)BytesTransferred);
        }

        ExInterlockedPushEntryList(
            &DeviceContext->ReceivePacketPool,
            &ReceiveTag->Linkage,
            &DeviceContext->Interlock);

        KeLowerIrql (oldirql1);

        break;

    case TYPE_STATUS_RESPONSE:      // response to remote adapter status

#if DBG
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            DbgPrint ("NBF: STATUS_RESPONSE TransferData failed\n");
        }
#endif

        NdisUnchainBufferAtFront (NdisPacket, &NdisBuffer);
        ASSERT (NdisBuffer);
        NdisFreeBuffer (NdisBuffer);

        Request = (PTP_REQUEST)ReceiveTag->Connection;

        if (ReceiveTag->CompleteReceive) {
            NbfCompleteRequest(
                Request,
                ReceiveTag->EndOfMessage ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW,
                Request->BytesWritten);
        }

        NbfDereferenceRequest("Status xfer done", Request, RREF_STATUS);

        ReceiveTag->PacketType = TYPE_AT_INDICATE;

        ExInterlockedPushEntryList(
            &DeviceContext->ReceivePacketPool,
            &ReceiveTag->Linkage,
            &DeviceContext->Interlock);

        break;

    default:
#if DBG
        NbfPrint1 ("NbfTransferDataComplete: Bang! Packet Transfer failed, unknown packet type: %ld\n",
            ReceiveTag->PacketType);
        DbgBreakPoint ();
#endif
        break;
    }

    return;

} // NbfTransferDataComplete



VOID
NbfReceiveComplete (
    IN NDIS_HANDLE BindingContext
    )

/*++

Routine Description:

    This routine receives control from the physical provider as an
    indication that a connection(less) frame has been received on the
    physical link.  We dispatch to the correct packet handler here.

Arguments:

    BindingContext - The Adapter Binding specified at initialization time.
                     Nbf uses the DeviceContext for this parameter.

Return Value:

    None

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    UINT i;
    NTSTATUS Status;
    KIRQL oldirql2;
    BOOLEAN Command;
    PDLC_U_FRAME UHeader;
    PDLC_FRAME DlcHeader;
    PLIST_ENTRY linkage;
    UINT NdisBufferLength;
    PVOID BufferPointer;
    PBUFFER_TAG BufferTag;
    PTP_ADDRESS Address;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PTP_CONNECTION Connection;
    PTP_LINK Link;

    ENTER_NBF;

    //

    IF_NBFDBG (NBF_DEBUG_DLC) {
        NbfPrint0 (" NbfReceiveComplete: Entered.\n");
    }

    DeviceContext = (PDEVICE_CONTEXT) BindingContext;

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql2);

    //
    // Complete all pending receives. Do a quick check
    // without the lock.
    //

    while (!IsListEmpty (&DeviceContext->IrpCompletionQueue)) {

        linkage = ExInterlockedRemoveHeadList(
                      &DeviceContext->IrpCompletionQueue,
                      &DeviceContext->Interlock);

        if (linkage != NULL) {

            Irp = CONTAINING_RECORD (linkage, IRP, Tail.Overlay.ListEntry);
            IrpSp = IoGetCurrentIrpStackLocation (Irp);

            Connection = IRP_RECEIVE_CONNECTION(IrpSp);

            if (Connection == NULL) {
#if DBG
                DbgPrint ("Connection of Irp %lx is NULL\n", Irp);
                DbgBreakPoint();
#endif
            }

            IRP_RECEIVE_REFCOUNT(IrpSp) = 0;
            IRP_RECEIVE_IRP (IrpSp) = NULL;

            LEAVE_NBF;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            ENTER_NBF;

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            if (Connection->Flags & CONNECTION_FLAGS_RC_PENDING) {

                Connection->Flags &= ~CONNECTION_FLAGS_RC_PENDING;

                if (Connection->Flags & CONNECTION_FLAGS_PEND_INDICATE) {

                    Connection->Flags &= ~CONNECTION_FLAGS_PEND_INDICATE;

                    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                    //
                    // We got an indicate (and sent a NO_RECEIVE) while
                    // this was in progress, so send the receive outstanding
                    // now.
                    //

                    NbfSendReceiveOutstanding (Connection);

                } else {

                    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                }

            } else {

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            }

            NbfDereferenceConnectionMacro ("receive completed", Connection, CREF_RECEIVE_IRP);

        } else {

            //
            // ExInterlockedRemoveHeadList returned NULL, so don't
            // bother looping back.
            //

            break;

        }

    }


    //
    // Packetize all waiting connections
    //

    if (!IsListEmpty(&DeviceContext->PacketizeQueue)) {

        PacketizeConnections (DeviceContext);

    }

    if (!IsListEmpty (&DeviceContext->DeferredRrQueue)) {

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->Interlock);

        while (!IsListEmpty(&DeviceContext->DeferredRrQueue)) {

            linkage = RemoveHeadList (&DeviceContext->DeferredRrQueue);

            Link = CONTAINING_RECORD (linkage, TP_LINK, DeferredRrLinkage);

            Link->OnDeferredRrQueue = FALSE;

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->Interlock);

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            StopT2 (Link);                  // we're acking, so no delay req'd.
            NbfSendRr (Link, FALSE, FALSE);   // releases lock

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->Interlock);

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->Interlock);

    }


    //
    // Get every waiting packet, in order...
    //


    if (!IsListEmpty (&DeviceContext->ReceiveInProgress)) {

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        while (!IsListEmpty (&DeviceContext->ReceiveInProgress)) {

            linkage = RemoveHeadList (&DeviceContext->ReceiveInProgress);
            BufferTag = CONTAINING_RECORD( linkage, BUFFER_TAG, Linkage);

            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint1 (" NbfReceiveComplete: Processing Buffer %lx\n", BufferTag);
            }

            //
            // NdisTransferData may have failed at async completion; check and
            // see. If it did, then we discard this packet. If we're still waiting
            // for transfer to complete, go back to sleep and hope (no guarantee!)
            // we get waken up later.
            //

#if DBG
            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint1 (" NbfReceiveComplete: NdisStatus: %s.\n",
                    NbfGetNdisStatus(BufferTag->NdisStatus));
            }
#endif
            if (BufferTag->NdisStatus == NDIS_STATUS_PENDING) {
                InsertHeadList (&DeviceContext->ReceiveInProgress, linkage);
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);
                IF_NBFDBG (NBF_DEBUG_DLC) {
                    NbfPrint0 (" NbfReceiveComplete: Status pending, returning packet to queue.\n");
                }
                KeLowerIrql (oldirql2);
                LEAVE_NBF;
                return;
            }

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            if (BufferTag->NdisStatus != NDIS_STATUS_SUCCESS) {
#if DBG
                NbfPrint1 (" NbfReceiveComplete: Failed return from Transfer data, reason: %s\n",
                    NbfGetNdisStatus (BufferTag->NdisStatus));
#endif
                goto FreeBuffer;   // skip the buffer, continue with while loop
            }

            //
            // Have a buffer. Since I allocated the storage for it, I know it's
            // virtually contiguous and can treat it that way, which I will
            // henceforth.
            //

            NdisQueryBuffer (BufferTag->NdisBuffer, &BufferPointer, &NdisBufferLength);

            IF_NBFDBG (NBF_DEBUG_DLC) {
                PUCHAR pc;
                NbfPrint0 (" NbfRC Packet: \n   ");
                pc = (PUCHAR)BufferPointer;
                for (i=0;i<25;i++) {
                    NbfPrint1 (" %2x",pc[i]);
                }
                NbfPrint0 ("\n");
            }

            //
            // Determine what address this is for, which is stored
            // in the buffer tag header.
            //

            Address = BufferTag->Address;

            //
            // Process the frame as a UI frame; only datagrams should
            // be processed here. If Address is NULL then this datagram
            // is not needed for any bound address and should be given
            // to RAS only.
            //


            IF_NBFDBG (NBF_DEBUG_DLC) {
                NbfPrint0 (" NbfReceiveComplete:  Delivering this frame manually.\n");
            }
            DlcHeader = (PDLC_FRAME)BufferPointer;
            Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);
            UHeader = (PDLC_U_FRAME)DlcHeader;

            BufferPointer = (PUCHAR)BufferPointer + 3;
            NdisBufferLength -= 3;                         // 3 less bytes.

            if (Address != NULL) {

                //
                // Indicate it or complete posted datagrams.
                //

                Status = NbfIndicateDatagram (
                    DeviceContext,
                    Address,
                    BufferPointer,    // the Dsdu, with some tweaking
                    NdisBufferLength);

                //
                // Dereference the address.
                //

                NbfDereferenceAddress ("Datagram done", Address, AREF_PROCESS_DATAGRAM);

            }

            //
            // Let the RAS clients have a crack at this if they want
            // (they only want directed datagrams, not broadcast).
            //

            if ((((PNBF_HDR_CONNECTIONLESS)BufferPointer)->Command == NBF_CMD_DATAGRAM) &&
                (DeviceContext->IndicationQueuesInUse)) {

                NbfActionDatagramIndication(
                     DeviceContext,
                     (PNBF_HDR_CONNECTIONLESS)BufferPointer,
                     NdisBufferLength);

            }

            BufferPointer = (PUCHAR)BufferPointer - 3;
            NdisBufferLength += 3;         // 3 more bytes.

            //
            // Finished with buffer; return to pool.
            //

FreeBuffer:;

            NdisAdjustBufferLength (BufferTag->NdisBuffer, BufferTag->Length);
            ExInterlockedPushEntryList(
                &DeviceContext->ReceiveBufferPool,
                (PSINGLE_LIST_ENTRY)&BufferTag->Linkage,
                &DeviceContext->Interlock);

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    } // if queue not empty

    KeLowerIrql (oldirql2);
    LEAVE_NBF;
    return;

}   /* NbfReceiveComplete */


VOID
NbfTransferLoopbackData (
    OUT PNDIS_STATUS NdisStatus,
    IN PDEVICE_CONTEXT DeviceContext,
    IN NDIS_HANDLE ReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer,
    IN PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred
    )

/*++

Routine Description:

    This routine is called instead of NdisTransferData for
    loopback indications. It copies the data from the
    source packet to the receive packet.

Arguments:

    NdisStatus - Returns the status of the operation.

    DeviceContext - The device context.

    ReceiveContext - A pointer to the source packet.

    ByteOffset - The offset from the start of the source packet
        that the transfer should begin at.

    BytesToTransfer - The number of bytes to transfer.

    Packet - A pointer to the receive packet.

    BytesTransferred - Returns the number of bytes copied.

Return Value:

    None.

--*/

{
    PNDIS_PACKET SourcePacket = (PNDIS_PACKET)ReceiveContext;

    NdisCopyFromPacketToPacket(
        Packet,
        0,
        BytesToTransfer,
        SourcePacket,
        DeviceContext->LoopbackHeaderLength + ByteOffset,
        BytesTransferred
        );

    *NdisStatus = NDIS_STATUS_SUCCESS;  // what if BytesTransferred is too small

}


VOID
NbfCopyFromPacketToBuffer(
    IN PNDIS_PACKET Packet,
    IN UINT Offset,
    IN UINT BytesToCopy,
    OUT PCHAR Buffer,
    OUT PUINT BytesCopied
    )

/*++

Routine Description:

    Copy from an ndis packet into a buffer.

Arguments:

    Packet - The packet to copy from.

    Offset - The offset from which to start the copy.

    BytesToCopy - The number of bytes to copy from the packet.

    Buffer - The destination of the copy.

    BytesCopied - The number of bytes actually copied.  Can be less then
    BytesToCopy if the packet is shorter than BytesToCopy.

Return Value:

    None

--*/

{

    //
    // Holds the number of ndis buffers comprising the packet.
    //
    UINT NdisBufferCount;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER CurrentBuffer;

    //
    // Holds the virtual address of the current buffer.
    //
    PVOID VirtualAddress;

    //
    // Holds the length of the current buffer of the packet.
    //
    UINT CurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy) return;

    //
    // Get the first buffer.
    //

    NdisQueryPacket(
        Packet,
        NULL,
        &NdisBufferCount,
        &CurrentBuffer,
        NULL
        );

    //
    // Could have a null packet.
    //

    if (!NdisBufferCount) return;

    NdisQueryBuffer(
        CurrentBuffer,
        &VirtualAddress,
        &CurrentLength
        );

    while (LocalBytesCopied < BytesToCopy) {

        if (!CurrentLength) {

            NdisGetNextBuffer(
                CurrentBuffer,
                &CurrentBuffer
                );

            //
            // We've reached the end of the packet.  We return
            // with what we've done so far. (Which must be shorter
            // than requested.
            //

            if (!CurrentBuffer) break;

            NdisQueryBuffer(
                CurrentBuffer,
                &VirtualAddress,
                &CurrentLength
                );
            continue;

        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (Offset) {

            if (Offset > Curr