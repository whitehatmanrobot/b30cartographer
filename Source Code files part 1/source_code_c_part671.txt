eInfo.if_indiscards        = pInterface->ulInDiscards;
    pInfo->ifeInfo.if_inerrors          = pInterface->ulInErrors;
    pInfo->ifeInfo.if_inunknownprotos   = pInterface->ulInUnknownProto;
    pInfo->ifeInfo.if_outoctets         = pInterface->ulOutOctets;
    pInfo->ifeInfo.if_outucastpkts      = pInterface->ulOutUniPkts;
    pInfo->ifeInfo.if_outnucastpkts     = pInterface->ulOutNonUniPkts;
    pInfo->ifeInfo.if_outdiscards       = pInterface->ulOutDiscards;
    pInfo->ifeInfo.if_outerrors         = pInterface->ulOutErrors;

    RtReleaseSpinLock(&(pInterface->rlLock),
                      kiIrql);

    DereferenceInterface(pInterface);
   
    pInfo->ifeInfo.if_type          = IF_TYPE_PPP;
    pInfo->ifeInfo.if_physaddrlen   = ARP_802_ADDR_LENGTH;
    pInfo->ifeInfo.if_descrlen      = 0;

    RtlZeroMemory(pInfo->ifeInfo.if_physaddr,
                  MAX_PHYSADDR_SIZE);
 
    pIrp->IoStatus.Information = 
        FIELD_OFFSET(WANARP_GET_IF_STATS_INFO, ifeInfo) + IFE_FIXED_SIZE;
    
    return STATUS_SUCCESS;
}

NTSTATUS
WanDeleteAdapters(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:

    Handler for IOCTL_WANARP_DELETE_ADAPTERS.
    The caller indicates to us the number of adapters that she wants
    removed. If we have that many free adapters, we remove them and
    return the names of the devices, removed.
    
Locks: 

    Acquires the g_rwlAdaptersLock as WRITER
    
Arguments:
      

Return Value:

    STATUS_BUFFER_TOO_SMALL
    STATUS_SUCCESS

--*/

{
    KIRQL               kiIrql;
    PADAPTER            pAdapter;
    PVOID               pvIoBuffer;
    ULONG               i;
    PLIST_ENTRY         pleNode;
    LIST_ENTRY          leTempHead;
    PVOID               pvNameBuffer;
    NTSTATUS            nStatus;
    KEVENT              keChangeEvent; 

    PWANARP_DELETE_ADAPTERS_INFO    pDeleteInfo;

    TraceEnter(ADPT, "DeleteAdapters");
    
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pIrp->IoStatus.Information = 0;

    if(ulInLength < sizeof(WANARP_DELETE_ADAPTERS_INFO))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    pDeleteInfo = (PWANARP_DELETE_ADAPTERS_INFO)pvIoBuffer;

    //
    // Dont service binds or unbinds here
    //

    WanpAcquireResource(&g_wrBindMutex);

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);
    
    if(pDeleteInfo->ulNumAdapters > g_ulNumFreeAdapters + g_ulNumAddedAdapters)
    {
        //
        // Asking to delete more adapters than are present
        //

        pIrp->IoStatus.Information = g_ulNumFreeAdapters + g_ulNumAddedAdapters;

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);
 
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // So there are enough unmapped adapters. See if we have enough space to
    // return the names of the adapters
    //

    if(ulOutLength < 
        FIELD_OFFSET(WANARP_DELETE_ADAPTERS_INFO, rgAdapterGuid[0]) + 
        (pDeleteInfo->ulNumAdapters * sizeof(GUID)))
    {
        //
        // Not enough space to hold the names
        //

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        pIrp->IoStatus.Information =
            FIELD_OFFSET(WANARP_DELETE_ADAPTERS_INFO, rgAdapterGuid[0]) +
            (pDeleteInfo->ulNumAdapters * sizeof(GUID));

        return STATUS_BUFFER_TOO_SMALL;
    }

    pIrp->IoStatus.Information = 
        FIELD_OFFSET(WANARP_DELETE_ADAPTERS_INFO, rgAdapterGuid[0]) +
        (pDeleteInfo->ulNumAdapters * sizeof(GUID)); 
    
    //
    // Everything's good. First see if we can remove the ones we want
    // removed from the free list
    //
   
    i = 0;

    while((i < pDeleteInfo->ulNumAdapters) and
          (!IsListEmpty(&g_leFreeAdapterList)))
    {
        pleNode = RemoveHeadList(&g_leFreeAdapterList);

        g_ulNumFreeAdapters--;

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        RtAssert(pAdapter->byState is AS_FREE);
        RtAssert(pAdapter->pInterface is NULL);

        //
        // Copy out the name
        // TCPIP_IF_PREFIX is \Device and we need to remove \Device\
        //

        ConvertStringToGuid(
            &(pAdapter->usDeviceNameW.Buffer[wcslen(TCPIP_IF_PREFIX) + 1]),
            pAdapter->usDeviceNameW.Length - ((wcslen(TCPIP_IF_PREFIX) + 1) * sizeof(WCHAR)),
            &(pDeleteInfo->rgAdapterGuid[i])
            );

        i++;
                           
        //
        // Deref it for removing it from the list. This should delete
        // it
        //

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        DereferenceAdapter(pAdapter);
    }

    if(i is pDeleteInfo->ulNumAdapters)
    {
        //
        // We are done
        //

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        return STATUS_SUCCESS;
    }
    
    //
    // Need to get some added adapters deleted, too
    //
    
    InitializeListHead(&leTempHead);
       
    while((i < pDeleteInfo->ulNumAdapters) and
          (!IsListEmpty(&g_leAddedAdapterList)))
    {
        pleNode = RemoveHeadList(&g_leAddedAdapterList);

        g_ulNumAddedAdapters--;
        
        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);
       
        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        pAdapter->byState = AS_REMOVING;
 
        InsertHeadList(&leTempHead,
                       &(pAdapter->leAdapterLink));
        
        //
        // Copy out the name
        //
      
        ConvertStringToGuid(
            &(pAdapter->usDeviceNameW.Buffer[wcslen(TCPIP_IF_PREFIX) + 1]),
            pAdapter->usDeviceNameW.Length - ((wcslen(TCPIP_IF_PREFIX) + 1) * sizeof(WCHAR)),
            &(pDeleteInfo->rgAdapterGuid[i])
            );

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
 
        i++; 
    }
    
    //
    // We better have enough adapters
    //
    
    RtAssert(i is pDeleteInfo->ulNumAdapters);
    
    //
    // Now we can let go of the lock
    //

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);
   
    KeInitializeEvent(&keChangeEvent,
                      SynchronizationEvent,
                      FALSE);
 
    //
    // Loop through and delete the adapters
    //

    while(!IsListEmpty(&leTempHead))
    {
        pleNode = RemoveHeadList(&leTempHead);

        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        //
        // Insert it into the change list
        //

        InsertHeadList(&g_leChangeAdapterList,
                       &(pAdapter->leAdapterLink));

        //
        // Set the event to block on
        //

        RtAssert(pAdapter->pkeChangeEvent is NULL);

        pAdapter->pkeChangeEvent = &keChangeEvent;

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        g_pfnIpDeleteInterface(pAdapter->pvIpContext,
                               FALSE);

        //
        // Wait till the CloseAdapter completes
        //

        nStatus = KeWaitForSingleObject(&keChangeEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        //
        // Remove from the change list
        //

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

#if DBG

        RtAssert(IsEntryOnList(&g_leChangeAdapterList,
                               &(pAdapter->leAdapterLink)));

#endif

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        RemoveEntryList(&(pAdapter->leAdapterLink));

        pAdapter->byState  = 0xFF;

        pAdapter->pkeChangeEvent = NULL;

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        //
        // Dereference the adapter for removing from the list
        // (CloseAdapter will deref it for removing from IP)
        //

        DereferenceAdapter(pAdapter);
    }

    WanpReleaseResource(&g_wrBindMutex);

    return STATUS_SUCCESS;
}

NTSTATUS
WanMapServerAdapter(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:

    Called by RAS to add the server adapter and map it to an interface. 
    It has to be done before the first client dials in.

Locks:

    Acquires the g_wrBindMutex. Also acquires the adapter list lock and the
    adapter lock

Arguments:


Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    STATUS_NO_SUCH_DEVICE
    STATUS_DIRECTORY_NOT_EMPTY

--*/

{
    NTSTATUS    nStatus;
    PVOID       pvIoBuffer;
    KIRQL       kiIrql;
    WCHAR       rgwcGuid[GUID_STR_LEN + 1];
    PLIST_ENTRY pleNode;
    PADAPTER    pTempAdapter;
    KEVENT      keTempEvent;

    UNICODE_STRING      usTempName;
    PUMODE_INTERFACE    pInterface;

    PWANARP_MAP_SERVER_ADAPTER_INFO pInfo;

    TraceEnter(ADPT, "MapServerAdapter");

    pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

    pInfo = (PWANARP_MAP_SERVER_ADAPTER_INFO)pvIoBuffer;

    pIrp->IoStatus.Information = 0;

    if((ulOutLength < sizeof(WANARP_MAP_SERVER_ADAPTER_INFO)) or
       (ulInLength < sizeof(WANARP_MAP_SERVER_ADAPTER_INFO)))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    WanpAcquireResource(&g_wrBindMutex);

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    if(g_pServerAdapter is NULL)
    {
        Trace(ADPT, ERROR,
              ("MapServerAdapter: No server adapter\n"));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        return STATUS_NO_SUCH_DEVICE;
    }

    RtAssert(g_pServerInterface);

    //
    // Lock the adapter and change the state to let people know we are
    // trying to add  or remove the adapter, hence they should wait on the 
    // global event
    //

    RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

    if(pInfo->fMap is 0)
    {
        //
        // Trying to unmap
        //

        pIrp->IoStatus.Information = 0;

        if(g_pServerAdapter->byState is AS_FREE)
        {
            //
            // Nothing to do
            //

            RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            WanpReleaseResource(&g_wrBindMutex);

            return STATUS_SUCCESS;
        }

        //
        // Since add is serialized, the only other state is AS_MAPPED
        //

        RtAssert(g_pServerAdapter->byState is AS_MAPPED);

        //
        // Make sure there are no new connections
        //

        if(!WanpIsConnectionTableEmpty())
        {
            Trace(ADPT, ERROR,
                  ("MapServerAdapter: Connection Table not empty\n"));

            // RtAssert(FALSE);

            RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

            ExitWriter(&g_rwlAdapterLock,
                       kiIrql);

            WanpReleaseResource(&g_wrBindMutex);

            return STATUS_DIRECTORY_NOT_EMPTY;
        }

        //
        // Remove the adapter from ip, remove the cross ref
        //

        //
        // Since we are changing the state, no one else should be also
        // changing the state
        //

        RtAssert(g_pServerAdapter->pkeChangeEvent is NULL);

        KeInitializeEvent(&keTempEvent,
                          SynchronizationEvent,
                          FALSE);

        g_pServerAdapter->pkeChangeEvent = &keTempEvent;

        ReferenceAdapter(g_pServerAdapter);

        g_pServerAdapter->byState = AS_REMOVING;

        RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        //
        // Delete from IP, but dont clear the index
        //

        g_pfnIpDeleteInterface(g_pServerAdapter->pvIpContext,
                               FALSE);

        nStatus = KeWaitForSingleObject(&keTempEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        RtAssert(nStatus is STATUS_SUCCESS);

        EnterWriter(&g_rwlAdapterLock,
                    &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

#if DBG

        Trace(ADPT, INFO,
              ("MapServerAdapter: Removed %s (server adapter) from Ip\n",
               g_pServerAdapter->asDeviceNameA.Buffer));

#endif

        g_pServerAdapter->pkeChangeEvent = NULL;

        g_pServerAdapter->byState    = AS_FREE;
        g_pServerInterface->pAdapter = NULL;
        g_pServerAdapter->pInterface = NULL;

        //
        // deref because of the cross ref
        //

        DereferenceAdapter(g_pServerAdapter);
        DereferenceInterface(g_pServerInterface);

        g_pServerAdapter->dwAdapterIndex = 0;

        //
        // If anyone is waiting on a state change, notify them
        //

        for(pleNode = g_pServerAdapter->leEventList.Flink;
            pleNode isnot &(g_pServerAdapter->leEventList);
            pleNode = pleNode->Flink)
        {
            PWAN_EVENT_NODE pTempEvent;

            pTempEvent = CONTAINING_RECORD(pleNode,
                                           WAN_EVENT_NODE,
                                           leEventLink);

            KeSetEvent(&(pTempEvent->keEvent),
                       0,
                       FALSE);
        }

        pTempAdapter = g_pServerAdapter;

        RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        DereferenceAdapter(pTempAdapter);

        return STATUS_SUCCESS;
    }


    if(g_pServerAdapter->byState isnot AS_FREE)
    {
        //
        // Valid states are AS_FREE, AS_ADDING, AS_MAPPED.
        // It can not be in the process of being added since the resource
        // is acquired
        //

        RtAssert(g_pServerAdapter->byState is AS_MAPPED);

        RtAssert(g_pServerAdapter->pInterface is g_pServerInterface);
        RtAssert(g_pServerInterface->pAdapter is g_pServerAdapter);

        pInfo->dwAdapterIndex = g_pServerAdapter->dwAdapterIndex;

        RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

        WanpReleaseResource(&g_wrBindMutex);

        pIrp->IoStatus.Information = sizeof(WANARP_MAP_SERVER_ADAPTER_INFO);

        return STATUS_SUCCESS;
    }

    RtAssert(g_pServerInterface->pAdapter is NULL);
    RtAssert(g_pServerAdapter->pInterface is NULL);

    ReferenceAdapter(g_pServerAdapter);

    g_pServerAdapter->byState = AS_ADDING;

    //
    // Since we are changing the state, no one else should be also
    // changing the state
    //

    RtAssert(g_pServerAdapter->pkeChangeEvent is NULL)

    KeInitializeEvent(&keTempEvent,
                      SynchronizationEvent,
                      FALSE);

    g_pServerAdapter->pkeChangeEvent = &keTempEvent;

    RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));
        
    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    usTempName.MaximumLength = (GUID_STR_LEN + 1) * sizeof(WCHAR);
    usTempName.Length        = GUID_STR_LEN * sizeof(WCHAR);
    usTempName.Buffer        = rgwcGuid;

    ConvertGuidToString(&(g_pServerInterface->Guid),
                        rgwcGuid);
    
    nStatus = WanpAddAdapterToIp(g_pServerAdapter,
                                 TRUE,
                                 g_pServerInterface->dwRsvdAdapterIndex,
                                 &usTempName,
                                 IF_TYPE_PPP,
                                 IF_ACCESS_POINTTOMULTIPOINT,
                                 IF_CONNECTION_PASSIVE);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(ADPT, ERROR,
              ("MapServerAdapter: %x adding %x to IP\n",
               nStatus, g_pServerAdapter));

        EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

        RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

        g_pServerAdapter->byState = AS_FREE;

        g_pServerAdapter->pkeChangeEvent = NULL;

        //
        // If anyone is waiting on a state change, notify them
        //

        for(pleNode = g_pServerAdapter->leEventList.Flink;
            pleNode isnot &(g_pServerAdapter->leEventList);
            pleNode = pleNode->Flink)
        {
            PWAN_EVENT_NODE pTempEvent;

            pTempEvent = CONTAINING_RECORD(pleNode,
                                           WAN_EVENT_NODE,
                                           leEventLink);

            KeSetEvent(&(pTempEvent->keEvent),
                       0,
                       FALSE);
        }

        pTempAdapter = g_pServerAdapter;

        RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

        ExitWriter(&g_rwlAdapterLock,
                   kiIrql);

#if DBG

        Trace(ADPT, ERROR,
              ("MapServerAdapter: Couldnt add  %s to Ip as server adapter\n",
               pTempAdapter->asDeviceNameA.Buffer));

#endif

        DereferenceAdapter(pTempAdapter);

        WanpReleaseResource(&g_wrBindMutex);

        return nStatus;
    }

    //
    // Wait till the OpenAdapter is called
    //

    nStatus = KeWaitForSingleObject(&keTempEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    RtAssert(nStatus is STATUS_SUCCESS);

    Trace(ADPT, TRACE,
          ("MapServerAdapter: IPAddInterface succeeded for adapter %w\n",
           g_pServerAdapter->usDeviceNameW.Buffer));

    EnterWriter(&g_rwlAdapterLock,
                &kiIrql);

    RtAcquireSpinLockAtDpcLevel(&(g_pServerAdapter->rlLock));

    //
    // Cross ref the structures
    //

    g_pServerAdapter->pInterface = g_pServerInterface;
    g_pServerInterface->pAdapter = g_pServerAdapter;

    g_pServerAdapter->byState       = AS_MAPPED;
    g_pServerInterface->dwOperState = IF_OPER_STATUS_CONNECTED;
    g_pServerInterface->dwLastChange= GetTimeTicks();

    //
    // bump the refcount because of the cross ref
    //

    ReferenceAdapter(g_pServerAdapter);
    ReferenceInterface(g_pServerInterface);

    pInfo->dwAdapterIndex = g_pServerAdapter->dwAdapterIndex;

    g_pServerAdapter->pkeChangeEvent = NULL;

    //
    // If anyone is waiting on a state change, notify them
    //

    for(pleNode = g_pServerAdapter->leEventList.Flink;
        pleNode isnot &(g_pServerAdapter->leEventList);
        pleNode = pleNode->Flink)
    {
        PWAN_EVENT_NODE pTempEvent;

        pTempEvent = CONTAINING_RECORD(pleNode,
                                       WAN_EVENT_NODE,
                                       leEventLink);

        KeSetEvent(&(pTempEvent->keEvent),
                   0,
                   FALSE);
    }

    pTempAdapter = g_pServerAdapter;

    RtReleaseSpinLockFromDpcLevel(&(g_pServerAdapter->rlLock));

    ExitWriter(&g_rwlAdapterLock,
               kiIrql);

    DereferenceAdapter(pTempAdapter);

    WanpReleaseResource(&g_wrBindMutex);

    pIrp->IoStatus.Information = sizeof(WANARP_MAP_SERVER_ADAPTER_INFO);

    return STATUS_SUCCESS;

}


NTSTATUS
WanStartStopQueuing(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:
      
    The handler for IOCTL_WANARP_QUEUE.
    It is used to start or stop queuing notifications to the router manager.
    On start, we return the dial out interfaces that we currently have.
    
Locks: 

    Acquires the IoCancelSpinLock
    
Arguments:
      
    
Return Value:

    STATUS_PENDING
    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    
--*/

{
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    PVOID       pvIoBuffer;
    ULONG       i, ulMaxInterfaces, ulSizeReq;
   
    PWANARP_QUEUE_INFO      pQueueInfo;
    PPENDING_NOTIFICATION   pNotification;

    TraceEnter(GLOBAL, "StartStopQueuing");
 
    pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
    
    pIrp->IoStatus.Information = 0;

    if(ulInLength < FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // use cancel spin lock to prevent irp being cancelled during this call.
    //
    
    IoAcquireCancelSpinLock(&kiIrql);

    //
    // If the user is stopping queueing, delete all the pending notifications
    //
   
    pQueueInfo = (PWANARP_QUEUE_INFO)pvIoBuffer; 

    if(!pQueueInfo->fQueue)
    {
        g_bQueueNotifications = FALSE;
    
        while(!IsListEmpty(&g_lePendingNotificationList))
        {
            //
            // We have some old info
            // Remove it off the pending list
            //
        
            pleNode = RemoveHeadList(&g_lePendingNotificationList);

            //
            // Get a pointer to the structure
            //
        
            pNotification = CONTAINING_RECORD(pleNode,
                                              PENDING_NOTIFICATION,
                                              leNotificationLink);
        
            //
            // Free the allocated notification
            //
        
            FreeNotification(pNotification);
        }

        //
        // Done
        //

        IoReleaseCancelSpinLock(kiIrql);
       
        WanpClearPendingIrps();
 
        return STATUS_SUCCESS;
    }

    //
    // The user wants to start queueing
    // See if she has given us enough space to copy out
    // the current dial outs
    //

    if(ulOutLength < FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo))
    {
        IoReleaseCancelSpinLock(kiIrql);
        
        return STATUS_BUFFER_TOO_SMALL;
    }

    EnterReaderAtDpcLevel(&g_rwlAdapterLock);
    
    ulSizeReq = FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo) +
                (g_ulNumDialOutInterfaces * sizeof(WANARP_IF_INFO));
    

    pQueueInfo->ulNumCallout = g_ulNumDialOutInterfaces;
    
    if(ulOutLength < ulSizeReq)
    {
        pIrp->IoStatus.Information = FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo);

        ExitReaderFromDpcLevel(&g_rwlAdapterLock);
        
        IoReleaseCancelSpinLock(kiIrql);
        
        return STATUS_MORE_ENTRIES;
    }

    ulMaxInterfaces = 
        (ulOutLength - FIELD_OFFSET(WANARP_QUEUE_INFO, rgIfInfo)) / sizeof(WANARP_IF_INFO);
    
    //
    // Have enough space
    // Walk the list of mapped adapters looking for CALLOUTs
    //

    for(i = 0, pleNode = g_leMappedAdapterList.Flink;
        pleNode isnot &g_leMappedAdapterList;
        pleNode = pleNode->Flink)
    {
        PUMODE_INTERFACE    pIf;
        PADAPTER            pAdapter;
        PCONN_ENTRY         pConnEntry;
        
        pAdapter = CONTAINING_RECORD(pleNode,
                                     ADAPTER,
                                     leAdapterLink);

        //
        // Lock the adapter and check its connection entry
        //

        RtAcquireSpinLockAtDpcLevel(&(pAdapter->rlLock));

        pConnEntry = pAdapter->pConnEntry;

        if(pConnEntry and
           (pConnEntry->duUsage is DU_CALLOUT))
        {
            RtAssert(i < ulMaxInterfaces);

            pIf = pAdapter->pInterface;

            RtAssert(pIf);
            RtAssert(pIf->dwRsvdAdapterIndex);

            pQueueInfo->rgIfInfo[i].InterfaceGuid   = pIf->Guid;
            pQueueInfo->rgIfInfo[i].dwAdapterIndex  = pIf->dwRsvdAdapterIndex;
            pQueueInfo->rgIfInfo[i].dwLocalAddr     = pConnEntry->dwLocalAddr;
            pQueueInfo->rgIfInfo[i].dwLocalMask     = pConnEntry->dwLocalMask;
            pQueueInfo->rgIfInfo[i].dwRemoteAddr    = pConnEntry->dwRemoteAddr;

            i++;
        }

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
    }

    g_bQueueNotifications = TRUE;

    ExitReaderFromDpcLevel(&g_rwlAdapterLock);
    
    IoReleaseCancelSpinLock(kiIrql);

    pIrp->IoStatus.Information = ulSizeReq;

    return STATUS_SUCCESS;
}


VOID
WanCancelNotificationIrp(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp
    )

/*++

Routine Description:

    Called to cancel a queued irp
  
Locks: 


Arguments:
      

Return Value:


--*/

{
    Trace(GLOBAL, TRACE,
          ("CancelNotificationIrp\n"));


    //
    // Mark this Irp as cancelled
    //
    
    pIrp->IoStatus.Status        = STATUS_CANCELLED;
    pIrp->IoStatus.Information   = 0;

    //
    // Take off our own list
    //
    
    RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

    //
    // Release cancel spin lock which the IO system acquired
    //
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    IoCompleteRequest(pIrp,
                      IO_NETWORK_INCREMENT);
}


VOID
WanpCompleteIrp(
    PPENDING_NOTIFICATION    pEvent
    )

/*++

Routine Description:

    Completes a notification irp.
  
Locks: 


Arguments:
      

Return Value:


--*/

{
    KIRQL   kiIrql;
    
    Trace(GLOBAL, TRACE,
          ("Completing Notification Irp\n"));

    //
    // grab cancel spin lock
    //
    
    IoAcquireCancelSpinLock(&kiIrql);

    if(!g_bQueueNotifications)
    {
        IoReleaseCancelSpinLock(kiIrql);

        FreeNotification(pEvent);

        return;
    }

    if(!IsListEmpty(&g_lePendingIrpList))
    {
        PLIST_ENTRY pleNode;
        PIRP        pIrp;

        //
        // We have a pending IRP. Use it to return info to router manager
        //
        
        pleNode = RemoveHeadList(&g_lePendingIrpList) ;

        pIrp = CONTAINING_RECORD(pleNode,
                                 IRP,
                                 Tail.Overlay.ListEntry);
        
        RtlCopyMemory(pIrp->AssociatedIrp.SystemBuffer,
                      &(pEvent->wnMsg),
                      sizeof(WANARP_NOTIFICATION));
        
        Trace(GLOBAL, TRACE,
              ("Returning Irp with event code of %d\n",
               ((PWANARP_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer)->ddeEvent));
        
        IoSetCancelRoutine(pIrp,
                           NULL);

        pIrp->IoStatus.Status       = STATUS_SUCCESS;
        pIrp->IoStatus.Information  = sizeof(WANARP_NOTIFICATION);

        //
        // release lock
        //
        
        IoReleaseCancelSpinLock(kiIrql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Free the allocated notification
        //
        
        FreeNotification(pEvent);

    }
    else
    {
        Trace(GLOBAL, TRACE,
              ("Found no pending Irp so queuing the notification\n"));

        
        InsertTailList(&g_lePendingNotificationList,
                       &(pEvent->leNotificationLink));

        //
        // release lock
        //
        
        IoReleaseCancelSpinLock(kiIrql);
    }
}


NTSTATUS
WanpGetNewIndex(
    OUT PULONG  pulIndex
    )

/*++

Routine Description:

    Gets a new interface index from IP

Locks:

    None

Arguments:

    pulIndex    OUT interface index

Return Value:


--*/

{
    ULONG   ulMax;

    *pulIndex = INVALID_IF_INDEX;

    return g_pfnIpReserveIndex(1, pulIndex, &ulMax);
}
       
VOID
WanpFreeIndex(
    IN  ULONG   ulIndex
    )

/*++

Routine Description:

    Frees an index back to IP

Locks:

    None

Arguments:

    ulIndex    

Return Value:


--*/

{
    ULONG   ulMax;

    g_pfnIpDereserveIndex(1,
                          ulIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\wanarp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp2\ipinip.h

Abstract:

    Main header file for the IP in IP encapsulation driver


Revision History:


--*/


#ifndef __WANARP_WANARP_H__
#define __WANARP_WANARP_H___

//
// Symbolic link into DOS space
//

#define WIN32_WANARP_SYMBOLIC_LINK  L"\\DosDevices\\WanArp"


//
// ARP name (for IP). Also goes into LLInterface
//

#define WANARP_ARP_NAME             WANARP_SERVICE_NAME_W

//
// Name for NDIS. NDIS requires us to have a TCPIP_ in front of the name
//

#define WANARP_NDIS_NAME            L"TCPIP_WANARP"


//
// Need to prefix all our device names with this when we give name to
// IP. We assume that the name we cat is of type \<Name>
//

#define TCPIP_IF_PREFIX             L"\\DEVICE"

//
// The prefix for the registry key
//

#define TCPIP_REG_PREFIX            L"\\Tcpip\\Parameters\\Interfaces\\"

//
// Length of a GUID
//

#define GUID_STR_LEN                (38)

//
// We look like an 802.x ARP interface
//

#define ARP_802_ADDR_LENGTH     6

//
// Macro for building a 802.3 hw address given an index. 
// We do this since our adapters do not have a real net card associated with
// them
//

#define HW_NAME_SEED            "\0SExx\0"

#define BuildHardwareAddrFromIndex(addr,index) {                \
                RtlCopyMemory(addr, HW_NAME_SEED, 6);           \
                addr[3] = (uchar) index >> 8;                   \
                addr[4] = (uchar) index;                        \
}

//
// The default speed and MTU. We change the MTU when we get a better estimate
// but the speed remains the same
//

#define WANARP_DEFAULT_MTU      1500
#define WANARP_DEFAULT_SPEED    28000

#define MEDIA_802_3             0           // index of media

#define WANARP_LOOKAHEAD_SIZE   128         // A reasonable lookahead size
#define MIN_ETYPE               0x600       // Minimum valid Ethertype


#define ARP_ETYPE_IP            0x800       // Standard ETYPE

//
// Max number of packets a connection can have pending
//

#define WANARP_MAX_PENDING_PACKETS      32

//
// Initial size of packet pool
//

#define WAN_PACKET_POOL_COUNT           64

//
// Max outstanding packets:
// Allow 64 connections to be maxed out pending, and 64 others to have 
// 2 packets outstanding
//

#define WAN_PACKET_POOL_OVERFLOW        ((WANARP_MAX_PENDING_PACKETS * 64) + (2 * 64))

#define CompareUnicodeStrings(S1,S2)                    \
    (((S1)->Length == (S2)->Length) &&                  \
     (RtlCompareMemory((S1)->Buffer,                    \
                       (S2)->Buffer,                    \
                       (S2)->Length) == (S2)->Length))


#define MIN(a,b)    ((a) < (b)?a:b)

//
// Functions which are called at passive but acquire spinlocks
//

#define PASSIVE_ENTRY()   PAGED_CODE()
#define PASSIVE_EXIT()    PAGED_CODE()

//
// Nifty macro for printing IP Addresses
//

#define PRINT_IPADDR(x) \
    ((x)&0x000000FF),(((x)&0x0000FF00)>>8),(((x)&0x00FF0000)>>16),(((x)&0xFF000000)>>24)

//
// 0.0.0.0 is an invalid address
//

#define INVALID_IP_ADDRESS  0x00000000

#define IsUnicastAddr(X)    ((DWORD)((X) & 0x000000F0) < (DWORD)(0x000000E0))
#define IsClassDAddr(X)     (((X) & 0x000000F0) == 0x000000E0)

//
// IPv4 header
//

#include <packon.h>

typedef struct _IP_HEADER
{
    BYTE      byVerLen;         // Version and length.
    BYTE      byTos;            // Type of service.
    WORD      wLength;          // Total length of datagram.
    WORD      wId;              // Identification.
    WORD      wFlagOff;         // Flags and fragment offset.
    BYTE      byTtl;            // Time to live.
    BYTE      byProtocol;       // Protocol.
    WORD      wXSum;            // Header checksum.
    DWORD     dwSrc;            // Source address.
    DWORD     dwDest;           // Destination address.
}IP_HEADER, *PIP_HEADER;

#define LengthOfIpHeader(X)   (ULONG)((((X)->byVerLen) & 0x0F)<<2)

typedef struct  _ETH_HEADER
{
    //
    // 6 byte destination address
    //

    BYTE        rgbyDestAddr[ARP_802_ADDR_LENGTH];

    //
    // 6 byte source address
    //

    BYTE        rgbySourceAddr[ARP_802_ADDR_LENGTH];

    //
    // 2 byte type
    //

    WORD        wType;

}ETH_HEADER, *PETH_HEADER;

#include <packoff.h>


#if DBG

//
// Reference history structure.
//

typedef struct _REF_HIST_ENTRY
{
    //
    // time of reference operation
    //

    LARGE_INTEGER       liChangeTime;

    //
    // Refcount after reference operation
    //

    LONG                lRefCount;

    //
    // File where reference operation was invoked
    //

    DWORD               dwFileSig;

    //
    // Line where reference operation was invoked
    //

    DWORD               dwLine;

} REF_HIST_ENTRY, *PREF_HIST_ENTRY;


#define MAX_REF_HISTORY     16

#endif


#define CS_DISCONNECTING    0x00
#define CS_CONNECTING       0x01
#define CS_CONNECTED        0x02

#if DBG

#define CS_IP_DELETED_LINK  0xf0

#endif

//
// The CONN_ENTRY structure defines a connection. There is only one
// CONN_ENTRY for each dial out or router connection. However, on the 
// server adapter, we can have multiple CONN_ENYTRYs - one for each dial
// in client. The fields of a CONN_ENTRY are all READ-ONLY except
// for ulSpeed, ulMtu, pAdapter and byState.
// REFCOUNTS: A CONN_ENTRY is refcounted once when the connection is
// created (LinkUp) and then once for every send. It is deref'ed
// on every SendComplete and then again on CloseLink.
//

typedef struct _CONN_ENTRY
{
    //
    // Back pointer to owning adapter
    //

    struct _ADAPTER     *pAdapter;

    //
    // Connection information
    //

    DWORD               dwLocalAddr;
    DWORD               dwLocalMask;
    DWORD               dwRemoteAddr;

    //
    // IP's context for this link. Only used for DU_CALLIN connections
    //

    PVOID               pvIpLinkContext;

    //
    // Pointer to the lock to use when locking this connection.
    // For clients, this is a pointer to rlLock, while for  others
    // this points to the adapter's lock entry
    //

    PRT_LOCK            prlLock;

    //
    // The lock for this entry. Only used for DU_CALLIN
    //
    
    RT_LOCK             rlLock;

    //
    // Refcount
    //

    LONG                lRefCount;

    //
    // The MTU and speed for this connection
    //

    ULONG               ulMtu;
    ULONG               ulSpeed;

    //
    // The usage (CALLIN, CALLOUT or ROUTER) for the connection
    //

    DIAL_USAGE          duUsage;

    //
    // The slot index in the connection table
    //

    ULONG               ulSlotIndex;

    //
    // Precanned header for this connection
    //

    ETH_HEADER          ehHeader;

    //
    // Flag which determines whether to filter netbios packets or not
    //

    BOOLEAN             bFilterNetBios;

    BYTE                byState;

#if DBG

    DWORD               dwTotalRefOps;
    
    REF_HIST_ENTRY      rheHistory[MAX_REF_HISTORY];

#endif

} CONN_ENTRY, *PCONN_ENTRY;

#include "ref.h"

#define InitConnEntryRefCount(p)    InitStructureRefCount("ConnEntry", (p), 0)

#if DBG

#define ReferenceConnEntry(p)                                   \
{                                                               \
    REF_HIST_ENTRY  __rheTemp;                                  \
    InterlockedIncrement((PLONG)&((p)->dwTotalRefOps));         \
    KeQuerySystemTime(&(__rheTemp.liChangeTime));               \
    __rheTemp.lRefCount = ReferenceStructure("ConnEntry", (p)); \
    __rheTemp.dwFileSig = __FILE_SIG__;                         \
    __rheTemp.dwLine    = __LINE__;                             \
    (p)->rheHistory[((p)->dwTotalRefOps) % MAX_REF_HISTORY] =   \
        __rheTemp;                                              \
}

#define DereferenceConnEntry(p)                                 \
{                                                               \
    REF_HIST_ENTRY  __rheTemp;                                  \
    InterlockedIncrement((PLONG)&((p)->dwTotalRefOps));         \
    KeQuerySystemTime(&(__rheTemp.liChangeTime));               \
    __rheTemp.dwFileSig = __FILE_SIG__;                         \
    __rheTemp.dwLine    = __LINE__;                             \
    if((__rheTemp.lRefCount =                                   \
            InterlockedDecrement(&((p)->lRefCount))) == 0)      \
    {                                                           \
        (p)->rheHistory[((p)->dwTotalRefOps) % MAX_REF_HISTORY] =\
            __rheTemp;                                          \
        WanpDeleteConnEntry((p));                               \
    }                                                           \
    else                                                        \
    {                                                           \
        (p)->rheHistory[((p)->dwTotalRefOps) % MAX_REF_HISTORY] =\
            __rheTemp;                                          \
    }                                                           \
}

#else

#define ReferenceConnEntry(p)       ReferenceStructure("ConnEntry", (p))
#define DereferenceConnEntry(p)     DereferenceStructure("ConnEntry", (p) ,WanpDeleteConnEntry)

#endif

#define AS_FREE             0x00
#define AS_REMOVING         0x01
#define AS_ADDING           0x02
#define AS_ADDED            0x03
#define AS_UNMAPPING        0x04
#define AS_MAPPING          0x05
#define AS_MAPPED           0x06

//
// There are two conditions where an adapter is in AS_MAPPED state yet has
// no connection entry:
// (i) A Server Adapter is mapped, but has a connection table
// (ii) If a demand dial attempt finds an added adapter, it maps it but
// doesnt create the CONN_ENTRY till LinkUp
//


//
// REFCOUNTS: An ADAPTER is referenced once on creation since it lies on
// a list and once when it added to IP. It is referenced when it
// is mapped to an interface since the interface has a pointer to it.
// It is also referenced once for each connection.
// ADAPTERs are dereferenced when they are unmapped from an interface (at
// linkdown or connection failure). They are deref'ed when a CONN_ENTRY
// is finally cleaned out (not at linkdown - rather when the CONN_ENTRY's
// ref goes to 0). They are deref'ed when they are removed from the
// list to be deleted. We also deref them when we get a CloseAdapter from 
// IP
//

typedef struct _ADAPTER
{
    //
    // Link in the list of adapters on this machine
    //

    LIST_ENTRY          leAdapterLink;

    //
    // The connection entry for this adapter. Not used for the Server
    // Adapter since it has many connections on it
    //

    PCONN_ENTRY         pConnEntry;

    //
    // Name of the binding
    //

    UNICODE_STRING      usConfigKey;

    //
    // Name of the device
    //

    UNICODE_STRING      usDeviceNameW;

#if DBG

    //
    // Same thing, only in asciiz so that we can print it easily
    //

    ANSI_STRING         asDeviceNameA;

#endif

    //
    // Lock that protects the adapter
    //

    RT_LOCK             rlLock;

    //
    // The reference count for the structure
    // Keep this and the lock together to make the cache happy
    //

    LONG                lRefCount;

    //
    // The index given to us by IP
    //

    DWORD               dwAdapterIndex;

#if DBG

    DWORD               dwRequestedIndex;

#endif

    //
    // TDI entity magic
    //

    DWORD               dwIfInstance;
    DWORD               dwATInstance;

    //
    // The state of this adapter
    //

    BYTE                byState;

    //
    // The Guid for the adapter
    //

    GUID                Guid;

    //
    // IP's context for this adapter
    //

    PVOID               pvIpContext;

    //
    // The interface that is adapter is mapped to
    //

    struct _UMODE_INTERFACE   *pInterface;

    //
    // The pending packet queue length
    //

    ULONG               ulQueueLen;

    //
    // Queue of pending packets
    //

    LIST_ENTRY          lePendingPktList;
    
    //
    // Queue of header buffers for the pending packets
    //

    LIST_ENTRY          lePendingHdrList;

    //
    // The next two members are used to synchronize state changes for
    // the adapter.  There are two kinds of notifications needed. When a
    // thread is modifying the state using functions which are completed
    // asynchronously, it needs to wait for the completion routine to run
    // The completion routine uses the pkeChangeEvent to notify the original 
    // thread.
    // Also while this change is in progress, other threads may be interested
    // in getting access to the data structure once the state has been
    // modified. They add WAN_EVENT_NODE to the EventList and the original
    // thread then goes about notifying each of the waiters
    //

    PKEVENT             pkeChangeEvent;
    LIST_ENTRY          leEventList;

    BYTE                rgbyHardwareAddr[ARP_802_ADDR_LENGTH];

}ADAPTER, *PADAPTER;

#define InitAdapterRefCount(p)      InitStructureRefCount("Adapter", (p), 1)
#define ReferenceAdapter(p)         ReferenceStructure("Adapter", (p))
#define DereferenceAdapter(p)       DereferenceStructure("Adapter", (p), WanpDeleteAdapter)

typedef struct _UMODE_INTERFACE
{
    //
    // Link on the list of interfaces
    //

    LIST_ENTRY          leIfLink;

    //
    // Pointer to adapter when mapped
    //

    PADAPTER            pAdapter;

    //
    // The (user mode) interface index
    //

    DWORD               dwIfIndex;

    //
    // The reserved index for this interface
    //

    DWORD               dwRsvdAdapterIndex;

    //
    // The lock for the interface
    //

    RT_LOCK             rlLock;

    //
    // The reference count for the structure
    // Keep this and the lock together to make the cache happy
    //

    LONG                lRefCount;

    //
    // The GUID for the interface. This is setup at add interface time
    // for router interfaces and at lineup for callouts
    //

    GUID                Guid;

    //
    // The usage (CALLIN, CALLOUT or ROUTER)
    //

    DIAL_USAGE          duUsage;

    //
    // Count of packets pending. Used to cap the max number of packets 
    // copied when a connection is being brought up
    //

    ULONG               ulPacketsPending;

    //
    // The admin and operational states.
    //

    DWORD               dwAdminState;
    DWORD               dwOperState;

    //
    // Last time the state changed. We dont do anything with this right now
    //

    DWORD               dwLastChange;

    //
    // Sundry MIB-II statistics for the interface
    //

    ULONG               ulInOctets;
    ULONG               ulInUniPkts;
    ULONG               ulInNonUniPkts;
    ULONG               ulInDiscards;
    ULONG               ulInErrors;
    ULONG               ulInUnknownProto;
    ULONG               ulOutOctets;
    ULONG               ulOutUniPkts;
    ULONG               ulOutNonUniPkts;
    ULONG               ulOutDiscards;
    ULONG               ulOutErrors;

}UMODE_INTERFACE, *PUMODE_INTERFACE;

#define InitInterfaceRefCount(p)    InitStructureRefCount("Interface", (p), 1)
#define ReferenceInterface(p)       ReferenceStructure("Interface", (p))
#define DereferenceInterface(p)     DereferenceStructure("Interface", (p), WanpDeleteInterface)

typedef struct _ADDRESS_CONTEXT
{
    //
    // The next RCE in the chain
    //

    RouteCacheEntry    *pNextRce;

    PCONN_ENTRY         pOwningConn;

}ADDRESS_CONTEXT, *PADDRESS_CONTEXT;

//
// Context for an asynchronous NdisRequest
//

typedef
VOID
(* PFNWANARP_REQUEST_COMPLETION_HANDLER)(
    NDIS_HANDLE                         nhHandle,
    struct _WANARP_NDIS_REQUEST_CONTEXT *pRequestContext,
    NDIS_STATUS                         nsStatus
    );

#pragma warning(disable:4201) 

typedef struct _WANARP_NDIS_REQUEST_CONTEXT
{
    //
    // The request sent to NDIS
    // Ndis returns a pointer to this in our completion routine; we
    // use CONTAINING_RECORD to get a pointer to the context structure
    // 

    NDIS_REQUEST                            NdisRequest;

    //
    // The completion routine to call when NDIS is done processing the
    // request. If NULL, then we stop
    //

    PFNWANARP_REQUEST_COMPLETION_HANDLER    pfnCompletionRoutine;

    union
    {
        BYTE                    rgbyProtocolId[ARP_802_ADDR_LENGTH];
        ULONG                   ulLookahead;
        ULONG                   ulPacketFilter;
        TRANSPORT_HEADER_OFFSET TransportHeaderOffset;
    };
        
}WANARP_NDIS_REQUEST_CONTEXT, *PWANARP_NDIS_REQUEST_CONTEXT;

#pragma warning(default:4201)

//
// Our resource (which doesnt allow recursive access)
//

typedef struct _WAN_RESOURCE
{
    //
    // Number of people waiting on the resource ( + 1 if one is using
    // the resource)
    //

    LONG    lWaitCount;

    KEVENT  keEvent;
}WAN_RESOURCE, *PWAN_RESOURCE;

//
// List of events
//

typedef struct _WAN_EVENT_NODE
{
    LIST_ENTRY  leEventLink;
    KEVENT      keEvent;

}WAN_EVENT_NODE, *PWAN_EVENT_NODE;

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#endif // __WANARP_WANARP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\rcv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\rcv.h

Abstract:

    Function prototypes for rcv.h

Revision History:

    AmritanR

--*/


#ifndef __WANARP_RCV_H__
#define __WANARP_RCV_H__


#define PORT137_NBO     (WORD)0x8900

INT
WanNdisReceivePacket(
    IN NDIS_HANDLE  nhProtocolContext,
    IN PNDIS_PACKET pnpPacket
    ); 


NDIS_STATUS
WanNdisReceive(
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhXferContext,
    VOID UNALIGNED  *pvHdr,
    UINT            uiHdrLen,
    VOID UNALIGNED  *pvData,
    UINT            uiDataLen,
    UINT            uiTotalLen
    );

NDIS_STATUS
WanReceiveCommon(
    NDIS_HANDLE     nhProtocolContext,
    NDIS_HANDLE     nhXferContext,
    VOID UNALIGNED  *pvHeader,
    UINT            uiHeaderLen,
    VOID UNALIGNED  *pvData,
    UINT            uiDataLen,
    UINT            uiTotalLen,
    PMDL            pMdl,
    PINT            piClientCount
    );

VOID
WanNdisReceiveComplete(
    NDIS_HANDLE nhProtocolContext
    );

VOID
WanNdisTransferDataComplete(
    NDIS_HANDLE     nhProtocolContext,
    PNDIS_PACKET    pnpPacket,
    NDIS_STATUS     nsStatus,
    UINT            uiBytesCopied
    );

NDIS_STATUS
WanIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    );

UINT
WanIpReturnPacket(
    PVOID           pvContext,
    PNDIS_PACKET    pnpPacket
    );

BOOLEAN
WanpDropNetbiosPacket(
    PBYTE       pbyBuffer,
    ULONG       ulBufferLen
    );

#endif // __WANARP_RCV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\send.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp\send.h

Abstract:

    Function prototypes for send.c

Revision History:

    AmritanR

--*/


#ifndef __WANARP_SEND_H__
#define __WANARP_SEND_H__

BUFFER_POOL     g_bpHeaderBufferPool;
BUFFER_POOL     g_bpDataBufferPool;

#define HEADER_BUFFER_SIZE  sizeof(ETH_HEADER)
#define DATA_BUFFER_SIZE    256

NDIS_STATUS
WanIpTransmit(
    PVOID           pvContext,
    NDIS_PACKET     **ppPacketArray,
    UINT            uiNumPackets,
    DWORD           dwDest,
    RouteCacheEntry *pRce,
    PVOID           pvArpCtxt
    );

NDIS_STATUS
WanpSendPackets(
    PADAPTER            pAdapter,
    PUMODE_INTERFACE    pInterface,
    PCONN_ENTRY         pConnEntry,
    NDIS_PACKET         **ppPacketArray,
    PLIST_ENTRY         pleBufferList,
    UINT                uiNumPackets,
    KIRQL               kiIrql
    );

VOID
WanNdisSendComplete(
    NDIS_HANDLE     nhHandle,
    PNDIS_PACKET    pnpPacket,
    NDIS_STATUS     nsStatus
    );

VOID
WanpTransmitQueuedPackets(
    IN PADAPTER         pAdapter,
    IN PUMODE_INTERFACE pInterface,
    IN PCONN_ENTRY      pConnEntry,
    IN KIRQL            kiIrql
    );

NDIS_STATUS
WanpCopyAndQueuePackets(
    PADAPTER        pAdapter,
    NDIS_PACKET     **ppPacketArray,
    PLIST_ENTRY     pleBufferList,
    UINT            uiNumPackets
    );

VOID
WanIpInvalidateRce(
    PVOID           pvContext,
    RouteCacheEntry *pRce
    );


#endif // __WANARP_SEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\send.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wanarp2\send.c

Abstract:

    The file contains the part of interface of the IP in IP tunnel driver
    to the TCP/IP stack that deals with sending data

    The code is a cleaned up version of wanarp\ipif.c which in turn
    was derived from HenrySa's ip\arp.c

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    SEND_SIG

#include "inc.h"

NDIS_STATUS
WanIpTransmit(
    PVOID           pvContext,
    NDIS_PACKET     **ppPacketArray,
    UINT            uiNumPackets,
    DWORD           dwDestAddr,
    RouteCacheEntry *pRce,
    PVOID           pvLinkContext
    )

/*++

Routine Description:

    Function called by IP to send an array of packets. We allocate
    one ETH_HEADER for each packet. The adapter (which is the pvContext)
    is locked. If the adapter is not mapped, we fail the send, otherwise
    we lock the interface. If

Locks:

    
Arguments:

    pvContext       Our context to IP for the interface - the PTUNNEL
    ppPacketArray   The array of NDIS_PACKETs to send
    uiNumPackets    The number of packets in the array
    dwDestAddr      The destination (next hop) address
    pRce            Pointer to RCE.
    
Return Value:

    NDIS_STATUS_SUCCESS    

--*/

{
    PADAPTER            pAdapter;
    PUMODE_INTERFACE    pInterface;
    PADDRESS_CONTEXT    pAddrContext;
    PCONN_ENTRY         pConnEntry;
    KIRQL               kiIrql;
    NDIS_STATUS         nsResult;
    UINT                i;
    LIST_ENTRY          leBufferList;
    
    TraceEnter(SEND, "IpTransmit");
    
    Trace(SEND,TRACE,
          ("IpTransmit: %d packet(s) over %p/%p to %d.%d.%d.%d\n",
           uiNumPackets,
           pvContext,
           pvLinkContext,
           PRINT_IPADDR(dwDestAddr)));

    if(g_nhNdiswanBinding is NULL)
    {
        //
        // In the process of shutting down, return
        //

        return NDIS_STATUS_ADAPTER_NOT_READY;
    }     

    //
    // Get the ethernet headers for each packet
    //

    if(!GetBufferListFromPool(&g_bpHeaderBufferPool,
                              uiNumPackets,
                              &leBufferList))
    {
        //
        // Couldnt get headers for all the buffers
        //

        Trace(SEND, ERROR,
              ("IpTransmit: couldnt allocate %d header buffers\n",
               uiNumPackets));

        return NDIS_STATUS_RESOURCES;
    }
    
    //
    // This function is not guaranteed to be at dispatch
    // The context given to us is a pointer to our adapter
    //

    pConnEntry = NULL;

    pAdapter = (PADAPTER)pvContext;

    RtAcquireSpinLock(&(pAdapter->rlLock),
                      &kiIrql);
    
    if(pAdapter->byState isnot AS_MAPPED)
    {
        //
        // If the adapter is unmapped, the connection is disconnected
        //
        
        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);

        FreeBufferListToPool(&g_bpHeaderBufferPool,
                             &leBufferList);

        Trace(SEND, INFO,
              ("IpTransmit: Send on %x which is unmapped\n",
               pAdapter));

        //
        // Cant increment stats because we dont have an interface
        //
        
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

    //
    // Since the adapter is mapped, it must have an interface
    //
    
    pInterface = pAdapter->pInterface;
    
    RtAssert(pInterface);

    RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));
    
    //
    // If interface is not yet connected (for demand dial case) the copy the
    // packet and succeed the send.
    //

    if(pInterface->dwOperState isnot IF_OPER_STATUS_CONNECTED)
    {
        if(pInterface->duUsage isnot DU_ROUTER)
        {
            //
            // Just a race condition
            //

            RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

            RtReleaseSpinLock(&(pAdapter->rlLock),
                              kiIrql);

            FreeBufferListToPool(&g_bpHeaderBufferPool,
                                 &leBufferList);

            return NDIS_STATUS_ADAPTER_NOT_READY;
        }

        //
        // If IP is transmitting on us, he must have called out to
        // connect
        //

        RtAssert(pInterface->dwOperState is IF_OPER_STATUS_CONNECTING);

        Trace(SEND, INFO,
              ("IpTransmit: I/F not connected, queueing packet\n"));

        //
        // New function which queues the whole packet array
        //

        nsResult = WanpCopyAndQueuePackets(pAdapter,
                                           ppPacketArray,
                                           &leBufferList,
                                           uiNumPackets);

        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);

        if(nsResult isnot STATUS_SUCCESS)
        {
            FreeBufferListToPool(&g_bpHeaderBufferPool,
                                 &leBufferList);
        }
        
        return nsResult;
    }

    //
    // Find the connection entry for this send
    //
    
    if(pAdapter is g_pServerAdapter)
    {
        pConnEntry = (PCONN_ENTRY)pvLinkContext;

        //RtAssert(pConnEntry);

        //
        // Hack for multicast
        //

        if(pConnEntry is NULL)
        {
            pConnEntry = WanpGetConnEntryGivenAddress(dwDestAddr);
        }

        //
        // We are dont with the adapter lock. All we need is to lock down
        // the connection entry
        // It is important that we release the locks since for dial-in
        // clients the locking hierarchy is CONN_ENTRY->ADAPTER->INTERFACE
        //

        if(pConnEntry)
        {
            if(pvLinkContext != NULL)
            {
                ReferenceConnEntry(pConnEntry);
            }
        }

        RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        //
        // NOTE: The state of the connection can change in this window
        //

        if(pConnEntry)
        {
            RtAcquireSpinLockAtDpcLevel(&(pConnEntry->rlLock));

            //
            // Not a useful assert because (i) we add static routes to clients
            // and (ii) we have that hack for netbt broadcasts
            //

            // RtAssert((pConnEntry->dwRemoteAddr is dwDestAddr) or
            //          (dwAddress is 0xFFFFFFFF));
        }
    }
    else
    {
        //
        // This send is on some adapter other than the server adapter
        // Such an adapter has only one connection. For these sends we
        // lock the adapter instead of the connection
        //


        pConnEntry = pAdapter->pConnEntry;

        if(pConnEntry)
        {
            ReferenceConnEntry(pConnEntry);

            RtAssert(pConnEntry->pAdapter is pAdapter);
        }
    }
    
    //
    // So now we have a locked connection entry (if client)
    // or a locked adapter (for dial out and router)
    //
    
    if((pConnEntry is NULL) or
       (pConnEntry->byState isnot CS_CONNECTED))
    {
        if((ULONG)(dwDestAddr & 0x000000FF) < (ULONG) 0x000000E0)
        {
            Trace(SEND, ERROR,
                  ("IpTransmit: Could not find conn entry for %d.%d.%d.%d\n",
                   PRINT_IPADDR(dwDestAddr)));
        }

        for(i = 0; i < uiNumPackets; i++)
        {
            PLIST_ENTRY     pleNode;
            PNDIS_BUFFER    pnbBuffer;
            PVOID           pvFirstBuffer;
            UINT            uiFirstBufLen, uiTotalLen;
            PIP_HEADER      pIpHeader;
            
            NdisGetFirstBufferFromPacket(ppPacketArray[i],
                                         &pnbBuffer,
                                         &pvFirstBuffer,
                                         &uiFirstBufLen,
                                         &uiTotalLen);
            

            if (pvFirstBuffer)
            {
                pIpHeader = (PIP_HEADER)pvFirstBuffer;
                
                RtAssert(pIpHeader);
                RtAssert(uiFirstBufLen >= sizeof(IP_HEADER));
                
                if(IsUnicastAddr(pIpHeader->dwDest))
                {
                    pInterface->ulOutUniPkts++;
                }
                else
                {
                    pInterface->ulOutNonUniPkts++;
                }
            }
        }
        
        //
        // The entry has been disconnected.
        // This is just a window in the timing
        //
        
        pInterface->ulOutDiscards += uiNumPackets;
        
        if(pAdapter is g_pServerAdapter)
        {
            if(pConnEntry isnot NULL)
            {
                RtReleaseSpinLock(&(pConnEntry->rlLock),
                                  kiIrql);
            }
            else
            {
                KeLowerIrql(kiIrql);
            }
        }   
        else    
        {
            RtReleaseSpinLockFromDpcLevel(&(pAdapter->rlLock));
            
            RtReleaseSpinLock(&(pInterface->rlLock),
                              kiIrql);
        }
        
        FreeBufferListToPool(&g_bpHeaderBufferPool,
                             &leBufferList);

        if(pConnEntry)
        {
            DereferenceConnEntry(pConnEntry);
        }

        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

#if DBG
    
    Trace(SEND, TRACE,
          ("IpTransmit: Send on %s\n",
           pAdapter->asDeviceNameA.Buffer));
  
    for(i = 0; i < uiNumPackets; i++)
    {
        PacketContext   *pPC;

        pPC = (PacketContext *)((ppPacketArray[i])->ProtocolReserved);

        RtAssert(pPC->pc_common.pc_owner isnot PACKET_OWNER_LINK);
    }

#endif

    //
    // This function will free the locks
    //
    
    nsResult = WanpSendPackets(pAdapter,
                               pInterface,
                               pConnEntry,
                               ppPacketArray,
                               &leBufferList,
                               uiNumPackets,
                               kiIrql);

    if(nsResult isnot STATUS_SUCCESS)
    {
        Trace(SEND,TRACE,
              ("IpTransmit: SendPackets returned status %x\n",nsResult));
    }

    DereferenceConnEntry(pConnEntry);

    return nsResult;
}

NDIS_STATUS
WanpSendPackets(
    PADAPTER            pAdapter,
    PUMODE_INTERFACE    pInterface,
    PCONN_ENTRY         pConnEntry,
    NDIS_PACKET         **ppPacketArray,
    PLIST_ENTRY         pleBufferList,
    UINT                uiNumPackets,
    KIRQL               kiIrql
    )

/*++

Routine Description:

    Main routine to send an array of packets
    

Locks:

    Called with the connection entry (for dial in) or the adapter+interface
    (all others) locked
    
Arguments:

    pAdapter        The adapter for the connection
    pInterface      The interface the adapter is mapped to
    pConnEntry      The connection entry for the send
    ppPacketArray   The array of packets to send
    pBuffHead       A list of buffers for the link layer header
    uiNumPackets    Number of packets (and ll header buffers)
    kiIrql          Irql at which the adapter or conn entry was locked

Return Value:

    NDIS_STATUS_PENDING

--*/

{
    NDIS_STATUS     nsStatus;
    PBYTE           pbyHeader;
    ULONG           i;
   
#if DBG
    
    Trace(SEND, TRACE,
          ("SendPackets:  %s\n",
           pAdapter->asDeviceNameA.Buffer));
    
#endif

    for(i = 0; i < uiNumPackets; i++)
    {
        PNDIS_BUFFER    pnbBuffer, pnbTempBuffer;
        PLIST_ENTRY     pleNode;
        PVOID           pvFirstBuffer;
        UINT            uiFirstBufLen, uiTotalBufLen, uiIpHdrLen;
        PIP_HEADER      pIpHeader;
        PBUFFER_HEAD    pBufferHead;

 
        NdisGetFirstBufferFromPacket(ppPacketArray[i],
                                     &pnbTempBuffer,
                                     &pvFirstBuffer,
                                     &uiFirstBufLen,
                                     &uiTotalBufLen);

        
        pIpHeader = (PIP_HEADER)pvFirstBuffer;

        RtAssert(pIpHeader);
        
        #if DBG
        RtAssert((pIpHeader->byVerLen & 0xF0) == 0x40);
        RtAssert(LengthOfIpHeader(pIpHeader) >= 20);
        #endif
        

        //
        // ToDo: remove till NK fixes the bug in IP transmit
        // with header inc
        //

        // RtAssert(uiFirstBufLen >= sizeof(IP_HEADER));

#if L2TP_DBG

#define L2TP_PORT_NBO 0xA506 // 1701 == 06A5

        //
        // If this is a l2tp packet, break
        //

        if(pIpHeader->byProtocol is 17)
        {
            WORD UNALIGNED *pwPort;

            //
            // See if we have enough data to get to the UDP header in
            // the first buffer
            //

            uiIpHdrLen = LengthOfIpHeader(pIpHeader);

            if(uiFirstBufLen >= uiIpHdrLen + sizeof(ULONG))
            {
                pwPort = (WORD UNALIGNED *)((ULONG_PTR)pIpHeader + uiIpHdrLen);
            }
            else
            {
                PNDIS_BUFFER    pNextBuf;

                //
                // Get the next buffer and look into its
                //

                pNextBuf = pnbTempBuffer->Next;

                pwPort = (WORD UNALIGNED *)(pnbTempBuffer->MappedSystemVa);
            }

            if((pwPort[0] is L2TP_PORT_NBO) or
               (pwPort[1] is L2TP_PORT_NBO))
            {
                Trace(SEND, ERROR,
                      ("SendPackets: %x buffer %x header %x port %d.%d\n",
                       pnbTempBuffer, pIpHeader, pwPort,
                       pwPort[0], pwPort[1]));

                RtAssert(FALSE);
            }
        }

#endif


        //
        // NOTE: If this is a client send, the server interface is not
        // locked. Hence the stats can be inconsistent for the server
        // interface
        //
        
        if(IsUnicastAddr(pIpHeader->dwDest))
        {
            pInterface->ulOutUniPkts++;
        }
        else
        {
            pInterface->ulOutNonUniPkts++;
        }
        
        pleNode = RemoveHeadList(pleBufferList);

#if LIST_DBG
        
        pBufferHead = CONTAINING_RECORD(pleNode,
                                        BUFFER_HEAD,
                                        leListLink);

        RtAssert(IsListEmpty(&(pBufferHead->leFreeBufferLink)));
        RtAssert(pBufferHead->bBusy);

        pBufferHead->leListLink.Flink = NULL;
        pBufferHead->leListLink.Blink = NULL;

#else

        pBufferHead = CONTAINING_RECORD(pleNode,
                                        BUFFER_HEAD,
                                        leFreeBufferLink);

#endif
        
        //
        // Get a pointer to the data and to the buffer
        //
       
 
        pbyHeader = BUFFER_FROM_HEAD(pBufferHead);
                
        pnbBuffer = pBufferHead->pNdisBuffer;

        //
        // Copy our prebuilt header into each buffer
        //
        
        RtlCopyMemory(pbyHeader,
                      &(pConnEntry->ehHeader),
                      sizeof(ETH_HEADER));

        //
        // Put the ethernet header in the front of the packet
        //

        NdisChainBufferAtFront(ppPacketArray[i],
                               pnbBuffer);

        //
        // Reference the entry once for each packet
        //
    
        ReferenceConnEntry(pConnEntry);

#if PKT_DBG

        Trace(SEND, ERROR,
              ("SendPackets: Pkt %x Eth buff %x (%x) Header %x (%x)\n",
               ppPacketArray[1],
               pnbBuffer,
               pbyHeader,
               pnbTempBuffer,
               pvFirstBuffer));

#endif // PKT_DBG
               
        
    }

    //
    // Increment the output queue length. This will be decremented
    // in the send complete handler
    //
    
    pAdapter->ulQueueLen++;

    //
    // Let go of the locks
    //

    if(pConnEntry->duUsage isnot DU_CALLIN)
    {
        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
    }

    RtReleaseSpinLock(pConnEntry->prlLock,
                      kiIrql);
    
    NdisSendPackets(g_nhNdiswanBinding,
                    ppPacketArray,
                    uiNumPackets);

    //
    // Dont dereference the connection entry. We will deref it in
    // the send complete handler
    //
        
    return NDIS_STATUS_PENDING;
}

VOID
WanNdisSendComplete(
    NDIS_HANDLE     nhHandle,
    PNDIS_PACKET    pnpPacket,
    NDIS_STATUS     nsStatus
    )

/*++

Routine Description:

    Our send complete handler called by NDIS once for each packet that was
    pending after a send.

Locks:

    

Arguments:

    

Return Value:


--*/

{
    PacketContext       *pPC;
    PNDIS_BUFFER        pnbBuffer, pnbEthBuffer;
    KIRQL               kiIrql;
    PADAPTER            pAdapter; 
    PUMODE_INTERFACE    pInterface;
    PCONN_ENTRY         pConnEntry;
    PETH_HEADER         pEthHeader;
    ULONG               ulIndex;
    PVOID               pvFirstBuffer;
    UINT                uiFirstBufLen, uiTotalLen;
 
    TraceEnter(SEND, "NdisSendComplete");
    
    //
    // Get first buffer on packet. This is our ethernet header buffer
    //
    
    NdisUnchainBufferAtFront(pnpPacket,
                             &pnbEthBuffer);

    //
    // Get the fake ethernet header
    //

    pEthHeader = NdisBufferVirtualAddress(pnbEthBuffer);

#if DBG

    //
    // The buffer head should say the same thing
    //

    RtAssert(pnbEthBuffer is ((HEAD_FROM_BUFFER(pEthHeader))->pNdisBuffer));

#endif

    ulIndex = GetConnIndexFromAddr(pEthHeader->rgbySourceAddr);

    //
    // Done with our buffer
    //

    FreeBufferToPool(&g_bpHeaderBufferPool,
                     (PBYTE)pEthHeader);

    //
    // Get the connection entry
    //

    RtAcquireSpinLock(&g_rlConnTableLock,
                      &kiIrql);

    pConnEntry = GetConnEntryGivenIndex(ulIndex);

    if(pConnEntry is NULL)
    {
        RtAssert(FALSE);

        RtReleaseSpinLock(&g_rlConnTableLock,
                          kiIrql);

        Trace(SEND, ERROR,
              ("NdisSendComplete: Couldnt find entry for connection %d\n",
               ulIndex));

        TraceLeave(RCV, "NdisSendComplete");
        
        return;
    }

    RtAcquireSpinLockAtDpcLevel(pConnEntry->prlLock);

    RtReleaseSpinLockFromDpcLevel(&g_rlConnTableLock);

    pAdapter = pConnEntry->pAdapter;

#if DBG
    
    Trace(SEND, INFO, 
          ("NdisSendComplete: Extracted adapter %x with name %s\n",
           pAdapter,
           pAdapter->asDeviceNameA.Buffer));

#endif

    pAdapter->ulQueueLen--;

    if(pConnEntry->duUsage is DU_CALLIN)
    {
        pInterface = g_pServerInterface;

        RtAssert(pAdapter is g_pServerAdapter);
    }
    else
    {
        //
        // See if we are still mapped to an interface, if so lock it
        //
        
        pInterface = pAdapter->pInterface;
        
        if(pInterface isnot NULL)
        {
            RtAcquireSpinLockAtDpcLevel(&(pInterface->rlLock));
        }
    }

    //
    // Right now we have the adapter + interface or the connection entry
    // locked.
    //
    
    if(nsStatus is NDIS_STATUS_SUCCESS)
    {
        NdisGetFirstBufferFromPacket(pnpPacket,
                                     &pnbBuffer,
                                     &pvFirstBuffer,
                                     &uiFirstBufLen,
                                     &uiTotalLen);

        

        if(pInterface)
        {
            pInterface->ulOutOctets += uiTotalLen;
        }

#if PKT_DBG

        Trace(SEND, ERROR,
              ("NdisSendComplete: Pkt %x Eth buff %x (%x) Header %x (%x)\n",
               pnpPacket,
               pnbEthBuffer,
               pEthHeader,
               pnbBuffer,
               pvFirstBuffer));

#endif PKT_DBG

    }
    else
    {
        Trace(SEND, INFO,
              ("NdisSendComplete: Failed %x\n",
               nsStatus));
 
        if(pInterface)
        {
            pInterface->ulOutDiscards++;
        }
    }

    //
    // If this is not our packet return it to the protocol
    //

    pPC = (PacketContext *)pnpPacket->ProtocolReserved;
  
    //
    // Unlock
    //

    if(pConnEntry->duUsage isnot DU_CALLIN)
    {
        if(pInterface isnot NULL)
        {
            RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));
        }
    } 

    RtReleaseSpinLock(pConnEntry->prlLock,
                      kiIrql);

    if(pPC->pc_common.pc_owner isnot PACKET_OWNER_LINK)
    {
        Trace(SEND, TRACE,
              ("NdisSendComplete: Calling IPSendComplete  for %p over %p(%p)\n",
               pnpPacket,
               pAdapter,
               pAdapter->pvIpContext));

        g_pfnIpSendComplete(pAdapter->pvIpContext,
                            pnpPacket,
                            nsStatus);
    }
    else
    {
        //
        // Free all buffers from our packet and then the packet itself
        //
   
        Trace(SEND, TRACE,
              ("NdisSendComplete: Not calling IPSendComplete  for %p\n",
               pnpPacket));
 
        WanpFreePacketAndBuffers(pnpPacket);
    }

    //
    // Deref the conn entry for the send and for the fact that
    // GetConnEntry.. put a ref on it
    //

    DereferenceConnEntry(pConnEntry);
    DereferenceConnEntry(pConnEntry);

    return;
}


VOID
WanpTransmitQueuedPackets(
    IN PADAPTER         pAdapter,
    IN PUMODE_INTERFACE pInterface,
    IN PCONN_ENTRY      pConnEntry,
    IN KIRQL            kiIrql
    )
{
    ULONG           i;
    PNDIS_PACKET    rgPacketArray[64];
    NDIS_PACKET     **ppPacketArray;
    LIST_ENTRY      leBufferList, *pleNode;


    //
    // This is only called for ROUTER interfaces
    //

    RtAssert(pConnEntry->duUsage is DU_ROUTER);
    RtAssert(pInterface->duUsage is DU_ROUTER);

    //
    // If there are no packets to transmit, just release the
    // locks
    //

    if(pInterface->ulPacketsPending is 0)
    {
        RtAssert(IsListEmpty(&(pAdapter->lePendingPktList)));
        RtAssert(IsListEmpty(&(pAdapter->lePendingHdrList)));

       
        RtReleaseSpinLockFromDpcLevel(&(pInterface->rlLock));

        RtReleaseSpinLock(&(pAdapter->rlLock),
                          kiIrql);

        return;
    }


    if(pInterface->ulPacketsPending <= 64)
    {
        //
        // Just use the stack array
        //

        ppPacketArray = rgPacketArray;
    }
    else
    {
        //
        // Allocate a packet array
        //

        ppPacketArray = 
            RtAllocate(NonPagedPool,
                       sizeof(PNDIS_PACKET) * pInterface->ulPacketsPending,
                       WAN_CONN_TAG);

        if(ppPacketArray is NULL)
        {
            Trace(SEND, ERROR,
                  ("TransmitQueuedPackets: Unable to allocate %d pointers\n",
                   pInterface->ulPacketsPending));

            while(!IsListEmpty(&(pAdapter->lePendingPktList)))
            {
                PNDIS_PACKET    pnpPacket;

                pleNode = RemoveHeadList(&(pAdapter->lePendingPktList));

                //
                // get to the packet structure in which LIST_ENTRY is embedded
                //

                pnpPacket = CONTAINING_RECORD(pleNode,
                                              NDIS_PACKET,
                                              MacReserved);

                WanpFreePacketAndBuffers(pnpPacket);
            }

            while(!IsListEmpty(&(pAdapter->lePendingHdrList)))
            {
                PBYTE           pbyHeader;
                PBUFFER_HEAD    pBuffHead;

                pleNode = RemoveHeadList(&(pAdapter->lePendingHdrList));

#if LIST_DBG
                pBuffHead = CONTAINING_RECORD(pleNode,
                                              BUFFER_HEAD,
                                              leListLink);

                RtAssert(IsListEmpty(&(pBuffHead->leFreeBufferLink)));
                RtAssert(pBuffHead->bBusy);

                pBuffHead->leListLink.Flink = NULL;
                pBuffHead->leListLink.Blink = NULL;

#else
                pBuffHead = CONTAINING_RECORD(pleNode,
                                              BUFFER_HEAD,
                                              leFreeBufferLink);
#endif


                pbyHeader = BUFFER_FROM_HEAD(pBuffHead);

                FreeBufferToPool(&g_bpHeaderBufferPool,
                                 pbyHeader);
            }
        }
    }

    for(i = 0, pleNode = pAdapter->lePendingPktList.Flink; 
        pleNode isnot &(pAdapter->lePendingPktList);
        pleNode = pleNode->Flink, i++)
    {
        PNDIS_PACKET    pnpPacket;

        pnpPacket = CONTAINING_RECORD(pleNode,
                                      NDIS_PACKET,
                                      MacReserved);

        ppPacketArray[i] = pnpPacket;
    }

    RtAssert(i is pInterface->ulPacketsPending);

#if DBG

    for(i = 0, pleNode = pAdapter->lePendingHdrList.Flink;
        pleNode isnot &(pAdapter->lePendingHdrList);
        pleNode = pleNode->Flink, i++);

    RtAssert(i is pInterface->ulPacketsPending);

#endif

    //
    // copy out the pending hdr list to leBufferList.
    //

    leBufferList = pAdapter->lePendingHdrList;

    pAdapter->lePendingHdrList.Flink->Blink = &leBufferList;
    pAdapter->lePendingHdrList.Blink->Flink = &leBufferList;

    pInterface->ulPacketsPending = 0;
    
    InitializeListHead(&(pAdapter->lePendingPktList));
    InitializeListHead(&(pAdapter->lePendingHdrList));

    WanpSendPackets(pAdapter,
                    pInterface,
                    pConnEntry,
                    ppPacketArray,
                    &leBufferList,
                    pInterface->ulPacketsPending,
                    kiIrql);

    if(rgPacketArray isnot ppPacketArray)
    {
        RtFree(ppPacketArray);
    }
}



NDIS_STATUS
WanpCopyAndQueuePackets(
    PADAPTER        pAdapter,
    NDIS_PACKET     **ppPacketArray,
    PLIST_ENTRY     pleBufferList,
    UINT            uiNumPackets
    )

/*++

Routine Description:

    This routine queues the packet to the adapter    
    Once this routine is called, the caller can not touch the pleListHead
    
Locks:

    The ADAPTER must be locked and mapped
    The interface the adapter is mapped to must also be locked
    
Arguments:

    pAdapter
    ppPacketArray
    pBuffHead
    uiNumPackets

Return Value:

    NDIS_STATUS_SUCCESS
    STATUS_QUOTA_EXCEEDED
    NDIS_STATUS_RESOURCES
    
--*/

{
    PacketContext   *pPC;
    NDIS_STATUS     nsStatus;
    PLIST_ENTRY     pleNode;
    ULONG           i;

#if DBG
    ULONG           ulPended = 0, ulHdrs = 0;
#endif    


    TraceEnter(SEND, "CopyAndQueuePackets");

    if(pAdapter->pInterface->ulPacketsPending >= WANARP_MAX_PENDING_PACKETS)
    {
        Trace(SEND, WARN,
              ("CopyAndQueuePackets: Dropping packets since cap exceeded\n"));

        return STATUS_QUOTA_EXCEEDED;
    }

    for(i = 0; i < uiNumPackets; i++)
    {
        PNDIS_PACKET    pnpPacket;
        UINT            uiTotalLen, uiBytesCopied;

        //
        // Get size of buffers required
        //
    
        NdisQueryPacket(ppPacketArray[i],
                        NULL,
                        NULL,
                        NULL,
                        &uiTotalLen);

        //
        // Allocate a packet.
        //
  
        pnpPacket = NULL;
 
        NdisAllocatePacket(&nsStatus,
                           &pnpPacket,
                           g_nhPacketPool);

        if(nsStatus isnot NDIS_STATUS_SUCCESS)
        {
            Trace(SEND, ERROR,
                  ("CopyAndQueuePackets: Cant allocate packet. %x\n",
                   nsStatus));

        }
        else
        {                            
            //
            // Allocate buffers for the packet
            //
  
            nsStatus = GetBufferChainFromPool(&g_bpDataBufferPool,
                                              pnpPacket,
                                              uiTotalLen,
                                              NULL,
                                              NULL);
        }
        
        if(nsStatus is STATUS_SUCCESS)
        {
            //
            // If we got a packet and the buffers, then copy from TCP/IP's 
            // packet into ours
            //

            NdisCopyFromPacketToPacket(pnpPacket,
                                       0,
                                       uiTotalLen,
                                       ppPacketArray[i],
                                       0,
                                       &uiBytesCopied);
            
            RtAssert(uiBytesCopied is uiTotalLen);
                
            //
            // This is now our packet, so set its context
            //

            pPC = (PacketContext *)pnpPacket->ProtocolReserved;

            pPC->pc_common.pc_owner = PACKET_OWNER_LINK;
    
            //
            // Attach Packet to pending packet list
            // We use the MacReserved portion as the list entry
            //
    
            InsertTailList(&pAdapter->lePendingPktList,
                           (PLIST_ENTRY)&(pnpPacket->MacReserved));

            pAdapter->pInterface->ulPacketsPending++;

#if DBG
            ulPended++;
#endif

        }
        else
        {
            PBUFFER_HEAD    pBufferHead;
            PBYTE           pbyHeader;

            //
            // We either have no packet, or couldnt get a buffer.
            // Nasty Nasty: Side effect of such a failure is that we free 
            // one of the header buffers
            //

            RtAssert(!IsListEmpty(pleBufferList));

            pleNode = RemoveHeadList(pleBufferList);
       
#if LIST_DBG
 
            pBufferHead = CONTAINING_RECORD(pleNode,
                                            BUFFER_HEAD,
                                            leListLink);

            RtAssert(IsListEmpty(&(pBufferHead->leFreeBufferLink)));
            RtAssert(pBufferHead->bBusy);

            pBufferHead->leListLink.Flink = NULL;
            pBufferHead->leListLink.Blink = NULL;

#else

            pBufferHead = CONTAINING_RECORD(pleNode,
                                            BUFFER_HEAD,
                                            leFreeBufferLink);

#endif
        
            //
            // Get a pointer to the data and to the buffer
            //
        
            pbyHeader = BUFFER_FROM_HEAD(pBufferHead);
                
            FreeBufferToPool(&g_bpHeaderBufferPool,
                             pbyHeader);

            if(pnpPacket)
            {
                NdisFreePacket(pnpPacket);
            }
        }
    }

    //
    // we have queued all the packets we could, and for the ones we
    // failed, we freed the corresponding ethernet header.
    // So the number of headers left on pleBufferList should be the number of
    // packets queued
    //

    if(!IsListEmpty(pleBufferList))
    {

#if DBG
        for(pleNode = pleBufferList->Flink;
            pleNode isnot pleBufferList;
            pleNode = pleNode->Flink)
        {
            ulHdrs++;
        }
#endif

        //
        // Add the headers to the front of the adapter chain
        //

        pleBufferList->Blink->Flink = pAdapter->lePendingHdrList.Flink;
        pleBufferList->Flink->Blink = &(pAdapter->lePendingHdrList);
        
        
        pAdapter->lePendingHdrList.Flink->Blink = pleBufferList->Blink;
        pAdapter->lePendingHdrList.Flink        = pleBufferList->Flink;
    }

#if DBG
    RtAssert(ulPended is ulHdrs);
#endif

    return NDIS_STATUS_SUCCESS;
}

VOID
WanpFreePacketAndBuffers(
    PNDIS_PACKET    pnpPacket
    )
{
    PNDIS_BUFFER    pnbFirstBuffer;

    FreeBufferChainToPool(&g_bpDataBufferPool,
                          pnpPacket);

    NdisFreePacket(pnpPacket);
}

   
VOID
WanIpInvalidateRce(
    PVOID           pvContext,
    RouteCacheEntry *pRce
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\dialog.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dialog.dlg
//
#define IDD_WATCHER                     101
#define IDL_ADAPTERS                    1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\adptif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ipx\adptif\adptif.c

Abstract:

	Router/sap agent interface to ipx stack
Author:

	Vadim Eydelman

Revision History:

--*/
#include "ipxdefs.h"

#ifdef UNICODE
#define _UNICODE
#endif

// [pmay] Make adptif pnp aware
#include "pnp.h"

// [pmay] The global trace id.
DWORD g_dwTraceId = 0;
DWORD g_dwBufferId = 0;

WCHAR			ISN_IPX_NAME[] = L"\\Device\\NwlnkIpx"; // Ipx stack driver name
ULONG			InternalNetworkNumber=0;				// Internal network parameters
UCHAR			INTERNAL_NODE_ADDRESS[6]={0,0,0,0,0,1};
IO_STATUS_BLOCK	IoctlStatus;			// IO status buffer for config change notifications
HANDLE			IpxDriverHandle;			// Driver handle for config change notifications
LONG			AdapterChangeApcPending = 0;
/*
DWORD (APIENTRY * RouterQueueWorkItemProc) (WORKERFUNCTION, PVOID, BOOL)=NULL;
										// Thread management API routine when running
										// under router
#define InRouter()	(RouterQueueWorkItemProc!=NULL)
*/
LIST_ENTRY			PortListHead;		// List of configuraiton ports
PCONFIG_PORT		IpxWanPort;			// Special port for IPX WAN
CRITICAL_SECTION	ConfigInfoLock;		// Protects access to port and message queues
ULONG				NumAdapters;		// Total number of available adapters (used
										// to estimate the size of the buffer passed to
										// the driver in config change notification calls)


DWORD
OpenAdapterConfigPort (
	void
	);

NTSTATUS
CloseAdapterConfigPort (
	PVOID pvConfigBuffer
	);

VOID APIENTRY
PostAdapterConfigRequest (
	PVOID			context
	);

NTSTATUS
ProcessAdapterConfigInfo (
	PVOID pvConfigBuffer
	);

DWORD
InitializeMessageQueueForClient (
	PCONFIG_PORT		config
	);

VOID
AdapterChangeAPC (
	PVOID				context,
	PIO_STATUS_BLOCK	IoStatus,
	ULONG				Reserved
	);
	
VOID
IpxSendCompletion (
	IN	PVOID				Context,
	IN	PIO_STATUS_BLOCK	IoStatus,
	IN	ULONG				Reserved
	);

VOID
IpxRecvCompletion (
	IN	PVOID				Context,
	IN	PIO_STATUS_BLOCK	IoStatus,
	IN	ULONG				Reserved
	);

VOID
FwCleanup (
	void
	);

// [pmay] Synchronize the forwarder with nic id renumberings
// in the stack.
DWORD FwRenumberNics (DWORD dwOpCode, USHORT usThreshold);


#if DBG && defined(WATCHER_DIALOG)
#include "watcher.c"
#endif

/*++
*******************************************************************
        D l l M a i n

Routine Description:

		Dll initialization and cleanup

Arguments:

      	hinstDLL,		handle of DLL module 
    	fdwReason,		reason for calling function 
      	lpvReserved 	reserved 

Return Value:

        TRUE			intialized OK
        FALSE			failed
Remarks:
		Return value is only valid when called with DLL_PROCESS_ATTACH reason
		This DLL makes use of CRT.DLL, so this entry point should
		be called from CRT.DLL entry point
*******************************************************************
--*/


BOOL WINAPI DllMain(
    HINSTANCE  	hinstDLL, 
    DWORD  		fdwReason, 
    LPVOID  	lpvReserved
    ) {
    BOOL		res = FALSE;
	TCHAR		ProcessFileName[MAX_PATH];
	DWORD		cnt;


	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:	// We are being attached to a new process
            // Initialize the system that maps virtual nic ids to physical ones
            NicMapInitialize ();
			InitializeCriticalSection (&ConfigInfoLock);			
			InitializeListHead (&PortListHead);
			IpxWanPort = NULL;
            // Register with the trace utility
            g_dwTraceId = TraceRegisterExA("IpxAdptif", 0);
#if DBG && defined(WATCHER_DIALOG)
			InitializeWatcher (hinstDLL);
#endif
			res = TRUE;
			break;

		case DLL_PROCESS_DETACH:	// The process is exiting
#if DBG && defined(WATCHER_DIALOG)
			CleanupWatcher ();
#endif
			DeleteCriticalSection (&ConfigInfoLock);
			FwCleanup ();
            TraceDeregisterExA(g_dwTraceId , 4);
            
            // Cleanup the system that maps virtual nic ids to physical ones
            NicMapCleanup ();

		default:					// Not interested in all other cases
			res = TRUE;
			break;			
		}

	return res;
	}

// Debug functions
char * DbgStatusToString(DWORD dwStatus) {
    switch (dwStatus) {
        case NIC_CREATED:
            return "Created";
        case NIC_DELETED:
            return "Deleted";
        case NIC_CONNECTED:
            return "Connected";
        case NIC_DISCONNECTED:
            return "Disconnected";
        case NIC_LINE_DOWN:
            return "Line down";
        case NIC_LINE_UP:
            return "Line up";
        case NIC_CONFIGURED:
            return "Configured";
    }
    return "Unknown";
}

// Debugging functions
char * DbgTypeToString(DWORD dwType) {
    switch (dwType) {
	    case NdisMedium802_3:
            return "802.3";
	    case NdisMedium802_5:
            return "802.5";
	    case NdisMediumFddi:
            return "Fddi";
	    case NdisMediumWan:
            return "Wan";
	    case NdisMediumLocalTalk:
            return "LocalTalk";
	    case NdisMediumDix:	
            return "Dix";
	    case NdisMediumArcnetRaw:
            return "Raw Arcnet";
	    case NdisMediumArcnet878_2:
            return "878.2";
	    case NdisMediumAtm:
            return "Atm";
	    case NdisMediumWirelessWan:
            return "Wireless Wan";
	    case NdisMediumIrda:
            return "Irda";
	    case NdisMediumBpc:
            return "Bpc";
	    case NdisMediumCoWan:
            return "Co Wan";
        case NdisMediumMax:
            return "Maxium value allowed";
    }

    return "Unknown";
}

// Returns the op-code (for nic id renumbering) associated with this
// message
DWORD GetNicOpCode(PIPX_NIC_INFO pNic) {
    DWORD dwOp = (DWORD)(pNic->Status & 0xf0);
    pNic->Status &= 0x0f;
    return dwOp;
}

// Inserts the op-code (for nic id renumbering) associated with this
// message
DWORD PutNicOpCode(PIPX_NIC_INFO pNic, DWORD dwOp) {
    pNic->Status |= dwOp;
    return dwOp;
}


// Outputs a list of nics to the tracing service
DWORD DbgDisplayNics(PIPX_NIC_INFO NicPtr, DWORD dwNicCount) {
    DWORD i;

    for (i = 0; i < dwNicCount; i++) {
        PUCHAR ln = NicPtr[i].Details.Node;
        USHORT NicId = NicPtr[i].Details.NicId;
        BOOLEAN Status = NicPtr[i].Status;
        GetNicOpCode(&NicPtr[i]);
        TracePrintf(g_dwTraceId, "[R=%d V=%x: %s]: Net=%x IfNum=%d Local=%x%x%x%x%x%x Type= %s", 
                        NicId, 
                        NicMapGetVirtualNicId(NicId),
                        DbgStatusToString(NicPtr[i].Status), 
                        NicPtr[i].Details.NetworkNumber,
                        NicPtr[i].InterfaceIndex,
                        ln[0], ln[1], ln[2], ln[3], ln[4], ln[5],
                        DbgTypeToString(NicPtr[i].NdisMediumType)
                        );
        NicPtr[i].Status = Status;
    }
    TracePrintf(g_dwTraceId, "\n");

    return NO_ERROR;
}

int DVNID (int x) {
    USHORT tmp;
    tmp = (USHORT)NicMapGetVirtualNicId((USHORT)x);
    return (tmp < 50) ? tmp : -1;
}

int DRNID (int x) {
    USHORT tmp;
    tmp = NicMapGetPhysicalNicId((USHORT)x);
    return (tmp < 50) ? tmp : -1;
}

// Outputs the virtual to physical adapter map 
DWORD DbgDisplayMap() {
    USHORT i;

/*    for (i = 0; i < 6; i++) {
        PUCHAR m = GlobalNicIdMap.nidMacAddrs[i];
        if (m)  {
            TracePrintf(g_dwTraceId, 
                    "Real %d \tis Virtual %x \t(%x->%x) \twith Mac %x%x%x%x%x%x", 
                    i, NicMapGetVirtualNicId(i), i, NicMapGetPhysicalNicId(i), 
                    m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        else {
            TracePrintf(g_dwTraceId, 
                    "Real %d \tis Virtual %x \t(%x->%x)", 
                    i, NicMapGetVirtualNicId(i), i, NicMapGetPhysicalNicId(i));
        }
    }
*/

    TracePrintf(g_dwTraceId, "R: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d",
                                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    TracePrintf(g_dwTraceId, "V: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d",
                                 DVNID(1), DVNID(2), DVNID(3), DVNID(4), DVNID(5), 
                                 DVNID(6), DVNID(7), DVNID(8), DVNID(9), DVNID(10));
                                 
    TracePrintf(g_dwTraceId, "V: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d",
                                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    TracePrintf(g_dwTraceId, "R: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n",
                                 DRNID(1), DRNID(2), DRNID(3), DRNID(4), DRNID(5), 
                                 DRNID(6), DRNID(7), DRNID(8), DRNID(9), DRNID(10));

    return NO_ERROR;
}

/*++

        C r e a t e S o c k e t P o r t

Routine Description:

		Creates port to communicate over IPX socket

Arguments:

		Socket			- IPX socket number to use (network byte order)

Return Value:

		Handle to communication port that provides async interface
		to IPX stack.  Returns INVALID_HANDLE_VALUE if port can not be opened

--*/

HANDLE WINAPI
CreateSocketPort(
	IN USHORT	Socket
	) {
	NTSTATUS			status;
	HANDLE				AddressHandle;
	IO_STATUS_BLOCK		IoStatusBlock;
	UNICODE_STRING		FileString;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	CHAR				spec[IPX_ENDPOINT_SPEC_BUFFER_SIZE];

#define ea ((PFILE_FULL_EA_INFORMATION)&spec)
#define TrAddress ((PTRANSPORT_ADDRESS)&ea->EaName[ROUTER_INTERFACE_LENGTH+1])
#define TaAddress ((PTA_ADDRESS)&TrAddress->Address[0])
#define IpxAddress ((PTDI_ADDRESS_IPX)&TaAddress->Address[0])

	RtlInitUnicodeString (&FileString, ISN_IPX_NAME);
	InitializeObjectAttributes(
			&ObjectAttributes,
			&FileString,
			OBJ_CASE_INSENSITIVE,
			NULL,
			NULL);


	ea->NextEntryOffset = 0;
	ea->Flags = 0;
	ea->EaNameLength = ROUTER_INTERFACE_LENGTH; 
	RtlCopyMemory (ea->EaName, ROUTER_INTERFACE, ROUTER_INTERFACE_LENGTH + 1);
	ea->EaValueLength =  sizeof(TRANSPORT_ADDRESS) - 1
								+ sizeof(TDI_ADDRESS_IPX);


	TrAddress->TAAddressCount = 1;
	TaAddress->AddressType = TDI_ADDRESS_TYPE_IPX;
	TaAddress->AddressLength = sizeof(TDI_ADDRESS_IPX);
  
	IpxAddress->Socket = Socket;
    

	status = NtCreateFile(
				  &AddressHandle,
				  GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
				  &ObjectAttributes,
				  &IoStatusBlock,            // returned status information
				  0,                              // block size (unused).
				  0,                              // file attributes.
				  FILE_SHARE_READ | FILE_SHARE_WRITE,
				  FILE_CREATE,                    // create disposition.
				  0,                              // create options.
				  ea,
				  sizeof (spec)
				  );

	if (NT_SUCCESS (status)) {
		SetLastError (NO_ERROR);
		return AddressHandle;
		}
	else {
#if DBG
		DbgPrint ("NtCreateFile (router if) failed with status %08x\n",
						 status);
#endif
		RtlNtStatusToDosError (status);	// Sets last error in Teb
		}
	return INVALID_HANDLE_VALUE;

#undef TrAddress
#undef TaAddress
#undef IpxAddress
	}
/*++

        D e l e t e S o c k e t P o r t

Routine Description:

		Cancel all the outstandng requests and dispose of all the resources
		allocated for communication port

Arguments:

		Handle		 - Handle to communication port to be disposed of

Return Value:

		NO_ERROR - success
		Windows error code - operation failed


--*/
DWORD WINAPI
DeleteSocketPort (
	HANDLE	Handle
	) {
	return RtlNtStatusToDosError (NtClose (Handle));
	}


/*++

        I p x S e n d C o m p l e t i o n

Routine Description:
		Io APC. Calls client provided completion routine

Arguments:
		Context - Pointer to client completion routine
		IoStatus - status of completed io operation (clients overlapped
					structure is used as the buffer)
		Reserved - ???
Return Value:
		None
--*/
VOID
IpxSendCompletion (
	IN	PVOID				Context,
	IN	PIO_STATUS_BLOCK	IoStatus,
	IN	ULONG				Reserved
	) {
	if (NT_SUCCESS (IoStatus->Status))
		(*(LPOVERLAPPED_COMPLETION_ROUTINE)Context) (NO_ERROR,
										// Adjust byte trasferred parameter to
										// include header supplied in the
										// packet
									((DWORD)IoStatus->Information+=sizeof (IPX_HEADER)),
									(LPOVERLAPPED)IoStatus);
	else
		(*(LPOVERLAPPED_COMPLETION_ROUTINE)Context) (
									RtlNtStatusToDosError (IoStatus->Status),
										// Adjust byte trasferred parameter to
										// include header supplied in the
										// packet if something was sent
									(IoStatus->Information > 0)
										? ((DWORD)IoStatus->Information += sizeof (IPX_HEADER))
										: ((DWORD)IoStatus->Information = 0),
									(LPOVERLAPPED)IoStatus);
	}

/*++

        I p x R e c v C o m p l e t i on

Routine Description:
		Io APC. Calls client provided completion routine

Arguments:
		Context - Pointer to client completion routine
		IoStatus - status of completed io operation (clients overlapped
					structure is used as the buffer)
		Reserved - ???
Return Value:
		None
--*/
VOID
IpxRecvCompletion (
	IN	PVOID				Context,
	IN	PIO_STATUS_BLOCK	IoStatus,
	IN	ULONG				Reserved
	) {
	if (NT_SUCCESS (IoStatus->Status))
		(*(LPOVERLAPPED_COMPLETION_ROUTINE)Context) (NO_ERROR,
											// Substract size of options header
											// reported by the driver in the beggining
											// of the buffer
										((DWORD)IoStatus->Information
											-= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data)),
										(LPOVERLAPPED)IoStatus);
	else
		(*(LPOVERLAPPED_COMPLETION_ROUTINE)Context) (
										RtlNtStatusToDosError (IoStatus->Status),
											// Substract size of options header
											// reported by the driver in the beggining
											// of the buffer if dirver was able
											// to actually receive something (not
											// just options in the buffer
										((DWORD)IoStatus->Information >
											 FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data))
											? ((DWORD)IoStatus->Information
												-= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data))
											: ((DWORD)IoStatus->Information = 0),
										(LPOVERLAPPED)IoStatus);
	}


/*++

        I p x G e t O v e r l a p p e d R e s u l t
Routine Description:
		GetOverlappedResult wrapper: gives adptif.dll a chance to adjust
		returned parameters (currently number of bytes transferred).

Arguments:
		Same as in GetOverlappedResult (see SDK doc)
Return Value:
		Same as in GetOverlappedResult (see SDK doc)
--*/
BOOL
IpxGetOverlappedResult (
	HANDLE			Handle,  
	LPOVERLAPPED	lpOverlapped, 
	LPDWORD			lpNumberOfBytesTransferred, 
	BOOL			bWait
	) {
	BOOL res = GetOverlappedResult (Handle, lpOverlapped, lpNumberOfBytesTransferred, bWait);
	if (res) {
		if (NT_SUCCESS (lpOverlapped->Internal)) {
			if (lpOverlapped->Offset==MIPX_SEND_DATAGRAM)
				*lpNumberOfBytesTransferred += sizeof (IPX_HEADER);
			else if (lpOverlapped->Offset==MIPX_RCV_DATAGRAM)
				*lpNumberOfBytesTransferred -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
			// else - neither, for packets generated with
			// PostQueuedCompletionStatus
			}
		else {
			if (lpOverlapped->Offset==MIPX_SEND_DATAGRAM) {
				if (*lpNumberOfBytesTransferred>0)
					*lpNumberOfBytesTransferred += sizeof (IPX_HEADER);
				}
			else if (lpOverlapped->Offset==MIPX_RCV_DATAGRAM) {
				if (*lpNumberOfBytesTransferred>FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data))
					*lpNumberOfBytesTransferred -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
				else
					*lpNumberOfBytesTransferred = 0;
				}
			// else - neither, for packets generated with
			// PostQueuedCompletionStatus
			}
		}
	return res;
	}

/*++

        I p x G e t Q u e u e d C o m p l e t i o n S t a t u s

Routine Description:
		GetQueuedCompletionStatus wrapper: gives adptif.dll a chance to adjust
		returned parameters (currently number of bytes transferred)

Arguments:
		Same as in GetQueuedCompletionStatus (see SDK doc)
Return Value:
		Same as in GetQueuedCompletionStatus (see SDK doc)
--*/
BOOL
IpxGetQueuedCompletionStatus(
	HANDLE			CompletionPort,
	LPDWORD			lpNumberOfBytesTransferred,
	PULONG_PTR   	lpCompletionKey,
	LPOVERLAPPED	*lpOverlapped,
	DWORD 			dwMilliseconds
	) {
	BOOL	res = GetQueuedCompletionStatus (CompletionPort,
   					lpNumberOfBytesTransferred,
   					lpCompletionKey,
   					lpOverlapped,
   					dwMilliseconds);
	if (res) {
		if (NT_SUCCESS ((*lpOverlapped)->Internal)) {
			if ((*lpOverlapped)->Offset==MIPX_SEND_DATAGRAM) {
				*lpNumberOfBytesTransferred += sizeof (IPX_HEADER);
				(*lpOverlapped)->InternalHigh = *lpNumberOfBytesTransferred;
				}
			else if ((*lpOverlapped)->Offset==MIPX_RCV_DATAGRAM) {
				*lpNumberOfBytesTransferred -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
				(*lpOverlapped)->InternalHigh = *lpNumberOfBytesTransferred;
				}
			// else - neither, for packets generated with
			// PostQueuedCompletionStatus
			}
		else {
			if ((*lpOverlapped)->Offset==MIPX_SEND_DATAGRAM) {
				if (*lpNumberOfBytesTransferred>0) {
					*lpNumberOfBytesTransferred += sizeof (IPX_HEADER);
					(*lpOverlapped)->InternalHigh = *lpNumberOfBytesTransferred;
					}
				}
			else if ((*lpOverlapped)->Offset==MIPX_RCV_DATAGRAM) {
				if (*lpNumberOfBytesTransferred>FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data)) {
					*lpNumberOfBytesTransferred -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
					(*lpOverlapped)->InternalHigh = *lpNumberOfBytesTransferred;
					}
				else {
					*lpNumberOfBytesTransferred = 0;
					(*lpOverlapped)->InternalHigh = *lpNumberOfBytesTransferred;
					}
				}
			// else - neither, for packets generated with
			// PostQueuedCompletionStatus
			}
		}
	return res;
	}
		

/*++

        I p x A d j u s t I o C o m p l e t i o n P a r a m s

Routine Description:
		Adjust io completion parameters for io performed
		by IpxSendPacket or IpxReceivePacket  and completed
		through the mechanisms other than routines provided
		above

Arguments:
		lpOverlapped	 - overlapped structure passed to
							Ipx(Send/Recv)Packet routines
		lpNumberOfBytesTransferred - adjusted number of bytes
						transferred in io
		error			- win32 error code
		
Return Value:
		None
--*/
VOID
IpxAdjustIoCompletionParams (
	IN OUT LPOVERLAPPED	lpOverlapped,
	OUT LPDWORD			lpNumberOfBytesTransferred,
	OUT LPDWORD			error
	) {
	if (NT_SUCCESS (lpOverlapped->Internal)) {
		if (lpOverlapped->Offset==MIPX_SEND_DATAGRAM) {
			lpOverlapped->InternalHigh += sizeof (IPX_HEADER);
			*lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;
			}
		else if (lpOverlapped->Offset==MIPX_RCV_DATAGRAM) {
			lpOverlapped->InternalHigh -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
			*lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;
			}
		// else - neither, for packets generated with
		// PostQueuedCompletionStatus
		*error = NO_ERROR;
		}
	else {
		if (lpOverlapped->Offset==MIPX_SEND_DATAGRAM) {
			if (lpOverlapped->InternalHigh>0) {
				lpOverlapped->InternalHigh += sizeof (IPX_HEADER);
				*lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;
				}
			}
		else if (lpOverlapped->Offset==MIPX_RCV_DATAGRAM) {
			if (lpOverlapped->InternalHigh>FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data)) {
				lpOverlapped->InternalHigh -= FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data);
				*lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;
				}
			else {
				lpOverlapped->InternalHigh = 0;
				*lpNumberOfBytesTransferred = 0;
				}
			}
		// else - neither, for packets generated with
		// PostQueuedCompletionStatus
		*error = RtlNtStatusToDosError ((DWORD)lpOverlapped->Internal);
		}
	}

/*++

        I p x P o s t Q u e u e d C o m p l e t i o n S t a t u s

Routine Description:
		PostQueuedCompletionStatus wrapper: gives adptif.dll a chance to
		setup lpOverlapped so it can be correctly processed by
		the IpxGetQueueCompletionStatus and IpxGetOverlappedResult

Arguments:
		Same as in PostQueuedCompletionStatus (see SDK doc)
Return Value:
		Same as in PostQueuedCompletionStatus (see SDK doc)
--*/
BOOL
IpxPostQueuedCompletionStatus(
	HANDLE			CompletionPort,
	DWORD			dwNumberOfBytesTransferred,
	DWORD			dwCompletionKey,
	LPOVERLAPPED	lpOverlapped	
	) {
	lpOverlapped->Offset = 0;
	return PostQueuedCompletionStatus (CompletionPort,
					dwNumberOfBytesTransferred,
					dwCompletionKey,
					lpOverlapped);
	}


/*++

        I p x S e n d P a c k e t

Routine Description:

		Enqueue request to receive IPX packet and return immediately. Event will
		be signalled or comletion routine will be called when done

Arguments:

		Handle		 - Handle to adapter & socket to use
		AdapterIdx	- adapter on which to send
		IpxPacket    - ipx packet complete with header
		IpxPacketLength - length of the packet
		pReserved	 - buffer to supply info to IPX stack
		lpOverlapped - structure to be used for async IO:
						Internal	- reserved
						InternalHigh - reserved
						Offset		- not used
						OffsetHigh - not used
						hEvent - event to be signalled when IO completes or NULL
								if CompletionRoutine is to be called
		CompletionRoutine - to be called when IO operation is completes
Return Value:
		NO_ERROR	- if lpOverlapped->hEvent!=NULL, then recv has successfully completed
						(do not need to wait on event), otherwise, recv operation has
						started and completion routine will be called when done
		ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and recv could not
						be completed immediately, event will be signalled when
						operation is done: call GetOverlapedResult to retrieve result of
						the operation
		other (windows error code) - operation could not be started (completion routine
						won't be called)


--*/
DWORD WINAPI
IpxSendPacket (
		IN HANDLE						Handle,
		IN ULONG						AdapterIdx,
		IN PUCHAR						IpxPacket,
		IN ULONG						IpxPacketLength,
		IN PADDRESS_RESERVED			lpReserved,
		LPOVERLAPPED					lpOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
		) {
#define hdr ((PIPX_HEADER)IpxPacket)
#define opt ((PIPX_DATAGRAM_OPTIONS2)lpReserved)
	NTSTATUS				status;

    // Send the data to the correct physical index
    AdapterIdx = (ULONG)NicMapGetPhysicalNicId((USHORT)AdapterIdx);
	
		// Put IPX header parameters into datagram options:
			// Packet type
	opt->DgrmOptions.PacketType = hdr->pkttype;
			// Source
	opt->DgrmOptions.LocalTarget.NicId = (USHORT)AdapterIdx;
	IPX_NODENUM_CPY (&opt->DgrmOptions.LocalTarget.MacAddress, hdr->dst.node);
			// Destination
	IPX_NODENUM_CPY (&opt->RemoteAddress.NodeAddress, hdr->dst.node);
	IPX_NETNUM_CPY (&opt->RemoteAddress.NetworkAddress, hdr->dst.net);
	opt->RemoteAddress.Socket = hdr->dst.socket;
	
	lpOverlapped->Offset = MIPX_SEND_DATAGRAM;
	status = NtDeviceIoControlFile(
						Handle,
						lpOverlapped->hEvent,
						((lpOverlapped->hEvent!=NULL) || (CompletionRoutine==NULL))
							 ? NULL
							 : IpxSendCompletion,
						CompletionRoutine ? (LPVOID)CompletionRoutine : (LPVOID)lpOverlapped,
						(PIO_STATUS_BLOCK)lpOverlapped,
						MIPX_SEND_DATAGRAM,
						lpReserved,
						sizeof (IPX_DATAGRAM_OPTIONS2),
						&hdr[1],
						IpxPacketLength-sizeof (IPX_HEADER)
						);
	if (NT_SUCCESS (status)) {
		SetLastError (NO_ERROR);
		return NO_ERROR;
		}

#if DBG
	DbgPrint ("Ioctl MIPX_SEND_DATAGRAM failed with status %08x\n", status);
#endif
	return RtlNtStatusToDosError (status);
#undef hdr
#undef opt
	}


/*++

        I p x R e c v P a c k e t

Routine Description:

		Enqueue request to receive IPX packet and return immediately. Event will
		be signalled or comletion routine will be called when done

Arguments:
		Handle		 - Handle to adapter & socket to use
		AdapterIdx	- adapter on which to packet was received (set upon completion)
		IpxPacket    - buffer for ipx packet (complete with header)
		IpxPacketLength - length of the buffer
		pReserved	 - buffer to get info from IPX stack
		lpOverlapped - structure to be used for async IO:
						Internal	- Reserved
						InternalHigh - Reserved
						Offset		- not used
						OffsetHigh - not used
						hEvent - event to be signalled when IO completes or NULL
								if CompletionRoutine is to be called
		CompletionRoutine - to be called when IO operation is completes


Return Value:

		NO_ERROR	- if lpOverlapped->hEvent!=NULL, then send has successfully completed
						(do not need to wait on event), otherwise, send operation has
						started and completion routine will be called when done
		ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and send could not
						be completed immediately, event will be signalled when
						operation is done: call GetOverlapedResult to retrieve result of
						the operation
		other (windows error code) - operation could not be started (completion routine
						won't be called)

--*/
DWORD WINAPI
IpxRecvPacket(
		IN HANDLE 						Handle,
		OUT PUCHAR 						IpxPacket,
		IN ULONG						IpxPacketLength,
		IN PADDRESS_RESERVED			lpReserved,
		LPOVERLAPPED					lpOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
		) {
	NTSTATUS			status;
		// A temporary hack (due to the available ipx interface):
    ASSERTMSG ("Packet buffer does not follow reserved area ",
                    IpxPacket==(PUCHAR)(&lpReserved[1]));

	lpOverlapped->Offset = MIPX_RCV_DATAGRAM;
	status = NtDeviceIoControlFile(
						Handle,
						lpOverlapped->hEvent,
						((lpOverlapped->hEvent!=NULL) || (CompletionRoutine==NULL))
							? NULL
							: IpxRecvCompletion,
						CompletionRoutine ? (LPVOID)CompletionRoutine : (LPVOID)lpOverlapped,
						(PIO_STATUS_BLOCK)lpOverlapped,
						MIPX_RCV_DATAGRAM,
						NULL,
						0,
						lpReserved,
						FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data)
							+ IpxPacketLength
						);
	if (NT_SUCCESS (status)) {
		SetLastError (NO_ERROR);
		return NO_ERROR;
		}
#if DBG
	DbgPrint ("Ioctl MIPX_RCV_DATAGRAM failed with status %08x\n", status);
#endif
	return RtlNtStatusToDosError (status);
	}


/*++

        I p x C r e a t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:

		Register client that wants to be updated of any changes in
		adapter state

Arguments:

		NotificationEvent	    - event to be signaled when adapter state changes
		AdptGlobalParameters	    - parameters that common to all adapters

Return Value:

		Handle to configuration port thru which changes in adapter state
		are reported.  Returns INVALID_HANDLE_VALUE if port could not be created

--*/
HANDLE WINAPI
IpxCreateAdapterConfigurationPort(IN HANDLE NotificationEvent,
		                          OUT PADAPTERS_GLOBAL_PARAMETERS AdptGlobalParameters) 
{
	PCONFIG_PORT	port;
	INT				i;
	DWORD			error=NO_ERROR;

    TracePrintf(
        g_dwTraceId, 
        "IpxCreateAdapterConfigurationPort: entered.");

    // Allocate port data structure
	port = (PCONFIG_PORT)
	    RtlAllocateHeap (RtlProcessHeap (), 0, sizeof (CONFIG_PORT));
	    
    if (port == NULL) 
    {
        TracePrintf(
            g_dwTraceId, 
            "IpxCreateAdapterConfigurationPort: unable to allocate port.");
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
		
    	return INVALID_HANDLE_VALUE;
    }

	// Initialize port data structure
	port->event = NotificationEvent;
	InitializeListHead (&port->msgqueue);

	// Make sure we own the list
	EnterCriticalSection (&ConfigInfoLock);

	// Open channel to IPX stack if not already opened
	//
	if (IpxDriverHandle == NULL) 
	{
        TracePrintf(
            g_dwTraceId, 
            "IpxCreateAdapterConfigurationPort: calling OpenAdapterConfigPort.");
		error = OpenAdapterConfigPort();
    }
	else
	{
		error = NO_ERROR;
    }

	if (error==NO_ERROR) 
	{
		// Add messages about existing adapters to the beginning of the queue
		// (to be seen only by the new client)
		error = InitializeMessageQueueForClient(port);
		if (error==NO_ERROR) 
		{
			InsertTailList (&PortListHead, &port->link);
			AdptGlobalParameters->AdaptersCount = NumAdapters;
		}
		else 
		{
            TracePrintf(
                g_dwTraceId, 
                "IpxCreateAdapterConfigurationPort: InitMessQForClient fail.");
		}
	}
	else 
	{
        TracePrintf(
            g_dwTraceId, 
            "IpxCreateAdapterConfigurationPort: OpenAdapterConfigPort failed.");
	}
    
    // Release our lock on the configuration information
	LeaveCriticalSection (&ConfigInfoLock);

	if (error==NO_ERROR)
		return (HANDLE)port;
	else
		SetLastError (error);

	RtlFreeHeap (RtlProcessHeap (), 0, port);
	
	return INVALID_HANDLE_VALUE;
}

/*++

        I p x W a n C r e a t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:
		Same as above, but creates port that only reports ADAPTER_UP
		events on WAN adapters that	require IPXWAN negotiation.
		IpxGetQueuedAdapterConfigurationStatus on this port should be
		followed by IpxWanSetAdapterConfiguration obtained during the
		negotiation process, and ADAPTER_UP event will then be reported
		to other clients (including forwarder dirver)
*/
HANDLE WINAPI
IpxWanCreateAdapterConfigurationPort(
	IN	HANDLE						NotificationEvent,
	OUT PADAPTERS_GLOBAL_PARAMETERS AdptGlobalParameters
	) {
	INT				i;
	DWORD			error=NO_ERROR;
	PCONFIG_PORT	port;

		// Allocate port data structure
	port = (PCONFIG_PORT)RtlAllocateHeap (RtlProcessHeap (), 0,
					 				sizeof (CONFIG_PORT));
	if (port!=NULL) {
		// Initialize port data structure
		port->event = NotificationEvent;
		InitializeListHead (&port->msgqueue);
		EnterCriticalSection (&ConfigInfoLock);
		if (IpxWanPort==NULL) {
				// Open channel to IPX stack if not already opened
			if (IpxDriverHandle==NULL) {
				error = OpenAdapterConfigPort ();
				}
			else
				error = NO_ERROR;

			if (error==NO_ERROR) {
				IpxWanPort = port;
				AdptGlobalParameters->AdaptersCount = NumAdapters;
				}
			}
		else
			error = ERROR_ALREADY_EXISTS;
		LeaveCriticalSection (&ConfigInfoLock);
		if (error==NO_ERROR)
			return (HANDLE)port;
		else
			SetLastError (error);

		RtlFreeHeap (RtlProcessHeap (), 0, port);
		}
	else
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	
	return INVALID_HANDLE_VALUE;
	}




/*++

        I p x D e l e t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:

		Unregister client

Arguments:

		Handle		- configuration port handle

Return Value:

		NO_ERROR
		ERROR_INVALID_PARAMETER
		ERROR_GEN_FAILURE

--*/
DWORD WINAPI
IpxDeleteAdapterConfigurationPort (
			       IN HANDLE Handle
	) {
	PCONFIG_PORT	port = (PCONFIG_PORT)Handle;

	// Make sure we owe the list
	EnterCriticalSection (&ConfigInfoLock);
	if (port==IpxWanPort)
	{
		IpxWanPort = NULL;
    }
	else
	{
		RemoveEntryList (&port->link);
    }
    
#if DBG && defined(WATCHER_DIALOG)
		// Adapter port is maintained by the watcher dialog
#else
	if (IsListEmpty (&PortListHead) && (IpxWanPort==NULL))
	{
		CloseAdapterConfigPort (NULL);
    }
#endif

	LeaveCriticalSection (&ConfigInfoLock);

	// Delete messages that client have not dequeued
	while (!IsListEmpty (&port->msgqueue)) 
	{
		PLIST_ENTRY	cur = RemoveHeadList (&port->msgqueue);
		RtlFreeHeap (RtlProcessHeap (), 0,
			CONTAINING_RECORD (cur, ADAPTER_MSG, link));
	}
		// Free the port itself
	RtlFreeHeap (RtlProcessHeap (), 0, port);
	return NO_ERROR;
}

/*++

        G e t Q u e u e d A d a p t e r C o n f i g u r a t i o n S t a t u s

Routine Description:

		Get info from the list of adapter info chages queued to the
		configuration info port

Arguments:

		Handle			   - configuration port handle
		AdapterIndex		   - number of adapter being reported
		AdapterConfigurationStatus - new adapter status
		AdapterParameters - adapter parameters

Return Value:

		NO_ERROR		- new information is reported
		ERROR_NO_MORE_ITEMS	- there is nothing to report
		Windows error code - operation failed
--*/
DWORD WINAPI
IpxGetQueuedAdapterConfigurationStatus(IN HANDLE Handle,
                                       OUT PULONG AdapterIndex,
	                                   OUT PULONG AdapterConfigurationStatus,
	                                   PADAPTER_INFO AdapterInfo)
{
	PCONFIG_PORT	port = (PCONFIG_PORT)Handle;
	DWORD			error;
	PWCHAR pszName;

    // Make sure nothing changes while we are reading the info
	EnterCriticalSection (&ConfigInfoLock);

    // If there is something to report
	if (!IsListEmpty (&port->msgqueue)) { 
	    PADAPTER_MSG msg = CONTAINING_RECORD (port->msgqueue.Flink, ADAPTER_MSG, link);
		RemoveEntryList (&msg->link);
		LeaveCriticalSection (&ConfigInfoLock);

        // By now, the correct virtual nic id has been set
		*AdapterIndex = (ULONG)msg->info.Details.NicId;
		
		// Map driver reported nic states to adapter states
		switch (msg->info.Status) {
			case NIC_CREATED:
			case NIC_CONFIGURED:
				*AdapterConfigurationStatus = ADAPTER_CREATED;
				break;
			case NIC_DELETED:
				*AdapterConfigurationStatus = ADAPTER_DELETED;
				break;
			case NIC_LINE_UP:
				*AdapterConfigurationStatus = ADAPTER_UP;
				break;
			case NIC_LINE_DOWN:
				*AdapterConfigurationStatus = ADAPTER_DOWN;
				break;
			default:
				ASSERTMSG ("Unknown nic status ", FALSE);
		}
		// Copy adapter parameters to client's buffer
		AdapterInfo->InterfaceIndex = msg->info.InterfaceIndex;
		IPX_NETNUM_CPY (&AdapterInfo->Network,
							&msg->info.Details.NetworkNumber);
		IPX_NODENUM_CPY (&AdapterInfo->LocalNode,
							&msg->info.Details.Node);
		IPX_NODENUM_CPY (&AdapterInfo->RemoteNode,
							&msg->info.RemoteNodeAddress);
		AdapterInfo->LinkSpeed = msg->info.LinkSpeed;
		AdapterInfo->PacketType = msg->info.PacketType;
		AdapterInfo->MaxPacketSize = msg->info.MaxPacketSize;
		AdapterInfo->NdisMedium = msg->info.NdisMediumType;
		AdapterInfo->ConnectionId = msg->info.ConnectionId;

        // Copy in the adapter name
        pszName = wcsstr(msg->info.Details.AdapterName, L"{");
        if (!pszName)
            pszName = (PWCHAR)msg->info.Details.AdapterName;
        wcsncpy(AdapterInfo->pszAdpName, pszName, MAX_ADAPTER_NAME_LEN);

		EnterCriticalSection (&ConfigInfoLock);
		if (IsListEmpty (&port->msgqueue))  {
				// Last message -> reset event (in case
				// client uses manual reset event)
			BOOL res = ResetEvent (port->event);
			ASSERTMSG ("Can't reset port event ", res);
			}
			// Decrement reference count on processed message and dispose of it
			// when ref count gets to 0
			RtlFreeHeap(RtlProcessHeap (), 0, msg);
		error = NO_ERROR;	// There is a message in the buffer
		}
	else if (NT_SUCCESS (IoctlStatus.Status)) {
		error = ERROR_NO_MORE_ITEMS;	// No more messages, request is pending
		}
	else {	// Last request completed with error, report it to client,
			// Client will have to reopen the port to force posting of new request
		error = RtlNtStatusToDosError (IoctlStatus.Status);
#if DBG
		DbgPrint ("Reporting result of failed Ioctl to client: status:%0lx -> error:%ld\n",
					IoctlStatus.Status, error);
#endif			
		}
	LeaveCriticalSection (&ConfigInfoLock);
	SetLastError (error);
	return error;
	}

// 
//  Function:   IpxGetAdapterConfig
//
//  Queries the stack for the internal network number along with the current total
//  number of adapters.  Function blocks until the query completes.
//
DWORD IpxGetAdapterConfig(OUT LPDWORD lpdwInternalNetNum,
                          OUT LPDWORD lpdwAdapterCount) 
{
    DWORD dwErr = NO_ERROR, dwNet, dwCount; 
    
	// Synchronize
	EnterCriticalSection (&ConfigInfoLock);

	// Open channel to IPX stack if not already opened
	if (IpxDriverHandle==NULL)
		dwErr = OpenAdapterConfigPort();

    // Set the values that were read
    dwNet = InternalNetworkNumber;
    dwCount = NumAdapters;

    // Release our lock on the configuration information
	LeaveCriticalSection (&ConfigInfoLock);

    if (dwErr != NO_ERROR)
        return dwErr;

    *lpdwInternalNetNum = dwNet;
    *lpdwAdapterCount = dwCount;

    return NO_ERROR;
}


// 
//  Function:   IpxGetAdapterConfig
//
//  Queries the stack for the list of all adapters currently bound to a network.
//  This function blocks until the query completes.
//
DWORD IpxGetAdapterList(OUT PIPX_ADAPTER_BINDING_INFO pAdapters,
                        IN  DWORD dwMaxAdapters,
                        OUT LPDWORD lpdwAdaptersRead) 
{
	NTSTATUS			status;
	PNWLINK_ACTION		action;
	PIPX_NICS			request;
	IO_STATUS_BLOCK		IoStatus;
	PIPX_NIC_INFO		info=NULL;
    DWORD               dwActionBufSize, dwRead;

    *lpdwAdaptersRead = 0;
    
    // Calculate the size of the buffer that we'll use
    // to retrieve adapter information from the IPX Stack
    dwActionBufSize = FIELD_OFFSET (NWLINK_ACTION, Data)   +
					  FIELD_OFFSET (IPX_NICS, Data)        +
					  sizeof (IPX_NIC_INFO)                *
					  (dwMaxAdapters>0 ? dwMaxAdapters : 1);

    // Prepare the data to send to the IPX Stack to retrieve the 
    // information about each adapter
	action = (PNWLINK_ACTION) RtlAllocateHeap(RtlProcessHeap (), 0, dwActionBufSize);
	if (action!=NULL) {
        // Initialize the action buffer with the appropriate identifiers
		action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
		action->OptionType = NWLINK_OPTION_CONTROL;
		action->Option = MIPX_GETNEWNICINFO;

		// The BufferLength includes the length of everything after it, 
        // which is sizeof(ULONG) for Option plus whatever Data is present. 
		action->BufferLength = sizeof (action->Option)              +
							   FIELD_OFFSET(IPX_NICS,Data)          +
							   sizeof (IPX_NIC_INFO)                *
                               (dwMaxAdapters>0 ? dwMaxAdapters : 1);

        // Setting this flag makes the stack return information about
        // all known adapters
		request = (PIPX_NICS)action->Data;
		request->NoOfNics = 0;
		request->TotalNoOfNics = 0;
		request->fAllNicsDesired = TRUE;	

        // Send the Ioctl
		status = NtDeviceIoControlFile(IpxDriverHandle,NULL,NULL,NULL,&IoStatus,
		                               IOCTL_TDI_ACTION,NULL,0,action,dwActionBufSize);

        // Wait for it to complete
		if (status==STATUS_PENDING) {
			status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
			if (NT_SUCCESS (status))
				status = IoStatus.Status;
		}

        // Make sure it was a successful completion
		if (NT_SUCCESS (status)) {
			PADAPTER_MSG	msg;
			PIPX_NIC_INFO	NicPtr = (PIPX_NIC_INFO)request->Data;
			UINT			i, j=0;
			dwRead = request->TotalNoOfNics;

            // Loop through the adapters
			for (i=0; (i<dwRead) && (status==STATUS_SUCCESS); i++, NicPtr++) {
			    if (NicPtr->Details.NetworkNumber != 0) {
                    pAdapters[j].AdapterIndex  = (ULONG)NicMapGetVirtualNicId((USHORT)NicPtr->Details.NetworkNumber);
                    PUTULONG2LONG(pAdapters[j].Network, NicPtr->Details.NetworkNumber);
                    memcpy(pAdapters[j].LocalNode, NicPtr->Details.Node, 6);
                    memcpy(pAdapters[j].RemoteNode, NicPtr->RemoteNodeAddress, 6);
                    pAdapters[j].MaxPacketSize = NicPtr->MaxPacketSize;
                    pAdapters[j].LinkSpeed     = NicPtr->LinkSpeed;
                    j++;
                }
            }
			*lpdwAdaptersRead = j;
        }

        // We're done with the action buffer we sent to the stack
        // now.  It's safe to clean it up.
		RtlFreeHeap (RtlProcessHeap (), 0, action);
	}

    return NO_ERROR;
}

// Requests the list of adapters from the stack
DWORD IpxSeedNicMap() {
	NTSTATUS			status;
	PNWLINK_ACTION		action;
	PIPX_NICS			request;
	IO_STATUS_BLOCK		IoStatus;
	PIPX_NIC_INFO		info=NULL;
    DWORD               dwActionBufSize, dwRead;

    TracePrintf(g_dwTraceId, "IpxSeedMap: entered.");
    
    // Calculate the size of the buffer that we'll use
    // to retrieve adapter information from the IPX Stack
    dwActionBufSize = FIELD_OFFSET (NWLINK_ACTION, Data)   +
					  FIELD_OFFSET (IPX_NICS, Data)        +
					  sizeof (IPX_NIC_INFO);

    // Prepare the data to send to the IPX Stack to retrieve the 
    // information about each adapter
	action = (PNWLINK_ACTION) RtlAllocateHeap(RtlProcessHeap (), 0, dwActionBufSize);
	if (action!=NULL) {
        // Initialize the action buffer with the appropriate identifiers
		action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
		action->OptionType = NWLINK_OPTION_CONTROL;
		action->Option = MIPX_GETNEWNICINFO;

		// The BufferLength includes the length of everything after it, 
        // which is sizeof(ULONG) for Option plus whatever Data is present. 
		action->BufferLength = sizeof (action->Option)              +
							   FIELD_OFFSET(IPX_NICS,Data)          +
							   sizeof (IPX_NIC_INFO);
							   
        // Setting this flag makes the stack return information about
        // all known adapters
		request = (PIPX_NICS)action->Data;
		request->NoOfNics = 0;
		request->TotalNoOfNics = 0;
		request->fAllNicsDesired = TRUE;	

        // Send the Ioctl
		status = NtDeviceIoControlFile(IpxDriverHandle,NULL,NULL,NULL,&IoStatus,
		                               IOCTL_TDI_ACTION,NULL,0,action,dwActionBufSize);

        // Wait for it to complete
		if (status==STATUS_PENDING) {
			status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
			if (NT_SUCCESS (status))
				status = IoStatus.Status;
		}

        // Make sure it was a successful completion
		if (NT_SUCCESS (status)) {
			PADAPTER_MSG	msg;
			PIPX_NIC_INFO	NicPtr = (PIPX_NIC_INFO)request->Data;
			UINT			i, j=0;

			NumAdapters = request->TotalNoOfNics;
			dwRead = request->NoOfNics;

            // Display the nics and their status as reported in this completion of the
            // MIPX_GETNEWNICINFO ioctl.
            TracePrintf(g_dwTraceId, "==========================");
            TracePrintf(g_dwTraceId, "MIPX_GETNEWNICS Completed. (%d of %d adapters reported)", request->NoOfNics, request->TotalNoOfNics);
            TracePrintf(g_dwTraceId, "Internal Net Number: %x", InternalNetworkNumber);
            DbgDisplayNics(NicPtr, dwRead);
            
            // Loop through the adapters
			for (i=0; (i<dwRead) && (status==STATUS_SUCCESS); i++, NicPtr++) {
			    GetNicOpCode(NicPtr);   // get rid of op code since this is clean (shouldn't be one)
			    NicMapAdd (NicPtr);     // add the nic to the map
            }

			// Post an irp for each adapter in case the stack decides to 
			// send information one adapter at a time.  Sending 5 extra 
			// irps gives pad so that stack will always have an irp to complete
			for (i = 0; i < 5; i++) {
				status = RtlQueueWorkItem (PostAdapterConfigRequest, NULL, 
                                                                        WT_EXECUTEINIOTHREAD);
				ASSERTMSG ("Could not queue router work item ", status==STATUS_SUCCESS);
			}
        }

        // We're done with the action buffer we sent to the stack
        // now.  It's safe to clean it up.
		RtlFreeHeap (RtlProcessHeap (), 0, action);
	}

    return NO_ERROR;
}

// Simulates a message in the given port that the internal adapter 
// was reported as configured.
DWORD IpxPostIntNetNumMessage(PCONFIG_PORT pPort, DWORD dwNewNetNum) {
    PADAPTER_MSG msg;
    
    TracePrintf(g_dwTraceId, "IpxPostIntNetNumMessage: entered.");
    
    // Send a regular adapter update message but make the 
    // adapter index equal to zero.
    msg = (PADAPTER_MSG)RtlAllocateHeap (RtlProcessHeap (), 0, sizeof(ADAPTER_MSG));
    if (msg == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize the message
    ZeroMemory(msg, sizeof(ADAPTER_MSG));
    msg->info.Details.NetworkNumber = dwNewNetNum;
    msg->info.Status = NIC_CONFIGURED;
    IPX_NODENUM_CPY (msg->info.Details.Node, INTERNAL_NODE_ADDRESS);

    // Signal event if this is the first message we process
    // and client queue is empty
    if (IsListEmpty (&pPort->msgqueue)) {
	    BOOL res = SetEvent (pPort->event);
	    ASSERTMSG ("Can't set client event ", res);
    }

    // Insert the message into the port's message queue.
    InsertTailList (&pPort->msgqueue, &msg->link);

    return NO_ERROR;
}

//
//  Function    IpxDoesRouteExist
//
//  Queries the stack to see if it has a route to the given network
//
//  Arguments:
//      puNetwork       The network-ordered network number to query for
//      pbRouteFound    Set to true if network is found, false otherwise
//
//  Returns:
//      NO_ERROR on success
//      Otherwise, an error that can be displayed with FormatMessage
//      
DWORD IpxDoesRouteExist (IN PUCHAR puNetwork, OUT PBOOL pbRouteFound) {
	NTSTATUS status;
	PNWLINK_ACTION action;
	PISN_ACTION_GET_LOCAL_TARGET pTarget;
	IO_STATUS_BLOCK	IoStatusBlock;
	PUCHAR puIoctlBuffer;
	DWORD dwBufferSize;
	
    // Verify parameters
    if (!puNetwork || !pbRouteFound)
        return ERROR_INVALID_PARAMETER;

    // Initialize
    *pbRouteFound = FALSE;
    dwBufferSize = sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_LOCAL_TARGET);
    puIoctlBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, dwBufferSize);
    if (!puIoctlBuffer)
        return ERROR_NOT_ENOUGH_MEMORY;
    ZeroMemory(puIoctlBuffer, dwBufferSize);

    // Initialize the buffer for the ioctl
	action = (PNWLINK_ACTION)puIoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->Option = MIPX_LOCALTARGET;
	action->BufferLength = sizeof (action->Option) + sizeof(ISN_ACTION_GET_LOCAL_TARGET);
	pTarget = (PISN_ACTION_GET_LOCAL_TARGET) action->Data;
	pTarget->IpxAddress.NetworkAddress = *((ULONG*)puNetwork);
	
    // Use critical section to serialize usage of driver handle
	EnterCriticalSection (&ConfigInfoLock);

	// Ask the stack if the route exists
	status = NtDeviceIoControlFile(IpxDriverHandle,
                                   NULL,
						           NULL,
						           NULL,
						           &IoStatusBlock,
						           IOCTL_TDI_ACTION,
						           NULL,
						           0,
						           action,
						           dwBufferSize);

    // Wait for an answer						           
	if (status == STATUS_PENDING)
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
	LeaveCriticalSection (&ConfigInfoLock);

    // Find out if the route was found
    if (NT_SUCCESS(IoStatusBlock.Status))
		*pbRouteFound = TRUE;
	else
	    *pbRouteFound = FALSE;

    // Cleanup
    RtlFreeHeap (RtlProcessHeap (), 0, puIoctlBuffer);
		
    return RtlNtStatusToDosError (status);
}




/*++

	G e t A d a p t e r N a m e W


Routine  Description:
		Returns UNICODE name of the adapter associated with given index

Arguments:

		AdapterIndex		- index of adapter
		AdapterNameSize		- size of adapter name (in bytes), including terminal wchar NULL
		AdapterNameBuffer	- buffer to receive adapter name

Return Value:

		NO_ERROR			- adapter name is in the buffer
		ERROR_INVALID_PARAMETER - adapter with given index does not exist
		ERROR_INSUFFICIENT_BUFFER   - buffer in to small. Updates AdapterNameSize to
					      the correct value.
		Other windows error code - operation failed

--*/
DWORD WINAPI
GetAdapterNameFromPhysNicW(
	IN ULONG	AdapterIndex,
	IN OUT PULONG	AdapterNameSize,
	OUT LPWSTR	AdapterNameBuffer
	) {
	NTSTATUS				status;
	DWORD					error;
	ULONG					ln;
	PNWLINK_ACTION			action;
	IO_STATUS_BLOCK			IoStatusBlock;
	PISN_ACTION_GET_DETAILS	details;
	CHAR					IoctlBuffer[
							sizeof (NWLINK_ACTION)
							+sizeof (ISN_ACTION_GET_DETAILS)];


	action = (PNWLINK_ACTION)IoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option)
							+sizeof (ISN_ACTION_GET_DETAILS);
	action->Option = MIPX_CONFIG;
	details = (PISN_ACTION_GET_DETAILS)action->Data;
	details->NicId = (USHORT)AdapterIndex;
	
	// Use critical section to serialize usage of driver handle
	EnterCriticalSection (&ConfigInfoLock);
	status = NtDeviceIoControlFile(
						IpxDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						action,
						sizeof(NWLINK_ACTION)
						+sizeof (ISN_ACTION_GET_DETAILS));
	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatusBlock.Status;
		}
	LeaveCriticalSection (&ConfigInfoLock);


	if (NT_SUCCESS (status)) {
			// Compute required buffer size
		ln = (lstrlenW (details->AdapterName)+1)*sizeof(WCHAR);
		if (ln<=(*AdapterNameSize)) {
				// Size of provided buffer is ok, copy the result
			*AdapterNameSize = ln;
			lstrcpyW (AdapterNameBuffer,details->AdapterName);
			error = NO_ERROR;
			}
		else {
				// Caller buffer is to small
			*AdapterNameSize = ln;
			error = ERROR_INSUFFICIENT_BUFFER;
			}
		}
	else {
		error = RtlNtStatusToDosError (status);
#if DBG
		DbgPrint ("TDI Ioctl MIPX_CONFIG failed with status %08x\n",
				 status);
#endif
		}
	return error;
	}


DWORD WINAPI
GetAdapterNameW(IN ULONG	AdapterIndex,
	            IN OUT PULONG	AdapterNameSize,
	            OUT LPWSTR	AdapterNameBuffer)
{
    return GetAdapterNameFromPhysNicW((ULONG)NicMapGetPhysicalNicId((USHORT)AdapterIndex),
                                      AdapterNameSize,
                                      AdapterNameBuffer);
}

DWORD WINAPI
GetAdapterNameFromMacAddrW(IN PUCHAR puMacAddr,
	                       IN OUT PULONG AdapterNameSize,
	                       OUT LPWSTR AdapterNameBuffer)
{
//    return GetAdapterNameFromPhysNicW((ULONG)GetPhysFromMac(puMacAddr),
//                                      AdapterNameSize,
//                                      AdapterNameBuffer);
    return NO_ERROR;
}

/*++

        I p x W a n S e t A d a p t e r C o n f i g u r a t i o n

Routine Description:

		Sets adapter configuration to be reported to both user and
		kernel mode clients (through the ADAPTER_UP/LINE_UP events)
Arguments:

		AdapterIndex	- number of adapter being set
		IpxWanInfo		- IPXWAN negotiated parameters

Return Value:

		NO_ERROR			- adapter info set successfully
		Windows error code	- operation failed
--*/
DWORD
IpxWanSetAdapterConfiguration (
	IN ULONG		AdapterIndex,
	IN PIPXWAN_INFO	IpxWanInfo
	) {
	NTSTATUS				status;
	PNWLINK_ACTION			action;
	IO_STATUS_BLOCK			IoStatusBlock;
	PIPXWAN_CONFIG_DONE		config;
	CHAR					IoctlBuffer[
							sizeof (NWLINK_ACTION)
							+sizeof (IPXWAN_CONFIG_DONE)];


	action = (PNWLINK_ACTION)IoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option)
							+sizeof (IPXWAN_CONFIG_DONE);
	action->Option = MIPX_IPXWAN_CONFIG_DONE;
	config = (PIPXWAN_CONFIG_DONE)action->Data;
	config->NicId = NicMapGetPhysicalNicId((USHORT)AdapterIndex);
	IPX_NETNUM_CPY (&config->Network, &IpxWanInfo->Network);
	IPX_NODENUM_CPY (&config->LocalNode, &IpxWanInfo->LocalNode);
	IPX_NODENUM_CPY (&config->RemoteNode, &IpxWanInfo->RemoteNode);
	
		// Use critical section to serialize usage of driver handle
	EnterCriticalSection (&ConfigInfoLock);
	status = NtDeviceIoControlFile(
						IpxDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						action,
						sizeof(NWLINK_ACTION)
						+sizeof (IPXWAN_CONFIG_DONE));
	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatusBlock.Status;
		}

	LeaveCriticalSection (&ConfigInfoLock);

#if DBG
	if (!NT_SUCCESS (status)) {
		DbgPrint ("TDI Ioctl MIPX_IPXWAN_CONFIG_DONE failed with status %08x\n",
				 status);
		}
#endif

	return RtlNtStatusToDosError (status);
	}

/*++

        I p x W a n Q u e r y I n a c t i v i t y T i m e r

Routine Description:

		Returns value of inactivity timer associated with WAN line
Arguments:
		ConnectionId		- connection id that identifies WAN line (used only
								if *AdapterIndex==INVALID_NICID
		AdapterIndex		- adapter index that identifies WAN line (preferred
							over connection id), if *AdapterIndex==INVALID_NICID
							the value of connection id is used to identify the
							WAN line and value of AdapterIndex is returned.
		InactivityCounter	- value of inactivity counter.

Return Value:

		NO_ERROR			- inactivity timer reading is returned
		Windows error code	- operation failed
--*/
DWORD
IpxWanQueryInactivityTimer (
	IN ULONG			ConnectionId,
	IN OUT PULONG		AdapterIndex,
	OUT PULONG			InactivityCounter
	) {
	NTSTATUS					status;
	PNWLINK_ACTION				action;
	IO_STATUS_BLOCK				IoStatusBlock;
	PIPX_QUERY_WAN_INACTIVITY	query;
	CHAR						IoctlBuffer[
									sizeof (NWLINK_ACTION)
									+sizeof (IPX_QUERY_WAN_INACTIVITY)];

	action = (PNWLINK_ACTION)IoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option)
							+sizeof (IPX_QUERY_WAN_INACTIVITY);
	action->Option = MIPX_QUERY_WAN_INACTIVITY;
	query = (PIPX_QUERY_WAN_INACTIVITY)action->Data;
	query->ConnectionId = ConnectionId;
	query->NicId = NicMapGetPhysicalNicId((USHORT)(*AdapterIndex));
	
		// Use critical section to serialize usage of driver handle
	EnterCriticalSection (&ConfigInfoLock);
	status = NtDeviceIoControlFile(
						IpxDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						action,
						sizeof(NWLINK_ACTION)
						+sizeof (IPX_QUERY_WAN_INACTIVITY));
	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatusBlock.Status;
		}
	LeaveCriticalSection (&ConfigInfoLock);

	if (NT_SUCCESS (status)) {
		*AdapterIndex = query->NicId;
		*InactivityCounter = query->WanInactivityCounter;
		}
#if DBG
	else {
		DbgPrint ("TDI Ioctl MIPX_QUERY_WAN_INACTIVITY failed with status %08x\n",
				 status);
		}
#endif

	return RtlNtStatusToDosError (status);
	}


	
/*++

	O p e n A d a p t e r C o n f i g P o r t


Routine  Description:

	Creates path to adapter configuration mechanism provided by the IPX stack
	and obtains "static" adapter information (number of adapters, internal net parameters)

Arguments:

		None
Return Value:

	NO_ERROR - port was open OK
	Windows error code - operation failed
--*/
DWORD
OpenAdapterConfigPort (void) {
	UNICODE_STRING		FileString;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	DWORD 				i; 

    // Initialize the parameters needed to open the driver
	RtlInitUnicodeString (&FileString, ISN_IPX_NAME);
	InitializeObjectAttributes(
			&ObjectAttributes,
			&FileString,
			OBJ_CASE_INSENSITIVE,
			NULL,
			NULL);

    // Get a handle to the ipx driver
	status = NtOpenFile(&IpxDriverHandle,
				        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
				        &ObjectAttributes,
				        &IoStatus,
				        FILE_SHARE_READ | FILE_SHARE_WRITE,
				        0);

    // If the driver handle wasn't opened, we're in an error state
	if (NT_SUCCESS (status)) {
		PISN_ACTION_GET_DETAILS	details;
		PNWLINK_ACTION			action;
		CHAR					IoctlBuffer[sizeof (NWLINK_ACTION)
											+sizeof (ISN_ACTION_GET_DETAILS)];

        // Prepare to send an ioctl to the stack to get the internal
        // net information along with the global adapter information
		action = (PNWLINK_ACTION)IoctlBuffer;
		action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
		action->OptionType = NWLINK_OPTION_CONTROL;
		action->BufferLength = sizeof(action->Option) + sizeof(ISN_ACTION_GET_DETAILS);
    	action->Option = MIPX_CONFIG;
		details = (PISN_ACTION_GET_DETAILS)action->Data;

        // Nic id 0 will return internal net information and
        // total number of adapters
		details->NicId = 0;	
							
	    // Send the ioctl
		status = NtDeviceIoControlFile(
							IpxDriverHandle,
							NULL,
							NULL,
							NULL,
							&IoStatus,
							IOCTL_TDI_ACTION,
							NULL,
							0,
							action,
							sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_DETAILS));

        // Wait for the ioctl to complete
		if (status==STATUS_PENDING) {
			status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
			if (NT_SUCCESS (status))
				status = IoStatus.Status;
		}

        // If the stack reports all the requested information without error,
        // update global variables with the information retrieved.
		if (NT_SUCCESS (status)) {
			NumAdapters = details->NicId;
			InternalNetworkNumber = details->NetworkNumber;

            // Seed the nic map by forcing the stack to at least report
            // one nic.  (you'll always be guarenteed that one nic will
            // be available -- the IpxLoopbackAdadpter
            IpxSeedNicMap();

			return NO_ERROR;
		}
#if DBG
        // If this branch is reached, display the ioctl error code
		else
			DbgPrint ("TDI Ioctl MIPX_CONFIG failed with status %08x\n",status);
#endif
	}
#if DBG
    // If this branch is reached, display the couldn't open driver error
	else 
		DbgPrint ("NtOpenFile failed with status %08x\n",status);
#endif
	return RtlNtStatusToDosError (status);
}

/*++

	I n i t i a l i z e M e s s a g e Q u e u e F o r C l i e n t


Routine  Description:
	Inserts messages that were already reported to existing clients
	in the beginning of the queue and points new client port (control block)
	to them.  Thus new client can see adapters that were already reported to
	others before, while others are not disturbed

Arguments:
	config - new client port (control block)

Return Value:
	NO_ERROR - messages were inserted OK
	Windows error code - operation failed
--*/
	
DWORD
InitializeMessageQueueForClient (PCONFIG_PORT port) {
	NTSTATUS		status = STATUS_SUCCESS;
    DWORD           dwAdapterCount;
	PADAPTER_MSG	msg;
	PIPX_NIC_INFO	NicPtr;
	DWORD			i, dwErr;
	USHORT          usNicId;
	
    // Output some debug information
    TracePrintf(g_dwTraceId, "InitializeMessageQueueForClient: entered.");

    // Find out how many adapters we know about in our table.
    dwAdapterCount = NicMapGetMaxNicId();

    // Loop through the adapters
	for (i = 0; i <= dwAdapterCount; i++) 
	{
	    NicPtr = NicMapGetNicInfo ((USHORT)i);
	    if (!NicPtr)
	        continue;
	        
#if DBG && defined(WATCHER_DIALOG)
		if (IsAdapterDisabled (NicPtr->NicId))
			continue;
#endif
		if (NicPtr->IpxwanConfigRequired == 1)
			continue;

        // Place the appropriate messages in the message queue of
        // the port of the client passed in.
        //
		switch (NicPtr->Status) 
		{
			case NIC_CONFIGURED:
			case NIC_LINE_UP:
                // Insert the message in the client queue
                //
                usNicId = NicMapGetVirtualNicId(NicPtr->Details.NicId);
                if (usNicId == NIC_MAP_INVALID_NICID)
                {
                    break;
                }
                NicPtr->Details.NicId = usNicId;
				msg = (PADAPTER_MSG) 
				    RtlAllocateHeap(RtlProcessHeap (), 0, sizeof(ADAPTER_MSG));
				if (msg!=NULL) 
				{
					RtlCopyMemory (&msg->info, NicPtr, sizeof (IPX_NIC_INFO));
					InsertTailList (&port->msgqueue, &msg->link);
					status = STATUS_SUCCESS;
				}
				else 
				{
#if DBG
					DbgPrint ("Could not allocate memory for config"
							 " message (gle:%08x).\n",
	 						 GetLastError ());
#endif
					status = STATUS_NO_MEMORY;
				}
				break;
				
			case NIC_DELETED:
			case NIC_CREATED:
			case NIC_LINE_DOWN:
				break;
				
			default:
				ASSERTMSG ("Unknown nic state reported ", FALSE);
        }
        
    }
    DbgDisplayMap();

    // Advertise the internal adapter
    dwErr = IpxPostIntNetNumMessage(port, InternalNetworkNumber);
    if (dwErr != NO_ERROR) 
    {
        TracePrintf(
            g_dwTraceId, 
            "Unable to report internal network number: %x  Err: %x",
            InternalNetworkNumber, 
            dwErr);
    }                                     

    // Go ahead and signal the client to do its processing
    // if everything has been successful to this point and
    // if the client's message queue isn't empty.
	if (NT_SUCCESS (status)) 
	{
		if (!IsListEmpty (&port->msgqueue)) 
		{
			BOOL res = SetEvent (port->event);
			ASSERTMSG ("Can't set client's event ", res);
		}
	}

	return RtlNtStatusToDosError (status);
}

/*++

	C l o s e A d a p t e r C o n f i g P o r t

Routine  Description:
	Closes path to the IPX stack adapter notification mechanism	
Arguments:
	None
Return Value:
	STATUS_SUCCESS - port was closed OK
	NT error status - operation failed
	
--*/
NTSTATUS
CloseAdapterConfigPort (PVOID pvConfigBuffer) {
	NTSTATUS	status;

	TracePrintf(g_dwTraceId, "CloseAdapterConfigPort: Entered");
	
	// Only close it if it is open
	if (IpxDriverHandle!=NULL) {			
		HANDLE	localHandle = IpxDriverHandle;
		IpxDriverHandle = NULL;
		status = NtClose (localHandle);
		ASSERTMSG ("NtClose failed ", NT_SUCCESS (status));
	}

	// Get rid of the buffer
	if (pvConfigBuffer != NULL)
		RtlFreeHeap (RtlProcessHeap(), 0, pvConfigBuffer);
		
	while (AdapterChangeApcPending>0)
		Sleep (100);
		
	return NO_ERROR;
}


/*++

	I n s e r t M e s s a g e

Routine  Description:
	Inserts message into client port queue
Arguments:
	port		- client port to isert message into
	NicInfo		- adapter info to be inserted as the message
Return Value:
	STATUS_SUCCESS - message was inserted ok
	NT error status - operation failed
	
--*/
NTSTATUS
InsertMessage (PCONFIG_PORT	port,
               PIPX_NIC_INFO	NicInfo) 
{
	PADAPTER_MSG	msg;

    // Allocate a new message
	msg = (PADAPTER_MSG)RtlAllocateHeap (RtlProcessHeap (), 
	                                     0,
						                 sizeof (ADAPTER_MSG));
	if (msg!=NULL) {
        // Copy in the Nic information
		RtlCopyMemory (&msg->info, NicInfo, sizeof (IPX_NIC_INFO));

		// Signal event if this is the first message we process
		// and client queue is empty
		if (IsListEmpty (&port->msgqueue)) {
			BOOL res = SetEvent (port->event);
			ASSERTMSG ("Can't set client event ", res);
		}

        // Insert the message into the port's message queue.
		InsertTailList (&port->msgqueue, &msg->link);
		return STATUS_SUCCESS;
	}
	else {
#if DBG
    	DbgPrint ("Could not allocate memory for config" " message (gle:%08x).\n",GetLastError ());
#endif
		return STATUS_NO_MEMORY;
	}
}

/*++

	P r o c e s s A d a p t e r C o n f i g I n f o

Routine  Description:
	Process adapter change information returned by the IPX stack and
	converts it to messages

Arguments:
	None

Return Value:
	None
	
--*/
NTSTATUS
ProcessAdapterConfigInfo (
    IN PVOID pvConfigBuffer) 
{
	INT				i, nMessages, nClients=0;
	PNWLINK_ACTION	action = (PNWLINK_ACTION)pvConfigBuffer;
	PIPX_NICS		request = (PIPX_NICS)action->Data;
	PIPX_NIC_INFO	NicPtr = (PIPX_NIC_INFO)request->Data;
	NTSTATUS		status = STATUS_SUCCESS;

    // Update number of adapters 
	NumAdapters = request->TotalNoOfNics; 
	nMessages = request->NoOfNics;

    // Display the nics and their status as reported in this completion of the
    // MIPX_GETNEWNICINFO ioctl.
    DbgDisplayNics(NicPtr, nMessages);

    // Loop through all of the adapters
	for (i=0; (i<nMessages) && (status==STATUS_SUCCESS); i++, NicPtr++) 
	{
		PLIST_ENTRY		cur;
		DWORD dwOpCode;

        // The stack will notify us that we need to renumber our
        // nic id's based on the addition/deletion adapters.  Find
        // out if this message is telling us that we need to renumber
        dwOpCode = GetNicOpCode(NicPtr);

        // Map the physical nic id to a virtual one -- rearraging
        // the mapping tables if needed.  Also, instruct the 
        // forwarder to renumber its nic id's as well
        if (dwOpCode == NIC_OPCODE_INCREMENT_NICIDS) 
        {
            FwRenumberNics (dwOpCode, NicPtr->Details.NicId);
            NicMapRenumber (dwOpCode, NicPtr->Details.NicId);
            NicMapAdd(NicPtr);
            TracePrintf(
                g_dwTraceId, 
                "Added %d -- Increment map", 
                NicPtr->Details.NicId);
            NicPtr->Details.NicId = 
                NicMapGetVirtualNicId(NicPtr->Details.NicId);
        }
        else if (dwOpCode == NIC_OPCODE_DECREMENT_NICIDS) 
        {
            USHORT usNicId = 
                NicMapGetVirtualNicId(NicPtr->Details.NicId);
            FwRenumberNics (dwOpCode, NicPtr->Details.NicId);
            NicMapDel (NicPtr);
            NicMapRenumber (dwOpCode, NicPtr->Details.NicId);
            TracePrintf(
                g_dwTraceId, 
                "Deleted %d -- Decrement map", 
                NicPtr->Details.NicId);
            NicPtr->Details.NicId = usNicId;
        }
        else 
        {
            if (NicPtr->Status != NIC_DELETED) 
            {
                TracePrintf(
                    g_dwTraceId, 
                    "Configured: %d -- Map reconfigure", 
                    NicPtr->Details.NicId);
                NicMapReconfigure(NicPtr);
            }
            else
            {
                TracePrintf(
                    g_dwTraceId, 
                    "Deleted: %d -- No map renumber", 
                    NicPtr->Details.NicId);
                NicMapDel(NicPtr);
            }
                
            NicPtr->Details.NicId = 
                NicMapGetVirtualNicId(NicPtr->Details.NicId);
        }

        // If the information about the current NIC is stating 
        // that a NIC has been created with a network address of
        // zero, and it's not a wan link (unumbered wan links can 
        // have net number = 0), then nothing needs to be done 
        // about this adapter since we wont be able to send information
        // out over it anyway.
		if ((NicPtr->Status==NIC_CREATED)               &&
			(NicPtr->Details.NetworkNumber==0)          &&
			(NicPtr->NdisMediumType!=NdisMediumWan))
        {			
			continue;
	    }

        #if DBG && defined(WATCHER_DIALOG)
        // Make sure that the adapter is enabled
		if (IsAdapterDisabled (NicPtr->NicId))
		{
			continue;
	    }
        #endif
        
        // Update the ipxwan configuration if neccesary
        //
		if (NicPtr->IpxwanConfigRequired==1) 
		{
            if (IpxWanPort!=NULL) 
            {
				status = InsertMessage (IpxWanPort, NicPtr);	
            }
		}

		else
		{
            // If this is a notification that the nic was deleted, 
            // tell the computers calling in that the nic was deleted.
            if ((IpxWanPort!=NULL) && (NicPtr->Status==NIC_DELETED)) 
            {
				status = InsertMessage (IpxWanPort, NicPtr);
            }

			// Signal each client (as in rtrmgr, sap, rip) to
            // check the status of the current Nic.
			for (cur = PortListHead.Flink; 
                 (cur != &PortListHead) && (status == STATUS_SUCCESS); 
                 cur = cur->Flink) 
            {
				status = 
				    InsertMessage (
				        CONTAINING_RECORD (cur,	CONFIG_PORT, link), 
				        NicPtr);
			}
		}
    }
    DbgDisplayMap();

	return status;
}

/*++

	A d a p t e r C h a n g e A P C

Routine  Description:
	APC invoked when adapter change notification IRP is completed by the Ipx Stack
	It is only used when running in router context (alertable thread provided by
	rtutils is used)
Arguments:
		Context - Not used
		IoStatus - status of completed io operation
		Reserved - ???
Return Value:
	None
	
--*/
VOID
AdapterChangeAPC (
    PVOID context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved) 
{
    DWORD dwErr, dwNetNum = 0;
    BOOL bNewInternal = FALSE;      
    PVOID pvConfigBuffer = ((PUCHAR)context) + sizeof(DWORD);       

    ASSERT (IoStatus==&IoctlStatus);

    // Display the id of the buffer reporting this information
    //
    TracePrintf(
        g_dwTraceId, 
        "AdapterChangeAPC called for buffer %d", 
        *((DWORD*)context));

    // [pmay] Check to see if the internal network number has 
    // changed.
    if (PnpGetCurrentInternalNetNum(&dwNetNum) == NO_ERROR) 
    {
        if ((bNewInternal = (InternalNetworkNumber != dwNetNum)) == TRUE) 
        {
            // Notify all clients to adptif (rtrmgr, sap, rip) that the 
            // internalnetwork number has changed.
            if (PnpHandleInternalNetNumChange(dwNetNum) == NO_ERROR)
            {
                InternalNetworkNumber = dwNetNum;
            }
        }
    }

    // Output some debug information
    {
        PNWLINK_ACTION  action = (PNWLINK_ACTION)pvConfigBuffer;
     	PIPX_NICS		request = (PIPX_NICS)action->Data;
        TracePrintf(
            g_dwTraceId, 
            "==========================");
        TracePrintf(
            g_dwTraceId, 
            "MIPX_GETNEWNICS Completed. (%d of %d adapters reported)", 
            request->NoOfNics, 
            request->TotalNoOfNics);
        TracePrintf(
            g_dwTraceId, 
            "Internal Net Number: %x (%s)", 
            dwNetNum, 
            (bNewInternal) ? "new" : "same");
    }

    // Ignore request when port is closed
    //
	if (IpxDriverHandle!=NULL) 
	{ 
		EnterCriticalSection (&ConfigInfoLock);

        // If the Irp completed successfully, process the  received 
        // information.
		if (NT_SUCCESS (IoctlStatus.Status)) 
		{	
			IoctlStatus.Status = ProcessAdapterConfigInfo (pvConfigBuffer);
		}

        // Re-send the IRP immediately so that the next time
        // an adapter change occurs, we'll be notified.
		if (NT_SUCCESS (IoctlStatus.Status)) 
		{
			PostAdapterConfigRequest (NULL);
		}

		else 
		{	
			PLIST_ENTRY cur;
            // Signal clients dialing in, so that they can get 
            // error information.  
            // 
			if ((IpxWanPort!=NULL) && IsListEmpty (&IpxWanPort->msgqueue)) 
			{
				BOOL res = SetEvent (IpxWanPort->event);
				ASSERTMSG ("Can't set client event ", res);
			}
            
            // Loop through all of the clients to this dll (i.e. rip, 
            // sap, router manager) 
			for (cur=PortListHead.Flink; cur!=&PortListHead; cur = cur->Flink) 
			{
				PCONFIG_PORT port = CONTAINING_RECORD (cur, CONFIG_PORT, link);
                // If the mes queue for client is empty at this point, then 
                // it means ProcessAdapterConfigInfo() didn't detect any work
                // items for the client in question.  We set the message 
                // here so that the client knows that something happened.
				if (IsListEmpty (&port->msgqueue)) 
				{
					BOOL res = SetEvent (port->event);
					ASSERTMSG ("Can't set client event ", res);
				}
			}
		}
		LeaveCriticalSection (&ConfigInfoLock);
        #if DBG && defined(WATCHER_DIALOG)
		InformWatcher ();	// Let watcher update its info as well
        #endif
	}
	else
	{
		TracePrintf(g_dwTraceId, "Warning - IpxDriverHandle is NULL, not processing");
    }

    // [pmay] 
    // We're done with the new nic info buffer now.
    //
    if (context)
    {
    	RtlFreeHeap (RtlProcessHeap(), 0, context);
    }    	

	InterlockedDecrement (&AdapterChangeApcPending);
}

/*++

	P o s t A d a p t e r C o n f i g R e q u e s t

Routine  Description:
	Posts IRP to the driver to get adapter change notifications
Arguments:
		Context - event to be used to signal completion of the IRP, NULL if APC
		is to be used for this purpose
Return Value:
	None
	
--*/
VOID 
APIENTRY
PostAdapterConfigRequest (
    IN PVOID context) 
{
    HANDLE WaitHandle = (HANDLE)context;
	PNWLINK_ACTION	action;
	PIPX_NICS		request;
    PVOID pvConfigBuffer = NULL;       
    DWORD dwBufSize = 0, dwActionSize = 0, dwNicBufSize = 0;

    TracePrintf(g_dwTraceId, "PostAdapterConfigRequest: Entered\n");

	EnterCriticalSection (&ConfigInfoLock);

    // Allocate request buffer, making sure that we have space for at
    // least one adapter.
    //
    dwNicBufSize = 
        FIELD_OFFSET (IPX_NICS, Data) + 
            (sizeof (IPX_NIC_INFO) * (NumAdapters>0 ? NumAdapters : 1));
    dwActionSize = 
        FIELD_OFFSET (NWLINK_ACTION, Data) + dwNicBufSize;
    dwBufSize = 
        sizeof(DWORD) + dwActionSize;

	pvConfigBuffer = 	    
	    RtlAllocateHeap (RtlProcessHeap (), 0, dwBufSize);

    if (pvConfigBuffer == NULL)
    {
        #if DBG
		DbgPrint (
		    "Could not alloc mem for global req buffer (gle:%08x).\n",
	 		 GetLastError ());
        #endif
		IoctlStatus.Status=STATUS_NO_MEMORY;
    	LeaveCriticalSection (&ConfigInfoLock);
    	return;
    }

    // Set up global buffer parameters
    //
    *((DWORD*)pvConfigBuffer) = g_dwBufferId++;

    // Set up the actions parameters
    //
	action = (PNWLINK_ACTION)((PUCHAR)pvConfigBuffer + sizeof(DWORD));
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option) + dwNicBufSize;
	action->Option = MIPX_GETNEWNICINFO;
	request = (PIPX_NICS)action->Data;
	request->NoOfNics = 0;
	request->TotalNoOfNics = 0;
	request->fAllNicsDesired = FALSE;

	IoctlStatus.Status = 
	    NtDeviceIoControlFile(
    		IpxDriverHandle,
    		WaitHandle,
    		(WaitHandle==NULL) ? AdapterChangeAPC : NULL,
            (WaitHandle==NULL) ? pvConfigBuffer : NULL, 
    		&IoctlStatus,
    		IOCTL_TDI_ACTION,
    		NULL,
    		0,
    		action,
    		dwActionSize);
	if (NT_SUCCESS (IoctlStatus.Status)) 
	{
		if (WaitHandle==NULL)
		{
			InterlockedIncrement (&AdapterChangeApcPending);
	    }
    }
	else 
	{
        #if DBG
		DbgPrint (
		    "Ioctl MIPX_GETNEWNICINFO failed with status %08x\n",
		    IoctlStatus.Status);
        #endif
    }

	LeaveCriticalSection (&ConfigInfoLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\wanarp2\kdext\wrp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    wrp.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    AmritanR
    
Environment:

    User Mode

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>
#include <wdbgexts.h>

#include <winsock.h>

#include <cxport.h>
#include <ndis.h>

#define __FILE_SIG__    KDEXT_SIG
#include "inc.h"

typedef struct _SYM_TAB_ENTRY
{
    PCHAR       pwszSymbol;
    ULONG_PTR   ulpAddress;
} SYM_TAB_ENTRY, *PSYM_TAB_ENTRY;

SYM_TAB_ENTRY g_rgSymbolTable [] = {
    { "wanarp!g_leIfList", (ULONG_PTR)0 },
    { "wanarp!g_leFreeAdapterList", (ULONG_PTR)0 },
    { "wanarp!g_ulNumFreeAdapters", (ULONG_PTR)0 },
    { "wanarp!g_leAddedAdapterList", (ULONG_PTR)0 },
    { "wanarp!g_ulNumAddedAdapters", (ULONG_PTR)0 },
    { "wanarp!g_leChangeAdapterList", (ULONG_PTR)0 },
    { "wanarp!g_ulNumAdapters", (ULONG_PTR)0 },
    { "wanarp!g_puipConnTable", (ULONG_PTR)0 },
    { "wanarp!g_ulConnTableSize", (ULONG_PTR)0 },
    { "wanarp!g_pServerInterface", (ULONG_PTR)0 },
    { "wanarp!g_pServerAdapter", (ULONG_PTR)0 },
    { "wanarp!g_dwDriverState", (ULONG_PTR)0 },
    { "wanarp!g_ulNumCreates", (ULONG_PTR)0 },
    { "wanarp!g_ulNumThreads", (ULONG_PTR)0 },
    { "wanarp!g_lePendingNotificationList", (ULONG_PTR)0 },
    { "wanarp!g_lePendingIrpList", (ULONG_PTR)0 },
};

//
// Symbols
//

#define IF_LIST             0
#define FREE_ADPT_LIST      1
#define NUM_FREE_ADPT       2
#define ADDED_ADPT_LIST     3
#define NUM_ADDED_ADPT      4
#define CHANGE_ADPT_LIST    5
#define NUM_ADPT            6
#define CONN_TABLE          7
#define CONN_TABLE_SIZE     8
#define SRVR_IF             9
#define SRVR_ADPT           10
#define DRIVER_STATE        11
#define NUM_CREATES         12
#define NUM_THREADS         13
#define NOTIFICATION_LIST   14
#define IRP_LIST            15



EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

BOOLEAN ChkTarget;
WINDBG_EXTENSION_APIS ExtensionApis;
BOOL g_bInit;
INT Item;
USHORT SavedMajorVersion;
USHORT SavedMinorVersion;


#define CHECK_SIZE(dwRead,dwReq,bRes)                               \
{                                                                   \
    if((dwRead) < (dwReq))                                          \
    {                                                               \
        dprintf("Requested %s (%d) read %d \n",#dwReq,dwReq,dwRead);\
        dprintf("Error in %s at %d\n",__FILE__,__LINE__);           \
        bRes = FALSE;                                               \
    }                                                               \
    else                                                            \
    {                                                               \
        bRes = TRUE;                                                \
    }                                                               \
} 

#define READ_MEMORY_ERROR(s, p)                                     \
    dprintf("Error %d bytes at %x\n",(s), (p))

#define GET_ADDRESS_ERROR(s)                                        \
    dprintf("Error getting the offset for %s\n",(s))

#define INET_NTOA(a) \
    inet_ntoa(*(struct in_addr*)&(a))

DllInit(
    HANDLE hModule,
    DWORD dwReason,
    DWORD dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH: {
            break;
        }

        case DLL_THREAD_DETACH: {
            break;
        }

        case DLL_PROCESS_DETACH: {

            g_bInit = FALSE;
            
            DisableThreadLibraryCalls(hModule);
            
            break;
        }

        case DLL_PROCESS_ATTACH: {
            break;
        }
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = ((SavedMajorVersion == 0x0c) ? TRUE : FALSE);
    
    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion);
}

VOID
CheckVersion(
    VOID
    )
{
    
#if DBG
    if((SavedMajorVersion isnot 0x0c) or
       (SavedMinorVersion isnot VER_PRODUCTBUILD)) 
    {
        dprintf("\n*** Extension DLL(%d Checked) does not match target system(%d %s)\n",
                VER_PRODUCTBUILD, 
                SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked");
    }

#else

    if((SavedMajorVersion isnot 0x0f) or 
       (SavedMinorVersion isnot VER_PRODUCTBUILD)) 
    {
        dprintf("\n*** Extension DLL(%d Free) does not match target (%d %s)\n",
                VER_PRODUCTBUILD, 
                SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked");
    }

#endif

}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Exported functions
//

DECLARE_API( help )

/*++

Routine Description:

    Command help for debugger extension.

Arguments:

    None

Return Value:

    None
    
--*/

{
    dprintf("\n\tWanArp debugger extension commands:\n\n");

    dprintf(
        "\tifpool <if>      - Show the address-pool of the interface at <if>\n"
        );

    dprintf("\n\tCompiled on " __DATE__ " at " __TIME__ "\n");

    return;
}


BOOL
InitDebugger(
    VOID
    )
{

    int i;
    
    if(g_bInit) 
    { 
        return TRUE; 
    }
    
    for(i = 0; 
        i < sizeof(g_rgSymbolTable)/sizeof(SYM_TAB_ENTRY);
        i++)
    {

        g_rgSymbolTable[i].ulpAddress = 
            GetExpression(g_rgSymbolTable[i].pwszSymbol);

        if(g_rgSymbolTable[i].ulpAddress == 0)
        {
            GET_ADDRESS_ERROR(g_rgSymbolTable[i].pwszSymbol);

            return FALSE;
        }
    }

    g_bInit = TRUE;

    return TRUE;
}

DECLARE_API( init )
{
    InitDebugger();
}

DECLARE_API( numif )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\ipxdefs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ipxintf\ipxintf.c

Abstract:

	Interface routines that simulate asynchronous network interface
	(to be implemented later) through WinSock IPX protocol stack
	External interfaces

Author:

	Vadim Eydelman

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <stdio.h>
#include <tchar.h>

#include "utils.h"
#include "rtutils.h"
#include "ipxrtprt.h"
#include "rtm.h"
#include "adapter.h"
#include "ipxconst.h"
#include "ipxrtdef.h"
#include <ipxfltdf.h>	// [pmay] Defines ioctls sent to the filter driver.
#include "NicTable.h"   // [pmay] Defines mechanism for mapping virtual adps to phys ones.

#include "packon.h"
typedef USHORT IPX_SOCKET_NUM, *PIPX_SOCKET_NUM;
typedef UCHAR IPX_NET_NUM[4], *PIPX_NET_NUM;
typedef UCHAR IPX_NODE_NUM[6], *PIPX_NODE_NUM;

typedef struct _IPX_ADDRESS_BLOCK {
	IPX_NET_NUM		net;
	IPX_NODE_NUM	node;
	IPX_SOCKET_NUM	socket;
	} IPX_ADDRESS_BLOCK, *PIPX_ADDRESS_BLOCK;

	// Header of IPX packet
typedef struct _IPX_HEADER {
		USHORT				checksum;
		USHORT				length;
		UCHAR				transportctl;
		UCHAR				pkttype;
		IPX_ADDRESS_BLOCK	dst;
		IPX_ADDRESS_BLOCK	src;
		} IPX_HEADER, *PIPX_HEADER;

#include "packoff.h"

// IPX Net Number copy macro
#define IPX_NETNUM_CPY(dst,src) *((UNALIGNED ULONG *)(dst)) = *((UNALIGNED ULONG *)(src))
// IPX Net Number comparison
#define IPX_NETNUM_CMP(net1,net2) memcmp(net1,net2,sizeof(IPX_NET_NUM))


// IPX Node Number copy macro
#define IPX_NODENUM_CPY(dst,src) memcpy(dst,src,sizeof(IPX_NODE_NUM))
// IPX Node Number comparison
#define IPX_NODENUM_CMP(node1,node2) memcmp(node1,node2,sizeof(IPX_NODE_NUM))
// IPX set boradcast node number
#define IPX_SET_BCAST_NODE(node) memset (node,0xFF,sizeof (IPX_NODE_NUM))

#define IsListEntry(link) (!IsListEmpty(link))
#define InitializeListEntry(link) InitializeListHead(link)

	// Size of buffer used to pass additional endpoing info in NtCreateFile call
	// to the driver
#define IPX_ENDPOINT_SPEC_BUFFER_SIZE (\
		sizeof (FILE_FULL_EA_INFORMATION)-1	\
			+ ROUTER_INTERFACE_LENGTH+1		\
			+ sizeof (TRANSPORT_ADDRESS)-1	\
			+ sizeof (TDI_ADDRESS_IPX))

	// Adapter configuration change message
typedef struct _ADAPTER_MSG {
		LIST_ENTRY				link;	// Link in message queue
		IPX_NIC_INFO			info;	// Info supplied by stack
		} ADAPTER_MSG, *PADAPTER_MSG;

	// Client's configuration port context
typedef struct _CONFIG_PORT {
		LIST_ENTRY				link;		// Link in port list
		HANDLE					event;		// Client's notification event
		LIST_ENTRY				msgqueue;	// unread message queue
		} CONFIG_PORT, *PCONFIG_PORT;

#include "ipxfwd.h"
#include "fwif.h"
#include "pingsvc.h"

#define DBG_FLT_LOG_ERRORS	0x00010000

#if DBG && defined(WATCHER_DIALOG)
		// Stuff for UI dialog that simmulates adapter status changes
#include <commctrl.h>
#include "Icons.h"
#include "Dialog.h"
#endif	//DBG && defined(WATCHER_DIALOG)

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\icons.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Icons.rc
//
#define ID_ICON_UP                      10
#define ID_ICON_DOWN                    11

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\ipxfwd.c ===
#include "ipxdefs.h"

HANDLE		FwdDriverHandle=NULL;
HANDLE		FltDriverHandle=NULL;
DWORD		FltTraceId;
extern DWORD g_dwTraceId;

#define FLT_LOG_BUFFER_SIZE	16384
#define NUM_FILTER_LOG_ENTRIES	2

typedef struct _FLT_LOG_ENTRY {
	OVERLAPPED		ovlp;
	UCHAR			buffer[FLT_LOG_BUFFER_SIZE];
} FLT_LOG_ENTRY, *PFLT_LOG_ENTRY;

FLT_LOG_ENTRY FltLogEntry [NUM_FILTER_LOG_ENTRIES];


VOID WINAPI
DumpFilterLog (
	DWORD error,
	DWORD cbCount,
	LPOVERLAPPED ovlp
	) {
	BOOL			res;
	PFLT_LOG_ENTRY	pEntry = CONTAINING_RECORD (ovlp, FLT_LOG_ENTRY, ovlp);

	if (error==NO_ERROR) {
		PFLT_PACKET_LOG	pLog = (PFLT_PACKET_LOG)pEntry->buffer;
		TracePuts (FltTraceId, TEXT (""));
		TracePrintfEx (FltTraceId,
					DBG_FLT_LOG_ERRORS|TRACE_USE_MASK|TRACE_NO_STDINFO, 
					TEXT ("%d bytes returned in IRP buffer.\n"), cbCount);
		while (((PUCHAR)pLog->Header<=&pEntry->buffer[cbCount])
				&& (&pLog->Header[pLog->DataSize]<=&pEntry->buffer[cbCount])) {
			TracePrintfEx (FltTraceId, TRACE_NO_STDINFO,
							TEXT ("Packet # %d,"), pLog->SeqNum);
			if (pLog->SrcIfIdx!=-1)
				TracePrintfEx (FltTraceId, TRACE_NO_STDINFO,
						TEXT (" received on interface: %d,"), pLog->SrcIfIdx);
			else
				TracePrintfEx (FltTraceId, TRACE_NO_STDINFO,
						TEXT (" no source interface context,"));
			if (pLog->DstIfIdx!=-1)
				TracePrintfEx (FltTraceId, TRACE_NO_STDINFO,
						TEXT (" sent on interface: %d."), pLog->DstIfIdx);
			else
				TracePrintfEx (FltTraceId, TRACE_NO_STDINFO,
						TEXT (" no destination interface context."));
			TraceDumpEx (FltTraceId, TRACE_NO_STDINFO ,
							pLog->Header, pLog->DataSize, 1,
							FALSE, NULL);
			TracePrintfEx (FltTraceId, TRACE_NO_STDINFO, TEXT("\n"));
			pLog = (PFLT_PACKET_LOG)((ULONG_PTR)(&pLog->Header[pLog->DataSize]+3)&(~(ULONG_PTR)3));
		}
	}
	else {
		TracePrintfEx (FltTraceId, DBG_FLT_LOG_ERRORS|TRACE_USE_MASK,
			TEXT ("IOCTL_FLT_GET_LOGGED_PACKETS completed with error %d\n"),
			error);
	}
	
	if (FltDriverHandle!=NULL) {
		res = DeviceIoControl(
					FltDriverHandle,
					IOCTL_FLT_GET_LOGGED_PACKETS,
					NULL,
					0,
					pEntry->buffer,
					sizeof (pEntry->buffer),
					NULL,
					&pEntry->ovlp);
		if (!res&&(GetLastError ()!=ERROR_IO_PENDING))
			TracePrintfEx (FltTraceId, DBG_FLT_LOG_ERRORS|TRACE_USE_MASK,
				TEXT ("DeviceIoControl failed with error %d"),
											GetLastError ());
	}
}


DWORD
FwStart (
	ULONG	RouteHashTableSize,
	BOOL	ThisMachineOnly 	// allow access to this machine only
								// for dialin clients
	) {
	SC_HANDLE	ScMgrHandle;
	SC_HANDLE	FwdServiceHandle, FltServiceHandle;
	DWORD		error = NO_ERROR;
	BOOL bOk;

	ASSERT (FwdDriverHandle==NULL);

	ScMgrHandle = OpenSCManager (NULL, NULL, 0);
	if (ScMgrHandle!=NULL) {

		FwdServiceHandle = OpenService (ScMgrHandle,
										TEXT ("NwLnkFwd"), 
										SERVICE_START|SERVICE_STOP);
		if (FwdServiceHandle!=NULL) {
			if (StartService (FwdServiceHandle, 0, NULL)
					|| (GetLastError ()==ERROR_SERVICE_ALREADY_RUNNING)) {
				UNICODE_STRING		FileString;
				OBJECT_ATTRIBUTES	ObjectAttributes;
				IO_STATUS_BLOCK		IoStatus;
				NTSTATUS			status;

				RtlInitUnicodeString (&FileString, IPXFWD_NAME);
				InitializeObjectAttributes(
						&ObjectAttributes,
						&FileString,
						OBJ_CASE_INSENSITIVE,
						NULL,
						NULL);


				status = NtOpenFile(
							 &FwdDriverHandle,
							 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
							 &ObjectAttributes,
							 &IoStatus,
							 FILE_SHARE_READ | FILE_SHARE_WRITE,
							 0);
				if (NT_SUCCESS (status)) {
					FWD_START_PARAMS		params;
					params.RouteHashTableSize = RouteHashTableSize;
					params.ThisMachineOnly = (UCHAR)ThisMachineOnly;
					status = NtDeviceIoControlFile(
										FwdDriverHandle,
										NULL,
										NULL,
										NULL,
										&IoStatus,
										IOCTL_FWD_START,
										&params,
										sizeof(params),
										NULL,
										0);
					if (status==STATUS_PENDING){
						status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
						if (NT_SUCCESS (status))
							status = IoStatus.Status;
					}
					if (NT_SUCCESS(status)) {
						FltServiceHandle = OpenService (ScMgrHandle,
														TEXT ("NwLnkFlt"), 
														SERVICE_START|SERVICE_STOP);
						if (FltServiceHandle!=NULL) {
							if (StartService (FltServiceHandle, 0, NULL)
									|| (GetLastError ()==ERROR_SERVICE_ALREADY_RUNNING)) {
								UNICODE_STRING		FileString;
								OBJECT_ATTRIBUTES	ObjectAttributes;
								IO_STATUS_BLOCK		IoStatus;
								NTSTATUS			status;

								RtlInitUnicodeString (&FileString, IPXFLT_NAME);
								InitializeObjectAttributes(
										&ObjectAttributes,
										&FileString,
										OBJ_CASE_INSENSITIVE,
										NULL,
										NULL);


								status = NtOpenFile(
											 &FltDriverHandle,
											 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
											 &ObjectAttributes,
											 &IoStatus,
											 FILE_SHARE_READ | FILE_SHARE_WRITE,
											 0);
								if (NT_SUCCESS (status)) {
									status = NtDeviceIoControlFile(
														FltDriverHandle,
														NULL,
														NULL,
														NULL,
														&IoStatus,
														IOCTL_FLT_START,
														NULL,
														0,
														NULL,
														0);
									if (status==STATUS_PENDING){
										status = NtWaitForSingleObject (FltDriverHandle, FALSE, NULL);
										if (NT_SUCCESS (status))
											status = IoStatus.Status;
									}
									if (NT_SUCCESS (status)) {
										INT		i;
										FltTraceId = TraceRegister (
												TEXT ("IPX Traffic Filter Logging"));

										error = NO_ERROR;
										bOk = BindIoCompletionCallback (
												FltDriverHandle,
												DumpFilterLog,
												0);
                                        if (!bOk)
                                        {
                                            error = GetLastError();
                                        }
										ASSERTMSG ("Can't set io completion proc", error==NO_ERROR);
										for (i=0; i<NUM_FILTER_LOG_ENTRIES; i++) {
											BOOL res;
											FltLogEntry[i].ovlp.hEvent = NULL;
											res = DeviceIoControl(
														FltDriverHandle,
														IOCTL_FLT_GET_LOGGED_PACKETS,
														NULL,
														0,
														FltLogEntry[i].buffer,
														sizeof (FltLogEntry[i].buffer),
														NULL,
														&FltLogEntry[i].ovlp);
											if (!res&&(GetLastError ()!=ERROR_IO_PENDING))
												TracePrintfEx (FltTraceId,
													DBG_FLT_LOG_ERRORS|TRACE_USE_MASK,
													TEXT ("DeviceIoControl failed with error %d"),
													GetLastError ());
										}
										SetLastError (NO_ERROR);
									}
									else {
										NtClose (FltDriverHandle);
										FltDriverHandle = NULL;
										error = RtlNtStatusToDosError (status);
									}
								}
								else
									error = RtlNtStatusToDosError (status);
								if (!NT_SUCCESS (status)) {
									SERVICE_STATUS	serviceStatus;
									ControlService (FltServiceHandle,
													SERVICE_CONTROL_STOP,
													&serviceStatus);
								}
							}
							else
								error = GetLastError ();
							CloseServiceHandle (FltServiceHandle);
						}
						else
							error = GetLastError ();
					}
					else
						error = RtlNtStatusToDosError (status);
					if (!NT_SUCCESS (status)) {
						NtClose (FwdDriverHandle);
						FwdDriverHandle = NULL;
					}
				}
				else
					error = RtlNtStatusToDosError (status);

				if (!NT_SUCCESS (status)) {
					SERVICE_STATUS	serviceStatus;
					ControlService (FwdServiceHandle,
									SERVICE_CONTROL_STOP,
									&serviceStatus);
				}
			}
			else
				error = GetLastError ();
			CloseServiceHandle (FwdServiceHandle);
		}
		else
			error = GetLastError ();
		CloseServiceHandle (ScMgrHandle);
	}
	else
		error = GetLastError ();
	SetLastError (error);
	return error;
}

// 
//  Function:   FwIsStarted
//
//  Reports whether the forwarder has been started/is running.
//
//
DWORD FwIsStarted (OUT PBOOL pbIsStarted) {
	SC_HANDLE hScMgr = NULL, hFwdService = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD dwErr = NO_ERROR;

    // Sanity check
    if (!pbIsStarted)
        return ERROR_INVALID_PARAMETER;

    // Get a reference to the service controller
	hScMgr = OpenSCManager (NULL, NULL, 0);
	if (hScMgr == NULL)
	    return GetLastError();

    __try {
    	// Get a handle to the service
    	hFwdService = OpenService (hScMgr, TEXT ("NwLnkFwd"), SERVICE_QUERY_STATUS);
    	if (hFwdService == NULL)
    	    return GetLastError();

    	// Query the service ServiceStatus
    	if (! QueryServiceStatus(hFwdService, &ServiceStatus))
    	    return GetLastError();

    	// Return accordingly
    	if (ServiceStatus.dwCurrentState == SERVICE_RUNNING            ||
            ServiceStatus.dwCurrentState == SERVICE_START_PENDING      ||
            ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING   ||
            ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING      ||
            ServiceStatus.dwCurrentState == SERVICE_PAUSED)
          *pbIsStarted = TRUE;
        else
          *pbIsStarted = FALSE;
    }
    __finally {
        if (hScMgr)
            CloseServiceHandle(hScMgr);
        if (hFwdService)
            CloseServiceHandle(hFwdService);
    }

    return NO_ERROR;
}

//
// Returns whether the given state is a pending state
//
BOOL 
FwIsPendingState (
    IN DWORD dwState) 
{
    return (BOOL) ((dwState == SERVICE_START_PENDING)    ||
                   (dwState == SERVICE_STOP_PENDING)     ||
                   (dwState == SERVICE_CONTINUE_PENDING) ||
                   (dwState == SERVICE_PAUSE_PENDING)    
                   ); 
}

// Stops the service referred by the opened hService
// handle.  It's assumed that the handle is opened for
// stopping the service and querying its status.
//
DWORD
FwStopService(
    IN HANDLE hService, 
    IN DWORD dwSecsTimeout) 
{
	SERVICE_STATUS SStatus;
	DWORD dwState, dwErr, dwOrigTimeout = dwSecsTimeout;
	BOOL bOk;

    // Get the current status of the service
    if (! QueryServiceStatus(hService, &SStatus))
    {
        dwErr = GetLastError();
    	TracePrintfEx (
    	    g_dwTraceId,
	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("QueryServiceStatus returned %d"),
    		dwErr);
        return dwErr;    		
    }

    // If it's already stopped, we're done
    if (SStatus.dwCurrentState == SERVICE_STOPPED)
        return NO_ERROR;
    dwState = SStatus.dwCurrentState;

	// Tell the service to stop
	bOk = ControlService (
    	    hService,
    		SERVICE_CONTROL_STOP,
    		&SStatus);
    if (! bOk)
    {
        dwErr = GetLastError();
        TracePrintfEx (
    	    g_dwTraceId,
	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("ControlService(Stop) returned %d"),
    		dwErr);
        return dwErr;    		
    }

    // Wait for the service to change states or for the timeout to
    // expire.
    dwSecsTimeout *= 4;
    while (dwSecsTimeout != 0) {
        // Get the status of the service
        bOk = QueryServiceStatus (
                hService, 
                &SStatus);
        if (! bOk) 
        {
            dwErr = GetLastError();
        	TracePrintfEx (
        	    g_dwTraceId,
    	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
        		TEXT ("QueryServiceStatus (2) returned %d"),
        		dwErr);
            return dwErr;    		
        }

        // See if the state changed
        if (dwState != SStatus.dwCurrentState) 
        {
            TracePrintfEx (
        	    g_dwTraceId,
    	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
        		TEXT ("Service status changed from %d to %d"),
        		dwState, 
        		SStatus.dwCurrentState);
        		
            // If the service changed to a pending state, continue
            if (FwIsPendingState (SStatus.dwCurrentState))
            {
                dwState = SStatus.dwCurrentState;
                TracePrintfEx (
            	    g_dwTraceId,
        	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
            		TEXT ("Pending state detected -- continuing to wait."));

            }

            // Otherwise, we're either stopped or running
            else
            {
                TracePrintfEx (
            	    g_dwTraceId,
        	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
            		TEXT ("Non-Pending state detected -- waiting complete."));
                break;
            }
        }
        else
        {
            TracePrintfEx (
        	    g_dwTraceId,
    	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
        		TEXT ("Service state hasn't changed from %d. Waiting..."),
        		dwState);
        }

        // Wait for something to happen
        Sleep(250);
        dwSecsTimeout--;
    }

    // Return a timeout error if appropriate
    if (dwSecsTimeout == 0)
    {
        TracePrintfEx (
    	    g_dwTraceId,
        	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("Timeout of %d seconds expired waiting for service to stop."),
    		dwOrigTimeout);
    		
        return ERROR_TIMEOUT;
    }        

    // If the service is now stopped, then everything
    // worked great.
    if (SStatus.dwCurrentState == SERVICE_STOPPED)
    {
        TracePrintfEx (
    	    g_dwTraceId,
        	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("Service stoppped successfully."));
    		
        return NO_ERROR;
    }        

    // Otherwise, return the fact that we were'nt able to 
    // get to a running state
    if (SStatus.dwWin32ExitCode != NO_ERROR)
    {
        TracePrintfEx (
    	    g_dwTraceId,
        	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("Service stop failed with code %d."),
    		SStatus.dwWin32ExitCode);
    		
        return SStatus.dwWin32ExitCode;
    }

    TracePrintfEx (
	    g_dwTraceId,
    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
		TEXT ("Service stop failed, no error reported."));
		
    return ERROR_CAN_NOT_COMPLETE;
}

DWORD
FwStop (
	void
	) {
	SC_HANDLE			ScMgrHandle;
	SC_HANDLE			FwdServiceHandle, FltServiceHandle;
	NTSTATUS			status;
	DWORD               dwErr;

	ASSERT (FwdDriverHandle!=NULL);
	ASSERT (FltDriverHandle!=NULL);

    // Close references to the filter and forwarder 
    // drivers
	status = NtClose (FltDriverHandle);
	FltDriverHandle = NULL;
	status = NtClose (FwdDriverHandle);
	FwdDriverHandle = NULL;

    // Open the service controller
	ScMgrHandle = OpenSCManager (NULL, NULL, 0);
	if (ScMgrHandle!=NULL) 
	{
    	TracePrintfEx (
    	    g_dwTraceId,
	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("Stopping the filter driver..."));

		// Open the service handle to the 
		// filter service
		//
		FltServiceHandle = OpenService (
		                        ScMgrHandle,
								"NwLnkFlt", 
								SERVICE_STOP | SERVICE_QUERY_STATUS);

        // Stop the filter service								
		if (FltServiceHandle != NULL) 
		{
            dwErr = FwStopService(FltServiceHandle, 10);
		    if (dwErr != NO_ERROR)
		    {
            	TracePrintfEx (
            	    g_dwTraceId,
        	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
            		TEXT ("FwStopService returned %d"),
            		dwErr);
		    }
			CloseServiceHandle (FltServiceHandle);
		}
		else 
		{
        	TracePrintfEx (
        	    g_dwTraceId,
    	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
        		TEXT ("Unable to open the filter driver service handle %d"),
        		GetLastError());
		}

        // Open the service handle to the
        // fowarder driver
        //
    	TracePrintfEx (
    	    g_dwTraceId,
	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
    		TEXT ("Stopping the forwarder driver..."));
    		
		FwdServiceHandle = OpenService (
		                        ScMgrHandle,
								"NwLnkFwd", 
								SERVICE_STOP | SERVICE_QUERY_STATUS);

        // Stop the forwarder driver
        //
		if (FwdServiceHandle != NULL) 
		{
		    dwErr = FwStopService(FwdServiceHandle, 10);
		    if (dwErr != NO_ERROR)
		    {
            	TracePrintfEx (
            	    g_dwTraceId,
        	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
            		TEXT ("FwStopService returned %d"),
            		dwErr);
		    }
			CloseServiceHandle (FwdServiceHandle);
		}
		else 
		{
        	TracePrintfEx (
        	    g_dwTraceId,
    	    	DBG_FLT_LOG_ERRORS | TRACE_USE_MASK,
        		TEXT ("Unable to open the forwarder driver service handle %d"),
        		GetLastError());
		}
    
	    CloseServiceHandle (ScMgrHandle);
	}
	
	TraceDeregister (FltTraceId);
	
	return NO_ERROR;
}

// Added for pnp resetting of forwarder's ThisMachineOnly
// setting.
DWORD 
FwUpdateConfig(BOOL ThisMachineOnly) {
    FWD_UPDATE_CONFIG_PARAMS Params;
	IO_STATUS_BLOCK	IoStatus;
	NTSTATUS status;

    Params.bThisMachineOnly = (BOOLEAN)(!!ThisMachineOnly);

    // Send the ioctl
	status = NtDeviceIoControlFile(FwdDriverHandle,
            					   NULL,
			            		   NULL,
						           NULL,
            					   &IoStatus,
            					   IOCTL_FWD_UPDATE_CONFIG,
            					   &Params,
            					   sizeof (Params),
            					   NULL,
            					   0);

    // Wait for completion 
	if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
    }

	return RtlNtStatusToDosError (status);
}

VOID
FwCleanup (
	void
	) {
	if (FwdDriverHandle!=NULL)
		FwStop ();
}
DWORD
FwCreateInterface (
	IN ULONG				InterfaceIndex,
	IN NET_INTERFACE_TYPE	InterfaceType,
	IN PFW_IF_INFO			FwIfInfo
	) {
	IO_STATUS_BLOCK			IoStatus;
	NTSTATUS				status;
	FWD_IF_CREATE_PARAMS	params;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		params.Index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		params.Index = InterfaceIndex;
		break;
	}

	switch (InterfaceType) {
	case PERMANENT:
		params.InterfaceType = FWD_IF_PERMANENT;
		break;
	case DEMAND_DIAL:
		params.InterfaceType = FWD_IF_DEMAND_DIAL;
		break;
	case LOCAL_WORKSTATION_DIAL:
		params.InterfaceType = FWD_IF_LOCAL_WORKSTATION;
		break;
	case REMOTE_WORKSTATION_DIAL:
		params.InterfaceType = FWD_IF_REMOTE_WORKSTATION;
		break;
	default:
		ASSERTMSG ("Invalid interface type ", FALSE);
	}

	switch (FwIfInfo->NetbiosAccept) {
	case ADMIN_STATE_ENABLED:
		params.NetbiosAccept = TRUE;
		break;
	case ADMIN_STATE_DISABLED:
		params.NetbiosAccept = FALSE;
		break;
	default:
		ASSERTMSG ("Invalid netbios state ", FALSE);
	}

	switch (FwIfInfo->NetbiosDeliver) {
	case ADMIN_STATE_ENABLED:
		params.NetbiosDeliver = FWD_NB_DELIVER_ALL;
		break;
	case ADMIN_STATE_DISABLED:
		params.NetbiosDeliver = FWD_NB_DONT_DELIVER;
		break;
	case ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING:
		params.NetbiosDeliver = FWD_NB_DELIVER_STATIC;
		break;
	case ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP:
		params.NetbiosDeliver = FWD_NB_DELIVER_IF_UP;
		break;
	default:
		ASSERTMSG ("Invalid netbios state ", FALSE);
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_CREATE_INTERFACE,
						&params,
						sizeof (params),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}
	
DWORD
FwDeleteInterface (
	IN ULONG				InterfaceIndex
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	ULONG				index;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_DELETE_INTERFACE,
						&index,
						sizeof (index),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwSetInterface (
	IN ULONG 				InterfaceIndex,
	IN PFW_IF_INFO			FwIfInfo
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	FWD_IF_SET_PARAMS	params;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		params.Index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		params.Index = InterfaceIndex;
		break;
	}

	switch (FwIfInfo->NetbiosAccept) {
	case ADMIN_STATE_ENABLED:
		params.NetbiosAccept = TRUE;
		break;
	case ADMIN_STATE_DISABLED:
		params.NetbiosAccept = FALSE;
		break;
	default:
		ASSERTMSG ("Invalid netbios state ", FALSE);
	}

	switch (FwIfInfo->NetbiosDeliver) {
	case ADMIN_STATE_ENABLED:
		params.NetbiosDeliver = FWD_NB_DELIVER_ALL;
		break;
	case ADMIN_STATE_DISABLED:
		params.NetbiosDeliver = FWD_NB_DONT_DELIVER;
		break;
	case ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING:
		params.NetbiosDeliver = FWD_NB_DELIVER_STATIC;
		break;
	case ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP:
		params.NetbiosDeliver = FWD_NB_DELIVER_IF_UP;
		break;
	default:
		ASSERTMSG ("Invalid netbios state ", FALSE);
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_SET_INTERFACE,
						&params,
						sizeof (params),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwGetInterface (
	IN  ULONG				InterfaceIndex,
	OUT PFW_IF_INFO			FwIfInfo,
	OUT PFW_IF_STATS		FwIfStats
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	union {
		FWD_IF_GET_PARAMS	params;
		ULONG				index;
	} iob;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		iob.index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		iob.index = InterfaceIndex;
		break;
	}

	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_GET_INTERFACE,
						&iob,
						sizeof (iob.index),
						&iob,
						sizeof (iob.params));

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}
	if (NT_SUCCESS(status)) {
		if (iob.params.NetbiosAccept)
			FwIfInfo->NetbiosAccept = ADMIN_STATE_ENABLED;
		else
			FwIfInfo->NetbiosAccept = ADMIN_STATE_DISABLED;

		switch (iob.params.NetbiosDeliver) {
		case FWD_NB_DONT_DELIVER:
			FwIfInfo->NetbiosDeliver = ADMIN_STATE_DISABLED;
			break;
		case FWD_NB_DELIVER_STATIC:
			FwIfInfo->NetbiosDeliver = ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING;
			break;
		case FWD_NB_DELIVER_IF_UP:
			FwIfInfo->NetbiosDeliver = ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP;
			break;
		case FWD_NB_DELIVER_ALL:
			FwIfInfo->NetbiosDeliver = ADMIN_STATE_ENABLED;
			break;
		default:
			ASSERTMSG ("Invalid NetbiosDeliver state ", FALSE);
		}


		switch (iob.params.Stats.OperationalState) {
		case FWD_OPER_STATE_UP:
			FwIfStats->IfOperState = OPER_STATE_UP;
			break;
		case FWD_OPER_STATE_DOWN:
			FwIfStats->IfOperState = OPER_STATE_DOWN;
			break;
		case FWD_OPER_STATE_SLEEPING:
			FwIfStats->IfOperState = OPER_STATE_SLEEPING;
			break;
		default:
			ASSERTMSG ("Invalid interface state ", FALSE);
		}


		FwIfStats->MaxPacketSize = iob.params.Stats.MaxPacketSize;	
		FwIfStats->InHdrErrors = iob.params.Stats.InHdrErrors;	
		FwIfStats->InFiltered = iob.params.Stats.InFiltered;		
		FwIfStats->InNoRoutes = iob.params.Stats.InNoRoutes;		
		FwIfStats->InDiscards = iob.params.Stats.InDiscards;		
		FwIfStats->InDelivers = iob.params.Stats.InDelivers;		
		FwIfStats->OutFiltered = iob.params.Stats.OutFiltered;	
		FwIfStats->OutDiscards = iob.params.Stats.OutDiscards;	
		FwIfStats->OutDelivers = iob.params.Stats.OutDelivers;	
		FwIfStats->NetbiosReceived = iob.params.Stats.NetbiosReceived;
		FwIfStats->NetbiosSent = iob.params.Stats.NetbiosSent;	
		return NO_ERROR;
	}
	return RtlNtStatusToDosError (status);
}

DWORD
FwBindFwInterfaceToAdapter (
	IN ULONG						InterfaceIndex,
	IN PIPX_ADAPTER_BINDING_INFO	AdptBindingInfo
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	FWD_IF_BIND_PARAMS	params;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		params.Index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		params.Index = InterfaceIndex;
		break;
	}

	params.Info.AdapterIndex = (ULONG)NicMapGetPhysicalNicId((USHORT)AdptBindingInfo->AdapterIndex);
	GETLONG2ULONG (&params.Info.Network, AdptBindingInfo->Network);
	IPX_NODENUM_CPY (&params.Info.LocalNode, AdptBindingInfo->LocalNode);
	IPX_NODENUM_CPY (params.Info.RemoteNode, AdptBindingInfo->RemoteNode);
	params.Info.MaxPacketSize = AdptBindingInfo->MaxPacketSize;
	params.Info.LinkSpeed = AdptBindingInfo->LinkSpeed;

	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_BIND_INTERFACE,
						&params,
						sizeof (params),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

//
//  Function    FwRenumberNics
//
//  Instructs the forwarder to increment or decrement all nicids above
//  the given threshold.  This allows the forwarder to keep in sync with
//  nic-id compaction that occurs in the stack.
//
DWORD 
FwRenumberNics (DWORD dwOpCode,
                USHORT usThreshold)
{
	IO_STATUS_BLOCK	IoStatus;
	NTSTATUS status;
    FWD_RENUMBER_NICS_DATA FwRenumData;

    if (NULL == FwdDriverHandle) 
    {
        return NO_ERROR;
    }
    
    // Assign the opcode
    if (dwOpCode == NIC_OPCODE_INCREMENT_NICIDS)
        FwRenumData.ulOpCode = FWD_NIC_OPCODE_INCREMENT;
    else if (dwOpCode == NIC_OPCODE_DECREMENT_NICIDS)
        FwRenumData.ulOpCode = FWD_NIC_OPCODE_DECREMENT;
    else
        return ERROR_INVALID_PARAMETER;

    // Assign the threshold
    FwRenumData.usThreshold = usThreshold;

    // Send the ioctl
	status = NtDeviceIoControlFile(FwdDriverHandle,
            					   NULL,
			            		   NULL,
						           NULL,
            					   &IoStatus,
            					   IOCTL_FWD_RENUMBER_NICS,
            					   &FwRenumData,
            					   sizeof (FwRenumData),
            					   NULL,
            					   0);

    // Wait for completion (we might take this out)
	//if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
    //}

	return RtlNtStatusToDosError (status);
}


DWORD
FwUnbindFwInterfaceFromAdapter (
	IN ULONG						InterfaceIndex
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	ULONG				index;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_UNBIND_INTERFACE,
						&index,
						sizeof (index),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwDisableFwInterface (
	IN ULONG			InterfaceIndex
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	ULONG				index;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_DISABLE_INTERFACE,
						&index,
						sizeof (index),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwEnableFwInterface (
	IN ULONG			InterfaceIndex
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	ULONG				index;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_ENABLE_INTERFACE,
						&index,
						sizeof (index),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwConnectionRequestFailed (
	IN ULONG	InterfaceIndex
	) {
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			status;
	ULONG				index;

	ASSERT (FwdDriverHandle!=NULL);
	
	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}


	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_DIAL_REQUEST_FAILED,
						&index,
						sizeof (index),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	return RtlNtStatusToDosError (status);
}

DWORD
FwNotifyConnectionRequest (
	OUT PFW_DIAL_REQUEST	Request, // Buffer to be filled with interface index
                                     //that requires connection plus packet
                                     // that forced it
	IN ULONG			    RequestSize, // Size of the buffer (must at least
                                        // be sizeof (FW_DIAL_REQUEST)
	IN LPOVERLAPPED		    lpOverlapped	// structure for asyncrhronous
							// operation, hEvent must be set
	) {
	NTSTATUS			status;

	ASSERT (FwdDriverHandle!=NULL);
	ASSERT (lpOverlapped->hEvent!=NULL);
    ASSERT (FIELD_OFFSET (FW_DIAL_REQUEST, IfIndex)==FIELD_OFFSET (FWD_DIAL_REQUEST, IfIndex));
    ASSERT (FIELD_OFFSET (FW_DIAL_REQUEST, Packet)==FIELD_OFFSET (FWD_DIAL_REQUEST, Packet));

    if (RequestSize<sizeof (FWD_DIAL_REQUEST))
        return ERROR_INVALID_PARAMETER;

    
	status = NtDeviceIoControlFile (
						FwdDriverHandle,
						lpOverlapped->hEvent,
						NULL,
						NULL,
						(PIO_STATUS_BLOCK)lpOverlapped,
						IOCTL_FWD_GET_DIAL_REQUEST,
						NULL,
						0,
						Request,
						RequestSize);
	if (status==STATUS_PENDING)
		return NO_ERROR;
	else
		return RtlNtStatusToDosError (status);
}
// Returns result of notification request. Should be called when 
// the event set in the lpOverlapped structure is signalled.
//
DWORD
FwGetNotificationResult (
	IN LPOVERLAPPED		lpOverlapped,
	OUT PULONG			nBytes		// Number of bytes placed into
                                    // the request buffer
	) {
	if (NT_SUCCESS(((PIO_STATUS_BLOCK)lpOverlapped)->Status)) {
		*nBytes = (ULONG)((PIO_STATUS_BLOCK)lpOverlapped)->Information;
		return NO_ERROR;
	}
	else
		return RtlNtStatusToDosError (
				((PIO_STATUS_BLOCK)lpOverlapped)->Status);
}

VOID
FwUpdateRouteTable (
	DWORD	ChangeFlags,
	PVOID	CurRoute,
	PVOID	PrevRoute
	) {
#define IPXCurRoute ((PRTM_IPX_ROUTE)CurRoute)
#define IPXPrevRoute ((PRTM_IPX_ROUTE)PrevRoute)
	IO_STATUS_BLOCK		    IoStatus;
	NTSTATUS			    status;
    FWD_ROUTE_SET_PARAMS    params;

    switch (ChangeFlags) {
    case RTM_ROUTE_ADDED:
        params.Action = FWD_ADD_ROUTE;
        params.Network = IPXCurRoute->RR_Network.N_NetNumber;
        IPX_NODENUM_CPY (params.NextHopAddress, IPXCurRoute->RR_NextHopAddress.NHA_Mac);
        params.TickCount = IPXCurRoute->RR_FamilySpecificData.FSD_TickCount;
        params.HopCount = IPXCurRoute->RR_FamilySpecificData.FSD_HopCount;
        params.InterfaceIndex = IPXCurRoute->RR_InterfaceID;
        break;
    case RTM_ROUTE_DELETED:
        params.Action = FWD_DELETE_ROUTE;
        params.Network = IPXPrevRoute->RR_Network.N_NetNumber;
        IPX_NODENUM_CPY (params.NextHopAddress, IPXPrevRoute->RR_NextHopAddress.NHA_Mac);
        params.TickCount = IPXPrevRoute->RR_FamilySpecificData.FSD_TickCount;
        params.HopCount = IPXPrevRoute->RR_FamilySpecificData.FSD_HopCount;
        params.InterfaceIndex = IPXPrevRoute->RR_InterfaceID;
        break;
    case RTM_ROUTE_CHANGED:
        if ((IPX_NODENUM_CMP (IPXPrevRoute->RR_NextHopAddress.NHA_Mac,
                        IPXCurRoute->RR_NextHopAddress.NHA_Mac)!=0)
                || (IPXPrevRoute->RR_FamilySpecificData.FSD_TickCount
                        !=IPXCurRoute->RR_FamilySpecificData.FSD_TickCount)
                || (IPXPrevRoute->RR_FamilySpecificData.FSD_HopCount
                        !=IPXCurRoute->RR_FamilySpecificData.FSD_HopCount)
                || (IPXPrevRoute->RR_InterfaceID
                        !=IPXCurRoute->RR_InterfaceID)) {
            params.Action = FWD_UPDATE_ROUTE;
            params.Network = IPXCurRoute->RR_Network.N_NetNumber;
            IPX_NODENUM_CPY (params.NextHopAddress, IPXCurRoute->RR_NextHopAddress.NHA_Mac);
            params.TickCount = IPXCurRoute->RR_FamilySpecificData.FSD_TickCount;
            params.HopCount = IPXCurRoute->RR_FamilySpecificData.FSD_HopCount;
            params.InterfaceIndex = IPXCurRoute->RR_InterfaceID;
            break;
        }
        else
            return;
    }

	status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_SET_ROUTES,
						&params,
						sizeof (params),
						NULL,
						0);

	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}


	return;
#undef IPXPrevRoute
#undef IPXCurRoute
}

//
// Sets the netbios static routing information on this interface
//

DWORD
FwSetStaticNetbiosNames (
	ULONG								InterfaceIndex,
	ULONG								NetbiosNamesCount,
	PIPX_STATIC_NETBIOS_NAME_INFO		NetbiosNames
	) {
	IO_STATUS_BLOCK		    IoStatus;
	ULONG					index;
	NTSTATUS			    status;

	ASSERT (FwdDriverHandle!=NULL);

	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}

	if (NetbiosNamesCount>0) {
		status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_SET_NB_NAMES,
						&index,
						sizeof(index),
						NetbiosNames,
						NetbiosNamesCount
							*sizeof(IPX_STATIC_NETBIOS_NAME_INFO)
						);
	}
	else {
		status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_RESET_NB_NAMES,
						&index,
						sizeof(index),
						NULL,
						0);
	}

	if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
	}


	return RtlNtStatusToDosError (status);
}

//
// Gets the netbios static routing information on this interface
//
// If NetbiosNamesCount < nr of names or NetbiosName == NULL then set the
// correct value in NetbiosNamesCount and return ERROR_INSUFFICIENT_BUFFER

DWORD
FwGetStaticNetbiosNames (
	ULONG							InterfaceIndex,
	PULONG							NetbiosNamesCount,
	PIPX_STATIC_NETBIOS_NAME_INFO	NetbiosName
	) {
	IO_STATUS_BLOCK		    IoStatus;
	NTSTATUS			    status;
	ULONG					index;
	ULONG					bSize;
	PFWD_NB_NAMES_PARAMS	params=NULL;
		// Local buffer for small amounts of data
	UCHAR					localBuf[FIELD_OFFSET (FWD_NB_NAMES_PARAMS,Names)];


	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}
	bSize = FIELD_OFFSET (FWD_NB_NAMES_PARAMS,
							Names[*NetbiosNamesCount]);
	if (bSize<=sizeof (localBuf)) {
		params = (PFWD_NB_NAMES_PARAMS)&localBuf;
	}
	else {
		params = (PFWD_NB_NAMES_PARAMS)RtlAllocateHeap (
						RtlProcessHeap (), 0,
						bSize);
	}

	if (params!=NULL) {
		status = NtDeviceIoControlFile(
						FwdDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_FWD_GET_NB_NAMES,
						&index,
						sizeof (index),
						params,
						bSize);

		if (status==STATUS_PENDING) {
			status = NtWaitForSingleObject (FwdDriverHandle, FALSE, NULL);
			if (NT_SUCCESS (status))
				status = IoStatus.Status;
		}

		switch (status) {
		case STATUS_SUCCESS:
		case STATUS_BUFFER_OVERFLOW:
			if (IoStatus.Information>FIELD_OFFSET (FWD_NB_NAMES_PARAMS,Names))
			    if (NetbiosName)
			    {
			        ULONG_PTR dwInfoSize, dwBufferSize;

			        dwInfoSize = 
			            IoStatus.Information - 
			            FIELD_OFFSET (FWD_NB_NAMES_PARAMS,Names);

                    dwBufferSize = 
                        *NetbiosNamesCount * sizeof(IPX_STATIC_NETBIOS_NAME_INFO);

    				RtlCopyMemory (
    				    NetbiosName, 
    				    &params->Names,
    				    (dwInfoSize > dwBufferSize) ? dwBufferSize : dwInfoSize);
			    }
			else if (status==STATUS_BUFFER_OVERFLOW)
				status = STATUS_BUFFER_TOO_SMALL;
			*NetbiosNamesCount = params->TotalCount;
			break;
		}

		if (params!=(PFWD_NB_NAMES_PARAMS)localBuf)
			RtlFreeHeap (RtlProcessHeap (), 0, params);
	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;

	return RtlNtStatusToDosError (status);
}



DWORD
SetFilters (
	IN ULONG	InterfaceIndex,
	IN ULONG	FilterMode,    // inbound, outbound
	IN ULONG	FilterAction,
	IN ULONG	FilterSize,
	IN LPVOID	FilterInfo,
	IN ULONG	FilterInfoSize
	) {
	IO_STATUS_BLOCK		    IoStatus;
	FLT_IF_SET_PARAMS		params;
	NTSTATUS			    status;
	ULONG					code;

	ASSERT (FltDriverHandle!=NULL);

	switch (FilterMode) {
	case IPX_TRAFFIC_FILTER_INBOUND:
		if (FilterInfoSize>0)
			code = IOCTL_FLT_IF_SET_IN_FILTERS;
		else
			code = IOCTL_FLT_IF_RESET_IN_FILTERS;
		break;
	case IPX_TRAFFIC_FILTER_OUTBOUND:
		if (FilterInfoSize>0)
			code = IOCTL_FLT_IF_SET_OUT_FILTERS;
		else
			code = IOCTL_FLT_IF_RESET_OUT_FILTERS;
		break;
	default:
		ASSERTMSG ("Invalid filter mode ", FALSE);
		return ERROR_INVALID_PARAMETER;
	}

	switch (InterfaceIndex) {
	case 0:
		params.InterfaceIndex = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		params.InterfaceIndex = InterfaceIndex;
		break;
	}
	if (FilterInfoSize>0) {
		params.FilterAction = FilterAction;
		params.FilterSize = FilterSize;
		status = NtDeviceIoControlFile(
							FltDriverHandle,
							NULL,
							NULL,
							NULL,
							&IoStatus,
							code,
							&params,
							sizeof(params),
							FilterInfo,
							FilterInfoSize
							);
	}
	else {
		status = NtDeviceIoControlFile(
							FltDriverHandle,
							NULL,
							NULL,
							NULL,
							&IoStatus,
							code,
							&params.InterfaceIndex,
							sizeof(params.InterfaceIndex),
							NULL,
							0
							);
	}

	if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (FltDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
	}


	return RtlNtStatusToDosError (status);
}

DWORD
GetFilters(IN ULONG	InterfaceIndex,
	   IN ULONG	FilterMode,    // inbound, outbound
	   OUT PULONG	FilterAction,
	   OUT PULONG	FilterSize,
	   OUT LPVOID	FilterInfo,
       IN OUT PULONG FilterInfoSize) {
	IO_STATUS_BLOCK		    IoStatus;
	NTSTATUS			    status;
	ULONG					index;
	ULONG					code;
	PFLT_IF_GET_PARAMS		params=NULL;
	ULONG					bSize;
		// Local buffer for small amounts of data
	UCHAR					localBuf[sizeof (FLT_IF_GET_PARAMS)];


	switch (FilterMode) {
	case IPX_TRAFFIC_FILTER_INBOUND:
		code = IOCTL_FLT_IF_GET_IN_FILTERS;
		break;
	case IPX_TRAFFIC_FILTER_OUTBOUND:
		code = IOCTL_FLT_IF_GET_OUT_FILTERS;
		break;
	default:
		ASSERTMSG ("Invalid filter mode ", FALSE);
		return ERROR_INVALID_PARAMETER;
	}

	switch (InterfaceIndex) {
	case 0:
		index = FWD_INTERNAL_INTERFACE_INDEX;
		break;
	default:
		index = InterfaceIndex;
		break;
	}

	bSize = sizeof (FLT_IF_GET_PARAMS)+*FilterInfoSize;
	if (bSize<=sizeof (localBuf)) {
		params = (PFLT_IF_GET_PARAMS)&localBuf;
	}
	else {
		params = (PFLT_IF_GET_PARAMS)RtlAllocateHeap (
						RtlProcessHeap (), 0,
						bSize);
	}

	if (params!=NULL) {
		status = NtDeviceIoControlFile(
						FltDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						code,
						&index,
						sizeof (index),
						params,
						bSize);

		if (status==STATUS_PENDING) {
			status = NtWaitForSingleObject (FltDriverHandle, FALSE, NULL);
			if (NT_SUCCESS (status))
				status = IoStatus.Status;
		}

		switch (status) {
		case STATUS_SUCCESS:
		case STATUS_BUFFER_OVERFLOW:
			if (FilterInfo && IoStatus.Information>=sizeof (FLT_IF_GET_PARAMS))
				RtlCopyMemory (FilterInfo, &params[1],
						IoStatus.Information
						-sizeof (FLT_IF_GET_PARAMS));
			else if (status==STATUS_BUFFER_OVERFLOW)
				status = STATUS_BUFFER_TOO_SMALL;

			*FilterInfoSize = params->TotalSize;
			*FilterAction = params->FilterAction;
			*FilterSize = params->FilterSize;
			break;
		default:
			break;
		}

		if (params!=(PFLT_IF_GET_PARAMS)localBuf)
			RtlFreeHeap (RtlProcessHeap (), 0, params);
	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;

	return RtlNtStatusToDosError (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\ipxtest2.c ===
#include "ipxdefs.h"

#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}
#else
#define ASSERTERR(exp)
#endif

#if DBG
#define ASSERTERRMSG(msg,exp) 									\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERRMSG(msg,exp)
#endif

typedef struct _SERVICE_ENTRY {
		USHORT				type;
		BYTE				name[48];
		IPX_ADDRESS_BLOCK	addr;
		USHORT				hops;
		} SERVICE_ENTRY, *PSERVICE_ENTRY;


typedef struct _SAP_PACKET {
		OVERLAPPED			ovrp;
		LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine;
		ADDRESS_RESERVED 	rsvd;
		IPX_HEADER			hdr;
		union {
			UCHAR				data[576-sizeof(IPX_HEADER)];
			struct {
				USHORT				operation;
				SERVICE_ENTRY		entry[7];
				}				sap;
			};
		} SAP_PACKET, *PSAP_PACKET;

#define SAP_SOCKET_NUM		0x0452



VOID CALLBACK
SendCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	);
	
VOID CALLBACK
RecvCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	);

BOOL WINAPI
CtrlHandler (
	DWORD		fdwCtrlType
	);

static BOOL			*AdapterArr;
static SAP_PACKET 	recvPacket;
static HANDLE		hdl[3];
static ULONG		CurAdapter;
static LONG			NumActiveAdapters;
static ADAPTERS_GLOBAL_PARAMETERS	gParam;
static HANDLE		sockPort=INVALID_HANDLE_VALUE;
static BOOL			Stop;


int __cdecl main (
	int 	argc,
	char 	**argv
	) {
	HANDLE		cfgHdl;
	WCHAR		name[64];
	ULONG		i, len=sizeof (name);
	ADAPTER_INFO params;
	DWORD		status;
	ULONG		adpStatus;
	PSAP_PACKET	sendPacket;
	LONG		nObjects=2;
	HANDLE		compHdl;


	printf ("**** Starting Up...\n\n");

	hdl[0] = CreateEvent (NULL, 	// def security
						TRUE,		// manual reset
						FALSE,		// initially non-signaled
						NULL);
	ASSERTERRMSG ("Can't create Ipx event. ", hdl[0]!=NULL);

	hdl[1] = CreateEvent (NULL, 	// def security
						TRUE,		// manual reset
						FALSE,		// initially non-signaled
						NULL);
	ASSERTERRMSG ("Can't create console event. ", hdl[1]!=NULL);
	
	Stop = FALSE;
	status = SetConsoleCtrlHandler (
					&CtrlHandler,
					TRUE
					);
	ASSERTERRMSG ("Can't set console ctrl handler. ", status);
	

	printf ("Press CTRL+C at any time to terminate this program\n.");

	cfgHdl = IpxCreateAdapterConfigurationPort (
							hdl[0],
							&gParam);
	ASSERTERRMSG ("Can't create config port. ",
							 cfgHdl!=INVALID_HANDLE_VALUE);
	ASSERTMSG ("No adapters available. ", gParam.AdaptersCount>0);

	AdapterArr = (BOOL *)GlobalAlloc (GMEM_FIXED, sizeof (BOOL)*(gParam.AdaptersCount+1));
	ASSERTERRMSG ("Can't allocate adapter array. ", AdapterArr!=NULL);
	for (i=0; i<=gParam.AdaptersCount; i++)
		AdapterArr[i] = FALSE;
	CurAdapter = 0xFFFFFFFF;
	NumActiveAdapters = -1;
	while (!Stop) {
		status=WaitForMultipleObjectsEx (
						nObjects,
						hdl,
						FALSE,	// Wait for any object to complete
						INFINITE,
						TRUE	// Alertable wait
						);
		switch (status) {
			case WAIT_IO_COMPLETION:
				break;
			case WAIT_OBJECT_0:
				while (IpxGetQueuedAdapterConfigurationStatus (
										cfgHdl,
										&i,
										&adpStatus,
										&params)==NO_ERROR) {
					switch (adpStatus) {
						case ADAPTER_DELETED:
						case ADAPTER_DOWN:
							printf ("\n*****Adapter # %d %s.*****", i,
									 (adpStatus==ADAPTER_DELETED)
									 	? "deleted" : "down");

							if (AdapterArr[i]) {
								AdapterArr[i] = FALSE;
								if (i!=0) {
									printf ("\n******Stopping adapter # %d******\n\n", i);
									if (InterlockedDecrement (&NumActiveAdapters)<0) {
										printf ("\n******Deleting socket port******\n\n");
										DeleteSocketPort (sockPort);
										sockPort = INVALID_HANDLE_VALUE;
										nObjects = 2;
										}
									}
								}
							
							break;
						case ADAPTER_CREATED:
						case ADAPTER_UP:
							len = sizeof (name);
							status = GetAdapterNameW (i, &len, name);
							ASSERTMSG ("GetAdapterNameW failed ", status==NO_ERROR);
							printf ("\n*****Adapter # %d (%ls) %s!*****\n\n",i,name,
									 (adpStatus==ADAPTER_CREATED)
									 	? "created" : "up");
							AdapterArr[i] = TRUE;
							if (i!=0) {
								printf ("\n******Starting adapter # %d******\n\n", i);
								if (InterlockedIncrement (&NumActiveAdapters)==0) {
									USHORT 	sockNum;
									printf ("\n******Creating socket port******\n\n");
									PUTUSHORT2SHORT (&sockNum, SAP_SOCKET_NUM);
									sockPort = CreateSocketPort (sockNum);
									ASSERTERR (sockPort!=INVALID_HANDLE_VALUE);
									compHdl = CreateIoCompletionPort (sockPort,
													NULL,
													0,
													0);
									ASSERTERR (compHdl!=NULL);
									hdl[2] = sockPort;
									nObjects = 3;

									recvPacket.ovrp.hEvent = NULL;
									recvPacket.CompletionRoutine = RecvCompletion;
									status = IpxRecvPacket (sockPort,
										(PUCHAR)&recvPacket.hdr,
										sizeof(SAP_PACKET)
											-FIELD_OFFSET (SAP_PACKET, hdr),
										&recvPacket.rsvd,
										&recvPacket.ovrp,
										NULL);
									ASSERTMSG ("Failed to start receive. ",
													 status==NO_ERROR);
									}

								sendPacket = (PSAP_PACKET)GlobalAlloc (GMEM_FIXED,
																sizeof(SAP_PACKET));
								ASSERTERR (sendPacket!=NULL);

								PUTUSHORT2SHORT (&sendPacket->hdr.checksum,0xFFFF);
								PUTUSHORT2SHORT (&sendPacket->hdr.length, 34);
								sendPacket->hdr.transportctl = 0;
								sendPacket->hdr.pkttype = 0x04;
								memcpy (&sendPacket->hdr.dst.net, &params.Network, 4);
								if (params.NdisMedium==NdisMediumWan)
									memcpy (sendPacket->hdr.dst.node, params.RemoteNode, 6);
								else
									memset (sendPacket->hdr.dst.node, 0xFF, 6);
								PUTUSHORT2SHORT (&sendPacket->hdr.dst.socket, SAP_SOCKET_NUM);
								memcpy (sendPacket->hdr.src.net, params.Network, 4);
								memcpy (sendPacket->hdr.src.node, params.LocalNode, 6);
								PUTUSHORT2SHORT (&sendPacket->hdr.src.socket, SAP_SOCKET_NUM);
								PUTUSHORT2SHORT (&sendPacket->sap.operation, 3);
								PUTUSHORT2SHORT (&sendPacket->sap.entry[0].type, 0x0003);
								sendPacket->ovrp.hEvent = NULL;
								sendPacket->CompletionRoutine = SendCompletion;
								status = IpxSendPacket (sockPort,
										i,
										(PUCHAR)&sendPacket->hdr,
										34,
										&sendPacket->rsvd,
										&sendPacket->ovrp,
										NULL);
								ASSERTMSG ("Failed to start send. ",
														status==NO_ERROR);
								}
							break;
						default:
							ASSERTMSG ("Unknown adapter status reported ", FALSE);
						
						}
					}
				break;
			case WAIT_OBJECT_0+1:
				break;
			case WAIT_OBJECT_0+2:
				if (IpxGetQueuedCompletionStatus (
								compHdl,
								&len,
								&i,
								(LPOVERLAPPED *)&sendPacket,
								0) || (sendPacket!=NULL))
					(*sendPacket->CompletionRoutine) (
										sendPacket->ovrp.Internal,
										len,
										&sendPacket->ovrp);
				else
					fprintf (stderr,
							 "Completion port is signalled,"
							 " but no packets are waiting.\n");
				break;
			}
		}

	printf ("\n\n**** Exiting with status: %lX ****\n\n", status);


	NumActiveAdapters = -1;
	if (sockPort!=INVALID_HANDLE_VALUE)
		DeleteSocketPort (sockPort);
	IpxDeleteAdapterConfigurationPort (cfgHdl);
	GlobalFree (AdapterArr);
	NtClose (hdl[2]);
	CloseHandle (hdl[1]);
	CloseHandle (hdl[0]);

	return status;
	}

BOOL WINAPI
CtrlHandler (
	DWORD		fdwCtrlType
	) {

	switch (fdwCtrlType) {
		case CTRL_C_EVENT:
			Stop = TRUE;
			SetEvent (hdl[1]);
			return TRUE;

        /* CTRL+CLOSE: confirm that the user wants to exit. */

        case CTRL_CLOSE_EVENT:
			Stop = TRUE;
			SetEvent (hdl[1]);
            return TRUE;

        /* Pass other signals to the next handler. */

        case CTRL_BREAK_EVENT:

        case CTRL_LOGOFF_EVENT:

        case CTRL_SHUTDOWN_EVENT:

        default:
			Stop = TRUE;
			SetEvent (hdl[1]);
            return FALSE;


    	}

	}


VOID CALLBACK
SendCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	) {
#define sendPacket ((PSAP_PACKET)context)

	printf ("Status          : %ld\n", status);
	printf ("Bytes sent      : %d\n", cbBytes);

	printf ("Checksum        : %04X\n", GETSHORT2USHORTdirect(&sendPacket->hdr.checksum));
	printf ("Length          : %d\n", GETSHORT2USHORTdirect (&sendPacket->hdr.length));
	printf ("Hop count       : %d\n", sendPacket->hdr.transportctl);
	printf ("Packet type     : %02X\n", sendPacket->hdr.pkttype);
	printf ("Dest. net       : %02X%02X%02X%02X\n",
										sendPacket->hdr.dst.net[0],
										sendPacket->hdr.dst.net[1],
										sendPacket->hdr.dst.net[2],
										sendPacket->hdr.dst.net[3]);
	printf ("Dest. node      : %02X%02X%02X%02X%02X%02X\n",
										sendPacket->hdr.dst.node[0],
										sendPacket->hdr.dst.node[1],
										sendPacket->hdr.dst.node[2],
										sendPacket->hdr.dst.node[3],
										sendPacket->hdr.dst.node[4],
										sendPacket->hdr.dst.node[5]);
	printf ("Dest. socket    : %04X\n", GETSHORT2USHORTdirect (&sendPacket->hdr.dst.socket));
	printf ("Source net      : %02X%02X%02X%02X\n",
										sendPacket->hdr.src.net[0],
										sendPacket->hdr.src.net[1],
										sendPacket->hdr.src.net[2],
										sendPacket->hdr.src.net[3]);
	printf ("Source node     : %02X%02X%02X%02X%02X%02X\n",
										sendPacket->hdr.src.node[0],
										sendPacket->hdr.src.node[1],
										sendPacket->hdr.src.node[2],
										sendPacket->hdr.src.node[3],
										sendPacket->hdr.src.node[4],
										sendPacket->hdr.src.node[5]);
	printf ("Source socket   : %04X\n", GETSHORT2USHORTdirect (&sendPacket->hdr.src.socket));
	printf ("\n\n");
	GlobalFree (sendPacket);
#undef sendPacket
	}


VOID CALLBACK
RecvCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	) {
#define recvPacket ((PSAP_PACKET)context)
	CurAdapter = GetNicId(&recvPacket->rsvd);
	if ((CurAdapter>=0)
		&& (CurAdapter<=gParam.AdaptersCount)
		&& AdapterArr[CurAdapter]) {
		printf ("Adapter #       : %d\n", CurAdapter);
		printf ("Status          : %ld\n", status);
		printf ("Bytes received  : %d\n", cbBytes);
		if (cbBytes>=(DWORD)(FIELD_OFFSET (SAP_PACKET, data)
						-FIELD_OFFSET(SAP_PACKET,hdr))) {
			printf ("Checksum        : %04X\n", GETSHORT2USHORTdirect(&recvPacket->hdr.checksum));
			printf ("Length          : %d\n", GETSHORT2USHORTdirect (&recvPacket->hdr.length));
			printf ("Hop count       : %d\n", recvPacket->hdr.transportctl);
			printf ("Packet type     : %02X\n", recvPacket->hdr.pkttype);
			printf ("Dest. net       : %02X%02X%02X%02X\n",
												recvPacket->hdr.dst.net[0],
												recvPacket->hdr.dst.net[1],
												recvPacket->hdr.dst.net[2],
												recvPacket->hdr.dst.net[3]);
			printf ("Dest. node      : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->hdr.dst.node[0],
												recvPacket->hdr.dst.node[1],
												recvPacket->hdr.dst.node[2],
												recvPacket->hdr.dst.node[3],
												recvPacket->hdr.dst.node[4],
												recvPacket->hdr.dst.node[5]);
			printf ("Dest. socket    : %04X\n", GETSHORT2USHORTdirect (&recvPacket->hdr.dst.socket));
			printf ("Source net      : %02X%02X%02X%02X\n",
												recvPacket->hdr.src.net[0],
												recvPacket->hdr.src.net[1],
												recvPacket->hdr.src.net[2],
												recvPacket->hdr.src.net[3]);
			printf ("Source node     : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->hdr.src.node[0],
												recvPacket->hdr.src.node[1],
												recvPacket->hdr.src.node[2],
												recvPacket->hdr.src.node[3],
												recvPacket->hdr.src.node[4],
												recvPacket->hdr.src.node[5]);
			printf ("Source socket   : %04X\n", GETSHORT2USHORTdirect (&recvPacket->hdr.src.socket));
			if (cbBytes>=(DWORD)(FIELD_OFFSET(SAP_PACKET,sap.entry[0])
									-FIELD_OFFSET(SAP_PACKET,hdr))) {
				INT	j;
				printf ("SAP Operation   : %d\n", GETSHORT2USHORTdirect (&recvPacket->sap.operation));
				for (j=0; (j<7) && (cbBytes>=(DWORD)FIELD_OFFSET (SAP_PACKET, sap.entry[j+1])); j++) {
					printf ("Server type     : %04X\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].type));
					printf ("Server name     : %.48s\n", recvPacket->sap.entry[j].name);
					printf ("Server net      : %02X%02X%02X%02X\n",
												recvPacket->sap.entry[j].addr.net[0],
												recvPacket->sap.entry[j].addr.net[1],
												recvPacket->sap.entry[j].addr.net[2],
												recvPacket->sap.entry[j].addr.net[3]);
					printf ("Server node     : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->sap.entry[j].addr.node[0],
												recvPacket->sap.entry[j].addr.node[1],
												recvPacket->sap.entry[j].addr.node[2],
												recvPacket->sap.entry[j].addr.node[3],
												recvPacket->sap.entry[j].addr.node[4],
												recvPacket->sap.entry[j].addr.node[5]);
					printf ("Server socket   : %04X\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].addr.socket));
					printf ("Server hops     : %d\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].hops));
					}
				}
			}
		else
			printf ("**************INVALID BYTE COUNT********");
		printf ("\n\n");
		}
	else
		printf ("Adapter #       : %d - ignored \n", CurAdapter);

	if ((NumActiveAdapters>=0) && !Stop) {
		status = IpxRecvPacket (sockPort,
			(PUCHAR)&recvPacket->hdr,
			sizeof(SAP_PACKET)
				-FIELD_OFFSET (SAP_PACKET, hdr),
			&recvPacket->rsvd,
			&recvPacket->ovrp,
			NULL);
		
		ASSERTMSG ("Failed to start receive. ", status==NO_ERROR);
		}
#undef recvPacket
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\ipxtest.c ===
#include "ipxdefs.h"

#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}
#else
#define ASSERTERR(exp)
#endif

#if DBG
#define ASSERTERRMSG(msg,exp) 									\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERRMSG(msg,exp)
#endif

typedef struct _SERVICE_ENTRY {
		USHORT				type;
		BYTE				name[48];
		IPX_ADDRESS_BLOCK	addr;
		USHORT				hops;
		} SERVICE_ENTRY, *PSERVICE_ENTRY;


typedef struct _SAP_PACKET {
		OVERLAPPED			ovrp;
		ADDRESS_RESERVED 	rsvd;
		IPX_HEADER			hdr;
		union {
			UCHAR				data[576-sizeof(IPX_HEADER)];
			struct {
				USHORT				operation;
				SERVICE_ENTRY		entry[7];
				}				sap;
			};
		} SAP_PACKET, *PSAP_PACKET;

#define SAP_SOCKET_NUM		0x0452



VOID CALLBACK
SendCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	);

VOID CALLBACK
RecvCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	);

BOOL WINAPI
CtrlHandler (
	DWORD		fdwCtrlType
	);

static BOOL			*AdapterArr;
static SAP_PACKET 	recvPacket;
static HANDLE		hdl[2];
static ULONG		CurAdapter;
static LONG			NumActiveAdapters;
static ADAPTERS_GLOBAL_PARAMETERS	gParam;
static HANDLE		sockPort=INVALID_HANDLE_VALUE;
static BOOL			Stop;

static LONG			Flags = 0;
#define FWD_IF_TEST	0x1
#define SAP_SOCKET_TEST 0x2
#define SEND_RECV_TEST	0x4


int __cdecl main (
	int 	argc,
	char 	**argv
	) {
	HANDLE		cfgHdl;
	WCHAR		name[64];
	ULONG		i, len=sizeof (name);
	ADAPTER_INFO params;
	DWORD		status;
	ULONG		adpStatus;
	PSAP_PACKET	sendPacket;
	FW_IF_INFO	info;
    FW_IF_STATS stats;
	IPX_ADAPTER_BINDING_INFO binfo;
	ULONG		dstNet;
	ULONG		nodeLow;
	USHORT		nodeHigh;
	UCHAR		dstNode[6];
	USHORT		dstSocket;
	RTM_IPX_ROUTE	route;

	for (i=1; (INT)i<argc; i++) {
		_strupr (argv[i]);
		if (strcmp (argv[i], "FWD")==0) {
			Flags |= FWD_IF_TEST;
			printf ("Test forwarder interface.\n");
			}
		else if (!(Flags & SEND_RECV_TEST)
					&& (strcmp (argv[i], "SAP")==0)) {
			Flags |= SAP_SOCKET_TEST;
			printf ("Test by sending and listening on sap socket.\n");
			}
		else if (!(Flags & SAP_SOCKET_TEST)
					&& (sscanf ("%8lX:%8lX%4hX:%4hX", argv[i],
							&dstNet, &nodeLow, nodeHigh,
							&dstSocket)==4)) {
			Flags |= SEND_RECV_TEST;
			PUTULONG2LONG (&dstNode[0], nodeLow);
			PUTUSHORT2SHORT (&dstNode[4], nodeHigh);
			printf ("Test by sending to %08lx:%02x%02x%02x%02x%02x%02x:%04x and"
				" listening on socket %04x.\n", dstNet,
				dstNode[0], dstNode[1], dstNode[2],
					dstNode[3], dstNode[4], dstNode[5],
				dstSocket, dstSocket);
			}
		else {
			printf ("Usage: %s [fwd] [ [sap] | [xxxxxxxx:xxxxxxxxxxx:xxxx] ]\n", argv[0]);
			return 1;
			}
		}

	printf ("**** Starting Up...\n\n");

	hdl[0] = CreateEvent (NULL, 	// def security
						TRUE,		// manual reset
						FALSE,		// initially non-signaled
						NULL);
	ASSERTERRMSG ("Can't create Ipx event. ", hdl[0]!=NULL);

	hdl[1] = CreateEvent (NULL, 	// def security
						TRUE,		// manual reset
						FALSE,		// initially non-signaled
						NULL);
	ASSERTERRMSG ("Can't create console event. ", hdl[0]!=NULL);
	
	Stop = FALSE;
	status = SetConsoleCtrlHandler (
					&CtrlHandler,
					TRUE
					);
	ASSERTERRMSG ("Can't set console ctrl handler. ", status);
	

	printf ("Press CTRL+C at any time to terminate this program\n.");

	if (Flags & FWD_IF_TEST) {
		status = FwStart (257, TRUE);
		ASSERTMSG ("Could not start forwarder " , status==NO_ERROR);
		}

	cfgHdl = IpxCreateAdapterConfigurationPort (
							hdl[0],
							&gParam);
	ASSERTERRMSG ("Can't create config port. ",
							 cfgHdl!=INVALID_HANDLE_VALUE);
	ASSERTMSG ("No adapters available. ", gParam.AdaptersCount>0);

	AdapterArr = (BOOL *)GlobalAlloc (GMEM_FIXED, sizeof (BOOL)*(gParam.AdaptersCount+1));
	ASSERTERRMSG ("Can't allocate adapter array. ", AdapterArr!=NULL);
	for (i=0; i<=gParam.AdaptersCount; i++)
		AdapterArr[i] = FALSE;
	CurAdapter = 0xFFFFFFFF;
	NumActiveAdapters = -1;
	while (!Stop) {
		status=WaitForMultipleObjectsEx (
						2,
						hdl,
						FALSE,	// Wait for any object to complete
						INFINITE,
						TRUE	// Alertable wait
						);
		switch (status) {
			case WAIT_IO_COMPLETION:
				break;
			case WAIT_OBJECT_0:
				while (IpxGetQueuedAdapterConfigurationStatus (
										cfgHdl,
										&i,
										&adpStatus,
										&params)==NO_ERROR) {
					switch (adpStatus) {
						case ADAPTER_DELETED:
						case ADAPTER_DOWN:
							printf ("\n*****Adapter # %d %s.*****", i,
									 (adpStatus==ADAPTER_DELETED)
									 	? "deleted" : "down");

							if (AdapterArr[i]) {
								AdapterArr[i] = FALSE;
									
								printf ("\n******Stopping adapter # %d******\n\n", i);
								if (Flags & FWD_IF_TEST) {
									status = FwUnbindFwInterfaceFromAdapter (i);
									ASSERTMSG ("Could not unbind fwif ",
														status==NO_ERROR);
									status = FwDeleteInterface (i);
									ASSERTMSG ("Could not delete fwif ",
														status==NO_ERROR);
									}
								if (i!=0) {
									if (InterlockedDecrement (&NumActiveAdapters)<0) {
										printf ("\n******Deleting socket port******\n\n");
										DeleteSocketPort (sockPort);
										sockPort = INVALID_HANDLE_VALUE;
										}
									}
								}
							
							break;
						case ADAPTER_CREATED:
						case ADAPTER_UP:
							len = sizeof (name);
							status = GetAdapterNameW (i, &len, name);
							ASSERTMSG ("GetAdapterNameW failed ", status==NO_ERROR);
							printf ("\n*****Adapter # %d (%ls) %s!*****\n\n",i,name,
									 (adpStatus==ADAPTER_CREATED)
									 	? "created" : "up");
							AdapterArr[i] = TRUE;

							if (Flags & FWD_IF_TEST) {
								info.NetbiosAccept = ADMIN_STATE_ENABLED;
								info.NetbiosDeliver = ADMIN_STATE_ENABLED;
								binfo.AdapterIndex = i;
								IPX_NETNUM_CPY (binfo.Network, params.Network);
								IPX_NODENUM_CPY (binfo.LocalNode, params.LocalNode);
								IPX_NODENUM_CPY (binfo.RemoteNode, params.RemoteNode);
								binfo.MaxPacketSize = params.MaxPacketSize;
								binfo.LinkSpeed = params.LinkSpeed;
								route.RR_RoutingProtocol = 0;
								route.RR_InterfaceID = 
									(params.NdisMedium==NdisMediumWan)
										? params.InterfaceIndex
										: i;
								memset (&route.RR_ProtocolSpecificData,
											0,
											sizeof (route.RR_ProtocolSpecificData));
								GETLONG2ULONG (&route.RR_Network.N_NetNumber,
												params.Network);
								memset (route.RR_NextHopAddress.NHA_Mac, 0, 6);
								route.RR_FamilySpecificData.FSD_Flags = 0;
								route.RR_FamilySpecificData.FSD_TickCount = 10;
								route.RR_FamilySpecificData.FSD_HopCount = 1;
								}

							if (i!=0) {
								printf ("\n******Starting adapter # %d******\n\n", i);
								if (Flags & FWD_IF_TEST) {
									status = FwCreateInterface (
										(params.NdisMedium==NdisMediumWan)
											? params.InterfaceIndex
											: i,
										(params.NdisMedium==NdisMediumWan)
											? DEMAND_DIAL
											: PERMANENT,
										&info);
									ASSERTMSG ("Could not create fwif ",
														status==NO_ERROR);
									FwUpdateRouteTable (RTM_ROUTE_ADDED, &route, NULL);
									status = FwEnableFwInterface (
										(params.NdisMedium==NdisMediumWan)
											? params.InterfaceIndex
											: i);
									ASSERTMSG ("Could not enable fwif ",
														status==NO_ERROR);
									status = FwBindFwInterfaceToAdapter (
										(params.NdisMedium==NdisMediumWan)
											? params.InterfaceIndex
											: i,
										&binfo);
									ASSERTMSG ("Could not bind fwif ",
														status==NO_ERROR);
									status = FwGetInterface (
										(params.NdisMedium==NdisMediumWan)
											? params.InterfaceIndex
											: i,
										&info,
										&stats);
									ASSERTMSG ("Could not get fwif ",
														status==NO_ERROR);
									}

								if (Flags & (SAP_SOCKET_TEST|SEND_RECV_TEST)) {
									if (InterlockedIncrement (&NumActiveAdapters)==0) {
										USHORT sockNum;
										printf ("\n******Creating socket port******\n\n");
										if (Flags & SAP_SOCKET_TEST) {
											PUTUSHORT2SHORT (&sockNum, SAP_SOCKET_NUM);
											}
										else {
											PUTUSHORT2SHORT (&sockNum, dstSocket);
											}

										sockPort = CreateSocketPort (sockNum);
										ASSERTERR (sockPort!=INVALID_HANDLE_VALUE);
										recvPacket.ovrp.hEvent = NULL;
										status = IpxRecvPacket (sockPort,
											(PUCHAR)&recvPacket.hdr,
											sizeof(SAP_PACKET)
												-FIELD_OFFSET (SAP_PACKET, hdr),
											&recvPacket.rsvd,
											&recvPacket.ovrp,
											&RecvCompletion);
										ASSERTMSG ("Failed to start receive. ",
														 status==NO_ERROR);
										}

									sendPacket = (PSAP_PACKET)GlobalAlloc (GMEM_FIXED,
																	sizeof(SAP_PACKET));
									ASSERTERR (sendPacket!=NULL);

									PUTUSHORT2SHORT (&sendPacket->hdr.checksum,0xFFFF);
									PUTUSHORT2SHORT (&sendPacket->hdr.length, 34);
									sendPacket->hdr.transportctl = 0;
									sendPacket->hdr.pkttype = 0x04;
									if (Flags & SAP_SOCKET_TEST) {
										memcpy (&sendPacket->hdr.dst.net, &params.Network, 4);
										if (params.NdisMedium==NdisMediumWan)
											memcpy (sendPacket->hdr.dst.node, params.RemoteNode, 6);
										else
											memset (sendPacket->hdr.dst.node, 0xFF, 6);
										PUTUSHORT2SHORT (&sendPacket->hdr.dst.socket, SAP_SOCKET_NUM);
										}
									else {
										PUTULONG2LONG (&sendPacket->hdr.dst.net, dstNet);
										memcpy (sendPacket->hdr.dst.node, dstNode, 6);
										PUTUSHORT2SHORT (&sendPacket->hdr.dst.socket, dstSocket);
										}
									memcpy (sendPacket->hdr.src.net, params.Network, 4);
									memcpy (sendPacket->hdr.src.node, params.LocalNode, 6);
									PUTUSHORT2SHORT (&sendPacket->hdr.src.socket, SAP_SOCKET_NUM);
									PUTUSHORT2SHORT (&sendPacket->sap.operation, 3);
									PUTUSHORT2SHORT (&sendPacket->sap.entry[0].type, 0x0003);
									sendPacket->ovrp.hEvent = NULL;
									status = IpxSendPacket (sockPort,
											i,
											(PUCHAR)&sendPacket->hdr,
											34,
											&sendPacket->rsvd,
											&sendPacket->ovrp,
											&SendCompletion);
									ASSERTMSG ("Failed to start send. ",
															status==NO_ERROR);
									}
								}
							else {
								if (Flags & FWD_IF_TEST) {
									status = FwCreateInterface (
												0, PERMANENT, &info);
									ASSERTMSG ("Could not create fwif ",
														status==NO_ERROR);
									FwUpdateRouteTable (RTM_ROUTE_ADDED, &route, NULL);
									status = FwEnableFwInterface (
										(params.NdisMedium==NdisMediumWan)
											? params.InterfaceIndex
											: i);
									status = FwBindFwInterfaceToAdapter (
												0, &binfo);
									ASSERTMSG ("Could not bind fwif ",
														status==NO_ERROR);
									}
								}
							break;
						default:
							ASSERTMSG ("Unknown adapter status reported ", FALSE);
						
						}
					}
				break;
			}
		}

	printf ("\n\n**** Exiting with status: %lX ****\n\n", status);


	NumActiveAdapters = -1;
	if (Flags & (SAP_SOCKET_TEST|SEND_RECV_TEST)) {
		if (sockPort!=INVALID_HANDLE_VALUE)
			DeleteSocketPort (sockPort);
		}
	IpxDeleteAdapterConfigurationPort (cfgHdl);
	GlobalFree (AdapterArr);
	CloseHandle (hdl[1]);
	CloseHandle (hdl[0]);
	if (Flags & FWD_IF_TEST) {
		status = FwStop ();
		ASSERTMSG ("Could not stop forwarder ", status==NO_ERROR);
		}
	return status;
	}

BOOL WINAPI
CtrlHandler (
	DWORD		fdwCtrlType
	) {

	switch (fdwCtrlType) {
		case CTRL_C_EVENT:
			Stop = TRUE;
			SetEvent (hdl[1]);
			return TRUE;

        /* CTRL+CLOSE: confirm that the user wants to exit. */

        case CTRL_CLOSE_EVENT:
			Stop = TRUE;
			SetEvent (hdl[1]);
            return TRUE;

        /* Pass other signals to the next handler. */

        case CTRL_BREAK_EVENT:

        case CTRL_LOGOFF_EVENT:

        case CTRL_SHUTDOWN_EVENT:

        default:
			Stop = TRUE;
			SetEvent (hdl[1]);
            return FALSE;


    	}

	}


VOID CALLBACK
SendCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	) {
#define sendPacket ((PSAP_PACKET)context)

	printf ("Status          : %ld\n", status);
	printf ("Bytes sent      : %d\n", cbBytes);

	printf ("Checksum        : %04X\n", GETSHORT2USHORTdirect(&sendPacket->hdr.checksum));
	printf ("Length          : %d\n", GETSHORT2USHORTdirect (&sendPacket->hdr.length));
	printf ("Hop count       : %d\n", sendPacket->hdr.transportctl);
	printf ("Packet type     : %02X\n", sendPacket->hdr.pkttype);
	printf ("Dest. net       : %02X%02X%02X%02X\n",
										sendPacket->hdr.dst.net[0],
										sendPacket->hdr.dst.net[1],
										sendPacket->hdr.dst.net[2],
										sendPacket->hdr.dst.net[3]);
	printf ("Dest. node      : %02X%02X%02X%02X%02X%02X\n",
										sendPacket->hdr.dst.node[0],
										sendPacket->hdr.dst.node[1],
										sendPacket->hdr.dst.node[2],
										sendPacket->hdr.dst.node[3],
										sendPacket->hdr.dst.node[4],
										sendPacket->hdr.dst.node[5]);
	printf ("Dest. socket    : %04X\n", GETSHORT2USHORTdirect (&sendPacket->hdr.dst.socket));
	printf ("Source net      : %02X%02X%02X%02X\n",
										sendPacket->hdr.src.net[0],
										sendPacket->hdr.src.net[1],
										sendPacket->hdr.src.net[2],
										sendPacket->hdr.src.net[3]);
	printf ("Source node     : %02X%02X%02X%02X%02X%02X\n",
										sendPacket->hdr.src.node[0],
										sendPacket->hdr.src.node[1],
										sendPacket->hdr.src.node[2],
										sendPacket->hdr.src.node[3],
										sendPacket->hdr.src.node[4],
										sendPacket->hdr.src.node[5]);
	printf ("Source socket   : %04X\n", GETSHORT2USHORTdirect (&sendPacket->hdr.src.socket));
	printf ("\n\n");
	GlobalFree (sendPacket);
#undef sendPacket
	}


VOID CALLBACK
RecvCompletion (
	DWORD				status,
	DWORD				cbBytes,
	LPOVERLAPPED		context
	) {
#define recvPacket ((PSAP_PACKET)context)
	CurAdapter = GetNicId(&recvPacket->rsvd);
	if ((CurAdapter>=0)
		&& (CurAdapter<=gParam.AdaptersCount)
		&& AdapterArr[CurAdapter]) {
		printf ("Adapter #       : %d\n", CurAdapter);
		printf ("Status          : %ld\n", status);
		printf ("Bytes received  : %d\n", cbBytes);
		if (cbBytes>=(DWORD)(FIELD_OFFSET (SAP_PACKET, data)
						-FIELD_OFFSET(SAP_PACKET,hdr))) {
			printf ("Checksum        : %04X\n", GETSHORT2USHORTdirect(&recvPacket->hdr.checksum));
			printf ("Length          : %d\n", GETSHORT2USHORTdirect (&recvPacket->hdr.length));
			printf ("Hop count       : %d\n", recvPacket->hdr.transportctl);
			printf ("Packet type     : %02X\n", recvPacket->hdr.pkttype);
			printf ("Dest. net       : %02X%02X%02X%02X\n",
												recvPacket->hdr.dst.net[0],
												recvPacket->hdr.dst.net[1],
												recvPacket->hdr.dst.net[2],
												recvPacket->hdr.dst.net[3]);
			printf ("Dest. node      : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->hdr.dst.node[0],
												recvPacket->hdr.dst.node[1],
												recvPacket->hdr.dst.node[2],
												recvPacket->hdr.dst.node[3],
												recvPacket->hdr.dst.node[4],
												recvPacket->hdr.dst.node[5]);
			printf ("Dest. socket    : %04X\n", GETSHORT2USHORTdirect (&recvPacket->hdr.dst.socket));
			printf ("Source net      : %02X%02X%02X%02X\n",
												recvPacket->hdr.src.net[0],
												recvPacket->hdr.src.net[1],
												recvPacket->hdr.src.net[2],
												recvPacket->hdr.src.net[3]);
			printf ("Source node     : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->hdr.src.node[0],
												recvPacket->hdr.src.node[1],
												recvPacket->hdr.src.node[2],
												recvPacket->hdr.src.node[3],
												recvPacket->hdr.src.node[4],
												recvPacket->hdr.src.node[5]);
			printf ("Source socket   : %04X\n", GETSHORT2USHORTdirect (&recvPacket->hdr.src.socket));
			if (cbBytes>=(DWORD)(FIELD_OFFSET(SAP_PACKET,sap.entry[0])
									-FIELD_OFFSET(SAP_PACKET,hdr))) {
				INT		j;
				ULONG	nbNameCount = 0;
				printf ("SAP Operation   : %d\n", GETSHORT2USHORTdirect (&recvPacket->sap.operation));
				for (j=0; (j<7) && (cbBytes>=(DWORD)FIELD_OFFSET (SAP_PACKET, sap.entry[j+1])); j++) {
					printf ("Server type     : %04X\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].type));
					printf ("Server name     : %.48s\n", recvPacket->sap.entry[j].name);
					printf ("Server net      : %02X%02X%02X%02X\n",
												recvPacket->sap.entry[j].addr.net[0],
												recvPacket->sap.entry[j].addr.net[1],
												recvPacket->sap.entry[j].addr.net[2],
												recvPacket->sap.entry[j].addr.net[3]);
					printf ("Server node     : %02X%02X%02X%02X%02X%02X\n",
												recvPacket->sap.entry[j].addr.node[0],
												recvPacket->sap.entry[j].addr.node[1],
												recvPacket->sap.entry[j].addr.node[2],
												recvPacket->sap.entry[j].addr.node[3],
												recvPacket->sap.entry[j].addr.node[4],
												recvPacket->sap.entry[j].addr.node[5]);
					printf ("Server socket   : %04X\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].addr.socket));
					printf ("Server hops     : %d\n", GETSHORT2USHORTdirect (&recvPacket->sap.entry[j].hops));
					if ((Flags & FWD_IF_TEST)
							&& (strlen (recvPacket->sap.entry[j].name)<=16)) {
						nbNameCount += 1;
						}
					}
				if ((Flags & FWD_IF_TEST) && (nbNameCount>0)) {
					ULONG							getNameCount = 0;
					PIPX_STATIC_NETBIOS_NAME_INFO	nmBuffer = NULL;
					BOOL							doNbSet = FALSE;
					status = FwGetStaticNetbiosNames (
									CurAdapter,
									&getNameCount,
									NULL);
					ASSERTMSG ("Could not get nb name count",
							(status==NO_ERROR)||(status==ERROR_INSUFFICIENT_BUFFER));
					nmBuffer = (PIPX_STATIC_NETBIOS_NAME_INFO)GlobalAlloc (
										GMEM_FIXED,
										sizeof (IPX_STATIC_NETBIOS_NAME_INFO)
										*(getNameCount+nbNameCount));
					ASSERTMSG ("Could not allocate nb name buffer ",
									nmBuffer!=NULL);

					if (getNameCount>0) {
						status = FwGetStaticNetbiosNames (
											CurAdapter,
											&getNameCount,
											nmBuffer);
						ASSERTMSG ("Could not get nb names", status==NO_ERROR);
						}
					for (j=0; j<7; j++) {
						UINT	nmLen = strlen (recvPacket->sap.entry[j].name);
						if (nmLen<=16) {
							UINT	k;
							ULONG	i;
							for (k=nmLen; k<16; k++)
								recvPacket->sap.entry[j].name[k] = ' ';

							for (i=0; i<getNameCount; i++) {
								if (memcmp (&nmBuffer[i], recvPacket->sap.entry[j].name, 16)==0)
									break;
							}
							if (i==getNameCount) {
								memcpy (&nmBuffer[getNameCount], recvPacket->sap.entry[j].name, 16);
								getNameCount += 1;
								doNbSet = TRUE;
								}
							nbNameCount -= 1;
							if (nbNameCount == 0)
								break;
							}
						}
					if (doNbSet) {
						status = FwSetStaticNetbiosNames (
											CurAdapter,
											getNameCount,
											nmBuffer);
						ASSERTMSG ("Could not get nb names", status==NO_ERROR);
						}
					}
				}
			}
		else
			printf ("**************INVALID BYTE COUNT********");
		printf ("\n\n");
		}
	else
		printf ("Adapter #       : %d - ignored \n", CurAdapter);

	if ((NumActiveAdapters>=0) && !Stop) {
		status = IpxRecvPacket (sockPort,
			(PUCHAR)&recvPacket->hdr,
			sizeof(SAP_PACKET)
				-FIELD_OFFSET (SAP_PACKET, hdr),
			&recvPacket->rsvd,
			&recvPacket->ovrp,
			&RecvCompletion);
		
		ASSERTMSG ("Failed to start receive. ", status==NO_ERROR);
		}
#undef recvPacket
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\nictable.c ===
/*
    File    NicTable.c

    Implements a nic-renaming scheme that allows adaptif to 
    advertise whatever nic id it chooses to its clients while
    maintaining the list of actual nic id's internally.

    This functionality was needed in order to Pnp enable the 
    ipx router.  When an adapter is deleted, the stack renumbers
    the nicid's so that it maintains a contiguous block of ids
    internally.  Rather that cause the clients to adptif to 
    match the stack's renumbering schemes, we handle this
    transparently in adptif.

    Author:     Paul Mayfield, 12/11/97
*/

#include "ipxdefs.h"

#define NicMapDefaultSize 500
#define NicMapDefaultFactor 5
#define MAXIMUM_NIC_MAP_SIZE 25000

// Nic map used to associate nic's with virtual ids
typedef struct _NICMAPNODE {
    USHORT usVirtualId;
    IPX_NIC_INFO * pNicInfo;
} NICMAPNODE;

// Maintains the mapping from nic id to virtual id.
typedef struct _NICMAP {
    DWORD dwMapSize;
    DWORD dwNicCount;
    DWORD dwMaxNicId;
    NICMAPNODE ** ppNics;
    USHORT * usVirtMap;
} NICMAP;

// Definition of the global nic id map
NICMAP GlobalNicIdMap;

DWORD nmAddNic (NICMAP * pNicMap, IPX_NIC_INFO * pNicInfo);


// Resizes the nic map to accomodate more nics.  This function will
// probably only ever be called to allocate the array the first time.
DWORD nmEnlarge(NICMAP * pNicMap) {
    USHORT * usVirtMap;
    DWORD i, dwNewSize;
    NICMAPNODE ** ppNics;

    // Are we enlarging for the first time?
    if (!pNicMap->dwMapSize)
        dwNewSize = NicMapDefaultSize;
    else
        dwNewSize = pNicMap->dwMapSize * NicMapDefaultFactor;

    // Make sure we aren't too big...
    if (dwNewSize > MAXIMUM_NIC_MAP_SIZE) {
        // do something critical here!
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Resize the arrays
    usVirtMap = (USHORT*) RtlAllocateHeap(RtlProcessHeap(), 
                                          0, 
                                          dwNewSize * sizeof(USHORT));
                                        
    ppNics = (NICMAPNODE **) RtlAllocateHeap(RtlProcessHeap(), 
                                             0, 
                                             dwNewSize * sizeof(NICMAPNODE*));
                                         
    if (!usVirtMap || !ppNics)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize
    FillMemory(usVirtMap, dwNewSize * sizeof(USHORT), 0xff);
    ZeroMemory(ppNics, dwNewSize * sizeof(IPX_NIC_INFO*));
    usVirtMap[0] = 0;

    // Initialize the arrays.  
    for (i = 0; i < pNicMap->dwMapSize; i++) {
        usVirtMap[i] = pNicMap->usVirtMap[i];
        ppNics[i] = pNicMap->ppNics[i];    
    }

    // Free old data if needed
    if (pNicMap->dwMapSize) {
        RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->usVirtMap);
        RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics);
    }

    // Assign the new arrays
    pNicMap->usVirtMap = usVirtMap;
    pNicMap->ppNics = ppNics;
    pNicMap->dwMapSize = dwNewSize;
    
    return NO_ERROR;
}

// Returns the next available nic id
USHORT nmGetNextVirtualNicId(NICMAP * pNicMap, USHORT usPhysId) {
    DWORD i;
    
    // If this can be a one->one mapping, make it so
    if (pNicMap->usVirtMap[usPhysId] == NIC_MAP_INVALID_NICID)
        return usPhysId;

    // Otherwise, walk the array until you find free spot
    for (i = 2; i < pNicMap->dwMapSize; i++) {
       if (pNicMap->usVirtMap[i] == NIC_MAP_INVALID_NICID) 
            return (USHORT)i;
    }            

    return NIC_MAP_INVALID_NICID;
}

// Cleans up the nic
DWORD nmCleanup (NICMAP * pNicMap) {
    DWORD i;
    
    // Cleanup the virtual map
    if (pNicMap->usVirtMap)
        RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->usVirtMap);

    // Cleanup any of the nics stored in the map
    if (pNicMap->ppNics) {
        for (i = 0; i < pNicMap->dwMapSize; i++) {
            if (pNicMap->ppNics[i]) {
                if (pNicMap->ppNics[i]->pNicInfo)
                    RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics[i]->pNicInfo);
                RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics[i]);
            }
        }
        RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics);
    }

    return NO_ERROR;
}

// Initializes the nic 
DWORD nmInitialize (NICMAP * pNicMap) {
    DWORD dwErr;

    __try {
        // Enlarge the map to its default size
        ZeroMemory(pNicMap, sizeof (NICMAP));
        if ((dwErr = nmEnlarge(pNicMap)) != NO_ERROR)
            return dwErr;
    }
    __finally {
        if (dwErr != NO_ERROR) {
            nmCleanup(pNicMap);
            pNicMap->dwMapSize = 0;
        }
    }
    
    return NO_ERROR;

}

// Maps virtual nic ids to physical ones
USHORT nmGetPhysicalId (NICMAP * pNicMap, USHORT usVirtAdp) {
    return pNicMap->usVirtMap[usVirtAdp];
}    

// Maps physical nic ids to virtual ones
USHORT nmGetVirtualId (NICMAP * pNicMap, USHORT usPhysAdp) {
    if (usPhysAdp == NIC_MAP_INVALID_NICID)
    {
        return NIC_MAP_INVALID_NICID;
    }
    if (pNicMap->ppNics[usPhysAdp])
        return pNicMap->ppNics[usPhysAdp]->usVirtualId;
    return (usPhysAdp == 0) ? 0 : NIC_MAP_INVALID_NICID;
}

// Gets the nic info associated with a physical adapter
IPX_NIC_INFO * nmGetNicInfo (NICMAP * pNicMap, USHORT usPhysAdp) {
    if (pNicMap->ppNics[usPhysAdp])
        return pNicMap->ppNics[usPhysAdp]->pNicInfo;
    return NULL;
}

// Returns the number of nics in the map
DWORD nmGetNicCount (NICMAP * pNicMap) {
    return pNicMap->dwNicCount;
}

// Returns the current maximum nic id
DWORD nmGetMaxNicId (NICMAP * pNicMap) {
    return pNicMap->dwMaxNicId;
}

// Reconfigures a nic
DWORD nmReconfigure(NICMAP * pNicMap, IPX_NIC_INFO * pSrc) {
    IPX_NIC_INFO * pDst = nmGetNicInfo (pNicMap, pSrc->Details.NicId);

    if (pDst) {
        CopyMemory(pDst, pSrc, sizeof (IPX_NIC_INFO));
        pDst->Details.NicId = nmGetVirtualId (pNicMap, pSrc->Details.NicId);
    }
    else 
        return nmAddNic(pNicMap, pSrc);

    return NO_ERROR;
}

// Adds a nic to the table
DWORD nmAddNic (NICMAP * pNicMap, IPX_NIC_INFO * pNicInfo) {
    USHORT i = pNicInfo->Details.NicId, usVirt;

    // If the nic already exists, reconfigure it
    if (pNicMap->ppNics[i])
        return nmReconfigure (pNicMap, pNicInfo);

    // Otherwise, add it
    pNicMap->ppNics[i] = (NICMAPNODE*) RtlAllocateHeap (RtlProcessHeap(), 
                                                        0, 
                                                       (sizeof (NICMAPNODE)));
    if (!pNicMap->ppNics[i])
        return ERROR_NOT_ENOUGH_MEMORY;
        
    pNicMap->ppNics[i]->pNicInfo = (IPX_NIC_INFO *) 
                                    RtlAllocateHeap (RtlProcessHeap(), 
                                                     0, 
                                                     sizeof (IPX_NIC_INFO));
    if (!pNicMap->ppNics[i]->pNicInfo)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize it
    usVirt = nmGetNextVirtualNicId(pNicMap, i);
    pNicMap->ppNics[i]->usVirtualId = usVirt;
    pNicMap->ppNics[i]->pNicInfo->Details.NicId = usVirt;
    CopyMemory(pNicMap->ppNics[i]->pNicInfo, pNicInfo, sizeof (IPX_NIC_INFO));
    pNicMap->usVirtMap[usVirt] = i;

    // Update the nic count and maximum nic id
    if (i > pNicMap->dwMaxNicId)
        pNicMap->dwMaxNicId = i;
    pNicMap->dwNicCount++;
    
    return NO_ERROR;
}

// Deletes a nic from the table
DWORD nmDelNic (NICMAP * pNicMap, IPX_NIC_INFO * pNicInfo) {
    USHORT i = pNicInfo->Details.NicId, usVirt;

    // If the nic doesn't exists do nothing
    if (! pNicMap->ppNics[i])
        return ERROR_INVALID_INDEX;

    // Otherwise, delete it
    pNicMap->usVirtMap[pNicMap->ppNics[i]->usVirtualId] = NIC_MAP_INVALID_NICID;
    RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics[i]->pNicInfo);
    RtlFreeHeap(RtlProcessHeap(), 0, pNicMap->ppNics[i]);
    pNicMap->ppNics[i] = NULL;
    
    // Update the nic count and maximum nic id
    if (i >= pNicMap->dwMaxNicId)
        pNicMap->dwMaxNicId--;
    pNicMap->dwNicCount--;
    
    return NO_ERROR;
}

// Renumbers the nics in the table.  dwOpCode is one
// of the NIC_OPCODE_XXX_XXX values
DWORD nmRenumber (NICMAP * pNicMap, USHORT usThreshold, DWORD dwOpCode) {
    DWORD i;

    // Increment the nic id's if needed
    if (dwOpCode == NIC_OPCODE_INCREMENT_NICIDS) {
        for (i = pNicMap->dwMaxNicId; i >= usThreshold; i--) {
            pNicMap->ppNics[i+1] = pNicMap->ppNics[i];
            if (pNicMap->ppNics[i])
                pNicMap->usVirtMap[pNicMap->ppNics[i]->usVirtualId] = (USHORT)(i+1);
        }
        pNicMap->ppNics[usThreshold] = NULL;
    }

    // Else decrement them
    else {
        // If there is a nic there, delete it.  This should never happen!
        if (pNicMap->ppNics[usThreshold])
            nmDelNic(pNicMap, pNicMap->ppNics[usThreshold]->pNicInfo);

        // Renumber
        for (i = usThreshold; i < pNicMap->dwMaxNicId; i++) {
            if (pNicMap->ppNics[i+1])
                pNicMap->usVirtMap[pNicMap->ppNics[i+1]->usVirtualId] = (USHORT)i;
            pNicMap->ppNics[i] = pNicMap->ppNics[i+1];
        }
        if (pNicMap->ppNics[i])
            pNicMap->ppNics[i] = NULL;
    }
    
    return NO_ERROR;
}

// Returns whether the nic map is empty
BOOL nmIsEmpty (NICMAP * pNicMap) {
    return pNicMap->dwNicCount == 0;
}


// ========================================
// Implementation of the api used by adptif
// ========================================

DWORD NicMapInitialize() {
    return nmInitialize(&GlobalNicIdMap);
}

DWORD NicMapCleanup() {
    return nmCleanup(&GlobalNicIdMap);
}

USHORT NicMapGetVirtualNicId(USHORT usPhysId) {
    return nmGetVirtualId(&GlobalNicIdMap, usPhysId);
}

USHORT NicMapGetPhysicalNicId(USHORT usVirtId) {
    return nmGetPhysicalId(&GlobalNicIdMap, usVirtId);
}

DWORD NicMapGetMaxNicId() {
    return nmGetMaxNicId(&GlobalNicIdMap);
}

DWORD NicMapGetNicCount() {
    return nmGetNicCount(&GlobalNicIdMap);
}

DWORD NicMapAdd (IPX_NIC_INFO * pNic) {
    return nmAddNic(&GlobalNicIdMap, pNic);
}

DWORD NicMapDel (IPX_NIC_INFO * pNic) {
    return nmDelNic(&GlobalNicIdMap, pNic);
}

DWORD NicMapReconfigure (IPX_NIC_INFO * pNic) {
    return nmReconfigure(&GlobalNicIdMap, pNic);
}

DWORD NicMapRenumber(DWORD dwOpCode, USHORT usThreshold) {
    return nmRenumber (&GlobalNicIdMap, usThreshold, dwOpCode);
}

IPX_NIC_INFO * NicMapGetNicInfo (USHORT usNicId) {
    return nmGetNicInfo (&GlobalNicIdMap, usNicId);
}    

BOOL NicMapIsEmpty () {
    return nmIsEmpty (&GlobalNicIdMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\pingsvc.h ===
#ifndef _PINGSVC_
#define _PINGSVC_


#define DBG_PING_ERRORS			0x00010000
#define DBG_PING_REQUESTS		0x00020000
#define DBG_PING_RESPONSES		0x00040000
#define DBG_PING_CONTROL        0x00080000

#include <packon.h>
// Extended IPX address structures described (but not defined) in wsnwlink.h
// For outgoing packets
typedef struct _SOCKADDR_IPX_EXT_SEND {
		SOCKADDR_IPX		std;
		UCHAR				pkttype;	// IPX packet type
		} SOCKADDR_IPX_EXT_SEND, *PSOCKADDR_IPX_EXT_SEND;
// For incoming packets
typedef struct _SOCKADDR_IPX_EXT_RECV {
		SOCKADDR_IPX		std;
		UCHAR				pkttype;	// IPX packet type
		UCHAR				who;		// Who sent it? 1 - broadcast, 2 - local
		} SOCKADDR_IPX_EXT_RECV, *PSOCKADDR_IPX_EXT_RECV;

#define IPX_PING_SOCKET 0x9086
typedef struct _IPX_PING_HEADER {
		UCHAR				signature[4];
		UCHAR				version;
		UCHAR				type;
#define PING_PACKET_TYPE_REQUEST	0
#define PING_PACKET_TYPE_RESPONSE	1
		UCHAR				pingid[2];
		UCHAR				result;
		UCHAR				reserved;
} IPX_PING_HEADER, *PIPX_PING_HEADER;
#include <packoff.h>

typedef struct _PING_DATA_BLOCK {
	WSAOVERLAPPED				ovlp;
	union {
		SOCKADDR_IPX_EXT_RECV	raddr;
		SOCKADDR_IPX_EXT_SEND	saddr;
	};
	IPX_PING_HEADER				pinghdr;
	CHAR						pingdata[1];
} PING_DATA_BLOCK, *PPING_DATA_BLOCK;

DWORD
StartPingSvc (
	VOID
	);

VOID
StopPingSvc (
	VOID
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\pnp.h ===
/*
    File    PnP.h     

    Declarations required to make the interface between the IPX stack and the IPX
    user-mode router components software PnP enabled.

    This file will plug into the NT 4.0 version adptif and provide the
    following PnP capabilities:

        1. Notify IPX router when new net cards are added (via PCMIA, bindings, etc.)
        2. Notify IPX router when the internal network number changes.
        3. Notify IPX router when changes to existing net cards occur:
            - Changes to network number associated with a given adapter
            - Changes to the frame type of a given adapter
  

    Strategy for notifying IPX router components of adapter changes
    ===============================================================
    1. In NT 4.0, the stack would complete the MIPX_GETNEWNICINFO IOCTL whenever 
       a wan link went up or down, whenever certain lan configuration changed,
       and in some other instances.  For PnP, we will modify the IPX stack to 
       complete this IOCTL whenever the internal net number changes and
       whenever an adapter-related PnP event occurs. 

    2. As part of processing the adapter configuration changes returned from the 
	   completion of the MIPX_GETNEWNICINFO IOCTL, adptif should also send the
       MIPX_CONFIG ioctl to get the internal network number and verify
       that it hasn't changed.  If it has changed, all ipx router components
       should be notified.

    3. Each router component (rtrmgr, rip, sap) is a client to adptif.dll and will 
       will therefore be notified about each adapter configuration change.  These
       components will have to be modified to deal with these changes individually.
       For example, sap will have to update its service table to reflect new network
       numbers and broadcast these changes to the network.  The router manager will
       have to instruct the fowarder to update its route table, etc.


    Paul Mayfield, 11/5/97.
*/


#ifndef __adptif_pnp_h
#define __adptif_pnp_h

// Queries the ipx stack for the current ipx internal net number
DWORD PnpGetCurrentInternalNetNum(LPDWORD lpdwNetNum);

// Notifies all clients to adptif (rtrmgr, sap, rip) that the internal
// network number has changed.
DWORD PnpHandleInternalNetNumChange(DWORD dwNewNetNum);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\nictable.h ===
/*
    File    NicTable.h

    Defines a nic-renaming scheme that allows adaptif to 
    advertise whatever nic id it chooses to its clients while
    maintaining the list of actual nic id's internally.

    This functionality was needed in order to Pnp enable the 
    ipx router.  When an adapter is deleted, the stack renumbers
    the nicid's so that it maintains a contiguous block of ids
    internally.  Rather that cause the clients to adptif to 
    match the stack's renumbering schemes, we handle this
    transparently in adptif.

    Author:     Paul Mayfield, 12/11/97
*/


#ifndef __adptif_nictable_h
#define __adptif_nictable_h

#define NIC_MAP_INVALID_NICID 0xffff

// Definitions to make this easy on adptif
DWORD NicMapInitialize();

DWORD NicMapCleanup();

USHORT NicMapGetVirtualNicId(USHORT usPhysId); 

USHORT NicMapGetPhysicalNicId(USHORT usVirtId); 

DWORD NicMapGetMaxNicId();

IPX_NIC_INFO * NicMapGetNicInfo (USHORT usNicId);

DWORD NicMapGetNicCount(); 

DWORD NicMapAdd(IPX_NIC_INFO * pNic);

DWORD NicMapDel(IPX_NIC_INFO * pNic); 

DWORD NicMapReconfigure(IPX_NIC_INFO * pNic);

DWORD NicMapRenumber(DWORD dwOpCode, USHORT usThreshold);

BOOL NicMapIsEmpty ();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\pingsvc.c ===
#include "ipxdefs.h"

SERVICE_STATUS_HANDLE   ServiceStatusHandle;
SERVICE_STATUS          ServiceStatus;
SOCKET                  PingSocket;
UINT                    PacketSize;
DWORD                   PingTraceId;
volatile LONG           RequestCount;

const union {
    CHAR    ch[4];
    LONG    l;
} ping_signature = {"Ping"};
#define IPX_PING_SIGNATURE ping_signature.l

VOID CALLBACK
ProcessPingRequest (
    IN DWORD            dwError,
    IN DWORD            cbTransferred,
    IN LPWSAOVERLAPPED  lpOverlapped
    );


DWORD
PostReceiveRequest (
    PVOID           context
    );

DWORD
StartPingSvc (
    VOID
    ) {
    BOOL            flag;
    SOCKADDR_IPX    addr;
    DWORD           status;
    int             sz;
    WORD            wVersionRequested;
    WSADATA         wsaData;
    int             res;


    wVersionRequested = MAKEWORD( 2, 0 );
    PingTraceId = TraceRegister (TEXT ("IPXPing"));

    res = WSAStartup( wVersionRequested, &wsaData );
    if ((res==NO_ERROR)
            && (LOBYTE(wsaData.wVersion)==2)
            && (HIBYTE(wsaData.wVersion)==0)) {
        PingSocket = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
        if (PingSocket!=INVALID_SOCKET) {
                // Tell WS IPX to use extended addresses
            flag = TRUE;
            if (setsockopt (PingSocket,
                            NSPROTO_IPX,
                            IPX_EXTENDED_ADDRESS,
                            (PCHAR)&flag,
                            sizeof (BOOL))==0) {
                // Bind to default address
                memset (&addr, 0, sizeof (addr));
                addr.sa_family = AF_IPX;
                addr.sa_socket = htons (IPX_PING_SOCKET);
                if (bind (PingSocket,
                            (PSOCKADDR)&addr,
                            sizeof (addr))==0) {
                    if (getsockopt (PingSocket,
                            SOL_SOCKET,
                            SO_MAX_MSG_SIZE,
                            (PCHAR)&PacketSize,
                            &sz)==0) {
                        status = NO_ERROR;
                        if (! SetIoCompletionProc ((HANDLE)PingSocket,
                                                    ProcessPingRequest))
                        {
                            status = GetLastError();
                        }
                        if (status==NO_ERROR) {
                            RequestCount = 0;
                            return NO_ERROR;
                        }
                        else {
                            TracePrintfEx (PingTraceId,
                                DBG_PING_ERRORS|TRACE_USE_MASK,
                                TEXT ("Failed to set IO completion proc, err:%ld.\n"),
                                status);
                        }
                    }
                    else {
                        status = WSAGetLastError ();
                        TracePrintfEx (PingTraceId,
                            DBG_PING_ERRORS|TRACE_USE_MASK,
                            TEXT ("Failed to get SO_MAX_MSG_SIZE, err:%ld.\n"),
                            status);
                    }
                }
                else {
                    status = WSAGetLastError ();
                    TracePrintfEx (PingTraceId,
                        DBG_PING_ERRORS|TRACE_USE_MASK,
                        TEXT ("Failed to bind to IPXPING socket (%.4x), err:%ld.\n"),
                        IPX_PING_SOCKET, status);
                }
            }
            else {
                status = WSAGetLastError ();
                TracePrintfEx (PingTraceId,
                    DBG_PING_ERRORS|TRACE_USE_MASK,
                    TEXT ("Failed to set IPX_EXTENDED_ADDRESS option, err:%ld.\n"),
                    status);
            }
        }
        else {
            status = WSAGetLastError ();
            TracePrintfEx (PingTraceId,
                DBG_PING_ERRORS|TRACE_USE_MASK,
                TEXT ("Failed to create socket, err:%ld.\n"),
                status);
        }

    }
    else {
        TracePrintfEx (PingTraceId,
                    DBG_PING_ERRORS|TRACE_USE_MASK,
                    TEXT ("IPX Ping service implementation is"
                    " incompatible with version of sockets installed"
                    " on this system.\n"));
        status = WSAVERNOTSUPPORTED;
    }

    PingSocket = INVALID_SOCKET;
    WSACleanup ();
    TracePrintfEx (PingTraceId,
        DBG_PING_ERRORS|TRACE_USE_MASK,
        TEXT ("IPX Ping service was not started!\n"));
    TraceDeregister (PingTraceId);
    return status;
}

VOID
ServiceHandler (
    DWORD   fdwControl
    ) {
    switch (fdwControl) {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

            TracePrintfEx (PingTraceId,
                        DBG_PING_CONTROL|TRACE_USE_MASK,
                        TEXT ("Stop or shutdown command received.\n"));

            StopPingSvc ();
            break;
            
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
            ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |

            TracePrintfEx (PingTraceId,
                        DBG_PING_CONTROL|TRACE_USE_MASK,
                        TEXT ("Interrogate command received.\n"));
            break;

        default:
            TracePrintfEx (PingTraceId,
                        DBG_PING_CONTROL|TRACE_USE_MASK,
                        TEXT ("Unknown or unsupported command received (%d).\n"),
                        fdwControl);
            break;

    }
    SetServiceStatus (ServiceStatusHandle, &ServiceStatus);
}

VOID
ServiceMain (
    DWORD                   argc,
    LPTSTR                  argv[]
    ) {
    HANDLE  hEvent;

    ServiceStatusHandle = RegisterServiceCtrlHandler (
                            TEXT("ipxping"), ServiceHandler);
    if (ServiceStatusHandle)
    {
        ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
        ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

        ServiceStatus.dwWin32ExitCode = StartPingSvc ();
        if (ServiceStatus.dwWin32ExitCode==NO_ERROR) {
            hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
            if (hEvent!=NULL) {

                ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                                 | SERVICE_ACCEPT_SHUTDOWN;
                SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

                while (PingSocket!=INVALID_SOCKET) {
                    if (PostReceiveRequest (hEvent)==NO_ERROR)
                        WaitForSingleObject (hEvent, INFINITE);
                    else
                        Sleep (3000);
                }
                while (RequestCount>0)
                    SleepEx (1000, TRUE);
            }
            else {
                ServiceStatus.dwWin32ExitCode = GetLastError ();
                TracePrintfEx (PingTraceId,
                        DBG_PING_ERRORS|TRACE_USE_MASK,
                        TEXT ("Failed to create receive event, err: %ld.\n"),
                        ServiceStatus.dwWin32ExitCode);
            }
        }
        ServiceStatus.dwCurrentState     = SERVICE_STOPPED;
        ServiceStatus.dwControlsAccepted = 0;
        SetServiceStatus (ServiceStatusHandle, &ServiceStatus);
    }
}

DWORD
PostReceiveRequest (
    HANDLE  hEvent
    ) {
    PPING_DATA_BLOCK    block;
    int                 res;
    DWORD               status;
    block = (PPING_DATA_BLOCK)GlobalAlloc (GPTR,
                FIELD_OFFSET (PING_DATA_BLOCK, pinghdr)
                +PacketSize);
    if (block!=NULL) {
        WSABUF              bufArray[1];
        DWORD               cbBytes, sz;
        DWORD               flags;

        block->ovlp.hEvent = hEvent;
        bufArray[0].buf = (PCHAR)(&block->pinghdr);
        bufArray[0].len = PacketSize;
        flags = 0;
        sz = sizeof (block->raddr);

        res = WSARecvFrom (PingSocket,  
                            bufArray,   
                            sizeof (bufArray)/sizeof (bufArray[0]),
                            &cbBytes,
                            &flags,
                            (PSOCKADDR)&block->raddr,
                            &sz,
                            &block->ovlp,
                            NULL
                            );
        if ((res==0) || (WSAGetLastError ()==WSA_IO_PENDING)) {
            InterlockedIncrement ((PLONG)&RequestCount);
            TracePrintfEx (PingTraceId,
                DBG_PING_REQUESTS|TRACE_USE_MASK,
                TEXT ("Posted ping request (%08lx).\n"),
                block);
            return NO_ERROR;
        }
        else {
            status = WSAGetLastError ();
            TracePrintfEx (PingTraceId,
                DBG_PING_ERRORS|TRACE_USE_MASK,
                TEXT ("Failed to post ping request, err: %ld.\n"),
                status);
        }

        GlobalFree (block);
    }
    else {
        status = GetLastError ();
        TracePrintfEx (PingTraceId,
                DBG_PING_ERRORS|TRACE_USE_MASK,
                TEXT ("Failed to allocate receive buffer, err: %ld.\n"),
                status);
    }
    return status;
}

VOID CALLBACK
ProcessPingRequest (
    IN DWORD            error,
    IN DWORD            cbBytes,
    IN LPWSAOVERLAPPED  ovlp
    ) {
    PPING_DATA_BLOCK    block = CONTAINING_RECORD (ovlp, PING_DATA_BLOCK, ovlp);
    USHORT              pktlen;
    int                 res;

    TracePrintfEx (PingTraceId,
        DBG_PING_REQUESTS|TRACE_USE_MASK,
        TEXT ("Processing ping request (%08lx), size: %ld, err: %ld.\n"),
        block, cbBytes, error);


    if (error!=ERROR_OPERATION_ABORTED) {

        if ((error==NO_ERROR)
                && (cbBytes>=sizeof (block->pinghdr))
                && (block->raddr.pkttype==0)
                && ((*((UNALIGNED LONG *)&block->pinghdr.signature))==IPX_PING_SIGNATURE)
                && (block->pinghdr.type==PING_PACKET_TYPE_REQUEST)
                ) {

            block->pinghdr.type = PING_PACKET_TYPE_RESPONSE;
            block->pinghdr.result =
                    (cbBytes>sizeof (block->pinghdr)) ? 1 : 0;
            block->pinghdr.version = 1;

            res = sendto (PingSocket,
                            (PCHAR)&block->pinghdr,
                            cbBytes,
                            0,
                            (PSOCKADDR)&block->saddr,
                            sizeof (block->saddr)
                            );
            if (res!=SOCKET_ERROR) {
                TracePrintfEx (PingTraceId,
                    DBG_PING_RESPONSES|TRACE_USE_MASK,
                    TEXT ("Sent response (%08lx) to"
                            " %.2x%.2x%.2x%.2x,%.2x%.2x%.2x%.2x%.2x%.2x,%.4x"
                            " with %d bytes of data.\n"),
                    block,
                    block->saddr.std.sa_netnum[0], block->saddr.std.sa_netnum[1],
                        block->saddr.std.sa_netnum[2], block->saddr.std.sa_netnum[3],
                    block->saddr.std.sa_nodenum[0], block->saddr.std.sa_netnum[1],
                        block->saddr.std.sa_netnum[2], block->saddr.std.sa_netnum[3],
                        block->saddr.std.sa_netnum[4], block->saddr.std.sa_netnum[5],
                    block->saddr.std.sa_socket,
                    cbBytes-sizeof (block->pinghdr));
            }
            else
                TracePrintfEx (PingTraceId,
                    DBG_PING_ERRORS|TRACE_USE_MASK,
                    TEXT ("Failed to send response, err: %ld.\n"),
                                    WSAGetLastError ());
        }
        else {
            TracePrintfEx (PingTraceId,
                DBG_PING_RESPONSES|TRACE_USE_MASK,
                TEXT ("Invalid request packet received from"
                        " %.2x%.2x%.2x%.2x,%.2x%.2x%.2x%.2x%.2x%.2x,%.4x"
                        " (pktsize: %d, pkttype: %.2x, sig:%4.4s, type: %d, ver: %d).\n"),
                block->raddr.std.sa_netnum[0], block->raddr.std.sa_netnum[1],
                    block->raddr.std.sa_netnum[2], block->raddr.std.sa_netnum[3],
                block->raddr.std.sa_nodenum[0], block->raddr.std.sa_netnum[1],
                    block->raddr.std.sa_netnum[2], block->raddr.std.sa_netnum[3],
                    block->raddr.std.sa_netnum[4], block->raddr.std.sa_netnum[5],
                block->raddr.std.sa_socket,
                cbBytes, block->raddr.pkttype,
                block->pinghdr.signature, block->pinghdr.type, block->pinghdr.version);
        }
    }

    GlobalFree (block);
    InterlockedDecrement ((PLONG)&RequestCount);
}

VOID
StopPingSvc (
    VOID
    ) {
    if (PingSocket!=INVALID_SOCKET) {
        SOCKET  s = PingSocket;
        PingSocket = INVALID_SOCKET;
        closesocket (s);
        WSACleanup ();
        TraceDeregister (PingTraceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\pnp.c ===
/*
    File    PnP.c      

    Implementation of pnp enhancements of the interface between the IPX stack and
    the IPX user-mode router components software PnP enabled.


    Paul Mayfield, 11/5/97.
*/


#include "ipxdefs.h"
#include "pnp.h"

// Globals from other files
extern WCHAR			ISN_IPX_NAME[];
extern ULONG			InternalNetworkNumber;
extern UCHAR			INTERNAL_NODE_ADDRESS[6];
extern IO_STATUS_BLOCK	IoctlStatus;			
extern HANDLE			IpxDriverHandle;		
extern LONG				AdapterChangeApcPending;
extern LIST_ENTRY		PortListHead;		
extern PCONFIG_PORT		IpxWanPort;			
extern CRITICAL_SECTION	ConfigInfoLock;		
extern ULONG			NumAdapters;		

// [pmay] The global trace id.
extern DWORD g_dwTraceId;
DWORD IpxPostIntNetNumMessage(PCONFIG_PORT pPort, DWORD dwNewNetNum);

// Queries the ipx stack for the current ipx internal net number.  This code was
// stolen from OpenAdapterConfigPort.
DWORD PnpGetCurrentInternalNetNum(LPDWORD lpdwNetNum) {
	PISN_ACTION_GET_DETAILS	details;
	PNWLINK_ACTION			action;
	CHAR					IoctlBuffer[sizeof (NWLINK_ACTION)
										+sizeof (ISN_ACTION_GET_DETAILS)];
	NTSTATUS status;
	IO_STATUS_BLOCK			IoStatus;

    if (IpxDriverHandle == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    //TracePrintf(g_dwTraceId, "Entered PnpGetCurrentInternalNetNum\n");

    // Prepare to send an ioctl to the stack to get the internal
    // net information along with the global adapter information
	action = (PNWLINK_ACTION)IoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof(action->Option) + sizeof(ISN_ACTION_GET_DETAILS);
    action->Option = MIPX_CONFIG;
	details = (PISN_ACTION_GET_DETAILS)action->Data;

    // Nic id 0 will return internal net information and
    // total number of adapters
	details->NicId = 0;	
						
	// Send the ioctl
	status = NtDeviceIoControlFile(
						IpxDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						action,
						sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_DETAILS));

    // Wait for the ioctl to complete
	if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
	}

    // Output the new net number
    //TracePrintf(g_dwTraceId, "PnpGetCurrentInternalNetNum: Stack has returned internal net num: %x\n", 
    //                              details->NetworkNumber);

    // If the stack reports all the requested information without error,
    // update global variables with the information retrieved.
	if (NT_SUCCESS (status)) {
		NumAdapters = details->NicId;
		*lpdwNetNum = details->NetworkNumber;
        //TracePrintf(g_dwTraceId, "PnpGetCurrentInternalNetNum: Returning success\n");
		return NO_ERROR;
	}

    return ERROR_CAN_NOT_COMPLETE;
}

// Notifies all clients to adptif (rtrmgr, sap, rip) that the internal
// network number has changed.
DWORD PnpHandleInternalNetNumChange(DWORD dwNewNetNum) {
    PCONFIG_PORT pPort;
	PLIST_ENTRY	cur;

    TracePrintf(g_dwTraceId, "PnpHandleInternalNetNumChange: Entered with number: %x", dwNewNetNum);

    // Signal each client (as in rtrmgr, sap, rip) to update
    // the internal network number.
	for (cur=PortListHead.Flink; cur != &PortListHead; cur = cur->Flink) {
        pPort = CONTAINING_RECORD (cur,	CONFIG_PORT, link);
        IpxPostIntNetNumMessage(pPort, dwNewNetNum);
	}

	TracePrintf(g_dwTraceId, "\n");
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\autonet\autonet.c ===
/*
    File    autonet.c

    Contains routines that allow the ipx router to automatically select an
    internal network number.

    Paul Mayfield, 11/21/97.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <raserror.h>
#include <dim.h>
#include <rtm.h>
#include <ipxrtprt.h>
#include <rmrtm.h>
#include <mprlog.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <adapter.h>
#include <fwif.h>
#include <rtutils.h>
#include "ipxanet.h"
#include "utils.h"

// Sends debug output to a debugger terminal
DWORD OutputDebugger (LPSTR pszError, ...) {
#if DBG
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszError);
    vsprintf(szTemp, pszError, arglist);
    va_end(arglist);

    sprintf(szBuffer, "IPXAUTO: %s", szTemp);


    OutputDebugStringA(szBuffer);
#endif
    return NO_ERROR;
}


DWORD dwTraceId = 0;
ULONG ulRandSeed = 0;

DWORD InitTrace() {
    if (dwTraceId)
        return NO_ERROR;

    dwTraceId = TraceRegisterExA ("ipxautonet", 0);
    return NO_ERROR;
}


DWORD SetIpxInternalNetNumber(DWORD dwNetNum);

// New helper functions from adptif
DWORD FwIsStarted (OUT PBOOL pbIsStarted);
DWORD IpxDoesRouteExist (IN PUCHAR puNetwork, OUT PBOOL pbRouteFound);
DWORD IpxGetAdapterConfig(OUT LPDWORD lpdwInternalNetNum,
                          OUT LPDWORD lpdwAdapterCount);

// Outputs an error to the tracing facility
VOID AutoTraceError(DWORD dwErr) {
    char buf[1024];
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,NULL,dwErr,(DWORD)0,buf,1024,NULL);
    TracePrintfA (dwTraceId, buf);
}

// Seeds the random number generator
DWORD SeedRandomGenerator() {
    DWORD dwTick;

    // Generate a unique number to seed the random number generator with
    dwTick = GetTickCount();
    ulRandSeed = dwTick ^ (dwTick << ((GetCurrentProcessId() % 16)));

    return NO_ERROR;
}

// Returns a random number between 11 and 2^32
// Currently, the rand() function generates a random number between 0 and 0x7fff.
// What we do to generate the random number is generate 8 random numbers each 4 bits
// wide and then paste them together.
DWORD RandomNetNumber() {
    DWORD dw[4], dwRand = 0, i;

    // Generate the numbers
    dw[0] = RtlRandom(&ulRandSeed) & 0xff;
    dw[1] = RtlRandom(&ulRandSeed) & 0xff;
    dw[2] = RtlRandom(&ulRandSeed) & 0xff;
    dw[3] = RtlRandom(&ulRandSeed) & 0xff;

    // Paste the numbers together
    for (i = 0; i < 4; i++)
        dwRand |= dw[i] << (i*8);

    // If by some small chance, an illegal value was choosen,
    // correct it.
    if (dwRand < 11)
        dwRand += 11;

    return dwRand;
}

//
//  Function: QueryStackForRouteExistance
//
//  Asks the stack to check it's route table for the existance of the given network.
//  If no route exists in its table, the stack will send out a rip broadcast to be
//  doubly sure that the network does not exist.
//
//  This function blocks until it completes.
//
//  Params:
//      dwNetwork        host-ordered network number to query
//      pbRouteExists    set to TRUE if a route to the given network exists. false,
//                       if the rip broadcast that the stack sends times out.
//
DWORD QueryStackForRouteExistance(IN DWORD dwNetwork, OUT PBOOL pbRouteExists) {
    UCHAR puNetwork[4];
    DWORD dwErr;

    // Prepare the network number
    PUTULONG2LONG(puNetwork, dwNetwork);

    // Initialize
    *pbRouteExists = FALSE;

    if ((dwErr = IpxDoesRouteExist (puNetwork, pbRouteExists)) != NO_ERROR)
        return dwErr;

    return NO_ERROR;
}

//
//  Function: QueryRtmForRouteExistance
//
//  Discovers whether a route to a given network exists in rtm.
//
//  This function blocks until it completes.
//
//  Params:
//      dwNetwork        host-ordered network number to query
//      pbRouteExists    set to TRUE if a route to the route exists -- false, otherwise
//
DWORD QueryRtmForRouteExistance(IN DWORD dwNetwork, OUT PBOOL pbRouteExists) {
    *pbRouteExists = RtmIsRoute (RTM_PROTOCOL_FAMILY_IPX, &dwNetwork, NULL);

    return NO_ERROR;
}

//
//  Function: PnpAutoSelectInternalNetNumber
//
//  Selects a new internal network number for this router and plumbs that network
//  number into the stack and the router.
//
//  Depending on whether the forwarder and ipxrip are enabled, it will validate the
//  newly selected net number against the stack or rtm.
//
//  Params:
//      dwNetwork        host-ordered network number to query
//      pbRouteExists    set to TRUE if a route to the route exists -- false, otherwise
//
DWORD PnpAutoSelectInternalNetNumber(DWORD dwGivenTraceId) {
    DWORD i, j, dwErr, dwNewNet;
    BOOL bNetworkFound = FALSE, bFwStarted;

    TracePrintfA (dwTraceId, "PnpAutoSelectInternalNetNumber: Entered");

    // Find out if the forwarder and ipx rip have been started
    if ((dwErr = FwIsStarted(&bFwStarted)) != NO_ERROR)
        return dwErr;
    TracePrintfA (dwTraceId, "PnpAutoSelectInternalNetNumber: Forwarder %s started",
                      (bFwStarted) ? "has already been" : "has not been");

    __try {
        // Initialize the random number generator
        if ((dwErr = SeedRandomGenerator()) != NO_ERROR)
            return dwErr;

        // Discover a unique network number
        do {
            // Randomly select a new net number
            dwNewNet = RandomNetNumber();

            // Find out if the given network exists
            if (bFwStarted) {
                if ((dwErr = QueryRtmForRouteExistance (dwNewNet, &bNetworkFound)) != NO_ERROR)
                    return dwErr;
            }
            else {
                if ((dwErr = QueryStackForRouteExistance (dwNewNet, &bNetworkFound)) != NO_ERROR)
                    return dwErr;
            }

            // Send some debug output
            TracePrintfA (dwTraceId, "PnpAutoSelectInternalNetNumber: 0x%08x %s", dwNewNet, (bNetworkFound) ? "already exists." : "has been selected.");
        } while (bNetworkFound);

        // Set the internal network number to the discovered unique net number.  This call
        // uses inetcfg to programmatically set the net network number.
        if ((dwErr = SetIpxInternalNetNumber(dwNewNet)) != NO_ERROR)
            return dwErr;
    }
    __finally {
        if (dwErr != NO_ERROR)
            AutoTraceError(dwErr);
    }

    return NO_ERROR;
}

BOOL NetNumIsValid (DWORD dwNum) {
    return ((dwNum != 0) && (dwNum != 0xffffffff));
}

//
//  Function: AutoValidateInternalNetNum
//
//  Queries the stack to learn the internal network number and then
//  returns whether this number is valid for running an ipx router.
//
//  Params:
//      pbIsValid    set to TRUE if internal net num is valid -- false, otherwise
//
DWORD AutoValidateInternalNetNum(OUT PBOOL pbIsValid, IN DWORD dwGlobalTraceId) {
    DWORD dwErr, dwIntNetNum, dwAdapterCount;

    InitTrace();
    TracePrintfA (dwTraceId, "AutoValidateInternalNetNum: Entered");

    // Get the current internal network number
    if ((dwErr = IpxGetAdapterConfig(&dwIntNetNum, &dwAdapterCount)) != NO_ERROR) {
        TracePrintfA (dwTraceId, "AutoValidateInternalNetNum: couldn't get adapter config %x", dwErr);
        AutoTraceError(dwErr);
        return dwErr;
    }

    // Check the validity of the internal net number.  If it's a valid
    // number, don't mess with it.
    *pbIsValid = !!(NetNumIsValid(dwIntNetNum));

    TracePrintfA (dwTraceId, "AutoValidateInternalNetNum: Net Number 0x%x is %s", dwIntNetNum,
                      (*pbIsValid) ? "valid" : "not valid");

    return NO_ERROR;
}

//
//  Function: AutoWaitForValidNetNum
//
//  Puts the calling thread to sleep until a valid internal network number
//  has been plumbed into the system.
//
//  Params:
//      dwTimeout     timeout in seconds
//      pbIsValid     if provided, returns whether number is valid
//
DWORD AutoWaitForValidIntNetNum (IN DWORD dwTimeout,
                                 IN OUT OPTIONAL PBOOL pbIsValid) {
    DWORD dwErr, dwNum, dwCount, dwGran = 250;

    // Initialize optional params
    if (pbIsValid)
        *pbIsValid = TRUE;

    // Convert the timeout to milliseconds
    dwTimeout *= 1000;

    while (dwTimeout > dwGran) {
        // Get the current internal network number
        if ((dwErr = IpxGetAdapterConfig(&dwNum, &dwCount)) != NO_ERROR)
            return dwErr;

        if (NetNumIsValid (dwNum)) {
            if (pbIsValid)
                *pbIsValid = TRUE;
            break;
        }

        Sleep (dwGran);
        dwTimeout -= dwGran;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\adptif\watcher.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ipx\adptif\watcher.c

Abstract:

	Debug mode code that display adapter information reported
	by the stack. It also provides UI mechanism to manually
	"disable" (make invisible to clients) and "reenable" adapters
Author:

	Vadim Eydelman

Revision History:

--*/
	// State information maintained for UI dialog
typedef struct _ADAPTER_STATE {
		USHORT			AdapterId;	// Nic ID
		BOOLEAN			Status;		// Status as supplied by the stack
		BOOLEAN			Enabled;	// User settable status
		} ADAPTER_STATE, *PADAPTER_STATE;

DWORD WINAPI
WatcherThread (
	LPVOID param
	);

BOOL CALLBACK
WatcherDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   );

VOID
NotifyClients (
	INT			i,
	BOOLEAN		Status
	);
VOID
UpdateAdapterList (
	HWND	AdapterLB
	);

HWND			WatcherDlg=NULL;			// UI dialog handle
PADAPTER_STATE	AdapterArray=NULL;			// Current adapter info
ULONG			AdapterArraySize=0;			// Number of adapters in array
PVOID			AdapterDataBuffer=NULL;		// Buffer to receive nic info from driver
HANDLE			DebugWatchEvent=NULL;		// Event to be nofified when nic info changes
DWORD			DbgFlags=0;					// Debug flags
#define DEBUG_SHOW_DIALOG	0x00000001		// Display UI dialog if set
HINSTANCE		HDLLInstance;				// Dll instance handle
HANDLE			WatcherThreadHdl=NULL;		// UI thread handle
DWORD			WatcherThreadID=0;			// Its id


/*++
*******************************************************************
        I n i t i a l i z e W a t c h e r

Routine Description:
		Initializes UI resorces and starts watcher thread

Arguments:

      	hinstDLL,		handle of DLL module 

Return Value:
		None
Remarks:
*******************************************************************
--*/
VOID
InitializeWatcher (
	HINSTANCE	hinstDLL
	) {
	HDLLInstance = hinstDLL;
	InitCommonControls ();
	DebugWatchEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
	ASSERT (DebugWatchEvent!=NULL);
	EnterCriticalSection (&ConfigInfoLock);
	if (IpxDriverHandle==NULL) {
		DWORD status = OpenAdapterConfigPort ();
		ASSERTMSG ("Could not open adapter config port", status==NO_ERROR);
		if (!InRouter ())
			PostAdapterConfigRequest (DebugWatchEvent);
		}
	LeaveCriticalSection (&ConfigInfoLock);

	WatcherThreadHdl = CreateThread (NULL,	// default security
				0,				// default stack
				&WatcherThread,
				(LPVOID)NULL,			
				0,				// default flags
				&WatcherThreadID);
	ASSERTMSG ("Could not create watcher thread ",
								 WatcherThreadHdl!=NULL);
	}

/*++
*******************************************************************
        C l e a n u p W a t c h e r

Routine Description:

		Disposes of resources allocated for UI

Arguments:
		None

Return Value:
		None
Remarks:
*******************************************************************
--*/
VOID
CleanupWatcher (
	void 
	) {
	PostThreadMessage (WatcherThreadID, WM_QUIT, 0, 0);
	WaitForSingleObject (WatcherThreadHdl, INFINITE);
	if (IpxDriverHandle!=NULL)
		CloseAdapterConfigPort ();
	CloseHandle (WatcherThreadHdl);
	CloseHandle (DebugWatchEvent);
	}

/*++
*******************************************************************
        W a t c h e r T h r e a d

Routine Description:

		Event loop for Watcher Dialog 

Arguments:

		param	- Not used

Return Value:

		None

*******************************************************************
--*/

DWORD WINAPI
WatcherThread (
	LPVOID param
	) {
	DWORD			status;
	HANDLE			WaitObjects[2];
#define RegChangeEvt (WaitObjects[0])
	HKEY			regHdl;
	DWORD			length, disposition, value;
	BOOL			Done=FALSE;

	RegChangeEvt = CreateEvent (NULL, FALSE, TRUE, NULL);
	ASSERT (RegChangeEvt!=NULL);

	WaitObjects[1] = DebugWatchEvent;

		// Create registry key that controls dialog display
	status = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
								InRouter()
									? TEXT ("System\\CurrentControlSet\\Services\\RemoteAccess\\Adptif")
									: TEXT ("System\\CurrentControlSet\\Services\\NwSapAgent\\Adptif"),
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_READ,
								NULL,
								&regHdl,
								&disposition
								);
	ASSERTMSG ("Can't create registry key. ", status==NO_ERROR);

	while (!Done) {
		status = MsgWaitForMultipleObjects (2, WaitObjects,
											FALSE, INFINITE, QS_ALLINPUT);
		if (status==(WAIT_OBJECT_0+2)) {
			MSG		msg;
			while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
				if (msg.message==WM_QUIT) {
					Done = TRUE;
					break;
					}
				else if (!IsWindow(WatcherDlg)
					|| !IsDialogMessage(WatcherDlg, &msg)) {
					TranslateMessage (&msg);
					DispatchMessage (&msg);
					}
				}
			}
		else if (status==WAIT_OBJECT_0) {
				// Registry change event signalled
			EnterCriticalSection (&ConfigInfoLock);
			length = sizeof (DWORD);
			status = RegQueryValueEx (regHdl, TEXT ("DbgFlags"), NULL, NULL,
											 (PUCHAR)&value, &length);
			if (status==NO_ERROR)
				DbgFlags = value;

			if (DbgFlags & DEBUG_SHOW_DIALOG) {
				if (!IsWindow(WatcherDlg)) {
					WatcherDlg = CreateDialog (HDLLInstance,
									MAKEINTRESOURCE (IDD_WATCHER),
									NULL,
									&WatcherDlgProc);

					ASSERT (WatcherDlg!=NULL);
					}
				}
			else {
				if (IsWindow (WatcherDlg)) {
					DestroyWindow (WatcherDlg);
					WatcherDlg = NULL;
					}
				}
					

			status = RegNotifyChangeKeyValue (regHdl,
									 FALSE,
									 REG_NOTIFY_CHANGE_LAST_SET,
									 RegChangeEvt,
									 TRUE);
			ASSERTMSG ("Can't start registry notifications. ",
													 status==NO_ERROR);
			LeaveCriticalSection (&ConfigInfoLock);
			}
		else if (status==WAIT_OBJECT_0+1) {
				// Adapter change IRP has completed
			EnterCriticalSection (&ConfigInfoLock);
			if (WatcherDlg!=NULL)	// Update dialog
				UpdateAdapterList (GetDlgItem (WatcherDlg, IDL_ADAPTERS));
			if (!InRouter ()) {		// Inform clients and repost IRP
				ProcessAdapterConfigInfo ();
				PostAdapterConfigRequest (DebugWatchEvent);
				}			// When in router, IRP is processed
							// by APC routine and new one is immediately
							// posted
			LeaveCriticalSection (&ConfigInfoLock);
			}			
		}


	if (IsWindow (WatcherDlg)) {
		DestroyWindow (WatcherDlg);
		WatcherDlg = NULL;
		}
	RegCloseKey (regHdl);
	CloseHandle (RegChangeEvt);
	return 0;
#undef RegChangeEvent
	}


/*++
*******************************************************************
        W a t c h e r D i a l o g P r o c

Routine Description:

		Window Proc for watcher dialog.
		Implements UI for adapter info changes

Arguments:

    	hDlg		- handle of dialog box
    	uMsg		- message
    	wParam		- first message parameter
    	lParam 		- second message parameter

Return Value:
		TRUE		if procedure processed tne message
		FALSE		if default procedure is to process the message

*******************************************************************
--*/
BOOL CALLBACK
WatcherDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   ) {
	UINT		i,aa;
	CHAR		buffer[60];		// Buffer to print adapter info to
	HWND		hLB;			// Adapter listbox window handle
	BOOL		res=FALSE;		// Return value
	DWORD		status;
	LV_COLUMN	lvc;
	HICON		hIcon;
    HIMAGELIST	hIml;
	RECT		rect;
	static RECT	lbPos;
	static LPTSTR Headers[]={TEXT(" Nic Name"), TEXT("NicId"), TEXT("ItfId"),
			TEXT("Network#"), TEXT("Local Node #"), TEXT("Remote Node#"),
			TEXT("Ln.Spd"), TEXT("MaxSz"), TEXT("Type"), TEXT("Medium"),
			TEXT("State"), NULL};

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
			hLB = GetDlgItem (hDlg, IDL_ADAPTERS);
			GetWindowRect (hLB, &lbPos);
			MapWindowPoints (HWND_DESKTOP, hDlg,
								(POINT *)&lbPos, 2);
			GetClientRect (hDlg, &rect);
			lbPos.bottom = rect.bottom - lbPos.bottom;
			lbPos.right = rect.right - lbPos.right;
			hIml = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
							GetSystemMetrics(SM_CYSMICON), TRUE, 2, 2);
			hIcon = LoadIcon(HDLLInstance,
								MAKEINTRESOURCE(ID_ICON_DOWN));
			ImageList_AddIcon(hIml, hIcon);
			DeleteObject(hIcon);
			hIcon = LoadIcon(HDLLInstance,
								MAKEINTRESOURCE(ID_ICON_UP));
			ImageList_AddIcon(hIml, hIcon);
			DeleteObject(hIcon);
			ListView_SetImageList(hLB, hIml, LVSIL_STATE);


 		   // Initialize the LV_COLUMN structure.
		    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
		    lvc.fmt = LVCFMT_LEFT;
			aa = ListView_GetStringWidth (hLB, TEXT("MM"));
			for (i=0; Headers[i]!=NULL; i++) {
				lvc.pszText = Headers[i];
				lvc.iSubItem = i;
				lvc.cx = ListView_GetStringWidth (hLB, lvc.pszText)+aa;
				status = ListView_InsertColumn(hLB, i, &lvc);
				ASSERTMSG ("Could not insert list column ", status!=-1);
				}
				
			EnterCriticalSection (&ConfigInfoLock);
			UpdateAdapterList (GetDlgItem (hDlg, IDL_ADAPTERS));
								// Disable all buttons (nothing selected)
			LeaveCriticalSection (&ConfigInfoLock);
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:	// Do not allow to close the Dialog Box
					MessageBeep (MB_ICONHAND);
					res = TRUE;
					break;
				}
			break;
		case WM_NOTIFY:
#define pnmv ((NM_LISTVIEW *)lParam)
			if ((pnmv->hdr.code==LVN_ITEMCHANGED)
					&& (pnmv->uChanged&LVIF_STATE)
					&& (pnmv->uNewState&LVIS_SELECTED)
					&& (pnmv->iItem>0)) {
				}
			else if (pnmv->hdr.code==NM_DBLCLK) {
				LV_HITTESTINFO	hit;
				status = GetMessagePos ();
				hit.pt.x = LOWORD(status);
				hit.pt.y = HIWORD(status);
				ScreenToClient (pnmv->hdr.hwndFrom, &hit.pt);
				ListView_HitTest(pnmv->hdr.hwndFrom, &hit);
				if ((hit.iItem>0)
						&& (hit.flags&LVHT_ONITEMSTATEICON)) {
					i = hit.iItem - 1;
					EnterCriticalSection (&ConfigInfoLock);
					if (!AdapterArray[i].Enabled) {
						AdapterArray[i].Enabled = TRUE;
						if ((AdapterArray[i].Status==NIC_CONFIGURED)
								||(AdapterArray[i].Status==NIC_LINE_UP))
							NotifyClients (i, NIC_LINE_UP);
						}
					else {
						AdapterArray[i].Enabled = FALSE;
						if ((AdapterArray[i].Status==NIC_CONFIGURED)
								||(AdapterArray[i].Status==NIC_LINE_UP))
							NotifyClients (i, NIC_LINE_DOWN);
						}
					ListView_SetItemState (pnmv->hdr.hwndFrom, hit.iItem,
								INDEXTOSTATEIMAGEMASK (
									AdapterArray[i].Enabled
										? (((AdapterArray[i].Status==NIC_CONFIGURED)
											|| (AdapterArray[i].Status==NIC_LINE_UP))
											? 2 : 1)
										: 0),
								LVIS_STATEIMAGEMASK);
					LeaveCriticalSection (&ConfigInfoLock);
					ListView_Update(pnmv->hdr.hwndFrom, hit.iItem);
					}
				}
			break;
#undef pnmw
		case WM_SIZE:
			hLB = GetDlgItem (hDlg, IDL_ADAPTERS);
			MoveWindow (hLB, lbPos.left, lbPos.top,
						LOWORD (lParam)-lbPos.right-lbPos.left,
						HIWORD (lParam)-lbPos.bottom-lbPos.top,
						TRUE);
			break;
		case WM_DESTROY:
			EnterCriticalSection (&ConfigInfoLock);
			if (AdapterDataBuffer!=NULL) {
				RtlFreeHeap (RtlProcessHeap (), 0, AdapterDataBuffer);
				AdapterDataBuffer = NULL;
				}
			if (AdapterArray!=NULL) {
				RtlFreeHeap (RtlProcessHeap (), 0, AdapterArray);
				AdapterArray = NULL;
				}
			LeaveCriticalSection (&ConfigInfoLock);
		break;
		}

	return res;
	}


/*++
*******************************************************************
		N o t i f y C l i e n t s

Routine Description:

		Notifies clients of adapter status changes made through UI
Arguments:
		i - index of the adapter that was modified
		Status - new state of the adapter

Return Value:
		None
*******************************************************************
--*/
VOID
NotifyClients (
	INT			i,
	BOOLEAN		Status
	) {
	PLIST_ENTRY		cur;
	PIPX_NIC_INFO 	NicPtr = 
			&((PIPX_NIC_INFO)
				((PIPX_NICS)
					((PNWLINK_ACTION)AdapterDataBuffer)
					->Data)
				->Data)[i];
	PADAPTER_MSG msg = (PADAPTER_MSG)RtlAllocateHeap (
							RtlProcessHeap (), 0,
								sizeof (ADAPTER_MSG));
	ASSERTMSG ("Could not allocate adapter message ",
												msg!=NULL);
	RtlCopyMemory (&msg->info, NicPtr, sizeof (IPX_NIC_INFO));
	msg->info.Status = Status;
	msg->refcnt = 0;
	cur = PortListHead.Flink;
	while (cur!=&PortListHead) {
		PCONFIG_PORT	config = CONTAINING_RECORD (cur,
					CONFIG_PORT, link);
		msg->refcnt += 1;;
		if (config->curmsg==NULL) {
			BOOL	res = SetEvent (config->event);
			ASSERTMSG ("Can't set client event ", res);
			config->curmsg = &msg->info;
			}
		cur = cur->Flink;
		}
	InsertTailList (&MessageListHead, &msg->link);
	}

/*++
*******************************************************************
		U p d a t e A d a p t e r L i s t

Routine Description:
		Updates adapter info displayed in the list
Arguments:
		AdapterLB - list view control window handle
Return Value:
		None
*******************************************************************
--*/
VOID
UpdateAdapterList (
	HWND	AdapterLB
	) {
	PNWLINK_ACTION		action;
	PIPX_NICS			request;
	IO_STATUS_BLOCK		IoStatus;
	PIPX_NIC_INFO		NicPtr;
	PISN_ACTION_GET_DETAILS	details;
	CHAR				IoctlBuffer[
								sizeof (NWLINK_ACTION)
								+sizeof (ISN_ACTION_GET_DETAILS)];
	ULONG				i, j;
	PADAPTER_STATE			newArray;
	WCHAR				namebuf[64];
	char				buf[128];
	ULONG				length;
	DWORD				status;
	LV_ITEM				lvi;

	status = ListView_DeleteAllItems(AdapterLB);
	ASSERTMSG ("Could not all list items ", status);

	action = (PNWLINK_ACTION)IoctlBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option)
							+sizeof (ISN_ACTION_GET_DETAILS);
	action->Option = MIPX_CONFIG;
	details = (PISN_ACTION_GET_DETAILS)action->Data;
	details->NicId = 0;

	status = NtDeviceIoControlFile(
						IpxDriverHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						action,
						sizeof(NWLINK_ACTION)
						+sizeof (ISN_ACTION_GET_DETAILS));
	if (status==STATUS_PENDING){
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	ASSERTMSG ("Ioclt MIPX_CONFIG failed ", NT_SUCCESS (status));

	ListView_SetItemCount(AdapterLB, details->NicId);
	lvi.mask = LVIF_TEXT;
	lvi.pszText = buf;

	lvi.iItem = 0;

	lvi.iSubItem = 0;
	sprintf (buf, "%ls", L"Internal");
	status = ListView_InsertItem (AdapterLB, &lvi);
	ASSERTMSG ("Could not insert list item ", status!=-1);

	lvi.iSubItem = 1;
	sprintf (buf, "%d", 0);
	status = ListView_SetItem (AdapterLB, &lvi);
	ASSERTMSG ("Could not set list subitem ", status);

	lvi.iSubItem = 2;
	sprintf (buf, "%d", 0);
	status = ListView_SetItem (AdapterLB, &lvi);
	ASSERTMSG ("Could not set list subitem ", status);

	lvi.iSubItem = 3;
	sprintf (buf,"%08x", GETLONG2ULONGdirect(&details->NetworkNumber));
	status = ListView_SetItem (AdapterLB, &lvi);
	ASSERTMSG ("Could not set list subitem ", status);

	lvi.iSubItem = 4;
	sprintf (buf, "%02x%02x%02x%02x%02x%02x",
			INTERNAL_NODE_ADDRESS[0], INTERNAL_NODE_ADDRESS[1],
				INTERNAL_NODE_ADDRESS[2], INTERNAL_NODE_ADDRESS[3],
				INTERNAL_NODE_ADDRESS[4], INTERNAL_NODE_ADDRESS[5]);
	status = ListView_SetItem (AdapterLB, &lvi);
	ASSERTMSG ("Could not set list subitem ", status);

	newArray = (PADAPTER_STATE)RtlAllocateHeap (RtlProcessHeap (), 0,
								sizeof (ADAPTER_STATE)*details->NicId);
	ASSERTMSG ("Could not allocate Adapter state array ", newArray!=NULL);

	if (AdapterDataBuffer!=NULL)
		RtlFreeHeap (RtlProcessHeap (), 0, AdapterDataBuffer);

	AdapterDataBuffer = RtlAllocateHeap (RtlProcessHeap (), 0,
							FIELD_OFFSET (NWLINK_ACTION, Data)
								+FIELD_OFFSET (IPX_NICS, Data)
								+sizeof (IPX_NIC_INFO)*details->NicId);
	ASSERTMSG ("Could not allocate request buffer ", action!=NULL);

	action = (PNWLINK_ACTION)AdapterDataBuffer;
	action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
	action->OptionType = NWLINK_OPTION_CONTROL;
	action->BufferLength = sizeof (action->Option)
						+FIELD_OFFSET(IPX_NICS,Data)
						+sizeof (IPX_NIC_INFO)*details->NicId;
	action->Option = MIPX_GETNEWNICINFO;
	request = (PIPX_NICS)action->Data;
	request->NoOfNics = 0;
	request->TotalNoOfNics = 0;
	request->fAllNicsDesired = TRUE;

	status = NtDeviceIoControlFile(
					IpxDriverHandle,
					NULL,
					NULL,
					NULL,
					&IoStatus,
					IOCTL_TDI_ACTION,
					NULL,
					0,
					action,
					FIELD_OFFSET(NWLINK_ACTION, Data)
						+FIELD_OFFSET(IPX_NICS,Data)
						+sizeof (IPX_NIC_INFO)*details->NicId);
	if (status==STATUS_PENDING) {
		status = NtWaitForSingleObject (IpxDriverHandle, FALSE, NULL);
		if (NT_SUCCESS (status))
			status = IoStatus.Status;
		}

	ASSERTMSG ("Ioctl MIPX_GETNEWNICINFO failed ", NT_SUCCESS (status));
	NicPtr = (PIPX_NIC_INFO)request->Data;
	NumAdapters = request->TotalNoOfNics;
	for (i=0; i<NumAdapters; i++, NicPtr++) {
		UINT j;
		for (j=0; (j<AdapterArraySize)
				&& (AdapterArray[j].AdapterId
					!=NicPtr->NicId); j++);
		newArray[i].AdapterId = NicPtr->NicId;
		newArray[i].Status = NicPtr->Status;
		if (j<AdapterArraySize)
			newArray[i].Enabled = AdapterArray[j].Enabled;
		else
			newArray[i].Enabled = TRUE;
		
		length = sizeof (namebuf);
		GetAdapterNameW (newArray[i].AdapterId, &length, namebuf);
		
		lvi.iItem = i+1;

		lvi.mask |= LVIF_STATE;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_STATEIMAGEMASK;
		lvi.state = INDEXTOSTATEIMAGEMASK (
					newArray[i].Enabled
						? (((NicPtr->Status==NIC_CONFIGURED)
							|| (NicPtr->Status==NIC_LINE_UP))
							? 2 : 1)
						: 0);
		sprintf (buf, "%ls", namebuf);
		status = ListView_InsertItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not insert list item ", status!=-1);
		lvi.mask &= (~LVIF_STATE);

		sprintf (buf, "%d", newArray[i].AdapterId);
		lvi.iSubItem = 1;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%d",
				(NicPtr->NdisMediumType==NdisMediumWan)
						&& (newArray[i].Status==NIC_LINE_UP)
					? NicPtr->InterfaceIndex
					: -1);
		lvi.iSubItem = 2;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%08x", GETLONG2ULONGdirect(&NicPtr->NetworkAddress));
		lvi.iSubItem = 3;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%02x%02x%02x%02x%02x%02x",
				NicPtr->LocalNodeAddress[0], NicPtr->LocalNodeAddress[1],
					NicPtr->LocalNodeAddress[2], NicPtr->LocalNodeAddress[3],
					NicPtr->LocalNodeAddress[4], NicPtr->LocalNodeAddress[5]);
		lvi.iSubItem = 4;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%02x%02x%02x%02x%02x%02x",
				NicPtr->RemoteNodeAddress[0], NicPtr->RemoteNodeAddress[1],
					NicPtr->RemoteNodeAddress[2], NicPtr->RemoteNodeAddress[3],
					NicPtr->RemoteNodeAddress[4], NicPtr->RemoteNodeAddress[5]);
		lvi.iSubItem = 5;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%d", NicPtr->LinkSpeed);
		lvi.iSubItem = 6;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%d", NicPtr->MaxPacketSize);
		lvi.iSubItem = 7;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		sprintf (buf, "%d", NicPtr->PacketType);
		lvi.iSubItem = 8;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		switch (NicPtr->NdisMediumType) {
			case NdisMedium802_3:
				sprintf (buf, "%s", "802.3");
				break;
    		case NdisMedium802_5:
				sprintf (buf, "%s", "802.5");
				break;
 			case NdisMediumFddi:
				sprintf (buf, "%s", "FDDI");
				break;
 			case NdisMediumWan:
				sprintf (buf, "%s", "Wan");
				break;
 			case NdisMediumLocalTalk:
				sprintf (buf, "%s", "LTalk");
				break;
 			case NdisMediumDix:
				sprintf (buf, "%s", "Dix");
				break;
 			case NdisMediumArcnetRaw:
				sprintf (buf, "%s", "ArcnetRaw");
				break;
 			case NdisMediumArcnet878_2:
				sprintf (buf, "%s", "Arcnet878.2");
				break;
			}
		lvi.iSubItem = 9;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);

		switch (NicPtr->Status) {
			case NIC_CREATED:
				sprintf (buf, "%s", "Created");
				break;
			case NIC_DELETED:
				sprintf (buf, "%s", "Deleted");
				break;
			case NIC_CONFIGURED:
				sprintf (buf, "%s", "Configured");
				break;
			case NIC_LINE_UP:
				sprintf (buf, "%s", "Up");
				break;
			case NIC_LINE_DOWN:
				sprintf (buf, "%s", "Down");
				break;
			default:
				ASSERTMSG ("Unknown nic status ", FALSE);
				break;
			}
		lvi.iSubItem = 10;
		status = ListView_SetItem (AdapterLB, &lvi);
		ASSERTMSG ("Could not set list subitem ", status);
		}

	if (AdapterArray!=NULL)
		RtlFreeHeap (RtlProcessHeap (), 0, AdapterArray);
	AdapterArray = newArray;
	AdapterArraySize = NumAdapters;
	}

/*++
*******************************************************************
		I p x R e c v C o m p l e t i o n W a t c h

Routine Description:
	Substitute completion routine that filters out packets
	received on the adapters disabled by the UI
Arguments:
		Context - Pointer to client completion routine
		IoStatus - status of completed io operation (clients overlapped
					structure is used as the buffer)
		Reserved - ???
Return Value:
		None
--*/

VOID
IpxRecvCompletionWatch (
	IN	PVOID				Context,
	IN	PIO_STATUS_BLOCK	IoStatus,
	IN	ULONG				Reserved
	) {
	LPOVERLAPPED	ovrp = (LPOVERLAPPED)IoStatus;
	if (NT_SUCCESS(IoStatus->Status)) {
			// Check if adapter is disabled through the UI and repost recv if so
		USHORT	NicId = GetNicId (ovrp->OffsetHigh);
		UINT		i;
		EnterCriticalSection (&ConfigInfoLock);
		if (AdapterArray!=NULL) {
			for (i=0; (i<AdapterArraySize) && (AdapterArray[i].AdapterId!=NicId); i++);
			ASSERTMSG ("Invalid Nic id ", i<AdapterArraySize);
			if (!AdapterArray[i].Enabled) {
				LeaveCriticalSection (&ConfigInfoLock);
				IoStatus->Status = NtDeviceIoControlFile(
									(HANDLE)ovrp->hEvent,
									NULL,
									IpxRecvCompletionWatch,
									Context,				// APC Context
									IoStatus,
									MIPX_RCV_DATAGRAM,
									NULL,
									0,
									(PVOID)ovrp->OffsetHigh,
									FIELD_OFFSET (IPX_DATAGRAM_OPTIONS2,Data)
										+ ovrp->Offset
									);
				if (NT_SUCCESS (IoStatus->Status))
					return;
				}
			else
				LeaveCriticalSection (&ConfigInfoLock);
			}
		else
			LeaveCriticalSection (&ConfigInfoLock);
		}		
	ovrp->hEvent = NULL;
	IpxRecvCompletion (Context, IoStatus, Reserved);
	}

/*++
*******************************************************************
		I s A d a p t e r D i s a b l e d

Routine Description:
	Chacks if adapter with given id is disabled by the UI (it wont be
		reported to the clients)
Arguments:
	NicId - id of the adapter to check
Return Value:
	TRUE - adapter is disabled
	FALSE - adapter is not disabled
--*/
BOOL
IsAdapterDisabled (
	USHORT	NicId
	) {
	if (AdapterArray!=NULL) {
		UINT	j;
		for (j=0; j<AdapterArraySize; j++) {
			if (AdapterArray[j].AdapterId==NicId)
				break;
			}						
		ASSERTMSG ("Nic not in the array ", j<AdapterArraySize);
		if (!AdapterArray[j].Enabled)
			return TRUE;
		}

	return FALSE;
	}

/*++
*******************************************************************
	I n f o r m W a t c h e r

Routine Description:
	Signals event to inform let watcher dialog update its adapter
	configuration info
Arguments:
	None
Return Value:
	None
--*/
VOID
InformWatcher (
	void
	) {
	if (WatcherDlg!=NULL) {
		BOOL	res = SetEvent (DebugWatchEvent);
		ASSERTMSG ("Could not set debug watch event ", res);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\autonet\netnum.cpp ===
/*
    File    netnum.cpp

    Private helper functions for setting the internal network number.
    We talk to ndis directly to set this number.

    Paul Mayfield, 1/5/98
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <ndispnp.h>

extern "C" {
    DWORD OutputDebugger (LPSTR pszError, ...);
};

//$ REVIEW - Start - This is moving to private\inc\ipxpnp.h

#define IPX_RECONFIG_VERSION        0x1

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

typedef struct _RECONFIG {
   unsigned long  ulVersion;
   BOOLEAN        InternalNetworkNumber;
   BOOLEAN        AdapterParameters[RECONFIG_PARAMETERS];
} RECONFIG, *PRECONFIG;

//$ REVIEW - End - This is moving to private\inc\ipxpnp.h

static const TCHAR c_szIpx[]                    = TEXT("nwlnkipx");
static const TCHAR c_szEmpty[]                  = TEXT("");
static const TCHAR c_szVirtualNetworkNumber[]   = TEXT("VirtualNetworkNumber");
static const TCHAR c_szIpxParameters[]          = TEXT("System\\CurrentControlSet\\Services\\NwlnkIpx\\Parameters");
static const TCHAR c_szDevice[]                 = TEXT("\\Device\\");

ULONG
CchMsz (
        LPCTSTR pmsz)
{
    ULONG cchTotal = 0;
    ULONG cch;

    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    while (*pmsz)
    {
        cch = lstrlen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of characters so far plus room for the
    // extra null terminator.
    return cchTotal + 1;
}

void
SetUnicodeMultiString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          pmsz )
{
    //AssertSz( pustr != NULL, "Invalid Argument" );
    //AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);
    pustr->Length = (USHORT) (CchMsz(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length;
}

void
SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz )
{
    //AssertSz( pustr != NULL, "Invalid Argument" );
    //AssertSz( psz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = (USHORT)(lstrlenW(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

HRESULT
HrSendNdisHandlePnpEvent (
        UINT        uiLayer,
        UINT        uiOperation,
        LPCWSTR     pszUpper,
        LPCWSTR     pszLower,
        LPCWSTR     pmszBindList,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

    //Assert(NULL != pszUpper);
    //Assert((NDIS == uiLayer)||(TDI == uiLayer));
    //Assert( (BIND == uiOperation) || (RECONFIGURE == uiOperation) || (UNBIND == uiOperation) );
    //AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
    //        (RECONFIGURE == uiOperation) &&
    //        (TDI == uiLayer) &&
    //        (0 == lstrlenW( pszLower ))),
    //        "bind order change requires a bind list, no lower, only for TDI, and with Reconfig for the operation" );

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
        //hr = HrFromLastWin32Error();
        hr = GetLastError();
    }

    return( hr );
}

HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        LPCWSTR     wszUpper,
        LPCWSTR     wszLower,
        PVOID       pvData,
        DWORD       dwSizeData)
{
    //Assert(NULL != wszUpper);
    //Assert((NDIS == uiLayer)||(TDI == uiLayer));
    //tstring strLower;
    WCHAR strLower[512];
    BOOL bSendNull = FALSE;

    if (NULL == wszLower)
    {
        wszLower = c_szEmpty;
    }

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if ( wszLower && lstrlenW(wszLower))
    {
        //strLower = c_szDevice;
        //strLower += wszLower;
        wcscpy(strLower, c_szDevice);
        wcscat(strLower, wszLower);
    }
    else
        bSendNull = TRUE;

    HRESULT hr = HrSendNdisHandlePnpEvent(uiLayer,
                RECONFIGURE,
                wszUpper,
                //strLower.c_str(),
                (bSendNull) ? NULL : strLower,
                c_szEmpty,
                pvData,
                dwSizeData);

    OutputDebugger( "HrSendNdisHandlePnpEvent: %x\n", hr);

    return hr;
}

HRESULT HrSetIpxVirtualNetNum(DWORD dwValue)
{
    RECONFIG  Config;
    HKEY      hkey;
    HRESULT   hr;

    // Open the registry key
    LONG lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIpxParameters, 0,
                           KEY_ALL_ACCESS, &hkey);
    hr = HRESULT_FROM_WIN32(lr);
    if (SUCCEEDED(hr))
    {
        // Splat the data
        lr = RegSetValueEx(hkey, c_szVirtualNetworkNumber, 0,
                           REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));
        hr = HRESULT_FROM_WIN32(lr);
        if (SUCCEEDED(hr))
        {
            memset(&Config, 0, sizeof(RECONFIG));
            Config.ulVersion             = IPX_RECONFIG_VERSION;
            Config.InternalNetworkNumber = TRUE;

            // Workstation or server?

            // Paul, Normally I only send this notification for servers. I
            // Assume you'll be able to distinguish

            // Now submit the global reconfig notification
            hr = HrSendNdisPnpReconfig(NDIS, c_szIpx, c_szEmpty, &Config, sizeof(RECONFIG));
        }

        RegCloseKey(hkey);
    }

    return hr;
}


// Here's the function we want -- it sets the ipx internal network number
// programatically.
EXTERN_C
DWORD SetIpxInternalNetNumber(DWORD dwNetNum) {
    return HrSetIpxVirtualNetNum(dwNetNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\adapter.h ===
#ifndef _IPX_ADAPTER_
#define _IPX_ADAPTER_

#include <ntddndis.h>
#include "tdi.h"
#include "isnkrnl.h"
#include "ipxrtdef.h"

// Adapter state changes
#define ADAPTER_CREATED			1 
#define ADAPTER_DELETED			2
#define ADAPTER_UP				3
#define ADAPTER_DOWN			4


//*** Adapter Info ***

// this information is communicated whenever an adapter gets
// created or gets connected

typedef struct _ADAPTER_INFO {
    ULONG		    InterfaceIndex; // relevant only for demand dial WAN interfaces
    UCHAR		    Network[4];
    UCHAR		    LocalNode[6];
    UCHAR		    RemoteNode[6];
    ULONG		    LinkSpeed;
    ULONG		    PacketType;
    ULONG		    MaxPacketSize;
    NDIS_MEDIUM		NdisMedium;
	ULONG			ConnectionId;
	WCHAR           pszAdpName[MAX_ADAPTER_NAME_LEN];
    } ADAPTER_INFO, *PADAPTER_INFO;

typedef struct _ADAPTERS_GLOBAL_PARAMETERS {
    ULONG	AdaptersCount;
    } ADAPTERS_GLOBAL_PARAMETERS, *PADAPTERS_GLOBAL_PARAMETERS;

typedef struct _IPXWAN_INFO {
	UCHAR			Network[4];
    UCHAR		    LocalNode[6];
    UCHAR		    RemoteNode[6];
	} IPXWAN_INFO, *PIPXWAN_INFO;

typedef struct _ADDRESS_RESERVED {
		UCHAR			Reserved[FIELD_OFFSET(IPX_DATAGRAM_OPTIONS2, Data)];
		} ADDRESS_RESERVED, *PADDRESS_RESERVED;

#define  GetNicId(pReserved)	((PIPX_DATAGRAM_OPTIONS2)pReserved)->DgrmOptions.LocalTarget.NicId

/*++

        I p x C r e a t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:

		Register client that wants to be updated of any changes in
		adapter state

Arguments:

		NotificationEvent		- event to be signaled when adapter state changes
		AdptGlobalParameters	- parameters that common to all adapters

Return Value:

		Handle to configuration port thru which changes in adapter state
		are reported.  Returns INVALID_HANDLE_VALUE if port could not be created

--*/
HANDLE WINAPI
IpxCreateAdapterConfigurationPort (
	IN HANDLE NotificationEvent,
	OUT PADAPTERS_GLOBAL_PARAMETERS AdptGlobalParameters
	);

/*++

        I p x W a n C r e a t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:
		Same as above, but creates port that only reports ADAPTER_UP
		events on WAN adapters that	require IPXWAN negotiation.
		IpxGetQueuedAdapterConfigurationStatus on this port should be
		followed by IpxWanSetAdapterConfiguration obtained during the
		negotiation process, and ADAPTER_UP event will then be reported
		to other clients (including forwarder dirver)
*/
HANDLE WINAPI
IpxWanCreateAdapterConfigurationPort (
	IN HANDLE NotificationEvent,
	OUT PADAPTERS_GLOBAL_PARAMETERS AdptGlobalParameters
	);


/*++

        I p x D e l e t e A d a p t e r C o n f i g u r a t i o n P o r t

Routine Description:

		Unregister client

Arguments:

		Handle	- configuration port handle

Return Value:

		NO_ERROR
		ERROR_INVALID_PARAMETER
		ERROR_GEN_FAILURE

--*/

DWORD WINAPI
IpxDeleteAdapterConfigurationPort (
	IN HANDLE Handle
	);

/*++

        G e t Q u e u e d A d a p t e r C o n f i g u r a t i o n S t a t u s

Routine Description:

		Get info from the list of adapter info chages queued to the
		configuration info port

Arguments:

		Handle						- configuration port handle
		AdapterIndex				- number of adapter being reported
		AdapterConfigurationStatus	- new adapter status
		AdapterParameters			- adapter parameters

Return Value:

		NO_ERROR			- new information is reported
		ERROR_NO_MORE_ITEMS	- there is nothing to report
		Windows error code	- operation failed
--*/
DWORD WINAPI
IpxGetQueuedAdapterConfigurationStatus(
	IN HANDLE Handle,
	OUT PULONG AdapterIndex,
	OUT PULONG AdapterConfigurationStatus,
	OUT PADAPTER_INFO AdapterInfo
	);


/*++

        I p x W a n S e t A d a p t e r C o n f i g u r a t i o n

Routine Description:

		Sets adapter configuration to be reported to both user and
		kernel mode clients (through the ADAPTER_UP/LINE_UP events)
Arguments:

		AdapterIndex	- number of adapter being set
		IpxWanInfo		- IPXWAN negotiated parameters

Return Value:

		NO_ERROR			- adapter info set successfully
		Windows error code	- operation failed
--*/
DWORD
IpxWanSetAdapterConfiguration (
	IN ULONG		AdapterIndex,
	IN PIPXWAN_INFO	IpxWanInfo
	);

/*++

        I p x W a n Q u e r y I n a c t i v i t y T i m e r

Routine Description:

		Returns value of inactivity timer associated with WAN line
Arguments:
		ConnectionId		- connection id that identifies WAN line (used only
								if *AdapterIndex==INVALID_NICID
		AdapterIndex		- adapter index that identifies WAN line (preferred
							over connection id), if *AdapterIndex==INVALID_NICID
							the value of connection id is used to identify the
							WAN line and value of AdapterIndex is returned.
		InactivityCounter	- value of inactivity counter.

Return Value:

		NO_ERROR			- inactivity timer reading is returned
		Windows error code	- operation failed
--*/
DWORD
IpxWanQueryInactivityTimer (
	IN ULONG			ConnectionId,
	IN OUT PULONG		AdapterIndex,
	OUT PULONG			InactivityCounter
	);

/*++

	G e t A d a p t e r N a m e W


Routine  Description:
		Returns UNICODE name of the adapter associated with given index

Arguments:

		AdapterIndex		- index of adapter
		AdapterNameSize		- size of adapter name (in bytes), including terminal wchar NULL
		AdapterNameBuffer	- buffer to receive adapter name

Return Value:

		NO_ERROR					- adapter name is in the buffer
		ERROR_INVALID_PARAMETER		- adapter with given index does not exist
		ERROR_INSUFFICIENT_BUFFER   - buffer in to small. Updates AdapterNameSize to
					      the correct value.
		Other windows error code	- operation failed

--*/
DWORD WINAPI
GetAdapterNameW(
	IN ULONG	AdapterIndex,
	IN OUT PULONG	AdapterNameSize,
	OUT LPWSTR	AdapterNameBuffer);


/*++

        C r e a t e S o c k e t P o r t

Routine Description:

		Creates port to communicate over IPX socket

Arguments:

		Socket	- IPX socket number to use (network byte order)

Return Value:

		Handle to communication port that provides async interface
		to IPX stack.  Returns INVALID_HANDLE_VALUE if port can not be opened

--*/
HANDLE WINAPI
CreateSocketPort(
		IN USHORT	Socket
		); 

/*++

        D e l e t e S o c k e t P o r t

Routine Description:

		Cancel all the outstandng requests and dispose of all the resources
		allocated for communication port

Arguments:

		Handle	- Handle to communication port to be disposed of

Return Value:

		NO_ERROR - success
		Windows error code - operation failed


--*/
DWORD WINAPI
DeleteSocketPort(
		IN HANDLE	Handle
		);

/*++

        I p x R e c v P a c k e t

Routine Description:

		Enqueue request to receive IPX packet and return immediately. Event will
		be signalled or comletion routine will be called when done

Arguments:
		Handle			- Handle to adapter & socket to use
		AdapterIdx		- adapter on which to packet was received (set upon completion)
		IpxPacket		- buffer for ipx packet (complete with header)
		IpxPacketLength - length of the buffer
		pReserved		- buffer to get info from IPX stack
		lpOverlapped	- structure to be used for async IO:
						Internal	- Reserved
						InternalHigh - Reserved
						Offset		- not used
						OffsetHigh - not used
						hEvent - event to be signalled when IO completes or NULL
								if CompletionRoutine is to be called
		CompletionRoutine - to be called when IO operation is completes


Return Value:

		NO_ERROR		- if lpOverlapped->hEvent!=NULL, then send has successfully completed
						(do not need to wait on event), otherwise, send operation has
						started and completion routine will be called when done
		ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and send could not
						be completed immediately, event will be signalled when
						operation is done: call GetOverlapedResult to retrieve result of
						the operation
		other (windows error code) - operation could not be started (completion routine
						won't be called)

--*/
DWORD WINAPI
IpxRecvPacket(
		IN HANDLE 						Handle,
		OUT PUCHAR 						IpxPacket,
		IN ULONG						IpxPacketLength,
		IN PADDRESS_RESERVED			lpReserved,
		LPOVERLAPPED					lpOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
		);

/*++

        I p x S e n d P a c k e t

Routine Description:

		Enqueue request to receive IPX packet and return immediately. Event will
		be signalled or comletion routine will be called when done

Arguments:

		Handle		 - Handle to adapter & socket to use
		AdapterIdx	- adapter on which to send
		IpxPacket    - ipx packet complete with header
		IpxPacketLength - length of the packet
		pReserved	 - buffer to supply info to IPX stack
		lpOverlapped - structure to be used for async IO:
						Internal	- reserved
						InternalHigh - reserved
						Offset		- not used
						OffsetHigh - not used
						hEvent - event to be signalled when IO completes or NULL
								if CompletionRoutine is to be called
		CompletionRoutine - to be called when IO operation is completes
Return Value:
		NO_ERROR	- if lpOverlapped->hEvent!=NULL, then recv has successfully completed
						(do not need to wait on event), otherwise, recv operation has
						started and completion routine will be called when done
		ERROR_IO_PENDING - only returned if lpOverlapped->hEvent!=NULL and recv could not
						be completed immediately, event will be signalled when
						operation is done: call GetOverlapedResult to retrieve result of
						the operation
		other (windows error code) - operation could not be started (completion routine
						won't be called)


--*/
DWORD WINAPI
IpxSendPacket (
		IN HANDLE						Handle,
		IN ULONG						AdapterIdx,
		IN PUCHAR						IpxPacket,
		IN ULONG						IpxPacketLength,
		IN PADDRESS_RESERVED			lpReserved,
		LPOVERLAPPED					lpOverlapped,
		LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine
		);

/*++

        I p x G e t O v e r l a p p e d R e s u l t
Routine Description:
		GetOverlappedResult wrapper: gives adptif.dll a chance to adjust
		returned parameters (currently number of bytes transferred).

Arguments:
		Same as in GetOverlappedResult (see SDK doc)
Return Value:
		Same as in GetOverlappedResult (see SDK doc)
--*/
BOOL
IpxGetOverlappedResult (
	HANDLE			Handle,  
	LPOVERLAPPED	lpOverlapped, 
	LPDWORD			lpNumberOfBytesTransferred, 
	BOOL			bWait
	);

/*++

        I p x G e t Q u e u e d C o m p l e t i o n S t a t u s

Routine Description:
		GetQueuedCompletionStatus wrapper: gives adptif.dll a chance to adjust
		returned parameters (currently number of bytes transferred)

Arguments:
		Same as in GetQueuedCompletionStatus (see SDK doc)
Return Value:
		Same as in GetQueuedCompletionStatus (see SDK doc)
--*/
BOOL
IpxGetQueuedCompletionStatus(
	HANDLE			CompletionPort,
	LPDWORD			lpNumberOfBytesTransferred,
	PULONG_PTR		lpCompletionKey,
	LPOVERLAPPED	*lpOverlapped,
	DWORD 			dwMilliseconds
	);

/*++

        I p x A d j u s t I o C o m p l e t i o n P a r a m s

Routine Description:
		Adjust io completion parameters for io performed
		by IpxSendPacket or IpxReceivePacket  and completed
		through the mechanisms other than routines provided
		above

Arguments:
		lpOverlapped	 - overlapped structure passed to
							Ipx(Send/Recv)Packet routines
		lpNumberOfBytesTransferred - adjusted number of bytes
						transferred in io
		error			- win32 error code
		
Return Value:
		None
--*/
VOID
IpxAdjustIoCompletionParams (
	IN OUT LPOVERLAPPED	lpOverlapped,
	OUT LPDWORD			lpNumberOfBytesTransferred,
	OUT LPDWORD			error
	);
/*++

        I p x P o s t Q u e u e d C o m p l e t i o n S t a t u s

Routine Description:
		PostQueuedCompletionStatus wrapper: gives adptif.dll a chance to
		setup lpOverlapped so it can be correctly processed by
		the IpxGetQueueCompletionStatus and IpxGetOverlappedResult

Arguments:
		Same as in PostQueuedCompletionStatus (see SDK doc)
Return Value:
		Same as in PostQueuedCompletionStatus (see SDK doc)
--*/
BOOL
IpxPostQueuedCompletionStatus(
	HANDLE			CompletionPort,
	DWORD			dwNumberOfBytesTransferred,
	DWORD			dwCompletionKey,
	LPOVERLAPPED	lpOverlapped	
	);

#endif // _IPX_ADAPTER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\fwif.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fwif.h

Abstract:

    This module contains the definitions of the internal Forwarder APIs
    used by the router manager

Author:

    Stefan Solomon  03/16/1995

Revision History:


--*/

#ifndef _FWIF_
#define _FWIF_

//*********************************************************
//							  *
//		 Forwarder Module APIs			  *
//							  *
//*********************************************************

//
// Forwarder Interface Management
//

// Forwarder if config info
typedef struct _FW_IF_INFO {
    ULONG				NetbiosAccept;
    ULONG				NetbiosDeliver;
    } FW_IF_INFO, *PFW_IF_INFO;

// Forwarder if statistics
typedef IPX_IF_STATS FW_IF_STATS, *PFW_IF_STATS;

typedef struct _FW_DIAL_REQUEST {
    ULONG               IfIndex;   // Interface from which packet came
    UCHAR               Packet[30]; // Packet that caused the
                                    // the connection (at least size of the
                                    // IPX header)
} FW_DIAL_REQUEST, *PFW_DIAL_REQUEST;


DWORD
FwStart (
	ULONG					RouteHashTableSize,
	BOOL					ThisMachineOnly  // allow access to this machine only
	);				  // for dialin clients

DWORD
FwStop (
	void
	);

DWORD 
FwUpdateConfig(
    BOOL                    ThisMachineOnly
    );

DWORD
FwCreateInterface (
	IN ULONG				InterfaceIndex,
	IN NET_INTERFACE_TYPE	InterfaceType,
	IN PFW_IF_INFO			FwIfInfo
	);

DWORD
FwDeleteInterface (
	IN ULONG				InterfaceIndex);

DWORD
FwSetInterface (
	IN ULONG 				InterfaceIndex,
	IN PFW_IF_INFO			FwIfInfo
	);

DWORD
FwGetInterface (
	IN  ULONG				InterfaceIndex,
	OUT PFW_IF_INFO			FwIfInfo,
	OUT PFW_IF_STATS		FwIfStats
	);

//
// This call tells the forwarder that the respective interface is connected
// via the specified adapter
//
DWORD
FwBindFwInterfaceToAdapter (
	IN ULONG						InterfaceIndex,
	IN PIPX_ADAPTER_BINDING_INFO	AdptBindingInfo
	);

//
// This call tells the forwarder that the connected interface has been
// disconnected.
//

DWORD
FwUnbindFwInterfaceFromAdapter (
	IN ULONG						InterfaceIndex
	);

//
// This call tells the forwarder that the respective interface is disabled
// and should be ignored by the forwarder
//

DWORD
FwDisableFwInterface (
	IN ULONG			InterfaceIndex
	);

//
// This call tells the forwarder that the respective interface is reenabled
// and should be operated on as ususal
//

DWORD
FwEnableFwInterface (
	IN ULONG			InterfaceIndex
	);

// Ioctl is sent to forwarder which completes when an interface
// requires dial out connection.
// When Ioctl completes, lpOverlapped->hEvent will be signalled:
//	GetNotificationResult should be called to get final result of the
// operation and the number bytes placed into the request buffer
DWORD
FwNotifyConnectionRequest (
	OUT PFW_DIAL_REQUEST	Request, // Buffer to be filled with interface index
                                     //that requires connection plus packet
                                     // that forced it
	IN ULONG			    RequestSize, // Size of the buffer (must at least
                                        // be sizeof (FW_DIAL_REQUEST)
	IN LPOVERLAPPED		    lpOverlapped	// structure for asyncrhronous
							// operation, hEvent must be set
	);


// Returns result of notification request. Should be called when 
// the event set in the lpOverlapped structure is signalled.
//
DWORD
FwGetNotificationResult (
	IN LPOVERLAPPED		lpOverlapped,
	OUT PULONG			nBytes		// Number of bytes placed into
                                    // the request buffer
	);

//
// Call to tell the forwarder that its connection request on a certain interface
// cannot be completed.
// The reason this cannot get completed is one of:
//
// 1. The physical connection failed. This is made known to the router manager
//    by DDM calling InterfaceNotReachable.
// 2. The physical connection succeded ok but the IPXCP negotiation failed.
// 3. IPXCP negotiation completed ok but IPXWAN negotiation failed.
//

DWORD
FwConnectionRequestFailed (
	IN ULONG	InterfaceIndex
	);


//
// Informs forwarder that route to the destination network has changed
//
VOID
FwUpdateRouteTable (
	DWORD	ChangeFlags,
	PVOID	CurRoute,
	PVOID	PrevRoute
	);

//
// Sets the netbios static routing information on this interface
//

DWORD
FwSetStaticNetbiosNames(ULONG				   InterfaceIndex,
			ULONG				   NetbiosNamesCount,
			PIPX_STATIC_NETBIOS_NAME_INFO	   NetbiosName);

//
// Gets the netbios static routing information on this interface
//
// If NetbiosNamesCount < nr of names or NetbiosName == NULL then set the
// correct value in NetbiosNamesCount and return ERROR_INSUFFICIENT_BUFFER

DWORD
FwGetStaticNetbiosNames(ULONG				   InterfaceIndex,
			PULONG				   NetbiosNamesCount,
			PIPX_STATIC_NETBIOS_NAME_INFO	   NetbiosName);



//
// ***	Traffic Filters ***
//


#define IPX_TRAFFIC_FILTER_INBOUND		1
#define IPX_TRAFFIC_FILTER_OUTBOUND		2

DWORD
SetFilters(ULONG	InterfaceIndex,
	   ULONG	FilterMode,    // inbound, outbound
	   ULONG	FilterAction, 
	   ULONG	FilterSize,
	   LPVOID	FilterInfo,
       ULONG    FilterInfoSize);

DWORD
GetFilters(IN ULONG	InterfaceIndex,
	   IN ULONG	FilterMode,    // inbound, outbound
	   OUT PULONG	FilterAction,
	   OUT PULONG	FilterSize,
	   OUT LPVOID	FilterInfo,
       IN OUT PULONG FilterInfoSize);



#endif // _FWIF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\ipxcpif.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxcpif.h

Abstract:

    This module contains the definitions of the APIs provided by the IPXCP
    DLL and the Router Manager DLL for inter-communication

Author:

    Stefan Solomon  03/16/1995

Revision History:


--*/

#ifndef _IPXCPIF_
#define _IPXCPIF_

// Configuration shared between ipxcp and the ipx router.
typedef struct _IPXCP_ROUTER_CONFIG_PARAMS {
    BOOL	ThisMachineOnly;
    BOOL	WanNetDatabaseInitialized;
    BOOL	EnableGlobalWanNet;
    UCHAR	GlobalWanNet[4];
} IPXCP_ROUTER_CONFIG_PARAMS, *PIPXCP_ROUTER_CONFIG_PARAMS;


// Entry points into the IPXCP DLL called by the IPX Router Manager

typedef struct _IPXCP_INTERFACE {

    // IPXCP configuration parameters needed by the IPX Router Manager

    IPXCP_ROUTER_CONFIG_PARAMS Params;

    // IPXCP Entry Points

    VOID (WINAPI *IpxcpRouterStarted)(VOID);

    VOID (WINAPI *IpxcpRouterStopped)(VOID);

    // IPX Router Manager Entry Points

    DWORD (WINAPI *RmCreateGlobalRoute)(PUCHAR	     Network);

    DWORD (WINAPI *RmAddLocalWkstaDialoutInterface)
	    (IN	    LPWSTR		    InterfaceNamep,
	     IN	    LPVOID		    InterfaceInfop,
	     IN OUT  PULONG		    InterfaceIndexp);

    DWORD (WINAPI *RmDeleteLocalWkstaDialoutInterface)(ULONG	InterfaceIndex);

    DWORD (WINAPI *RmGetIpxwanInterfaceConfig)
	    (ULONG	InterfaceIndex,
	    PULONG	IpxwanConfigRequired);

    BOOL  (WINAPI *RmIsRoute)(PUCHAR	Network);

    DWORD (WINAPI *RmGetInternalNetNumber)(PUCHAR	Network);

    DWORD (WINAPI *RmUpdateIpxcpConfig)(PIPXCP_ROUTER_CONFIG_PARAMS pParams);

    } IPXCP_INTERFACE, *PIPXCP_INTERFACE;


#define IPXCP_BIND_ENTRY_POINT			    IpxcpBind
#define IPXCP_BIND_ENTRY_POINT_STRING		    "IpxcpBind"

typedef DWORD
(WINAPI  *PIPXCP_BIND)(PIPXCP_INTERFACE	IpxcpInterface);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\ipxanet.h ===
/*
    File:   ipxanet.h

    Defines functions that assign a random internal network number
    after verifying that the number in question is not present on 
    the network.

    Paul Mayfield, 1/29/97
*/

#ifndef __ipx_autonet_h
#define __ipx_autonet_h

// 
//  Function: AutoValidateInternalNetNum
// 
//  Queries the stack to learn the internal network number and then
//  returns whether this number is valid. (i.e. non zero and non all ff's)
//  
//  Params:  
//      pbIsValid       set to TRUE if internal net num is valid -- false, otherwise 
//      dwTraceId       If non-zero, sends trace through this id
//
DWORD AutoValidateInternalNetNum(OUT PBOOL pbIsValid, IN DWORD dwTraceId);

// 
//  Function: AutoWaitForValidNetNum
// 
//  Puts the calling thread to sleep until a valid internal network number
//  has been plumbed into the system.
//
//  Params:
//      dwTimeout     timeout in seconds
//      pbIsValid     if provided, returns whether number is valid
//      
DWORD AutoWaitForValidIntNetNum (IN DWORD dwTimeout, 
                                 IN OUT OPTIONAL PBOOL pbIsValid);

// 
//  Function: PnpAutoSelectInternalNetNumber
// 
//  Selects a new internal network number for this router and plumbs that network
//  number into the stack and the router.
//
//  Depending on whether the forwarder and ipxrip are enabled, it will validate the
//  newly selected net number against the stack or rtm.
// 
//  Params:  
//      dwTraceId        If non-zero, sends trace to this id
//
DWORD PnpAutoSelectInternalNetNumber(IN DWORD dwTraceId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\utils.h ===
/*******************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	utils.h
//
// Description: Contains miscellaneous utilities
//
// Author:	Stefan Solomon (stefans)    May 10, 1995.
//
// Revision History:
//
//***

#ifndef _UTILS_
#define _UTILS_

/*
 * The following macros deal with on-the-wire short and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04.
 * Similarly a short value of 0x0102 is represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a short from on-the-wire format to a USHORT in the host format
#define GETSHORT2USHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 8) +	\
					  (*((PUCHAR)(SrcPtr)+1)		))

// Get a long from on-the-wire format to a ULONG in the host format
#define GETLONG2ULONG(DstPtr, SrcPtr)	\
		*(PULONG)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 24) + \
					  (*((PUCHAR)(SrcPtr)+1) << 16) + \
					  (*((PUCHAR)(SrcPtr)+2) << 8)	+ \
					  (*((PUCHAR)(SrcPtr)+3)	))

// Put a USHORT from the host format to a short to on-the-wire format
#define PUTUSHORT2SHORT(DstPtr, Src)   \
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((USHORT)(Src) >> 8), \
		*((PUCHAR)(DstPtr)+1) = (UCHAR)(Src)

// Put a ULONG from the host format to an array of 4 UCHARs on-the-wire format
#define PUTULONG2LONG(DstPtr, Src)   \
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((ULONG)(Src) >> 24), \
		*((PUCHAR)(DstPtr)+1) = (UCHAR) ((ULONG)(Src) >> 16), \
		*((PUCHAR)(DstPtr)+2) = (UCHAR) ((ULONG)(Src) >>	8), \
		*((PUCHAR)(DstPtr)+3) = (UCHAR) (Src)

// Get a short from on-the-wire format to a USHORT in the host format
#define GETSHORT2USHORTdirect(SrcPtr)	\
		((*((PUCHAR)(SrcPtr)+0) << 8) +	(*((PUCHAR)(SrcPtr)+1) ))

// Get a long from on-the-wire format to a ULONG in the host format
#define GETLONG2ULONGdirect(SrcPtr)	\
		((*((PUCHAR)(SrcPtr)+0) << 24) + \
		(*((PUCHAR)(SrcPtr)+1) << 16) + \
		(*((PUCHAR)(SrcPtr)+2) << 8)	+ \
		(*((PUCHAR)(SrcPtr)+3)	))

#endif	// _UTILS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\ipxwan.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ipxwan.c

Abstract:

    ipxwan control

Author:

    Stefan Solomon  02/06/1996

Revision History:


--*/

#include    "precomp.h"
#pragma     hdrstop

ULONG	    EnableUnnumberedWanLinks;
HANDLE	    WorkerThreadHandle;

// IPXCP Entry Points

DWORD
(WINAPI *IpxcpGetWanNetNumber)(IN OUT PUCHAR		Network,
					 IN OUT PULONG		AllocatedNetworkIndexp,
					 IN	ULONG		InterfaceType);

VOID
(WINAPI *IpxcpReleaseWanNetNumber)(ULONG	    AllocatedNetworkIndex);

DWORD
(WINAPI *IpxcpConfigDone)(ULONG		ConnectionId,
			  PUCHAR	Network,
			  PUCHAR	LocalNode,
			  PUCHAR	RemoteNode,
			  BOOL		Success);

VOID
(WINAPI *IpxcpGetInternalNetNumber)(PUCHAR	Network);

ULONG
(WINAPI *IpxcpGetInterfaceType)(ULONG	    ConnectionId);

DWORD
(WINAPI *IpxcpGetRemoteNode)(ULONG	    ConnectionId,
			     PUCHAR	    RemoteNode);

BOOL
(WINAPI *IpxcpIsRoute)(PUCHAR	  Network);


// worker thread waitable objects
HANDLE	    hWaitableObject[MAX_WAITABLE_OBJECTS];

VOID
ProcessWorkItem(VOID);

VOID
WorkerThread(VOID);


VOID
ProcessDequeuedIoPacket(DWORD		   ErrorCode,
			DWORD		   BytesTransferred,
			LPOVERLAPPED	      Overlappedp);

CRITICAL_SECTION	DbaseCritSec;
CRITICAL_SECTION	QueuesCritSec;
LIST_ENTRY		WorkersQueue;

// worker thread object handlers

typedef     VOID   (*WOBJECT_HANDLER)(VOID);

WOBJECT_HANDLER    WaitableObjectHandler[MAX_WAITABLE_OBJECTS] = {

    AdapterNotification,	    // ADAPTER_NOTIFICATION_EVENT
    ProcessWorkItem,		    // WORKERS_QUEUE_EVENT
    ProcessTimerQueue		    // TIMER_HANDLE

    };

BOOLEAN Active;
TCHAR   ModuleName[MAX_PATH+1];

BOOL WINAPI
IpxWanDllEntry(HINSTANCE hInstDll,
	       DWORD fdwReason,
	       LPVOID pReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        GetModuleFileName (hInstDll, ModuleName,
                        sizeof (ModuleName)/sizeof (ModuleName[0]));
	    // Create the adapters hash table lock
	    InitializeCriticalSection(&DbaseCritSec);

	    // Create the queues lock
	    InitializeCriticalSection(&QueuesCritSec);

        StartTracing();
        break;

	case DLL_PROCESS_DETACH:
    
        StopTracing ();

	    // delete the database lock
	    DeleteCriticalSection(&DbaseCritSec);

	    // delete the queues lock
	    DeleteCriticalSection(&QueuesCritSec);

        break;

    default:

        break;
    }

    return TRUE;
}

/*++

Function:	IpxwanBind

Descr:		called by IPXCP to initialize the IPXWAN module

--*/

DWORD
IPXWAN_BIND_ENTRY_POINT(PIPXWAN_INTERFACE	     IpxwanIfp)
{
    DWORD	    threadid, i;
    HANDLE	    ThreadHandle;


    Trace(INIT_TRACE, "IpxwanBind: Entered\n");

    EnableUnnumberedWanLinks = IpxwanIfp->EnableUnnumberedWanLinks;
    IpxcpGetWanNetNumber = IpxwanIfp->IpxcpGetWanNetNumber;
    IpxcpReleaseWanNetNumber = IpxwanIfp->IpxcpReleaseWanNetNumber;
    IpxcpConfigDone  = IpxwanIfp->IpxcpConfigDone;
    IpxcpGetInternalNetNumber = IpxwanIfp->IpxcpGetInternalNetNumber;
    IpxcpGetInterfaceType = IpxwanIfp->IpxcpGetInterfaceType;
    IpxcpGetRemoteNode = IpxwanIfp->IpxcpGetRemoteNode;
    IpxcpIsRoute = IpxwanIfp->IpxcpIsRoute;

    // create the worker thread's waitable objects array
    // for the ipxwan worker thread
    for(i=0; i<MAX_EVENTS; i++) {

	if((hWaitableObject[i] = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {

	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    if((hWaitableObject[TIMER_HANDLE] = CreateWaitableTimer(NULL, FALSE, NULL)) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // init all the queues
    //
    InitializeListHead(&WorkersQueue);
    InitializeListHead(&TimerQueue);

    // create the workers work items heap
    if(CreateWorkItemsManager() != NO_ERROR) {

	goto ErrorExit;
    }

    // open the IpxWan socket for I/O
    if(OpenIpxWanSocket() != NO_ERROR) {

	Trace(INIT_TRACE, "Cannot open IPXWAN socket\n");

	goto ErrorExit;
    }

    if(! BindIoCompletionCallback(IpxWanSocketHandle,
			   ProcessDequeuedIoPacket, 0)) {

	Trace(INIT_TRACE, "Cannot associate IO CompletionPort\n");

	goto ErrorExit;
    }

    if(StartAdapterManager() != NO_ERROR) {

	Trace(INIT_TRACE, "Cannot create adapter config port\n");

	goto ErrorExit;
    }

    // create the Worker thread
    if ((WorkerThreadHandle = CreateThread(
			    (LPSECURITY_ATTRIBUTES) NULL,
			    0,
			    (LPTHREAD_START_ROUTINE) WorkerThread,
			    NULL,
			    0,
			    &threadid)) == NULL) {

	// !!! log error cannot create the worker thread !!!
	goto ErrorExit;
    }

    Active = TRUE;
    return NO_ERROR;

ErrorExit:

    return ERROR_CAN_NOT_COMPLETE;
}


VOID
IPXWAN_UNBIND_ENTRY_POINT (VOID) {
    Active = FALSE;
    SetEvent (hWaitableObject[WORKERS_QUEUE_EVENT]);
    
    Trace(INIT_TRACE, "IpxwanUnBind: Finished\n");
}
    


VOID
WorkerThread(VOID)
{
    INT         i;
    DWORD	    rc;
    DWORD	    signaled_object;
    HINSTANCE   hModule = LoadLibrary (ModuleName);

    Trace(INIT_TRACE, "IpxwanWorker: Started\n");

    StartReceiver();
    while(TRUE)
    {
	    rc = WaitForMultipleObjectsEx(
		    MAX_WAITABLE_OBJECTS,
		    hWaitableObject,
		    FALSE,			 // wait any
		    INFINITE,		 // timeout
		    TRUE			 // wait alertable, so we can run APCs
                    );
        if (Active) {
            ASSERT (((int)rc>=WAIT_OBJECT_0) && (rc<WAIT_OBJECT_0+MAX_WAITABLE_OBJECTS));
	        signaled_object = rc - WAIT_OBJECT_0;

	        if(signaled_object < MAX_WAITABLE_OBJECTS) {

	            // invoke the event handler
	            (*WaitableObjectHandler[signaled_object])();
	        }
            else
                SleepEx (3000, TRUE);
        }
        else
            break;
    }
    StopAdapterManager ();
    CloseIpxWanSocket ();
    DestroyWorkItemsManager ();

    for(i=0; i<MAX_WAITABLE_OBJECTS; i++) {
    	CloseHandle (hWaitableObject[i]);
    }
    Trace(INIT_TRACE, "IpxwanWorker: Finished\n");
    FreeLibraryAndExitThread (hModule, 0);
}

VOID
ProcessDequeuedIoPacket(DWORD		   ErrorCode,
			DWORD		   BytesTransferred,
			LPOVERLAPPED	   Overlappedp)
{
    PWORK_ITEM		wip;
    DWORD           nBytes;

    wip = CONTAINING_RECORD(Overlappedp, WORK_ITEM, Overlapped);
    IpxAdjustIoCompletionParams (Overlappedp, &nBytes, &wip->IoCompletionStatus); 

    switch(wip->Type) {

	case RECEIVE_PACKET_TYPE:

	    ReceiveComplete(wip);
	    break;

	default:

	    SendComplete(wip);
	    break;
    }
}


VOID
ProcessWorkItem(VOID)
{
    PLIST_ENTRY     lep;
    PWORK_ITEM	    wip;
    PACB	    acbp;

    ACQUIRE_QUEUES_LOCK;

    while(!IsListEmpty(&WorkersQueue)) {

	lep = RemoveHeadList(&WorkersQueue);
	wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

	RELEASE_QUEUES_LOCK;

	switch(wip->Type) {

	    case RECEIVE_PACKET_TYPE:

		ACQUIRE_DATABASE_LOCK;

		if((acbp = GetAdapterByIndex(wip->AdapterIndex)) != NULL) {

		    ACQUIRE_ADAPTER_LOCK(acbp);

		    RELEASE_DATABASE_LOCK;

		    ProcessReceivedPacket(acbp, wip);

		    RELEASE_ADAPTER_LOCK(acbp);
		}
		else
		{
		    RELEASE_DATABASE_LOCK;
		}

		RepostRcvPacket(wip);

		break;

	    default:

		// these are ReXmit packets referencing the adapter via ACB ptr
		acbp = wip->acbp;
		ACQUIRE_ADAPTER_LOCK(acbp);

		acbp->RefCount--;

		switch(wip->Type) {

		    case SEND_PACKET_TYPE:

			ProcessReXmitPacket(wip);
			break;

		    case WITIMER_TYPE:

			ProcessTimeout(wip);
			break;

		    default:

			SS_ASSERT(FALSE);
			break;
		}

		if(acbp->Discarded && (acbp->RefCount == 0)) {

		    ACQUIRE_DATABASE_LOCK;

		    // remove the adapter from the discarded list
		    RemoveEntryList(&acbp->Linkage);

		    RELEASE_DATABASE_LOCK;

		    Trace(ADAPTER_TRACE, "ProcessWorkItem: adpt# %d not referenced and discarded. Free CB",
			  acbp->AdapterIndex);

		    DeleteCriticalSection(&acbp->AdapterLock);

		    GlobalFree(acbp);
		}
		else
		{
		    RELEASE_ADAPTER_LOCK(acbp);
		}
	}

	ACQUIRE_QUEUES_LOCK;
    }

    RELEASE_QUEUES_LOCK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\io.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    io.c

Abstract:

    Contains the send/rcv packet routines

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

// nr of receive work items (receive packets) posted
ULONG		RcvPostedCount;

// nr of send worl items posted
ULONG		SendPostedCount;

// high and low water marks for the current count of posted rcv packets

#define     RCV_POSTED_LOW_WATER_MARK	    8
#define     RCV_POSTED_HIGH_WATER_MARK	    16

ULONG		RcvPostedLowWaterMark = RCV_POSTED_LOW_WATER_MARK;
ULONG		RcvPostedHighWaterMark = RCV_POSTED_HIGH_WATER_MARK;

DWORD
ReceiveSubmit(PWORK_ITEM	wip);


/*++

Function:	OpenIpxWanSocket

Descr:

--*/

HANDLE	    IpxWanSocketHandle;

DWORD
OpenIpxWanSocket(VOID)
{
    USHORT	ipxwansocket;

    PUTUSHORT2SHORT(&ipxwansocket, IPXWAN_SOCKET);

    if((IpxWanSocketHandle = CreateSocketPort(ipxwansocket)) == INVALID_HANDLE_VALUE) {

	Trace(INIT_TRACE, "CreateSocketPort FAILED!\n");

	return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

/*++

Function:	CloseIpxWanSocket

Descr:

--*/
DWORD
CloseIpxWanSocket(VOID)
{
    DWORD    rc;

    rc = DeleteSocketPort(IpxWanSocketHandle);

    Trace(INIT_TRACE, "IpxWan: DeleteSocketPort rc = %d\n", rc);

    while ((RcvPostedCount>0) || (SendPostedCount>0))
        SleepEx (1000, TRUE);

    return rc;
}


/*++

Function:	StartReceiver

Descr:		Starts allocating and posting receive
		work items until it reaches the low water mark.

--*/

VOID
StartReceiver(VOID)
{
    PWORK_ITEM	    wip;
    DWORD	    rc;

    ACQUIRE_QUEUES_LOCK;

    while(RcvPostedCount < RcvPostedLowWaterMark) {

	if((wip = AllocateWorkItem(RECEIVE_PACKET_TYPE)) == NULL) {

	    // !!! log something
	    break;
	}

	if((rc = ReceiveSubmit(wip)) != NO_ERROR) {

	    FreeWorkItem(wip);
	    break;
	}
    }

    RELEASE_QUEUES_LOCK;
}

/*++

Function:   RepostRcvPacket

Descr:

--*/

VOID
RepostRcvPacket(PWORK_ITEM	wip)
{
    ACQUIRE_QUEUES_LOCK;

    if(RcvPostedCount >= RcvPostedHighWaterMark) {

	// discard the received wi and don't repost
	FreeWorkItem(wip);
    }
    else
    {
	if(ReceiveSubmit(wip) != NO_ERROR) {

	    FreeWorkItem(wip);
	}
    }

    RELEASE_QUEUES_LOCK;
}


/*++

Function:	ReceiveComplete

Descr:		invoked in the io completion thread when a receive packet has completed.
		if the number of receive packets waiting to be processed is below
		the limit then
		   Enqueues the received packet work item in the WorkersQueue.
		Finally, it reposts a new receive packet if below the low water mark.

--*/

VOID
ReceiveComplete(PWORK_ITEM	wip)
{
    PWORK_ITEM	    newwip;
    DWORD	    rc;
    PUCHAR	    reservedp;

    reservedp = wip->AddressReserved.Reserved;
    wip->AdapterIndex =  GetNicId(reservedp);

    InterlockedDecrement(&RcvPostedCount);

	// repost if below water mark
    if (wip->IoCompletionStatus!=NO_ERROR) {
	    if((wip->IoCompletionStatus!=ERROR_OPERATION_ABORTED)
            && (wip->IoCompletionStatus!=ERROR_INVALID_HANDLE)) {

	        Trace(RECEIVE_TRACE, "Receive failed with error 0x%x\n",
	          wip->IoCompletionStatus);

            ACQUIRE_QUEUES_LOCK;
            if (RcvPostedCount < RcvPostedLowWaterMark) {

	            if(ReceiveSubmit(wip) == NO_ERROR) {
	                RELEASE_QUEUES_LOCK;
	                return;
                }
	        }
    	    RELEASE_QUEUES_LOCK;
        }
        // Closing, or enough posted already, or failed to repost
        FreeWorkItem(wip);
	    return;
	}


    //
    //** Process the received packet **
    //

    ACQUIRE_QUEUES_LOCK;
    // first repost a new receive packet if below water mark
    if(RcvPostedCount < RcvPostedLowWaterMark) {

	if((newwip = AllocateWorkItem(RECEIVE_PACKET_TYPE)) == NULL) {

	    Trace(RECEIVE_TRACE, "ReceiveComplete: Cannot allocate work item\n");
	}
	else
	{
	    // repost the new receive packet and increment the ref count
	    if((rc = ReceiveSubmit(newwip)) != NO_ERROR) {

		FreeWorkItem(newwip);
	    }
	}
    }

    EnqueueWorkItemToWorker(wip);

    RELEASE_QUEUES_LOCK;
}


/*++

Function:	SendComplete

Descr:		invoked in the worker thread APC when a send packet has completed

--*/

VOID
SendComplete(PWORK_ITEM     wip)
{
    InterlockedDecrement(&SendPostedCount);

    // if one time send packet type, free it
    if(!wip->ReXmitPacket) {

	FreeWorkItem(wip);
	return;
    }

    ACQUIRE_QUEUES_LOCK;

    wip->WiState = WI_SEND_COMPLETED;
    EnqueueWorkItemToWorker(wip);

    RELEASE_QUEUES_LOCK;
}


/*++

Function:      ReceiveSubmit

Descr:	       posts a receive packet work item for receive
	       increments the receive posted count

--*/

DWORD
ReceiveSubmit(PWORK_ITEM	wip)
{
    DWORD	rc;

    wip->Overlapped.hEvent = NULL;

    rc = IpxRecvPacket(IpxWanSocketHandle,
		       wip->Packet,
		       MAX_IPXWAN_PACKET_LEN,
		       &wip->AddressReserved,
		       &wip->Overlapped,
		       NULL);

    if(rc != NO_ERROR) {

	Trace(RECEIVE_TRACE, "Failed to submit receive error 0x%x\n", rc);
    }
    else
    {
	InterlockedIncrement(&RcvPostedCount);
    }

    return rc;
}



/*++

Function:      SendSubmit

Descr:	       posts a send packet work item for send to the adapter index
	       specified by the work item
	       increments the send statistics for the interface specified
	       by the work item

Remark:        >> called with the interface lock held <<

--*/


DWORD
SendSubmit(PWORK_ITEM		wip)
{
    DWORD	rc;
    USHORT	SendPacketLength;

    // get the length from the packet to send
    SendPacketLength = GETSHORT2USHORT(&SendPacketLength, wip->Packet + IPXH_LENGTH);
    wip->Overlapped.hEvent = NULL;

    rc = IpxSendPacket(IpxWanSocketHandle,
		       wip->AdapterIndex,
		       wip->Packet,
		       (ULONG)SendPacketLength,
		       &wip->AddressReserved,
		       &wip->Overlapped,
		       NULL);

    if(rc != NO_ERROR) {

	Trace(SEND_TRACE, "Failed to send the packet on adapter %d error 0x%x\n",
	      wip->acbp->AdapterIndex,
	      rc);
    }
    else
    {
	InterlockedIncrement(&SendPostedCount);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\adptmgr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    adptmgr.c

Abstract:

    This module contains the adapter management functions

Author:

    Stefan Solomon  12/02/1996

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define 	ADAPTER_INDEX_HASH_TABLE_SIZE	32

#define     adpthashindex(AdapterIndex)   (AdapterIndex) % ADAPTER_INDEX_HASH_TABLE_SIZE

LIST_ENTRY	AdapterHT[ADAPTER_INDEX_HASH_TABLE_SIZE];

LIST_ENTRY	DiscardedAdaptersList;

HANDLE		AdapterConfigPortHandle;

VOID
CreateAdapter(ULONG		AdapterIndex,
	      PADAPTER_INFO	AdapterInfo);

VOID
DeleteAdapter(ULONG	    AdapterIndex);

/*++

Function:	StartAdapterManager

Descr:		opens the IPX stack notification port for ipxwan

--*/

DWORD
StartAdapterManager(VOID)
{
    ADAPTERS_GLOBAL_PARAMETERS		AdptGlobalParameters;
    DWORD				rc, i;

    Trace(ADAPTER_TRACE, "StartAdapterManager: Entered\n");

    // create adapter config port
    if((AdapterConfigPortHandle = IpxWanCreateAdapterConfigurationPort(
	    hWaitableObject[ADAPTER_NOTIFICATION_EVENT],
	    &AdptGlobalParameters)) == INVALID_HANDLE_VALUE) {

	// can't create config port
	return ERROR_CAN_NOT_COMPLETE;
    }

    // create adapters hash table
    for(i=0; i<ADAPTER_INDEX_HASH_TABLE_SIZE; i++) {

	InitializeListHead(&AdapterHT[i]);
    }

    // create discarded adapters list
    InitializeListHead(&DiscardedAdaptersList);

    return NO_ERROR;
}

/*++

Function:	AddToAdapterHt

Descr:		Adds the adapter control block to the hash table of adapters

Remark: 	>> called with database lock held <<

--*/

VOID
AddToAdapterHt(PACB	    acbp)
{
    int 	    hv;
    PLIST_ENTRY     lep;
    PACB	    list_acbp;

    // insert in index hash table
    hv = adpthashindex(acbp->AdapterIndex);
    InsertTailList(&AdapterHT[hv], &acbp->Linkage);
}

/*++

Function:	RemoveFromAdapterHt

Descr:

Remark: 	>> called with database lock held <<

--*/

VOID
RemoveFromAdapterHt(PACB	acbp)
{
    RemoveEntryList(&acbp->Linkage);
}

/*++

Function:	GetAdapterByIndex

Descr:

Remark: 	>> called with database lock held <<

--*/

PACB
GetAdapterByIndex(ULONG	    AdptIndex)
{
    PACB	    acbp;
    PLIST_ENTRY     lep;
    int 	    hv;

    hv = adpthashindex(AdptIndex);

    lep = AdapterHT[hv].Flink;

    while(lep != &AdapterHT[hv])
    {
	acbp = CONTAINING_RECORD(lep, ACB, Linkage);
	if (acbp->AdapterIndex == AdptIndex) {

	    return acbp;
	}

	lep = acbp->Linkage.Flink;
    }

    return NULL;
}

/*++

Function:	StopAdapterManager

Descr:		Closes the IPX notification port

--*/

VOID
StopAdapterManager(VOID)
{
    DWORD	    rc;
    ULONG	    AdapterIndex;

    Trace(ADAPTER_TRACE, "StopAdapterManager: Entered\n");

    // Close the IPX stack notification port
    IpxDeleteAdapterConfigurationPort(AdapterConfigPortHandle);
}

/*++

Function:	    AdapterNotification

Descr:		    Processes adapter notification events

--*/

VOID
AdapterNotification(VOID)
{
    ADAPTER_INFO    AdapterInfo;
    ULONG	    AdapterIndex;
    ULONG	    AdapterConfigurationStatus;
    ULONG	    AdapterNameSize;
    LPWSTR	    AdapterNameBuffer;
    DWORD	    rc;

    Trace(ADAPTER_TRACE, "AdapterNotification: Entered\n");

    while((rc = IpxGetQueuedAdapterConfigurationStatus(
					AdapterConfigPortHandle,
					&AdapterIndex,
					&AdapterConfigurationStatus,
					&AdapterInfo)) == NO_ERROR) {

	switch(AdapterConfigurationStatus) {

	    case ADAPTER_CREATED:

		// got the adapter name, create the adapter
		CreateAdapter(AdapterIndex,
			      &AdapterInfo);
		break;

	    case ADAPTER_DELETED:

		DeleteAdapter(AdapterIndex);
		break;

	    default:

		SS_ASSERT(FALSE);
		break;
	 }
    }
}

/*++

Function:	CreateAdapter

Descr:

--*/

VOID
CreateAdapter(ULONG		AdapterIndex,
	      PADAPTER_INFO	AdapterInfo)
{
    PACB	    acbp;

    Trace(ADAPTER_TRACE, "CreateAdapter: Entered for adpt# %d", AdapterIndex);

    if((acbp = (PACB)GlobalAlloc(GPTR, sizeof(ACB))) == NULL) {

	Trace(ADAPTER_TRACE, "CreateAdapter: Cannot allocate adapter control block\n");
	IpxcpConfigDone(AdapterInfo->ConnectionId,
			NULL,
			NULL,
			NULL,
			FALSE);
	return;
    }

    ACQUIRE_DATABASE_LOCK;

    acbp->AdapterIndex = AdapterIndex;
    acbp->ConnectionId = AdapterInfo->ConnectionId;
    acbp->Discarded = FALSE;

    InitializeCriticalSection(&acbp->AdapterLock);

    AddToAdapterHt(acbp);

    ACQUIRE_ADAPTER_LOCK(acbp);

    RELEASE_DATABASE_LOCK;

    // initialize and start the protocol negotiation on this adapter
    StartIpxwanProtocol(acbp);

    RELEASE_ADAPTER_LOCK(acbp);
}


/*++

Function:	DeleteAdapter

Descr:

Remark: 	If adapter gets deleted IPXCP is also informed by PPP that
		the connection has been terminated.
--*/

VOID
DeleteAdapter(ULONG	    AdapterIndex)
{
    PACB	acbp;

    ACQUIRE_DATABASE_LOCK;

    if((acbp = GetAdapterByIndex(AdapterIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return;
    }

    Trace(ADAPTER_TRACE, "DeleteAdapter: Entered for adpt# %d", AdapterIndex);

    ACQUIRE_ADAPTER_LOCK(acbp);

    StopIpxwanProtocol(acbp);

    RemoveFromAdapterHt(acbp);

    if(acbp->RefCount) {

	InsertTailList(&DiscardedAdaptersList, &acbp->Linkage);

	acbp->Discarded = TRUE;

	Trace(ADAPTER_TRACE, "DeleteAdapter: adpt# %d still referenced, inserted in discarded list", AdapterIndex);

	RELEASE_ADAPTER_LOCK(acbp);
    }
    else
    {
	DeleteCriticalSection(&acbp->AdapterLock);

	Trace(ADAPTER_TRACE, "DeleteAdapter: adpt# %d not referenced, free CB", AdapterIndex);

	GlobalFree(acbp);
    }

    RELEASE_DATABASE_LOCK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\ipxwan.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

   ipxwan.h

Abstract:

    This module contains the definitions of the internal control structures
    used by the ipxwan protocol module

Author:

    Stefan Solomon  02/06/1996

Revision History:


--*/

#ifndef _IPXWAN_
#define _IPXWAN_

// adapter control block

typedef struct _ACB {

    ULONG		AdapterIndex;
    CRITICAL_SECTION	AdapterLock;
    LIST_ENTRY		Linkage;	// linkage in the adapter HT
    ULONG		ConnectionId;	// identifies the connection. Used to reference
					// the coresponding IPXCP control block
    ULONG		RefCount;	// nr of work items keeping a reference to me
    BOOL		Discarded;
    BOOL		SlaveTimerStarted;

    // IPXWAN States

    ULONG		OperState;	// UP/DOWN
    ULONG		AcbLevel;	// IPXWAN Negotiation State (Level), see below
    ULONG		AcbRole;	// Master or Slave, see below

    // IPXWAN Retransmission

    ULONG		ReXmitCount;
    UCHAR		ReXmitSeqNo;
    ULONG		TReqTimeStamp;	// time when the timer request has been sent

    // IPXWAN Database

    ULONG		InterfaceType;		// identifies who is this interface, see below
    UCHAR		InternalNetNumber[4];
    UCHAR		WNodeId[4];		// node id sent in timer request
    BOOL		IsExtendedNodeId;	// tells if we send this option
    UCHAR		ExtendedWNodeId[4];
    ULONG		SupportedRoutingTypes;	// supported routing types flags
    USHORT		LinkDelay;

    // IPXWAN Negotiated Values

    ULONG		RoutingType;
    UCHAR		Network[4];
    UCHAR		LocalNode[6];
    UCHAR		RemoteNode[6];

    // allocated wan net number

    ULONG		AllocatedNetworkIndex;

    } ACB, *PACB;

// ACB States

#define     ACB_TIMER_LEVEL	    0
#define     ACB_INFO_LEVEL	    1
#define     ACB_CONFIGURED_LEVEL    2

// ACB Roles

#define     ACB_UNKNOWN_ROLE	    0
#define     ACB_MASTER_ROLE	    1
#define     ACB_SLAVE_ROLE	    2

// Interface Type:
//
// InterfaceType				Local	Remote
//---------------------------------------------------------------
// IF_TYPE_WAN_ROUTER				Router	Router
// IF_TYPE_WAN_WORKSTATION			Router	Wksta
// IF_TYPE_PERSONAL_WAN_ROUTER			Router	Pers.Router
// IF_TYPE_ROUTER_WORKSTATION_DIALOUT		Wksta	Router
// IF_TYPE_STANDALONE_WKSTA_DIALOUT		Wksta	Router

// Routing Types Flags

#define     NUMBERED_RIP_FLAG			0x00000001
#define     ON_DEMAND_ROUTING_FLAG		0x00000002
#define     WORKSTATION_FLAG			0x00000004
#define     UNNUMBERED_RIP_FLAG 		0x00000008

#define     IS_NUMBERED_RIP(rt)		     (rt) & NUMBERED_RIP_FLAG
#define     IS_ON_DEMAND_ROUTING(rt)	     (rt) & ON_DEMAND_ROUTING_FLAG
#define     IS_WORKSTATION(rt)		     (rt) & WORKSTATION_FLAG
#define     IS_UNNUMBERED_RIP(rt)	     (rt) & UNNUMBERED_RIP_FLAG

#define     SET_NUMBERED_RIP(rt)	     (rt) |= NUMBERED_RIP_FLAG
#define     SET_ON_DEMAND_ROUTING(rt)	     (rt) |= ON_DEMAND_ROUTING_FLAG
#define     SET_WORKSTATION(rt)		     (rt) |= WORKSTATION_FLAG
#define     SET_UNNUMBERED_RIP(rt)	     (rt) |= UNNUMBERED_RIP_FLAG

// work item

typedef enum _WORK_ITEM_TYPE {

    RECEIVE_PACKET_TYPE,
    SEND_PACKET_TYPE,
    WITIMER_TYPE

    } WORK_ITEM_TYPE, *PWORK_ITEM_TYPE;

typedef struct _WORK_ITEM {

    LIST_ENTRY		Linkage;	   // timer queue or worker queue
    WORK_ITEM_TYPE	Type;		   // work item type
    DWORD		DueTime;	   // used by the timer
    PACB		acbp;		   // pointer to the referenced adapter control block

    // work item state and rexmit fields

    BOOL		ReXmitPacket;	   // true for re-xmit packets
    ULONG		WiState;	   // states of work item, see below

    // io & packet data

    ULONG		AdapterIndex;
    DWORD		IoCompletionStatus;
    OVERLAPPED		Overlapped;
    ADDRESS_RESERVED	AddressReserved;
    UCHAR		Packet[1];

    } WORK_ITEM, *PWORK_ITEM;

// work item states

#define     WI_INIT			    0
#define     WI_SEND_COMPLETED		    1
#define     WI_WAITING_TIMEOUT		    2
#define     WI_TIMEOUT_COMPLETED	    3

// IPXWAN Worker Thread waitable objects definitions

#define     ADAPTER_NOTIFICATION_EVENT	    0
#define     WORKERS_QUEUE_EVENT		    1
#define     TIMER_HANDLE		    2

#define     MAX_EVENTS			    2
#define     MAX_WAITABLE_OBJECTS	    3

#define ACQUIRE_DATABASE_LOCK	  EnterCriticalSection(&DbaseCritSec)
#define RELEASE_DATABASE_LOCK	  LeaveCriticalSection(&DbaseCritSec)

#define ACQUIRE_QUEUES_LOCK	  EnterCriticalSection(&QueuesCritSec)
#define RELEASE_QUEUES_LOCK	  LeaveCriticalSection(&QueuesCritSec)

#define ACQUIRE_ADAPTER_LOCK(acbp)	EnterCriticalSection(&(acbp)->AdapterLock)
#define RELEASE_ADAPTER_LOCK(acbp)	LeaveCriticalSection(&(acbp)->AdapterLock)

// macro to assess if time1 is later then time2 when both are ulong with wrap around
#define IsLater(time1, time2)	  (((time1) - (time2)) < MAXULONG/2)


extern	    LIST_ENTRY		TimerQueue;
extern	    HANDLE		IpxWanSocketHandle;
extern	    HANDLE		hWaitableObject[];
extern	    CRITICAL_SECTION	DbaseCritSec;
extern	    CRITICAL_SECTION	QueuesCritSec;
extern	    LIST_ENTRY		WorkersQueue;
extern	    ULONG		EnableUnnumberedWanLinks;

#define     REXMIT_TIMEOUT	20000		   // 20 sec rexmit timeout
#define     MAX_REXMIT_COUNT	16
#define     SLAVE_TIMEOUT	60000		   // 1 minute slave timeout

extern DWORD (WINAPI *IpxcpGetWanNetNumber)(IN OUT PUCHAR		Network,
					 IN OUT PULONG		AllocatedNetworkIndexp,
					 IN	ULONG		InterfaceType);

extern VOID  (WINAPI *IpxcpReleaseWanNetNumber)(ULONG	    AllocatedNetworkIndex);

extern DWORD (WINAPI *IpxcpConfigDone)(ULONG		ConnectionId,
			  PUCHAR	Network,
			  PUCHAR	LocalNode,
			  PUCHAR	RemoteNode,
			  BOOL		Success);

extern VOID  (WINAPI *IpxcpGetInternalNetNumber)(PUCHAR	Network);

extern ULONG (WINAPI *IpxcpGetInterfaceType)(ULONG	    ConnectionId);

extern DWORD (WINAPI *IpxcpGetRemoteNode)(ULONG	    ConnectionId,
			     PUCHAR	    RemoteNode);

extern BOOL (WINAPI *IpxcpIsRoute)(PUCHAR	  Network);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\iwdbg.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    iwdbg.h

Abstract:

    This module contains the debug utilities definitions

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _IWDBG_
#define _IWDBG_

//*** Tracing Components IDs ***

#define     INIT_TRACE		    0x00010000
#define     ADAPTER_TRACE	    0x00020000
#define     RECEIVE_TRACE	    0x00040000
#define     SEND_TRACE		    0x00080000
#define     TIMER_TRACE 	    0x00100000
#define     IPXWAN_TRACE	    0x00200000
#define     IPXWAN_ALERT	    0x80000000

#if DBG

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

#define SS_ASSERT(exp) if (!(exp)) SsAssert( #exp, __FILE__, __LINE__ )

#else

#define SS_ASSERT(exp)

#endif // DBG

VOID
StartTracing(VOID);

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...);

VOID
StopTracing(VOID);

#endif // ndef _IWDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\iwdbg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    iwdbg.c

Abstract:

    The debug functions

Author:

    Stefan Solomon  03/11/1996

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//*** TRACE ID FOR IPXWAN ***

DWORD	    IpxWanTraceID;

//*** Functions for Debug Printing ***

#if DBG

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    Trace(IPXWAN_ALERT, "\nAssertion failed: %s\n  at line %ld of %s\n",
		FailedAssertion, LineNumber, FileName);

    DbgUserBreakPoint( );

} // SsAssert

#endif

VOID
StartTracing(VOID)
{
    IpxWanTraceID = TraceRegister("IPXWAN");
}

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...)
{
    va_list	arglist;

    va_start(arglist, Format);

    TraceVprintfEx(IpxWanTraceID,
		   ComponentID | TRACE_USE_MASK,
		   Format,
		   arglist);

    va_end(arglist);
}

VOID
StopTracing(VOID)
{
    TraceDeregister(IpxWanTraceID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\inc\ipxif.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxif.h

Abstract:

    This module contains the definitions of the some direct IPX stack IOCtls
    used by IPXCP

Author:

    Stefan Solomon  11/08/1995

Revision History:


--*/

// This function return the counter in minutes since last activity
// occured on this connection.
//
//  Parameters:
//			ConnectionId - identifies the connection passed in LineUp
//				       to the IPX stack
//			IpxConnectionHandle - initially -1 and filled by the
//					      IPX stack on return to the value
//					      corresponding to the connection Id
//					      In subsequent calls this is used.
//			WanInnnactivityCounter -
//
//

DWORD
IpxGetWanInactivityCounter(
		    IN ULONG	    ConnectionId,
		    IN PULONG	    IpxConnectionHandle,
		    IN PULONG	    WanInactivityCounter);


//  This function checks if the specified network exists on the net
//  If there is no router installed, it does a re-rip to find out
//
//  Return:	    TRUE    - The net number is in use

BOOL
IpxIsRoute(PUCHAR	Network);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\packet.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	packet.h
//
// Description: Contains general definitions for the ipx and ipxwan packets
//
// Author:	Stefan Solomon (stefans)    February 6, 1996.
//
// Revision History:
//
//***

#ifndef _PACKET_
#define _PACKET_

// IPXWAN Packets Format:
//
//	IPX header	 - fixed length
//	IPXWAN header	 - fixed length
//	IPXWAN option 1  - fixed length header + variable length data
//	....
//	IPXWAN option n


//*** Socket Numbers
#undef IPXWAN_SOCKET
#define IPXWAN_SOCKET	    (USHORT)0x9004

//*** IPXWAN Confidence Identifier

#define IPXWAN_CONFIDENCE_ID	  "WASM" // 0x5741534D

//*** IPX Packet Exchange Type (encapsulating the IPXWAN packet)

#define IPX_PACKET_EXCHANGE_TYPE    4

//*** Offsets into the IPX header

#define IPXH_HDRSIZE	    30	    // Size of the IPX header

#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH	    2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET	    18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

#define IPX_NET_LEN	    4
#define IPX_NODE_LEN	    6

//*** Offsets of the IPXWAN header

#define IPXWAN_HDRSIZE	    11

#define WIDENTIFIER	    0
#define WPACKET_TYPE	    4
#define WNODE_ID	    5
#define WSEQUENCE_NUMBER    9
#define WNUM_OPTIONS	    10

// packet types

#define TIMER_REQUEST		0
#define TIMER_RESPONSE		1
#define INFORMATION_REQUEST	2
#define INFORMATION_RESPONSE	3
#define NAK			0xFF

// IPXWAN option format
//
//     IPXWAN option header  - fixed length
//     IPXWAN option data    - variable length


//*** Offsets of the IPXWAN Option header

#define OPTION_HDRSIZE	    4

#define WOPTION_NUMBER	    0	// identifies a particular option, see list below
#define WACCEPT_OPTION	    1	// see below
#define WOPTION_DATA_LEN    2	// length of the option data part
#define WOPTION_DATA	    4

// accept option definitions

#define NO		    0
#define YES		    1
#define NOT_APPLICABLE	    3

// option definitions

//*** Routing Type Option ***

#define ROUTING_TYPE_OPTION	    0	 // option number
#define ROUTING_TYPE_DATA_LEN	    1

// values of the data part

#define NUMBERED_RIP_ROUTING_TYPE		    0
#define NLSP_ROUTING_TYPE			    1
#define UNNUMBERED_RIP_ROUTING_TYPE		    2
#define ON_DEMAND_ROUTING_TYPE			    3
#define WORKSTATION_ROUTING_TYPE		    4	// client-router connection

//*** Extended Node Id Option ***

#define EXTENDED_NODE_ID_OPTION     4
#define EXTENDED_NODE_ID_DATA_LEN   4

//*** RIP/SAP Info Exchange Option ***

#define RIP_SAP_INFO_EXCHANGE_OPTION	1
#define RIP_SAP_INFO_EXCHANGE_DATA_LEN	54

// values
// offsets in the data part (from the beginning of the option header)

#define WAN_LINK_DELAY		    4
#define COMMON_NETWORK_NUMBER	    6
#define ROUTER_NAME		    10

//*** Node Number Option ***

#define NODE_NUMBER_OPTION	    5
#define NODE_NUMBER_DATA_LEN	    6

// values
// IPX node number to be used by the client on a client-router connection.

//*** Pad Option ***

#define PAD_OPTION		    0xFF

// Unsupported Options

#define NLSP_INFORMATION_OPTION		2
#define NLSP_RAW_THROUGHPUT_DATA_OPTION	3
#define COMPRESSION_OPTION		0x80

//*** Packet Lengths ***

#define TIMER_REQUEST_PACKET_LENGTH	576
#define MAX_IPXWAN_PACKET_LEN		TIMER_REQUEST_PACKET_LENGTH

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dim.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <adapter.h>
#include <ipxcpcom.h>
#include <rtutils.h>
#include "ipxwan.h"
#include "packet.h"
#include "prot.h"
#include "utils.h"
#include "iwdbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\prot.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

   prot.h

Abstract:


Author:

    Stefan Solomon  02/06/1996

Revision History:


--*/

DWORD
CreateWorkItemsManager(VOID);

DWORD
OpenIpxWanSocket(VOID);

DWORD
CloseIpxWanSocket(VOID);

DWORD
StartAdapterManager(VOID);

VOID
StopAdapterManager(VOID);

PACB
GetAdapterByIndex(ULONG        AdapterIndex);

VOID
ProcessReceivedPacket(PACB	  acbp,
		      PWORK_ITEM  wip);

VOID
RepostRcvPacket(PWORK_ITEM	  wip);

VOID
ProcessReXmitPacket(PWORK_ITEM	      wip);

VOID
ProcessTimeout(PWORK_ITEM	 wip);

VOID
AdapterNotification(VOID);

VOID
ProcessTimerQueue(VOID);

VOID
StartWiTimer(PWORK_ITEM 	reqwip,
	     ULONG		timeout);

VOID
StopWiTimer(PACB	      acbp);

DWORD
CreateWorkItemsManager(VOID);

VOID
DestroyWorkItemsManager(VOID);

PWORK_ITEM
AllocateWorkItem(ULONG	      Type);

VOID
FreeWorkItem(PWORK_ITEM     wip);

VOID
EnqueueWorkItemToWorker(PWORK_ITEM	wip);

VOID
StartReceiver(VOID);

VOID
ReceiveComplete(PWORK_ITEM	wip);

VOID
SendComplete(PWORK_ITEM     wip);

VOID
StartIpxwanProtocol(PACB	acbp);

VOID
StopIpxwanProtocol(PACB 	acbp);

DWORD
SendSubmit(PWORK_ITEM		wip);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\protocol.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    ipxwan protocol processing

Author:

    Stefan Solomon  02/14/1996

Revision History:


--*/

#include    "precomp.h"
#pragma     hdrstop

PCHAR	    Workstationp = "WORKSTATION";
PCHAR	    NumberedRip = "NUMBERED RIP";
PCHAR	    UnnumberedRip = "UNNUMBERED RIP";
PCHAR	    OnDemand = "ON DEMAND, STATIC ROUTING";


DWORD
GeneratePacket(PACB	    acbp,
	       PUCHAR	    ipxhdrp,
	       UCHAR	    PacketType);

ULONG
GetRole(PUCHAR		hdrp,
	PACB		acbp);

DWORD
StartSlaveTimer(PACB	    acbp);

DWORD
ProcessInformationResponsePacket(PACB	    acbp,
				 PUCHAR     rcvhdrp);

DWORD
MakeTimerRequestPacket(PACB	    acbp,
		       PUCHAR	    rcvhdrp,
		       PUCHAR	    hdrp);

DWORD
MakeTimerResponsePacket(PACB		acbp,
			PUCHAR		rcvhdrp,
			PUCHAR		hdrp);

DWORD
MakeInformationRequestPacket(PACB	    acbp,
			     PUCHAR	    rcvhdrp,
			     PUCHAR	    hdrp);

DWORD
MakeInformationResponsePacket(PACB		acbp,
			      PUCHAR		rcvhdrp,
			      PUCHAR		hdrp);

DWORD
MakeNakPacket(PACB		acbp,
	      PUCHAR		rcvhdrp,
	      PUCHAR		hdrp);

DWORD
SendReXmitPacket(PACB		    acbp,
		 PWORK_ITEM	    wip);

VOID
fillpadding(PUCHAR	    padp,
	    ULONG	    len);

//** AcbFailure **

// after this macro is called, clean-up for this adapter is done as follows:
// ipxcp will delete the route (as in ndiswan route to ipx stack)
// this will trigger an adapter deleted indication which will call StopIpxwanProtocol
// this last call will flush the timer queue
// when all pending work items are freed the adapter gets deleted

#define     AcbFailure(acbp)	    Trace(IPXWAN_TRACE, "IPXWAN Configuration failed for adapter %d\n", (acbp)->AdapterIndex);\
				    (acbp)->OperState = OPER_STATE_DOWN;\
				    IpxcpConfigDone((acbp)->ConnectionId, NULL, NULL, NULL, FALSE);

UCHAR	    allffs[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
UCHAR	    allzeros[] = { 0, 0, 0, 0, 0, 0 };

#define     ERROR_IGNORE_PACKET 	1
#define     ERROR_DISCONNECT		2
#define     ERROR_GENERATE_NAK		3

/*++

Function:	StartIpxwanProtocol

Descr:		Called when an adapter is created.
		Starts IPXWAN negotiation on this adapter.

Remark: 	>> called with the adapter lock held <<

--*/

VOID
StartIpxwanProtocol(PACB	acbp)
{
    PWORK_ITEM	    wip;

    Trace(IPXWAN_TRACE, "StartIpxwanProtocol: Entered for adapter # %d\n", acbp->AdapterIndex);

    // initialize the IPXWAN states

    acbp->OperState = OPER_STATE_UP;
    acbp->AcbLevel = ACB_TIMER_LEVEL;
    acbp->AcbRole = ACB_UNKNOWN_ROLE;

    // initialize the IPXWAN database

    acbp->InterfaceType = IpxcpGetInterfaceType(acbp->ConnectionId);
    if((acbp->InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT) ||
       (acbp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT)) {

	memset(acbp->InternalNetNumber, 0, 4);
    }
    else
    {
	IpxcpGetInternalNetNumber(acbp->InternalNetNumber);
    }

    acbp->IsExtendedNodeId = FALSE;
    acbp->SupportedRoutingTypes = 0;

    // set the routing type and node id to be sent in timer request
    switch(acbp->InterfaceType) {

	case IF_TYPE_WAN_ROUTER:
	case IF_TYPE_PERSONAL_WAN_ROUTER:

	    if(EnableUnnumberedWanLinks) {

		memset(acbp->WNodeId, 0, 4);
		acbp->IsExtendedNodeId = TRUE;
		memcpy(acbp->ExtendedWNodeId, acbp->InternalNetNumber, 4);

		SET_UNNUMBERED_RIP(acbp->SupportedRoutingTypes);
	    }
	    else
	    {
		memcpy(acbp->WNodeId, acbp->InternalNetNumber, 4);
		SET_NUMBERED_RIP(acbp->SupportedRoutingTypes);
	    }

	    break;

	case IF_TYPE_WAN_WORKSTATION:

	    memcpy(acbp->WNodeId, acbp->InternalNetNumber, 4);
	    SET_WORKSTATION(acbp->SupportedRoutingTypes);
	    SET_NUMBERED_RIP(acbp->SupportedRoutingTypes);
	    break;

	case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:
	case IF_TYPE_STANDALONE_WORKSTATION_DIALOUT:

	    memset(acbp->WNodeId, 0, 4);
	    SET_WORKSTATION(acbp->SupportedRoutingTypes);

	    break;

	default:

	    Trace(IPXWAN_TRACE, "StartIpxwanProtocol: adpt# %d, Invalid interface type, DISCONNECT",
		  acbp->AdapterIndex);
	    SS_ASSERT(FALSE);

	    AcbFailure(acbp);
	    break;
    }

    // init negotiated values

    acbp->RoutingType = 0;
    memset(acbp->Network, 0, 4);
    memset(acbp->LocalNode, 0, 6);
    memset(acbp->RemoteNode, 0, 6);

    // no net number allocated yet
    acbp->AllocatedNetworkIndex = INVALID_NETWORK_INDEX;

    if(GeneratePacket(acbp, NULL, TIMER_REQUEST) != NO_ERROR) {

	Trace(IPXWAN_TRACE, "StartIpxwanProtocol: adpt# %d, ERROR: cannot generate TIMER_REQUEST, DISCONNECT\n",
	      acbp->AdapterIndex);

	AcbFailure(acbp);
    }
    else
    {
	Trace(IPXWAN_TRACE, "StartIpxwanProtocol: adpt# %d, Sent TIMER_REQUEST\n",
	      acbp->AdapterIndex);
    }
}

/*++

Function:	StopIpxwanProtocol

Descr:		Called when an adapter is deleted.
		Stops IPXWAN negotiation if still going.

Remark: 	>> called with the adapter lock held <<

--*/

VOID
StopIpxwanProtocol(PACB 	acbp)
{
    Trace(IPXWAN_TRACE, "StopIpxwanProtocol: Entered for adapter # %d\n", acbp->AdapterIndex);

    acbp->OperState = OPER_STATE_DOWN;

    // remove all work items referencing this acb from the timer queue
    StopWiTimer(acbp);

    // free allocated wan net if any
    if(acbp->AllocatedNetworkIndex != INVALID_NETWORK_INDEX) {

	IpxcpReleaseWanNetNumber(acbp->AllocatedNetworkIndex);
    }
}

/*++

Function:   IpxwanConfigDone

Descr:	    remove items referencing this acb from the timer queue
	    sets the new configured values in the ipx stack

Remark:     >> called with the adapter lock held <<

--*/

VOID
IpxwanConfigDone(PACB	    acbp)
{
    DWORD	    rc;
    IPXWAN_INFO     IpxwanInfo;

    StopWiTimer(acbp);

    memcpy(IpxwanInfo.Network, acbp->Network, 4);
    memcpy(IpxwanInfo.LocalNode, acbp->LocalNode, 6);
    memcpy(IpxwanInfo.RemoteNode, acbp->RemoteNode, 6);

    rc = IpxWanSetAdapterConfiguration(acbp->AdapterIndex,
				       &IpxwanInfo);

    if(rc != NO_ERROR) {

	Trace(IPXWAN_TRACE, "IpxwanConfigDone: Error %d in IpxWanSetAdapterConfiguration\n",
	      rc);
	AcbFailure(acbp);
	SS_ASSERT(FALSE);
    }
    else
    {
	IpxcpConfigDone(acbp->ConnectionId,
			acbp->Network,
			acbp->LocalNode,
			acbp->RemoteNode,
			TRUE);

	Trace(IPXWAN_TRACE,"\n*** IPXWAN final configuration ***");
	Trace(IPXWAN_TRACE,"    Network:     %.2x%.2x%.2x%.2x\n",
		   acbp->Network[0],
		   acbp->Network[1],
		   acbp->Network[2],
		   acbp->Network[3]);

	Trace(IPXWAN_TRACE,"    LocalNode:   %.2x%.2x%.2x%.2x%.2x%.2x",
		   acbp->LocalNode[0],
		   acbp->LocalNode[1],
		   acbp->LocalNode[2],
		   acbp->LocalNode[3],
		   acbp->LocalNode[4],
		   acbp->LocalNode[5]);

	Trace(IPXWAN_TRACE,"    RemoteNode:  %.2x%.2x%.2x%.2x%.2x%.2x",
		   acbp->RemoteNode[0],
		   acbp->RemoteNode[1],
		   acbp->RemoteNode[2],
		   acbp->RemoteNode[3],
		   acbp->RemoteNode[4],
		   acbp->RemoteNode[5]);
    }
}

/*++

Function:	ProcessReceivedPacket

Descr:

Remark: 	>> called with the adapter lock held <<

--*/

VOID
ProcessReceivedPacket(PACB		acbp,
		      PWORK_ITEM	wip)
{
    PUCHAR	    ipxhdrp;	  // ipx header
    PUCHAR	    wanhdrp;	  // ipx wan header
    PUCHAR	    opthdrp;	  // option header
    DWORD	    rc = NO_ERROR;
    USHORT	    pktlen;
    ULONG	    role;
    USHORT	    rcvsocket;
    PCHAR	    Slavep = "SLAVE";
    PCHAR	    Masterp = "MASTER";

    if(acbp->OperState == OPER_STATE_DOWN) {

	return;
    }

    // validate packet
    ipxhdrp = wip->Packet;

    // check the packet length
    GETSHORT2USHORT(&pktlen, ipxhdrp + IPXH_LENGTH);

    if(pktlen > MAX_IPXWAN_PACKET_LEN) {

	// bad length packet
	Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Reject packet because of invalid length %d\n", pktlen);
	return;
    }

    // check remote socket and confidence id
    GETSHORT2USHORT(&rcvsocket, ipxhdrp + IPXH_SRCSOCK);
    if(rcvsocket != IPXWAN_SOCKET) {

	Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Reject packet because of invalid socket %x\n", rcvsocket);
	return;
    }

    wanhdrp = ipxhdrp + IPXH_HDRSIZE;

    if(memcmp(wanhdrp + WIDENTIFIER,
	      IPXWAN_CONFIDENCE_ID,
	      4)) {

	// no confidence
	Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Reject packet because of invalid confidence id\n");
	return;
    }

    switch(*(wanhdrp + WPACKET_TYPE)) {

	case TIMER_REQUEST:

	    role = GetRole(ipxhdrp, acbp);

	    switch(role) {

		case ACB_SLAVE_ROLE:

		    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd TIMER_REQUEST adpt# %d, local role %s",
			  acbp->AdapterIndex,
			  Slavep);

		    acbp->AcbRole = ACB_SLAVE_ROLE;
		    acbp->RoutingType = 0;

		    if(acbp->AcbLevel != ACB_TIMER_LEVEL) {

			acbp->AcbLevel = ACB_TIMER_LEVEL;
		    }

		    rc = GeneratePacket(acbp, ipxhdrp, TIMER_RESPONSE);

		    switch(rc) {

			case NO_ERROR:

			    acbp->AcbLevel = ACB_INFO_LEVEL;

			    // start the slave timeout
			    if(StartSlaveTimer(acbp) != NO_ERROR) {

				Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT adpt# %d: cannot start slave timer",
				      acbp->AdapterIndex);
				AcbFailure(acbp);
			    }

			    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: TIMER_RESPONSE sent OK on adpt # %d",
				  acbp->AdapterIndex);

			    break;

			case ERROR_DISCONNECT:

			    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT: Error generating TIMER_RESPONSE on adpt# %d",
				  acbp->AdapterIndex);
			    AcbFailure(acbp);
			    break;

			case ERROR_IGNORE_PACKET:
			default:

			    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Ignore received TIMER_REQUEST on adpt# %d",
				  acbp->AdapterIndex);
			    break;
		    }

		case ACB_MASTER_ROLE:

		    if(acbp->AcbLevel != ACB_TIMER_LEVEL) {

			// ignore
			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: ignore TIMER_REQUEST on adpt# %d because not at TIMER LEVEL",
			      acbp->AdapterIndex);
			return;
		    }
		    else
		    {
			 acbp->AcbRole = ACB_MASTER_ROLE;
			 Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd TIMER_REQUEST adpt# %d, local role %s",
			       acbp->AdapterIndex,
			       Masterp);
		    }

		    break;

		default:

		    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT adpt# %d: Unknown role with rcvd TIMER_REQUEST",
			  acbp->AdapterIndex);
		    AcbFailure(acbp);
	    }

	    break;

	case TIMER_RESPONSE:

	    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd TIMER_RESPONSE on adpt# %d",
		  acbp->AdapterIndex);

	    // validate
	    if((acbp->AcbRole == ACB_SLAVE_ROLE) ||
	       !(acbp->AcbLevel == ACB_TIMER_LEVEL)) {

		Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd TIMER_RESPONSE, DISCONNECT adpt# %d: role not MASTER or state not TIMER LEVEL",
		      acbp->AdapterIndex);
		AcbFailure(acbp);
	    }
	    else if(*(wanhdrp + WSEQUENCE_NUMBER) == acbp->ReXmitSeqNo) {

		// rfc 1634 - link delay calculation
		acbp->LinkDelay = (USHORT)((GetTickCount() - acbp->TReqTimeStamp) * 6);

		rc = GeneratePacket(acbp, ipxhdrp, INFORMATION_REQUEST);

		switch(rc) {

		    case NO_ERROR:

			acbp->AcbLevel = ACB_INFO_LEVEL;
			acbp->AcbRole = ACB_MASTER_ROLE;

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: INFORMATION_REQUEST sent OK on adpt # %d",
			      acbp->AdapterIndex);

			break;

		    case ERROR_DISCONNECT:

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT adpt# %d: Error generating INFORMATION_REQUEST",
			      acbp->AdapterIndex);
			AcbFailure(acbp);
			break;

		    case ERROR_IGNORE_PACKET:
		    default:

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Ignore received TIMER_RESPONSE on adpt# %d",
			      acbp->AdapterIndex);

			break;
		}
	    }
	    else
	    {
		Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Ignore TIMER RESPONSE and adpt# %d, non-matching seq no",
		      acbp->AdapterIndex);
	    }

	    break;

	case INFORMATION_REQUEST:

	    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd INFORMATION_REQUEST on adpt# %d",
		  acbp->AdapterIndex);

	    if((acbp->AcbLevel == ACB_INFO_LEVEL) && (acbp->AcbRole == ACB_SLAVE_ROLE)) {

		rc = GeneratePacket(acbp, ipxhdrp, INFORMATION_RESPONSE);

		switch(rc) {

		    case NO_ERROR:

			acbp->AcbLevel = ACB_CONFIGURED_LEVEL;

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: INFORMATION_RESPONSE sent OK on adpt # %d",
			      acbp->AdapterIndex);

			IpxwanConfigDone(acbp);

			// stop the slave timer
			StopWiTimer(acbp);

			break;

		    case ERROR_DISCONNECT:

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT adpt# %d: Error processing rcvd INFORMATION_REQUEST",
			      acbp->AdapterIndex);

			AcbFailure(acbp);
			break;

		    case ERROR_IGNORE_PACKET:
		    default:

			Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Ignore rcvd INFORMATION_REQUEST on adpt# %d",
			      acbp->AdapterIndex);
			break;
		}
	    }
	    else
	    {
		Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT on rcvd INFORMATION_REQUEST on adpt# %d\nState not INFO LEVEL or Role not SLAVE\n",
		      acbp->AdapterIndex);
		AcbFailure(acbp);
	    }

	    break;

	case INFORMATION_RESPONSE:

	    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd INFORMATION_RESPONSE on adpt# %d",
		  acbp->AdapterIndex);

	    if((acbp->AcbLevel == ACB_INFO_LEVEL) && (acbp->AcbRole == ACB_MASTER_ROLE)) {

		if(*(wanhdrp + WSEQUENCE_NUMBER) == acbp->ReXmitSeqNo) {

		    rc = ProcessInformationResponsePacket(acbp, wip->Packet);

		    switch(rc) {

			case NO_ERROR:

			    acbp->AcbLevel = ACB_CONFIGURED_LEVEL;
			    IpxwanConfigDone(acbp);
			    break;

			case ERROR_DISCONNECT:

			    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT adpt# %d: Error processing rcvd INFORMATION_RESPONSE",
				  acbp->AdapterIndex);

			    AcbFailure(acbp);
			    break;

			case ERROR_IGNORE_PACKET:
			default:

			    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Ignore rcvd INFORMATION_RESPONSE on adpt# %d",
				  acbp->AdapterIndex);

			    break;
		    }
		}
	    }
	    else
	    {
		Trace(IPXWAN_TRACE, "ProcessReceivedPacket: DISCONNECT on rcvd INFORMATION_RESPONSE on adpt# %d\nState not INFO LEVEL or Role not MASTER\n",
		      acbp->AdapterIndex);

		AcbFailure(acbp);
	    }

	    break;

	case NAK:

	    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd NAK on adpt# %d, DISCONNECT\n",
		  acbp->AdapterIndex);

	    AcbFailure(acbp);
	    break;

	default:

	    Trace(IPXWAN_TRACE, "ProcessReceivedPacket: Rcvd unknown packet on adpt# %d, IGNORE\n",
		  acbp->AdapterIndex);

	    break;
    }
}

/*++

Function:	ProcessReXmitPacket

Descr:

Remark: 	>> called with the adapter lock held <<

--*/

VOID
ProcessReXmitPacket(PWORK_ITEM		wip)
{
    PACB	acbp;
    UCHAR	WPacketType;
    DWORD	rc;
    PCHAR	PacketTypep;

    acbp = wip->acbp;

    if(acbp->OperState != OPER_STATE_UP) {

	FreeWorkItem(wip);
	return;
    }

    WPacketType = *(wip->Packet + IPXH_HDRSIZE + WPACKET_TYPE);

    if(!((acbp->AcbLevel == ACB_TIMER_LEVEL) && (WPacketType == TIMER_REQUEST)) &&
       !((acbp->AcbLevel == ACB_INFO_LEVEL) && (WPacketType == INFORMATION_REQUEST))) {

	FreeWorkItem(wip);
	return;
    }

    switch(wip->WiState) {

	case WI_SEND_COMPLETED:

	    StartWiTimer(wip, REXMIT_TIMEOUT);
	    acbp->RefCount++;
	    break;

	case WI_TIMEOUT_COMPLETED:

	    switch(WPacketType) {

		case TIMER_REQUEST:

		    PacketTypep = "TIMER_REQUEST";
		    break;

		case INFORMATION_REQUEST:
		default:

		    PacketTypep = "INFORMATION_REQUEST";
		    break;
	    }

	    if(acbp->ReXmitCount) {

		Trace(IPXWAN_TRACE, "ProcessReXmitPacket: Re-send %s on adpt# %d\n",
		      PacketTypep,
		      acbp->AdapterIndex);

		if(SendReXmitPacket(acbp, wip) != NO_ERROR) {

		    Trace(IPXWAN_TRACE, "ProcessReXmitPacket: failed to send on adpt# %d, DISCONNECT\n",
			  acbp->AdapterIndex);

		    AcbFailure(acbp);
		}
	    }
	    else
	    {
		Trace(IPXWAN_TRACE, "ProcessReXmitPacket: Exhausted retry limit for sending %s on adpt# %d, DISCONNECT\n",
		      PacketTypep,
		      acbp->AdapterIndex);

		AcbFailure(acbp);
	    }

	    break;

	default:

	    SS_ASSERT(FALSE);
	    break;
    }
}


/*++

Function:	ProcessTimeout

Descr:

Remark: 	>> called with the adapter lock held <<

--*/

VOID
ProcessTimeout(PWORK_ITEM      wip)
{
    PACB	acbp;
    UCHAR	WPacketType;
    DWORD	rc;

    acbp = wip->acbp;

    FreeWorkItem(wip);

    if(acbp->OperState != OPER_STATE_UP) {

	return;
    }

    if((acbp->AcbRole == ACB_SLAVE_ROLE) && (acbp->AcbLevel != ACB_CONFIGURED_LEVEL)) {

	AcbFailure(acbp);
    }
}

/*++

Function:	SendReXmitPacket

Descr:		adjusts the rexmit count and seq no and sends the packet

Remark: 	>> called with adapter lock held <<

--*/

DWORD
SendReXmitPacket(PACB		    acbp,
		 PWORK_ITEM	    wip)
{
    DWORD	rc;

    // set the wi rexmit fields
    acbp->ReXmitCount--;
    acbp->ReXmitSeqNo++;
    *(wip->Packet + IPXH_HDRSIZE + WSEQUENCE_NUMBER) = acbp->ReXmitSeqNo;
    rc = SendSubmit(wip);

    if(rc == NO_ERROR) {

	acbp->RefCount++;
    }

    acbp->TReqTimeStamp = GetTickCount();

    return rc;
}

/*++

Function:	GeneratePacket

Descr:		allocate the work item,
		constructs the response packet to the received packet (if any)
		send the response as a rexmit packet or as a one time send packet

Returns:	NO_ERROR
		ERROR_IGNORE_PACKET - ignore the received packet
		ERROR_DISCONNECT - disconnect the adapter because of fatal error

Remark: 	>> called with the adapter lock held <<

--*/

DWORD
GeneratePacket(PACB	    acbp,
	       PUCHAR	    ipxhdrp,
	       UCHAR	    PacketType)
{
    DWORD	rc;
    ULONG	WiType;
    PWORK_ITEM	wip;

    if((wip = AllocateWorkItem(SEND_PACKET_TYPE)) == NULL) {

	return ERROR_DISCONNECT;
    }

    switch(PacketType) {

	case TIMER_REQUEST:

	    rc = MakeTimerRequestPacket(acbp, ipxhdrp, wip->Packet);
	    break;

	case TIMER_RESPONSE:

	    rc = MakeTimerResponsePacket(acbp, ipxhdrp, wip->Packet);
	    break;

	case INFORMATION_REQUEST:

	    rc = MakeInformationRequestPacket(acbp, ipxhdrp, wip->Packet);
	    break;

	case INFORMATION_RESPONSE:

	    rc = MakeInformationResponsePacket(acbp, ipxhdrp, wip->Packet);
	    break;

	default:

	    rc = ERROR_DISCONNECT;
	    break;
    }

    if(rc == NO_ERROR) {

	// no error making the packet -> try to send it
	wip->AdapterIndex = acbp->AdapterIndex;
	wip->WiState = WI_INIT;

	switch(PacketType) {

	    case TIMER_REQUEST:
	    case INFORMATION_REQUEST:

		// re-xmit packet type
		wip->ReXmitPacket = TRUE;

		// create a reference to the adapter CB
		wip->acbp = acbp;

		acbp->ReXmitCount = MAX_REXMIT_COUNT;
		acbp->ReXmitSeqNo = 0xFF;

		if(SendReXmitPacket(acbp, wip) != NO_ERROR) {

		    rc = ERROR_DISCONNECT;
		}

		break;

	    case TIMER_RESPONSE:
	    case INFORMATION_RESPONSE:
	    default:

		// one time send
		wip->ReXmitPacket = FALSE;

		if(SendSubmit(wip) != NO_ERROR) {

		    rc = ERROR_DISCONNECT;
		}

		break;
	}
    }

    if(rc != NO_ERROR) {

	// error making or trying to send the packet
	if(rc != ERROR_GENERATE_NAK) {

	    FreeWorkItem(wip);
	}
	else
	{
	    // if we were requested to generate a NAK packet instead, try to it it
	    MakeNakPacket(acbp, ipxhdrp, wip->Packet);

	    wip->ReXmitPacket = FALSE;

	    if(SendSubmit(wip) != NO_ERROR) {

		FreeWorkItem(wip);
		rc = ERROR_DISCONNECT;
	    }
	    else
	    {
		rc = ERROR_IGNORE_PACKET;
	    }
	}
    }

    return rc;
}

ULONG
GetRole(PUCHAR		hdrp,
	PACB		acbp)
{
    ULONG	RemoteWNodeId;
    ULONG	LocalWNodeId;
    PUCHAR	ipxwanhdrp = hdrp + IPXH_HDRSIZE;
    PUCHAR	optp;
    USHORT	optlen;
    BOOL	IsRemoteExtendedNodeId = FALSE;
    ULONG	RemoteExtendedWNodeId;
    ULONG	LocalExtendedWNodeId;
    ULONG	i;

    GETLONG2ULONG(&LocalWNodeId, acbp->WNodeId);
    GETLONG2ULONG(&RemoteWNodeId,  ipxwanhdrp + WNODE_ID);

    if((LocalWNodeId == 0) && (RemoteWNodeId == 0)) {

	// check if received timer request has the extended node id option
	for(optp = ipxwanhdrp + IPXWAN_HDRSIZE, i=0;
	    i < *(ipxwanhdrp + WNUM_OPTIONS);
	    i++)
	{
	    if(*(optp + WOPTION_NUMBER) == EXTENDED_NODE_ID_OPTION) {

		IsRemoteExtendedNodeId = TRUE;
		GETLONG2ULONG(&RemoteExtendedWNodeId, optp + WOPTION_DATA);
		break;
	    }

	    GETSHORT2USHORT(&optlen, optp + WOPTION_DATA_LEN);
	    optp += OPTION_HDRSIZE + optlen;
	}

	if(acbp->IsExtendedNodeId && IsRemoteExtendedNodeId) {

	    GETLONG2ULONG(&LocalExtendedWNodeId, acbp->ExtendedWNodeId);
	    if(LocalExtendedWNodeId > RemoteExtendedWNodeId) {

		return ACB_MASTER_ROLE;
	    }
	    else if(LocalExtendedWNodeId < RemoteExtendedWNodeId) {

		return ACB_SLAVE_ROLE;
	    }
	    else
	    {
		return ACB_UNKNOWN_ROLE;
	    }
	}
	else if(acbp->IsExtendedNodeId)  {

	    return ACB_MASTER_ROLE;
	}
	else if(IsRemoteExtendedNodeId) {

	    return ACB_SLAVE_ROLE;
	}
	else
	{
	    return ACB_UNKNOWN_ROLE;
	}
    }
    else if(LocalWNodeId > RemoteWNodeId) {

	return ACB_MASTER_ROLE;
    }
    else if(LocalWNodeId < RemoteWNodeId) {

	return ACB_SLAVE_ROLE;
    }
    else
    {
	return ACB_UNKNOWN_ROLE;
    }
}



/*++

Function:	MakeTimerRequestPacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		hdrp	    - ptr to the new packet to be made

--*/

DWORD
MakeTimerRequestPacket(PACB	    acbp,
		       PUCHAR	    rcvhdrp,
		       PUCHAR	    hdrp)
{
    PUCHAR	ipxwanhdrp;
    PUCHAR	optp;
    USHORT	padlen = TIMER_REQUEST_PACKET_LENGTH;

    // set IPX Header
    memcpy(hdrp + IPXH_CHECKSUM, allffs, 2);
    PUTUSHORT2SHORT(hdrp + IPXH_LENGTH, TIMER_REQUEST_PACKET_LENGTH);
    *(hdrp + IPXH_XPORTCTL) = 0;
    *(hdrp + IPXH_PKTTYPE) = IPX_PACKET_EXCHANGE_TYPE;
    memcpy(hdrp + IPXH_DESTNET, allzeros, 4);
    memcpy(hdrp + IPXH_DESTNODE, allffs, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);
    memcpy(hdrp + IPXH_SRCNET, allzeros, 4);
    memcpy(hdrp + IPXH_SRCNODE, allzeros, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);

    // set IPXWAN Header
    ipxwanhdrp = hdrp + IPXH_HDRSIZE;

    memcpy(ipxwanhdrp + WIDENTIFIER, IPXWAN_CONFIDENCE_ID, 4);
    *(ipxwanhdrp + WPACKET_TYPE) = TIMER_REQUEST;
    memcpy(ipxwanhdrp + WNODE_ID, acbp->WNodeId, 4);
    // the sequence number is written when the packet gets sent
    *(ipxwanhdrp + WNUM_OPTIONS) = 0;

    padlen -= (IPXH_HDRSIZE + IPXWAN_HDRSIZE);

    // set OPTIONS
    optp = ipxwanhdrp + IPXWAN_HDRSIZE;

    if(IS_WORKSTATION(acbp->SupportedRoutingTypes)) {

	(*(ipxwanhdrp + WNUM_OPTIONS))++;
	*(optp + WOPTION_NUMBER) = ROUTING_TYPE_OPTION;
	*(optp + WACCEPT_OPTION) = YES;
	PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, ROUTING_TYPE_DATA_LEN);
	*(optp + WOPTION_DATA) = WORKSTATION_ROUTING_TYPE;

	optp += OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN;
	padlen -= (OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN);
    }
    if(IS_NUMBERED_RIP(acbp->SupportedRoutingTypes)) {

	(*(ipxwanhdrp + WNUM_OPTIONS))++;
	*(optp + WOPTION_NUMBER) = ROUTING_TYPE_OPTION;
	*(optp + WACCEPT_OPTION) = YES;
	PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, ROUTING_TYPE_DATA_LEN);
	*(optp + WOPTION_DATA) = NUMBERED_RIP_ROUTING_TYPE;

	optp += OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN;
	padlen -= (OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN);
    }
    if(IS_UNNUMBERED_RIP(acbp->SupportedRoutingTypes)) {

	(*(ipxwanhdrp + WNUM_OPTIONS))++;
	*(optp + WOPTION_NUMBER) = ROUTING_TYPE_OPTION;
	*(optp + WACCEPT_OPTION) = YES;
	PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, ROUTING_TYPE_DATA_LEN);
	*(optp + WOPTION_DATA) = UNNUMBERED_RIP_ROUTING_TYPE;

	optp += OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN;
	padlen -= (OPTION_HDRSIZE + ROUTING_TYPE_DATA_LEN);
    }
    if(acbp->IsExtendedNodeId) {

	(*(ipxwanhdrp + WNUM_OPTIONS))++;
	*(optp + WOPTION_NUMBER) = EXTENDED_NODE_ID_OPTION;
	*(optp + WACCEPT_OPTION) = YES;
	PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, EXTENDED_NODE_ID_DATA_LEN);
	memcpy(optp + WOPTION_DATA, acbp->ExtendedWNodeId, EXTENDED_NODE_ID_DATA_LEN);

	optp += OPTION_HDRSIZE + EXTENDED_NODE_ID_DATA_LEN;
	padlen -= (OPTION_HDRSIZE + EXTENDED_NODE_ID_DATA_LEN);
    }

    // PAD
    padlen -= OPTION_HDRSIZE;

    (*(ipxwanhdrp + WNUM_OPTIONS))++;
    *(optp + WOPTION_NUMBER) = PAD_OPTION;
    *(optp + WACCEPT_OPTION) = YES;
    PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, padlen);

    fillpadding(optp + WOPTION_DATA, padlen);

    return NO_ERROR;
}


/*++

Function:	MakeTimerResponsePacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		rcvhdrp	    - ptr to the received TIMER_REQUEST packet
		hdrp	    - ptr to the new packet to be made

--*/

DWORD
MakeTimerResponsePacket(PACB		acbp,
			PUCHAR		rcvhdrp,
			PUCHAR		hdrp)
{
    USHORT	rcvlen;
    USHORT	optlen;
    PUCHAR	ipxwanhdrp;
    PUCHAR	optp;
    ULONG	RemoteWNodeId;
    ULONG	i;

    Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: Entered adapter # %d", acbp->AdapterIndex);

    // check received packet length
    GETSHORT2USHORT(&rcvlen, rcvhdrp + IPXH_LENGTH);

    if(rcvlen < TIMER_REQUEST_PACKET_LENGTH) {

	return ERROR_IGNORE_PACKET;
    }

    memcpy(hdrp, rcvhdrp, rcvlen);

    // set IPX Header
    memcpy(hdrp + IPXH_CHECKSUM, allffs, 2);
    PUTUSHORT2SHORT(hdrp + IPXH_LENGTH, TIMER_REQUEST_PACKET_LENGTH);
    *(hdrp + IPXH_XPORTCTL) = 0;
    *(hdrp + IPXH_PKTTYPE) = IPX_PACKET_EXCHANGE_TYPE;
    memcpy(hdrp + IPXH_DESTNET, allzeros, 4);
    memcpy(hdrp + IPXH_DESTNODE, allffs, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);
    memcpy(hdrp + IPXH_SRCNET, allzeros, 4);
    memcpy(hdrp + IPXH_SRCNODE, allzeros, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);

    // set IPXWAN Header
    ipxwanhdrp = hdrp + IPXH_HDRSIZE;

    *(ipxwanhdrp + WPACKET_TYPE) = TIMER_RESPONSE;
    GETLONG2ULONG(&RemoteWNodeId, ipxwanhdrp + WNODE_ID);
    memcpy(ipxwanhdrp + WNODE_ID, acbp->InternalNetNumber, 4);

    // parse each option in the received timer request packet
    for(optp = ipxwanhdrp + IPXWAN_HDRSIZE, i=0;
	i < *(ipxwanhdrp + WNUM_OPTIONS);
	i++, optp += OPTION_HDRSIZE + optlen)
    {
	GETSHORT2USHORT(&optlen, optp + WOPTION_DATA_LEN);

	switch(*(optp + WOPTION_NUMBER)) {

	    case ROUTING_TYPE_OPTION:

		if(optlen != ROUTING_TYPE_DATA_LEN) {

		    return ERROR_GENERATE_NAK;
		}

		if((*(optp + WOPTION_DATA) == WORKSTATION_ROUTING_TYPE) &&
		   (IS_WORKSTATION(acbp->SupportedRoutingTypes)) &&
		   (acbp->RoutingType == 0) &&
		   (*(optp + WACCEPT_OPTION) == YES)) {

		    SET_WORKSTATION(acbp->RoutingType);
		    Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept routing type: %s",
			  acbp->AdapterIndex,
			  Workstationp);
		}
		else if((*(optp + WOPTION_DATA) == UNNUMBERED_RIP_ROUTING_TYPE) &&
		       (IS_UNNUMBERED_RIP(acbp->SupportedRoutingTypes)) &&
		       (acbp->RoutingType == 0) &&
		       (*(optp + WACCEPT_OPTION) == YES)) {

		    SET_UNNUMBERED_RIP(acbp->RoutingType);
		    Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept routing type: %s",
			  acbp->AdapterIndex,
			  UnnumberedRip);
		}
		else if((*(optp + WOPTION_DATA) == NUMBERED_RIP_ROUTING_TYPE) &&
		       (acbp->RoutingType == 0) &&
		       (*(optp + WACCEPT_OPTION) == YES)) {

			if(IS_NUMBERED_RIP(acbp->SupportedRoutingTypes)) {

			SET_NUMBERED_RIP(acbp->RoutingType);
			Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept routing type: %s",
			      acbp->AdapterIndex,
			      NumberedRip);

			}
			else if((IS_UNNUMBERED_RIP(acbp->SupportedRoutingTypes)) &&
				RemoteWNodeId) {

			    // the local router cannot assign net numbers but it
			    // accepts the numbered rip type because the remote router
			    // claims it can assign a net number (because remote node id is not null).

			    SET_NUMBERED_RIP(acbp->RoutingType);
			    Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept routing type: %s",
				  acbp->AdapterIndex,
				  NumberedRip);
			}
			else
			{
			    *(optp + WACCEPT_OPTION) = NO;
			    Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, decline routing type: %d",
				  acbp->AdapterIndex,
				  *(optp + WOPTION_NUMBER));

			}
		    }
		    else
		    {
			*(optp + WACCEPT_OPTION) = NO;
			Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, decline routing type: %d",
			      acbp->AdapterIndex,
			      *(optp + WOPTION_DATA));
		    }

		break;

	    case EXTENDED_NODE_ID_OPTION:

		if(optlen != EXTENDED_NODE_ID_DATA_LEN) {

		    return ERROR_GENERATE_NAK;
		}

		*(optp + WACCEPT_OPTION) = YES;
		Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept extended node id",
		      acbp->AdapterIndex);

		break;

	    case PAD_OPTION:

		*(optp + WACCEPT_OPTION) = YES;
		Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, accept padding",
		      acbp->AdapterIndex);

		break;

	    default:

		*(optp + WACCEPT_OPTION) = NO;
		Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, decline option number %d",
		      acbp->AdapterIndex,
		      *(optp + WOPTION_NUMBER));

		break;
	}
    }

    // check if we have agreed on a routing type
    if(!acbp->RoutingType) {

	Trace(IPXWAN_TRACE, "MakeTimerResponsePacket: adapter # %d, negotiation failed: no routing type accepted",
	      acbp->AdapterIndex);

	return ERROR_DISCONNECT;
    }

    return NO_ERROR;
}

/*++

Function:	MakeInformationRequestPacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		rcvhdrp     - ptr to the received TIMER_RESPONSE packet
		hdrp	    - ptr to the new packet to be made

--*/

DWORD
MakeInformationRequestPacket(PACB	    acbp,
			     PUCHAR	    rcvhdrp,
			     PUCHAR	    hdrp)
{
    PUCHAR	    optp;
    USHORT	    optlen;
    PUCHAR	    rcvipxwanhdrp, ipxwanhdrp;
    ULONG	    rt_options_count = 0;
    USHORT	    pktlen = 0;
    ULONG	    i;
    ULONG	    ComputerNameLen;
    CHAR	    ComputerName[49];

    memset(ComputerName, 0, 49);

    Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: Entered for adpt# %d", acbp->AdapterIndex);

    rcvipxwanhdrp = rcvhdrp + IPXH_HDRSIZE;

    // establish the routing type
    for(optp = rcvipxwanhdrp + IPXWAN_HDRSIZE, i=0;
	i < *(rcvipxwanhdrp + WNUM_OPTIONS);
	i++, optp += OPTION_HDRSIZE + optlen)
    {
	GETSHORT2USHORT(&optlen, optp + WOPTION_DATA_LEN);

	if(*(optp + WOPTION_NUMBER) == ROUTING_TYPE_OPTION) {

	    rt_options_count++;

	    if(optlen != ROUTING_TYPE_DATA_LEN) {

		Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: Invalid ROUTING TYPE data len, make NAK for adpt# %d", acbp->AdapterIndex);
		return ERROR_GENERATE_NAK;
	    }

	    if((*(optp + WOPTION_DATA) == WORKSTATION_ROUTING_TYPE) &&
		(IS_WORKSTATION(acbp->SupportedRoutingTypes)) &&
		(acbp->RoutingType == 0) &&
		(*(optp + WACCEPT_OPTION) == YES)) {

		SET_WORKSTATION(acbp->RoutingType);
		Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d, accept routing type: %s",
			  acbp->AdapterIndex,
			  Workstationp);

	    }
	    else if((*(optp + WOPTION_DATA) == UNNUMBERED_RIP_ROUTING_TYPE) &&
		     (IS_UNNUMBERED_RIP(acbp->SupportedRoutingTypes)) &&
		     (acbp->RoutingType == 0) &&
		     (*(optp + WACCEPT_OPTION) == YES)) {

		SET_UNNUMBERED_RIP(acbp->RoutingType);
		Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d, accept routing type: %s",
		      acbp->AdapterIndex,
		      UnnumberedRip);

	    }
	    else if((*(optp + WOPTION_DATA) == NUMBERED_RIP_ROUTING_TYPE) &&
		     (acbp->RoutingType == 0) &&
		     (IS_NUMBERED_RIP(acbp->SupportedRoutingTypes)) &&
		     (*(optp + WACCEPT_OPTION) == YES)) {

		 SET_NUMBERED_RIP(acbp->RoutingType);
		 Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d, accept routing type: %s",
		       acbp->AdapterIndex,
		       NumberedRip);
	    }
	}
    }

    // there should be one and only one routing type option in the timer response
    if(rt_options_count != 1) {

	Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d negotiation failed, no/too many routing options",
	      acbp->AdapterIndex);
	return ERROR_DISCONNECT;
    }

    //
    //*** MASTER: Set the common network number and the local node number ***
    //

    if(IS_UNNUMBERED_RIP(acbp->RoutingType)) {

	memset(acbp->Network, 0, 4);
    }
    else
    {
	// call ipxcp to get a net number
	if(IpxcpGetWanNetNumber(acbp->Network,
			   &acbp->AllocatedNetworkIndex,
			   acbp->InterfaceType) != NO_ERROR) {

	    Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d negotiation failed, cannot allocate net number",
	      acbp->AdapterIndex);

	    return ERROR_DISCONNECT;
	}
    }

    memset(acbp->LocalNode, 0, 6);
    memcpy(acbp->LocalNode, acbp->InternalNetNumber, 4);

    // set IPX Header
    pktlen = IPXH_HDRSIZE + IPXWAN_HDRSIZE + OPTION_HDRSIZE + RIP_SAP_INFO_EXCHANGE_DATA_LEN;

    memcpy(hdrp + IPXH_CHECKSUM, allffs, 2);
    *(hdrp + IPXH_XPORTCTL) = 0;
    *(hdrp + IPXH_PKTTYPE) = IPX_PACKET_EXCHANGE_TYPE;
    memcpy(hdrp + IPXH_DESTNET, allzeros, 4);
    memcpy(hdrp + IPXH_DESTNODE, allffs, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);
    memcpy(hdrp + IPXH_SRCNET, allzeros, 4);
    memcpy(hdrp + IPXH_SRCNODE, allzeros, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);

    // set IPXWAN Header
    ipxwanhdrp = hdrp + IPXH_HDRSIZE;
    memcpy(ipxwanhdrp + WIDENTIFIER, IPXWAN_CONFIDENCE_ID, 4);
    *(ipxwanhdrp + WPACKET_TYPE) = INFORMATION_REQUEST;
    memcpy(ipxwanhdrp + WNODE_ID, acbp->InternalNetNumber, 4);
    // the sequence number is written when the packet gets sent
    *(ipxwanhdrp + WNUM_OPTIONS) = 1;

    // set OPTIONS
    optp = ipxwanhdrp + IPXWAN_HDRSIZE;

    *(optp + WOPTION_NUMBER) = RIP_SAP_INFO_EXCHANGE_OPTION;
    *(optp + WACCEPT_OPTION) = YES;
    PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, RIP_SAP_INFO_EXCHANGE_DATA_LEN);

    PUTUSHORT2SHORT(optp + WAN_LINK_DELAY, acbp->LinkDelay);
    memcpy(optp + COMMON_NETWORK_NUMBER, acbp->Network, 4);

    memset(optp + ROUTER_NAME, 0, 48);

    ComputerNameLen = 48;

    if(!GetComputerName(optp + ROUTER_NAME,
			&ComputerNameLen)) {

	// failed to get machine name
	return ERROR_DISCONNECT;
    }

    memcpy(ComputerName, optp + ROUTER_NAME, ComputerNameLen);
    Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d, Delay %d\nCommon Net %.2x%.2x%.2x%.2x\nRouterName: %s\n",
	  acbp->AdapterIndex,
	  acbp->LinkDelay,
	  acbp->Network[0],
	  acbp->Network[1],
	  acbp->Network[2],
	  acbp->Network[3],
	  ComputerName);

    //
    //*** MASTER: Set the remote node number ***
    //
    if(acbp->InterfaceType == IF_TYPE_WAN_WORKSTATION) {

	// if the remote machine is a connecting wksta we should provide it with a node
	// number
	pktlen += OPTION_HDRSIZE + NODE_NUMBER_DATA_LEN;
	(*(ipxwanhdrp + WNUM_OPTIONS))++;

	optp += OPTION_HDRSIZE + RIP_SAP_INFO_EXCHANGE_DATA_LEN;

	*(optp + WOPTION_NUMBER) = NODE_NUMBER_OPTION;
	*(optp + WACCEPT_OPTION) = YES;
	PUTUSHORT2SHORT(optp + WOPTION_DATA_LEN, NODE_NUMBER_DATA_LEN);

	if(IpxcpGetRemoteNode(acbp->ConnectionId, optp + WOPTION_DATA) != NO_ERROR) {

	    return ERROR_DISCONNECT;
	}

	memcpy(acbp->RemoteNode, optp + WOPTION_DATA, 6);

	Trace(IPXWAN_TRACE, "MakeInformationRequestPacket: adpt# %d add NIC Address Option: %.2x%.2x%.2x%.2x%.2x%.2x\n",
		   acbp->RemoteNode[0],
		   acbp->RemoteNode[1],
		   acbp->RemoteNode[2],
		   acbp->RemoteNode[3],
		   acbp->RemoteNode[4],
		   acbp->RemoteNode[5]);

    }
    else
    {
	// remote machine is a router -> its node number is derived from its internal net
	memset(acbp->RemoteNode, 0, 6);
	memcpy(acbp->RemoteNode, rcvipxwanhdrp + WNODE_ID, 4);
    }

    PUTUSHORT2SHORT(hdrp + IPXH_LENGTH, pktlen);

    return NO_ERROR;
}

/*++

Function:	MakeInformationResponsePacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		rcvhdrp     - ptr to the received INFORMATION_REQUEST packet
		hdrp	    - ptr to the new packet to be made

--*/


DWORD
MakeInformationResponsePacket(PACB		acbp,
			      PUCHAR		rcvhdrp,
			      PUCHAR		hdrp)
{
    USHORT	rcvlen;
    USHORT	optlen;
    PUCHAR	ipxwanhdrp;
    PUCHAR	optp;
    UCHAR	RcvWNodeId[4];
    ULONG	RipSapExchangeOptionCount = 0;
    ULONG	NodeNumberOptionCount = 0;
    UCHAR	LocalNode[6];
    ULONG	i;
    ULONG	ComputerNameLen=48;

    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: Entered adpt# %d", acbp->AdapterIndex);

    memset(LocalNode, 0, 6);

    // get received packet length
    GETSHORT2USHORT(&rcvlen, rcvhdrp + IPXH_LENGTH);

    if(rcvlen < IPXH_HDRSIZE + IPXWAN_HDRSIZE + OPTION_HDRSIZE + RIP_SAP_INFO_EXCHANGE_DATA_LEN) {

	// malformed packet
	return ERROR_IGNORE_PACKET;
    }

    memcpy(hdrp, rcvhdrp, rcvlen);

    // set IPX Header
    memcpy(hdrp + IPXH_CHECKSUM, allffs, 2);
    *(hdrp + IPXH_XPORTCTL) = 0;
    *(hdrp + IPXH_PKTTYPE) = IPX_PACKET_EXCHANGE_TYPE;
    memcpy(hdrp + IPXH_DESTNET, allzeros, 4);
    memcpy(hdrp + IPXH_DESTNODE, allffs, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);
    memcpy(hdrp + IPXH_SRCNET, allzeros, 4);
    memcpy(hdrp + IPXH_SRCNODE, allzeros, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_DESTSOCK, IPXWAN_SOCKET);

    // set IPXWAN Header
    ipxwanhdrp = hdrp + IPXH_HDRSIZE;

    *(ipxwanhdrp + WPACKET_TYPE) = INFORMATION_RESPONSE;
    memcpy(RcvWNodeId, ipxwanhdrp + WNODE_ID, 4);
    memcpy(ipxwanhdrp + WNODE_ID, acbp->InternalNetNumber, 4);

    // parse each option in the received information request packet
    for(optp = ipxwanhdrp + IPXWAN_HDRSIZE, i=0;
	i < *(ipxwanhdrp + WNUM_OPTIONS);
	i++, optp += OPTION_HDRSIZE + optlen)
    {
	GETSHORT2USHORT(&optlen, optp + WOPTION_DATA_LEN);

	switch(*(optp + WOPTION_NUMBER)) {

	    case RIP_SAP_INFO_EXCHANGE_OPTION:

		if(RipSapExchangeOptionCount++) {

		    // more then one rip/sap exchange option
		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: more then 1 RIP_SAP_EXCHANGE_OPTION in rcvd INFORAMTION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		if(optlen != RIP_SAP_INFO_EXCHANGE_DATA_LEN) {

		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: bad length RIP_SAP_EXCHANGE_OPTION in rcvd INFORAMTION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_GENERATE_NAK;
		}

		if(*(optp + WACCEPT_OPTION) != YES) {

		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: ACCEPT==NO RIP_SAP_EXCHANGE_OPTION in rcvd INFORAMTION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		GETSHORT2USHORT(&acbp->LinkDelay, optp + WAN_LINK_DELAY);

		// validate routing type and common net number
		if((IS_NUMBERED_RIP(acbp->RoutingType)) &&
		   !memcmp(optp + COMMON_NETWORK_NUMBER, allzeros, 4)) {

		    // negotiation error
		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: NUMBERED RIP Routing but Network==0 in rcvd INFORAMTION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		if((IS_UNNUMBERED_RIP(acbp->RoutingType)) &&
		   memcmp(optp + COMMON_NETWORK_NUMBER, allzeros, 4)) {

		    // negotiation error
		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: ON DEMAND Routing but Network!=0 in rcvd INFORAMTION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		// check we were handed a unique net number
		if(memcmp(optp + COMMON_NETWORK_NUMBER, allzeros, 4)) {

		    switch(acbp->InterfaceType) {

			case  IF_TYPE_WAN_ROUTER:
			case  IF_TYPE_PERSONAL_WAN_ROUTER:
			case  IF_TYPE_ROUTER_WORKSTATION_DIALOUT:

			    if(IpxcpIsRoute(optp + COMMON_NETWORK_NUMBER)) {

				Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: Network not unique in rcvd INFORAMTION_REQUEST\n",
				      acbp->AdapterIndex);

				return ERROR_DISCONNECT;
			    }

			    break;

			default:

			    break;
		    }
		}

		//
		//*** SLAVE: Set the common net number and the remote node ***
		//
		memcpy(acbp->Network, optp + COMMON_NETWORK_NUMBER, 4);

		Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, Recvd Common Network Number %.2x%.2x%.2x%.2x\n",
		      acbp->AdapterIndex,
		      acbp->Network[0],
		      acbp->Network[1],
		      acbp->Network[2],
		      acbp->Network[3]);

		// make the remote node number from its remote WNODE ID field
		memset(acbp->RemoteNode, 0, 6);
		memcpy(acbp->RemoteNode, RcvWNodeId, 4);

		// give our router name
		memset(optp + ROUTER_NAME, 0, 48);

		if(!GetComputerName(optp + ROUTER_NAME, &ComputerNameLen)) {

		    // failed to get machine name
		    return ERROR_DISCONNECT;
		}

		break;

	    case NODE_NUMBER_OPTION:

		if(NodeNumberOptionCount++) {

		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: more than 1 NODE_NUMBER_OPTION in rcvd INFORMATION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		if(optlen != NODE_NUMBER_DATA_LEN) {

		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: bad length for NODE_NUMBER_OPTION in rcvd INFORMATION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_GENERATE_NAK;
		}

		if(*(optp + WACCEPT_OPTION) != YES) {

		    Trace(IPXWAN_TRACE, "MakeInformationResponsePacket: adpt# %d, ERROR: ACCEPT==NO for NODE_NUMBER_OPTION in rcvd INFORMATION_REQUEST\n",
		    acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		memcpy(LocalNode, optp + WOPTION_DATA, 6);

		break;

	    default:

		*(optp + WACCEPT_OPTION) = NO;
		break;
	}
    }

    //
    //*** SLAVE: Set local node ***
    //
    if(NodeNumberOptionCount) {

	memcpy(acbp->LocalNode, LocalNode, 6);
    }
    else
    {
	// make the local node from our internal net
	memset(acbp->LocalNode, 0, 6);
	memcpy(acbp->LocalNode, acbp->InternalNetNumber, 4);
    }

    return NO_ERROR;
}

/*++

Function:	MakeNakPacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		rcvhdrp     - ptr to the received UNKNOWN packet
		hdrp	    - ptr to the new packet to be made

--*/

DWORD
MakeNakPacket(PACB		acbp,
	      PUCHAR		rcvhdrp,
	      PUCHAR		hdrp)
{
    USHORT	    rcvlen;
    PUCHAR	    ipxwanhdrp;

    // get received packet length
    GETSHORT2USHORT(&rcvlen, rcvhdrp + IPXH_LENGTH);

    memcpy(hdrp, rcvhdrp, rcvlen);

    // set IPXWAN Header
    ipxwanhdrp = hdrp + IPXH_HDRSIZE;

    *(ipxwanhdrp + WPACKET_TYPE) = NAK;

    return NO_ERROR;
}

/*++

Function:	ProcessInformationResponsePacket

Descr:

Arguments:	acbp	    - ptr to adapter CB
		rcvhdrp     - ptr to the received INFORMATION_RESPONSE packet

--*/

DWORD
ProcessInformationResponsePacket(PACB	    acbp,
				 PUCHAR     rcvhdrp)
{
    USHORT	rcvlen;
    USHORT	optlen;
    PUCHAR	ipxwanhdrp;
    PUCHAR	optp;
    ULONG	RipSapExchangeOptionCount = 0;
    ULONG	i;

    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: Entered adpt# %d", acbp->AdapterIndex);

    // get received packet length
    GETSHORT2USHORT(&rcvlen, rcvhdrp + IPXH_LENGTH);

    if(rcvlen < IPXH_HDRSIZE + IPXWAN_HDRSIZE + OPTION_HDRSIZE + RIP_SAP_INFO_EXCHANGE_DATA_LEN) {

	// malformed packet
	return ERROR_IGNORE_PACKET;
    }

    ipxwanhdrp =rcvhdrp + IPXH_HDRSIZE;

    // parse each option in the received information response packet
    for(optp = ipxwanhdrp + IPXWAN_HDRSIZE, i=0;
	i < *(ipxwanhdrp + WNUM_OPTIONS);
	i++, optp += OPTION_HDRSIZE + optlen)
    {
	GETSHORT2USHORT(&optlen, optp + WOPTION_DATA_LEN);

	switch(*(optp + WOPTION_NUMBER)) {

	    case RIP_SAP_INFO_EXCHANGE_OPTION:

		if(RipSapExchangeOptionCount++) {

		    // more then one rip/sap exchange option
		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: more then 1 RIP_SAP_INFO_EXCHANGE_OPTION in rcvd INFORMATION_RESPONSE\n",
		    acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		if(optlen != RIP_SAP_INFO_EXCHANGE_DATA_LEN) {

		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: bad length RIP_SAP_EXCHANGE_OPTION in rcvd INFORMATION_RESPONSE\n",
			  acbp->AdapterIndex);

		    return ERROR_GENERATE_NAK;
		}

		if(*(optp + WACCEPT_OPTION) != YES) {

		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: ACCEPT==NO RIP_SAP_EXCHANGE_OPTION in rcvd INFORMATION_RESPONSE\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		if(memcmp(optp + COMMON_NETWORK_NUMBER, acbp->Network, 4)) {

		    // we don't agree on the common net number
		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: Different common net returned\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		break;

	    case NODE_NUMBER_OPTION:

		if(optlen != NODE_NUMBER_DATA_LEN) {

		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: bad length NODE_NUMBER_OPTION in rcvd INFORMATION_REQUEST\n",
			  acbp->AdapterIndex);

		    return ERROR_GENERATE_NAK;
		}

		if(*(optp + WACCEPT_OPTION) != YES) {

		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: ACCEPT==NO NODE_NUMBER_OPTION in rcvd INFORMATION_RESPONSE\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		// check that it coincides with the number we assigned
		if(memcmp(optp + WOPTION_DATA, acbp->RemoteNode, 6)) {

		    Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: Different remote node number returned\n",
			  acbp->AdapterIndex);

		    return ERROR_DISCONNECT;
		}

		break;

	    default:

		Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: Unrequested option in rcvd INFORMATION_RESPONSE\n",
		      acbp->AdapterIndex);

		return ERROR_DISCONNECT;
		break;
	}
    }

    if(!RipSapExchangeOptionCount) {

	Trace(IPXWAN_TRACE, "ProcessInformationResponsePacket: adpt# %d, ERROR: RIP_SAP_EXCHANGE_OPTION missing from rcvd INFORMATION_RESPONSE\n",
	      acbp->AdapterIndex);

	return ERROR_DISCONNECT;
    }

    return NO_ERROR;
}


VOID
fillpadding(PUCHAR	    padp,
	    ULONG	    len)
{
    ULONG	i;

    for(i=0; i<len; i++)
    {
	*(padp + i) = (UCHAR)i;
    }
}

/*++

Function:	StartSlaveTimer

Descr:		A timer is started when the slave gets its role (i.e. slave) and sends
		a timer response. This insures the slave won't wait forever to receive
		an information request.

Remark: 	>> called with the adapter lock held <<

--*/

DWORD
StartSlaveTimer(PACB	    acbp)
{
    PWORK_ITEM	    wip;

    if((wip = AllocateWorkItem(WITIMER_TYPE)) == NULL) {

	return ERROR_DISCONNECT;
    }

    wip->acbp = acbp;
    StartWiTimer(wip, SLAVE_TIMEOUT);
    acbp->RefCount++;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\filter.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    filter.c

Abstract:

    RIP advertise & accept filtering functions

Author:

    Stefan Solomon  09/29/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

////////////////////////////////////////////////////////////////////////////////////////
//										      //
//										      //
//				INTERFACE FILTERS				      //
//										      //
//										      //
////////////////////////////////////////////////////////////////////////////////////////


/*++

Function:	PassRipSupplyFilter

Descr:		Filters outgoing RIP advertisments on this interface

Returns:	TRUE   - PASS
		FALSE  - DO NOT PASS

Remark: 	>> called with the interface lock held <<

--*/

BOOL
PassRipSupplyFilter(PICB	icbp,
		    PUCHAR	Network)
{
    ULONG			NetNumber, i;
    BOOL			filtaction;
    PRIP_ROUTE_FILTER_INFO_I	rfip;
    PRIP_IF_FILTERS_I		fcbp;

    fcbp = icbp->RipIfFiltersIp;

    if(fcbp == NULL) {

	return TRUE;
    }

    if((fcbp != NULL) &&
       (fcbp->SupplyFilterCount == 0)) {

	return TRUE;
    }

    GETLONG2ULONG(&NetNumber, Network);

    // check if we have it
    for(i=0, rfip = fcbp->RouteFilterI;
	i< fcbp->SupplyFilterCount;
	i++, rfip++)
    {
	if((NetNumber & rfip->Mask) == rfip->Network) {

	    return fcbp->SupplyFilterAction;
	}
    }

    return !fcbp->SupplyFilterAction;
}


/*++

Function:	PassRipListenFilter

Descr:		Filters incoming RIP advertisments on this interface

Returns:	TRUE   - PASS
		FALSE  - DO NOT PASS

Remark: 	>> called with the interface lock held <<

--*/

BOOL
PassRipListenFilter(PICB	icbp,
		    PUCHAR	Network)
{
    ULONG			NetNumber, i;
    BOOL			filtaction;
    PRIP_ROUTE_FILTER_INFO_I	rfip;
    PRIP_IF_FILTERS_I		fcbp;

    fcbp = icbp->RipIfFiltersIp;

    if(fcbp == NULL) {

	return TRUE;
    }

    if((fcbp != NULL) &&
       (fcbp->ListenFilterCount == 0)) {

	return TRUE;
    }

    GETLONG2ULONG(&NetNumber, Network);

    // check if we have it
    for(i=0, rfip = fcbp->RouteFilterI + fcbp->SupplyFilterCount;
	i< fcbp->ListenFilterCount;
	i++, rfip++)
    {
	if((NetNumber & rfip->Mask) == rfip->Network) {

	    return fcbp->ListenFilterAction;
	}
    }

    return !fcbp->ListenFilterAction;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\workitem.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    worker.c

Abstract:

    work items management functions

Author:

    Stefan Solomon  07/11/1995

Revision History:

--*/

#include  "precomp.h"
#pragma hdrstop

/*++

Function:	CreateWorkItemsManager

Descr:		creates the work items heap

--*/

HANDLE		WiHeapHandle;
volatile LONG WorkItemsCount;

DWORD
CreateWorkItemsManager(VOID)
{
    if((WiHeapHandle = HeapCreate(0,
				 0x8000,     // 32k initial size
				 0x100000    // 1 meg max size
				 )) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }
    WorkItemsCount = 0;

    return NO_ERROR;
}

VOID
DestroyWorkItemsManager(VOID)
{
    while (WorkItemsCount>0)
        SleepEx (1000, TRUE);
    HeapDestroy(WiHeapHandle);
}

/*++

Function:	AllocateWorkItem

Descr:		allocates the work item from the workitems heap
		The function looks at the work item type and allocates a
		packet at the end if required

--*/

PWORK_ITEM
AllocateWorkItem(ULONG	      Type)
{
    PWORK_ITEM		wip;

    switch(Type) {

	case WITIMER_TYPE:

	    if((wip = GlobalAlloc(GPTR, sizeof(WORK_ITEM))) == NULL) {

		return NULL;
	    }

	    break;

	default:

	    if((wip = HeapAlloc(WiHeapHandle,
				HEAP_ZERO_MEMORY,
				sizeof(WORK_ITEM) + MAX_IPXWAN_PACKET_LEN)) == NULL) {

		return NULL;
	    }
    }

    wip->Type = Type;

    InterlockedIncrement((PLONG)&WorkItemsCount);

    return wip;
}

/*++

Function:	FreeWorkItem

Descr:		frees the work item to the workitems heap

--*/

VOID
FreeWorkItem(PWORK_ITEM     wip)
{
    HGLOBAL	   rc_global;
    BOOL	   rc_heap;

    switch(wip->Type) {

	case WITIMER_TYPE:

	    rc_global = GlobalFree(wip);
	    SS_ASSERT(rc_global == NULL);

	    break;

	default:

	    rc_heap = HeapFree(WiHeapHandle,
			       0,
			       wip);

	    SS_ASSERT(rc_heap);

	    break;
    }

    InterlockedDecrement((PLONG)&WorkItemsCount);
}

/*++

Function:	EnqueueWorkItemToWorker

Descr:		inserts a work item in the workers queue and signals the
		event

Remark: 	Called with the Queues Lock held

--*/

VOID
EnqueueWorkItemToWorker(PWORK_ITEM	wip)
{
    InsertTailList(&WorkersQueue, &wip->Linkage);

    SetEvent(hWaitableObject[WORKERS_QUEUE_EVENT]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\changebc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    changebc.c

Abstract:

    The change broadcast handlers

Author:

    Stefan Solomon  07/11/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

BOOL		    RTMSignaledChanges = FALSE;
BOOL		    RIPSignaledChanges = FALSE;

BOOL		    DestroyStartChangesBcastWi = FALSE;

//  List of interfaces CBs which can send changes broadcasts

LIST_ENTRY	    IfChangesBcastList;

PWORK_ITEM
CreateChangesBcastWi(PICB	icbp);

VOID
AddRouteToChangesBcast(PICB	    icbp,
		       PIPX_ROUTE   IpxRoutep);

VOID
FlushChangesBcastQueue(PICB	    icbp);

BOOL
IsChangeBcastPacketEmpty(PUCHAR 	 hdrp);

VOID
CreateStartChangesBcastWi(VOID)
{
    PWORK_ITEM	    wip;

    InitializeListHead(&IfChangesBcastList);

    if((wip = AllocateWorkItem(START_CHANGES_BCAST_TYPE)) == NULL) {

	// !!! log -> can't allocate wi
	return;
    }

    StartWiTimer(wip, CHANGES_BCAST_TIME);
}


VOID
ProcessRTMChanges(VOID)
{
    RTMSignaledChanges = TRUE;
}

VOID
ProcessRIPChanges(VOID)
{
    RIPSignaledChanges = TRUE;
}


/*++

Function:	StartChangesBcast

Descr:		Called by the worker every 1 second

Remark:        >> Called with the database lock held <<

--*/

VOID
StartChangesBcast(PWORK_ITEM	    wip)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;
    PWORK_ITEM	    bcwip;   // bcast change work item
    BOOL	    skipit, lastmessage;
    IPX_ROUTE	    IpxRoute;

    if(DestroyStartChangesBcastWi) {

	FreeWorkItem(wip);
	return;
    }

    if(!RTMSignaledChanges && !RIPSignaledChanges) {

	// re-queue in the timer queue if no changes signaled in the last 1 sec
	StartWiTimer(wip, CHANGES_BCAST_TIME);
	return;
    }

    // make a list of interfaces with
    // oper state UP. This is a local list of nodes where each node points to
    // an interface with state UP and lock held.

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IfListLinkage);

	if((icbp->InterfaceIndex != 0) &&
	   (icbp->IfStats.RipIfOperState == OPER_STATE_UP) &&
	   (icbp->IfConfigInfo.UpdateMode == IPX_STANDARD_UPDATE) &&
	   (icbp->IfConfigInfo.Supply == ADMIN_STATE_ENABLED))	{

	    ACQUIRE_IF_LOCK(icbp);

	    if((bcwip = CreateChangesBcastWi(icbp)) == NULL) {

		RELEASE_IF_LOCK(icbp);
		break;
	    }
	    else
	    {
		// insert the bcast wi in the interface changes bcast queue
		InsertTailList(&icbp->ChangesBcastQueue, &bcwip->Linkage);

		// insert the interface CB in the global if changes bcast list
		InsertTailList(&IfChangesBcastList, &icbp->AuxLinkage);
	    }
	}

	lep = lep->Flink;
    }

    // dequeue	the RTM messages. For each message fill in the bcast changes
    // wi packets according to the split horizon algorithm

    if(RIPSignaledChanges) {

	ACQUIRE_RIP_CHANGED_LIST_LOCK;

	while(DequeueRouteChangeFromRip(&IpxRoute) == NO_ERROR) {

	    lep = IfChangesBcastList.Flink;

	    while(lep != &IfChangesBcastList)
	    {
		icbp = CONTAINING_RECORD(lep, ICB, AuxLinkage);

		AddRouteToChangesBcast(icbp, &IpxRoute);

		lep = lep->Flink;
	    }
	}

	RELEASE_RIP_CHANGED_LIST_LOCK;

	RIPSignaledChanges = FALSE;
    }

    if(RTMSignaledChanges) {

	while(DequeueRouteChangeFromRtm(&IpxRoute, &skipit, &lastmessage) == NO_ERROR)
	{
	    if(skipit) {

		if(lastmessage) {

		    break;
		}
		else
		{
		    continue;
		}
	    }
	    else
	    {
		lep = IfChangesBcastList.Flink;

		while(lep != &IfChangesBcastList)
		{
		    icbp = CONTAINING_RECORD(lep, ICB, AuxLinkage);

		    AddRouteToChangesBcast(icbp, &IpxRoute);

		    lep = lep->Flink;
		}

		if(lastmessage) {

		    break;
		}
	    }
	}

	RTMSignaledChanges = FALSE;
    }

    // send the first bcast change wi for each if CB

    while(!IsListEmpty(&IfChangesBcastList))
    {
	lep = RemoveHeadList(&IfChangesBcastList);

	icbp = CONTAINING_RECORD(lep, ICB, AuxLinkage);

	if(!IsListEmpty(&icbp->ChangesBcastQueue)) {

	    lep = RemoveHeadList(&icbp->ChangesBcastQueue);

	    bcwip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

	    // check if the bcast work item packet contains at least one net entry
	    if(!IsChangeBcastPacketEmpty(bcwip->Packet)) {

		// send the bcast change work item
		if(IfRefSendSubmit(bcwip) != NO_ERROR) {

		    // can't send on this interface -> Flush the changes bc queue
		    FlushChangesBcastQueue(icbp);

		    // and free the current changes bcast wi
		    FreeWorkItem(bcwip);
		}
	    }
	    else
	    {
		FreeWorkItem(bcwip);
	    }
	}

	RELEASE_IF_LOCK(icbp);
    }

    // requeue the start changes bcast wi in timer queue
    StartWiTimer(wip, CHANGES_BCAST_TIME);
}

/*++

Function:   IfChangeBcast

Descr:	    if the interface is operational then
	      the change bcast packet work item is freed and the next change bacst
	      wi is dequeued from the interface change bcast queue.
	    else
	      the work item is discarded

Remark:     Called with the interface lock held

--*/

VOID
IfChangeBcast(PWORK_ITEM	wip)
{
    PICB	    icbp;
    PWORK_ITEM	    list_wip;
    PLIST_ENTRY     lep;

    icbp = wip->icbp;

    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

	// flush the associated changes bcast queue if any
	FlushChangesBcastQueue(icbp);
    }
    else
    {
	if(!IsListEmpty(&icbp->ChangesBcastQueue)) {

	    // send next bcast change
	    lep = RemoveHeadList(&icbp->ChangesBcastQueue);
	    list_wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

	    // submit the work item for send and increment the ref count
	    if(IfRefSendSubmit(list_wip) != NO_ERROR) {

		// can't send on this interface -> Flush the changes bc queue
		FlushChangesBcastQueue(icbp);

		// and free the one we intended to send
		FreeWorkItem(list_wip);
	    }
	}
    }

    FreeWorkItem(wip);
}

/*++

Function:	ShutdownInterfaces

Descr:		called to:
		1. Initiate a bcast update on all interfaces with the down routes
		2. check on the bcast update termination

Remark: 	called with database locked

Note:		Because the database is locked when this routine is called,
		no interface can change its operational state while this routine
		is executing

--*/

#define 	IsStartShutdown() \
		wip->WorkItemSpecific.WIS_ShutdownInterfaces.ShutdownState == SHUTDOWN_START

#define 	IsCheckShutdown() \
		wip->WorkItemSpecific.WIS_ShutdownInterfaces.ShutdownState == SHUTDOWN_STATUS_CHECK

#define 	SetCheckShutdown() \
		wip->WorkItemSpecific.WIS_ShutdownInterfaces.ShutdownState = SHUTDOWN_STATUS_CHECK;

/*++

Function:	ShutdownInterfaces

Descr:		if START_SHUTDOWN then:

		initiates if shutdown bcast on all active ifs and
		removes (deletes) all inactive ifs

		else

		removes all ifs which finished shutdown bcast


Remark: 	called with database lock held

--*/

VOID
ShutdownInterfaces(PWORK_ITEM	 wip)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;

    if(IsStartShutdown()) {

	lep = IndexIfList.Flink;
	while(lep != &IndexIfList)
	{
	    icbp = CONTAINING_RECORD(lep, ICB, IfListLinkage);
	    lep = lep->Flink;

	    ACQUIRE_IF_LOCK(icbp);

	    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

		// interface down -> delete it
		Trace(CHANGEBC_TRACE, "ShutdownInterfaces: delete inactive if %d\n", icbp->InterfaceIndex);

		if(!DeleteRipInterface(icbp)) {

		    // if cb moved on discarded list, still referenced
		    RELEASE_IF_LOCK(icbp);
		}
	    }
	    else
	    {
		// interface up -> remove its rip routes
		DeleteAllRipRoutes(icbp->InterfaceIndex);
		RELEASE_IF_LOCK(icbp);
	    }
	}
    }
    else
    {
	SS_ASSERT(IsCheckShutdown());

	lep = IndexIfList.Flink;
	while(lep != &IndexIfList)
	{
	    icbp = CONTAINING_RECORD(lep, ICB, IfListLinkage);
	    lep = lep->Flink;

	    ACQUIRE_IF_LOCK(icbp);

	    if(IsListEmpty(&icbp->ChangesBcastQueue)) {

		Trace(CHANGEBC_TRACE, "ShutdownInterfaces: delete shut-down if %d\n", icbp->InterfaceIndex);

		// interface broadcasted all changes -> delete it
		if(!DeleteRipInterface(icbp)) {

		    // if cb moved on discarded list, still referenced
		    RELEASE_IF_LOCK(icbp);
		}
	    }
	    else
	    {
		// interface still broadcasting
		RELEASE_IF_LOCK(icbp);
	    }
	}
    }

    if(!IsListEmpty(&IndexIfList)) {

	SetCheckShutdown();

	StartWiTimer(wip, 5000);
    }
    else
    {
	// no more ifs up
	FreeWorkItem(wip);
    // signal the worker thread to stop
    SetEvent(WorkerThreadObjects[TERMINATE_WORKER_EVENT]);
    }
}

/*++

Function:	    CreateChnagesBcastWi

Descr:		    allocates and inits the wi and packet header for a chnages bacst

--*/

PWORK_ITEM
CreateChangesBcastWi(PICB	icbp)
{
    PWORK_ITEM		wip;
    UCHAR		ripsocket[2];

    if((wip = AllocateWorkItem(CHANGE_BCAST_PACKET_TYPE)) == NULL) {

	return NULL;
    }

    // init the bcast work item
    wip->icbp = icbp;
    wip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;

    PUTUSHORT2SHORT(ripsocket, IPX_RIP_SOCKET);

    SetRipIpxHeader(wip->Packet,
		    icbp,
		    bcastnode,
		    ripsocket,
		    RIP_RESPONSE);

    // set initial packet length
    PUTUSHORT2SHORT(wip->Packet + IPXH_LENGTH, RIP_INFO); // header length + RIP op code

    return wip;
}

/*++

Function:	AddRouteToChangesBcast

Descr:		checks if the route should be bcasted on this if
		walks the list of broadcast change work items queued at the
		if CB and sets the network entry in the last packet
		If last packet is full allocates a new work bcast work item

--*/

VOID
AddRouteToChangesBcast(PICB	    icbp,
		       PIPX_ROUTE   IpxRoutep)
{
    PUCHAR	    hdrp;
    PLIST_ENTRY     lep;
    USHORT	    pktlen;
    PWORK_ITEM	    wip; // changes bcast wi ptr

    // check if to bcast the route on this if
    if(!IsRouteAdvertisable(icbp, IpxRoutep)) {

	return;
    }

    // go to the last bcast change wi in the list
    lep = icbp->ChangesBcastQueue.Blink;

    if(lep == &icbp->ChangesBcastQueue) {

	// changes bcast queue empty !
	return;
    }

    wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

    // check if the last packet is full
    GETSHORT2USHORT(&pktlen, wip->Packet + IPXH_LENGTH);

    if(pktlen >= RIP_PACKET_LEN) {

	// we need a new packet
	if((wip = CreateChangesBcastWi(icbp)) == NULL) {

	    // out of memory
	    return;
	}

	InsertTailList(&icbp->ChangesBcastQueue, &wip->Linkage);

	GETSHORT2USHORT(&pktlen, wip->Packet + IPXH_LENGTH);
    }

    SetNetworkEntry(wip->Packet + pktlen, IpxRoutep, icbp->LinkTickCount);

    pktlen += NE_ENTRYSIZE;

    PUTUSHORT2SHORT(&wip->Packet + IPXH_LENGTH, pktlen);
}

BOOL
IsChangeBcastPacketEmpty(PUCHAR 	 hdrp)
{
    USHORT	    pktlen;

    GETSHORT2USHORT(&pktlen, hdrp + IPXH_LENGTH);

    if(pktlen > RIP_INFO) {

	return FALSE;
    }
    else
    {
	return TRUE;
    }
}


VOID
FlushChangesBcastQueue(PICB	    icbp)
{
    PLIST_ENTRY 	lep;
    PWORK_ITEM		wip;

    // flush the associated changes bcast queue if any
    while(!IsListEmpty(&icbp->ChangesBcastQueue))
    {
	lep = RemoveHeadList(&icbp->ChangesBcastQueue);
	wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);
	FreeWorkItem(wip);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\globals.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    globals.c

Abstract:

    globals

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop


// ***	  registry parameters

ULONG	    SendGenReqOnWkstaDialLinks = 1;
ULONG		CheckUpdateTime = 10;


// ***	  broadcast and null values for net & node ***

UCHAR	    bcastnet[4] = { 0xff, 0xff, 0xff, 0xff };
UCHAR	    bcastnode[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
UCHAR	    nullnet[4] = { 0, 0, 0, 0 };

// ***	  Rip operational state ***

ULONG	    RipOperState = OPER_STATE_DOWN;


//
//  ***   Database Lock - protects:  ***
//
//  Interface Database, i.e:
//
//  List of interface CBs ordered by interface index
//  Hash table of interface CBs hashed by interface index
//  Hash table of interface CBs hashed by adapter index
//  Discarded interfaces list
//

CRITICAL_SECTION		  DbaseCritSec;

// List of interface CBs ordered by interface index

LIST_ENTRY    IndexIfList;

// Hash table of interface CBs hashed by interface index

LIST_ENTRY     IfIndexHt[IF_INDEX_HASH_TABLE_SIZE];

// Hash table of interface CBs hashed by adapter index

LIST_ENTRY     AdapterIndexHt[ADAPTER_INDEX_HASH_TABLE_SIZE];

// List of discarded interface CBs waiting for all references to terminate
// before being freed

LIST_ENTRY	DiscardedIfList;




//  ***   Queues Lock - protects:   ***
//
//  Repost receive packets queue
//  Work items queue
//  Timer queue
//
//  Receiver ref count
//  Queue of event messages for the router manager

CRITICAL_SECTION		QueuesCritSec;

// workers queue

// LIST_ENTRY			WorkersQueue;

// timer queue

LIST_ENTRY			TimerQueue;

// queue of rcv packets used by the worker and waiting to be reposted (or freed)
// by the rcv thread

LIST_ENTRY			RepostRcvPacketsQueue;

// queue of event messages

LIST_ENTRY			RipMessageQueue;

//***  Worker Thread Wait Objects Table ***

HANDLE	    WorkerThreadObjects[MAX_WORKER_THREAD_OBJECTS];

//***	 Timer Timeout	  ***

ULONG	    TimerTimeout = INFINITE;

// IO Handle
HANDLE		RipSocketHandle;

// Io Completion Port
HANDLE		IoCompletionPortHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\ipxwan\timer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Work Items Timer

Author:

    Stefan Solomon  07/20/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

#define	    TimerHandle   hWaitableObject[TIMER_HANDLE]

LIST_ENTRY  TimerQueue;

/*++

Function:	StartWiTimer


Descr:		Inserts a work item in the timer queue for the specified time

Remark: 	has to take and release the queues lock

--*/

VOID
StartWiTimer(PWORK_ITEM 	reqwip,
	     ULONG		timeout)    // milliseconds
{
    PLIST_ENTRY     lep;
    PWORK_ITEM	    timqwip;
    ULONG	    delay;
    LONGLONG	    to;
    BOOL	    rc;

    reqwip->DueTime = GetTickCount() + timeout;

    ACQUIRE_QUEUES_LOCK;

    lep = TimerQueue.Blink;

    while(lep != &TimerQueue)
    {
	timqwip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);
	if(IsLater(reqwip->DueTime, timqwip->DueTime)) {

	    break;
	}
	lep = lep->Blink;
    }

    InsertHeadList(lep, &reqwip->Linkage);
    reqwip->WiState = WI_WAITING_TIMEOUT;

    if(lep == &TimerQueue) {

	delay = reqwip->DueTime - GetTickCount();
	if(delay > MAXULONG/2) {

	    // already happened
	    to = 0;
	}
	else
	{
	    to = ((LONGLONG)delay) * (-10000);
	}

	rc = SetWaitableTimer(TimerHandle,
			      (PLARGE_INTEGER)&to,
			      0,    // signal once
			      NULL, // no completion routine
			      NULL,
			      FALSE);

	if(!rc) {

	    Trace(TIMER_TRACE, "Cannot start waitable timer %d\n", GetLastError());
	}
    }

    RELEASE_QUEUES_LOCK;
}


/*++

Function:	ProcessTimerQueue


Descr:		called when the timer queue due time has come.
		Dequeues all wi with expired timeout and queues them in the
		workers work items queue

Remark: 	has to take and release the queues lock

--*/

VOID
ProcessTimerQueue(VOID)
{
    ULONG	currTime = GetTickCount();
    ULONG	dueTime = currTime + MAXULONG/2;
    PWORK_ITEM	wip;
    FILETIME	filetime;
    LONGLONG	to;
    DWORD	rc;

    ACQUIRE_QUEUES_LOCK;

    while(!IsListEmpty(&TimerQueue))
    {
	// check the first in the list
	wip = CONTAINING_RECORD(TimerQueue.Flink, WORK_ITEM, Linkage);

	if(IsLater(currTime, wip->DueTime)) {

	    RemoveEntryList(&wip->Linkage);
	    wip->WiState = WI_TIMEOUT_COMPLETED;
	    EnqueueWorkItemToWorker(wip);
	}
	else
	{
	    dueTime = wip->DueTime;
	    break;
	}
    }

    to = ((LONGLONG)(dueTime - currTime)) * (-10000);

    rc = SetWaitableTimer(
			  TimerHandle,
			  (PLARGE_INTEGER)&to,
			  0,	  // signal once
			  NULL, // no completion routine
			  NULL,
			  FALSE);

    if(!rc) {

	Trace(TIMER_TRACE, "Cannot start waitable timer %d\n", GetLastError());
    }

    RELEASE_QUEUES_LOCK;
}

/*++

Function:	StopWiTimer

Descr:		remove from the timer queue all the work items referencing this adapter
		and insert them in the workers queue

Remark: 	takes the queues lock

--*/

VOID
StopWiTimer(PACB	   acbp)
{
    PWORK_ITEM		wip;
    PLIST_ENTRY 	lep;

    ACQUIRE_QUEUES_LOCK;

    lep = TimerQueue.Flink;
    while(lep != &TimerQueue) {

	wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

	lep = lep->Flink;
	if(wip->acbp == acbp) {

	    RemoveEntryList(&wip->Linkage);
	    wip->WiState = WI_TIMEOUT_COMPLETED;
	    EnqueueWorkItemToWorker(wip);
	}

    }

    RELEASE_QUEUES_LOCK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ifdbase.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ifdbase.c

Abstract:

    RIP Interface Data Base Manager
    All functions called with the database locked

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

#define ifhashindex(IfIndex)  (IfIndex) % IF_INDEX_HASH_TABLE_SIZE
#define adapterhashindex(AdapterIndex) (AdapterIndex) % ADAPTER_INDEX_HASH_TABLE_SIZE

USHORT
tickcount(UINT	    linkspeed);


VOID
InitIfDbase(VOID)
{
    int		    i;
    PLIST_ENTRY     HtBucketp;

    InitializeListHead(&IndexIfList);

    InitializeListHead(&DiscardedIfList);

    for(i=0, HtBucketp = IfIndexHt;
	i<IF_INDEX_HASH_TABLE_SIZE;
	i++, HtBucketp++) {

	InitializeListHead(HtBucketp);
    }

    for(i=0, HtBucketp = AdapterIndexHt;
	i<ADAPTER_INDEX_HASH_TABLE_SIZE;
	i++, HtBucketp++) {

	InitializeListHead(HtBucketp);
    }
}

PICB
GetInterfaceByIndex(ULONG	InterfaceIndex)
{
    PLIST_ENTRY     lep, hashbucketp;
    PICB	    icbp;

    hashbucketp = &IfIndexHt[ifhashindex(InterfaceIndex)];
    lep = hashbucketp->Flink;

    while(lep != hashbucketp) {

	icbp = CONTAINING_RECORD(lep, ICB, IfHtLinkage);
	if(icbp->InterfaceIndex == InterfaceIndex) {

	    return icbp;
	}

	lep = lep->Flink;
    }

    return NULL;
}

PICB
GetInterfaceByAdapterIndex(ULONG	AdapterIndex)
{
    PLIST_ENTRY     lep, hashbucketp;
    PICB	    icbp;

    hashbucketp = &AdapterIndexHt[adapterhashindex(AdapterIndex)];
    lep = hashbucketp->Flink;

    while(lep != hashbucketp) {

	icbp = CONTAINING_RECORD(lep, ICB, AdapterHtLinkage);
	if(icbp->AdapterBindingInfo.AdapterIndex == AdapterIndex) {

	    return icbp;
	}

	lep = lep->Flink;
    }

    return NULL;
}

VOID
AddIfToDb(PICB	    icbp)
{
    int 	    hv;
    PLIST_ENTRY     lep;
    PICB	    list_icbp;
    BOOL	    Done = FALSE;

    hv = ifhashindex(icbp->InterfaceIndex);
    InsertTailList(&IfIndexHt[hv], &icbp->IfHtLinkage);

    // insert in the list ordered by index
    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	list_icbp = CONTAINING_RECORD(lep, ICB, IfListLinkage);
	if (list_icbp->InterfaceIndex > icbp->InterfaceIndex) {

	    InsertTailList(lep, &icbp->IfListLinkage);
	    Done = TRUE;
	    break;
	}

	lep = lep->Flink;
    }

    if(!Done) {

	InsertTailList(lep, &icbp->IfListLinkage);
    }
}

VOID
RemoveIfFromDb(PICB	icbp)
{
    RemoveEntryList(&icbp->IfListLinkage);
    RemoveEntryList(&icbp->IfHtLinkage);
}

VOID
BindIf(PICB				icbp,
       PIPX_ADAPTER_BINDING_INFO	BindingInfop)
{
    int 	hv;

    icbp->AdapterBindingInfo = *BindingInfop;

    // set then tick count if not internal interface
    if(icbp->InterfaceIndex != 0) {

	icbp->LinkTickCount = tickcount(BindingInfop->LinkSpeed);
    }

    hv = adapterhashindex(icbp->AdapterBindingInfo.AdapterIndex);
    InsertTailList(&AdapterIndexHt[hv], &icbp->AdapterHtLinkage);
}

/*++

Function:	    UnbindIf

Descr:		    removes the if CB from the adapters hash table
		    sets the adapter index in the if CB to INVALID_ADAPTER_INDEX

--*/

VOID
UnbindIf(PICB			icbp)
{
    RemoveEntryList(&icbp->AdapterHtLinkage);
    icbp->AdapterBindingInfo.AdapterIndex = INVALID_ADAPTER_INDEX;
}

/*++

Function:   tickcount

Descr:	    gets nr of ticks to send a 576 bytes packet over this link

Argument:   link speed as a multiple of 100 bps

--*/

USHORT
tickcount(UINT	    linkspeed)
{
    USHORT   tc;

    if(linkspeed == 0) {

	return 1;
    }

    if(linkspeed >= 10000) {

	// link speed >= 1M bps
	return 1;
    }
    else
    {
	 // compute the necessary time to send a 576 bytes packet over this
	 // line and express it as nr of ticks.
	 // One tick = 55ms

	 // time in ms to send 576 bytes (assuming 10 bits/byte for serial line)
	 tc = 57600 / linkspeed;

	 // in ticks
	 tc = tc / 55 + 1;
	 return tc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ifmgr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ifmgr.c

Abstract:

    RIP Interface Manager

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop



#define IsInterfaceBound(icbp)\
    ((icbp)->AdapterBindingInfo.AdapterIndex != INVALID_ADAPTER_INDEX)

#define IsInterfaceEnabled(icbp)\
    (((icbp)->IfConfigInfo.AdminState == ADMIN_STATE_ENABLED) &&\
     ((icbp)->IpxIfAdminState == ADMIN_STATE_ENABLED))

VOID
StartInterface(PICB    icbp);

VOID
StopInterface(PICB	    icbp);

PICB
CreateInterfaceCB(LPWSTR    InterfaceName,
          ULONG 	       InterfaceIndex,
		  PRIP_IF_INFO	       IfConfigInfop,
		  NET_INTERFACE_TYPE   NetInterfaceType,
		  PRIP_IF_STATS        IfStatsp OPTIONAL);

VOID
DiscardInterfaceCB(PICB 	icbp);

DWORD
CreateNewFiltersBlock(PRIP_IF_FILTERS_I	 *fcbpp,
		      PRIP_IF_FILTERS	 RipIfFiltersp);

DWORD
CreateOldFiltersBlockCopy(PRIP_IF_FILTERS_I	 *fcbpp,
			  PRIP_IF_FILTERS_I	 RipIfFiltersp);

DWORD  WINAPI
AddInterface(
        IN LPWSTR           InterfaceName,
	    IN ULONG		    InterfaceIndex,
	    IN NET_INTERFACE_TYPE   NetInterfaceType,
	    IN PVOID		    InterfaceInfo)
{
    PICB	      icbp;
    PRIP_IF_FILTERS_I fcbp;

    Trace(IFMGR_TRACE, "AddInterface: Entered for if # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(GetInterfaceByIndex(InterfaceIndex) != NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    // create the filters block for this interface
    if(CreateNewFiltersBlock(&fcbp, &((PRIP_IF_CONFIG)InterfaceInfo)->RipIfFilters) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = CreateInterfaceCB(
                InterfaceName,
                InterfaceIndex,
				(PRIP_IF_INFO)InterfaceInfo,
				NetInterfaceType,
				NULL)) == NULL) {

	if(fcbp) {

	    GlobalFree(fcbp);
	}

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    // bind the filters block with the interface control block
    icbp->RipIfFiltersIp = fcbp;

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD	WINAPI
DeleteInterface(
	    IN ULONG	InterfaceIndex)
{
    PICB	icbp;
    DWORD	rc;

    Trace(IFMGR_TRACE,"DeleteInterface: Entered for if # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    ACQUIRE_IF_LOCK(icbp);

    if(!DeleteRipInterface(icbp)) {

	// interface CB still exists but has been discarded
	RELEASE_IF_LOCK(icbp);
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}


DWORD  WINAPI
GetInterfaceConfigInfo(
	IN ULONG	    InterfaceIndex,
	IN PVOID	    InterfaceInfo,
	IN OUT PULONG	    InterfaceInfoSize)
{
    PICB		     icbp;
    DWORD		     rc, i;
    ULONG		     ifconfigsize;
    PRIP_IF_FILTERS_I	     fcbp;
    PRIP_IF_FILTERS	     RipIfFiltersp;
    PRIP_ROUTE_FILTER_INFO   rfp;
    PRIP_ROUTE_FILTER_INFO_I rfip;


    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    ACQUIRE_IF_LOCK(icbp);

    ifconfigsize = sizeof(RIP_IF_CONFIG);

    if((fcbp = icbp->RipIfFiltersIp) != NULL) {

	ifconfigsize += (fcbp->SupplyFilterCount +
			 fcbp->ListenFilterCount - 1) * sizeof(RIP_ROUTE_FILTER_INFO);
    }

    if((InterfaceInfo == NULL) || (*InterfaceInfoSize < ifconfigsize)) {

	*InterfaceInfoSize = ifconfigsize;

	RELEASE_IF_LOCK(icbp);
	RELEASE_DATABASE_LOCK;
	return ERROR_INSUFFICIENT_BUFFER;
    }

    ((PRIP_IF_CONFIG)InterfaceInfo)->RipIfInfo = icbp->IfConfigInfo;
    RipIfFiltersp = &(((PRIP_IF_CONFIG)InterfaceInfo)->RipIfFilters);

    if(fcbp == NULL) {

	// no filters
	memset(RipIfFiltersp, 0, sizeof(RIP_IF_FILTERS));
    }
    else
    {
	// convert all filters from internal to external format
	if(fcbp->SupplyFilterAction) {

	    RipIfFiltersp->SupplyFilterAction = IPX_ROUTE_FILTER_PERMIT;
	}
	else
	{
	    RipIfFiltersp->SupplyFilterAction = IPX_ROUTE_FILTER_DENY;
	}

	RipIfFiltersp->SupplyFilterCount = fcbp->SupplyFilterCount;

	if(fcbp->ListenFilterAction) {

	    RipIfFiltersp->ListenFilterAction = IPX_ROUTE_FILTER_PERMIT;
	}
	else
	{
	    RipIfFiltersp->ListenFilterAction = IPX_ROUTE_FILTER_DENY;
	}

	RipIfFiltersp->ListenFilterCount = fcbp->ListenFilterCount;

	rfp = RipIfFiltersp->RouteFilter;
	rfip = fcbp->RouteFilterI;

	for(i=0;
	    i<fcbp->SupplyFilterCount + fcbp->ListenFilterCount;
	    i++, rfp++, rfip++)
	{
	    PUTULONG2LONG(rfp->Network, rfip->Network);
	    PUTULONG2LONG(rfp->Mask, rfip->Mask);
	}
    }

    *InterfaceInfoSize = ifconfigsize;

    RELEASE_IF_LOCK(icbp);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD  WINAPI
SetInterfaceConfigInfo(
	IN ULONG	InterfaceIndex,
	IN PVOID	InterfaceInfo)
{
    DWORD		rc;
    PICB		icbp;
    PRIP_IF_FILTERS_I	fcbp;


    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    // create the filters block for this interface
    if(CreateNewFiltersBlock(&fcbp, &((PRIP_IF_CONFIG)InterfaceInfo)->RipIfFilters) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    rc = SetRipInterface(InterfaceIndex,
			 (PRIP_IF_INFO)InterfaceInfo,
			 fcbp,
			 0);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD  WINAPI
BindInterface(
	IN ULONG	InterfaceIndex,
	IN PVOID	BindingInfo)
{
    PICB	      icbp, newicbp;
    DWORD	      rc;
    PWORK_ITEM	      wip;
    PRIP_IF_FILTERS_I  fcbp = NULL;

    Trace(IFMGR_TRACE, "BindInterface: Entered for if # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    ACQUIRE_IF_LOCK(icbp);

    if(IsInterfaceBound(icbp)) {

	SS_ASSERT(FALSE);

	RELEASE_IF_LOCK(icbp);
	RELEASE_DATABASE_LOCK;

	return ERROR_INVALID_PARAMETER;
    }

    SS_ASSERT(icbp->IfStats.RipIfOperState != OPER_STATE_UP);

    if(icbp->RefCount) {

	// The interface is UNBOUND but is still referenced.
	// make a copy of the old if filters if any
	if(icbp->RipIfFiltersIp != NULL) {

	    if(CreateOldFiltersBlockCopy(&fcbp, icbp->RipIfFiltersIp) != NO_ERROR) {

		// cannot allocate memory for the copy of the filters block
		RELEASE_IF_LOCK(icbp);
		RELEASE_DATABASE_LOCK;
		return ERROR_CAN_NOT_COMPLETE;
	    }
	}

	// remove the old if Cb from the if list and hash
	RemoveIfFromDb(icbp);

	if((newicbp = CreateInterfaceCB(
                    icbp->InterfaceName,
                    InterfaceIndex,
					&icbp->IfConfigInfo,
					icbp->InterfaceType,
					&icbp->IfStats)) == NULL) {

	    // restore the old if and get out
	    AddIfToDb(icbp);

	    if(fcbp != NULL) {

		GlobalFree(fcbp);
	    }

	    RELEASE_IF_LOCK(icbp);
	    RELEASE_DATABASE_LOCK;
	    return ERROR_CAN_NOT_COMPLETE;
	}

	// bind the old filters copy to the new interface
	if(icbp->RipIfFiltersIp != NULL) {

	   newicbp->RipIfFiltersIp = fcbp;
	}

	newicbp->IfConfigInfo = icbp->IfConfigInfo;
	newicbp->IpxIfAdminState = icbp->IpxIfAdminState;

	DiscardInterfaceCB(icbp);

	RELEASE_IF_LOCK(icbp);

	ACQUIRE_IF_LOCK(newicbp);

	icbp = newicbp;
    }

	// bind the if to adapter and add it to adapter hash table
	BindIf(icbp, (PIPX_ADAPTER_BINDING_INFO)BindingInfo);

	// start work on this interface if the admin state is enabled
	if(IsInterfaceEnabled(icbp) && (InterfaceIndex!=0)) {

	StartInterface(icbp);
	}

    RELEASE_IF_LOCK(icbp);
    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD  WINAPI
UnbindInterface(
	   IN ULONG	InterfaceIndex)
{
    PICB	   icbp;
    DWORD	rc;

    Trace(IFMGR_TRACE, "UnbindInterface: Entered for if # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    ACQUIRE_IF_LOCK(icbp);

    if(!IsInterfaceBound(icbp)) {

	// already unbound
	RELEASE_IF_LOCK(icbp);
	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    UnbindIf(icbp);

    if(icbp->IfStats.RipIfOperState == OPER_STATE_UP) {

	// remove RIP routes added by this interface and discard the send queue
	StopInterface(icbp);
    }

    RELEASE_IF_LOCK(icbp);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD  WINAPI
EnableInterface(IN ULONG	InterfaceIndex)
{
    DWORD   rc;
    PICB    icbp;

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    rc = SetRipInterface(InterfaceIndex, NULL, NULL, ADMIN_STATE_ENABLED);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD  WINAPI
DisableInterface(IN ULONG	InterfaceIndex)
{
    DWORD   rc;
    PICB    icbp;

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    rc = SetRipInterface(InterfaceIndex, NULL, NULL, ADMIN_STATE_DISABLED);

    RELEASE_DATABASE_LOCK;

    return rc;
}


/*++

Function:	SetRipInterface

Descr:		set the new interface parameters.
		If the interface was actively doing something, all operations
		are implicitly aborted on this interface.

Remark: 	Called with the database lock held

--*/


DWORD
SetRipInterface(ULONG		    InterfaceIndex,
		PRIP_IF_INFO	    RipIfInfop,	  // if this parameter NULL -> Enable/Disable if
		PRIP_IF_FILTERS_I   RipIfFiltersIp,
		ULONG		    IpxIfAdminState)
{
    PICB		       icbp, newicbp;
    IPX_ADAPTER_BINDING_INFO   AdapterBindingInfo;
    PWORK_ITEM		       wip;
    PRIP_IF_FILTERS_I	       fcbp = NULL;

    if((icbp = GetInterfaceByIndex(InterfaceIndex)) == NULL) {

	return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_IF_LOCK(icbp);

    if(icbp->RefCount) {

	// The interface is still referenced.

	// if this is an enable/disable interface call, we need to make a copy of the old
	// interface filter block
	if((RipIfInfop == NULL) &&
	   (icbp->RipIfFiltersIp != NULL)) {

	    if(CreateOldFiltersBlockCopy(&fcbp, icbp->RipIfFiltersIp) != NO_ERROR) {

		// cannot allocate memory for the copy of the filters block
		RELEASE_IF_LOCK(icbp);
		return ERROR_CAN_NOT_COMPLETE;
	    }
	}

	// remove the old if CB from the if list and hash
	RemoveIfFromDb(icbp);

	// Create a new if CB and add it to the list
	if((newicbp = CreateInterfaceCB(
                    icbp->InterfaceName,
                    InterfaceIndex,
					&icbp->IfConfigInfo,
					icbp->InterfaceType,
					&icbp->IfStats)) == NULL) {

	    // restore the old if and get out
	    AddIfToDb(icbp);

	    if(fcbp != NULL) {

		GlobalFree(fcbp);
	    }

	    RELEASE_IF_LOCK(icbp);
	    return ERROR_CAN_NOT_COMPLETE;
	}

	// bind the new interface cb with a copy of the old filter block if this is just an
	// enable/disable
	if((RipIfInfop == NULL) &&
	   (icbp->RipIfFiltersIp != NULL)) {

	   newicbp->RipIfFiltersIp = fcbp;
	}

	if(IsInterfaceBound(icbp)) {

	    // copy the binding info and insert the new one in adapters hash table
	    // if bound.
	    AdapterBindingInfo = icbp->AdapterBindingInfo;

	    // remove the old if from the adapters hash and insert the new one
	    UnbindIf(icbp);
	    BindIf(newicbp, &AdapterBindingInfo);
	}

	// copy the old config info and the old binding info
	newicbp->IfConfigInfo = icbp->IfConfigInfo;
	newicbp->IpxIfAdminState = icbp->IpxIfAdminState;

	DiscardInterfaceCB(icbp);

	ACQUIRE_IF_LOCK(newicbp);

	RELEASE_IF_LOCK(icbp);

	icbp = newicbp;
    }
    //
    // *** Set the new config info  OR	Set the new Ipx If Admin State ***
    //

    // if this is a SetInterface call, modify the configuration
    if(RipIfInfop != NULL) {

	// config info has changed
	icbp->IfConfigInfo = *RipIfInfop;

	// dispose of the old filters block if any and bind to the new one
	if((icbp->RipIfFiltersIp != NULL) && (icbp->RipIfFiltersIp!=RipIfFiltersIp)) {

	    GlobalFree(icbp->RipIfFiltersIp);
	}

	icbp->RipIfFiltersIp = RipIfFiltersIp;
    }
    else
    {
	// Ipx interface admin state has changed
	icbp->IpxIfAdminState = IpxIfAdminState;
    }

	if (InterfaceIndex!=0) {
		if(IsInterfaceBound(icbp)) {

		if(IsInterfaceEnabled(icbp)) {

			StartInterface(icbp);
		}
		else
		{
			// interface has been disabled
			if(icbp->IfStats.RipIfOperState == OPER_STATE_UP) {

			// remove the routes and discard the changes bcast queue
			StopInterface(icbp);
			}
			else
				icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;
		}
		}
		else {
			if (IsInterfaceEnabled(icbp)
					&& (icbp->InterfaceType!=PERMANENT))
				icbp->IfStats.RipIfOperState = OPER_STATE_SLEEPING;
			else
				icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;
		}
	}

    RELEASE_IF_LOCK(icbp);

    return NO_ERROR;
}

/*++

Function:	StartInterface

Descr:		Start work on this interface

Remark: 	Called with interface lock held

--*/

VOID
StartInterface(PICB	   icbp)
{
    PWORK_ITEM	    bcwip, grwip;

    Trace(IFMGR_TRACE, "StartInterface: Entered for if index %d\n", icbp->InterfaceIndex);

    icbp->IfStats.RipIfOperState = OPER_STATE_UP;
    // check that this is not the internal interface and
    // check the update type and make a periodic update work item if necessary
    if(((icbp->IfConfigInfo.UpdateMode == IPX_STANDARD_UPDATE) &&
	(icbp->IfConfigInfo.Supply == ADMIN_STATE_ENABLED)) ||
	(icbp->InterfaceType == LOCAL_WORKSTATION_DIAL)) {


	if((bcwip = AllocateWorkItem(PERIODIC_BCAST_PACKET_TYPE)) == NULL) {

	    goto ErrorExit;
	}

	// init the periodic bcast work item
	bcwip->icbp = icbp;
	bcwip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;

	// mark the work item state as "start of bcast"
	bcwip->WorkItemSpecific.WIS_EnumRoutes.RtmEnumerationHandle = NULL;

	// start bcast on this interface
	IfPeriodicBcast(bcwip);

	// send a general request packet on this interface
	SendRipGenRequest(icbp);
    }

    if(((icbp->InterfaceType == REMOTE_WORKSTATION_DIAL) ||
       (icbp->InterfaceType == LOCAL_WORKSTATION_DIAL)) &&
       SendGenReqOnWkstaDialLinks) {

	if((grwip = AllocateWorkItem(PERIODIC_GEN_REQUEST_TYPE)) == NULL) {

	    goto ErrorExit;
	}

	grwip->icbp = icbp;
	grwip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;

	IfPeriodicGenRequest(grwip);
    }

    return;

ErrorExit:

    icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;

    return;
}


/*++

Function:	StopInterface

Descr:		Stop work on this interface:
		remove rip routes added by this interface
		set oper state to sleeping

Remark: 	Called with database AND interface locks held

--*/

VOID
StopInterface(PICB	    icbp)
{
    PLIST_ENTRY 	lep;
    PWORK_ITEM		wip;

    Trace(IFMGR_TRACE, "StopInterface: Entered for if index %d\n", icbp->InterfaceIndex);

    DeleteAllRipRoutes(icbp->InterfaceIndex);

    if (IsInterfaceEnabled (icbp))
        icbp->IfStats.RipIfOperState = OPER_STATE_SLEEPING;
    else
        icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;
        
}


/*++

Function:	CreateInterfaceCB

Descr:		allocate interface CB
		init if lock
		init if index
		init if config info
		init if stats
		add if to db
		mark it unbound

--*/

PICB
CreateInterfaceCB(
          LPWSTR                InterfaceName,
          ULONG 	            InterfaceIndex,
		  PRIP_IF_INFO	        IfConfigInfop,
		  NET_INTERFACE_TYPE    InterfaceType,
		  PRIP_IF_STATS         IfStatsp OPTIONAL)
{
    PICB	icbp;

    if((icbp = GlobalAlloc(GPTR,
            FIELD_OFFSET(ICB,InterfaceName[wcslen(InterfaceName)+1]))) == NULL) {

	return NULL;
    }

    // create the interface lock
    try {

	InitializeCriticalSection(&icbp->InterfaceLock);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {

	GlobalFree(icbp);
	return NULL;
    }

    // initialize the ICB
    wcscpy (icbp->InterfaceName, InterfaceName);
    icbp->InterfaceIndex = InterfaceIndex;

    icbp->IfConfigInfo = *IfConfigInfop;
    icbp->InterfaceType = InterfaceType;

    if(IfStatsp != NULL) {

	icbp->IfStats = *IfStatsp;
    }
    else
    {
	icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;
	icbp->IfStats.RipIfInputPackets = 0;
	icbp->IfStats.RipIfOutputPackets = 0;
    }

    icbp->RefCount = 0;

    // link the ICB in the ordered if list and the if hash table
    AddIfToDb(icbp);

    icbp->Discarded = FALSE;

    // init the changes bcast queue
    InitializeListHead(&icbp->ChangesBcastQueue);

    // mark the interface as unbound to any adapter
    icbp->AdapterBindingInfo.AdapterIndex = INVALID_ADAPTER_INDEX;

    // set the ipx if admin state to disabled until we find out what it is
    icbp->IpxIfAdminState = ADMIN_STATE_DISABLED;

    // set the filters block ptr to null initially
    icbp->RipIfFiltersIp = NULL;

    return icbp;
}



/*++

Function:	DiscardInterfaceCB

Descr:		insert the if in the discarded list
		mark it discarded
		set its oper state to down so the referencing work items will
		know to
--*/

VOID
DiscardInterfaceCB(PICB 	icbp)
{
    icbp->IfStats.RipIfOperState = OPER_STATE_DOWN;

    InsertTailList(&DiscardedIfList, &icbp->IfListLinkage);

    icbp->Discarded = TRUE;

    Trace(IFMGR_TRACE, "DiscardInterface: interface CB for if # %d moved on DISCARDED list\n",
		       icbp->InterfaceIndex);
}

/*++

Function:	DeleteRipInterface

Descr:		remove the if from the database
		unbinds and stops the if if active
		if not referenced frees the if CB and destroys the lock,
		else discards it

Returns:	TRUE  - interface CB has been freed and if lock deleted
		FALSE - interface CB has been discarded and if lock is valid

Remark:		called with if lock held AND database lock held

--*/

BOOL
DeleteRipInterface(PICB     icbp)
{
    // remove the interface from the database
    RemoveIfFromDb(icbp);

    // check if the interface is still bound to an adapter.
    if(IsInterfaceBound(icbp)) {

	UnbindIf(icbp);
    }

    // set if state to sleeping and remove changes bcast queued at the if cb
    if(icbp->IfStats.RipIfOperState == OPER_STATE_UP) {

	StopInterface(icbp);
    }

    // check if the interface is still referenced
    if(icbp->RefCount == 0) {

	Trace(IFMGR_TRACE, "DeleteRipInterface: free interface CB for if # %d\n",
		       icbp->InterfaceIndex);

	// no more references to this interface CB, free it
	//
	DestroyInterfaceCB(icbp);

	return TRUE;
    }
    else
    {
	// the interface CB is still referenced. It will be freed by the
	// worker when the RefCount becomes 0.
	DiscardInterfaceCB(icbp);

	return FALSE;
    }
}

DWORD
ValidStateAndIfIndex(ULONG	InterfaceIndex,
		     PICB	*icbpp)
{
    if(RipOperState != OPER_STATE_UP) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    if((*icbpp = GetInterfaceByIndex(InterfaceIndex)) == NULL) {

	return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


/*++

Function:	CreateFiltersBlock

Descr:		Allocates and initializes a filters block from the
		Add/Set Interface Config filter parameter

--*/

DWORD
CreateNewFiltersBlock(PRIP_IF_FILTERS_I	 *fcbpp,
		      PRIP_IF_FILTERS	 RipIfFiltersp)
{
    ULONG		     FcbSize, i;
    PRIP_ROUTE_FILTER_INFO   rfp;
    PRIP_ROUTE_FILTER_INFO_I rfip;

    if((RipIfFiltersp->SupplyFilterCount == 0) &&
       (RipIfFiltersp->ListenFilterCount == 0)) {

	*fcbpp = NULL;
	return NO_ERROR;
    }

    FcbSize = sizeof(RIP_IF_FILTERS_I) +
	      (RipIfFiltersp->SupplyFilterCount +
	       RipIfFiltersp->ListenFilterCount - 1) * sizeof(RIP_ROUTE_FILTER_INFO_I);

    if((*fcbpp = GlobalAlloc(GPTR, FcbSize)) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    if(RipIfFiltersp->SupplyFilterAction == IPX_ROUTE_FILTER_PERMIT) {

	(*fcbpp)->SupplyFilterAction = TRUE;
    }
    else
    {
	(*fcbpp)->SupplyFilterAction = FALSE;
    }

    if(RipIfFiltersp->ListenFilterAction == IPX_ROUTE_FILTER_PERMIT) {

	(*fcbpp)->ListenFilterAction = TRUE;
    }
    else
    {
	(*fcbpp)->ListenFilterAction = FALSE;
    }

    (*fcbpp)->SupplyFilterCount = RipIfFiltersp->SupplyFilterCount;
    (*fcbpp)->ListenFilterCount = RipIfFiltersp->ListenFilterCount;

    // convert route_filters into route_filters_i
    rfp = RipIfFiltersp->RouteFilter;
    rfip = (*fcbpp)->RouteFilterI;

    for(i=0;
	i<RipIfFiltersp->SupplyFilterCount + RipIfFiltersp->ListenFilterCount;
	i++, rfp++, rfip++)
    {
	GETLONG2ULONG(&rfip->Network, rfp->Network);
	GETLONG2ULONG(&rfip->Mask, rfp->Mask);
    }

    return NO_ERROR;
}


/*++

Function:	CreateOldFiltersBlockCopy

Descr:		Allocates and initializes a filters block from an existing filters block

--*/

DWORD
CreateOldFiltersBlockCopy(PRIP_IF_FILTERS_I	 *fcbpp,
			  PRIP_IF_FILTERS_I	 RipIfFiltersp)
{
    ULONG		     FcbSize;

    FcbSize = sizeof(RIP_IF_FILTERS_I) +
	      (RipIfFiltersp->SupplyFilterCount +
	       RipIfFiltersp->ListenFilterCount - 1) * sizeof(RIP_ROUTE_FILTER_INFO_I);

    if((*fcbpp = GlobalAlloc(GPTR, FcbSize)) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    memcpy(*fcbpp, RipIfFiltersp, FcbSize);

    return NO_ERROR;
}

VOID
DestroyInterfaceCB(PICB     icbp)
{
    DeleteCriticalSection(&icbp->InterfaceLock);

    if(icbp->RipIfFiltersIp) {

	GlobalFree(icbp->RipIfFiltersIp);
    }

    GlobalFree(icbp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\io.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Contains the rcv packet routines

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

// nr of receive work items (receive packets) posted
ULONG		RcvPostedCount;

// nr of send worl items posted
ULONG		SendPostedCount;

// high and low water marks for the current count of posted rcv packets

#define     RCV_POSTED_LOW_WATER_MARK	    8
#define     RCV_POSTED_HIGH_WATER_MARK	    16

ULONG		RcvPostedLowWaterMark = RCV_POSTED_LOW_WATER_MARK;
ULONG		RcvPostedHighWaterMark = RCV_POSTED_HIGH_WATER_MARK;



// current count of rcv packets completed and waiting processing
ULONG		RcvProcessingCount;


// limit on the number of rcv packets completed and waiting processing
#define     MAX_RCV_PROCESSING		1000;

ULONG		MaxRcvProcessing = MAX_RCV_PROCESSING;


/*++

Function:	OpenRipSocket

Descr:

--*/

DWORD
OpenRipSocket(VOID)
{
    USHORT	 ripsocket;

    PUTUSHORT2SHORT(&ripsocket, IPX_RIP_SOCKET);

    if((RipSocketHandle = CreateSocketPort(ripsocket)) == INVALID_HANDLE_VALUE) {

	Trace(INIT_TRACE, "CreateSocketPort FAILED!\n");
    IF_LOG(EVENTLOG_ERROR_TYPE) {
        RouterLogErrorA (RipEventLogHdl,
                ROUTERLOG_IPXRIP_RIP_SOCKET_IN_USE,
                0, NULL, GetLastError ());
    }

	return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

/*++

Function:	CloseRipSocket

Descr:

--*/

DWORD
CloseRipSocket(VOID)
{
    DWORD    rc;

    rc = DeleteSocketPort(RipSocketHandle);

    Trace(INIT_TRACE, "IpxRip: DeleteSocketPort rc = %d\n", rc);

    return rc;
}


/*++

Function:	StartReceiver

Descr:		Starts allocating and posting receive
		work items until it reaches the low water mark.

--*/

VOID
StartReceiver(VOID)
{
    PWORK_ITEM	    wip;
    DWORD	    rc;

    // init RcvProcessingCount
    RcvProcessingCount = 0;

    ACQUIRE_QUEUES_LOCK;

    while(RcvPostedCount < RcvPostedLowWaterMark) {

	if((wip = AllocateWorkItem(RECEIVE_PACKET_TYPE)) == NULL) {

	    // !!! log something
	    break;
	}

	if((rc = ReceiveSubmit(wip)) != NO_ERROR) {

	    FreeWorkItem(wip);
	    break;
	}
    }

    RELEASE_QUEUES_LOCK;
}

/*++

Function:	RepostRcvPackets

Descr:		invoked in the rcv thread when signaled that rcv pkts are
		available in the repostrcvpackets queue.
		Dequeues all available packets and either reposts them up to
		high water mark or frees them if enough reposted

--*/

VOID
RepostRcvPackets(VOID)
{
    PWORK_ITEM	    wip;
    PLIST_ENTRY     lep;
    DWORD	    rc;

    ACQUIRE_QUEUES_LOCK;

    while(!IsListEmpty(&RepostRcvPacketsQueue))
    {
	RcvProcessingCount--;

	lep = RemoveHeadList(&RepostRcvPacketsQueue);
	wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

	// if the protocol is stopping OR
	// enough rcv packets posted (i.e. posted up to high water mark, discard
	// the rcv packet
	if(((RipOperState != OPER_STATE_STARTING) &&
	    (RipOperState != OPER_STATE_UP)) ||
	   (RcvPostedCount >= RcvPostedHighWaterMark)) {

	   // discard the received wi and don't repost
	   FreeWorkItem(wip);
	}
	else
	{
	    if((rc = ReceiveSubmit(wip)) != NO_ERROR) {

		FreeWorkItem(wip);
	    }
	}
    }

    RELEASE_QUEUES_LOCK;
}

/*++

Function:	ReceiveComplete

Descr:		invoked in the io completion thread when a receive packet has completed.
		if the number of receive packets waiting to be processed is below
		the limit then
		   Enqueues the received packet work item in the WorkersQueue.
		Finally, it reposts a new receive packet if below the low water mark.

--*/

VOID
ReceiveComplete(PWORK_ITEM	wip)
{
    PWORK_ITEM	    newwip;
    DWORD	    rc;
    PUCHAR	    reservedp;

    reservedp = wip->AddressReserved.Reserved;
    wip->AdapterIndex =  GetNicId(reservedp);

    ACQUIRE_QUEUES_LOCK;

    InterlockedDecrement(&RcvPostedCount);

    if(wip->IoCompletionStatus != NO_ERROR) {

	Trace(RECEIVE_TRACE, "Receive posted failed with error 0x%x\n",
		  wip->IoCompletionStatus);
    }

    // if the protocol is stopping all the receive work items will get discarded
    if((RipOperState != OPER_STATE_STARTING) &&
       (RipOperState != OPER_STATE_UP)) {

	// discard the received wi and don't repost
	FreeWorkItem(wip);

	RELEASE_QUEUES_LOCK;
	return;
    }

    // if completed with error or too many waiting to be processed,
    // then repost the same

    if((wip->IoCompletionStatus != NO_ERROR) ||
       (RcvProcessingCount >= MaxRcvProcessing)) {

	// repost if below water mark
	if(RcvPostedCount < RcvPostedLowWaterMark) {

	    if((rc = ReceiveSubmit(wip)) != NO_ERROR) {

		FreeWorkItem(wip);
	    }
	}
	else
	{
	    // enough posted already
	    FreeWorkItem(wip);
	}

	RELEASE_QUEUES_LOCK;
	return;
    }

    //
    //** Process the received packet **
    //

    // first repost a new receive packet if below water mark
    if(RcvPostedCount < RcvPostedLowWaterMark) {

	if((newwip = AllocateWorkItem(RECEIVE_PACKET_TYPE)) == NULL) {

	    Trace(RECEIVE_TRACE, "ReceiveComplete: Cannot allocate receive packet\n");
	}
	else
	{
	    // repost the new receive packet and increment the ref count
	    if((rc = ReceiveSubmit(newwip)) != NO_ERROR) {

		FreeWorkItem(newwip);
	    }
	}
    }

    RcvProcessingCount++;


    RELEASE_QUEUES_LOCK;
    ProcessWorkItem(wip);
}


/*++

Function:	SendComplete

Descr:		invoked in the worker thread APC when a send packet has completed

--*/

VOID
SendComplete(PWORK_ITEM     wip)
{
    InterlockedDecrement(&SendPostedCount);

    // if this is a regular send packet, discard it
    if(wip->Type == SEND_PACKET_TYPE) {

	FreeWorkItem(wip);
	return;
    }

    // time stamp and enqueue in the workers queue for further processing
    wip->TimeStamp = GetTickCount();

    ProcessWorkItem(wip);

}


/*++

Function:	EnqueueRcvPacketToRepostQueue

Descr:		take queues lock
		enqueues rcv packet in repost queue
		signals repost queue event
		rel queues lock

--*/

VOID
EnqueueRcvPacketToRepostQueue(PWORK_ITEM	wip)
{
    ACQUIRE_QUEUES_LOCK;

    InsertTailList(&RepostRcvPacketsQueue, &wip->Linkage);

    RELEASE_QUEUES_LOCK;

    SetEvent(WorkerThreadObjects[REPOST_RCV_PACKETS_EVENT]);
}

/*++

Function:      ReceiveSubmit

Descr:	       posts a receive packet work item for receive
	       increments the receive count

--*/

DWORD
ReceiveSubmit(PWORK_ITEM	wip)
{
    DWORD	rc;

    wip->Overlapped.hEvent = NULL;

    rc = IpxRecvPacket(RipSocketHandle,
		       wip->Packet,
		       MAX_PACKET_LEN,
		       &wip->AddressReserved,
		       &wip->Overlapped,
		       NULL);

    if(rc != NO_ERROR) {

	Trace(RECEIVE_TRACE, "Failed to submit receive error 0x%x\n", rc);
    }
    else
    {
	InterlockedIncrement(&RcvPostedCount);
    }

    return rc;
}



/*++

Function:      SendSubmit

Descr:	       posts a send packet work item for send to the adapter index
	       specified by the work item
	       increments the send statistics for the interface specified
	       by the work item

Remark:        >> called with the interface lock held <<

--*/


DWORD
SendSubmit(PWORK_ITEM		wip)
{
    DWORD	rc;
    USHORT	SendPacketLength;

    // increment the send statistics. Note that we still hold the if lock here
    wip->icbp->IfStats.RipIfOutputPackets++;

    // get the length from the packet to send
    SendPacketLength = GETSHORT2USHORT(&SendPacketLength, wip->Packet + IPXH_LENGTH);
    wip->Overlapped.hEvent = NULL;

    rc = IpxSendPacket(RipSocketHandle,
		       wip->AdapterIndex,
		       wip->Packet,
		       (ULONG)SendPacketLength,
		       &wip->AddressReserved,
		       &wip->Overlapped,
		       NULL);

    if(rc != NO_ERROR) {

	Trace(SEND_TRACE, "Failed to send the packet on if %d error 0x%x\n",
	      wip->icbp->InterfaceIndex,
	      rc);
    }
    else
    {
	InterlockedIncrement(&SendPostedCount);
    }

    return rc;
}

/*++

Function:	IfRefSendSubmit

Descr:		send a work item and increment the interface ref count

Remark: 	>> called with the interface lock held <<

--*/

DWORD
IfRefSendSubmit(PWORK_ITEM	    wip)
{
    DWORD	rc;

    if((rc = SendSubmit(wip)) == NO_ERROR) {

	wip->icbp->RefCount++;
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dim.h>
#include <rtm.h>
#include <stm.h>
#include <ipxrtprt.h>
#include <mprlog.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <adapter.h>
#include <ipxrip.h>
#include <rtutils.h>
#include "ripint.h"
#include "packet.h"
#include "prot.h"
#include "utils.h"
#include "ripdbg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\packet.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	packet.h
//
// Description: Contains general definitions for the ipx and rip packets
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _PACKET_
#define _PACKET_

//*** Socket Numbers

#define IPX_RIP_SOCKET	    (USHORT)0x453

//*** Packet Types

#define IPX_RIP_TYPE	    1	   // RIP request/reply packet

//*** RIP Operations

#define RIP_REQUEST	   (USHORT)1
#define RIP_RESPONSE	   (USHORT)2

//*** Offsets into the IPX header

#define IPXH_HDRSIZE	    30	    // Size of the IPX header
#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH	    2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET	    18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

#define IPX_NET_LEN	    4
#define IPX_NODE_LEN	    6

//*** RIP Operation Field Offset

#define RIP_OPCODE	    30	    // rip operation code offset

//*** Network entry structure in the RIP request/response

#define RIP_INFO	    32	    // first network entry offset in the rip packet

#define NE_ENTRYSIZE	    8	    // 4 network + 2 hops + 2 ticks
#define NE_NETNUMBER	    0	    // network number offset
#define NE_NROFHOPS	    4	    // number of hops offset
#define NE_NROFTICKS	    6	    // number of ticks offset

//*** maximum nr of hops for a normal packet ***

#define IPX_MAX_HOPS	    16

//*** define max RIP packet size

#define RIP_PACKET_LEN	    432
#define MAX_PACKET_LEN	    1500

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\prot.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    prot.h

Abstract:

    RIP component prototypes

Author:

    Stefan Solomon  06/22/1995

Revision History:


--*/

#ifndef _PROT_
#define _PROT_

VOID
InitIfDbase(VOID);

PICB
GetInterfaceByIndex(ULONG	InterfaceIndex);

PICB
GetInterfaceByAdapterIndex(ULONG	AdapterIndex);

VOID
AddIfToDb(PICB	    icbp);

VOID
RemoveIfFromDb(PICB	icbp);

VOID
BindIf(PICB			icbp,
       PIPX_ADAPTER_BINDING_INFO	BindingInfop);

VOID
UnbindIf(PICB			icbp);

VOID
ProcessReceivedPacket(PWORK_ITEM	wip);

VOID
PostEventMessage(ROUTING_PROTOCOL_EVENTS	Event,
		 PMESSAGE			Result);

BOOL
DeleteRipInterface(PICB     icbp);

DWORD
SetRipInterface(ULONG		    InterfaceIndex,
		PRIP_IF_INFO	    RipIfInfop,
		PRIP_IF_FILTERS_I   RipIfFiltersIp,
		ULONG		    IpxIfAdminState);

DWORD
InitTimer(VOID);

VOID
StartWiTimer(PWORK_ITEM 	wip,
	     ULONG		timeout);

ULONG
ProcessTimerQueue(VOID);

VOID
FlushTimerQueue(VOID);


DWORD
OpenRipSocket(VOID);

DWORD
CloseRipSocket(VOID);

VOID
StartReceiver(VOID);

VOID
RepostRcvPackets(VOID);

VOID
EnqueueRcvPacketToRepostQueue(PWORK_ITEM	wip);

PWORK_ITEM
DequeueRcvPacketFromRepostQueue(PWORK_ITEM	wip);

DWORD
ReceiveSubmit(PWORK_ITEM	wip);

DWORD
SendSubmit(PWORK_ITEM		wip);

VOID
CreateStartChangesBcastWi(VOID);

VOID
ProcessRTMChanges(VOID);

VOID
StartChangesBcast(PWORK_ITEM	wip);

VOID
ChangeBcast(PWORK_ITEM	wip);

VOID
ShutdownInterfaces(PWORK_ITEM	wip);

VOID
CheckUpdateStatus(PWORK_ITEM	    wip);

DWORD
OpenRTM(VOID);

VOID
CloseRTM(VOID);

VOID
DeleteAllRipRoutes(ULONG	InterfaceIndex);

VOID
SendGeneralRequest(PWORK_ITEM	    wip);

DWORD
ValidStateAndIfIndex(ULONG	InterfaceIndex,
		     PICB	*icbpp);

DWORD
CreateWorkItemsManager(VOID);

PWORK_ITEM
AllocateWorkItem(ULONG	      Type);

VOID
FreeWorkItem(PWORK_ITEM     wip);

//VOID
//EnqueueWorkItemToWorker(PWORK_ITEM	wip);
			    // Queue the work item for processing by the
			    // worker threads
VOID
ProcessWorkItem(PWORK_ITEM    wip);

VOID
DestroyWorkItemsManager(VOID);

PWORK_ITEM
DequeueWorkItemForWorker(VOID);

ULONG
GetRipRoutesCount(ULONG 	InterfaceIndex);

VOID
IfPeriodicBcast(PWORK_ITEM	wip);

VOID
IfCompleteGenResponse(PWORK_ITEM	    wip);

VOID
IfChangeBcast(PWORK_ITEM	wip);

VOID
IfCheckUpdateStatus(PWORK_ITEM	    wip);

USHORT
MakeRipGenResponsePacket(PWORK_ITEM	wip,
			 PUCHAR 	dstnodep,
			 PUCHAR 	dstsocket);

HANDLE
CreateBestRoutesEnumHandle(VOID);

DWORD
EnumGetNextRoute(HANDLE		EnumHandle,
		 PIPX_ROUTE	IpxRoutep);

VOID
CloseEnumHandle(HANDLE EnumHandle);

HANDLE
CreateRipRoutesEnumHandle(ULONG     InterfaceIndex);

DWORD
DequeueRouteChangeFromRtm(PIPX_ROUTE	    IpxRoutep,
			  PBOOL 	    skipitp,
			  PBOOL 	    lastmessagep);

DWORD
DequeueRouteChangeFromRip(PIPX_ROUTE	    IpxRoutep);


VOID
SetRipIpxHeader(PUCHAR		    hdrp,      // pointer to the packet header
		PICB		    icbp,
		PUCHAR		    dstnode,
		PUCHAR		    dstsocket,
		USHORT		    RipOpcode);

VOID
SetNetworkEntry(PUCHAR		pktp,	    // ptr where to set the net entry
		PIPX_ROUTE	IpxRoutep,
		USHORT		LinkTickCount);

DWORD
SendRipGenRequest(PICB		icbp);

DWORD
AddRipRoute(PIPX_ROUTE		IpxRoutep,
	    ULONG		TimeToLive);

DWORD
DeleteRipRoute(PIPX_ROUTE	IpxRoutep);

BOOL
IsRoute(PUCHAR		Network,
	PIPX_ROUTE	IpxRoutep);

DWORD
IfRefSendSubmit(PWORK_ITEM	    wip);

VOID
ReceiveComplete(PWORK_ITEM	wip);

VOID
SendComplete(PWORK_ITEM     wip);

VOID
ProcessRIPChanges(VOID);

BOOL
PassFilter(PICB 	icbp,
	   PUCHAR	Network);

VOID
CreateFiltersDatabase(VOID);

VOID
DestroyFiltersDatabase(VOID);

BOOL
IsRouteAdvertisable(PICB	    icbp,
		    PIPX_ROUTE	    IpxRoutep);

VOID
IfPeriodicGenRequest(PWORK_ITEM	wip);

VOID
GetIpxRipRegistryParameters(VOID);

BOOL
IsDuplicateBestRoute(PICB	    icbp,
		     PIPX_ROUTE     IpxRoutep);

BOOL
PassRipSupplyFilter(PICB	icbp,
		    PUCHAR	Network);

BOOL
PassRipListenFilter(PICB	icbp,
		    PUCHAR	Network);

VOID
DestroyInterfaceCB(PICB     icbp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\mib.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mib.c

Abstract:

    Contains the MIB APIs

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/


#include  "precomp.h"
#pragma hdrstop


DWORD
WINAPI
MibCreate(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData
	)
{
    return ERROR_CAN_NOT_COMPLETE;
}

DWORD
WINAPI
MibDelete(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData
	)
{
    return ERROR_CAN_NOT_COMPLETE;
}

DWORD
WINAPI
MibGet(
	IN ULONG		InputDataSize,
	IN PVOID		InputData,
	OUT PULONG		OutputDataSize,
	OUT PVOID		OutputData
	)
{
    PRIP_MIB_GET_INPUT_DATA	midp;
    PRIPMIB_BASE		mbp;
    PRIP_INTERFACE		mip;
    DWORD			rc = NO_ERROR;
    PICB			icbp;
    ULONG			GlobalInfoSize;

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    midp = (PRIP_MIB_GET_INPUT_DATA)InputData;

    switch(midp->TableId) {

	case RIP_BASE_ENTRY:

	    if(*OutputDataSize < sizeof(RIPMIB_BASE)) {

		*OutputDataSize = sizeof(RIPMIB_BASE);
		rc = ERROR_INSUFFICIENT_BUFFER;
		break;
	    }

	    mbp = (PRIPMIB_BASE)OutputData;
	    mbp->RIPOperState = RipOperState;
	    *OutputDataSize = sizeof(RIPMIB_BASE);
	    break;

	case RIP_INTERFACE_TABLE:

	    if(*OutputDataSize < sizeof(RIPMIB_BASE)) {

		*OutputDataSize = sizeof(RIP_INTERFACE);
		rc = ERROR_INSUFFICIENT_BUFFER;
		break;
	    }

	    if((icbp = GetInterfaceByIndex(midp->InterfaceIndex)) == NULL) {

		*OutputDataSize = 0;
		rc = ERROR_NO_MORE_ITEMS;
	    }
	    else
	    {
		ACQUIRE_IF_LOCK(icbp);

		mip = (PRIP_INTERFACE)OutputData;
		mip->InterfaceIndex = icbp->InterfaceIndex;
		mip->RipIfInfo = icbp->IfConfigInfo;
		mip->RipIfStats = icbp->IfStats;

		RELEASE_IF_LOCK(icbp);

		*OutputDataSize = sizeof(RIP_INTERFACE);
		rc = NO_ERROR;
	    }

	    break;

	default:

	    rc = ERROR_CAN_NOT_COMPLETE;

	    break;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
WINAPI
MibSet(
	IN ULONG 		InputDataSize,
	IN PVOID		InputData
	)

{
    PRIP_MIB_SET_INPUT_DATA	    midp;
    PICB			    icbp;
    DWORD			    rc;

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(InputDataSize < sizeof(RIP_MIB_SET_INPUT_DATA)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    midp = (PRIP_MIB_SET_INPUT_DATA)InputData;

    switch(midp->TableId) {

	case RIP_INTERFACE_TABLE:

	    if((icbp = GetInterfaceByIndex(midp->RipInterface.InterfaceIndex)) == NULL) {

		rc = ERROR_NO_MORE_ITEMS;
	    }
	    else
	    {
		rc = SetRipInterface(midp->RipInterface.InterfaceIndex,
				     &midp->RipInterface.RipIfInfo,
				     icbp->RipIfFiltersIp,
				     0); // no ipx admin state change
	    }

	    break;

	default:

	    rc = ERROR_INVALID_PARAMETER;

	    break;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
WINAPI
MibGetFirst(
	IN ULONG		InputDataSize,
	IN PVOID		InputData,
	OUT PULONG		OutputDataSize,
	OUT PVOID		OutputData
	)
{
    PRIP_MIB_GET_INPUT_DATA	midp;
    PRIP_INTERFACE		mip;
    DWORD			rc = NO_ERROR;
    PICB			icbp;

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(InputDataSize < sizeof(RIP_MIB_GET_INPUT_DATA)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    midp = (PRIP_MIB_GET_INPUT_DATA)InputData;

    switch(midp->TableId) {

	case RIP_INTERFACE_TABLE:

	    if(IsListEmpty(&IndexIfList)) {

		*OutputDataSize = 0;
		rc = ERROR_NO_MORE_ITEMS;
	    }
	    else
	    {
		if(*OutputDataSize < sizeof(RIP_INTERFACE)) {

		    *OutputDataSize = sizeof(RIP_INTERFACE);
		    rc = ERROR_INSUFFICIENT_BUFFER;
		    break;
		}

		icbp = CONTAINING_RECORD(IndexIfList.Flink, ICB, IfListLinkage);

		ACQUIRE_IF_LOCK(icbp);

		mip = (PRIP_INTERFACE)OutputData;
		mip->InterfaceIndex = icbp->InterfaceIndex;
		mip->RipIfInfo = icbp->IfConfigInfo;
		mip->RipIfStats = icbp->IfStats;

		RELEASE_IF_LOCK(icbp);

		*OutputDataSize = sizeof(RIP_INTERFACE);
		rc = NO_ERROR;
	    }

	    break;

	default:

	    rc = ERROR_INVALID_PARAMETER;

	    break;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
WINAPI
MibGetNext(
	IN ULONG		InputDataSize,
	IN PVOID		InputData,
	OUT PULONG		OutputDataSize,
	OUT PVOID		OutputData
	)
{
    PRIP_MIB_GET_INPUT_DATA	midp;
    PRIP_INTERFACE		mip;
    DWORD			rc = NO_ERROR;
    PICB			icbp;
    PLIST_ENTRY 		lep;

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(InputDataSize < sizeof(RIP_MIB_GET_INPUT_DATA)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    midp = (PRIP_MIB_GET_INPUT_DATA)InputData;

    switch(midp->TableId) {

	case RIP_INTERFACE_TABLE:

	    lep = IndexIfList.Flink;
	    rc = ERROR_NO_MORE_ITEMS;

	    while(lep != &IndexIfList)
	    {
		icbp = CONTAINING_RECORD(lep, ICB, IfListLinkage);
		if (icbp->InterfaceIndex > midp->InterfaceIndex) {

		    // found the next
		    if(*OutputDataSize < sizeof(RIP_INTERFACE)) {

			*OutputDataSize = sizeof(RIP_INTERFACE);
			rc = ERROR_INSUFFICIENT_BUFFER;
			break;
		    }

		    ACQUIRE_IF_LOCK(icbp);

		    mip = (PRIP_INTERFACE)OutputData;
		    mip->InterfaceIndex = icbp->InterfaceIndex;
		    mip->RipIfInfo = icbp->IfConfigInfo;
		    mip->RipIfStats = icbp->IfStats;

		    RELEASE_IF_LOCK(icbp);

		    *OutputDataSize = sizeof(RIP_INTERFACE);
		    rc = NO_ERROR;

		    break;
		}

		lep = lep->Flink;
	    }

	    break;

	default:

	    rc = ERROR_INVALID_PARAMETER;

	    break;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ripdbg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripdbg.c

Abstract:

    The debug functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//*** TRACE ID FOR RIP ***

DWORD	    RipTraceID=INVALID_TRACEID;
HANDLE      RipEventLogHdl=NULL;
DWORD       RipEventLogMask=0;
//*** Functions for Debug Printing ***

#if DBG

HANDLE	DbgLogFileHandle;
DWORD	DebugLog = 1;

DWORD	DbgLevel = DEFAULT_DEBUG_LEVEL;

VOID
SsDbgInitialize(VOID)
{
    if (DebugLog == 1) {

	CONSOLE_SCREEN_BUFFER_INFO csbi;
	COORD coord;
	(VOID)AllocConsole( );
	(VOID)GetConsoleScreenBufferInfo(
				     GetStdHandle(STD_OUTPUT_HANDLE),
				     &csbi
				     );
	coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
	coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
	(VOID)SetConsoleScreenBufferSize(
				     GetStdHandle(STD_OUTPUT_HANDLE),
				     coord
				     );
    }

    if(DebugLog > 1) {

	DbgLogFileHandle = CreateFile("\\ipxrtdbg.log",
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_READ,
					 NULL,
					 CREATE_ALWAYS,
					 0,
					 NULL);
    }
}

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    Trace(RIP_ALERT, "\nAssertion failed: %s\n  at line %ld of %s\n",
		FailedAssertion, LineNumber, FileName);

    DbgUserBreakPoint( );

} // SsAssert

#endif

#if DBG
VOID
SsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

    if(DbgLogFileHandle != INVALID_HANDLE_VALUE) {

	WriteFile(DbgLogFileHandle, (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // SsPrintf
#endif

#if DBG

VOID
SsPrintPacket(PUCHAR	packetp)
{
    USHORT	pktlen, printlen, dstsock, srcsock, ripop, ticks, hops;

    GETSHORT2USHORT(&pktlen, packetp + IPXH_LENGTH);
    GETSHORT2USHORT(&dstsock, packetp + IPXH_DESTSOCK);
    GETSHORT2USHORT(&srcsock, packetp + IPXH_SRCSOCK);
    GETSHORT2USHORT(&ripop, packetp + RIP_OPCODE);

    SsPrintf("---- RIP packet ----\n");
    SsPrintf("dest net %.2x%.2x%.2x%.2x\n",
	*(packetp + IPXH_DESTNET),
	*(packetp + IPXH_DESTNET + 1),
	*(packetp + IPXH_DESTNET + 2),
	*(packetp + IPXH_DESTNET + 3));
    SsPrintf("dest node %.2x%.2x%.2x%.2x%.2x%.2x\n",
	*(packetp + IPXH_DESTNODE),
	*(packetp + IPXH_DESTNODE + 1),
	*(packetp + IPXH_DESTNODE + 2),
	*(packetp + IPXH_DESTNODE + 3),
	*(packetp + IPXH_DESTNODE + 4),
	*(packetp + IPXH_DESTNODE + 5));
    SsPrintf("dest socket %x\n", dstsock);
    SsPrintf("src net %.2x%.2x%.2x%.2x\n",
	*(packetp + IPXH_SRCNET),
	*(packetp + IPXH_SRCNET + 1),
	*(packetp + IPXH_SRCNET + 2),
	*(packetp + IPXH_SRCNET + 3));
    SsPrintf("src node %.2x%.2x%.2x%.2x%.2x%.2x\n",
	*(packetp + IPXH_SRCNODE),
	*(packetp + IPXH_SRCNODE + 1),
	*(packetp + IPXH_SRCNODE + 2),
	*(packetp + IPXH_SRCNODE + 3),
	*(packetp + IPXH_SRCNODE + 4),
	*(packetp + IPXH_SRCNODE + 5));
    SsPrintf("src socket %x\n", srcsock);
    SsPrintf("RIP operation: %d\n", ripop);

    printlen = RIP_INFO;

    while(printlen < pktlen) {

	SsPrintf("net entry network %.2x%.2x%.2x%.2x\n",
	*(packetp + printlen + NE_NETNUMBER),
	*(packetp + printlen + NE_NETNUMBER + 1),
	*(packetp + printlen + NE_NETNUMBER + 2),
	*(packetp + printlen + NE_NETNUMBER + 3));

	GETSHORT2USHORT(&ticks, packetp + printlen + NE_NROFTICKS);
	GETSHORT2USHORT(&hops, packetp + printlen + NE_NROFHOPS);

	SsPrintf("net entry ticks %d\n", ticks);
	SsPrintf("net entry hops %d\n", hops);

	printlen += NE_ENTRYSIZE;
    }
}

#endif

VOID
StartTracing(VOID)
{
    RipTraceID = TraceRegisterA ("IPXRIP");
    RipEventLogHdl = RouterLogRegisterA ("IPXRIP");
}

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...)
{
    if (RipTraceID!=INVALID_TRACEID) {
        va_list	arglist;

        va_start(arglist, Format);

        TraceVprintfExA(RipTraceID,
		       ComponentID | TRACE_USE_MASK,
		       Format,
		       arglist);

        va_end(arglist);
    }
}

VOID
StopTracing(VOID)
{
    if (RipTraceID!=INVALID_TRACEID)
        TraceDeregisterA(RipTraceID);
    if (RipEventLogHdl!=NULL)
        RouterLogDeregisterA (RipEventLogHdl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\periodbc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    periodbc.c

Abstract:

    Contains the work item handler periodic bcast

Author:

    Stefan Solomon  07/20/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop


/*++

Function:	IfPeriodicBcast

Descr:		called to initiate or continue (complete) a bcast
		if EnumHandle is NULL it is a start, else a continuation

Remark: 	called with the interface lock held

--*/

VOID
IfPeriodicBcast(PWORK_ITEM	wip)
{
    UCHAR	ripsocket[2];
    USHORT	pktlen;
    ULONG	delay;
    PICB	icbp;

    icbp = wip->icbp;

#define EnumHandle  wip->WorkItemSpecific.WIS_EnumRoutes.RtmEnumerationHandle

    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

	if(EnumHandle) {

	    CloseEnumHandle(EnumHandle);
	}

	FreeWorkItem(wip);

	return;
    }

    PUTUSHORT2SHORT(ripsocket, IPX_RIP_SOCKET);

    // check if this is the start or the continuation of a periodic bcast
    if(EnumHandle == NULL) {

	// *** This is the start of a new broadcast ***

	// create an RTM enumeration handle
	if((EnumHandle = CreateBestRoutesEnumHandle()) == NULL) {

	     SS_ASSERT(FALSE);
	     FreeWorkItem(wip);
	     return;
	}
    }
    else
    {
	// *** This is the continuation of a started broadcast ***

	// check if this was the last packet in the response
	GETSHORT2USHORT(&pktlen, wip->Packet + IPXH_LENGTH);

	if(pktlen < FULL_PACKET)  {

	    // we are done
	    goto ResetPeriodicBcast;
	}

	// check the time stamp to determine if an interpacket gap is needed
	delay = (wip->TimeStamp + 55) - GetTickCount();
	if(delay < MAXULONG/2) {

	    // have to wait this delay
	    IfRefStartWiTimer(wip, delay);

	    return;
	}
    }

    // make the gen response packet
    pktlen = MakeRipGenResponsePacket(wip,
				      bcastnode,
				      ripsocket);
    if(pktlen == EMPTY_PACKET) {

	// we are done
	goto ResetPeriodicBcast;
    }

    // send the bcast and increment the ref counter
    if(IfRefSendSubmit(wip) != NO_ERROR) {

	// can't send on this interface now -> requeue in timer and retry
	goto ResetPeriodicBcast;
    }

    return;

ResetPeriodicBcast:

    // no more routes to advertise for this general response
    CloseEnumHandle(EnumHandle);
    EnumHandle = NULL;

    // enqueue for the bcast time in the timer queue
    IfRefStartWiTimer(wip, PERIODIC_UPDATE_INTERVAL_MILISECS(icbp));
}

/*++

Function:	IfPeriodicSendGenRequest

Descr:		called to send periodically a gen request on a wan line for
		a remote or local workstation dial. This is mainly to remain
		compatible with NT 3.51 rip router which requires a gen request
		in order to send its internal node (if client) or routing table
		if server.

Remark: 	called with the interface lock held

--*/

VOID
IfPeriodicGenRequest(PWORK_ITEM	wip)
{
    PICB	icbp;

    icbp = wip->icbp;

    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

	FreeWorkItem(wip);

	return;
    }

    SendRipGenRequest(icbp);

    // enqueue the periodic send bcast in the timer queue
    IfRefStartWiTimer(wip, 60000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: routines for reading the registry configuration
//
// Author:	Stefan Solomon (stefans)    October 30, 1995.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma  hdrstop

//***
//
// Function:	GetIpxRipRegistryParameters
//
// Descr:	Reads the parameters from the registry and sets them
//
//***

VOID
GetIpxRipRegistryParameters(VOID)
{

    NTSTATUS Status;
    PWSTR IpxRouterParametersPath = L"RemoteAccess\\RouterManagers\\IPX\\RoutingProtocols\\IPXRIP\\Parameters";
    RTL_QUERY_REGISTRY_TABLE	paramTable[3]; // table size = nr of params + 1

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));
    
    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"SendGenReqOnWkstaDialLinks";
    paramTable[0].EntryContext = &SendGenReqOnWkstaDialLinks;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &SendGenReqOnWkstaDialLinks;
    paramTable[0].DefaultLength = sizeof(ULONG);
        
    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"TriggeredUpdateCheckInterval";
    paramTable[1].EntryContext = &CheckUpdateTime;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &CheckUpdateTime;
    paramTable[1].DefaultLength = sizeof(ULONG);
        
    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_SERVICES,
		 IpxRouterParametersPath,
		 paramTable,
		 NULL,
		 NULL);

    Trace(INIT_TRACE, "GetIpxCpRegistryParameters:\n"
						"        SendGenReqOnWkstaDialLinks = %d\n"
						"        TriggeredUpdateCheckInterval = %d\n",
						SendGenReqOnWkstaDialLinks,
						CheckUpdateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ripdbg.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripdbg.h

Abstract:

    This module contains the debug utilities definitions

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _RIPDBG_
#define _RIPDBG_

//*** Tracing Components IDs ***

#define     RIP_REQUEST_TRACE		    0x00010000
#define     RIP_RESPONSE_TRACE		    0x00020000
#define     SEND_TRACE			    0x00040000
#define     RECEIVE_TRACE		    0x00080000
#define     INIT_TRACE			    0x00100000
#define     IFMGR_TRACE 		    0x00200000
#define     CHANGEBC_TRACE		    0x00400000
#define     RTM_TRACE			    0x00800000
#define     RIP_ALERT			    0x80000000

#if DBG

//*** Definitions to enable debug printing

extern DWORD	DbgLevel;

#define DEFAULT_DEBUG_LEVEL	    0


#define DEBUG if ( TRUE )
#define IF_DEBUG(flag) if (DbgLevel & (DEBUG_ ## flag))

VOID
SsDbgInitialize(VOID);

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID
SsPrintf (
    char *Format,
    ...
    );

VOID
SsPrintPacket(PUCHAR   packetp);

#define SS_DBGINITIALIZE  SsDbgInitialize()

#define SS_PRINT(args) SsPrintf args

#define SS_PRINT_PACKET(args) SsPrintPacket args

#define SS_ASSERT(exp) if (!(exp)) SsAssert( #exp, __FILE__, __LINE__ )

#else

#define DEBUG if ( FALSE )
#define IF_DEBUG(flag) if (FALSE)

#define SS_DBGINITIALIZE

#define SS_PRINT(args)

#define SS_PRINT_PACKET(args)

#define SS_ASSERT(exp)

#endif // DBG

VOID
StartTracing(VOID);

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...);

VOID
StopTracing(VOID);

extern HANDLE      RipEventLogHdl;
extern DWORD       RipEventLogMask;
#define IF_LOG(Event)                       \
    if ((RipEventLogHdl!=NULL) && ((Event&RipEventLogMask)==Event))

#endif // ndef _RIPDBG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ripmain.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripmain.c

Abstract:

    Contains the rcv and worker threads

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/


#include  "precomp.h"
#pragma hdrstop

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

DWORD
APIENTRY
StartProtocol(
    IN HANDLE hMgrNotifyEvent,
    IN PSUPPORT_FUNCTIONS pSupportFunctions,
    IN PVOID pConfig
    );

DWORD
APIENTRY
StopProtocol(
    VOID
    );

DWORD
APIENTRY
GetGlobalInfo(
    IN OUT PVOID pConfig,
    IN OUT PDWORD pdwSize
    );


DWORD
APIENTRY
SetGlobalInfo(
    IN PVOID pConfig
    );

DWORD
APIENTRY
AddInterface(
    IN PWCHAR pwszInterfaceName,
    IN DWORD dwIndex,
    IN NET_INTERFACE_TYPE dwIfType,
    IN PVOID pConfig
    );

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    );

DWORD
APIENTRY
GetInterfaceConfigInfo(
    IN DWORD dwIndex,
    IN OUT PVOID pConfig,
    IN OUT PDWORD pdwSize
    );

DWORD
APIENTRY
SetInterfaceConfigInfo(
    IN DWORD dwIndex,
    IN PVOID pConfig
    );

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    );

DWORD
APIENTRY
UnbindInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

// Router Manager Notification Event
HANDLE	      RM_Event;

TCHAR         ModuleName[MAX_PATH+1];

VOID
WorkerThread(VOID);


DWORD
CreateWorkerThreadObjects(VOID);

VOID
DestroyWorkerThreadObjects(VOID);

VOID
ProcessDequeuedIoPacket(DWORD		      ErrorCode,
			DWORD		      BytesTransferred,
			LPOVERLAPPED	      Overlappedp);

BOOL WINAPI
IpxRipDllEntry(HINSTANCE hInstDll,
		  DWORD fdwReason,
		  LPVOID pReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

        GetModuleFileName (hInstDll, ModuleName,
                    sizeof (ModuleName)/sizeof (ModuleName[0]));
	    SS_DBGINITIALIZE;

	    RipOperState = OPER_STATE_DOWN;

	    // Create the database lock
	    InitializeCriticalSection(&DbaseCritSec);

	    // Create the queues lock
	    InitializeCriticalSection(&QueuesCritSec);

	    // Create the RIP changed list lock
        InitializeCriticalSection(&RipChangedListCritSec);

            break;

	case DLL_PROCESS_DETACH:

	    // delete the RIP changed list lock
	    DeleteCriticalSection(&RipChangedListCritSec);

	    // delete the database lock
	    DeleteCriticalSection(&DbaseCritSec);

	    // delete the queues lock
	    DeleteCriticalSection(&QueuesCritSec);

            break;

        default:

            break;
    }

    return TRUE;
}

DWORD WINAPI
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    if(pRoutingChar->dwProtocolId != IPX_PROTOCOL_RIP)
    {
        return ERROR_NOT_SUPPORTED;
    }

    pServiceChar->fSupportedFunctionality = 0;

    pRoutingChar->fSupportedFunctionality = (ROUTING | DEMAND_UPDATE_ROUTES);

    pRoutingChar->pfnStartProtocol    = StartProtocol;
    pRoutingChar->pfnStopProtocol     = StopProtocol;
    pRoutingChar->pfnAddInterface     = AddInterface;
    pRoutingChar->pfnDeleteInterface  = DeleteInterface;
    pRoutingChar->pfnGetEventMessage  = GetEventMessage;
    pRoutingChar->pfnGetInterfaceInfo = GetInterfaceConfigInfo;
    pRoutingChar->pfnSetInterfaceInfo = SetInterfaceConfigInfo;
    pRoutingChar->pfnBindInterface    = BindInterface;
    pRoutingChar->pfnUnbindInterface  = UnbindInterface;
    pRoutingChar->pfnEnableInterface  = EnableInterface;
    pRoutingChar->pfnDisableInterface = DisableInterface;
    pRoutingChar->pfnGetGlobalInfo    = GetGlobalInfo;
    pRoutingChar->pfnSetGlobalInfo    = SetGlobalInfo;
    pRoutingChar->pfnMibCreateEntry   = MibCreate;
    pRoutingChar->pfnMibDeleteEntry   = MibDelete;
    pRoutingChar->pfnMibGetEntry      = MibGet;
    pRoutingChar->pfnMibSetEntry      = MibSet;
    pRoutingChar->pfnMibGetFirstEntry = MibGetFirst;
    pRoutingChar->pfnMibGetNextEntry  = MibGetNext;
    pRoutingChar->pfnUpdateRoutes     = DoUpdateRoutes;

    return NO_ERROR;
}

DWORD WINAPI
StartProtocol(IN HANDLE		    NotificationEvent,
			   IN PSUPPORT_FUNCTIONS    SupportFunctions,
			   IN PVOID		    GlobalInfo)
{
#define ripGlobalInfo ((PRIP_GLOBAL_INFO)GlobalInfo)
    DWORD	    threadid, i;
    HANDLE	    ThreadHandle;

    RipEventLogMask = ripGlobalInfo->EventLogMask;
    StartTracing();

    Trace(INIT_TRACE, "StartProtocol: Entered\n");

    ACQUIRE_DATABASE_LOCK;
    ACQUIRE_QUEUES_LOCK;

    RipOperState = OPER_STATE_STARTING;

    GetIpxRipRegistryParameters();

    RM_Event = NotificationEvent;

    //init the interfaces database
    InitIfDbase();

    //
    // init all the queues
    //
//    InitializeListHead(&WorkersQueue);
    InitializeListHead(&TimerQueue);
    InitializeListHead(&RepostRcvPacketsQueue);
    InitializeListHead(&RipMessageQueue);


    // create the workers work items heap
    if(CreateWorkItemsManager() != NO_ERROR) {

	goto ErrorExit;
    }

    // open the RIP socket for I/O
    if(OpenRipSocket() != NO_ERROR) {

	Trace(INIT_TRACE, "Cannot open RIP socket\n");

	goto ErrorExit;
    }

    if(! BindIoCompletionCallback(RipSocketHandle,
			   ProcessDequeuedIoPacket, 0)) {

	Trace(INIT_TRACE, "Cannot associate IO Completion Port\n");

	goto ErrorExit;
    }


    // create synchronization objects for the rip threads
    if(CreateWorkerThreadObjects() != NO_ERROR) {

	Trace(INIT_TRACE, "Cannot create synchronization objects\n");

	goto ErrorExit;
    }

    // Open RTM for RIP
    if(OpenRTM()) {

	Trace(INIT_TRACE, "Cannot open RTM\n");

	goto ErrorExit;
    }

    // create the Worker thread

    if ((ThreadHandle = CreateThread(
			    (LPSECURITY_ATTRIBUTES) NULL,
			    0,
			    (LPTHREAD_START_ROUTINE) WorkerThread,
			    NULL,
			    0,
			    &threadid)) == NULL) {

	// !!! log error cannot create the worker thread !!!
	goto ErrorExit;
    }
    else
        CloseHandle (ThreadHandle);

    RipOperState = OPER_STATE_UP;

    RELEASE_QUEUES_LOCK;
    RELEASE_DATABASE_LOCK;

    CreateStartChangesBcastWi();

    Trace(INIT_TRACE, "Started successfully\n");

    return NO_ERROR;

ErrorExit:

    RELEASE_QUEUES_LOCK;
    RELEASE_DATABASE_LOCK;

    return ERROR_CAN_NOT_COMPLETE;
#undef ripGlobalInfo
}

DWORD
WINAPI
StopProtocol(VOID)
{
    PWORK_ITEM	    wip;

    Trace(INIT_TRACE, "StopProtocol: Entered\n");

    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	SS_ASSERT(FALSE);
	goto ErrorExit;
    }

    RipOperState = OPER_STATE_STOPPING;

    // send interfaces shutdown work item to the workers
    if((wip = AllocateWorkItem(SHUTDOWN_INTERFACES_TYPE)) == NULL) {

	goto ErrorExit;
    }

    wip->WorkItemSpecific.WIS_ShutdownInterfaces.ShutdownState = SHUTDOWN_START;

    RtlQueueWorkItem(ProcessWorkItem, wip, 0);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;

ErrorExit:

    RELEASE_DATABASE_LOCK;

    return ERROR_CAN_NOT_COMPLETE;
}

VOID
WorkerThread(VOID)
{
    DWORD	 rc;
    DWORD	 signaled_event, delay;
    ULONG	 dueTime = GetTickCount() + MAXULONG/2;
    PWORK_ITEM	 wip;
    PLIST_ENTRY  lep;
    HANDLE  hModuleReference;

    hModuleReference = LoadLibrary (ModuleName);
    StartReceiver();

    while(TRUE)
    {
	delay = dueTime - GetTickCount();
	if(delay < MAXULONG/2) {

	    // dueTime is later then present time

	    while((rc = WaitForMultipleObjects(
			  MAX_WORKER_THREAD_OBJECTS,
			  WorkerThreadObjects,
			  FALSE,		 // wait any
			  delay			 // timeout
			  )) == WAIT_IO_COMPLETION);
	}
	else
	{
	    // dueTime already happened
	    rc = WAIT_TIMEOUT;
	}

	if(rc == WAIT_TIMEOUT) {

	    dueTime = ProcessTimerQueue();
	}
	else
	{
	    signaled_event = rc - WAIT_OBJECT_0;

	    if(signaled_event < MAX_WORKER_THREAD_OBJECTS) {

		switch(signaled_event) {

		    case TIMER_EVENT:

			dueTime = ProcessTimerQueue();
			break;

		    case REPOST_RCV_PACKETS_EVENT:

			RepostRcvPackets();
			break;

//		    case WORKERS_QUEUE_EVENT:

			// dequeue only one item from the work items queue
//			ACQUIRE_QUEUES_LOCK;

//			while(!IsListEmpty(&WorkersQueue)) {

//			    lep = RemoveHeadList(&WorkersQueue);
//			    wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);

//			    RELEASE_QUEUES_LOCK;

			    // Queue the work item for processing by the
			    // worker threads
//			    RtlQueueWorkItem(ProcessWorkItem,
//					  wip,
//					  WT_EXECUTEINIOTHREAD); // never dieing workers so we can do send submits
						                 // and the thread won't die before send completes

//			    ACQUIRE_QUEUES_LOCK;
//			}

//			RELEASE_QUEUES_LOCK;

//			break;

		    case RTM_EVENT:

			ProcessRTMChanges();
			break;

		    case RIP_CHANGES_EVENT:

			ProcessRIPChanges();
			break;

		    case TERMINATE_WORKER_EVENT:

            // stop the StartChangesBcast work item
            DestroyStartChangesBcastWi = TRUE;

            // close the rip socket
            CloseRipSocket();

            FlushTimerQueue();
            CloseRTM();

            // wait until no more work items
            while(WorkItemsCount != 0) {

	        Trace(INIT_TRACE, "Terminating: Waiting for work items to be freed: %d outstanding ...\n",
		               WorkItemsCount);

	        Sleep(1000);
            }


            // destroy worker thread objects
            DestroyWorkerThreadObjects();

            // destroy workers heap
            DestroyWorkItemsManager();

            // post stop complete message
            PostEventMessage(ROUTER_STOPPED, NULL);

            Trace(INIT_TRACE, "Terminating: Stop completed and STOP Event Message posted\n");
    	    FreeLibraryAndExitThread(hModuleReference, 0);
			break;

		    default:

			break;
		}
	    }
	}
    }
}


// table of handlers for work items which keep a reference to the if CB

typedef VOID   (* IF_WORK_ITEM_HANDLER)(PWORK_ITEM	wip);

IF_WORK_ITEM_HANDLER	IfWorkItemHandler[] = {

    IfPeriodicBcast,
    IfCompleteGenResponse,
    IfChangeBcast,
    IfCheckUpdateStatus,
    IfPeriodicGenRequest

    };

#define MAX_IF_WORK_ITEM_HANDLERS	 sizeof(IfWorkItemHandler)/sizeof(IF_WORK_ITEM_HANDLER)

VOID
ProcessWorkItem(PWORK_ITEM	    wip)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;

    switch(wip->Type) {

	case RECEIVE_PACKET_TYPE:

	    // this work item references the interface via the adapter index

	    ACQUIRE_DATABASE_LOCK;

	    if(RipOperState != OPER_STATE_UP) {

		RELEASE_DATABASE_LOCK;
	    }
	    else
	    {
		if((icbp = GetInterfaceByAdapterIndex(wip->AdapterIndex)) != NULL) {

		    wip->icbp = icbp;

		    ACQUIRE_IF_LOCK(icbp);

		    RELEASE_DATABASE_LOCK;

		    ProcessReceivedPacket(wip);

		    RELEASE_IF_LOCK(icbp);
		}
		else
		{
		    RELEASE_DATABASE_LOCK;
		}
	    }

	    // queue the receive packet back to recv thread for reposting
	    EnqueueRcvPacketToRepostQueue(wip);

	    break;

	case START_CHANGES_BCAST_TYPE:

	    ACQUIRE_DATABASE_LOCK;

	    StartChangesBcast(wip);

	    RELEASE_DATABASE_LOCK;

	    break;

	case SHUTDOWN_INTERFACES_TYPE:

	    ACQUIRE_DATABASE_LOCK;

	    ShutdownInterfaces(wip);

	    RELEASE_DATABASE_LOCK;

	    break;

	case DEBUG_TYPE:

	    FreeWorkItem(wip);
	    break;

	default:

	    // all these work items reference the interface via an if CB pointer
	    icbp = wip->icbp;

	    ACQUIRE_IF_LOCK(icbp);

	    (*IfWorkItemHandler[wip->Type])(wip);

	    if(icbp->Discarded) {

		RELEASE_IF_LOCK(icbp);

		ACQUIRE_DATABASE_LOCK;

		ACQUIRE_IF_LOCK(icbp);

		if(--icbp->RefCount == 0) {

		    // remove the if CB from the discarded queue and free it
		    RemoveEntryList(&icbp->IfListLinkage);

		    // free the interface CB
		    Trace(INIT_TRACE, "ProcessWorkItem: Free DISCARDED if CB for if # %d\n", icbp->InterfaceIndex);

		    DestroyInterfaceCB(icbp);
		}
		else
		{
		    RELEASE_IF_LOCK(icbp);
		}

		RELEASE_DATABASE_LOCK;
	    }
	    else
	    {
		icbp->RefCount--;
		RELEASE_IF_LOCK(icbp);
	    }
    }
}


DWORD
WINAPI
GetEventMessage(ROUTING_PROTOCOL_EVENTS	    *Event,
			      PMESSAGE			    Result)
{
    PRIP_MESSAGE		emp;
    PLIST_ENTRY 		lep;

    Trace(INIT_TRACE, "GetEventMessage: Entered\n");

    ACQUIRE_DATABASE_LOCK;

    if((RipOperState == OPER_STATE_DOWN) ||
       (RipOperState == OPER_STATE_STARTING)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    ACQUIRE_QUEUES_LOCK;

    if(IsListEmpty(&RipMessageQueue)) {

	RELEASE_QUEUES_LOCK;

	RELEASE_DATABASE_LOCK;
	return ERROR_NO_MORE_ITEMS;
    }

    lep = RemoveHeadList(&RipMessageQueue);
    emp = CONTAINING_RECORD(lep, RIP_MESSAGE, Linkage);

    *Event = emp->Event;
    if(Result != NULL) {

	*Result = emp->Result;
    }

    if(emp->Event == ROUTER_STOPPED) {

	    RipOperState = OPER_STATE_DOWN;
        StopTracing();
    }

    GlobalFree(emp);

    RELEASE_QUEUES_LOCK;

    RELEASE_DATABASE_LOCK;
    return NO_ERROR;
}

VOID
PostEventMessage(ROUTING_PROTOCOL_EVENTS	Event,
		 PMESSAGE			Result)
{
    PRIP_MESSAGE		emp;

    if((emp = GlobalAlloc(GPTR, sizeof(RIP_MESSAGE))) == NULL) {

	return;
    }

    emp->Event = Event;

    if(Result != NULL) {

	emp->Result = *Result;
    }

    ACQUIRE_QUEUES_LOCK;

    InsertTailList(&RipMessageQueue, &emp->Linkage);

    RELEASE_QUEUES_LOCK;

    SetEvent(RM_Event);
}


DWORD
CreateWorkerThreadObjects(VOID)
{
    int 	i;

    for(i=0; i<MAX_WORKER_THREAD_OBJECTS; i++) {

	if((WorkerThreadObjects[i] = CreateEvent(NULL,
					      FALSE,
					      FALSE,
					      NULL)) == NULL) {
	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    return NO_ERROR;
}


VOID
DestroyWorkerThreadObjects(VOID)
{
    int     i;

    for(i=0; i<MAX_WORKER_THREAD_OBJECTS; i++) {

	CloseHandle(WorkerThreadObjects[i]);
    }
}


DWORD WINAPI
SetGlobalInfo(PVOID	GlobalInfo)
{
#define ripGlobalInfo ((PRIP_GLOBAL_INFO)GlobalInfo)
    ACQUIRE_DATABASE_LOCK;

    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    RipEventLogMask = ripGlobalInfo->EventLogMask;
    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
#undef ripGlobalInfo
}


DWORD WINAPI
GetGlobalInfo(
	IN  PVOID	GlobalInfo,
	IN OUT PULONG	GlobalInfoSize
	)
{
    ACQUIRE_DATABASE_LOCK;
    if(RipOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if ((*GlobalInfoSize>=sizeof (RIP_GLOBAL_INFO))
            && (GlobalInfo!=NULL)) {
            #define ripGlobalInfo ((PRIP_GLOBAL_INFO)GlobalInfo)
            ripGlobalInfo->EventLogMask = RipEventLogMask;
            #undef ripGlobalInfo
    }
    *GlobalInfoSize = sizeof (RIP_GLOBAL_INFO);

	RELEASE_DATABASE_LOCK;
    return NO_ERROR;
}


VOID
ProcessDequeuedIoPacket(DWORD		      ErrorCode,
			DWORD		      BytesTransferred,
			LPOVERLAPPED	      Overlappedp)
{
    PWORK_ITEM		  wip;

    wip = CONTAINING_RECORD(Overlappedp, WORK_ITEM, Overlapped);
    wip->IoCompletionStatus = (DWORD)Overlappedp->Internal;

    switch(wip->Type) {

	case RECEIVE_PACKET_TYPE:

	    ReceiveComplete(wip);
	    break;

	default:

	    SendComplete(wip);
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ripint.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripint.h

Abstract:

    This module contains the definitions of the internal control structures
    used by the rip protocol module

Author:

    Stefan Solomon  06/22/1995

Revision History:


--*/

#ifndef _RIPINT_
#define _RIPINT_

//
//*** RIP Internal Structures ***
//

// internal filter control block

typedef struct _RIP_ROUTE_FILTER_INFO_I {

    ULONG   Network;
    ULONG   Mask;

    } RIP_ROUTE_FILTER_INFO_I, *PRIP_ROUTE_FILTER_INFO_I;

typedef struct _RIP_IF_FILTERS_I {

    BOOL			SupplyFilterAction; // TRUE - Pass, FALSE - Don't Pass
    ULONG			SupplyFilterCount;
    BOOL			ListenFilterAction; // TRUE - Pass, FALSE - Don't Pass
    ULONG			ListenFilterCount;
    RIP_ROUTE_FILTER_INFO_I	RouteFilterI[1];

    } RIP_IF_FILTERS_I, *PRIP_IF_FILTERS_I;


// Interface Control Block

typedef struct _ICB {

    ULONG			InterfaceIndex;
    LIST_ENTRY			IfListLinkage;	    // linkage in if list ordered by Index
    LIST_ENTRY			IfHtLinkage;	    // linkage in if hash table
    LIST_ENTRY			AdapterHtLinkage;   // linkage in adapter hash table
    RIP_IF_INFO 		IfConfigInfo;	    // config info
    RIP_IF_STATS		IfStats;	    // statistics
    ULONG			RefCount;	    // reference counter
    IPX_ADAPTER_BINDING_INFO	AdapterBindingInfo;
    CRITICAL_SECTION		InterfaceLock;
    BOOL			Discarded;	    // if the if CB is queued on discarded list
    LIST_ENTRY			ChangesBcastQueue;  // queue of bcast work items (packets) to be sent
    LIST_ENTRY			AuxLinkage;	    // auxiliary linkage in temp queues
    USHORT			LinkTickCount;	    // tick count equiv. of link speed
    ULONG			IpxIfAdminState;    // admin state of the IPX interface
    NET_INTERFACE_TYPE		InterfaceType;
    UCHAR			RemoteWkstaInternalNet[4]; // internal net of the remote client
    PRIP_IF_FILTERS_I		RipIfFiltersIp;	    // pointer to the if filters block
    WCHAR                   InterfaceName[1];

    } ICB, *PICB;


// Work Item

typedef enum _WORK_ITEM_TYPE {

    PERIODIC_BCAST_PACKET_TYPE,
    GEN_RESPONSE_PACKET_TYPE,
    CHANGE_BCAST_PACKET_TYPE,
    UPDATE_STATUS_CHECK_TYPE,
    PERIODIC_GEN_REQUEST_TYPE,

    // if you change the order/number of work items above this line you
    // must change also the WorkItemHandler table

    RECEIVE_PACKET_TYPE,
    SEND_PACKET_TYPE,
    START_CHANGES_BCAST_TYPE,
    SHUTDOWN_INTERFACES_TYPE,
    DEBUG_TYPE

    } WORK_ITEM_TYPE;


typedef struct _ENUM_ROUTES_SPECIFIC {

    HANDLE	    RtmEnumerationHandle;

    } ENUM_ROUTES_SPECIFIC, *PENUM_ROUTES_SPECIFIC;


typedef struct _UPDATE_SPECIFIC {

    ULONG	    UpdatedRoutesCount;
    ULONG	    UpdateRetriesCount;
    ULONG		OldRipListen;	    // saved Listen state when updating routes
	ULONG		OldRipInterval;		// saved update interval when updating routes

    } UPDATE_SPECIFIC, *PUPDATE_SPECIFIC;

typedef struct _SHUTDOWN_INTERFACES_SPECIFIC {

    ULONG	    ShutdownState;

    } SHUTDOWN_INTERFACES_SPECIFIC, *PSHUTDOWN_INTERFACES_SPECIFIC;

typedef struct _DEBUG_SPECIFIC {

    ULONG	    DebugData;

    } DEBUG_SPECIFIC, *PDEBUG_SPECIFIC;

// shutdown states definitions
#define SHUTDOWN_START		    0
#define SHUTDOWN_STATUS_CHECK	    1


typedef union _WORK_ITEM_SPECIFIC {

    ENUM_ROUTES_SPECIFIC	 WIS_EnumRoutes;
    UPDATE_SPECIFIC		 WIS_Update;
    SHUTDOWN_INTERFACES_SPECIFIC WIS_ShutdownInterfaces;
    DEBUG_SPECIFIC		 WIS_Debug;

    } WORK_ITEM_SPECIFIC, *PWORK_ITEM_SPECIFIC;

typedef struct _WORK_ITEM {

    LIST_ENTRY		    Linkage;	    // linkage in the worker's work queue
    WORK_ITEM_TYPE	    Type;	    // work item type
    DWORD		    TimeStamp;	    // used by the send complete to stamp for interpacket gap calc.
    DWORD		    DueTime;	    // use for timer queue
    PICB		    icbp;	    // ptr to the referenced if CB
    ULONG		    AdapterIndex;
    DWORD		    IoCompletionStatus;
    WORK_ITEM_SPECIFIC	    WorkItemSpecific;
    OVERLAPPED		    Overlapped;
    ADDRESS_RESERVED	    AddressReserved;
    UCHAR		    Packet[1];

    } WORK_ITEM, *PWORK_ITEM;

// event and message queued for the router manager

typedef struct _RIP_MESSAGE {

    LIST_ENTRY			Linkage;
    ROUTING_PROTOCOL_EVENTS	Event;
    MESSAGE			Result;

    } RIP_MESSAGE, *PRIP_MESSAGE;

//
//***	Constants   ***
//

// Worker Thread Wait Objects Indices

#define     TIMER_EVENT 		    0
#define     REPOST_RCV_PACKETS_EVENT	    1
//#define     WORKERS_QUEUE_EVENT 	    2
#define     RTM_EVENT			    2
#define     RIP_CHANGES_EVENT		    3
#define     TERMINATE_WORKER_EVENT	    4

#define     MAX_WORKER_THREAD_OBJECTS	    5

// invalid (unbound) adapter
#define INVALID_ADAPTER_INDEX	    0xFFFFFFFF

// size of interfaces and adapter hash tables

#define    IF_INDEX_HASH_TABLE_SIZE	    32
#define    ADAPTER_INDEX_HASH_TABLE_SIZE    32

// RIP packet length values

#define FULL_PACKET		    RIP_PACKET_LEN
#define EMPTY_PACKET		    RIP_INFO

// Time interval to check and broadcast changes (in milisec)

#define     CHANGES_BCAST_TIME	    1000

//
//***	Macros	   ***

#define ACQUIRE_DATABASE_LOCK	  EnterCriticalSection(&DbaseCritSec)
#define RELEASE_DATABASE_LOCK	  LeaveCriticalSection(&DbaseCritSec)

#define ACQUIRE_QUEUES_LOCK	  EnterCriticalSection(&QueuesCritSec)
#define RELEASE_QUEUES_LOCK	  LeaveCriticalSection(&QueuesCritSec)

#define ACQUIRE_RIP_CHANGED_LIST_LOCK	  EnterCriticalSection(&RipChangedListCritSec)
#define RELEASE_RIP_CHANGED_LIST_LOCK	  LeaveCriticalSection(&RipChangedListCritSec)

#define ACQUIRE_IF_LOCK(icbp)	  EnterCriticalSection(&(icbp)->InterfaceLock)
#define RELEASE_IF_LOCK(icbp)	  LeaveCriticalSection(&(icbp)->InterfaceLock)

// macro to assess if time1 is later then time2 when both are ulong with wrap around
#define IsLater(time1, time2)	  (((time1) - (time2)) < MAXULONG/2)

// enqueue a work item in timer queue and increment the interface ref count
#define IfRefStartWiTimer(wip, delay)	 (wip)->icbp->RefCount++;\
					 StartWiTimer((wip), (delay));

// Update Time and Route Time To Live definitions

#define     PERIODIC_UPDATE_INTERVAL_SECS(icbp)		(icbp)->IfConfigInfo.PeriodicUpdateInterval // in seconds
#define     PERIODIC_UPDATE_INTERVAL_MILISECS(icbp)	(PERIODIC_UPDATE_INTERVAL_SECS(icbp)) * 1000
#define     AGE_INTERVAL_MULTIPLIER(icbp)		(icbp)->IfConfigInfo.AgeIntervalMultiplier

#define     ROUTE_TIME_TO_LIVE_SECS(icbp)	 (AGE_INTERVAL_MULTIPLIER(icbp)) * (PERIODIC_UPDATE_INTERVAL_SECS(icbp))

#define      CHECK_UPDATE_TIME_MILISECS 		 (CheckUpdateTime*1000)

//
//***  Global Variables     ***
//

extern	  CRITICAL_SECTION	    DbaseCritSec;
extern	  CRITICAL_SECTION	    QueuesCritSec;
extern	  CRITICAL_SECTION	    RipChangedListCritSec;
extern	  ULONG 		    RipOperState;
extern	  LIST_ENTRY		    IndexIfList;
extern	  LIST_ENTRY		    IfIndexHt[IF_INDEX_HASH_TABLE_SIZE];
extern	  LIST_ENTRY		    AdapterIndexHt[ADAPTER_INDEX_HASH_TABLE_SIZE];
extern	  LIST_ENTRY		    DiscardedIfList;
extern	  CRITICAL_SECTION	    QueuesCritSec;
extern	  ULONG			    RcvPostedCount;
extern	  LIST_ENTRY		    RepostRcvPacketsQueue;
extern	  LIST_ENTRY		    RipMessageQueue;
extern	  HANDLE		    WorkerThreadObjects[MAX_WORKER_THREAD_OBJECTS];
//extern	  LIST_ENTRY		    WorkersQueue;
extern	  LIST_ENTRY		    TimerQueue;
extern	  BOOL			    DestroyStartChangesBcastWi;
extern	  ULONG 		    WorkItemsCount;
extern	  ULONG 		    TimerTimeout;
extern	  ULONG			    RipOperState;
extern	  UCHAR 		    bcastnet[4];
extern	  UCHAR 		    bcastnode[6];
extern	  ULONG			    RcvPostedCount;
extern	  ULONG			    SendPostedCount;
extern	  UCHAR 		    nullnet[4];
extern	  HANDLE		    RipSocketHandle;
extern	  HANDLE		    IoCompletionPortHandle;
extern	  ULONG 		    RipFiltersCount;
extern	  ULONG 		    SendGenReqOnWkstaDialLinks;
extern    ULONG				CheckUpdateTime;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\rippkt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rippkt.c

Abstract:

    Common RIP packet functions

Author:

    Stefan Solomon  09/01/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop


/*++

Function:	SetRipIpxHeader

Descr:		sets the IPX packet header for a RIP packet to be sent
		from this machine & the RIP Operation Code

Arguments:
		hdrp -	    packet header pointer
		icbp -	    pointer to the interface CB on which the packet will be sent
		dstnode -   destination node
		dstsocket - destination socket
		RipOpCode - operation to be set in the packet RIP header

Remark: 	the packet length is not set by this function

--*/

VOID
SetRipIpxHeader(PUCHAR		    hdrp,      // pointer to the packet header
		PICB		    icbp,
		PUCHAR		    dstnode,
		PUCHAR		    dstsocket,
		USHORT		    RipOpcode)
{
    PUTUSHORT2SHORT(hdrp + IPXH_CHECKSUM, 0xFFFF);
    *(hdrp + IPXH_XPORTCTL) = 0;
    *(hdrp + IPXH_PKTTYPE) = 1;  // RIP packet
    memcpy(hdrp + IPXH_DESTNET, icbp->AdapterBindingInfo.Network, 4);
    memcpy(hdrp + IPXH_DESTNODE, dstnode, 6);
    memcpy(hdrp + IPXH_DESTSOCK, dstsocket, 2);
    memcpy(hdrp + IPXH_SRCNET, icbp->AdapterBindingInfo.Network, 4);
    memcpy(hdrp + IPXH_SRCNODE, icbp->AdapterBindingInfo.LocalNode, 6);
    PUTUSHORT2SHORT(hdrp + IPXH_SRCSOCK, IPX_RIP_SOCKET);

    // set the opcode
    PUTUSHORT2SHORT(hdrp + RIP_OPCODE, RipOpcode);
}

/*++

Function:	SetNetworkEntry

Descr:		sets a RIP network entry in the RIP packet

--*/

VOID
SetNetworkEntry(PUCHAR		pktp,	    // ptr where to set the net entry
		PIPX_ROUTE	IpxRoutep,
		USHORT		LinkTickCount)	// add to the route tick count
{
    memcpy(pktp + NE_NETNUMBER, IpxRoutep->Network, 4);
    if (IpxRoutep->HopCount<16)
        PUTUSHORT2SHORT(pktp + NE_NROFHOPS, IpxRoutep->HopCount+1);
    else
        PUTUSHORT2SHORT(pktp + NE_NROFHOPS, IpxRoutep->HopCount);

    // adjust the tick count with the adapter link speed (expressed as ticks)
    PUTUSHORT2SHORT(pktp + NE_NROFTICKS, IpxRoutep->TickCount + LinkTickCount);
}

/*++

Function:	MakeRipGenResponsePacket

Descr:		fills in a gen response packet network entries

Returns:	the packet length. Note that a length of RIP_INFO means
		empty packet and a length of RIP_PACKET_LEN means full packet.

--*/

USHORT
MakeRipGenResponsePacket(PWORK_ITEM	wip,
			 PUCHAR 	dstnodep,
			 PUCHAR 	dstsocket)
{
    PUCHAR		hdrp;
    USHORT		resplen;
    IPX_ROUTE		IpxRoute;
    HANDLE		EnumHandle;
    PICB		icbp;	    // interface to send the gen response on
    PICB		route_icbp; // interface on which the route resides

    hdrp = wip->Packet;
    EnumHandle = wip->WorkItemSpecific.WIS_EnumRoutes.RtmEnumerationHandle;
    icbp = wip->icbp;

    // create the IPX packet header
    SetRipIpxHeader(hdrp,
		    icbp,
		    dstnodep,
		    dstsocket,
		    RIP_RESPONSE);

    resplen = RIP_INFO;

    while(resplen < RIP_PACKET_LEN)
    {
	if(EnumGetNextRoute(EnumHandle, &IpxRoute) != NO_ERROR) {

	    break;
	}

	// check if this route can be advertised over this interface
	if(IsRouteAdvertisable(icbp, &IpxRoute)) {

	    // if this is the local client if, we advertise only the internal
	    // net over it
	    if(icbp->InterfaceType == LOCAL_WORKSTATION_DIAL) {

		if(IpxRoute.InterfaceIndex != 0) {

		    // skip if not internal net
		    continue;
		}
	    }

	    // check if the network doesn't appear also on the interface we
	    // will broadcast WITH THE SAME METRIC
	    if(IsDuplicateBestRoute(icbp, &IpxRoute)) {

		continue;
	    }

	    SetNetworkEntry(hdrp + resplen, &IpxRoute, icbp->LinkTickCount);
	    resplen += NE_ENTRYSIZE;
	}
    }

    // set the packet size in the IPX packet header
    PUTUSHORT2SHORT(hdrp + IPXH_LENGTH, resplen);

    return resplen;
}

/*++

Function:	SendRipGenRequest

Descr:		sends a RIP General Request packet over the specified interface

Remark: 	>> called with the interface lock held <<

--*/

DWORD
SendRipGenRequest(PICB		icbp)
{
    PWORK_ITEM		wip;
    UCHAR		ripsocket[2];
    USHORT		pktlen;

    PUTUSHORT2SHORT(ripsocket, IPX_RIP_SOCKET);

    if((wip = AllocateWorkItem(SEND_PACKET_TYPE)) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    wip->icbp = icbp;
    wip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;

    SetRipIpxHeader(wip->Packet,
		    icbp,
		    bcastnode,
		    ripsocket,
		    RIP_REQUEST);

    memcpy(wip->Packet + RIP_INFO + NE_NETNUMBER, bcastnet, 4);
    PUTUSHORT2SHORT(wip->Packet + RIP_INFO + NE_NROFHOPS, 0xFFFF);
    PUTUSHORT2SHORT(wip->Packet + RIP_INFO + NE_NROFTICKS, 0xFFFF);

    pktlen = RIP_INFO + NE_ENTRYSIZE;

    PUTUSHORT2SHORT(wip->Packet + IPXH_LENGTH, pktlen);

    if(SendSubmit(wip) != NO_ERROR) {

	FreeWorkItem(wip);
    }

    return NO_ERROR;
}

/*++

Function:	IsRouteAdvertisable

Descr:		checks if the route can be advertised over this interface

Arguments:	interface to advertise on
		route

Remark: 	>> called with interface lock taken <<

--*/

BOOL
IsRouteAdvertisable(PICB	    icbp,
		    PIPX_ROUTE	    IpxRoutep)
{
    if((icbp->InterfaceIndex != IpxRoutep->InterfaceIndex) &&
       PassRipSupplyFilter(icbp, IpxRoutep->Network) &&
       ((IpxRoutep->Flags & DO_NOT_ADVERTISE_ROUTE) == 0)) {

	return TRUE;
    }
    else
    {
	return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\update.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    update.c

Abstract:

    RIP Auto-Static Update

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop


// Max update retries
#define MAX_UPDATE_RETRIES		3

VOID
PostUpdateCompleteMessage(ULONG     InterfaceIndex,
			  DWORD     Status);


DWORD
WINAPI
DoUpdateRoutes(ULONG	    InterfaceIndex)
{
    DWORD	rc;
    PICB	icbp;
    PWORK_ITEM	wip;

    ACQUIRE_DATABASE_LOCK;

    if((rc = ValidStateAndIfIndex(InterfaceIndex, &icbp)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    ACQUIRE_IF_LOCK(icbp);

    // check if there are any parameters which disable doing update on this if
    if((icbp->IfConfigInfo.AdminState != ADMIN_STATE_ENABLED) ||
       (icbp->IfConfigInfo.UpdateMode != IPX_AUTO_STATIC_UPDATE) ||
       (icbp->IfStats.RipIfOperState != OPER_STATE_UP)) {

	rc = ERROR_CAN_NOT_COMPLETE;
	goto Exit;
    }

    // send a general request packet
    if(SendRipGenRequest(icbp) != NO_ERROR) {

	rc = ERROR_CAN_NOT_COMPLETE;
	goto Exit;
    }

    // allocate an update status check wi and queue it in timer queue for 10 sec
    if((wip = AllocateWorkItem(UPDATE_STATUS_CHECK_TYPE)) == NULL) {

	goto Exit;
    }

    wip->icbp = icbp;
    wip->AdapterIndex = INVALID_ADAPTER_INDEX;
    wip->IoCompletionStatus = NO_ERROR;
    wip->WorkItemSpecific.WIS_Update.UpdatedRoutesCount = 0;
    wip->WorkItemSpecific.WIS_Update.UpdateRetriesCount = 1;

    // save Listen state and enable it so we can execute the update command
    wip->WorkItemSpecific.WIS_Update.OldRipListen = icbp->IfConfigInfo.Listen;
    wip->WorkItemSpecific.WIS_Update.OldRipInterval = icbp->IfConfigInfo.PeriodicUpdateInterval;
    icbp->IfConfigInfo.Listen = ADMIN_STATE_ENABLED;
	icbp->IfConfigInfo.PeriodicUpdateInterval = MAXULONG;


    // delete all previous routes we kept for this if
    DeleteAllRipRoutes(icbp->InterfaceIndex);

    // Enqueue the update status check work item in the timer queue and increment
    // ref count
    IfRefStartWiTimer(wip, CHECK_UPDATE_TIME_MILISECS);

    rc = NO_ERROR;

Exit:

    RELEASE_IF_LOCK(icbp);
    RELEASE_DATABASE_LOCK;

    return rc;
}


/*++

Function:	CheckUpdateStatus

Descr:		Entered with the update status check wi processing every 10 sec.
		Compares the wi number of routes with the RTM held number of
		rip routes. If same -> update done, else go in timer queue again

Remark: 	Called with the Interface Lock held

--*/

VOID
IfCheckUpdateStatus(PWORK_ITEM	    wip)
{
    ULONG	RipRoutesCount;
    PICB	icbp;

    icbp = wip->icbp;

    // check if the interface is up and running
    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

	// restore Rip Listen
	icbp->IfConfigInfo.Listen = wip->WorkItemSpecific.WIS_Update.OldRipListen;
	icbp->IfConfigInfo.PeriodicUpdateInterval
							= wip->WorkItemSpecific.WIS_Update.OldRipInterval;

	// discard the CheckUpdateStatus work item and signal update failure
	PostUpdateCompleteMessage(icbp->InterfaceIndex, ERROR_CAN_NOT_COMPLETE);

	FreeWorkItem(wip);

	return;
    }

    RipRoutesCount = GetRipRoutesCount(icbp->InterfaceIndex);

    //if we have not received anything yet, send a new request up to the max
    if(RipRoutesCount == 0) {

	// if we can retry send a new request
	if(++wip->WorkItemSpecific.WIS_Update.UpdateRetriesCount <= MAX_UPDATE_RETRIES) {

	    SendRipGenRequest(icbp);
	    IfRefStartWiTimer(wip, CHECK_UPDATE_TIME_MILISECS);
	    return;
	}
    }

    if(wip->WorkItemSpecific.WIS_Update.UpdatedRoutesCount == RipRoutesCount) {

	// the number of routes didn't change in the last 10 seconds OR

	// restore Rip Listen & update interval
	icbp->IfConfigInfo.Listen = wip->WorkItemSpecific.WIS_Update.OldRipListen;
	icbp->IfConfigInfo.PeriodicUpdateInterval
							= wip->WorkItemSpecific.WIS_Update.OldRipInterval;


	PostUpdateCompleteMessage(icbp->InterfaceIndex, NO_ERROR);

	FreeWorkItem(wip);
    }
    else
    {
	// still getting new routes -> update with the latest count
	wip->WorkItemSpecific.WIS_Update.UpdatedRoutesCount = RipRoutesCount;

	// Enqueue the update status check work item in the timer queue and increment
	// ref count
	IfRefStartWiTimer(wip, CHECK_UPDATE_TIME_MILISECS);
    }
}

VOID
PostUpdateCompleteMessage(ULONG     InterfaceIndex,
			  DWORD     Status)
{
    MESSAGE	Result;

    Result.UpdateCompleteMessage.InterfaceIndex = InterfaceIndex;
    Result.UpdateCompleteMessage.UpdateType = DEMAND_UPDATE_ROUTES;
    Result.UpdateCompleteMessage.UpdateStatus = Status;

    PostEventMessage(UPDATE_COMPLETE, &Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\timer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Work Items Timer

Author:

    Stefan Solomon  07/20/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop


/*++

Function:	StartWiTimer


Descr:		Inserts a work item in the timer queue for the specified time

Remark: 	has to take and release the queues lock

--*/

VOID
StartWiTimer(PWORK_ITEM 	reqwip,
	     ULONG		timeout)
{
    PLIST_ENTRY     lep;
    PWORK_ITEM	    timqwip;

    reqwip->DueTime = GetTickCount() + timeout;

    ACQUIRE_QUEUES_LOCK;

    lep = TimerQueue.Blink;

    while(lep != &TimerQueue)
    {
	timqwip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);
	if(IsLater(reqwip->DueTime, timqwip->DueTime)) {

	    break;
	}
	lep = lep->Blink;
    }

    InsertHeadList(lep, &reqwip->Linkage);

    SetEvent(WorkerThreadObjects[TIMER_EVENT]);

    RELEASE_QUEUES_LOCK;
}


/*++

Function:	ProcessTimerQueue


Descr:		called when the timer queue due time has come.
		Dequeues all wi with expired timeout and queues them in the
		workers work items queue

Remark: 	has to take and release the queues lock

--*/

ULONG
ProcessTimerQueue(VOID)
{
    ULONG	dueTime = GetTickCount() + MAXULONG/2;
    PWORK_ITEM	wip;

    ACQUIRE_QUEUES_LOCK;

    while(!IsListEmpty(&TimerQueue))
    {
	// check the first in the list
	wip = CONTAINING_RECORD(TimerQueue.Flink, WORK_ITEM, Linkage);

	if(IsLater(GetTickCount(), wip->DueTime)) {

	    RemoveEntryList(&wip->Linkage);
	    RtlQueueWorkItem (ProcessWorkItem , wip, 0);
	}
	else
	{
	    dueTime = wip->DueTime;
	    break;
	}
    }

    RELEASE_QUEUES_LOCK;

    return dueTime;
}


/*++

Function:	FlushTimerQueue

Descr:		Dequeues all items in the timer queue and queues them into
		the workers work items queue


Remark: 	has to take and release the queues lock

--*/

VOID
FlushTimerQueue(VOID)
{
    PLIST_ENTRY 	lep;
    PWORK_ITEM		wip;

    ACQUIRE_QUEUES_LOCK;

    while(!IsListEmpty(&TimerQueue))
    {
	lep = RemoveHeadList(&TimerQueue);
	wip = CONTAINING_RECORD(lep, WORK_ITEM, Linkage);
        RtlQueueWorkItem (ProcessWorkItem , wip, 0);
    }

    RELEASE_QUEUES_LOCK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\rtmif.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmif.c

Abstract:

    Contains the RTM interface functions

Author:

    Stefan Solomon  07/06/1995

Revision History:


--*/


#include  "precomp.h"
#pragma hdrstop

// RTM RIP Client Handle

HANDLE	       RtmRipHandle;

typedef struct _ROUTE_NODE {

    LIST_ENTRY	    Linkage;
    IPX_ROUTE	    IpxRoute;

    } ROUTE_NODE, *PROUTE_NODE;

// List of route nodes with RIP route changes
LIST_ENTRY	RipChangedList;

// state of the RipChangedList
BOOL		RipChangedListOpen = FALSE;

// Lock for the RIP changed list
CRITICAL_SECTION    RipChangedListCritSec;

VOID
AddRouteToRipChangedList(PIPX_ROUTE	IpxRoutep);

HANDLE
CreateRipRoutesEnumHandle(ULONG     InterfaceIndex);


DWORD
OpenRTM(VOID)
{
    // initialize the variables for the RIP changes list
    InitializeListHead(&RipChangedList);
    RipChangedListOpen = TRUE;

    // register as RTM client
    if((RtmRipHandle = RtmRegisterClient(RTM_PROTOCOL_FAMILY_IPX,
					   IPX_PROTOCOL_RIP,
					   WorkerThreadObjects[RTM_EVENT],
					   0)) == NULL) {
	return ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
	return NO_ERROR;
    }
}

VOID
CloseRTM(VOID)
{
    PLIST_ENTRY 	lep;
    PROUTE_NODE 	rnp;

    // flush the RIP changed list and destroy its critical section
    ACQUIRE_RIP_CHANGED_LIST_LOCK;

    while(!IsListEmpty(&RipChangedList))
    {
	lep = RemoveHeadList(&RipChangedList);
	rnp = CONTAINING_RECORD(lep, ROUTE_NODE, Linkage);
	GlobalFree(rnp);
    }

    RipChangedListOpen = FALSE;

    RELEASE_RIP_CHANGED_LIST_LOCK;

    // deregister as RTM client
    RtmDeregisterClient(RtmRipHandle);
}

VOID
RtmToIpxRoute(PIPX_ROUTE	    IpxRoutep,
	      PRTM_IPX_ROUTE	    RtmRoutep)
{
    IpxRoutep->InterfaceIndex = (ULONG)(RtmRoutep->R_Interface);
    IpxRoutep->Protocol = RtmRoutep->R_Protocol;

    PUTULONG2LONG(IpxRoutep->Network, RtmRoutep->R_Network);

    IpxRoutep->TickCount = RtmRoutep->R_TickCount;
    IpxRoutep->HopCount = RtmRoutep->R_HopCount;
    memcpy(IpxRoutep->NextHopMacAddress,
	   RtmRoutep->R_NextHopMacAddress,
	   6);
    IpxRoutep->Flags = RtmRoutep->R_Flags;
}

VOID
IpxToRtmRoute(PRTM_IPX_ROUTE	    RtmRoutep,
	      PIPX_ROUTE	    IpxRoutep)
{
    RtmRoutep->R_Interface = IpxRoutep->InterfaceIndex;
    RtmRoutep->R_Protocol = IpxRoutep->Protocol;

    GETLONG2ULONG(&RtmRoutep->R_Network, IpxRoutep->Network);

    RtmRoutep->R_TickCount = IpxRoutep->TickCount;
    RtmRoutep->R_HopCount = IpxRoutep->HopCount;
    memcpy(RtmRoutep->R_NextHopMacAddress,
	   IpxRoutep->NextHopMacAddress,
	   6);

    RtmRoutep->R_Flags = IpxRoutep->Flags;
}


/*++

Function:	AddRipRoute

Descr:		adds a RIP route to RTM

--*/

DWORD
AddRipRoute(PIPX_ROUTE		IpxRoutep,
	    ULONG		TimeToLive)
{
    DWORD	    rc = 0;
    DWORD	    flags = 0;
    RTM_IPX_ROUTE   RtmRoute;
    RTM_IPX_ROUTE   CurBestRoute;
    RTM_IPX_ROUTE   PrevBestRoute;
    IPX_ROUTE	    PrevBestIpxRoute;

    IpxRoutep->Protocol = IPX_PROTOCOL_RIP;

    IpxToRtmRoute(&RtmRoute, IpxRoutep);

    if((rc = RtmAddRoute(
		     RtmRipHandle,
		     &RtmRoute,
		     TimeToLive,
		     &flags,
		     &CurBestRoute,
		     &PrevBestRoute)) != NO_ERROR) {

	return rc;
    }

    // check the type of change
    switch(flags) {

	case  RTM_ROUTE_ADDED:

	    AddRouteToRipChangedList(IpxRoutep);
	    break;

	case RTM_ROUTE_CHANGED:

	    if(CurBestRoute.R_HopCount == 16) {

		if(PrevBestRoute.R_HopCount < 16) {

		    // advertise that the previous route is down
		    RtmToIpxRoute(&PrevBestIpxRoute, &PrevBestRoute);
		    PrevBestIpxRoute.HopCount = 16;
		    AddRouteToRipChangedList(&PrevBestIpxRoute);
		}
	    }
	    else
	    {
		if((CurBestRoute.R_TickCount != PrevBestRoute.R_TickCount) ||
		   (CurBestRoute.R_HopCount != PrevBestRoute.R_HopCount)) {

		    AddRouteToRipChangedList(IpxRoutep);
		}
	    }

	    break;

	default:

	    break;
    }

    return rc;
}

/*++

Function:	DeleteRipRoute

Descr:		deletes a RIP route from RTM

--*/

DWORD
DeleteRipRoute(PIPX_ROUTE	IpxRoutep)
{
    DWORD		rc;
    DWORD		flags = 0;
    RTM_IPX_ROUTE	RtmRoute;
    RTM_IPX_ROUTE	CurBestRoute;
    IPX_ROUTE		CurBestIpxRoute;

    IpxRoutep->Protocol = IPX_PROTOCOL_RIP;

    IpxToRtmRoute(&RtmRoute, IpxRoutep);

    if((rc = RtmDeleteRoute(RtmRipHandle,
			&RtmRoute,
			&flags,
			&CurBestRoute
			)) != NO_ERROR) {

	return rc;
    }

    switch(flags) {

	case RTM_ROUTE_DELETED:

	    // bcast that we lost the previous route
	    AddRouteToRipChangedList(IpxRoutep);
	    break;

	case RTM_ROUTE_CHANGED:

	    // current best route changed
	    RtmToIpxRoute(&CurBestIpxRoute, &CurBestRoute);

	    if(CurBestIpxRoute.HopCount == 16) {

		// bcast that we lost the previous route
		AddRouteToRipChangedList(IpxRoutep);
	    }
	    else
	    {
		// bcast that we have a new best route
		AddRouteToRipChangedList(&CurBestIpxRoute);
	    }

	    break;

	default:

	    break;
    }

    return rc;
}

/*++

Function:	DeleteAllRipRoutes

Descr:		deletes all RIP routes for the specified interface

--*/

VOID
DeleteAllRipRoutes(ULONG	InterfaceIndex)
{
    HANDLE			EnumHandle;
    IPX_ROUTE			IpxRoute;
    RTM_IPX_ROUTE		RtmCriteriaRoute;
    DWORD			rc;

    Trace(RTM_TRACE, "DeleteAllRipRoutes: Entered for if # %d\n", InterfaceIndex);

    // enumerate all the routes for this interface and add them in the rip changed
    // list
    if((EnumHandle = CreateRipRoutesEnumHandle(InterfaceIndex)) == NULL) {

	Trace(RTM_TRACE, "DeleteAllRipRoutes: cannot create enum handle for if # %d\n", InterfaceIndex);

	goto DeleteRoutes;
    }

    while(EnumGetNextRoute(EnumHandle, &IpxRoute) == NO_ERROR)
    {
	if(IpxRoute.HopCount < 16) {

	    IpxRoute.HopCount = 16;
	    AddRouteToRipChangedList(&IpxRoute);
	}
    }

    CloseEnumHandle(EnumHandle);

DeleteRoutes:

    // ... and now delete all routes for this interface
    memset(&RtmCriteriaRoute,
	   0,
	   sizeof(RTM_IPX_ROUTE));

    RtmCriteriaRoute.R_Interface = InterfaceIndex;
    RtmCriteriaRoute.R_Protocol = IPX_PROTOCOL_RIP;

    rc = RtmBlockDeleteRoutes(RtmRipHandle,
		      RTM_ONLY_THIS_INTERFACE,
		      &RtmCriteriaRoute);

    Trace(RTM_TRACE, "DeleteAllRipRoutes: RtmBlockDeleteRoutes returned rc=%d for if # %d\n",
		   rc,
		   InterfaceIndex);

}

/*++

Function:	IsRoute

Descr:		returns TRUE if a route to the specified net exists

--*/

BOOL
IsRoute(PUCHAR		Network,
	PIPX_ROUTE	IpxRoutep)
{
    DWORD	    RtmNetwork;
    RTM_IPX_ROUTE   RtmRoute;

    GETLONG2ULONG(&RtmNetwork, Network);

    if(RtmIsRoute(RTM_PROTOCOL_FAMILY_IPX,
	       &RtmNetwork,
	       &RtmRoute)) {

    if (IpxRoutep!=NULL)
	    RtmToIpxRoute(IpxRoutep, &RtmRoute);

	return TRUE;
    }
    else
    {
	return FALSE;
    }
}

//***********************************************************************
//									*
//		Fast Enumeration Functions				*
//									*
//***********************************************************************

HANDLE
CreateBestRoutesEnumHandle(VOID)
{
    HANDLE			EnumHandle;
    RTM_IPX_ROUTE		CriteriaRoute;

    EnumHandle = RtmCreateEnumerationHandle(RTM_PROTOCOL_FAMILY_IPX,
					    RTM_ONLY_BEST_ROUTES,
					    &CriteriaRoute);
    return EnumHandle;
}

DWORD
EnumGetNextRoute(HANDLE		EnumHandle,
		 PIPX_ROUTE	IpxRoutep)
{
    RTM_IPX_ROUTE	    RtmRoute;
    DWORD	    rc;

    rc = RtmEnumerateGetNextRoute(EnumHandle,
				  &RtmRoute);

    if (rc == NO_ERROR)
    {
        RtmToIpxRoute(IpxRoutep, &RtmRoute);
    }        

    return rc;
}

VOID
CloseEnumHandle(HANDLE EnumHandle)
{
    RtmCloseEnumerationHandle(EnumHandle);
}

HANDLE
CreateRipRoutesEnumHandle(ULONG     InterfaceIndex)
{
    RTM_IPX_ROUTE		EnumCriteriaRoute;
    HANDLE			EnumHandle;

    memset(&EnumCriteriaRoute, 0, sizeof(RTM_IPX_ROUTE));

    EnumCriteriaRoute.R_Interface = InterfaceIndex;
    EnumCriteriaRoute.R_Protocol = IPX_PROTOCOL_RIP;

    EnumHandle = RtmCreateEnumerationHandle(RTM_PROTOCOL_FAMILY_IPX,
		 RTM_ONLY_BEST_ROUTES | RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL,
					    &EnumCriteriaRoute);
    return EnumHandle;
}


/*++

Function:	GetRipRoutesCount

Descr:		returns the number of rip routes associated with this interface

--*/

ULONG
GetRipRoutesCount(ULONG 	InterfaceIndex)
{
    HANDLE	   EnumHandle;
    ULONG	   RipRoutesCount = 0;
    IPX_ROUTE	   IpxRoute;

    if((EnumHandle = CreateRipRoutesEnumHandle(InterfaceIndex)) == NULL) {

	return 0;
    }

    while(EnumGetNextRoute(EnumHandle, &IpxRoute) == NO_ERROR)
    {
	RipRoutesCount++;
    }

    CloseEnumHandle(EnumHandle);

    return RipRoutesCount;
}

/*++

Function:	DequeueRouteChangeFromRip

Descr:

Remark:        >> called with the database & queues lock held <<

--*/

DWORD
DequeueRouteChangeFromRip(PIPX_ROUTE	    IpxRoutep)
{
    PLIST_ENTRY     lep;
    PROUTE_NODE	    rnp;

    if(!IsListEmpty(&RipChangedList)) {

	lep = RemoveHeadList(&RipChangedList);
	rnp = CONTAINING_RECORD(lep, ROUTE_NODE, Linkage);
	*IpxRoutep = rnp->IpxRoute;

	GlobalFree(rnp);

	return NO_ERROR;
    }
    else
    {
	return ERROR_NO_MORE_ITEMS;
    }
}


/*++

Function:	DequeueRouteChangeFromRtm

Descr:

Remark: 	>> called with the database locks held <<

--*/


DWORD
DequeueRouteChangeFromRtm(PIPX_ROUTE	    IpxRoutep,
			  PBOOL 	    skipitp,
			  PBOOL 	    lastmessagep)
{
    RTM_IPX_ROUTE	    CurBestRoute, PrevBestRoute;
    DWORD		    Flags = 0;
    DWORD		    rc;

    *skipitp = FALSE;
    *lastmessagep = FALSE;

    rc = RtmDequeueRouteChangeMessage(RtmRipHandle,
				      &Flags,
				      &CurBestRoute,
				      &PrevBestRoute);

    switch(rc) {

	case NO_ERROR:

	    *lastmessagep = TRUE;
	    break;

	case ERROR_MORE_MESSAGES:

	    break;

	default:

	    return ERROR_NO_MORE_ITEMS;
    }

    switch(Flags) {

	case RTM_ROUTE_ADDED:

	    RtmToIpxRoute(IpxRoutep, &CurBestRoute);

	    break;

	case RTM_ROUTE_DELETED:

	    RtmToIpxRoute(IpxRoutep, &PrevBestRoute);

	    IpxRoutep->HopCount = 16;

	    break;

	case RTM_ROUTE_CHANGED:

	    // if there was a change in metric advertise it.
	    // Else, ignore it.

	    if(CurBestRoute.R_TickCount != PrevBestRoute.R_TickCount) {

		RtmToIpxRoute(IpxRoutep, &CurBestRoute);
	    }
	    else
	    {
		*skipitp = TRUE;
	    }

	    break;

	default:

	    *skipitp = TRUE;

	    break;
    }

    return NO_ERROR;
}


VOID
AddRouteToRipChangedList(PIPX_ROUTE	IpxRoutep)
{
    PROUTE_NODE     rnp;

    if((rnp = GlobalAlloc(GPTR, sizeof(ROUTE_NODE))) == NULL) {

	return;
    }

    rnp->IpxRoute = *IpxRoutep;

    ACQUIRE_RIP_CHANGED_LIST_LOCK;

    if(!RipChangedListOpen) {

	GlobalFree(rnp);
    }
    else
    {
	InsertTailList(&RipChangedList, &rnp->Linkage);
	SetEvent(WorkerThreadObjects[RIP_CHANGES_EVENT]);
    }

    RELEASE_RIP_CHANGED_LIST_LOCK;
}

BOOL
IsDuplicateBestRoute(PICB	    icbp,
		     PIPX_ROUTE     IpxRoutep)
{
    RTM_IPX_ROUTE	    RtmRoute;
    DWORD		    rc;

    GETLONG2ULONG(&RtmRoute.R_Network, IpxRoutep->Network);
    RtmRoute.R_Interface = icbp->InterfaceIndex;

    rc = RtmGetFirstRoute(
			RTM_PROTOCOL_FAMILY_IPX,
			RTM_ONLY_THIS_NETWORK | RTM_ONLY_THIS_INTERFACE,
			&RtmRoute);

    // check if it has the same metric
    if((rc == NO_ERROR) &&
       ((USHORT)(RtmRoute.R_TickCount) == IpxRoutep->TickCount)) {

	// duplicate !
	return TRUE;
    }
    else
    {
	return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\ripproc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ripproc.c

Abstract:

    RIP processing functions

Author:

    Stefan Solomon  09/01/1995

Revision History:


--*/

#include  "precomp.h"
#pragma hdrstop

VOID
RipRequest(PWORK_ITEM	     wip);

VOID
RipResponse(PWORK_ITEM	      wip);

VOID
StartGenResponse(PICB	icbp,
		 PUCHAR	dstnodep,
		 PUCHAR	dstsocket);

ULONG
RouteTimeToLiveSecs(PICB	icbp);

/*++

Function:	ProcessReceivedPacket

Descr:		increments the receive if statistics
		does rip processing

Remark: 	>> called with the if lock held <<

--*/

VOID
ProcessReceivedPacket(PWORK_ITEM	wip)
{
    USHORT	    opcode;
    PUCHAR	    hdrp;    // ptr to the packet header
    PICB	    icbp;
    USHORT	    pktlen;

    icbp = wip->icbp;

    // check that the interface is up
    if(icbp->IfStats.RipIfOperState != OPER_STATE_UP) {

	return;
    }

    // get a ptr to the packet header
    hdrp = wip->Packet;

    // check if this is a looped back packet
    if(!memcmp(hdrp + IPXH_SRCNODE, icbp->AdapterBindingInfo.LocalNode, 6)) {

	return;
    }

    // update the interface receive statistics
    icbp->IfStats.RipIfInputPackets++;

    // check the packet length
    GETSHORT2USHORT(&pktlen, hdrp + IPXH_LENGTH);

    if(pktlen > MAX_PACKET_LEN) {

	// bad length RIP packet
	return;
    }

    // check the RIP operation type
    GETSHORT2USHORT(&opcode, hdrp + RIP_OPCODE);

    switch(opcode) {

	case RIP_REQUEST:

	    RipRequest(wip);
	    break;

	case RIP_RESPONSE:

	    RipResponse(wip);
	    break;

	default:

	    // this is a bad opcode RIP packet
	    break;
    }
}


//***
//
// Function:	RipRequest
//
// Descr:	process the RIP request
//
// Remark:	>> called with the if lock held <<
//
//***

VOID
RipRequest(PWORK_ITEM	     wip)
{
    USHORT		reqlen;	// offset to get next request
    USHORT		resplen; // offset to put next response
    USHORT		pktlen;	// packet length
    PUCHAR		hdrp;	// ptr to the received packet header
    PUCHAR		resphdrp; // ptr to the response packet header
    PICB		icbp;
    USHORT		srcsocket;
    IPX_ROUTE		IpxRoute;
    PWORK_ITEM		respwip = NULL;	// response packet
    ULONG		network;

    icbp = wip->icbp;

    Trace(RIP_REQUEST_TRACE, "RipRequest: Entered on if # %d", icbp->InterfaceIndex);

    if(icbp->IfConfigInfo.Supply != ADMIN_STATE_ENABLED) {

	Trace(RIP_REQUEST_TRACE,
	      "RIP request discarded on if %d because Supply is DISABLED\n",
	      icbp->InterfaceIndex);

	return;
    }

    // get a ptr to the packet header
    hdrp = wip->Packet;

    // get IPX packet length
    GETSHORT2USHORT(&pktlen, hdrp + IPXH_LENGTH);

    // if the packet is too long, discard
    if(pktlen > MAX_PACKET_LEN) {

	Trace(RIP_REQUEST_TRACE,
	      "RIP request discarded on if %d because the packet size %d > max packet len %d\n",
	      icbp->InterfaceIndex,
	      pktlen,
	      MAX_PACKET_LEN);

	return;
    }

    // We may have one or more network entry requests in the packet.
    // If one network entry is 0xFFFFFFFF, then a general RIP response is
    // requested.

    // for each network entry, try to get the answer from our routing table
    for(reqlen = resplen = RIP_INFO;
	(reqlen+NE_ENTRYSIZE) <= pktlen;
	reqlen += NE_ENTRYSIZE) {

	// check if a general response is requested
	if(!memcmp(hdrp + reqlen + NE_NETNUMBER, bcastnet, 4)) {

	    //*** a general response is requested ***

	    // create the initial general response packet (work item).
	    // when the send completes for this packet, the work item will
	    // contain the RTM enumeration handle which is used to continue
	    // for the creation of the next succesive gen response packets
	    StartGenResponse(icbp,
			     hdrp + IPXH_SRCNODE,
			     hdrp + IPXH_SRCSOCK);
	    return;
	}

	//*** a specific response is requested. ***

	// allocate a response packet if none allocated yet
	if(respwip == NULL) {

	    if((respwip = AllocateWorkItem(SEND_PACKET_TYPE)) == NULL) {

		// give up!
		Trace(RIP_REQUEST_TRACE,
		"RIP request discarded on if %d because cannot allocate response packet\n",
		 icbp->InterfaceIndex);

		return;
	    }
	    else
	    {
		// init the send packet
		respwip->icbp = icbp;
		respwip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;
		resphdrp = respwip->Packet;
	    }
	}

	if(IsRoute(hdrp + reqlen + NE_NETNUMBER, &IpxRoute)) {

	    // check if we can route the packet
	    // the route should be on a different interface index than the
	    // received packet. For the global WAN net, the interface index is
	    // the GLOBAL_INTERFACE_INDEX

	    if(IsRouteAdvertisable(icbp, &IpxRoute)) {

		// we can route it -> answer to it
		// fill in the network entry structure in the packet with the
		// info from the route entry
		SetNetworkEntry(resphdrp + resplen, &IpxRoute, icbp->LinkTickCount);

		// increment the response length to the next response entry
		resplen += NE_ENTRYSIZE;
	    }
	}
	else
	{
	    GETLONG2ULONG(&network, hdrp + reqlen + NE_NETNUMBER);

	    Trace(RIP_REQUEST_TRACE,
		  "RIP Request on if %d : Route not found for net %x\n",
		  icbp->InterfaceIndex,
		  network);
	}
    }

    // We are done answering this request.
    // Check if any response has been generated
    if(resplen == RIP_INFO) {

	// no response generated for this packet
	if(respwip != NULL) {

	    FreeWorkItem(respwip);
	}
	return;
    }

    // set the response packet header (src becomes dest)
    SetRipIpxHeader(resphdrp,
		    icbp,	    // sets the src&dst net, src node and src socket
		    hdrp + IPXH_SRCNODE,
		    hdrp + IPXH_SRCSOCK,
		    RIP_RESPONSE);

    // set the new packet length
    PUTUSHORT2SHORT(resphdrp + IPXH_LENGTH, resplen);

    // send the response
    if(SendSubmit(respwip) != NO_ERROR) {

	FreeWorkItem(respwip);
    }
}

//***
//
// Function:	RipResponse
//
// Descr:	Updates the routing table with the response info
//
// Params:	Packet
//
// Returns:	none
//
// Remark:	>> called with the interface lock held <<
//
//***

VOID
RipResponse(PWORK_ITEM	      wip)
{
    PICB	       icbp;
    USHORT	       resplen;	// offset of the next response network entry
    USHORT	       pktlen;	// IPX packet length
    PUCHAR	       hdrp;	// ptr to the packet header
    USHORT	       nrofhops;
    USHORT	       tickcount;
    IPX_ROUTE	       IpxRoute;
    ULONG          i; 

    // get a ptr to this ICB
    icbp = wip->icbp;

    // check if LISTEN TO RIP UPDATES is enabled on this interface
    if(icbp->IfConfigInfo.Listen != ADMIN_STATE_ENABLED) {

	Trace(RIP_RESPONSE_TRACE,
	  "RIP Response on if %d : discard response packet because LISTEN is DISABLED\n",
	   icbp->InterfaceIndex);

	return;
    }

    // get a ptr to the received response packet header
    hdrp = wip->Packet;

    // get received response packet length
    GETSHORT2USHORT(&pktlen, hdrp + IPXH_LENGTH);

    // check the source address of the sender. If different then what is locally
    // configured log an error.
    if(memcmp(hdrp + IPXH_SRCNET, icbp->AdapterBindingInfo.Network, 4)) {

	Trace(RIP_ALERT,
	"The router at %.2x%.2x%.2x%.2x%.2x%.2x claims the local interface # %d has network number %.2x%.2x%.2x%.2x !\n",
	*(hdrp + IPXH_SRCNODE),
	*(hdrp + IPXH_SRCNODE + 1),
	*(hdrp + IPXH_SRCNODE + 2),
	*(hdrp + IPXH_SRCNODE + 3),
	*(hdrp + IPXH_SRCNODE + 4),
	*(hdrp + IPXH_SRCNODE + 5),
	icbp->InterfaceIndex,
	*(hdrp + IPXH_SRCNET),
	*(hdrp + IPXH_SRCNET + 1),
	*(hdrp + IPXH_SRCNET + 2),
	*(hdrp + IPXH_SRCNET + 3));

    IF_LOG (EVENTLOG_WARNING_TYPE) {
        LPWSTR   pname[1] = {icbp->InterfaceName};
        RouterLogWarningDataW (RipEventLogHdl,
                ROUTERLOG_IPXRIP_LOCAL_NET_NUMBER_CONFLICT,
                1, pname,
                10, hdrp+IPXH_SRCNET);
    }

	return;
    }

    // For each network entry:
    //		chcek if it passes the acceptance filter and if yes:
    //		add it to our routing table if route not down
    //		delete it from the routing table if route down

    for(resplen = RIP_INFO, i = 0;
	((resplen+NE_ENTRYSIZE) <= pktlen) && (i < 50);
	resplen += NE_ENTRYSIZE, i++) {

	// check if there is an entry left in the packet
	if(resplen + NE_ENTRYSIZE > pktlen) {

	    Trace(RIP_ALERT, "RipResponse: Invalid length for last network entry in the packet, discard entry!\n");
	    continue;
	}

	// check if it passes the acceptance filter
	if(!PassRipListenFilter(icbp, hdrp + resplen + NE_NETNUMBER)) {

	    Trace(RIP_RESPONSE_TRACE,
		  "RIP Response on if %d : do not accept net %.2x%.2x%.2x%.2x because of LISTEN filter\n",
		  icbp->InterfaceIndex,
		  *(hdrp + IPXH_SRCNET),
		  *(hdrp + IPXH_SRCNET + 1),
		  *(hdrp + IPXH_SRCNET + 2),
		  *(hdrp + IPXH_SRCNET + 3));

	    continue;
	}

	// check if the network route is up or down
	GETSHORT2USHORT(&nrofhops, hdrp + resplen + NE_NROFHOPS);

	if(nrofhops < 16) {
        // pmay: U270476.  Disregard routes with 0 hop count
        //
        if (nrofhops == 0)
        {
            continue;
        }

	    // if there is a bogus network number advertised in this packet
	    // like 0 or FFFFFFFF ignore it.
	    if(!memcmp(hdrp + resplen + NE_NETNUMBER, nullnet, 4)) {

		continue;
	    }

	    if(!memcmp(hdrp + resplen + NE_NETNUMBER, bcastnet, 4)) {

		continue;
	    }

	    // should not accept route for a directly connected net
	    if(IsRoute(hdrp + resplen + NE_NETNUMBER, &IpxRoute) &&
	       (IpxRoute.Protocol == IPX_PROTOCOL_LOCAL)) {

		continue;
	    }

	    // should not accept the route if it has a bad number of ticks
	    // like 0 or > 60000.
	    GETSHORT2USHORT(&IpxRoute.TickCount, hdrp + resplen + NE_NROFTICKS);
	    if((IpxRoute.TickCount == 0) ||
	       (IpxRoute.TickCount > 60000)) {

		continue;
	    }

	    // Add (update) this route to the routing table

	    IpxRoute.InterfaceIndex = icbp->InterfaceIndex;
	    IpxRoute.Protocol = IPX_PROTOCOL_RIP;
	    memcpy(IpxRoute.Network, hdrp + resplen + NE_NETNUMBER, 4);

	    // if this route is learned over a point to point wan, next hop doesn't
	    // make sense
	    if(icbp->InterfaceType == PERMANENT) {

		memcpy(IpxRoute.NextHopMacAddress, hdrp + IPXH_SRCNODE, 6);
	    }
	    else
	    {
		memcpy(IpxRoute.NextHopMacAddress, bcastnode, 6);
	    }

	    GETSHORT2USHORT(&IpxRoute.HopCount, hdrp + resplen + NE_NROFHOPS);

	    if(IpxRoute.HopCount == 15) {

		IpxRoute.Flags = DO_NOT_ADVERTISE_ROUTE;
		AddRipRoute(&IpxRoute, RouteTimeToLiveSecs(icbp));
	    }
	    else
	    {
		IpxRoute.Flags = 0;

		// add it to the table
		switch(icbp->InterfaceType) {

		case REMOTE_WORKSTATION_DIAL:

		    // this RIP advertisment comes from a remote client
		    // we should accept it only if this is its internal net and if
		    // it doesn't conflict with a network we already have
		    if ((memcmp(icbp->RemoteWkstaInternalNet, nullnet, 4)==0)
                    || (memcmp(icbp->RemoteWkstaInternalNet, IpxRoute.Network, 4)==0)) {

			// none added so far as internal net for this client
			if (!IsRoute(IpxRoute.Network, NULL)) {

			    // we assume this is its internal net and it will be
                // cleaned up when interface is disconnected
			    AddRipRoute(&IpxRoute, INFINITE);

			    memcpy(icbp->RemoteWkstaInternalNet,
				   IpxRoute.Network,
				   4);
			}
		    }

		    // do not accept any more advertisments from this client
		    return;

		case LOCAL_WORKSTATION_DIAL:

		    // the interface is the local host dialed out.
		    // routes received by it should not be advertised over any
		    // interface but kept only for internal routing

			if (!IsRoute(IpxRoute.Network, NULL)) {
		        IpxRoute.Flags = DO_NOT_ADVERTISE_ROUTE;
		        AddRipRoute(&IpxRoute, INFINITE);
            }
		    break;

		default:

		    AddRipRoute(&IpxRoute, RouteTimeToLiveSecs(icbp));
		    break;
		}
	    }
	}
	else
	{
	    // Delete this route from the routing table

	    IpxRoute.InterfaceIndex = icbp->InterfaceIndex;
	    IpxRoute.Protocol = IPX_PROTOCOL_RIP;
	    memcpy(IpxRoute.Network, hdrp + resplen + NE_NETNUMBER, 4);
	    memcpy(IpxRoute.NextHopMacAddress, hdrp + IPXH_SRCNODE, 6);
	    GETSHORT2USHORT(&IpxRoute.TickCount, hdrp + resplen + NE_NROFTICKS);
	    GETSHORT2USHORT(&IpxRoute.HopCount, hdrp + resplen + NE_NROFHOPS);

	    // delete it from the table
	    DeleteRipRoute(&IpxRoute);
	}
    }
}


/*++

Function:	StartGenResponse

Descr:		Creates a work item (packet) of type general response
		Creates a RTM enumeration handle
		Starts filling in a packet from RTM using split horizon
		Sends the packet

--*/

VOID
StartGenResponse(PICB	icbp,
		 PUCHAR	dstnodep,     // dst node to send gen resp
		 PUCHAR	dstsocket)   // dst socket to send gen resp
{
    PWORK_ITEM		wip;
    HANDLE		EnumHandle;
    PUCHAR		hdrp;  // gen resp ipx packet header

    // allocate a work item
    if((wip = AllocateWorkItem(GEN_RESPONSE_PACKET_TYPE)) == NULL) {

	return;
    }

    // init the work item
    wip->icbp = icbp;
    wip->AdapterIndex = icbp->AdapterBindingInfo.AdapterIndex;

    // create an RTM enumeration handle
    if((EnumHandle = CreateBestRoutesEnumHandle()) == NULL) {

	FreeWorkItem(wip);
	return;
    }

    wip->WorkItemSpecific.WIS_EnumRoutes.RtmEnumerationHandle = EnumHandle;

    // make the first gen response packet
    if(MakeRipGenResponsePacket(wip,
				dstnodep,
				dstsocket) == EMPTY_PACKET) {

	// no routes to advertise for this general response
	CloseEnumHandle(EnumHandle);
	FreeWorkItem(wip);

	return;
    }

    // Send the gen response on the associated adapter
    if(IfRefSendSubmit(wip) != NO_ERROR) {

	// !!!
	CloseEnumHandle(EnumHandle);
	FreeWorkItem(wip);
    }
}


/*++

Function:	IfCompleteGenResponse

Descr:		Completes the gen response work item either by terminating it
		if no more routes to advertise or by
		getting the rest of the routes up to one packet and sending
		the packet

--*/


VOID
IfCompleteGenResponse(PWORK_ITEM	    wip)
{
    USHORT	    opcode;
    PICB	    icbp;
    HANDLE	    EnumHandle;
    USHORT	    pktlen;

    EnumHandle = wip->WorkItemSpecific.WIS_EnumRoutes.RtmEnumerationHandle;

    // first off - check the interface status
    icbp = wip->icbp;
    GETSHORT2USHORT(&pktlen, wip->Packet + IPXH_LENGTH);

    // check that:
    // 1.    the interface is up
    // 2.    this was not the last packet in the response
    if((icbp->IfStats.RipIfOperState != OPER_STATE_UP) ||
      (pktlen < FULL_PACKET)) {

	CloseEnumHandle(EnumHandle);
	FreeWorkItem(wip);

	return;
    }

    // make the next gen response packet
    if(MakeRipGenResponsePacket(wip,
				wip->Packet + IPXH_DESTNODE,
				wip->Packet + IPXH_DESTSOCK) == EMPTY_PACKET) {

	// no more routes to advertise in this gen response
	CloseEnumHandle(EnumHandle);
	FreeWorkItem(wip);

	return;
    }

    // Send the gen response on the associated adapter
    if(IfRefSendSubmit(wip) != NO_ERROR) {

	CloseEnumHandle(EnumHandle);
	FreeWorkItem(wip);
    }
}

ULONG
RouteTimeToLiveSecs(PICB	icbp)
{
    if(icbp->IfConfigInfo.PeriodicUpdateInterval == MAXULONG) {

	return INFINITE;
    }
    else
    {
	return (AGE_INTERVAL_MULTIPLIER(icbp)) * (PERIODIC_UPDATE_INTERVAL_SECS(icbp));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rip\workitem.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    worker.c

Abstract:

    work items management functions

Author:

    Stefan Solomon  07/11/1995

Revision History:

--*/


#include  "precomp.h"
#pragma hdrstop


/*++

Function:	CreateWorkItemsManager

Descr:		creates the work items heap

--*/

HANDLE		WiHeapHandle;
ULONG		WorkItemsCount;

DWORD
CreateWorkItemsManager(VOID)
{
    if((WiHeapHandle = HeapCreate(0,
				 0x8000,     // 32k initial size
				 0x800000    // 8 meg max size
				 )) == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

VOID
DestroyWorkItemsManager(VOID)
{
    HeapDestroy(WiHeapHandle);
}

/*++

Function:	AllocateWorkItem

Descr:		allocates the work item from the workitems heap
		The function looks at the work item type and allocates a
		packet at the end if required

--*/

PWORK_ITEM
AllocateWorkItem(ULONG	      Type)
{
    PWORK_ITEM		wip;

    switch(Type) {

	case UPDATE_STATUS_CHECK_TYPE:
	case START_CHANGES_BCAST_TYPE:
	case SHUTDOWN_INTERFACES_TYPE:
	case PERIODIC_GEN_REQUEST_TYPE:
	case DEBUG_TYPE:

	    if((wip = GlobalAlloc(GPTR, sizeof(WORK_ITEM))) == NULL) {

		return NULL;
	    }

	    break;

	default:

	    if((wip = HeapAlloc(WiHeapHandle,
				HEAP_ZERO_MEMORY,
				sizeof(WORK_ITEM) + MAX_PACKET_LEN)) == NULL) {

		return NULL;
	    }
    }

    wip->Type = Type;

    InterlockedIncrement(&WorkItemsCount);

    return wip;
}

/*++

Function:	FreeWorkItem

Descr:		frees the work item to the workitems heap

--*/

VOID
FreeWorkItem(PWORK_ITEM     wip)
{
    HGLOBAL	   rc_global;
    BOOL	   rc_heap;

    switch(wip->Type) {

	case UPDATE_STATUS_CHECK_TYPE:
	case START_CHANGES_BCAST_TYPE:
	case SHUTDOWN_INTERFACES_TYPE:
	case PERIODIC_GEN_REQUEST_TYPE:
	case DEBUG_TYPE:

	    rc_global = GlobalFree(wip);
	    SS_ASSERT(rc_global == NULL);

	    break;

	default:

	    rc_heap = HeapFree(WiHeapHandle,
			       0,
			       wip);

	    SS_ASSERT(rc_heap);

	    break;
    }

    InterlockedDecrement(&WorkItemsCount);
}

/*++

Function:	EnqueueWorkItemToWorker

Descr:		inserts a work item in the workers queue and signals the
		semaphore

Remark: 	Called with the Queues Lock held

--*/
/* Converted to macro
VOID
EnqueueWorkItemToWorker(PWORK_ITEM	wip)
{
    InsertTailList(&WorkersQueue, &wip->Linkage);

    SetEvent(WorkerThreadObjects[WORKERS_QUEUE_EVENT]);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\cpstub.c ===
#include "precomp.h"
#pragma hdrstop


VOID
IpxcpGetConfiguration(PBOOL	    ThisMachineOnly,
		      PBOOL	    WanNetDatabaseInitialized,
		      PBOOL	    EnableGlobalWanNet,
		      PUCHAR	    GlobalWannet)
{
}



VOID
IpxcpRouterStarted(VOID)
{

}

VOID
IpxcpRouterStopped(VOID)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\adpdbase.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    adpdbase.c

Abstract:

    Functions to manipulate the adapters data base

Author:

    Stefan Solomon  04/10/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define adpthashindex(AdptIndex)  (AdptIndex) % ADAPTER_HASH_TABLE_SIZE

// THIS FUNCTIONS ASSUME THE ROUTER MANAGER IS IN CRITICAL SECTION WHEN CALLED

//***
//
// Function:	InitAdptDB
//
// Descr:
//
//***

VOID
InitAdptDB(VOID)
{
    int 	    i;
    PLIST_ENTRY     IfHtBucketp;

    IfHtBucketp = IndexAdptHt;

    for(i=0; i<ADAPTER_HASH_TABLE_SIZE; i++, IfHtBucketp++) {

	InitializeListHead(IfHtBucketp);
    }
}

/*++

Function:	AddToAdapterHt

Descr:		Adds the adapter control block to the hash table of adapters

--*/

VOID
AddToAdapterHt(PACB	    acbp)
{
    int 	    hv;
    PLIST_ENTRY     lep;
    PACB	    list_acbp;

    // insert in index hash table
    hv = adpthashindex(acbp->AdapterIndex);
    InsertTailList(&IndexAdptHt[hv], &acbp->IndexHtLinkage);
}

VOID
RemoveFromAdapterHt(PACB	acbp)
{
    RemoveEntryList(&acbp->IndexHtLinkage);
}

/*++

Function:	GetAdapterByIndex

Descr:

--*/

PACB
GetAdapterByIndex(ULONG	    AdptIndex)
{
    PACB	    acbp;
    PLIST_ENTRY     lep;
    int 	    hv;

    hv = adpthashindex(AdptIndex);

    lep = IndexAdptHt[hv].Flink;

    while(lep != &IndexAdptHt[hv])
    {
	acbp = CONTAINING_RECORD(lep, ACB, IndexHtLinkage);
	if (acbp->AdapterIndex == AdptIndex) {

	    return acbp;
	}

	lep = acbp->IndexHtLinkage.Flink;
    }

    return NULL;
}


/*++

Function:	GetAdapterByName

Descr:		Scans the list of adapters looking for the matching name

--*/

PACB
GetAdapterByNameAndPktType (LPWSTR 	    AdapterName, ULONG PacketType)
{
    PACB	    acbp;
    PLIST_ENTRY     lep;
    int 	    i;

    // the list of adapters is kept in the adapters hash table.
    for(i=0; i<ADAPTER_HASH_TABLE_SIZE;i++) {

	lep = IndexAdptHt[i].Flink;

	while(lep != &IndexAdptHt[i])
	{
	    acbp = CONTAINING_RECORD(lep, ACB, IndexHtLinkage);

	    if(!_wcsicmp(AdapterName, acbp->AdapterNamep)) {
            if ((PacketType == AUTO_DETECT_PACKET_TYPE)
                || (PacketType == acbp->AdapterInfo.PacketType))

		        // found !
		        return acbp;
	    }

	    lep = acbp->IndexHtLinkage.Flink;
	}
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\connreq.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    connreq.c

Abstract:

    This module contains the connection request handling functions

Author:

    Stefan Solomon  04/19/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


VOID
DoConnectInterface(PVOID	InterfaceIndex);

/*++

Function:   ForwarderNotification

Descr:	    This is invoked in the router manager worker thread context
	    following a notification from the forwarder. It dequeues all
	    connection requests and calls DDM for each one of them.

--*/

VOID
ForwarderNotification(VOID)
{
    DWORD   rc;
    PICB    icbp;
    HANDLE  hDIMInterface;
    ULONG   nBytes = 0;

    // Check if the signaled notification is valid or an error condition
    rc = FwGetNotificationResult(&ConnReqOverlapped, &nBytes);

    ACQUIRE_DATABASE_LOCK;
    if (RouterOperState == OPER_STATE_UP) {
        if(rc == NO_ERROR) {
            if (((icbp = GetInterfaceByIndex(ConnRequest->IfIndex)) != NULL)
                    && !icbp->ConnectionRequestPending) {
                IF_LOG (EVENTLOG_INFORMATION_TYPE) {
                    WCHAR   ByteCount[16];
                    LPWSTR  StrArray[2]= {icbp->InterfaceNamep, ByteCount};

                    _ultow (nBytes-FIELD_OFFSET (FW_DIAL_REQUEST, Packet),
                            ByteCount, 10);
                    RouterLogInformationDataW (RMEventLogHdl,
                                ROUTERLOG_IPX_DEMAND_DIAL_PACKET,
                                2, StrArray,
                                nBytes-FIELD_OFFSET (FW_DIAL_REQUEST, Packet),
                                &ConnRequest->Packet[0]);
                }

            	icbp->ConnectionRequestPending = TRUE;
                if(RtlQueueWorkItem(DoConnectInterface, (PVOID)ConnRequest, 0) == STATUS_SUCCESS) {

	                // work item queued
	                WorkItemsPendingCounter++;
                }
                else
                {
	                SS_ASSERT(FALSE);
                }
                ConnRequest = (PFW_DIAL_REQUEST)GlobalAlloc (GPTR, DIAL_REQUEST_BUFFER_SIZE);
                if (ConnRequest==NULL) {
                    rc = GetLastError ();
                    Trace(CONNREQ_TRACE, "Cannot allocate Connecttion Request buffer, rc = %d\n", rc);
                }
            }
        }
        else {
    	    Trace(CONNREQ_TRACE, "Error %d in FwGetNotificationResult\n", rc);
        }
            // now repost the IOCtl
        if (ConnRequest!=NULL) {
            rc = FwNotifyConnectionRequest(ConnRequest,
			              DIAL_REQUEST_BUFFER_SIZE,
			              &ConnReqOverlapped);

            if(rc != NO_ERROR) {
                GlobalFree (ConnRequest);
                ConnRequest = NULL;
	            Trace(CONNREQ_TRACE, "Cannot repost the FwNotifyConnecttionRequest, rc = %d\n", rc);
            }
        }
    }
    else {
        GlobalFree (ConnRequest);
    }
    RELEASE_DATABASE_LOCK;
    return;
}

VOID
DoConnectInterface(PVOID	param)
{
#define connRequest ((PFW_DIAL_REQUEST)param)
    PICB	icbp;
    HANDLE	hDIMInterface;
    DWORD	rc;


    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	goto Exit;
    }


    if ((icbp = GetInterfaceByIndex(connRequest->IfIndex)) == NULL){
    	goto Exit;
    }

    hDIMInterface = icbp->hDIMInterface;

    RELEASE_DATABASE_LOCK;


    rc = (*ConnectInterface)(hDIMInterface, PID_IPX);

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(connRequest->IfIndex)) == NULL) {

	    goto Exit;
	}

    if (rc != PENDING) {
    	icbp->ConnectionRequestPending = FALSE;

	// check if we failed right away
	if(rc != NO_ERROR) {

	    // failed to request connection
	    Trace(CONNREQ_TRACE, "DoConnectInterface: ConnectInterface failed with rc= 0x%x for if # %d\n",
				rc, connRequest->IfIndex);

	    FwConnectionRequestFailed(connRequest->IfIndex);
	}
	else
	{
	    // Connection request has been succesfull right away and
	    // we will get notified via the connected adapter
	    Trace(CONNREQ_TRACE, "DoConnectInterface: ConnectInterface successful -> CONNECTED for if # %d\n",
				 connRequest->IfIndex);
	}
    }
    else
    {
	// a connection request is pending

	Trace(CONNREQ_TRACE, "DoConnectInterface: Connection request PENDING for if # %d\n",
			      connRequest->IfIndex);

    }

Exit:
    GlobalFree (connRequest);
    WorkItemsPendingCounter--;

    RELEASE_DATABASE_LOCK;
#undef connRequest
}

DWORD
RoutingProtocolConnectionRequest(ULONG	    ProtocolId,
				 ULONG	    InterfaceIndex)
{
    PICB	    icbp;
    HANDLE	    hDIMInterface;
    DWORD	    rc;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;

	return ERROR_CAN_NOT_COMPLETE;
    }

    if (icbp->ConnectionRequestPending) {
	RELEASE_DATABASE_LOCK;

	return PENDING;
    }

    // ask DDM to make a connection for this interface
    hDIMInterface = icbp->hDIMInterface;
   	icbp->ConnectionRequestPending = TRUE;

    RELEASE_DATABASE_LOCK;

    rc = (*ConnectInterface)(hDIMInterface, PID_IPX);
    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(InterfaceIndex)) == NULL) {
	RELEASE_DATABASE_LOCK;

	return ERROR_CAN_NOT_COMPLETE;
    }

    if (rc != PENDING)
    	icbp->ConnectionRequestPending = FALSE;
	RELEASE_DATABASE_LOCK;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\globals.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Contains all(most) router manager globals

Author:

    Stefan Solomon  03/21/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//*****************************************************************
//								  *
//	       ROUTER CONFIGURATION PARAMETERS			  *
//								  *
//*****************************************************************

// Size of the routing table and routing hash table

ULONG		MaxRoutingTableSize = IPX_MAX_ROUTING_TABLE_SIZE;
ULONG		RoutingTableHashSize = IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE;

//*****************************************************************
//								  *
//		      Internal Variables			  *
//								  *
//*****************************************************************

// Routing Protocols Oper State
ULONG	    RipOperState = OPER_STATE_DOWN;
ULONG	    SapOperState = OPER_STATE_DOWN;

// Pointer to the internal interface

PICB	InternalInterfacep = NULL;

// Pointer to the internal adapter

PACB	InternalAdapterp = NULL;

// The RouterWorker thread events: adapter, forwarder, autostatic update, stop
// and timer notifications

HANDLE	g_hEvents[MAX_EVENTS];

// signatures

// Interface Control Block Signature

UCHAR	InterfaceSignature[4] = { 'I', 'P', 'X', 'I' };

// Adapter Control Block Signature

UCHAR	AdapterSignature[4] = { 'I', 'P', 'X', 'A' };

// Router Operational State

ULONG	RouterOperState = OPER_STATE_DOWN;

//
//  Router Database Lock
//

CRITICAL_SECTION	DatabaseLock;

//
// RTM Handle
//

HANDLE	    RtmStaticHandle = NULL;
HANDLE	    RtmLocalHandle = NULL;

//
// Hash Table of ICBs hashed by interface index
//

LIST_ENTRY     IndexIfHt[IF_HASH_TABLE_SIZE];

//
// List of intefaces ordered by interface index
//

LIST_ENTRY     IndexIfList;

//
// Global WAN net
//

BOOL		WanNetDatabaseInitialized = FALSE;

BOOL		EnableGlobalWanNet = FALSE;

UCHAR		GlobalWanNet[4] = {0,0,0,0};

//
// Hash Table of ACBs hashed by adapter index
//

LIST_ENTRY     IndexAdptHt[ADAPTER_HASH_TABLE_SIZE];

//
// MIB APIs Ref Counter
//

ULONG	    MibRefCounter = 0;

// null net
UCHAR	    nullnet[4] = {0,0,0,0};

//
// List of routing protocols control blocks and counter
//

LIST_ENTRY	RoutingProtocolCBList;
ULONG		RoutingProtocolActiveCount = 0;

// Indicates the mode of the router (lan only) or lan & wan

BOOL		LanOnlyMode = TRUE;

// Variable to get the interface index requesting connection

PFW_DIAL_REQUEST	ConnRequest;

OVERLAPPED	        ConnReqOverlapped;

// Variable to count the number of pending work items

ULONG		WorkItemsPendingCounter = 0;

//
// ************ 	DDM ENTRY POINTS	********
//

DWORD
(APIENTRY *ConnectInterface)(IN HANDLE		hDIMInterface,
			    IN DWORD		ProtocolId);

DWORD
(APIENTRY *DisconnectInterface)(IN HANDLE	hDIMInterface,
			       IN DWORD		ProtocolId);


    //
    // This call will make DIM store the interface information into the 
    // Site Object for this interface.
    // Either but not both of pInterfaceInfo and pFilterInfo may be NULL
    //


DWORD
(APIENTRY *SaveInterfaceInfo)(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          pInterfaceInfo,
		IN	DWORD		cbInterfaceInfoSize);

    //
    // This will make DIM get interface information from the Site object. 
    // Either but not both of pInterfaceInfo and pFilterInfo may be NULL
    //


DWORD
(APIENTRY *RestoreInterfaceInfo)(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          lpInterfaceInfo,
		IN	LPDWORD 	lpcbInterfaceInfoSize);

VOID
(APIENTRY *RouterStopped)(
                IN      DWORD           dwProtocolId,
                IN      DWORD           dwError  ); 
VOID
(APIENTRY *InterfaceEnabled)(
            IN      HANDLE          hDIMInterface, 
            IN      DWORD           dwProtocolId,
            IN      BOOL            fEnabled  ); 
//
// ***********	    IPXCP ENTRY POINTS		********
//


DWORD	(*IpxcpBind)(PIPXCP_INTERFACE	    IpxcpInterface);

VOID	(*IpxcpRouterStarted)(VOID);

VOID	(*IpxcpRouterStopped)(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\ifdbase.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ifdbase.c

Abstract:

    Functions to manipulate the interfaces database

Author:

    Stefan Solomon  04/10/1995

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define     ifhashindex(IfIndex)    (IfIndex) % IF_HASH_TABLE_SIZE

// THESE FUNCTIONS ASSUME THE ROUTER MANAGER IS IN CRITICAL SECTION WHEN CALLED

//***
//
// Function:	InitIfDB
//
// Descr:
//
//***

VOID
InitIfDB(VOID)
{
    int 	    i;
    PLIST_ENTRY     IfHtBucketp;

    IfHtBucketp = IndexIfHt;

    for(i=0; i<IF_HASH_TABLE_SIZE; i++, IfHtBucketp++) {

	InitializeListHead(IfHtBucketp);
    }

    InitializeListHead(&IndexIfList);
}


//***
//
// Function:	AddIfToDB
//
// Descr:	Inserts a new interface in the Data Base
//		The new if is inserted in the hash table of interface indices
//		and the linked list of interfaces ordered by index
//
//***

VOID
AddIfToDB(PICB	    icbp)
{
    int 	    hv;
    PLIST_ENTRY     lep;
    PICB	    list_icbp;

    // insert in index hash table
    hv = ifhashindex(icbp->InterfaceIndex);
    InsertTailList(&IndexIfHt[hv], &icbp->IndexHtLinkage);

    // insert in the list ordered by index
    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	list_icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);
	if (list_icbp->InterfaceIndex > icbp->InterfaceIndex) {

	    InsertTailList(lep, &icbp->IndexListLinkage);
	    return;
	}

	lep = list_icbp->IndexListLinkage.Flink;
    }

    InsertTailList(lep, &icbp->IndexListLinkage);
}


//***
//
// Function:	RemoveIfFromDB
//
// Descr:	Removes an interface from the interface data base
//
//***

VOID
RemoveIfFromDB(PICB	    icbp)
{
    RemoveEntryList(&icbp->IndexHtLinkage);
    RemoveEntryList(&icbp->IndexListLinkage);
}

PICB
GetInterfaceByIndex(ULONG	IfIndex)
{
    PICB	    icbp;
    PLIST_ENTRY     lep;
    int 	    hv;

    hv = ifhashindex(IfIndex);

    lep = IndexIfHt[hv].Flink;

    while(lep != &IndexIfHt[hv])
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexHtLinkage);
	if (icbp->InterfaceIndex == IfIndex) {

	    return icbp;
	}

	lep = icbp->IndexHtLinkage.Flink;
    }

    return NULL;
}

PICB
GetInterfaceByName(LPWSTR	    IfName)
{
    PICB	    icbp;
    PLIST_ENTRY     lep;

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);

	if(!_wcsicmp(IfName, icbp->InterfaceNamep)) {

	    // found !
	    return icbp;
	}

	lep = icbp->IndexListLinkage.Flink;
    }

    return NULL;
}

/*++

Function:	GetInterfaceByAdapterName

Descr:		scans the list of interfaces looking for the adapter name
		on dedicated interfaces

--*/

PICB
GetInterfaceByAdapterName(LPWSTR	    AdapterName)
{
    PICB	    icbp;
    PLIST_ENTRY     lep;

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);

	if(icbp->MIBInterfaceType == IF_TYPE_LAN) {

	    if(!_wcsicmp(AdapterName, icbp->AdapterNamep)) {

		// found !
		return icbp;
	    }
	}

	lep = icbp->IndexListLinkage.Flink;
    }

    return NULL;
}

/*++

Function:	GetInterfaceByAdptNameAndPktType

Descr:	Iterates through all interfaces looking for one that matches the 
        given packet type and name.

[pmay]  I added this because some interface bindings weren't taking place
        during pnp because there would be multiple interfaces with the same
        adapter name whose binding depended on the packet type.
--*/

PICB
GetInterfaceByAdptNameAndPktType(LPWSTR AdapterName, DWORD dwType)
{
    PICB icbp;
    PLIST_ENTRY lep;

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList) {
    	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);
    	if(icbp->MIBInterfaceType == IF_TYPE_LAN) {
    	    if((_wcsicmp(AdapterName, icbp->AdapterNamep) == 0) &&
    	       ((icbp->PacketType == AUTO_DETECT_PACKET_TYPE) || (icbp->PacketType == dwType)))
    	    {
        		return icbp;
    	    }
    	}

    	lep = icbp->IndexListLinkage.Flink;
    }

    return NULL;
}

/*++

Function:   EnumerateFirstInterfaceIndex

Descr:	    returns the first interface index, if any

Note:	    called with database lock held

--*/

DWORD
EnumerateFirstInterfaceIndex(PULONG InterfaceIndexp)
{
    PICB	icbp;

    if(!IsListEmpty(&IndexIfList)) {

	icbp = CONTAINING_RECORD(IndexIfList.Flink, ICB, IndexListLinkage);
	*InterfaceIndexp = icbp->InterfaceIndex;

	return NO_ERROR;
    }
    else
    {
	return ERROR_NO_MORE_ITEMS;
    }
}

/*++

Function:   EnumerateNextInterfaceIndex

Descr:	    returns next if index in the database

Descr:	    called with database lock held

--*/

DWORD
EnumerateNextInterfaceIndex(PULONG InterfaceIndexp)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;

    // scan the index if list until we find the next if index

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);
	if (icbp->InterfaceIndex > *InterfaceIndexp) {

	    *InterfaceIndexp = icbp->InterfaceIndex;
	    return NO_ERROR;
	}

	lep = lep->Flink;
    }

    return ERROR_NO_MORE_ITEMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\adptmgr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    adptmgr.c

Abstract:

    This module contains the adapter management functions

Author:

    Stefan Solomon  03/07/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//
// Adapter Manager Globals
//


HANDLE	    AdapterConfigPortHandle;
HANDLE	    AdapterNotificationThreadHandle;

//  Counter of created adapters
ULONG	    AdaptersCount = 0;

PICB
GetInterfaceByAdptNameAndPktType(LPWSTR AdapterName, DWORD dwType);

DWORD 
PnpAdapterConfigHandler(ADAPTER_INFO * pAdapterInfo,
                        ULONG AdapterIndex,
                        ULONG AdapterConfigurationStatus);

DWORD 
ReConfigureAdapter(IN DWORD dwAdapterIndex, 
                   IN PWSTR pszAdapterName, 
                   IN PADAPTER_INFO pAdapter);
                            
VOID
CreateAdapter(ULONG		AdapterIndex,
	      PWSTR		AdapterNamep,
	      PADAPTER_INFO	adptip);

VOID
DeleteAdapter(ULONG	AdapterIndex);

VOID
AdapterUp(ULONG 	AdapterIndex);

VOID
AdapterDown(ULONG	AdapterIndex);

/*++

Function:	StartAdapterManager

Descr:		opens the IPX stack notification port

--*/

DWORD
StartAdapterManager(VOID)
{
    ADAPTERS_GLOBAL_PARAMETERS		AdptGlobalParameters;
    DWORD				threadid;

    Trace(ADAPTER_TRACE, "StartAdapterManager: Entered\n");

    // create adapter config port
    if((AdapterConfigPortHandle = IpxCreateAdapterConfigurationPort(
	    g_hEvents[ADAPTER_NOTIFICATION_EVENT],
	    &AdptGlobalParameters)) == INVALID_HANDLE_VALUE) {

	// can't create config port
	return (1);
    }

    return (0);
}

/*++

Function:	StopAdapterManager

Descr:		Closes the IPX notification port

--*/

VOID
StopAdapterManager(VOID)
{
    DWORD	    rc;
    ULONG	    AdapterIndex;

    Trace(ADAPTER_TRACE, "StopAdapterManager: Entered\n");

    // Close the IPX stack notification port
    IpxDeleteAdapterConfigurationPort(AdapterConfigPortHandle);
}
// Debugging functions
char * DbgTypeToString(DWORD dwType) {
    switch (dwType) {
	    case MISN_FRAME_TYPE_ETHERNET_II:
            return "EthII";
	    case MISN_FRAME_TYPE_802_3:
            return "802.3";
	    case MISN_FRAME_TYPE_802_2:
            return "802.2";
	    case MISN_FRAME_TYPE_SNAP:
            return "SNAP";
	    case MISN_FRAME_TYPE_ARCNET:
            return "Arcnet";
	    case ISN_FRAME_TYPE_AUTO:
            return "Autodetect";
    }

    return "Unknown";
}

// Helper debug function traces out information about a given interface
VOID DbgTraceAdapterInfo(IN PADAPTER_INFO pAdapter, DWORD dwIndex, LPSTR pszTitle) {
    Trace(ADAPTER_TRACE, "%s: Ind=%d IfInd=%d Net=%x Lcl=%x Rmt=%x Spd=%d Type=%d", 
                         pszTitle,
                         dwIndex,
                         pAdapter->InterfaceIndex,
                         *((LONG*)(pAdapter->Network)), 
                         *((LONG*)(pAdapter->LocalNode)),
                         *((LONG*)(pAdapter->RemoteNode)),
                         pAdapter->LinkSpeed,
                         pAdapter->NdisMedium);
}

// Outputs the current status of an adapter to the trace window
VOID DbgTraceAdapter(PACB acbp) {
    Trace(ADAPTER_TRACE, "[%d]  Interface: %d, Network: %x, Type: %s", 
                         acbp->AdapterIndex,
                         (acbp->icbp) ? acbp->icbp->InterfaceIndex : -1,
                         *((LONG*)(acbp->AdapterInfo.Network)),
                         DbgTypeToString(acbp->AdapterInfo.PacketType));
}


// Outputs the current list of adapters to the trace window
VOID DbgTraceAdapterList() {
    PLIST_ENTRY lep;
    DWORD i;
    PACB	    acbp;

    ACQUIRE_DATABASE_LOCK;

	Trace(ADAPTER_TRACE, "List of current adapters:");
	Trace(ADAPTER_TRACE, "=========================");
    // Loop through the adapter hash table, printing as we go
    for (i = 0; i < ADAPTER_HASH_TABLE_SIZE; i++) {
        lep = IndexAdptHt[i].Flink;
        while(lep != &IndexAdptHt[i]) {
    	    acbp = CONTAINING_RECORD(lep, ACB, IndexHtLinkage);
    	    DbgTraceAdapter(acbp);
    	    lep = acbp->IndexHtLinkage.Flink;
    	}
    }
    Trace(ADAPTER_TRACE, "\n");

	RELEASE_DATABASE_LOCK;
}

/*++

Function:	    AdapterNotification

Descr:		    Processes adapter notification events

--*/

VOID
AdapterNotification(VOID)
{
    ADAPTER_INFO    AdapterInfo;
    ULONG	    AdapterIndex;
    ULONG	    AdapterConfigurationStatus;
    DWORD	    rc;

    Trace(ADAPTER_TRACE, "AdapterNotification: Entered");

    // Adaptif manages the adapter information.  Get the next piece of
    // information that adptif has queued for us.
    while((rc = IpxGetQueuedAdapterConfigurationStatus(
					AdapterConfigPortHandle,
					&AdapterIndex,
					&AdapterConfigurationStatus,
					&AdapterInfo)) == NO_ERROR) 
    {
	    switch(AdapterConfigurationStatus) {
            // An adapter is being created.  This is happening either
            // because we are receiving the list of current adapters 
            // at initialization time or as a result of a PnP event.
            // Either way, the smarts to deal with the situation are built
            // into our PnP handler.  
            // 
            // This message is also sent when an existing adapter is 
            // being configured.
	        case ADAPTER_CREATED:
                PnpAdapterConfigHandler(&AdapterInfo,
                                         AdapterIndex,
                                         AdapterConfigurationStatus);
		        break;
            // Handle an adapter being deleted -- this can happen as a result of
            // pcmcia removing the adapter or as a result of a binding change
            // or a wan link removal.
	        case ADAPTER_DELETED:
		        DeleteAdapter(AdapterIndex);
		        break;
            // A wan line came up.
	        case ADAPTER_UP:
		        AdapterUp(AdapterIndex);
		        break;
            // A wan line went down
	        case ADAPTER_DOWN:
		        AdapterDown(AdapterIndex);
		        break;

            // Some internal error has occured.
	        default:
		        SS_ASSERT(FALSE);
		        break;
	     }
    }
    DbgTraceAdapterList();
}

// Handles adapter creation and configuration notifications.
DWORD PnpAdapterConfigHandler(ADAPTER_INFO * pAdapterInfo,
                              ULONG AdapterIndex,
                              ULONG AdapterConfigurationStatus) 
{
    ULONG AdapterNameSize;
    LPWSTR AdapterNameBuffer;
    DWORD dwErr;

    Trace(ADAPTER_TRACE, "PnpAdapterConfigHandler: Entered for adpt #%d", AdapterIndex);

    // If this is the internal adapter, we don't need an adapter name
    if (AdapterIndex == 0)
        AdapterNameBuffer = L"";

    // Otherwise, get the adapter name from the stack
    else {
        AdapterNameSize = wcslen(pAdapterInfo->pszAdpName) * sizeof (WCHAR) + sizeof(WCHAR);

        //Allocate the memory to hold the name of the adapter
		if((AdapterNameBuffer = GlobalAlloc(GPTR, AdapterNameSize)) == NULL)
			return ERROR_NOT_ENOUGH_MEMORY;

		wcscpy(AdapterNameBuffer, pAdapterInfo->pszAdpName);
	}

    // Either create or configure the adapter depending on whether
    // it has already exists in the adapter database.
    ACQUIRE_DATABASE_LOCK;
    
    if(GetAdapterByIndex(AdapterIndex))
        ReConfigureAdapter(AdapterIndex, AdapterNameBuffer, pAdapterInfo);
    else 
        CreateAdapter(AdapterIndex, AdapterNameBuffer, pAdapterInfo);
        
	RELEASE_DATABASE_LOCK;

    // Cleanup
    if (AdapterIndex != 0)
   		GlobalFree(AdapterNameBuffer);

    return NO_ERROR;
}

// Attempt to bind an unbound adapter
DWORD AttemptAdapterBinding (PACB acbp) {
    PICB icbp;

    // Make sure we aren't already bound
    if (acbp->icbp)
        return NO_ERROR;
    
    if(acbp->AdapterInfo.NdisMedium != NdisMediumWan) {
	    // this is a DEDICATED (e.g	LAN) adapter. If an interface already exists for it,
	    // bind it to its interface and notify the other modules
	    if(acbp->AdapterIndex != 0) {
	        icbp = GetInterfaceByAdptNameAndPktType(acbp->AdapterNamep, 
	                                                acbp->AdapterInfo.PacketType);
	        if (icbp)
		        BindInterfaceToAdapter(icbp, acbp);
	    }
	    else {
	        // This is the internal adapter
	        InternalAdapterp = acbp;

            // If the internal network number was set to zero (nullnet), then
            // we have a configuration problem -- don't barf on this, just log
            // the fact.
	        if(!memcmp(acbp->AdapterInfo.Network, nullnet, 4)) {
                IF_LOG (EVENTLOG_ERROR_TYPE) {
                    RouterLogErrorDataA (RMEventLogHdl, 
                        ROUTERLOG_IPX_NO_VIRTUAL_NET_NUMBER,
                        0, NULL, 0, NULL);
                }
		        Trace(ADAPTER_TRACE, "CreateAdapter: Internal net number is not configured !");
		        // [pmay] now when we get a bad internal net number, we re-configure.
		        // SS_ASSERT(FALSE);
		        PnpAutoSelectInternalNetNumber(ADAPTER_TRACE);
	        }

	        // if the internal interface already exists, bind to it
	        if(icbp = InternalInterfacep) {
    		    BindInterfaceToAdapter(icbp, acbp);
	        }
	    }
    }
    else {
	    // this is a connected WAN adapter
	    SS_ASSERT(acbp->icbp == NULL);

	    // bind to corresponding interface
	    if(icbp = GetInterfaceByIndex(acbp->AdapterInfo.InterfaceIndex)) {
	        // bind all interfaces to this adapter
	        BindInterfaceToAdapter(icbp, acbp);
	    }
    }

    return NO_ERROR;
}

// Resets the configuration of the given adapter.  This function assumes that
// the database is locked and that the given adapter index references an
// adapter in the database.  Furthermore this function assumes that it does
// not need to release its lock on the database.
DWORD ReConfigureAdapter(IN DWORD dwAdapterIndex, 
                         IN PWSTR pszAdapterName, 
                         IN PADAPTER_INFO pAdapter)
{
    PACB	acbp;
    PICB	icbp;

    Trace(
        ADAPTER_TRACE, 
        "ReConfigureAdapter: Entered for %d: %S: %x, %d", 
        dwAdapterIndex, 
        pszAdapterName, 
        *((DWORD*)(pAdapter->Network)),
        pAdapter->InterfaceIndex
        );

    // If the adapter being configured is the internal adapter and if it is to be
    // re-configured to a zero net number, that is to be a signal to automatically
    // assign a new network number.
    if ((dwAdapterIndex == 0) && (*((DWORD*)pAdapter->Network) == 0)) {
        DWORD dwErr;
        
        Trace(ADAPTER_TRACE, "ReConfigureAdapter: Internal Net = 0, selecting new number");
        if ((dwErr = PnpAutoSelectInternalNetNumber(ADAPTER_TRACE)) != NO_ERROR) 
            Trace(ADAPTER_TRACE, "ReConfigureAdapter: Auto-select of new net number FAILED!");
        return dwErr;
    }

    // Get a reference to the adapter and the interface
    if (dwAdapterIndex == 0)
        acbp = InternalAdapterp;
    else
        acbp = GetAdapterByIndex(dwAdapterIndex);
        
    if (!acbp) {
        Trace(ADAPTER_TRACE, "ReConfigureAdapter: Invalid adapter %d!", dwAdapterIndex);
        return ERROR_CAN_NOT_COMPLETE;
    }
    icbp = acbp->icbp;

    // If this adapter isn't bound yet, update it and then
    // try to bind it.
    if (!icbp) {
        acbp->AdapterInfo = *pAdapter;
        AttemptAdapterBinding (acbp);
    }        

    // Otherwise, unbind and then re-bind the adapter
    else {
        // Unbind the interface from the adapter
        UnbindInterfaceFromAdapter(icbp);

        // Update the information
        acbp->AdapterInfo = *pAdapter;

        // Rebind the interface to the adapter
        AttemptAdapterBinding(acbp);
    }

    return NO_ERROR;
}

/*++

Function:	CreateAdapter

Descr:		creates the adapter control block

Modification:
            [pmay] Assume the database lock is aquired before this function enters
                   and that the given adapter index has not already been added
                   to the adapter database.
--*/
VOID
CreateAdapter(ULONG	AdapterIndex,
	          PWSTR	AdapterNamep,
	          PADAPTER_INFO	adptip)
{
    PACB	acbp;
    PICB	icbp;
    ULONG	namelen;
    PUCHAR  ln = adptip->LocalNode;

    Trace(
        ADAPTER_TRACE, 
        "CreateAdapter: Entered for %d (%x%x%x%x%x%x)(%S), %d", 
        AdapterIndex, 
        ln[0], ln[1], ln[2], ln[3], ln[4], ln[5], 
        AdapterNamep, 
        adptip->InterfaceIndex);
    
	// adapter name len including the unicode null
	namelen = (wcslen(AdapterNamep) + 1) * sizeof(WCHAR);

    // new adapter, try to get an ACB
    if((acbp = GlobalAlloc(GPTR, sizeof(ACB) + namelen)) == NULL) {
        Trace(ADAPTER_TRACE, "CreateAdapter: RETURNING BECAUSE INSUFFICIENT MEMORY TO ALLOCATE ADAPTER");
        // [pmay] PnP handler takes care of aquiring and releasing the database lock.
	    // RELEASE_DATABASE_LOCK;       
	    SS_ASSERT(FALSE);
	    return;
    }

    // make the ACB
    acbp->AdapterIndex = AdapterIndex;
    AddToAdapterHt(acbp);
    memcpy(acbp->Signature, AdapterSignature, 4);

    // We haven't bound to any interface at this point
    acbp->icbp = NULL;

    // Store the adapter information pertinent to this adapter
    acbp->AdapterInfo = *adptip;

    // Copy of the adapter name
    acbp->AdapterNamep = (LPWSTR)((PUCHAR)acbp + sizeof(ACB));
	wcscpy(acbp->AdapterNamep, AdapterNamep);
	acbp->AdapterNameLen = namelen - 1; // without the unicode null

	// Attempt to bind the adapter
	AttemptAdapterBinding (acbp);

    AdaptersCount++;

    if(acbp->AdapterInfo.NdisMedium != NdisMediumWan) {
	    if(acbp->AdapterIndex == 0) {
	        Trace(ADAPTER_TRACE, "CreateAdapter: Created INTERNAL adapter index 0");
	    }
	    else {
	        Trace(ADAPTER_TRACE, "CreateAdapter: Created LAN adapter # %d name %S",
			       acbp->AdapterIndex,
			       acbp->AdapterNamep);
	    }
    }
    else {
	    Trace(ADAPTER_TRACE, "CreateAdapter: created WAN adapter # %d", acbp->AdapterIndex);
    }

    // [pmay] PnP handler takes care of aquiring and releasing the database lock.
    // RELEASE_DATABASE_LOCK;
}

/*++

Function:	DeleteAdapter
Descr:

--*/

VOID
DeleteAdapter(ULONG	AdapterIndex)
{
    PACB	acbp, acbp2;
    PICB    icbp;
    WCHAR   pszAdapterName[MAX_ADAPTER_NAME_LEN];

    Trace(ADAPTER_TRACE, "DeleteAdapter: Entered for adapter # %d", AdapterIndex);

    ACQUIRE_DATABASE_LOCK;

    // Get the adapter
    if((acbp = GetAdapterByIndex(AdapterIndex)) == NULL) {
    	RELEASE_DATABASE_LOCK;
    	Trace(ADAPTER_TRACE, "DeleteAdapter: Ignored. There is no adapter # %d to be deleted !\n", AdapterIndex);
    	return;
    }

    // 1. if the adapter is bound to an interface -> unbind it.  Also, save the adapter name.
    if((icbp = acbp->icbp) != NULL) {
    	wcscpy(pszAdapterName, acbp->AdapterNamep);
    	UnbindInterfaceFromAdapter(acbp->icbp);
    }

    // Remove the adapter from the database
    RemoveFromAdapterHt(acbp);
    AdaptersCount--;

    // [pmay]
    // Since pnp can cause adapters to be added and removed from the database 
    // in unpredictable orders, see if there is already another adapter in the 
    // database with which the bound interface can immediately re-bind.
    if (icbp) {
        if((acbp2 = GetAdapterByNameAndPktType (pszAdapterName, icbp->PacketType)) != NULL)
            BindInterfaceToAdapter(icbp, acbp2);
    }

    RELEASE_DATABASE_LOCK;

    Trace(ADAPTER_TRACE, "DeleteAdapter: deleted adapter # %d", acbp->AdapterIndex);
    GlobalFree(acbp);

    return;
}

/*++

Function:	AdapterDown

Descr:		Called if the LAN adapter isn't functional.
		It calls back into the SNMP Agent with a trap - AdapterDown

--*/

VOID
AdapterDown(ULONG	AdapterIndex)
{
    // Call AdapterDownTrap
}

/*++

Function:	AdapterUp

Descr:		Called if the LAN adapter isn't functional.
		It calls back into the SNMP Agent with a trap - AdapterUP

--*/

VOID
AdapterUp(ULONG	AdapterIndex)
{
    // Call AdapterUpTrap
}

VOID
DestroyAllAdapters(VOID)
{
    PLIST_ENTRY     IfHtBucketp, lep;
    PACB	    acbp;
    ULONG	    AdapterIndex;
    int 	    i;

    for(i=0, IfHtBucketp = IndexAdptHt;	i<ADAPTER_HASH_TABLE_SIZE;	i++, IfHtBucketp++) {
    	if (!IsListEmpty(IfHtBucketp)) {
    	    acbp = CONTAINING_RECORD(IfHtBucketp->Flink, ACB, IndexHtLinkage);
    	    RemoveFromAdapterHt(acbp);
    	    AdaptersCount--;
    	    Trace(ADAPTER_TRACE, "DestroyAllAdapters: destroyed adapter # %d\n", acbp->AdapterIndex);
    	    GlobalFree(acbp);
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\ipxcpif.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Some router initialization functions

Author:

    Stefan Solomon  05/10/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//*******************************************************************
//*								    *
//*		IPXCP  Interface Functions			    *
//*								    *
//*******************************************************************


#define IPXCP_INITIALIZE_ENTRY_POINT "IpxCpInit"
#define IPXCP_CLEANUP_ENTRY_POINT IPXCP_INITIALIZE_ENTRY_POINT

typedef DWORD (* IpxcpInitFunPtr)(BOOL);
typedef DWORD (* IpxcpCleanupFunPtr)(BOOL);


// Initializes IpxCp so that it can be used.  Assumes the IpxCp
DWORD InitializeIpxCp (HINSTANCE hInstDll) {
    IpxcpInitFunPtr pfnInit;
    DWORD dwErr;

    pfnInit = (IpxcpInitFunPtr)GetProcAddress(hInstDll, IPXCP_INITIALIZE_ENTRY_POINT);
    if (!pfnInit)
        return ERROR_CAN_NOT_COMPLETE;

    if ((dwErr = (*pfnInit)(TRUE)) != NO_ERROR)
        return dwErr;
    
    return NO_ERROR;
}

// Cleansup the initialization of ipxcp that occurred when the 
// program loaded.
DWORD CleanupIpxCp (HINSTANCE hInstDll) {
    IpxcpCleanupFunPtr pfnCleanup;
    DWORD dwErr;

    pfnCleanup = (IpxcpCleanupFunPtr)GetProcAddress(hInstDll, IPXCP_CLEANUP_ENTRY_POINT);
    if (!pfnCleanup)
        return ERROR_CAN_NOT_COMPLETE;

    if ((dwErr = (*pfnCleanup)(FALSE)) != NO_ERROR)
        return dwErr;
    
    return NO_ERROR;
}

/*++

Function:	RmCreateGlobalRoute

Descr:		called by ipxcp to create the global wan net if so configured

--*/

DWORD
RmCreateGlobalRoute(PUCHAR	    Network)
{
    DWORD	rc;

    Trace(IPXCPIF_TRACE, "RmCreateGlobalRoute: Entered for 0x%x%x%x%x%x%x (%x)", 
           Network[0], Network[1], Network[2], Network[3], Network[4], Network[5], 
           WanNetDatabaseInitialized);

    ACQUIRE_DATABASE_LOCK;

    if((RouterOperState != OPER_STATE_UP) || LanOnlyMode) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    // In NT5 we allow changing the global route on the 
    // fly although it will only happen when there are
    // no WAN connections active.
    //
    // SS_ASSERT(WanNetDatabaseInitialized == FALSE);
    //
    if (WanNetDatabaseInitialized == TRUE) {
        DeleteGlobalRoute(GlobalWanNet);
    }

    WanNetDatabaseInitialized = TRUE;

    if((rc = CreateGlobalRoute(Network)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    EnableGlobalWanNet = TRUE;
    memcpy(GlobalWanNet, Network, 4);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}


/*++

Function:	AllLocalWkstaDialoutInterface

Descr:		called by ipxcp to add an interface for the case when the
		host dials out. This interface type is not handled by DIM

--*/


DWORD
RmAddLocalWkstaDialoutInterface(
	    IN	    LPWSTR		    InterfaceNamep,
	    IN	    LPVOID		    InterfaceInfop,
	    IN OUT  PULONG		    InterfaceIndexp)
{
    PICB			icbp;
    ULONG			InterfaceNameLen; // if name length in bytes including wchar NULL
    PIPX_IF_INFO		IpxIfInfop;
    PIPXWAN_IF_INFO		IpxwanIfInfop;
    PIPX_INFO_BLOCK_HEADER	IfInfop = (PIPX_INFO_BLOCK_HEADER)InterfaceInfop;
    PACB			acbp;
    PIPX_TOC_ENTRY		tocep;
    UINT			i;
    ULONG			tmp;
    FW_IF_INFO			FwIfInfo;

    Trace(IPXCPIF_TRACE, "AddLocalWkstaDialoutInterface: Entered for interface %S\n", InterfaceNamep);

    // interface name length including the unicode null
    InterfaceNameLen = (wcslen(InterfaceNamep) + 1) * sizeof(WCHAR);

    ACQUIRE_DATABASE_LOCK;

    if((RouterOperState != OPER_STATE_UP) || LanOnlyMode) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    // Allocate a new ICB and initialize it
    // we allocate the interface and adapter name buffers at the end of the
    // ICB struct.
    if((icbp = (PICB)GlobalAlloc(GPTR,
				 sizeof(ICB) +
				 InterfaceNameLen)) == NULL) {

	RELEASE_DATABASE_LOCK;

	// can't alloc memory
	SS_ASSERT(FALSE);

	return ERROR_NOT_ENOUGH_MEMORY;
    }

    // signature
    memcpy(&icbp->Signature, InterfaceSignature, 4);

    icbp->InterfaceIndex = GetNextInterfaceIndex();

    // copy the interface name
    icbp->InterfaceNamep = (PWSTR)((PUCHAR)icbp + sizeof(ICB));
    memcpy(icbp->InterfaceNamep, InterfaceNamep, InterfaceNameLen);

    icbp->AdapterNamep = NULL;
    icbp->PacketType = 0;

    // set the DIM interface type of this ICB
    icbp->DIMInterfaceType = 0xFFFFFFFF;

    // set the MIB interface type of this ICB
    icbp->MIBInterfaceType = IF_TYPE_ROUTER_WORKSTATION_DIALOUT;

    // mark the interface as unbound to an adapter (default)
    icbp->acbp = NULL;

    // get the if handle used when calling DIM entry points
    icbp->hDIMInterface = INVALID_HANDLE_VALUE;

    // reset the update status fields
    ResetUpdateRequest(icbp);

    // mark connection not requested yet
    icbp->ConnectionRequestPending = FALSE;

    // get to the interface entries in the interface info block
    if(((IpxIfInfop = (PIPX_IF_INFO)GetInfoEntry(InterfaceInfop, IPX_INTERFACE_INFO_TYPE)) == NULL) ||
       ((IpxwanIfInfop = (PIPXWAN_IF_INFO)GetInfoEntry(InterfaceInfop, IPXWAN_INTERFACE_INFO_TYPE)) == NULL)) {

	GlobalFree(icbp);

	RELEASE_DATABASE_LOCK;

    IF_LOG (EVENTLOG_ERROR_TYPE) {
        RouterLogErrorDataW (RMEventLogHdl, 
            ROUTERLOG_IPX_BAD_CLIENT_INTERFACE_CONFIG,
            0, NULL, 0, NULL);
    }
	// don't have all ipx or ipxwan interfaces info
	Trace(IPXCPIF_TRACE, "AddInterface: missing ipx or ipxwan interface info\n");

	SS_ASSERT(FALSE);

	return ERROR_INVALID_PARAMETER;
    }

    // set the IPXWAN interface info
    icbp->EnableIpxWanNegotiation = IpxwanIfInfop->AdminState;

    // Initialize the Oper State of this interface.
    icbp->OperState = OPER_STATE_DOWN;

    // this is a WAN interface. As long as it isn't connected, and enabled the
    // oper state will be sleeping on this interface
    if(IpxIfInfop->AdminState == ADMIN_STATE_ENABLED)
	    icbp->OperState = OPER_STATE_SLEEPING;

    // create the routing protocols (rip/sap or nlsp) interface info
    // insert the if in the index hash table
    AddIfToDB(icbp);

    // If the routing protocols interface info is missing this will fail
    if(CreateRoutingProtocolsInterfaces(InterfaceInfop, icbp) != NO_ERROR) {

	RemoveIfFromDB(icbp);
	GlobalFree(icbp);

	RELEASE_DATABASE_LOCK;

    IF_LOG (EVENTLOG_ERROR_TYPE) {
        RouterLogErrorDataW (RMEventLogHdl, 
            ROUTERLOG_IPX_BAD_CLIENT_INTERFACE_CONFIG,
            0, NULL, 0, NULL);
    }
	// don't have all rip and sap interfaces info
	Trace(IPXCPIF_TRACE, "AddInterface: missing routing protocols interface info\n");

	SS_ASSERT(FALSE);

	return ERROR_INVALID_PARAMETER;
    }

    // create the Forwarder interface
    FwIfInfo.NetbiosAccept = IpxIfInfop->NetbiosAccept;
    FwIfInfo.NetbiosDeliver = IpxIfInfop->NetbiosDeliver;
    FwCreateInterface(icbp->InterfaceIndex,
		      LOCAL_WORKSTATION_DIAL,
		      &FwIfInfo);

    // mark the interface reachable
    icbp->InterfaceReachable = TRUE;

    // set the admin state
    if(IpxIfInfop->AdminState == ADMIN_STATE_ENABLED) {

	AdminEnable(icbp);
    }
    else
    {
	AdminDisable(icbp);
    }

    // increment the interface counter
    InterfaceCount++;

    *InterfaceIndexp = icbp->InterfaceIndex;

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD
RmDeleteLocalWkstaDialoutInterface(ULONG	InterfaceIndex)
{
    return(DeleteInterface((HANDLE)UlongToPtr(InterfaceIndex)));
}

DWORD
RmGetIpxwanInterfaceConfig(ULONG	InterfaceIndex,
			   PULONG	IpxwanConfigRequired)
{
    PICB	icbp;

    ACQUIRE_DATABASE_LOCK;

    if((RouterOperState != OPER_STATE_UP) || LanOnlyMode) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = GetInterfaceByIndex(InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(icbp->EnableIpxWanNegotiation == ADMIN_STATE_ENABLED) {

	*IpxwanConfigRequired = 1;
    }
    else
    {
	*IpxwanConfigRequired = 0;
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

BOOL
RmIsRoute(PUCHAR	Network)
{
    BOOL	rc;

    ACQUIRE_DATABASE_LOCK;

    if((RouterOperState != OPER_STATE_UP) || LanOnlyMode) {

	RELEASE_DATABASE_LOCK;
	return FALSE;
    }

    rc = IsRoute(Network);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
RmGetInternalNetNumber(PUCHAR	    Network)
{
    PACB	 acbp;

    ACQUIRE_DATABASE_LOCK;

    if((RouterOperState != OPER_STATE_UP) || LanOnlyMode) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if(InternalInterfacep) {

	if(acbp = InternalInterfacep->acbp)  {

	    memcpy(Network, acbp->AdapterInfo.Network, 4);
	    RELEASE_DATABASE_LOCK;
	    return NO_ERROR;
	}
    }

    RELEASE_DATABASE_LOCK;

    return ERROR_CAN_NOT_COMPLETE;
}

//
//  This is a function added for pnp reasons so that the
//  ipx-related ras server settings could be updated.
//
DWORD RmUpdateIpxcpConfig (PIPXCP_ROUTER_CONFIG_PARAMS pParams) {
    DWORD dwErr;

    // Validate parameters
    if (! pParams)
        return ERROR_INVALID_PARAMETER;

    // Trace out the new settings
    Trace(IPXCPIF_TRACE, "RmUpdateIpxcpConfig: entered: %x %x %x %x", 
                            pParams->ThisMachineOnly, pParams->WanNetDatabaseInitialized,
                            pParams->EnableGlobalWanNet, *((DWORD*)pParams->GlobalWanNet));

    // Update the forwarder's ThisMachineOnly setting
    if ((dwErr = FwUpdateConfig(pParams->ThisMachineOnly)) != NO_ERROR)
        return dwErr;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\mibprot.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mibprot.h

Abstract:

    The MIB handling functions prototypes

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

DWORD
MibCreateStaticService(LPVOID);

DWORD
MibDeleteStaticService(LPVOID);

DWORD
MibGetStaticService(LPVOID, LPVOID, PULONG);

DWORD
MibGetFirstStaticService(LPVOID, LPVOID, PULONG);

DWORD
MibGetNextStaticService(LPVOID, LPVOID, PULONG);

DWORD
MibSetStaticService(LPVOID);

DWORD
MibGetService(LPVOID, LPVOID, PULONG);

DWORD
MibGetFirstService(LPVOID, LPVOID, PULONG);

DWORD
MibGetNextService(LPVOID, LPVOID, PULONG);

DWORD
MibInvalidFunction(LPVOID	    p);

DWORD
MibGetIpxBase(LPVOID, LPVOID, PULONG);

DWORD
MibGetIpxInterface(LPVOID, LPVOID, PULONG);

DWORD
MibGetFirstIpxInterface(LPVOID, LPVOID, PULONG);

DWORD
MibGetNextIpxInterface(LPVOID, LPVOID, PULONG);

DWORD
MibSetIpxInterface(LPVOID);

DWORD
MibGetRoute(LPVOID, LPVOID, PULONG);

DWORD
MibGetFirstRoute(LPVOID, LPVOID, PULONG);

DWORD
MibGetNextRoute(LPVOID, LPVOID, PULONG);

DWORD
MibCreateStaticRoute(LPVOID);

DWORD
MibDeleteStaticRoute(LPVOID);

DWORD
MibGetStaticRoute(LPVOID, LPVOID, PULONG);

DWORD
MibGetFirstStaticRoute(LPVOID, LPVOID, PULONG);

DWORD
MibGetNextStaticRoute(LPVOID, LPVOID, PULONG);

DWORD
MibSetStaticRoute(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\ifmgr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ifmgr.c

Abstract:

    This module contains the interface management functions

Author:

    Stefan Solomon  03/06/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//
//***  Interface Manager Globals ***
//

// Counter of existing interfaces

ULONG		InterfaceCount = 0;


//
//*** Interface Manager APIs ***
//

typedef struct	_IF_TYPE_TRANSLATION {

    ROUTER_INTERFACE_TYPE	DIMInterfaceType;
    ULONG			MIBInterfaceType;

    } IF_TYPE_TRANSLATION, *PIF_TYPE_TRANSLATION;

IF_TYPE_TRANSLATION   IfTypeTranslation[] = {

    { ROUTER_IF_TYPE_FULL_ROUTER, IF_TYPE_WAN_ROUTER },
    { ROUTER_IF_TYPE_HOME_ROUTER, IF_TYPE_PERSONAL_WAN_ROUTER },
    { ROUTER_IF_TYPE_DEDICATED,	  IF_TYPE_LAN },
    { ROUTER_IF_TYPE_CLIENT,	  IF_TYPE_WAN_WORKSTATION },
    { ROUTER_IF_TYPE_INTERNAL,	  IF_TYPE_INTERNAL }

   };

#define MAX_IF_TRANSLATION_TYPES    sizeof(IfTypeTranslation)/sizeof(IF_TYPE_TRANSLATION)

/*++

Function:	AddInterface

Descr:		Creates the interface control block and adds the specific
		structures of the interface info to the corresponding modules.

Arguments:
		InterfaceNamep :

		Pointer to a WCHAR string representing the interface name.

		InterfaceInfop :

		Pointer to an IPX_INFO_BLOCK_HEADER structure containing the
		IPX, RIP and SAP interface information, static routes and static services.

		Pointer to an IPX_INFO_BLOCK_HEADER structure containing the
		traffic filters.

		InterfaceType:

REMARK: 	In order for the router to be able to start, the internal interface
		has to be added.

--*/

DWORD
AddInterface(
	    IN	    LPWSTR		    InterfaceNamep,
	    IN	    LPVOID		    InterfaceInfop,
//	    IN	    LPVOID		    InFilterInfop,
//	    IN	    LPVOID		    OutFilterInfop,
	    IN	    ROUTER_INTERFACE_TYPE   DIMInterfaceType,
	    IN	    HANDLE		    hDIMInterface,
	    IN OUT  PHANDLE		    phInterface)
{
    PICB			icbp;
    ULONG			InterfaceNameLen; // if name length in bytes including wchar NULL
    PIPX_IF_INFO		IpxIfInfop;
    PIPX_STATIC_ROUTE_INFO	StaticRtInfop;
    PIPX_STATIC_SERVICE_INFO	StaticSvInfop;
    PIPXWAN_IF_INFO		IpxwanIfInfop;
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO InFltGlInfo, OutFltGlInfo;
//    PUCHAR			TrafficFilterInfop;
    PIPX_INFO_BLOCK_HEADER	IfInfop = (PIPX_INFO_BLOCK_HEADER)InterfaceInfop;
    PACB			acbp;
    ULONG			AdapterNameLen = 0; // length of adapter name
						    // for ROUTER_IF_TYPE_DEDICATED interface type.
    PIPX_TOC_ENTRY		tocep;
    UINT			i;
    PIPX_ADAPTER_INFO		AdapterInfop;
    ULONG			tmp;
    FW_IF_INFO			FwIfInfo;
    PIF_TYPE_TRANSLATION	ittp;
    ULONG			InterfaceIndex;
    PIPX_STATIC_NETBIOS_NAME_INFO StaticNbInfop;

    Trace(INTERFACE_TRACE, "AddInterface: Entered for interface %S", InterfaceNamep);

    if(InterfaceInfop == NULL) {

    IF_LOG (EVENTLOG_ERROR_TYPE) {
        RouterLogErrorDataW (RMEventLogHdl, 
            ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
            1, &InterfaceNamep, 0, NULL);
    }
	Trace(INTERFACE_TRACE, "AddInterface: Missing interface info for interface %ls\n", InterfaceNamep);
	return ERROR_CAN_NOT_COMPLETE;
    }

    // interface name length including the unicode null
    InterfaceNameLen = (wcslen(InterfaceNamep) + 1) * sizeof(WCHAR);

    // If the interface type if ROUTER_IF_TYPE_DEDICATED (LAN Adapter) we parse the
    // interface name to extract the adapter name and the packet type.
    // The packet type will be then converted to an integer and the two will
    // be used to identify a corresponding adapter.

    if(DIMInterfaceType == ROUTER_IF_TYPE_DEDICATED) {
        PWCHAR pszStart, pszEnd;
        DWORD dwGuidLength = 37;

    	// get the lan adapter specific info from the interface
    	if((AdapterInfop = (PIPX_ADAPTER_INFO)GetInfoEntry(InterfaceInfop,
    					   IPX_ADAPTER_INFO_TYPE)) == NULL) 
    	{

            IF_LOG (EVENTLOG_ERROR_TYPE) {
                RouterLogErrorDataW (RMEventLogHdl, 
                    ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                    1, &InterfaceNamep, 0, NULL);
            }
    	    Trace(INTERFACE_TRACE, "AddInterface: Dedicated interface %ls missing adapter info\n", InterfaceNamep);

    	    return ERROR_INVALID_PARAMETER;
    	}

    	// If the supplied adater is a reference to a guid, then use the name
    	// of the guid supplied in the interface name.  This is because load/save
    	// config's can cause these two to get out of sync.
    	pszStart = wcsstr (InterfaceNamep, L"{");
    	pszEnd = wcsstr (InterfaceNamep, L"}");
    	if ( (pszStart)                     && 
    	     (pszEnd)                       && 
    	     (pszStart == InterfaceNamep)   &&
    	     ((DWORD)(pszEnd - pszStart) == dwGuidLength) )
    	{
    	    wcsncpy (AdapterInfop->AdapterName, InterfaceNamep, dwGuidLength);
    	}

    	AdapterNameLen = (wcslen(AdapterInfop->AdapterName) + 1) * sizeof(WCHAR);
    }

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    // Check if this is the internal interface. If it is and if we
    // already have the internal interface, we return an error
    if((DIMInterfaceType == ROUTER_IF_TYPE_INTERNAL) &&
       (InternalInterfacep)) {

	RELEASE_DATABASE_LOCK;

	// internal interface already exists
	Trace(INTERFACE_TRACE, "AddInterface: INTERNAL interface already exists\n");

	return ERROR_INVALID_PARAMETER;
    }

    // Allocate a new ICB and initialize it
    // we allocate the interface and adapter name buffers at the end of the
    // ICB struct.
    if((icbp = (PICB)GlobalAlloc(GPTR,
				 sizeof(ICB) +
				 InterfaceNameLen +
				 AdapterNameLen)) == NULL) {

	RELEASE_DATABASE_LOCK;

	// can't alloc memory
	SS_ASSERT(FALSE);

	return ERROR_OUT_OF_STRUCTURES;
    }

    // signature
    memcpy(&icbp->Signature, InterfaceSignature, 4);

    // get a new index and increment the global interface index counter
    // if this is not the internal interface. For the internal interface we
    // have reserved index 0
    if(DIMInterfaceType == ROUTER_IF_TYPE_INTERNAL) {

	icbp->InterfaceIndex = 0;
    }
    else
    {
	icbp->InterfaceIndex = GetNextInterfaceIndex();
	if(icbp->InterfaceIndex == MAX_INTERFACE_INDEX) {

	    GlobalFree(icbp);

	    RELEASE_DATABASE_LOCK;

	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    InterfaceIndex = icbp->InterfaceIndex;


    // copy the interface name
    icbp->InterfaceNamep = (PWSTR)((PUCHAR)icbp + sizeof(ICB));
    memcpy(icbp->InterfaceNamep, InterfaceNamep, InterfaceNameLen);

    // copy the adapter name and packet type if dedicated interface
    if(DIMInterfaceType == ROUTER_IF_TYPE_DEDICATED) {

	icbp->AdapterNamep = (PWSTR)((PUCHAR)icbp + sizeof(ICB) + InterfaceNameLen);
	wcscpy(icbp->AdapterNamep, AdapterInfop->AdapterName);
	icbp->PacketType = AdapterInfop->PacketType;
    }
    else
    {
	icbp->AdapterNamep = NULL;
	icbp->PacketType = 0;
    }

    // insert the if in the index hash table
    AddIfToDB(icbp);

    // get the if handle used when calling DIM entry points
    icbp->hDIMInterface = hDIMInterface;

    // reset the update status fields
    ResetUpdateRequest(icbp);

    // mark connection not requested yet
    icbp->ConnectionRequestPending = FALSE;

    // get to the interface entries in the interface info block
    if(((IpxIfInfop = (PIPX_IF_INFO)GetInfoEntry(InterfaceInfop, IPX_INTERFACE_INFO_TYPE)) == NULL) ||
       ((IpxwanIfInfop = (PIPXWAN_IF_INFO)GetInfoEntry(InterfaceInfop, IPXWAN_INTERFACE_INFO_TYPE)) == NULL)) {

	RemoveIfFromDB(icbp);
	GlobalFree(icbp);

	RELEASE_DATABASE_LOCK;

	// don't have all ipx or ipxwan interfaces info
    IF_LOG (EVENTLOG_ERROR_TYPE) {
        RouterLogErrorDataW (RMEventLogHdl, 
            ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
            1, &InterfaceNamep, 0, NULL);
    }
	Trace(INTERFACE_TRACE, "AddInterface: missing ipx or ipxwan interface info\n");

	return ERROR_INVALID_PARAMETER;
    }

    // Initialize the Admin State and the Oper State of this interface.
    // Oper State may be changed will be changed later to OPER_STATE_SLEEPING
    // if this is a WAN interface.
    icbp->OperState = OPER_STATE_DOWN;

    // set the DIM interface type of this ICB
    icbp->DIMInterfaceType = DIMInterfaceType;

    // set the MIB interface type of this ICB
    icbp->MIBInterfaceType = IF_TYPE_OTHER;
    for(i=0, ittp=IfTypeTranslation; i<MAX_IF_TRANSLATION_TYPES; i++, ittp++) {

	if(icbp->DIMInterfaceType == ittp->DIMInterfaceType) {

	    icbp->MIBInterfaceType = ittp->MIBInterfaceType;
	    break;
	}
    }

    // create the routing protocols (rip/sap or nlsp) interface info
    // If the routing protocols interface info is missing this will fail
    if(CreateRoutingProtocolsInterfaces(InterfaceInfop, icbp) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;

	// don't have all rip and sap interfaces info
	Trace(INTERFACE_TRACE, "AddInterface: Bad routing protocols interface config info\n");

	goto ErrorExit;
    }

    // create the Forwarder interface
    FwIfInfo.NetbiosAccept = IpxIfInfop->NetbiosAccept;
    FwIfInfo.NetbiosDeliver = IpxIfInfop->NetbiosDeliver;
    FwCreateInterface(icbp->InterfaceIndex,
		      MapIpxToNetInterfaceType(icbp),
		      &FwIfInfo);

    // Seed the traffic filters
    if ((tocep = GetTocEntry(InterfaceInfop, IPX_IN_TRAFFIC_FILTER_INFO_TYPE))!=NULL) {

    if ((InFltGlInfo = GetInfoEntry(InterfaceInfop, IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE)) == NULL) {

	    RELEASE_DATABASE_LOCK;

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "AddInterface: Bad input filters config info");

	    goto ErrorExit;
    }
	
	if (SetFilters(icbp->InterfaceIndex,
			IPX_TRAFFIC_FILTER_INBOUND,
			InFltGlInfo->FilterAction,	 // pass or don't pass
			tocep->InfoSize,	  // filter size
			(LPBYTE)InterfaceInfop+tocep->Offset,
			tocep->InfoSize*tocep->Count) != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "AddInterface: Bad input filters config info");

	    goto ErrorExit;
	}
    }
    else { // No Filters -> delete all
        if (SetFilters(icbp->InterfaceIndex,
			        IPX_TRAFFIC_FILTER_INBOUND,  // in or outbound,
			        0,	 // pass or don't pass
			        0,	  // filter size
			        NULL,
			        0)!=NO_ERROR) {
	    RELEASE_DATABASE_LOCK;

	    Trace(INTERFACE_TRACE, "AddInterface: Could not delete input filters");

	    goto ErrorExit;
	}
    }

    if ((tocep = GetTocEntry(InterfaceInfop, IPX_OUT_TRAFFIC_FILTER_INFO_TYPE))!=NULL) {

    if ((OutFltGlInfo = GetInfoEntry(InterfaceInfop, IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE)) == NULL) {

	    RELEASE_DATABASE_LOCK;

	    Trace(INTERFACE_TRACE, "AddInterface: Bad output filters config info");

	    goto ErrorExit;
    }
	
	if (SetFilters(icbp->InterfaceIndex,
			IPX_TRAFFIC_FILTER_OUTBOUND,
			OutFltGlInfo->FilterAction,	 // pass or don't pass
			tocep->InfoSize,	  // filter size
			(LPBYTE)InterfaceInfop+tocep->Offset,
			tocep->InfoSize*tocep->Count) != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "AddInterface: Bad output filters config info");

	    goto ErrorExit;
	}
    }
    else { // No Filters -> delete all
        if (SetFilters(icbp->InterfaceIndex,
			        IPX_TRAFFIC_FILTER_OUTBOUND,  // in or outbound,
			        0,	 // pass or don't pass
			        0,	  // filter size
			        NULL,
			        0)!=NO_ERROR) {
	    RELEASE_DATABASE_LOCK;

	    Trace(INTERFACE_TRACE, "AddInterface: Could not delete output filters");

	    goto ErrorExit;
	}
    }

    // mark the interface reachable
    icbp->InterfaceReachable = TRUE;

    // set the admin state
    if(IpxIfInfop->AdminState == ADMIN_STATE_ENABLED) {

	AdminEnable(icbp);
    }
    else
    {
	AdminDisable(icbp);
    }

    // seed the static routes
    if(DIMInterfaceType!=ROUTER_IF_TYPE_CLIENT) {
        if (tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_ROUTE_INFO_TYPE)) {

	    StaticRtInfop = (PIPX_STATIC_ROUTE_INFO)GetInfoEntry(InterfaceInfop,
						     IPX_STATIC_ROUTE_INFO_TYPE);

	    for(i=0; i<tocep->Count; i++, StaticRtInfop++) {

	        CreateStaticRoute(icbp, StaticRtInfop);
	    }
        }

        // seed the static services
        if(tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_SERVICE_INFO_TYPE)) {

	    StaticSvInfop = (PIPX_STATIC_SERVICE_INFO)GetInfoEntry(InterfaceInfop,
						     IPX_STATIC_SERVICE_INFO_TYPE);

	    for(i=0; i<tocep->Count; i++, StaticSvInfop++) {

	        CreateStaticService(icbp, StaticSvInfop);
	    }
        }

        // seed the static netbios names
        if(tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_NETBIOS_NAME_INFO_TYPE)) {

	    StaticNbInfop = (PIPX_STATIC_NETBIOS_NAME_INFO)GetInfoEntry(InterfaceInfop,
						          IPX_STATIC_NETBIOS_NAME_INFO_TYPE);

	    FwSetStaticNetbiosNames(icbp->InterfaceIndex,
				    tocep->Count,
				    StaticNbInfop);
        }
    }

    // set the IPXWAN interface info
    icbp->EnableIpxWanNegotiation = IpxwanIfInfop->AdminState;

    // mark the interface as unbound to an adapter (default)
    icbp->acbp = NULL;

    // check if we can bind it now to an adapter. We can do this only for a
    // a dedicated (LAN) interface or for an internal interface.

    switch(icbp->DIMInterfaceType) {

	case ROUTER_IF_TYPE_DEDICATED:
            // Only bind interface if internal interface is already 
            // created and bound
        if (InternalInterfacep && InternalInterfacep->acbp) {
	        // check if we have an adapter with a corresponding name and
	        // packet type
	        if((acbp = GetAdapterByNameAndPktType (icbp->AdapterNamep,
                        icbp->PacketType)) != NULL) {

		        BindInterfaceToAdapter(icbp, acbp);
	        }
        }

	    break;

	case ROUTER_IF_TYPE_INTERNAL:

	    // get the pointer to the internal interface
	    InternalInterfacep = icbp;

	    // check that we have the adapter with adapter index 0 which
	    // represents the internal adapter
	    if(InternalAdapterp) {
            PLIST_ENTRY lep;
			acbp = InternalAdapterp;

			BindInterfaceToAdapter(icbp, acbp);
            lep = IndexIfList.Flink;
                // Bind all previously added dedicated interfaces that were
                // not bound awaiting for internal interface to be added
            while(lep != &IndexIfList) {
                PACB    acbp2;
            	PICB    icbp2 = CONTAINING_RECORD(lep, ICB, IndexListLinkage);
        	    lep = lep->Flink;
                switch(icbp2->DIMInterfaceType) {
	            case ROUTER_IF_TYPE_DEDICATED:
	                // check if we have an adapter with a corresponding name and
	                // packet type
	                if ((icbp2->acbp==NULL)
                            &&((acbp2 = GetAdapterByNameAndPktType (icbp2->AdapterNamep,
                                icbp2->PacketType)) != NULL)) {

		                BindInterfaceToAdapter(icbp2, acbp2);
	                }
                }
            }
	    }

	    break;

	default:
	
		if (icbp->AdminState==ADMIN_STATE_ENABLED)
			// this is a WAN interface. As long as it isn't connected, and
			// enabled the oper state will be sleeping on this interface
			icbp->OperState = OPER_STATE_SLEEPING;
	    break;

    }

    // increment the interface counter
    InterfaceCount++;

    switch(icbp->DIMInterfaceType)
    {

	case ROUTER_IF_TYPE_DEDICATED:

	    if(icbp->acbp) {

		Trace(INTERFACE_TRACE, "AddInterface: created LAN interface: # %d name %ls bound to adapter # %d name %ls\n",
			      icbp->InterfaceIndex,
			      icbp->InterfaceNamep,
			      icbp->acbp->AdapterIndex,
			      icbp->AdapterNamep);
	    }
	    else
	    {
		Trace(INTERFACE_TRACE, "AddInterface: created LAN interface: # %d name %ls unbound to any adapter\n",
			      icbp->InterfaceIndex,
			      icbp->InterfaceNamep);
	    }

	    break;

	case ROUTER_IF_TYPE_INTERNAL:

	    if(icbp->acbp) {

		Trace(INTERFACE_TRACE, "AddInterface: created INTERNAL interface: # %d name %ls bound to internal adapter\n",
			      icbp->InterfaceIndex,
			      icbp->InterfaceNamep);
	    }
	    else
	    {
		Trace(INTERFACE_TRACE, "AddInterface: created INTERNAL interface: # %d name %ls unbound to any adapter\n",
			      icbp->InterfaceIndex,
			      icbp->InterfaceNamep);
	    }

	    break;

	default:

	    Trace(INTERFACE_TRACE, "AddInterface: created WAN interface: # %d name %ls\n",
			      icbp->InterfaceIndex,
			      icbp->InterfaceNamep);
	    break;

    }

    RELEASE_DATABASE_LOCK;

    // return the allocated if index
    *phInterface = (HANDLE)UlongToPtr(icbp->InterfaceIndex);
    return NO_ERROR;

ErrorExit:

    InterfaceCount++;

    DeleteInterface((HANDLE)UlongToPtr(InterfaceIndex));

    return ERROR_CAN_NOT_COMPLETE;
}

/*++

Function:	DeleteInterface
Descr:

--*/

DWORD
DeleteInterface(HANDLE	InterfaceIndex)
{
    PICB	icbp;

    Trace(INTERFACE_TRACE, "DeleteInterface: Entered for interface # %d\n",
		   InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex));

    if(icbp == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    if(memcmp(&icbp->Signature, InterfaceSignature, 4)) {

       // not a valid if pointer
       SS_ASSERT(FALSE);

       RELEASE_DATABASE_LOCK;

       return ERROR_INVALID_PARAMETER;
    }

    // if bound to an adapter -> unbind
    if(icbp->acbp) {

	UnbindInterfaceFromAdapter(icbp);
    }

    // delete the routing protocols interfaces
    DeleteRoutingProtocolsInterfaces(icbp->InterfaceIndex);

    // delete all static routes from RTM
    DeleteAllStaticRoutes(icbp->InterfaceIndex);

    DeleteAllStaticServices(icbp->InterfaceIndex);

    // delete the Fw interface. This will delete all associated filters
    FwDeleteInterface(icbp->InterfaceIndex);

    // remove the if from the data base
    RemoveIfFromDB(icbp);

    // done
    GlobalFree(icbp);

    // decrement the interface counter
    InterfaceCount--;

    RELEASE_DATABASE_LOCK;

    Trace(INTERFACE_TRACE, "DeleteInterface: Deleted interface %d\n", InterfaceIndex);

    return NO_ERROR;
}


/*++

Function:	GetInterfaceInfo
Descr:

--*/

DWORD
GetInterfaceInfo(
	    IN	HANDLE	    InterfaceIndex,
	    OUT LPVOID	    InterfaceInfop,
	    IN OUT DWORD    *InterfaceInfoSize
//	    OUT LPVOID	    InFilterInfo,
//	    IN OUT DWORD    *InFilterInfoSize,
//	    OUT LPVOID	    OutFilterInfo,
//	    IN OUT DWORD    *OutFilterInfoSize
    )
{
    PICB		    icbp;
    PIPX_INFO_BLOCK_HEADER  ibhp, fbhp;
    PIPX_TOC_ENTRY	    tocep;
    PIPX_IF_INFO	    IpxIfInfop;
    PIPX_STATIC_ROUTE_INFO  StaticRtInfop;
    PIPX_STATIC_SERVICE_INFO StaticSvInfop;
    PIPXWAN_IF_INFO	    IpxwanIfInfop;
    PIPX_ADAPTER_INFO	IpxAdapterInfop;
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO InFltGlInfo, OutFltGlInfo;
    ULONG           InFltAction, OutFltAction;
    ULONG           InFltSize, OutFltSize;
    ULONG		    InFltInfoSize=0, OutFltInfoSize=0;
    FW_IF_STATS		    FwIfStats;
    ULONG		    iftoccount = 0;
    ULONG		    ifinfolen = 0;
    ULONG		    NextInfoOffset;
    ULONG		    IpxIfOffset = 0;
    ULONG		    StaticRtOffset = 0;
    ULONG		    StaticSvOffset = 0;
    IPX_STATIC_ROUTE_INFO   StaticRoute;
    UINT		    i;
    HANDLE		    EnumHandle;
    FW_IF_INFO		    FwIfInfo;
    ULONG		    StaticRoutesCount, StaticServicesCount, TrafficFiltersCount;
    DWORD		    rc;
    PIPX_STATIC_NETBIOS_NAME_INFO NetbiosNamesInfop;
    ULONG		    NetbiosNamesCount = 0;

    Trace(INTERFACE_TRACE, "GetInterfaceInfo: Entered for interface # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;

	Trace(INTERFACE_TRACE, "GetInterfaceInfo: Nonexistent interface with # %d\n", InterfaceIndex);

	return ERROR_INVALID_HANDLE;
    }

    SS_ASSERT(!memcmp(&icbp->Signature, InterfaceSignature, 4));

    // calculate the minimum number of toc entries we should have:
    // ipx toc entry
    // routing protocols toc entries
    // ipxwan toc entry
    iftoccount = 2 + RoutingProtocolsTocCount();

    // if this is a lan adapter, it should also have adapter info
    if(icbp->DIMInterfaceType == ROUTER_IF_TYPE_DEDICATED) {

	iftoccount++;
    }

    // calculate the minimun length of the interface info block
    ifinfolen = sizeof(IPX_INFO_BLOCK_HEADER) +
		(iftoccount - 1) * sizeof(IPX_TOC_ENTRY) +
		sizeof(IPX_IF_INFO) +
		SizeOfRoutingProtocolsIfsInfo(PtrToUlong(InterfaceIndex)) +
		sizeof(IPXWAN_IF_INFO);

    // if this is a lan adapter, add the size of the adapter info
    if(icbp->DIMInterfaceType == ROUTER_IF_TYPE_DEDICATED) {

	ifinfolen += sizeof(IPX_ADAPTER_INFO);
    }

    if(StaticRoutesCount = GetStaticRoutesCount(icbp->InterfaceIndex)) {

	ifinfolen += sizeof(IPX_TOC_ENTRY) +
		     StaticRoutesCount * sizeof(IPX_STATIC_ROUTE_INFO);

	iftoccount++;
    }

    if(StaticServicesCount = GetStaticServicesCount(icbp->InterfaceIndex)) {

	ifinfolen += sizeof(IPX_TOC_ENTRY) +
		   StaticServicesCount * sizeof(IPX_STATIC_SERVICE_INFO);

	iftoccount++;
    }

    FwGetStaticNetbiosNames(icbp->InterfaceIndex,
			    &NetbiosNamesCount,
			    NULL);

    if(NetbiosNamesCount) {

	ifinfolen += sizeof(IPX_TOC_ENTRY) +
		     NetbiosNamesCount * sizeof(IPX_STATIC_NETBIOS_NAME_INFO);

	iftoccount++;
    }


    // get the length of the filters info
    rc = GetFilters(icbp->InterfaceIndex,
	       IPX_TRAFFIC_FILTER_INBOUND,
           &InFltAction,
           &InFltSize,
	       NULL,
	       &InFltInfoSize);

    if((rc != NO_ERROR) && (rc != ERROR_INSUFFICIENT_BUFFER)) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    if (InFltInfoSize>0) {
        ifinfolen += sizeof (IPX_TOC_ENTRY)*2 + InFltInfoSize
                        + sizeof (IPX_TRAFFIC_FILTER_GLOBAL_INFO);
    	iftoccount += 2;
    }

    rc = GetFilters(icbp->InterfaceIndex,
	       IPX_TRAFFIC_FILTER_OUTBOUND,
           &OutFltAction,
           &OutFltSize,
	       NULL,
	       &OutFltInfoSize);

    if((rc != NO_ERROR) && (rc != ERROR_INSUFFICIENT_BUFFER)) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    if (OutFltInfoSize>0) {
        ifinfolen += sizeof (IPX_TOC_ENTRY)*2 + OutFltInfoSize
                        + sizeof (IPX_TRAFFIC_FILTER_GLOBAL_INFO);
    	iftoccount += 2;
    }
    // check if we have valid and sufficient buffers
    if((InterfaceInfop == NULL) ||
        (ifinfolen > *InterfaceInfoSize)) {

	*InterfaceInfoSize = ifinfolen;

	RELEASE_DATABASE_LOCK;

	return ERROR_INSUFFICIENT_BUFFER;
    }

	*InterfaceInfoSize = ifinfolen;


    //
    // Start filling in the interface info block
    //

    // start of the info block
    ibhp = (PIPX_INFO_BLOCK_HEADER)InterfaceInfop;

    // offset of the first INFO entry
    NextInfoOffset = sizeof(IPX_INFO_BLOCK_HEADER) +
		     (iftoccount -1) * sizeof(IPX_TOC_ENTRY);

    ibhp->Version = IPX_ROUTER_VERSION_1;
    ibhp->Size = ifinfolen;
    ibhp->TocEntriesCount = iftoccount;

    tocep = ibhp->TocEntry;

    // ipx if toc entry
    tocep->InfoType = IPX_INTERFACE_INFO_TYPE;
    tocep->InfoSize = sizeof(IPX_IF_INFO);
    tocep->Count = 1;
    tocep->Offset =  NextInfoOffset;
    NextInfoOffset += tocep->Count * tocep->InfoSize;

    // ipx if info entry
    IpxIfInfop = (PIPX_IF_INFO)((PUCHAR)ibhp + tocep->Offset);

    IpxIfInfop->AdminState = icbp->AdminState;

    FwGetInterface(icbp->InterfaceIndex,
		   &FwIfInfo,
		   &FwIfStats);

    IpxIfInfop->NetbiosAccept = FwIfInfo.NetbiosAccept;
    IpxIfInfop->NetbiosDeliver = FwIfInfo.NetbiosDeliver;

    // create the toc and info entries for the routing protocols in the
    // ouput buffer; this function will update the current TOC entry pointer
    // value (tocep) and the current next entry info offset value (nextInfoOffset)
    if((rc = CreateRoutingProtocolsTocAndInfoEntries(ibhp,
					    icbp->InterfaceIndex,
					    &tocep,
					    &NextInfoOffset)) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return rc;
    }

    // ipxwan if toc entry
    tocep++;
    tocep->InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    tocep->InfoSize = sizeof(IPXWAN_IF_INFO);
    tocep->Count = 1;
    tocep->Offset = NextInfoOffset;
    NextInfoOffset += tocep->Count * tocep->InfoSize;

    // ipxwan if info entry
    IpxwanIfInfop = (PIPXWAN_IF_INFO)((PUCHAR)ibhp + tocep->Offset);

    IpxwanIfInfop->AdminState = icbp->EnableIpxWanNegotiation;

    // if this is a lan interface, fill in the adapter info
    if(icbp->DIMInterfaceType == ROUTER_IF_TYPE_DEDICATED) {

	// ipx adapter toc entry
	tocep++;
	tocep->InfoType = IPX_ADAPTER_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_ADAPTER_INFO);

	tocep->Count = 1;
	tocep->Offset = NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	// ipx adapter info entry
	IpxAdapterInfop = (PIPX_ADAPTER_INFO)((PUCHAR)ibhp + tocep->Offset);

	IpxAdapterInfop->PacketType = icbp->PacketType;
	wcscpy(IpxAdapterInfop->AdapterName, icbp->AdapterNamep);
    }

    // static routes toc + info entries
    if(StaticRoutesCount) {

	// static routes toc entry
	tocep++;
	tocep->InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
	tocep->Count = StaticRoutesCount;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	// Create static routes enumeration handle for this interface
	EnumHandle = CreateStaticRoutesEnumHandle(icbp->InterfaceIndex);

	for(i=0, StaticRtInfop = (PIPX_STATIC_ROUTE_INFO)((PUCHAR)ibhp + tocep->Offset);
	    i<StaticRoutesCount;
	    i++, StaticRtInfop++) {

	    GetNextStaticRoute(EnumHandle, StaticRtInfop);
	}

	// Close the enumeration handle
	CloseStaticRoutesEnumHandle(EnumHandle);
    }

    // static services toc + info entries
    if(StaticServicesCount) {

	// static services toc entry
	tocep++;
	tocep->InfoType = IPX_STATIC_SERVICE_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_STATIC_SERVICE_INFO);
	tocep->Count = StaticServicesCount;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	// Create static services enumeration handle for this interface
	EnumHandle = CreateStaticServicesEnumHandle(icbp->InterfaceIndex);

	for(i=0, StaticSvInfop = (PIPX_STATIC_SERVICE_INFO)((PUCHAR)ibhp + tocep->Offset);
	    i<StaticServicesCount;
	    i++, StaticSvInfop++) {

	    GetNextStaticService(EnumHandle, StaticSvInfop);
	}

	// Close the enumeration handle
	CloseStaticServicesEnumHandle(EnumHandle);
    }

    // static netbios names toc + info entries
    if(NetbiosNamesCount) {

	// static netbios names toc entry
	tocep++;
	tocep->InfoType = IPX_STATIC_NETBIOS_NAME_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_STATIC_NETBIOS_NAME_INFO);
	tocep->Count = NetbiosNamesCount;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	NetbiosNamesInfop = (PIPX_STATIC_NETBIOS_NAME_INFO)((PUCHAR)ibhp + tocep->Offset);

	rc = FwGetStaticNetbiosNames(icbp->InterfaceIndex,
				       &NetbiosNamesCount,
				       NetbiosNamesInfop);

	if(rc != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;
	    return rc;
	}
    }

    if(InFltInfoSize) {

	// traffic filter input global info
	tocep++;
	tocep->InfoType = IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_TRAFFIC_FILTER_GLOBAL_INFO);
	tocep->Count = 1;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	InFltGlInfo = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)((PUCHAR)ibhp + tocep->Offset);


    rc = GetFilters(icbp->InterfaceIndex,
	       IPX_TRAFFIC_FILTER_INBOUND,
           &InFltAction,
           &InFltSize,
	       (LPBYTE)InterfaceInfop+NextInfoOffset,
	       &InFltInfoSize);
	if(rc != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;
	    return rc;
	}

    InFltGlInfo->FilterAction = InFltAction;

	// traffic filter input global info
	tocep++;
	tocep->InfoType = IPX_IN_TRAFFIC_FILTER_INFO_TYPE;
	tocep->InfoSize = InFltSize;
	tocep->Count = InFltInfoSize/InFltSize;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;
    }

    if(OutFltInfoSize) {

	// traffic filter input global info
	tocep++;
	tocep->InfoType = IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE;
	tocep->InfoSize = sizeof(IPX_TRAFFIC_FILTER_GLOBAL_INFO);
	tocep->Count = 1;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;

	OutFltGlInfo = (PIPX_TRAFFIC_FILTER_GLOBAL_INFO)((PUCHAR)ibhp + tocep->Offset);


    rc = GetFilters(icbp->InterfaceIndex,
	       IPX_TRAFFIC_FILTER_OUTBOUND,
           &OutFltAction,
           &OutFltSize,
	       (LPBYTE)InterfaceInfop+NextInfoOffset,
	       &OutFltInfoSize);
	if(rc != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;
	    return rc;
	}

    OutFltGlInfo->FilterAction = OutFltAction;

	// traffic filter input global info
	tocep++;
	tocep->InfoType = IPX_OUT_TRAFFIC_FILTER_INFO_TYPE;
	tocep->InfoSize = OutFltSize;
	tocep->Count = OutFltInfoSize/OutFltSize;
	tocep->Offset =	NextInfoOffset;
	NextInfoOffset += tocep->Count * tocep->InfoSize;
    }


    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}


/*++

Function:	SetInterfaceInfo
Descr:

--*/


DWORD
SetInterfaceInfo(
		IN  HANDLE	InterfaceIndex,
		IN  LPVOID	InterfaceInfop)
{
    PICB			icbp;
    PIPX_IF_INFO		IpxIfInfop;
    PIPXWAN_IF_INFO		IpxwanIfInfop;
    PIPX_STATIC_ROUTE_INFO	NewStaticRtInfop;
    PIPX_STATIC_SERVICE_INFO	NewStaticSvInfop;
    PIPX_INFO_BLOCK_HEADER	IfInfop = (PIPX_INFO_BLOCK_HEADER)InterfaceInfop;
    PIPX_TOC_ENTRY		tocep;
    DWORD			rc = NO_ERROR;
    HANDLE			EnumHandle;
    FW_IF_INFO			FwIfInfo;
    PIPX_STATIC_NETBIOS_NAME_INFO StaticNbInfop;
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO InFltGlInfo, OutFltGlInfo;

    ACQUIRE_DATABASE_LOCK;

	if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }


    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_HANDLE;
    }

    SS_ASSERT(!memcmp(&icbp->Signature, InterfaceSignature, 4));

    // check if there was a change in the interface info block
    if(IfInfop == NULL) {

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
    }

    // check that we have all the mandatory info blocks
    if(((IpxIfInfop = (PIPX_IF_INFO)GetInfoEntry(InterfaceInfop, IPX_INTERFACE_INFO_TYPE)) == NULL) ||
       ((IpxwanIfInfop = (PIPXWAN_IF_INFO)GetInfoEntry(InterfaceInfop, IPXWAN_INTERFACE_INFO_TYPE)) == NULL)) {

	RELEASE_DATABASE_LOCK;

	// invalid info
	return ERROR_INVALID_PARAMETER;
    }

    if(SetRoutingProtocolsInterfaces(InterfaceInfop,
				     icbp->InterfaceIndex) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;

	// invalid info
	return ERROR_INVALID_PARAMETER;
    }

    // set ipx if info changes
    if(icbp->AdminState != IpxIfInfop->AdminState) {

	if(IpxIfInfop->AdminState == ADMIN_STATE_ENABLED) {

	    AdminEnable(icbp);
	}
	else
	{
	    AdminDisable(icbp);
	}
    }

    FwIfInfo.NetbiosAccept = IpxIfInfop->NetbiosAccept;
    FwIfInfo.NetbiosDeliver = IpxIfInfop->NetbiosDeliver;

    FwSetInterface(icbp->InterfaceIndex, &FwIfInfo);

    // set IPXWAN info changes
    icbp->EnableIpxWanNegotiation = IpxwanIfInfop->AdminState;

    // set static routes
    if((tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_ROUTE_INFO_TYPE)) == NULL) {

	// no static routes
	// delete them if we've got them
	if(GetStaticRoutesCount(icbp->InterfaceIndex)) {

	    DeleteAllStaticRoutes(icbp->InterfaceIndex);
	}
    }
    else
    {
	// delete non-present ones and add new ones
	NewStaticRtInfop = (PIPX_STATIC_ROUTE_INFO)GetInfoEntry(InterfaceInfop, IPX_STATIC_ROUTE_INFO_TYPE);

	// Create static routes enumeration handle for this interface
	EnumHandle = CreateStaticRoutesEnumHandle(icbp->InterfaceIndex);

	if(UpdateStaticIfEntries(icbp,
			      EnumHandle,
			      sizeof(IPX_STATIC_ROUTE_INFO),
			      tocep->Count,    // number of routes in the new info
			      NewStaticRtInfop,
			      GetNextStaticRoute,
			      DeleteStaticRoute,
			      CreateStaticRoute)) {

	    // Close the enumeration handle
	    CloseStaticRoutesEnumHandle(EnumHandle);

	    rc = ERROR_GEN_FAILURE;
	    goto UpdateFailure;
	}

	// Close the enumeration handle
	CloseStaticRoutesEnumHandle(EnumHandle);
    }

    // set static services
    if((tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_SERVICE_INFO_TYPE)) == NULL) {

	// no static services
	// delete them if we've got them
	if(GetStaticServicesCount(icbp->InterfaceIndex)) {

	    DeleteAllStaticServices(icbp->InterfaceIndex);
	}
    }
    else
    {
	// delete non-present ones and add new ones
	NewStaticSvInfop = (PIPX_STATIC_SERVICE_INFO)GetInfoEntry(InterfaceInfop, IPX_STATIC_SERVICE_INFO_TYPE);

	// Create static services enumeration handle for this interface
	EnumHandle = CreateStaticServicesEnumHandle(icbp->InterfaceIndex);

	if(UpdateStaticIfEntries(icbp,
			      EnumHandle,
			      sizeof(IPX_STATIC_SERVICE_INFO),
			      tocep->Count,    // number of services in the new info
			      NewStaticSvInfop,
			      GetNextStaticService,
			      DeleteStaticService,
			      CreateStaticService)) {


	    // Close the enumeration handle
	    CloseStaticServicesEnumHandle(EnumHandle);

	    rc = ERROR_GEN_FAILURE;
	    goto UpdateFailure;
	}

	// Close the enumeration handle
	CloseStaticServicesEnumHandle(EnumHandle);
    }

    // set static netbios names
    if((tocep = GetTocEntry(InterfaceInfop, IPX_STATIC_NETBIOS_NAME_INFO_TYPE)) == NULL) {

	// no static netbios names
	FwSetStaticNetbiosNames(icbp->InterfaceIndex,
				0,
				NULL);
    }
    else
    {
	// set the new ones
	StaticNbInfop = (PIPX_STATIC_NETBIOS_NAME_INFO)GetInfoEntry(InterfaceInfop,
							IPX_STATIC_NETBIOS_NAME_INFO_TYPE);

	FwSetStaticNetbiosNames(icbp->InterfaceIndex,
				tocep->Count,
				StaticNbInfop);
    }

    // Seed the traffic filters
    if ((tocep = GetTocEntry(InterfaceInfop, IPX_IN_TRAFFIC_FILTER_INFO_TYPE))!=NULL) {

    if ((InFltGlInfo = GetInfoEntry(InterfaceInfop, IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE)) == NULL) {

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &icbp->InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "SetInterface: Bad input filters config info");

	    goto UpdateFailure;
    }
	
	if (SetFilters(icbp->InterfaceIndex,
			IPX_TRAFFIC_FILTER_INBOUND,
			InFltGlInfo->FilterAction,	 // pass or don't pass
			tocep->InfoSize,	  // filter size
			(LPBYTE)InterfaceInfop+tocep->Offset,
			tocep->InfoSize*tocep->Count) != NO_ERROR) {

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &icbp->InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "SetInterface: Bad input filters config info");

	    goto UpdateFailure;
	}
    }
    else { // No Filters -> delete all
        if (SetFilters(icbp->InterfaceIndex,
			        IPX_TRAFFIC_FILTER_INBOUND,  // in or outbound,
			        0,	 // pass or don't pass
			        0,	  // filter size
			        NULL,
			        0)!=NO_ERROR) {

	    Trace(INTERFACE_TRACE, "SetInterface: Could not delete input filters");

	    goto UpdateFailure;
	}
    }

    if ((tocep = GetTocEntry(InterfaceInfop, IPX_OUT_TRAFFIC_FILTER_INFO_TYPE))!=NULL) {

    if ((OutFltGlInfo = GetInfoEntry(InterfaceInfop, IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE)) == NULL) {


        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &icbp->InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "SetInterface: Bad output filters config info");

	    goto UpdateFailure;
    }
	
	if (SetFilters(icbp->InterfaceIndex,
			IPX_TRAFFIC_FILTER_OUTBOUND,
			OutFltGlInfo->FilterAction,	 // pass or don't pass
			tocep->InfoSize,	  // filter size
			(LPBYTE)InterfaceInfop+tocep->Offset,
			tocep->InfoSize*tocep->Count) != NO_ERROR) {

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_BAD_INTERFACE_CONFIG,
                1, &icbp->InterfaceNamep, 0, NULL);
        }
	    Trace(INTERFACE_TRACE, "SetInterface: Bad output filters config info");

	    goto UpdateFailure;
	}
    }
    else { // No Filters -> delete all
        if (SetFilters(icbp->InterfaceIndex,
			        IPX_TRAFFIC_FILTER_OUTBOUND,  // in or outbound,
			        0,	 // pass or don't pass
			        0,	  // filter size
			        NULL,
			        0)!=NO_ERROR) {
	    Trace(INTERFACE_TRACE, "SetInterface: Could not delete output filters");

	    goto UpdateFailure;
	}
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;

UpdateFailure:

    RELEASE_DATABASE_LOCK;
    return rc;
}

/*++

Function:	InterfaceNotReachable

Descr:		Called in the following cases:

		1. Following a ConnectInterface request from the Router Manager,
		   to indicate that the connection atempt has failed.

		2. When DIM realizes it won't be able to execute any further
		   ConnectInterface requests because of out of resources.

--*/

DWORD
InterfaceNotReachable(
		IN  HANDLE			      InterfaceIndex,
		IN  UNREACHABILITY_REASON	      Reason)
{
    PICB	icbp;

    Trace(INTERFACE_TRACE, "IpxRM: InterfaceNotReachable: Entered for if # %d\n",
		   InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }


    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	// interface has been removed
	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    if(icbp->ConnectionRequestPending) {

	icbp->ConnectionRequestPending = FALSE;

	// notify the forwarder of the connection failure
	FwConnectionRequestFailed(icbp->InterfaceIndex);
    }

    // if there is reason to stop advertising routes/services on this if
    // because it can't be reached in the future, do it!

    if(icbp->InterfaceReachable) 
    {
		icbp->InterfaceReachable = FALSE;

		// stop advertising static routes on this interface
		DisableStaticRoutes(icbp->InterfaceIndex);

		// disable the interface for all routing prot and fw
		// this will stop advertising any static services
		ExternalDisableInterface(icbp->InterfaceIndex);
	}

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

/*++

Function:	InterfaceReachable

Descr:		Called by DIM following a previous InterfaceNotReachable to
		indicate that conditions are met to do connections on this if.

--*/

DWORD
InterfaceReachable(
		IN  HANDLE	InterfaceIndex)
{
    PICB	icbp;

    Trace(INTERFACE_TRACE, "IpxRM: InterfaceReachable: Entered for if # %d\n",
		   InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;
    if(RouterOperState != OPER_STATE_UP) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	// interface has been removed
	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    if(!icbp->InterfaceReachable) {

	icbp->InterfaceReachable = TRUE;

	if(icbp->AdminState == ADMIN_STATE_ENABLED) {

	    // enable all static routes for this interface
	    EnableStaticRoutes(icbp->InterfaceIndex);

	    // enable external interfaces. Implicitly, this will enable static services
	    // bound to this interface to be advertised
	    ExternalEnableInterface(icbp->InterfaceIndex);
	}
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

DWORD APIENTRY
InterfaceConnected ( 
    IN      HANDLE          hInterface,
    IN      PVOID           pFilter,
    IN      PVOID           pPppProjectionResult
    ) {
    return NO_ERROR;
}

VOID
DestroyAllInterfaces(VOID)
{
    PICB	icbp;

    while(!IsListEmpty(&IndexIfList)) {

	icbp = CONTAINING_RECORD(IndexIfList.Flink, ICB, IndexListLinkage);

	// remove the if from the data base
	RemoveIfFromDB(icbp);

	Trace(INTERFACE_TRACE, "DestroyAllInterfaces: destroyed interface %d\n", icbp->InterfaceIndex);

	GlobalFree(icbp);

	// decrement the interface counter
	InterfaceCount--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\mibserv.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mibserv.c

Abstract:

    The MIB services handling functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

/*++

Function:	MibGetService

Descr:

--*/

DWORD
MibGetService(PIPX_MIB_INDEX		    mip,
	      PIPX_SERVICE		    Svp,
	      PULONG			    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    if(IsService(mip->ServicesTableIndex.ServiceType,
		 mip->ServicesTableIndex.ServiceName,
		 Svp)) {

	return NO_ERROR;
    }
    else
    {
	return ERROR_INVALID_PARAMETER;
    }
}

/*++

Function:	MibGetFirstService

Descr:

--*/

DWORD
MibGetFirstService(PIPX_MIB_INDEX	    mip,
		   PIPX_SERVICE		    Svp,
		   PULONG		    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    return(GetFirstService(STM_ORDER_BY_TYPE_AND_NAME, 0, Svp));
}

/*++

Function:	MibGetNextService

Descr:

--*/

DWORD
MibGetNextService(PIPX_MIB_INDEX	    mip,
		  PIPX_SERVICE		    Svp,
		  PULONG		    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Svp->Server.Type = mip->ServicesTableIndex.ServiceType;
    memcpy(Svp->Server.Name, mip->ServicesTableIndex.ServiceName, 48);

    return(GetNextService(STM_ORDER_BY_TYPE_AND_NAME, 0, Svp));
}

/*++

Function:	MibCreateStaticService
Descr:

--*/

DWORD
MibCreateStaticService(PIPX_MIB_ROW	    MibRowp)
{
    PIPX_SERVICE		StaticSvp;
    DWORD			rc;
    PICB            icbp;

    StaticSvp = &MibRowp->Service;

    ACQUIRE_DATABASE_LOCK;

    // check the interface exists
    if((icbp=GetInterfaceByIndex(StaticSvp->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    rc = CreateStaticService(icbp,
			     &StaticSvp->Server);

    RELEASE_DATABASE_LOCK;
    return rc;
}

/*++

Function:	DeleteStaticService

Descr:

--*/

DWORD
MibDeleteStaticService(PIPX_MIB_ROW	 MibRowp)
{
    PIPX_SERVICE   StaticSvp;
    DWORD	   rc;

    StaticSvp = &MibRowp->Service;

    ACQUIRE_DATABASE_LOCK;

    // check the interface exists
    if(GetInterfaceByIndex(StaticSvp->InterfaceIndex) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    rc = DeleteStaticService(StaticSvp->InterfaceIndex,
			     &StaticSvp->Server);

    RELEASE_DATABASE_LOCK;
    return rc;
}

/*++

Function:	MibGetStaticService

Descr:

--*/

DWORD
MibGetStaticService(PIPX_MIB_INDEX	    mip,
		    PIPX_SERVICE	    Svp,
		    PULONG		    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Svp->InterfaceIndex = mip->StaticServicesTableIndex.InterfaceIndex;
    Svp->Server.Type = mip->StaticServicesTableIndex.ServiceType;
    memcpy(Svp->Server.Name, mip->StaticServicesTableIndex.ServiceName, 48);
    Svp->Protocol = IPX_PROTOCOL_STATIC;

    return(GetFirstService(STM_ORDER_BY_INTERFACE_TYPE_NAME,
    STM_ONLY_THIS_INTERFACE | STM_ONLY_THIS_TYPE | STM_ONLY_THIS_NAME | STM_ONLY_THIS_PROTOCOL,
    Svp));
}

/*++

Function:	MibGetFirstStaticService

Descr:

--*/

DWORD
MibGetFirstStaticService(PIPX_MIB_INDEX	    mip,
			 PIPX_SERVICE	    Svp,
			 PULONG		    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    // set the static protocol
    Svp->Protocol = IPX_PROTOCOL_STATIC;

    return(GetFirstService(STM_ORDER_BY_INTERFACE_TYPE_NAME,
			   STM_ONLY_THIS_PROTOCOL,
			   Svp));
}

/*++

Function:	MibGetNextStaticService

Descr:

--*/

DWORD
MibGetNextStaticService(PIPX_MIB_INDEX	    mip,
			PIPX_SERVICE	    Svp,
			PULONG		    ServiceSize)
{
    if((Svp == NULL) || (*ServiceSize < sizeof(IPX_SERVICE))) {

	*ServiceSize = sizeof(IPX_SERVICE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Svp->InterfaceIndex = mip->StaticServicesTableIndex.InterfaceIndex;
    Svp->Server.Type = mip->StaticServicesTableIndex.ServiceType;
    memcpy(Svp->Server.Name, mip->StaticServicesTableIndex.ServiceName, 48);
    Svp->Protocol = IPX_PROTOCOL_STATIC;

    return(GetNextService(STM_ORDER_BY_INTERFACE_TYPE_NAME,
			  STM_ONLY_THIS_PROTOCOL,
			  Svp));
}

/*++

Function:	MibSetStaticService
Descr:

--*/

DWORD
MibSetStaticService(PIPX_MIB_ROW	    MibRowp)
{
    PIPX_SERVICE		StaticSvp;
    DWORD			rc;
    PICB            icbp;

    StaticSvp = &MibRowp->Service;

    ACQUIRE_DATABASE_LOCK;

    // check the interface exists
    if((icbp=GetInterfaceByIndex(StaticSvp->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    DeleteStaticService(StaticSvp->InterfaceIndex,
			&StaticSvp->Server);

    rc = CreateStaticService(icbp,
			     &StaticSvp->Server);

    RELEASE_DATABASE_LOCK;
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\misc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    misc.c

Abstract:

    Miscellaneous management functions

Author:

    Stefan Solomon  03/13/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


UCHAR	    bcastnode[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

VOID
SetAdapterBindingInfo(PIPX_ADAPTER_BINDING_INFO	    abip,
		      PACB			    acbp);

VOID
RMCreateLocalRoute(PICB	    icbp);

VOID
RMDeleteLocalRoute(PICB	    icbp);

VOID
ExternalBindInterfaceToAdapter(PICB	    icbp);

VOID
ExternalUnbindInterfaceFromAdapter(ULONG    InterfaceIndex);

/*++

Function:	GetTocEntry
Descr:		Returns a pointer to the specified table of contents entry
		in the interface info block.

--*/

PIPX_TOC_ENTRY
GetTocEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	    ULONG			InfoEntryType)
{
    PIPX_TOC_ENTRY	tocep;
    UINT		i;

    for(i=0, tocep = InterfaceInfop->TocEntry;
	i<InterfaceInfop->TocEntriesCount;
	i++, tocep++) {

	if(tocep->InfoType == InfoEntryType) {

	    return tocep;
	}
    }

    return NULL;
}

/*++

Function:	GetInfoEntry
Descr:		Returns a pointer to the specified info entry in the interface
		control block. If more then one entries, returns a pointer to
		the first one.

--*/

LPVOID
GetInfoEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	     ULONG			InfoEntryType)
{
    PIPX_TOC_ENTRY	tocep;

    if(tocep = GetTocEntry(InterfaceInfop, InfoEntryType)) {

	return((LPVOID)((PUCHAR)InterfaceInfop + tocep->Offset));
    }
    else
    {
	return NULL;
    }
}


/*++

Function:	UpdateStaticIfEntries
Descr:		Compares the entries in the interface info block with the
		stored static entries. Deletes the entries not present
		in the interface info blolck and adds the new entries

--*/


DWORD
UpdateStaticIfEntries(
		PICB	 icbp,
		HANDLE	 EnumHandle,	     // handle for the get next enumeration
		ULONG	 StaticEntrySize,
		ULONG	 NewStaticEntriesCount,  // number of new static entries
		LPVOID	 NewStaticEntry,	 // start of the new entries array
		ULONG	 (*GetNextStaticEntry)(HANDLE EnumHandle, LPVOID entry),
		ULONG	 (*DeleteStaticEntry)(ULONG IfIndex, LPVOID entry),
		ULONG	 (*CreateStaticEntry)(PICB icbp, LPVOID entry))
{
    PUCHAR	EntryIsNew, nsep, OldStaticEntry;
    BOOL	found;
    UINT	i;

    // delete non-present entries and add the new entries

    // array of flags to mark the new entries
    if((EntryIsNew = GlobalAlloc(GPTR, NewStaticEntriesCount)) == NULL) {

	return 1;
    }

    memset(EntryIsNew, 1, NewStaticEntriesCount);

    if((OldStaticEntry = GlobalAlloc(GPTR, StaticEntrySize)) == NULL) {

	GlobalFree(EntryIsNew);

	return 1;
    }

    if(EnumHandle) {

	while(!GetNextStaticEntry(EnumHandle, OldStaticEntry))
	{

	    // compare it with each new static static entry until we find a match
	    found = FALSE;
	    for(i = 0, nsep = NewStaticEntry;
		i<NewStaticEntriesCount;
		i++, nsep+= StaticEntrySize) {

		if(!memcmp(OldStaticEntry, nsep, StaticEntrySize)) {

		    // match - set the flags to OLD
		    EntryIsNew[i] = 0;
		    found = TRUE;
		    break;
		}
	    }

	    if(!found) {

		// non present old entry -> delete it
		DeleteStaticEntry(icbp->InterfaceIndex, OldStaticEntry);
	    }
	}
    }

    // all compared and old non-present ones deleted
    // now, add all the new ones

    for(i=0, nsep = NewStaticEntry;
	i<NewStaticEntriesCount;
	i++, nsep+= StaticEntrySize) {

	if(EntryIsNew[i]) {

	    CreateStaticEntry(icbp, nsep);
	}
    }

    GlobalFree(EntryIsNew);

    return 0;
}

/*++

Function:	GetInterfaceAnsiName

Arguments:

		AnsiInterfaceNameBuffer - buffer of IPX_INTERFACE_ANSI_NAME_LEN

		UnicodeInterfaceNameBuffer -

Descr:

--*/

VOID
GetInterfaceAnsiName(PUCHAR	    AnsiInterfaceNameBuffer,
		     PWSTR	    UnicodeInterfaceNameBuffer)
{
    UNICODE_STRING	    UnicodeInterfaceName;
    ANSI_STRING 	    AnsiInterfaceName;
    NTSTATUS            ntStatus;

    // init a unicode string with the interface name string
    RtlInitUnicodeString(&UnicodeInterfaceName, UnicodeInterfaceNameBuffer);

    // make the interface name unicode string an ansi string
    // in an rtl allocated buffer
    ntStatus = RtlUnicodeStringToAnsiString(&AnsiInterfaceName,
				 &UnicodeInterfaceName,
				 TRUE	     // allocate the ansi buffer
				 );
    if (ntStatus != STATUS_SUCCESS)
    {
        return;
    }

    // copy the interface name into the supplied buffer, up to the
    // argument buffer max size
    memcpy(AnsiInterfaceNameBuffer,
	   AnsiInterfaceName.Buffer,
	   min(AnsiInterfaceName.MaximumLength, IPX_INTERFACE_ANSI_NAME_LEN));

    // free the rtl allocated buffer
    RtlFreeAnsiString(&AnsiInterfaceName);
}

/*++

Function:	BindInterfaceToAdapter

Descr:		Binds the interface to the adapter in the router manager and in
		all the other modules and creates a local route for the interface
		in the RTM

--*/

VOID
BindInterfaceToAdapter(PICB	    icbp,
		       PACB	    acbp)
{
    DWORD	rc;

    Trace(BIND_TRACE, "BindInterfaceToAdapter: Bind interface # %d to adapter # %d",
		   icbp->InterfaceIndex,
		   acbp->AdapterIndex);

    if(icbp->acbp != NULL) 
    {
        Trace(BIND_TRACE, "BindInterfaceToAdapter: interface # %d already bound !!!",
		      icbp->InterfaceIndex);

	    //SS_ASSERT(FALSE);

	    return;
    }

    // Make sure that the adapter is not currently claimed by any 
    // interface either.
    //
    if ((acbp->icbp) && (acbp->icbp->acbp == acbp))
    {
    	Trace(
    	    BIND_TRACE, 
    	    "BindInterfaceToAdapter: adapter # %d already bound to int # %d!!",
    	    acbp->AdapterIndex,
    		acbp->icbp->InterfaceIndex);

    	return;
    }
    

    // internal bind the adapter control block and the interface control block
    icbp->acbp = acbp;
    acbp->icbp = icbp;

    // if a connection was requested on this if, mark that it has been done
    if(icbp->ConnectionRequestPending) {

	icbp->ConnectionRequestPending = FALSE;
    }

    if(!icbp->InterfaceReachable) {

	// we should never hit this code path in normal operation
	// However, should anybody atempt and succeed a dial (manually?) on an
	// interface marked unreachable, we should reset our state

	// icbp->InterfaceReachable = TRUE;

	if(icbp->AdminState == ADMIN_STATE_ENABLED) {

	    // enable all static routes for this interface
	    EnableStaticRoutes(icbp->InterfaceIndex);

	    // enable external interfaces. Implicitly, this will enable static services
	    // bound to this interface to be advertised
	    ExternalEnableInterface(icbp->InterfaceIndex);
	}
    }

    if (icbp->AdminState==ADMIN_STATE_ENABLED) {
	    icbp->OperState = OPER_STATE_UP;
	    // create a local route entry in RTM for the connected interface
	    RMCreateLocalRoute(icbp);
	}


    ExternalBindInterfaceToAdapter(icbp);

    // if the interface is a local client type (i.e. host doing manual dial from
    // the local machine, try to update the internal routing table
    if(icbp->MIBInterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

	if((rc = RtProtRequestRoutesUpdate(icbp->InterfaceIndex)) == NO_ERROR) {

	    icbp->UpdateReq.RoutesReqStatus = UPDATE_PENDING;
	}
	else
	{
	    Trace(UPDATE_TRACE, "BindInterfaceToAdapter: Routing Update is Disabled");
	}

	if((rc = RtProtRequestServicesUpdate(icbp->InterfaceIndex)) == NO_ERROR) {

	    icbp->UpdateReq.ServicesReqStatus = UPDATE_PENDING;
	}
	else
	{
	    Trace(UPDATE_TRACE, "BindInterfaceToAdapter: Services Update is Disabled");
	}
    }
}

/*++

Function:	UnbindInterfaceFromAdapter

Descr:		Unbind the Rip, Sap and Forwarder interfaces with this index from
		the respective adapter

--*/

VOID
UnbindInterfaceFromAdapter(PICB	icbp)
{
    PACB	acbp;
    ULONG	new_if_oper_state;

	
    acbp = icbp->acbp;

	if (acbp==NULL) {
	    Trace(BIND_TRACE, "UnbindInterfaceFromAdapter:Interface # %d is not bound to any adapter",
			   icbp->InterfaceIndex);
		return;
	}

    Trace(BIND_TRACE, "UnbindInterfaceFromAdapter: Unbind interface # %d from adapter # %d",
		   icbp->InterfaceIndex,
		   acbp->AdapterIndex);

    switch(icbp->MIBInterfaceType) {

	case IF_TYPE_PERSONAL_WAN_ROUTER:
	case IF_TYPE_WAN_WORKSTATION:
	case IF_TYPE_WAN_ROUTER:
	case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:

	    if (icbp->AdminState==ADMIN_STATE_ENABLED) {
		    icbp->OperState = OPER_STATE_SLEEPING;
			break;
		}

	default:

	    icbp->OperState = OPER_STATE_DOWN;
	    break;

    }

    if (icbp->AdminState==ADMIN_STATE_ENABLED) {

	    // delete local route and ext unbind
	    RMDeleteLocalRoute(icbp);

    }

    ExternalUnbindInterfaceFromAdapter(icbp->InterfaceIndex);

    // if there were updates going on they will get cancelled automatically
    // by the respective routing protocols.
    // We just have to reset the update state in the ICB
    ResetUpdateRequest(icbp);

    // Now we can unbind the adapter from interface
    acbp->icbp = NULL;
    icbp->acbp = NULL;
}

/*++

Function:	GetNextInterfaceIndex

Descr:		Returns the next available interface index. There are a number of
		policies to consider here. The one we'll use is to keep the
		interface index a small number and to return the first unused
		interface index between 1 and MAX_INTERFACE_INDEX.

Note:		Called with database locked

--*/

ULONG
GetNextInterfaceIndex(VOID)
{
    PICB	    icbp;
    PLIST_ENTRY     lep;
    ULONG	    i;

    if((icbp = GetInterfaceByIndex(1)) == NULL) {

	return 1;
    }

    lep = icbp->IndexListLinkage.Flink;
    i = 2;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);
	if(i < icbp->InterfaceIndex) {

	    return i;
	}

	i = icbp->InterfaceIndex + 1;

	if(i == MAX_INTERFACE_INDEX) {

	    // abort
	    SS_ASSERT(FALSE);

	    return i;
	}

	lep = icbp->IndexListLinkage.Flink;
    }

    SS_ASSERT(i < MAX_INTERFACE_INDEX);

    return i;
}




VOID
SetAdapterBindingInfo(PIPX_ADAPTER_BINDING_INFO	    abip,
		       PACB			    acbp)
{
    abip->AdapterIndex = acbp->AdapterIndex;
    memcpy(abip->Network, acbp->AdapterInfo.Network, 4);
    memcpy(abip->LocalNode, acbp->AdapterInfo.LocalNode, 6);
    if(acbp->AdapterInfo.NdisMedium != NdisMediumWan) {

	memcpy(abip->RemoteNode, bcastnode, 6);
    }
    else
    {
	memcpy(abip->RemoteNode, acbp->AdapterInfo.RemoteNode, 6);
    }
    abip->MaxPacketSize = acbp->AdapterInfo.MaxPacketSize;
    abip->LinkSpeed = acbp->AdapterInfo.LinkSpeed;
}


VOID
ExternalBindInterfaceToAdapter(PICB	    icbp)
{
    PACB			   acbp;
    IPX_ADAPTER_BINDING_INFO	   abi;

    acbp = icbp->acbp;

    SetAdapterBindingInfo(&abi, acbp);
    FwBindFwInterfaceToAdapter(icbp->InterfaceIndex, &abi);
    BindRoutingProtocolsIfsToAdapter(icbp->InterfaceIndex, &abi);
}

VOID
ExternalUnbindInterfaceFromAdapter(ULONG    InterfaceIndex)
{
    UnbindRoutingProtocolsIfsFromAdapter(InterfaceIndex);
    FwUnbindFwInterfaceFromAdapter(InterfaceIndex);
}

VOID
ExternalEnableInterface(ULONG	    InterfaceIndex)
{
    RoutingProtocolsEnableIpxInterface(InterfaceIndex);
    FwEnableFwInterface(InterfaceIndex);
}

VOID
ExternalDisableInterface(ULONG	    InterfaceIndex)
{
    FwDisableFwInterface(InterfaceIndex);
    RoutingProtocolsDisableIpxInterface(InterfaceIndex);
}

VOID
RMCreateLocalRoute(PICB     icbp)
{
    PADAPTER_INFO	    aip;

    // check if a network number has been assigned to this interface
    aip = &(icbp->acbp->AdapterInfo);

    if(!memcmp(aip->Network, nullnet, 4)) {

	// no net number
	return;
    }

    // if the interface is a remote workstation and global wan net exists,
    // we are done.
    if((icbp->MIBInterfaceType == IF_TYPE_WAN_WORKSTATION) &&
       EnableGlobalWanNet &&
       !LanOnlyMode) {

	SS_ASSERT(!memcmp(aip->Network, GlobalWanNet, 4));
	return;
    }

    CreateLocalRoute(icbp);
}

VOID
RMDeleteLocalRoute(PICB 	icbp)
{
    PADAPTER_INFO	    aip;

    // check if a network number has been assigned to this interface
    aip = &(icbp->acbp->AdapterInfo);

    if(!memcmp(aip->Network, nullnet, 4)) {

	// no net number
	return;
    }

    // if the interface is a remote workstation and global wan net exists,
    // we are done.
    if((icbp->MIBInterfaceType == IF_TYPE_WAN_WORKSTATION) &&
       EnableGlobalWanNet &&
       !LanOnlyMode) {

	SS_ASSERT(!memcmp(aip->Network, GlobalWanNet, 4));
	return;
    }

    DeleteLocalRoute(icbp);
}

VOID
AdminEnable(PICB	icbp)
{
    PACB			 acbp;
    IPX_ADAPTER_BINDING_INFO	 aii;

    if(icbp->AdminState == ADMIN_STATE_ENABLED) {

	return;
    }

    icbp->AdminState = ADMIN_STATE_ENABLED;

    // XP 497242.  AdminEnable and AdminDisable are always called with the
    // database lock held.  But locking is order is supposed to be from 
    // DDM to the router managers.  So when we callback to DDM, we must 
    // first release our lock.
    //
    RELEASE_DATABASE_LOCK;
    
    InterfaceEnabled (icbp->hDIMInterface, PID_IPX, TRUE);

    ACQUIRE_DATABASE_LOCK;

    if(icbp->acbp != NULL) {

	// bound to adapter
	icbp->OperState = OPER_STATE_UP;

	RMCreateLocalRoute(icbp);
    }
	else {
		switch(icbp->MIBInterfaceType) {

		case IF_TYPE_PERSONAL_WAN_ROUTER:
		case IF_TYPE_WAN_WORKSTATION:
		case IF_TYPE_WAN_ROUTER:
		case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:
			icbp->OperState = OPER_STATE_SLEEPING;
			break;
		default:

			icbp->OperState = OPER_STATE_DOWN;
			break;

		}
	}

    // if REACHABLE, resume advertising routes and services
    if(icbp->InterfaceReachable) {

	// enable all static routes for this interface
	EnableStaticRoutes(icbp->InterfaceIndex);

	// enable external interfaces. Implicitly, this will enable static services
	// bound to this interface to be advertised
	ExternalEnableInterface(icbp->InterfaceIndex);
    }
}

VOID
AdminDisable(PICB	icbp)
{
    if(icbp->AdminState == ADMIN_STATE_DISABLED) {

	return;
    }

    icbp->AdminState = ADMIN_STATE_DISABLED;

    // XP 497242.  AdminEnable and AdminDisable are always called with the
    // database lock held.  But locking is order is supposed to be from 
    // DDM to the router managers.  So when we callback to DDM, we must 
    // first release our lock.
    //
    RELEASE_DATABASE_LOCK;
    
    InterfaceEnabled (icbp->hDIMInterface, PID_IPX, FALSE);

    ACQUIRE_DATABASE_LOCK;

	icbp->OperState = OPER_STATE_DOWN;

    if(icbp->acbp != NULL)
		RMDeleteLocalRoute(icbp);

    // disable all static routes for this interface
    DisableStaticRoutes(icbp->InterfaceIndex);

    // disable external interfaces. Implicitly, static services bound to this
    // interface will stop being advertised.
    ExternalDisableInterface(icbp->InterfaceIndex);
}


NET_INTERFACE_TYPE
MapIpxToNetInterfaceType(PICB		icbp)
{
    NET_INTERFACE_TYPE		NetInterfaceType;

    switch(icbp->MIBInterfaceType) {

	case IF_TYPE_WAN_ROUTER:
	case IF_TYPE_PERSONAL_WAN_ROUTER:

	    NetInterfaceType = DEMAND_DIAL;
	    break;

	case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:

	    NetInterfaceType = LOCAL_WORKSTATION_DIAL;
	    break;

	case IF_TYPE_WAN_WORKSTATION:

	    NetInterfaceType = REMOTE_WORKSTATION_DIAL;
	    break;

	default:

	    NetInterfaceType = PERMANENT;
	    break;
    }

    return NetInterfaceType;
}


/*++

Function:   I_SetFilters

Descr:	    Internal parses the traffic filter info block and sets the filter
	    driver info.

--*/
/*
DWORD
I_SetFilters(ULONG	    InterfaceIndex,
	     ULONG	    FilterMode, // inbound or outbound
	     LPVOID	    FilterInfop)

{
    PIPX_TRAFFIC_FILTER_GLOBAL_INFO	    gip;
    PIPX_TOC_ENTRY			    tocep;
    LPVOID				    FilterDriverInfop;
    ULONG				    FilterDriverInfoSize;
    DWORD				    rc;

    if(FilterInfop == NULL) {

	// remove all filters
	rc = SetFilters(InterfaceIndex,
		    FilterMode, 	  // in or outbound,
		    0,
		    0,
		    NULL,
		    0);

	return rc;
    }

    gip = GetInfoEntry((PIPX_INFO_BLOCK_HEADER)FilterInfop,
		       IPX_TRAFFIC_FILTER_GLOBAL_INFO_TYPE);

    if(gip == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    FilterDriverInfop = GetInfoEntry((PIPX_INFO_BLOCK_HEADER)FilterInfop,
					IPX_TRAFFIC_FILTER_INFO_TYPE);

    if(FilterDriverInfop == NULL) {

	rc = SetFilters(InterfaceIndex,
			FilterMode,	  // in or outbound,
			0,	 // pass or don't pass
			0,	  // filter size
			NULL,
			0);

	return rc;
    }

    tocep = GetTocEntry((PIPX_INFO_BLOCK_HEADER)FilterInfop,
			IPX_TRAFFIC_FILTER_INFO_TYPE);

    FilterDriverInfoSize = tocep->Count * tocep->InfoSize;

    rc = SetFilters(InterfaceIndex,
		    FilterMode, 	  // in or outbound,
		    gip->FilterAction,   // pass or don't pass
		    tocep->InfoSize,	  // filter size
		    FilterDriverInfop,
		    FilterDriverInfoSize);

    return rc;
}
*/
/*++

Function:   I_GetFilters

Descr:	    Internal builds the traffic filters info block from the filter driver
	    information.

--*/
/*
typedef struct	_FILTERS_INFO_HEADER {

    IPX_INFO_BLOCK_HEADER	    Header;
    IPX_TOC_ENTRY		    TocEntry;
    IPX_TRAFFIC_FILTER_GLOBAL_INFO  GlobalInfo;

    } FILTERS_INFO_HEADER, *PFILTERS_INFO_HEADER;

DWORD
I_GetFilters(ULONG	    InterfaceIndex,
	     ULONG	    FilterMode,
	     LPVOID	    FilterInfop,
	     PULONG	    FilterInfoSize)
{
    DWORD			rc;
    ULONG			FilterAction;
    ULONG			FilterSize;
    PFILTERS_INFO_HEADER	fhp;
    LPVOID			FilterDriverInfop;
    ULONG			FilterDriverInfoSize = 0;
    PIPX_TOC_ENTRY		tocep;

    if((FilterInfop == NULL) || (*FilterInfoSize == 0)) {

	// we are asked for size
	rc = GetFilters(InterfaceIndex,
			FilterMode,
			&FilterAction,
			&FilterSize,
			NULL,
			&FilterDriverInfoSize);

	if((rc != NO_ERROR) && (rc != ERROR_INSUFFICIENT_BUFFER)) {

	    return ERROR_CAN_NOT_COMPLETE;
	}

	if(FilterDriverInfoSize) {

	    // there are filters
	    *FilterInfoSize = sizeof(FILTERS_INFO_HEADER) + FilterDriverInfoSize;
	    return ERROR_INSUFFICIENT_BUFFER;
	}
	else
	{
	    // NO filters exist
	    *FilterInfoSize = 0;
	    return NO_ERROR;
	}
    }

    if(*FilterInfoSize <= sizeof(FILTERS_INFO_HEADER)) {

	return ERROR_INSUFFICIENT_BUFFER;
    }

    FilterDriverInfoSize = *FilterInfoSize - sizeof(FILTERS_INFO_HEADER);

    FilterDriverInfop = (LPVOID)((PUCHAR)FilterInfop + sizeof(FILTERS_INFO_HEADER));

    rc = GetFilters(InterfaceIndex,
		    FilterMode,
		    &FilterAction,
		    &FilterSize,
		    FilterDriverInfop,
		    &FilterDriverInfoSize);

    if(rc != NO_ERROR) {

	if(rc == ERROR_MORE_DATA) {

	    *FilterInfoSize = sizeof(FILTERS_INFO_HEADER) + FilterDriverInfoSize;
	    return ERROR_INSUFFICIENT_BUFFER;
	}
	else
	{
	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    // got it
    fhp = (PFILTERS_INFO_HEADER)FilterInfop;
    fhp->Header.Version = IPX_ROUTER_VERSION_1;
    fhp->Header.Size = *FilterInfoSize;
    fhp->Header.TocEntriesCount = 2;

    tocep = fhp->Header.TocEntry;

    tocep->InfoType = IPX_TRAFFIC_FILTER_GLOBAL_INFO_TYPE;
    tocep->InfoSize = sizeof(IPX_TRAFFIC_FILTER_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&(fhp->GlobalInfo) - (PUCHAR)FilterInfop);

    tocep++;

    tocep->InfoType = IPX_TRAFFIC_FILTER_INFO_TYPE;
    tocep->InfoSize = FilterSize;
    tocep->Count = FilterDriverInfoSize / FilterSize;
    tocep->Offset = sizeof(FILTERS_INFO_HEADER);

    fhp->GlobalInfo.FilterAction = FilterAction;

    return NO_ERROR;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\mib.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mib.c

Abstract:

    The MIB handling functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define MIB_CALL_BEGIN {\
	ACQUIRE_DATABASE_LOCK;\
	if(RouterOperState != OPER_STATE_UP){\
	    RELEASE_DATABASE_LOCK;\
	    return ERROR_CAN_NOT_COMPLETE;\
	}\
	MibRefCounter++;\
	RELEASE_DATABASE_LOCK;\
     };

#define MIB_CALL_END {\
	ACQUIRE_DATABASE_LOCK;\
	MibRefCounter--;\
	RELEASE_DATABASE_LOCK;\
	return rc;\
     };


DWORD
MibInvalidFunction(LPVOID    p)
{
    return ERROR_INVALID_FUNCTION;
}

typedef DWORD (*IPX_MIB_SET_HANDLER)(LPVOID);
typedef DWORD (*IPX_MIB_GET_HANDLER)(LPVOID, LPVOID, PULONG);

IPX_MIB_SET_HANDLER	  IpxMibCreate[MAX_IPX_MIB_TABLES] = {

    MibInvalidFunction,		// Create Base
    MibInvalidFunction, 	// CreateInterface
    MibInvalidFunction, 	// Create Route
    MibCreateStaticRoute,
    MibInvalidFunction, 	// Create Service
    MibCreateStaticService

    };


DWORD
MibCreate(ULONG 	ProtocolId,
	  ULONG 	InputDataSize,
	  PVOID 	InputData)
{
    PIPX_MIB_SET_INPUT_DATA	  msip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_SET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	msip = (PIPX_MIB_SET_INPUT_DATA)InputData;

	rc = (*IpxMibCreate[msip->TableId])(&msip->MibRow);
    }
    else
    {
	// to be routed to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibCreate)(InputDataSize, InputData);
    }

Exit:

    MIB_CALL_END;

    return rc;
}

IPX_MIB_SET_HANDLER IpxMibDelete[MAX_IPX_MIB_TABLES] = {

    MibInvalidFunction,		// Delete Base
    MibInvalidFunction, 	// DeleteInterface
    MibInvalidFunction, 	// Delete Route
    MibDeleteStaticRoute,
    MibInvalidFunction, 	// Delete Service
    MibDeleteStaticService

    };

DWORD
MibDelete(ULONG		ProtocolId,
	  ULONG 	InputDataSize,
	  PVOID 	InputData)
{
    PIPX_MIB_SET_INPUT_DATA	  msip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_SET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	msip = (PIPX_MIB_SET_INPUT_DATA)InputData;

	rc = (*IpxMibDelete[msip->TableId])(&msip->MibRow);
    }
    else
    {
	// to be routed to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibDelete)(InputDataSize, InputData);
    }

Exit:

    MIB_CALL_END;

    return rc;
}

IPX_MIB_SET_HANDLER  IpxMibSet[MAX_IPX_MIB_TABLES] = {

    MibInvalidFunction,		// Set Base
    MibSetIpxInterface,		// SetInterface
    MibInvalidFunction, 	// Set Route
    MibSetStaticRoute,
    MibInvalidFunction, 	// Set Service
    MibSetStaticService

    };

DWORD
MibSet(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData)
{
    PIPX_MIB_SET_INPUT_DATA	  msip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_SET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	msip = (PIPX_MIB_SET_INPUT_DATA)InputData;

	rc = (*IpxMibSet[msip->TableId])(&msip->MibRow);
    }
    else
    {
	// to be routed to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibSet)(InputDataSize, InputData);
    }

Exit:

    MIB_CALL_END;

    return rc;
}

IPX_MIB_GET_HANDLER    IpxMibGet[MAX_IPX_MIB_TABLES] = {

    MibGetIpxBase,
    MibGetIpxInterface,
    MibGetRoute,
    MibGetStaticRoute,
    MibGetService,
    MibGetStaticService

    };

DWORD
MibGet(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData)
{
    PIPX_MIB_GET_INPUT_DATA	  mgip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_GET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	mgip = (PIPX_MIB_GET_INPUT_DATA)InputData;

	rc = (*IpxMibGet[mgip->TableId])(&mgip->MibIndex,
					 OutputData,
					 OutputDataSize);
    }
    else
    {
	// to be demux to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibGet)(InputDataSize,
				 InputData,
				 OutputDataSize,
				 OutputData);

    }

Exit:

    MIB_CALL_END;

    return rc;
}

IPX_MIB_GET_HANDLER	IpxMibGetFirst[MAX_IPX_MIB_TABLES] = {

    MibGetIpxBase,
    MibGetFirstIpxInterface,
    MibGetFirstRoute,
    MibGetFirstStaticRoute,
    MibGetFirstService,
    MibGetFirstStaticService

    };

DWORD
MibGetFirst(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData)
{
    PIPX_MIB_GET_INPUT_DATA	  mgip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_GET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	mgip = (PIPX_MIB_GET_INPUT_DATA)InputData;

	rc = (*IpxMibGetFirst[mgip->TableId])(&mgip->MibIndex,
					      OutputData,
					      OutputDataSize);
    }
    else
    {
	// to be demux to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibGetFirst)(InputDataSize,
				 InputData,
				 OutputDataSize,
				 OutputData);
    }

Exit:

    MIB_CALL_END;

    return rc;
}

IPX_MIB_GET_HANDLER	   IpxMibGetNext[MAX_IPX_MIB_TABLES] = {

    MibGetIpxBase,
    MibGetNextIpxInterface,
    MibGetNextRoute,
    MibGetNextStaticRoute,
    MibGetNextService,
    MibGetNextStaticService

    };


DWORD
MibGetNext(ULONG	ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData)
{
    PIPX_MIB_GET_INPUT_DATA	  mgip;
    PRPCB			  rpcbp;
    DWORD			  rc;

    MIB_CALL_BEGIN;

    if(ProtocolId == IPX_PROTOCOL_BASE) {

	if(InputDataSize != sizeof(IPX_MIB_GET_INPUT_DATA)) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	mgip = (PIPX_MIB_GET_INPUT_DATA)InputData;

	rc = (*IpxMibGetNext[mgip->TableId])(&mgip->MibIndex,
					     OutputData,
					     OutputDataSize);
    }
    else
    {
	// to be demux to one of our routing protocols
	if((rpcbp = GetRoutingProtocolCB(ProtocolId)) == NULL) {

	    rc = ERROR_CAN_NOT_COMPLETE;
	    goto Exit;
	}

	rc = (*rpcbp->RP_MibGetNext)(InputDataSize,
				 InputData,
				 OutputDataSize,
				 OutputData);
    }

Exit:

    MIB_CALL_END;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\mibif.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mibif.c

Abstract:

    The IPX MIB Base and Interface Functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


/*++

Function:	MibGetIpxBase

Descr:

--*/

DWORD
MibGetIpxBase(PIPX_MIB_INDEX		    mip,
	      PIPXMIB_BASE		    BaseEntryp,
	      PULONG			    BaseEntrySize)
{
    PICB	icbp;
    PACB	acbp;

    if((BaseEntryp == NULL) || (*BaseEntrySize < sizeof(IPXMIB_BASE))) {

	*BaseEntrySize = sizeof(IPXMIB_BASE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    ACQUIRE_DATABASE_LOCK;

    BaseEntryp->OperState = OPER_STATE_UP;

    // Router is Up -> check that we have the internal interface bound to the
    // internal adapter.
    if((InternalInterfacep == NULL) || (InternalAdapterp == NULL)) {
	    RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    icbp = InternalInterfacep;
    acbp = icbp->acbp;

    memcpy(BaseEntryp->PrimaryNetNumber,
	   acbp->AdapterInfo.Network,
	   4);

    memcpy(BaseEntryp->Node,
	   acbp->AdapterInfo.LocalNode,
	   6);

    GetInterfaceAnsiName(BaseEntryp->SysName, icbp->InterfaceNamep);

    BaseEntryp->MaxPathSplits = 1;
    BaseEntryp->IfCount = InterfaceCount;

    // fill in the dest count
    BaseEntryp->DestCount = RtmGetNetworkCount(RTM_PROTOCOL_FAMILY_IPX);

    // fill in the services count
    BaseEntryp->ServCount = GetServiceCount();

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

VOID
GetMibInterface(PICB		    icbp,
		PIPX_INTERFACE	    Ifp);

/*++

Function:	MibGetIpxInterface

Descr:

--*/

DWORD
MibGetIpxInterface(PIPX_MIB_INDEX		      mip,
		   PIPX_INTERFACE		      Ifp,
		   PULONG			      IfSize)
{
    PICB		  icbp;

    if((Ifp == NULL) || (*IfSize < sizeof(IPX_INTERFACE))) {

	*IfSize = sizeof(IPX_INTERFACE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Ifp->InterfaceIndex = mip->InterfaceTableIndex.InterfaceIndex;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(Ifp->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    GetMibInterface(icbp, Ifp);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

/*++

Function:	MibGetFirstIpxInterface

Descr:

--*/

DWORD
MibGetFirstIpxInterface(PIPX_MIB_INDEX		      mip,
			PIPX_INTERFACE		      Ifp,
			PULONG			      IfSize)
{
    PICB		  icbp;

    if((Ifp == NULL) || (*IfSize < sizeof(IPX_INTERFACE))) {

	*IfSize = sizeof(IPX_INTERFACE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    ACQUIRE_DATABASE_LOCK;

    if(IsListEmpty(&IndexIfList)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    icbp = CONTAINING_RECORD(IndexIfList.Flink, ICB, IndexListLinkage);

    GetMibInterface(icbp, Ifp);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

/*++

Function:	MibGetNextIpxInterface

Descr:

--*/

DWORD
MibGetNextIpxInterface(PIPX_MIB_INDEX		      mip,
		       PIPX_INTERFACE		      Ifp,
		       PULONG			      IfSize)
{
    PICB		  icbp;
    PLIST_ENTRY 	  lep;

    if((Ifp == NULL) || (*IfSize < sizeof(IPX_INTERFACE))) {

	*IfSize = sizeof(IPX_INTERFACE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Ifp->InterfaceIndex = mip->InterfaceTableIndex.InterfaceIndex;

    // scan the ordered interface list until we get to this interface or to
    // an interface with a higher index (meaning this interface has been removed)

    ACQUIRE_DATABASE_LOCK;

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList) {

	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);

	if(Ifp->InterfaceIndex == icbp->InterfaceIndex) {

	    // found, get the next interface and return
	    if(icbp->IndexListLinkage.Flink == &IndexIfList) {

		// this was the last entry in the list, stop here
		RELEASE_DATABASE_LOCK;
		return ERROR_NO_MORE_ITEMS;
	    }

	    icbp = CONTAINING_RECORD(icbp->IndexListLinkage.Flink,
				     ICB,
				     IndexListLinkage);

	    GetMibInterface(icbp, Ifp);

	    RELEASE_DATABASE_LOCK;
	    return NO_ERROR;
	}

	if(Ifp->InterfaceIndex < icbp->InterfaceIndex) {

	    // the interface has been removed. We return the next interface
	    // in the index order
	    GetMibInterface(icbp, Ifp);

	    RELEASE_DATABASE_LOCK;
	    return NO_ERROR;
	}
	else
	{
	    lep = icbp->IndexListLinkage.Flink;
	}
    }

    // didn't find anything

    RELEASE_DATABASE_LOCK;

    return ERROR_NO_MORE_ITEMS;
}

/*++

Function:	MibSetIpxInterface

Descr:		The SNMP manager can set the following parameters on an interface:

		- AdminState
		- NetbiosAccept
		- NetbiosDeliver

--*/

DWORD
MibSetIpxInterface(PIPX_MIB_ROW     MibRowp)
{
    PIPX_INTERFACE  Ifp;
    FW_IF_INFO	    FwIfInfo;
    PICB	    icbp;

    Ifp = &MibRowp->Interface;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(Ifp->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;

	return ERROR_INVALID_PARAMETER;
    }

    // set the new states in the forwarder
    FwIfInfo.NetbiosAccept = Ifp->NetbiosAccept;
    FwIfInfo.NetbiosDeliver = Ifp->NetbiosDeliver;

    FwSetInterface(icbp->InterfaceIndex, &FwIfInfo);

    // if the current admin state doesn't match the new admin state, set the
    // new admin state.
    if(icbp->AdminState != Ifp->AdminState) {

	if(Ifp->AdminState == ADMIN_STATE_ENABLED) {

	    AdminEnable(icbp);
	}
	else
	{
	    AdminDisable(icbp);
	}
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

/*++

Function:	GetMibInterface

Descr:		Gets the ipx mib interface data from the router manager
		data structures.

Remark: 	Called only in critical section

--*/

VOID
GetMibInterface(PICB		    icbp,
		PIPX_INTERFACE	    Ifp)
{
    PACB		  acbp;
    FW_IF_INFO		  FwIfInfo;

    Ifp->InterfaceIndex = icbp->InterfaceIndex;

    // get the forwarder interface data
    FwGetInterface(icbp->InterfaceIndex,
		   &FwIfInfo,
		   &Ifp->IfStats);

    Ifp->AdminState = icbp->AdminState;
    Ifp->IfStats.IfOperState = icbp->OperState;
    Ifp->NetbiosAccept = FwIfInfo.NetbiosAccept;
    Ifp->NetbiosDeliver = FwIfInfo.NetbiosDeliver;

    // fill in the rest from the icb
    if(icbp->acbp) {

	acbp = icbp->acbp;

	Ifp->AdapterIndex = acbp->AdapterIndex;
	Ifp->MediaType = acbp->AdapterInfo.NdisMedium;
    if (Ifp->IfStats.IfOperState==OPER_STATE_UP) {
	    memcpy(Ifp->NetNumber, acbp->AdapterInfo.Network, 4);
	    memcpy(Ifp->MacAddress, acbp->AdapterInfo.LocalNode, 6);
        if (acbp->AdapterInfo.LinkSpeed>0) {
            ULONGLONG speed = 100i64*acbp->AdapterInfo.LinkSpeed;
            if (speed<MAXLONG)
                Ifp->Throughput = (ULONG)speed;
            else
                Ifp->Throughput = MAXLONG;


            Ifp->Delay = (ULONG)(8000000i64/speed);
        }
        else {
	        Ifp->Delay = 0;
	        Ifp->Throughput = 0;
        }
    }
    else {
	    memset(Ifp->NetNumber, 0 ,4);
	    memset(Ifp->MacAddress, 0, 4);
	    Ifp->Delay = 0;
	    Ifp->Throughput = 0;
    }

	// !!! fill in delay and throughput from link speed
    }
    else
    {
	Ifp->AdapterIndex = 0;
	Ifp->MediaType = 0;
	memset(Ifp->NetNumber, 0 ,4);
	memset(Ifp->MacAddress, 0, 4);
	Ifp->Delay = 0;
	Ifp->Throughput = 0;
    }

    GetInterfaceAnsiName(Ifp->InterfaceName, icbp->InterfaceNamep);
    Ifp->InterfaceType = icbp->MIBInterfaceType;
    Ifp->EnableIpxWanNegotiation = icbp->EnableIpxWanNegotiation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\mibroute.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mibroute.c

Abstract:

    The MIB handling functions for the Forwarding Group (Routes & Static Routes)

Author:

    Stefan Solomon  05/02/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

DWORD
MibGetRoute(PIPX_MIB_INDEX		    mip,
	    PIPX_ROUTE			    Route,
	    PULONG			    RouteSize)
{
    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    memcpy(Route->Network, mip->RoutingTableIndex.Network, 4);

    return(GetRoute(IPX_DEST_TABLE, Route));
}



DWORD
MibGetFirstRoute(PIPX_MIB_INDEX		    mip,
		 PIPX_ROUTE		    Route,
		 PULONG			    RouteSize)
{
    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    return(GetFirstRoute(IPX_DEST_TABLE, Route));
}

DWORD
MibGetNextRoute(PIPX_MIB_INDEX		    mip,
		PIPX_ROUTE		    Route,
		PULONG			    RouteSize)
{
    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    memcpy(Route->Network, mip->RoutingTableIndex.Network, 4);

    return(GetNextRoute(IPX_DEST_TABLE, Route));
}

DWORD
MibCreateStaticRoute(PIPX_MIB_ROW	 MibRowp)
{
    PIPX_ROUTE			 NewRoutep;
    IPX_ROUTE			 OldRoute;
    PICB			 icbp;
    IPX_STATIC_ROUTE_INFO	 strtinfo;
    DWORD			 rc;

    NewRoutep = &MibRowp->Route;
    OldRoute = *NewRoutep;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(NewRoutep->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    // if this static route already exists, delete it
    if(GetRoute(IPX_STATIC_ROUTE_TABLE, &OldRoute) == NO_ERROR) {

	memcpy(&strtinfo.Network,
	       OldRoute.Network,
	       4);
	strtinfo.TickCount = OldRoute.TickCount;
	strtinfo.HopCount = OldRoute.HopCount;
	memcpy(&strtinfo.NextHopMacAddress,
	       OldRoute.NextHopMacAddress,
	       6);

	if(DeleteStaticRoute(OldRoute.InterfaceIndex,
			     &strtinfo) != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;
	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    memcpy(&strtinfo.Network,
	   NewRoutep->Network,
	   4);
    strtinfo.TickCount = NewRoutep->TickCount;
    strtinfo.HopCount = NewRoutep->HopCount;
    memcpy(&strtinfo.NextHopMacAddress,
	   NewRoutep->NextHopMacAddress,
	   6);

    rc = CreateStaticRoute(icbp, &strtinfo);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
MibDeleteStaticRoute(PIPX_MIB_ROW	 MibRowp)
{
    PIPX_ROUTE			 Route;
    PICB			 icbp;
    IPX_STATIC_ROUTE_INFO	 strtinfo;
    DWORD			 rc;

    Route = &MibRowp->Route;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(Route->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    memcpy(&strtinfo.Network,
	   Route->Network,
	   4);
    strtinfo.TickCount = Route->TickCount;
    strtinfo.HopCount = Route->HopCount;
    memcpy(&strtinfo.NextHopMacAddress,
	   Route->NextHopMacAddress,
	   6);

    rc = DeleteStaticRoute(Route->InterfaceIndex,
			   &strtinfo);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
MibGetStaticRoute(PIPX_MIB_INDEX	    mip,
		  PIPX_ROUTE		    Route,
		  PULONG		    RouteSize)
{
    DWORD	rc;

    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Route->InterfaceIndex = mip->StaticRoutesTableIndex.InterfaceIndex;
    memcpy(Route->Network, mip->StaticRoutesTableIndex.Network, 4);

    return(GetRoute(IPX_STATIC_ROUTE_TABLE, Route));
}

DWORD
MibGetFirstStaticRoute(PIPX_MIB_INDEX	    mip,
		       PIPX_ROUTE	    Route,
		       PULONG		    RouteSize)
{
    ULONG   InterfaceIndex;
    DWORD   rc;

    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    ACQUIRE_DATABASE_LOCK;

    if(EnumerateFirstInterfaceIndex(&InterfaceIndex)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_NO_MORE_ITEMS;
    }

    RELEASE_DATABASE_LOCK;

    Route->InterfaceIndex = InterfaceIndex;
    rc = GetFirstRoute(IPX_STATIC_ROUTE_TABLE, Route);

    if(rc == NO_ERROR) {

	return rc;
    }

    // no more static routes for this interface. Find the next interface
    // which has static routes

    ACQUIRE_DATABASE_LOCK;

    while(rc != NO_ERROR)
    {
	if(EnumerateNextInterfaceIndex(&InterfaceIndex)) {

	    rc = ERROR_NO_MORE_ITEMS;
	    break;
	 }
	 else
	 {
	    Route->InterfaceIndex = InterfaceIndex;
	    rc = GetFirstRoute(IPX_STATIC_ROUTE_TABLE, Route);
	 }
    }

    RELEASE_DATABASE_LOCK;

    return rc;

}

DWORD
MibGetNextStaticRoute(PIPX_MIB_INDEX	    mip,
		      PIPX_ROUTE	    Route,
		      PULONG		    RouteSize)
{
    DWORD   rc;
    ULONG   InterfaceIndex;

    if((Route == NULL) || (*RouteSize < sizeof(IPX_ROUTE))) {

	*RouteSize = sizeof(IPX_ROUTE);
	return ERROR_INSUFFICIENT_BUFFER;
    }

    Route->InterfaceIndex = mip->StaticRoutesTableIndex.InterfaceIndex;
    memcpy(Route->Network, mip->StaticRoutesTableIndex.Network, 4);

    rc = GetNextRoute(IPX_STATIC_ROUTE_TABLE, Route);

    if(rc == NO_ERROR) {

	return rc;
    }

    // no more static routes for this interface. Find the next interface
    // which has static routes

    InterfaceIndex = mip->StaticRoutesTableIndex.InterfaceIndex;

    ACQUIRE_DATABASE_LOCK;

    while(rc != NO_ERROR)
    {
	if(EnumerateNextInterfaceIndex(&InterfaceIndex)) {

	    rc = ERROR_NO_MORE_ITEMS;
	    break;
	 }
	 else
	 {
	    Route->InterfaceIndex = InterfaceIndex;
	    rc = GetFirstRoute(IPX_STATIC_ROUTE_TABLE, Route);
	 }
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
MibSetStaticRoute(PIPX_MIB_ROW	 MibRowp)
{
    PIPX_ROUTE			 NewRoutep;
    IPX_ROUTE			 OldRoute;
    PICB			 icbp;
    IPX_STATIC_ROUTE_INFO	 strtinfo;
    DWORD			 rc;

    NewRoutep = &MibRowp->Route;
    OldRoute = *NewRoutep;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(OldRoute.InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    // first, delete this route if it exists
    if(GetRoute(IPX_STATIC_ROUTE_TABLE, &OldRoute) != NO_ERROR) {

	// route doesn't exist
	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    memcpy(&strtinfo.Network,
	   OldRoute.Network,
	   4);
    strtinfo.TickCount = OldRoute.TickCount;
    strtinfo.HopCount = OldRoute.HopCount;
    memcpy(&strtinfo.NextHopMacAddress,
	   OldRoute.NextHopMacAddress,
	   6);

    if(DeleteStaticRoute(OldRoute.InterfaceIndex,
			   &strtinfo) != NO_ERROR) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    memcpy(&strtinfo.Network,
	   NewRoutep->Network,
	   4);
    strtinfo.TickCount = NewRoutep->TickCount;
    strtinfo.HopCount = NewRoutep->HopCount;
    memcpy(&strtinfo.NextHopMacAddress,
	   NewRoutep->NextHopMacAddress,
	   6);

    // add it again with the new parameters
    rc = CreateStaticRoute(icbp,
			   &strtinfo);

    RELEASE_DATABASE_LOCK;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <raserror.h>
#include <dim.h>
#include <rtm.h>
#include <rmrtm.h>
#include <ipxrtprt.h>
#include <mprlog.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <adapter.h>
#include <fwif.h>
#include <rtutils.h>
#include <ipxcpif.h>
#include "rtrdbg.h"
#include "mibprot.h"
#include "rtrmgr.h"
#include "rtrprot.h"
#include "utils.h"
#include "ipxanet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtrdbg.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtrdbg.h

Abstract:

    This module contains the debug utilities definitions

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _RTRDBG_
#define _RTRDBG_

extern HANDLE      RMEventLogHdl;
extern DWORD       RMEventLogMask;
#define IF_LOG(Event)                       \
    if ((RMEventLogHdl!=NULL) && ((Event&RMEventLogMask)==Event))


#define INIT_TRACE			0x00010000
#define ADAPTER_TRACE			0x00020000
#define INTERFACE_TRACE			0x00040000
#define BIND_TRACE			0x00080000
#define RPAL_TRACE			0x00100000
#define CONNREQ_TRACE			0x00200000
#define ROUTE_TRACE			0x00400000
#define IPXCPIF_TRACE			0x00800000
#define UPDATE_TRACE			0x01000000
#define ROUTER_ALERT			0x80000000

#if DBG

extern DWORD	DbgLevel;

#define DEBUG if ( TRUE )
#define IF_DEBUG(flag) if (DbgLevel & (DEBUG_ ## flag))

VOID
SsDbgInitialize(VOID);

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID
SsPrintf (
    char *Format,
    ...
    );

#define SS_DBGINITIALIZE  SsDbgInitialize()

#define SS_PRINT(args) SsPrintf args

#define SS_ASSERT(exp) if (!(exp)) SsAssert( #exp, __FILE__, __LINE__ )

#else

#define DEBUG if ( FALSE )
#define IF_DEBUG(flag) if (FALSE)

#define SS_DBGINITIALIZE

#define SS_PRINT(args)

#define SS_ASSERT(exp)

#endif // DBG

//*** Definitions to enable debug printing

#define DEFAULT_DEBUG		    0x0FFFF

#endif // ndef _RTRDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtmif.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmif.c

Abstract:

    Static & local routes management functions

Author:

    Stefan Solomon  03/13/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

extern UCHAR	bcastnode[6];

INT
NetNumCmpFunc(PDWORD	    Net1,
	      PDWORD	    Net2);
INT
NextHopAddrCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p);

BOOL
FamSpecDataCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p);

INT
NetNumHashFunc(PDWORD		Net);

INT
RouteMetricCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p);

DWORD
RouteValidateFunc(PRTM_IPX_ROUTE	Routep);


RTM_PROTOCOL_FAMILY_CONFIG Config = {

    0,
    0,
    sizeof(RTM_IPX_ROUTE),
    NetNumCmpFunc,
    NextHopAddrCmpFunc,
    FamSpecDataCmpFunc,
    RouteMetricCmpFunc,
    NetNumHashFunc,
    RouteValidateFunc,
    FwUpdateRouteTable
};

USHORT
tickcount(UINT	    linkspeed);

/*++

Function:	CreateRouteTable

Descr:		Creates the IPX route table in RTM

--*/

DWORD
CreateRouteTable(VOID)
{
    DWORD	rc;

    Config.RPFC_MaxTableSize = MaxRoutingTableSize;
    Config.RPFC_HashSize = RoutingTableHashSize;

    rc = RtmCreateRouteTable(
		RTM_PROTOCOL_FAMILY_IPX,
		&Config);

    return rc;
}

/*++

Function:	DeleteRouteTable

Descr:		Creates the IPX route table in RTM

--*/

DWORD
DeleteRouteTable(VOID)
{
    DWORD	rc;

    rc = RtmDeleteRouteTable(RTM_PROTOCOL_FAMILY_IPX);

    return rc;
}




/*++

Function:	StaticToRtmRoute

Descr:		Creates a RTM IPX route entry out of an IPX_STATIC_ROUTE_INFO

--*/

VOID
StaticToRtmRoute(PRTM_IPX_ROUTE		   RtmRoutep,
         ULONG                      IfIndex,
		 PIPX_STATIC_ROUTE_INFO    StaticRouteInfop)
{
    RtmRoutep->R_Interface = IfIndex;
    RtmRoutep->R_Protocol = IPX_PROTOCOL_STATIC;

    GETLONG2ULONG(&RtmRoutep->R_Network, StaticRouteInfop->Network);

    RtmRoutep->R_TickCount = StaticRouteInfop->TickCount;
    RtmRoutep->R_HopCount = StaticRouteInfop->HopCount;
    memcpy(RtmRoutep->R_NextHopMacAddress,
	   StaticRouteInfop->NextHopMacAddress,
	   6);

    RtmRoutep->R_Flags = 0;
}

VOID
RtmToStaticRoute(PIPX_STATIC_ROUTE_INFO     StaticRouteInfop,
		 PRTM_IPX_ROUTE		    RtmRoutep)
{
    PUTULONG2LONG(StaticRouteInfop->Network, RtmRoutep->R_Network);

    StaticRouteInfop->TickCount = (USHORT)(RtmRoutep->R_TickCount);
    StaticRouteInfop->HopCount = RtmRoutep->R_HopCount;
    memcpy(StaticRouteInfop->NextHopMacAddress,
	   RtmRoutep->R_NextHopMacAddress,
	   6);
}

VOID
RtmToIpxRoute(PIPX_ROUTE	    IpxRoutep,
	      PRTM_IPX_ROUTE	    RtmRoutep)
{
    IpxRoutep->InterfaceIndex = (ULONG)(RtmRoutep->R_Interface);
    IpxRoutep->Protocol = RtmRoutep->R_Protocol;

    PUTULONG2LONG(IpxRoutep->Network, RtmRoutep->R_Network);

    IpxRoutep->TickCount = (USHORT)(RtmRoutep->R_TickCount);
    IpxRoutep->HopCount = RtmRoutep->R_HopCount;
    memcpy(IpxRoutep->NextHopMacAddress,
	   RtmRoutep->R_NextHopMacAddress,
	   6);

    IpxRoutep->Flags = RtmRoutep->R_Flags;
}

DWORD
CreateStaticRoute(PICB			    icbp,
		  PIPX_STATIC_ROUTE_INFO    StaticRouteInfop)
{
    DWORD	    rc, flags;
    RTM_IPX_ROUTE	    RtmRoute;

    StaticToRtmRoute(&RtmRoute, icbp->InterfaceIndex, StaticRouteInfop);

    if (icbp->AdminState==ADMIN_STATE_DISABLED)
        RtmRoute.R_Flags = DO_NOT_ADVERTISE_ROUTE;
    rc = RtmAddRoute(RtmStaticHandle,
		     &RtmRoute,
		     INFINITE,
		     &flags,
		     NULL,
		     NULL);

    SS_ASSERT(rc == NO_ERROR);

    if (icbp->AdminState==ADMIN_STATE_DISABLED) {
        DisableStaticRoute (icbp->InterfaceIndex, StaticRouteInfop->Network);
        RtmRoute.R_Flags = 0;
        rc = RtmAddRoute(RtmStaticHandle,
                &RtmRoute,
                INFINITE,
                &flags,
                NULL,
                NULL);
        SS_ASSERT (rc == NO_ERROR);
    }

    return rc;
}


DWORD
DeleteStaticRoute(ULONG			    IfIndex,
		  PIPX_STATIC_ROUTE_INFO    StaticRouteInfop)
{
    DWORD	    rc;
    DWORD	    RtmFlags;
    RTM_IPX_ROUTE	    RtmRoute;

    StaticToRtmRoute(&RtmRoute, IfIndex, StaticRouteInfop);

    rc = RtmDeleteRoute(RtmStaticHandle,
		     &RtmRoute,
		     &RtmFlags,
		     NULL
		     );

    SS_ASSERT(rc == NO_ERROR);

    return rc;
}

VOID
DeleteAllStaticRoutes(ULONG	    InterfaceIndex)
{
    RTM_IPX_ROUTE		RtmCriteriaRoute;

    Trace(ROUTE_TRACE, "DeleteAllStaticRoutes: Entered for if # %d\n", InterfaceIndex);

    memset(&RtmCriteriaRoute,
	   0,
	   sizeof(RTM_IPX_ROUTE));

    RtmCriteriaRoute.R_Interface = InterfaceIndex;
    RtmCriteriaRoute.R_Protocol = IPX_PROTOCOL_STATIC;

    RtmBlockDeleteRoutes(RtmStaticHandle,
		      RTM_ONLY_THIS_INTERFACE,
		      &RtmCriteriaRoute);
}


VOID
LocalToRtmRoute(PRTM_IPX_ROUTE	    RtmRoutep,
		PICB		    icbp)
{
    RtmRoutep->R_Interface = icbp->InterfaceIndex;
    RtmRoutep->R_Protocol = IPX_PROTOCOL_LOCAL;

    GETLONG2ULONG(&RtmRoutep->R_Network, icbp->acbp->AdapterInfo.Network);

    RtmRoutep->R_TickCount = tickcount(icbp->acbp->AdapterInfo.LinkSpeed);
    RtmRoutep->R_HopCount = 1;
    memset(RtmRoutep->R_NextHopMacAddress,
	   0,
	   6);

    // if this is a local workstation dialout interface, then do not
    // advertise this route over any protocol
    if(icbp->MIBInterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

	RtmRoutep->R_Flags = DO_NOT_ADVERTISE_ROUTE;
    }
    else
    {
	RtmRoutep->R_Flags = 0;
    }
}


DWORD
CreateLocalRoute(PICB	icbp)
{
    DWORD		    rc, flags;
    RTM_IPX_ROUTE	    RtmRoute;

    if(!memcmp(icbp->acbp->AdapterInfo.Network, nullnet, 4)) {

	Trace(ROUTE_TRACE, "CreateLocalRoute: Can't create local NULL route !\n");
	return NO_ERROR;
    }

    LocalToRtmRoute(&RtmRoute, icbp);

    rc = RtmAddRoute(RtmLocalHandle,
		     &RtmRoute,
		     INFINITE,
		     &flags,
		     NULL,
		     NULL);

    SS_ASSERT(rc == NO_ERROR);

    return rc;
}



DWORD
DeleteLocalRoute(PICB	icbp)
{
    DWORD	    rc;
    RTM_IPX_ROUTE	    RtmRoute;
    DWORD	    RtmFlags;

    LocalToRtmRoute(&RtmRoute, icbp);

    rc = RtmDeleteRoute(RtmLocalHandle,
			&RtmRoute,
			&RtmFlags,
			NULL);

    SS_ASSERT(rc == NO_ERROR);

    return rc;
}

VOID
GlobalToRtmRoute(PRTM_IPX_ROUTE     RtmRoutep,
		 PUCHAR 	    Network)
{
    RtmRoutep->R_Interface = GLOBAL_INTERFACE_INDEX;
    RtmRoutep->R_Protocol = IPX_PROTOCOL_LOCAL;

    GETLONG2ULONG(&RtmRoutep->R_Network, Network);

    RtmRoutep->R_TickCount = 15;	// a good default value -> should be a config param ??? !!!
    RtmRoutep->R_HopCount = 1;
    memset(RtmRoutep->R_NextHopMacAddress, 0, 6);

    RtmRoutep->R_Flags = GLOBAL_WAN_ROUTE;
}


/*++

Function:	CreateGlobalRoute

Descr:		Creates a route which doesn't have a corresponding interface
		but represents a set of interfaces (e.g. all client wan
		interfaces).
		The interface index for this route is the "global interface"
		index.

--*/

DWORD
CreateGlobalRoute(PUCHAR	  Network)
{
    DWORD		    rc, flags;
    RTM_IPX_ROUTE	    RtmRoute;

    Trace(ROUTE_TRACE, "CreateGlobalRoute: Entered for route %.2x%.2x%.2x%.2x\n",
		   Network[0],
		   Network[1],
		   Network[2],
		   Network[3]);

    GlobalToRtmRoute(&RtmRoute, Network);

    rc = RtmAddRoute(RtmLocalHandle,
		     &RtmRoute,
		     INFINITE,
		     &flags,
		     NULL,
		     NULL);

    SS_ASSERT(rc == NO_ERROR);

    return rc;
}

DWORD
DeleteGlobalRoute(PUCHAR    Network)
{
    DWORD	    rc;
    RTM_IPX_ROUTE   RtmRoute;
    DWORD	    RtmFlags;

    Trace(ROUTE_TRACE, "DeleteGlobalRoute: Entered for route %.2x%.2x%.2x%.2x\n",
		   Network[0],
		   Network[1],
		   Network[2],
		   Network[3]);

    GlobalToRtmRoute(&RtmRoute, Network);

    rc = RtmDeleteRoute(RtmLocalHandle,
			&RtmRoute,
			&RtmFlags,
			NULL);

    SS_ASSERT(rc == NO_ERROR);

    return rc;
}

DWORD
GetRoute(ULONG		RoutingTable,
	 PIPX_ROUTE	IpxRoutep)
{
    RTM_IPX_ROUTE	RtmRoute;
    DWORD		EnumFlags;
    DWORD		rc;

    switch(RoutingTable) {

	case IPX_DEST_TABLE:

	    EnumFlags = RTM_ONLY_THIS_NETWORK |
			RTM_ONLY_BEST_ROUTES | RTM_INCLUDE_DISABLED_ROUTES;

	    GETLONG2ULONG(&RtmRoute.R_Network, IpxRoutep->Network);

	    break;

	case IPX_STATIC_ROUTE_TABLE:

	    EnumFlags = RTM_ONLY_THIS_NETWORK |
			RTM_ONLY_THIS_INTERFACE |
			RTM_ONLY_THIS_PROTOCOL |
			RTM_INCLUDE_DISABLED_ROUTES;

	    RtmRoute.R_Interface = (IpxRoutep->InterfaceIndex);
	    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;

	    GETLONG2ULONG(&RtmRoute.R_Network, IpxRoutep->Network);

	    break;

	default:

	    SS_ASSERT(FALSE);
	    return ERROR_INVALID_PARAMETER;
	    break;
    }

    rc = RtmGetFirstRoute(
			 RTM_PROTOCOL_FAMILY_IPX,
			 EnumFlags,
			 &RtmRoute);

    RtmToIpxRoute(IpxRoutep, &RtmRoute);

    return rc;
}

/*++

Function:		IsRoute

Descr:			returns TRUE if there is a route to the specified
			network

--*/

BOOL
IsRoute(PUCHAR		Network)
{
    RTM_IPX_ROUTE		RtmRoute;
    DWORD		EnumFlags;
    DWORD		rc;


    EnumFlags = RTM_ONLY_THIS_NETWORK |
		RTM_ONLY_BEST_ROUTES |
		RTM_INCLUDE_DISABLED_ROUTES;

    GETLONG2ULONG(&RtmRoute.R_Network, Network);

    rc = RtmGetFirstRoute(
			 RTM_PROTOCOL_FAMILY_IPX,
			 EnumFlags,
			 &RtmRoute);

    if(rc == NO_ERROR) {

	return TRUE;
    }

    return FALSE;
}


//********************************************************************************
//										 *
// Fast Enumeration Functions - Used by the Router Manager for internal purposes *
//										 *
//********************************************************************************

HANDLE
CreateStaticRoutesEnumHandle(ULONG    InterfaceIndex)
{
    RTM_IPX_ROUTE	EnumCriteriaRoute;
    HANDLE		EnumHandle;

    memset(&EnumCriteriaRoute, 0, sizeof(RTM_IPX_ROUTE));

    EnumCriteriaRoute.R_Interface = InterfaceIndex;
    EnumCriteriaRoute.R_Protocol = IPX_PROTOCOL_STATIC;

    EnumHandle = RtmCreateEnumerationHandle(RTM_PROTOCOL_FAMILY_IPX,
			       RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL | RTM_INCLUDE_DISABLED_ROUTES,
			       &EnumCriteriaRoute);

    if((EnumHandle == NULL) && (GetLastError() != ERROR_NO_ROUTES)) {

	Trace(ROUTE_TRACE, "CreateStaticRoutesEnumHandle: RtmCreateEnumerationHandle failed with %d\n", GetLastError());
	SS_ASSERT(FALSE);
    }

    return EnumHandle;
}

DWORD
GetNextStaticRoute(HANDLE			EnumHandle,
		   PIPX_STATIC_ROUTE_INFO	StaticRtInfop)
{
    RTM_IPX_ROUTE   RtmRoute;
    DWORD	    rc;

    rc = RtmEnumerateGetNextRoute(EnumHandle,
				  &RtmRoute);

    SS_ASSERT((rc == NO_ERROR) || (rc == ERROR_NO_MORE_ROUTES));

    RtmToStaticRoute(StaticRtInfop, &RtmRoute);

    return rc;
}

VOID
CloseStaticRoutesEnumHandle(HANDLE EnumHandle)
{
    if(EnumHandle) {

	RtmCloseEnumerationHandle(EnumHandle);
    }
}


//********************************************************************************
//										 *
// Slow Enumeration Functions - Used by the Router Manager for MIB APIs support  *
//										 *
//********************************************************************************


DWORD
GetFirstRoute(ULONG		   RoutingTable,
	      PIPX_ROUTE	   IpxRoutep)
{
    RTM_IPX_ROUTE	       RtmRoute;
    DWORD	       EnumFlags;
    DWORD	       rc;


    switch(RoutingTable) {

	case IPX_DEST_TABLE:

	    // get the first route in the best routes table
	    EnumFlags = RTM_ONLY_BEST_ROUTES | RTM_INCLUDE_DISABLED_ROUTES;
	    break;

	case IPX_STATIC_ROUTE_TABLE:

	    // get the first route in the static routes table for this
	    // interface
	    EnumFlags = RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL | RTM_INCLUDE_DISABLED_ROUTES;
	    RtmRoute.R_Interface = IpxRoutep->InterfaceIndex;
	    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;
	    break;

	default:

	    SS_ASSERT(FALSE);
	    return ERROR_INVALID_PARAMETER;
	    break;
    }

    rc = RtmGetFirstRoute(
			 RTM_PROTOCOL_FAMILY_IPX,
			 EnumFlags,
			 &RtmRoute);

    RtmToIpxRoute(IpxRoutep, &RtmRoute);

    return rc;
}


DWORD
GetNextRoute(ULONG		    RoutingTable,
	     PIPX_ROUTE 	    IpxRoutep)
{
    RTM_IPX_ROUTE		RtmRoute;
    DWORD		EnumFlags;
    DWORD		rc;

    ZeroMemory(&RtmRoute, sizeof(RtmRoute));
    GETLONG2ULONG(&RtmRoute.R_Network, IpxRoutep->Network);

    switch(RoutingTable) {

	case IPX_DEST_TABLE:

	    // get next route in the best routes table
	    EnumFlags = RTM_ONLY_BEST_ROUTES | RTM_INCLUDE_DISABLED_ROUTES;
	    break;

	case IPX_STATIC_ROUTE_TABLE:

	    // get next route in the static routes table for this interface
	    EnumFlags = RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL | RTM_INCLUDE_DISABLED_ROUTES;
	    RtmRoute.R_Interface = (IpxRoutep->InterfaceIndex);
	    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;
	    memcpy(RtmRoute.R_NextHopMacAddress, bcastnode, 6);
	    break;

	default:

	    SS_ASSERT(FALSE);
	    return ERROR_INVALID_PARAMETER;
	    break;
    }

    rc = RtmGetNextRoute(
			 RTM_PROTOCOL_FAMILY_IPX,
			 EnumFlags,
			 &RtmRoute);

    RtmToIpxRoute(IpxRoutep, &RtmRoute);

    return rc;
}


//
// Convert routes added by updating routes protocol to static routes
//

/*++

Function:	ConvertProtocolRoutesToStatic

Descr:

--*/

VOID
ConvertAllProtocolRoutesToStatic(ULONG	    InterfaceIndex,
			      ULONG	    RoutingProtocolId)
{
    RTM_IPX_ROUTE	RtmRoute;
    DWORD	EnumFlags;
    DWORD	rc;

    EnumFlags = RTM_ONLY_THIS_INTERFACE | RTM_ONLY_THIS_PROTOCOL;

    memset(&RtmRoute, 0, sizeof(RTM_IPX_ROUTE));

    RtmRoute.R_Interface = InterfaceIndex;
    RtmRoute.R_Protocol = RoutingProtocolId;

    rc = RtmBlockConvertRoutesToStatic(
			RtmStaticHandle,
			EnumFlags,
			&RtmRoute);
    return;
}

VOID
DisableStaticRoutes(ULONG	    InterfaceIndex)
{
    RTM_IPX_ROUTE	RtmRoute;
    DWORD		EnumFlags;
    DWORD		rc;

    EnumFlags = RTM_ONLY_THIS_INTERFACE;

    memset(&RtmRoute, 0, sizeof(RTM_IPX_ROUTE));

    RtmRoute.R_Interface = InterfaceIndex;
    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;

    rc = RtmBlockDisableRoutes(
			RtmStaticHandle,
			EnumFlags,
			&RtmRoute);
    return;
}


VOID
DisableStaticRoute(ULONG       InterfaceIndex, PUCHAR Network)
{
    RTM_IPX_ROUTE   RtmRoute;
    DWORD       EnumFlags;
    DWORD       rc;

    EnumFlags = RTM_ONLY_THIS_INTERFACE|RTM_ONLY_THIS_NETWORK;

    memset(&RtmRoute, 0, sizeof(RTM_IPX_ROUTE));

    RtmRoute.R_Interface = InterfaceIndex;
    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;
    GETLONG2ULONG(&RtmRoute.R_Network, Network);

    rc = RtmBlockDisableRoutes(
            RtmStaticHandle,
            EnumFlags,
            &RtmRoute);
    return;
}


VOID
EnableStaticRoutes(ULONG	    InterfaceIndex)
{
    RTM_IPX_ROUTE	RtmRoute;
    DWORD		EnumFlags;
    DWORD		rc;

    EnumFlags = RTM_ONLY_THIS_INTERFACE;

    memset(&RtmRoute, 0, sizeof(RTM_IPX_ROUTE));

    RtmRoute.R_Interface = InterfaceIndex;
    RtmRoute.R_Protocol = IPX_PROTOCOL_STATIC;

    rc = RtmBlockReenableRoutes(
			RtmStaticHandle,
			EnumFlags,
			&RtmRoute);
    return;
}

/*++

Function:	GetStaticRoutesCount

Descr:		returns the number of static routes associated with this if

--*/

DWORD
GetStaticRoutesCount(ULONG	     InterfaceIndex)
{
    HANDLE		    EnumHandle;
    DWORD		    rc, Count = 0;
    IPX_STATIC_ROUTE_INFO   StaticRtInfo;

    EnumHandle = CreateStaticRoutesEnumHandle(InterfaceIndex);

    if(EnumHandle != NULL) {

	while(GetNextStaticRoute(EnumHandle, &StaticRtInfo) == NO_ERROR) {

	    Count++;
	}

	CloseStaticRoutesEnumHandle(EnumHandle);
    }

    return Count;
}

INT
NetNumCmpFunc(PDWORD	    Net1,
	      PDWORD	    Net2)
{
   if(*Net1 > *Net2) {

	return 1;
   }
   else
   {
	if(*Net1 == *Net2) {

	    return 0;
	}
	else
	{
	    return -1;
	}
    }
}

INT
NextHopAddrCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p)
{
    return ( memcmp(Route1p->R_NextHopMacAddress,
		    Route2p->R_NextHopMacAddress,
		    6)
	  );
}

BOOL
FamSpecDataCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p)
{
    if((Route1p->R_Flags == Route2p->R_Flags) &&
       (Route1p->R_TickCount == Route2p->R_TickCount) &&
       (Route1p->R_HopCount == Route2p->R_HopCount)) {

	return TRUE;
    }
    else
    {
	return FALSE;
    }
}

INT
NetNumHashFunc(PDWORD		Net)
{
    return  (*Net %  RoutingTableHashSize);
}

INT
RouteMetricCmpFunc(PRTM_IPX_ROUTE	Route1p,
		   PRTM_IPX_ROUTE	Route2p)
{
    // if either route has 16 hops, it is the worst, no matter how many ticks
    if((Route1p->R_HopCount == 16) && (Route2p->R_HopCount == 16)) {

	return 0;
    }

    if(Route1p->R_HopCount == 16) {

	return 1;
    }

    if(Route2p->R_HopCount == 16) {

	return -1;
    }

    // shortest number of ticks is the best route
    if(Route1p->R_TickCount < Route2p->R_TickCount) {

	return -1;
    }

    if(Route1p->R_TickCount > Route2p->R_TickCount) {

	return 1;
    }

    // if two routes exist with equal tick count values, the one with
    // the least hops should be used
    if(Route1p->R_HopCount < Route2p->R_HopCount) {

	return -1;
    }

    if(Route1p->R_HopCount > Route2p->R_HopCount) {

	return 1;
    }

    return 0;
}

DWORD
RouteValidateFunc(PRTM_IPX_ROUTE	Routep)
{
    return NO_ERROR;
}

/*++

Function:   tickcount

Descr:	    gets nr of ticks to send a 576 bytes packet over this link

Argument:   link speed as a multiple of 100 bps

--*/

USHORT
tickcount(UINT	    linkspeed)
{
    USHORT   tc;

    if(linkspeed == 0) {

	return 1;
    }

    if(linkspeed >= 10000) {

	// link speed >= 1M bps
	return 1;
    }
    else
    {
	 // compute the necessary time to send a 576 bytes packet over this
	 // line and express it as nr of ticks.
	 // One tick = 55ms

	 // time in ms to send 576 bytes (assuming 10 bits/byte for serial line)
	 tc = 57600 / linkspeed;

	 // in ticks
	 tc = tc / 55 + 1;
	 return tc;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtrprot.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtrprot.h

Abstract:

    This module contains the internal prototypes

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _RTRPROT_
#define _RTRPROT_

//
// *** Internal Prototypes ***
//

DWORD
GetIpxRouterParameters(VOID);

VOID
InitIfDB(VOID);

VOID
InitAdptDB(VOID);

DWORD
FwInitialize(VOID);

DWORD
StartAdapterManager(VOID);

VOID
StopAdapterManager(VOID);

DWORD
SetGlobalInfo(LPVOID);

DWORD
AddInterface(
	    IN	LPWSTR		    InterfaceNamep,
	    IN	LPVOID		    InterfaceInfop,
	    IN	INTERFACE_TYPE	    InterfaceType,
	    IN	HANDLE		    hDDMInterface,
	    IN OUT HANDLE	    *phInterface);

DWORD
DeleteInterface(HANDLE	InterfaceIndex);

DWORD
GetInterfaceInfo(
	    IN	HANDLE	    InterfaceIndex,
	    OUT LPVOID	    InterfaceInfo,
	    IN OUT DWORD    *InterfaceInfoSize);


DWORD
SetInterfaceInfo(
		IN  HANDLE	InterfaceIndex,
		IN  LPVOID	InterfaceInfop);


DWORD APIENTRY
InterfaceConnected (
    IN      HANDLE          hInterface,
    IN      PVOID           pFilter,
    IN      PVOID           pPppProjectionResult
    );

VOID
InterfaceDisconnected(
		IN HANDLE Interface);

DWORD
InterfaceNotReachable(
		IN  HANDLE			      Interface,
		IN  UNREACHABILITY_REASON	      Reason);

DWORD
InterfaceReachable(
		IN  HANDLE	Interface);

VOID
UpdateCompleted(PUPDATE_COMPLETE_MESSAGE    ucmsgp);


DWORD
SetGlobalInfo(
                IN      LPVOID          pGlobalInfo );

VOID
AdapterNotification(VOID);

VOID
ForwarderNotification(VOID);

LPVOID
GetInfoEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	     ULONG			InfoEntryType);

DWORD
CreateStaticRoute(PICB			    icbp,
		  PIPX_STATIC_ROUTE_INFO    StaticRouteInfop);

DWORD
DeleteStaticRoute(ULONG			    IfIndex,
		  PIPX_STATIC_ROUTE_INFO    StaticRouteInfop);

PICB
GetInterfaceByName(LPWSTR	    InterfaceNamep);

PICB
GetInterfaceByIndex(ULONG	    InterfaceIndex);

PIPX_TOC_ENTRY
GetTocEntry(PIPX_INFO_BLOCK_HEADER HeaderInfop,
	    ULONG		   InfoType);

VOID
AddIfToDB(PICB	   icbp);

VOID
RemoveIfFromDB(PICB	icbp);

PACB
GetAdapterByNameAndPktType (LPWSTR 	    AdapterName, ULONG PacketType);

VOID
BindInterfaceToAdapter(PICB	   icbp,
		       PACB	   acbp);

VOID
UnbindInterfaceFromAdapter(PICB	icbp);

VOID
DeleteAllStaticRoutes(ULONG	    InterfaceIndex);

DWORD
UpdateStaticIfEntries(
		PICB	 icbp,
		HANDLE	 EnumHandle,	     // handle for the get next enumeration
		ULONG	 StaticEntrySize,
		ULONG	 NewStaticEntriesCount,  // number of new static entries
		LPVOID	 NewStaticEntry,	 // start of the new entries array
		ULONG	 (*GetNextStaticEntry)(HANDLE EnumHandle, LPVOID entry),
		ULONG	 (*DeleteStaticEntry)(ULONG IfIndex, LPVOID entry),
		ULONG	 (*CreateStaticEntry)(PICB icbp, LPVOID entry));

HANDLE
CreateStaticRoutesEnumHandle(ULONG    InterfaceIndex);

DWORD
GetNextStaticRoute(HANDLE EnumHandle, PIPX_STATIC_ROUTE_INFO StaticRtInfop);

VOID
CloseStaticRoutesEnumHandle(HANDLE EnumHandle);

HANDLE
CreateStaticServicesEnumHandle(ULONG	InterfaceIndex);

DWORD
GetNextStaticService(HANDLE EnumHandle, PIPX_STATIC_SERVICE_INFO StaticSvInfop);

DWORD
CloseStaticServicesEnumHandle(HANDLE EnumHandle);

DWORD
DeleteAllStaticServices(ULONG	InterfaceIndex);

PACB
GetAdapterByIndex(ULONG     AdapterIndex);

PICB
GetInterfaceByAdapterName(LPWSTR	AdapterName);

DWORD
CreateLocalRoute(PICB	icbp);

DWORD
DeleteLocalRoute(PICB	icbp);

VOID
GetInterfaceAnsiName(PUCHAR	    AnsiInterfaceNameBuffer,
		     PWSTR	    UnicodeInterfaceNameBuffer);
VOID
InitIfDB(VOID);

VOID
AddToAdapterHt(PACB	acbp);

VOID
RemoveFromAdapterHt(PACB	acbp);

BOOL
RtCreateTimer(IN PHANDLE  TimerHandlep);

BOOL
RtDestroyTimer(IN HANDLE	TimerHandle);

BOOL
RtSetTimer(
    IN HANDLE TimerHandle,
    IN ULONG MillisecondsToExpire,
    IN PTIMER_APC_ROUTINE  TimerRoutine,
    IN PVOID Context
    );

BOOL
RtCancelTimer(
	  IN HANDLE	TimerHandle
    );


DWORD
StartRoutingProtocols(HANDLE RoutesUpdateEvent, HANDLE ServicesUpdateEvent);

VOID
StopRoutingProtocols(VOID);

DWORD
CreateRoutingProtocolsInterfaces(PIPX_INFO_BLOCK_HEADER     InterfaceInfop,
				 PICB			    icbp);

DWORD
DeleteRoutingProtocolsInterfaces(ULONG	    InterfaceIndex);

ULONG
SizeOfRoutingProtocolsIfsInfo(ULONG    InterfaceIndex);

ULONG
RoutingProtocolsTocCount(VOID);

DWORD
CreateRoutingProtocolsTocAndInfoEntries(PIPX_INFO_BLOCK_HEADER	    ibhp,
					ULONG			    InterfaceIndex,
					PIPX_TOC_ENTRY		    *current_tocepp,
					PULONG			    current_NextInfoOffsetp);

DWORD
SetRoutingProtocolsInterfaces(PIPX_INFO_BLOCK_HEADER	   InterfaceInfop,
				 ULONG			    InterfaceIndex);

DWORD
BindRoutingProtocolsIfsToAdapter(ULONG			  InterfaceIndex,
				 PIPX_ADAPTER_BINDING_INFO	  abip);

DWORD
UnbindRoutingProtocolsIfsFromAdapter(ULONG	InterfaceIndex);

DWORD
CreateStaticService(PICB			    icbp,
		    PIPX_STATIC_SERVICE_INFO	ServiceEntry);

DWORD
DeleteStaticService(ULONG			InterfaceIndex,
		    PIPX_STATIC_SERVICE_INFO	ServiceEntry);


DWORD
GetFirstService(IN  DWORD	      OrderingMethod,
		IN  DWORD	      ExclusionFlags,
		IN  OUT PIPX_SERVICE Service);

DWORD
GetNextService(IN  DWORD	      OrderingMethod,
		IN  DWORD	      ExclusionFlags,
		IN  OUT PIPX_SERVICE Service);

BOOL
IsService(USHORT	    Type,
	 PUCHAR 	    Name,
	 PIPX_SERVICE	    Service);

DWORD
GetRoute(ULONG		RoutingTable,
	 PIPX_ROUTE	IpxRoutep);

DWORD
GetFirstRoute(ULONG		   RoutingTable,
	      PIPX_ROUTE	   IpxRoutep);

DWORD
GetNextRoute(ULONG		    RoutingTable,
	     PIPX_ROUTE 	    IpxRoutep);

BOOL
IsRoute(PUCHAR	    Network);

DWORD
InitWanNetConfigDbase(VOID);

ULONG
GetNextInterfaceIndex(VOID);

DWORD
CreateGlobalRoute(PUCHAR	  Network);

DWORD
DeleteGlobalRoute(PUCHAR    Network);


DWORD
RtProtRequestRoutesUpdate(ULONG    InterfaceIndex);

DWORD
RtProtRequestServicesUpdate(ULONG   InterfaceIndex);

DWORD
RtProtSendRoutesUpdate(ULONG	   InterfaceIndex);

DWORD
RtProtSendServicesUpdate(ULONG	 InterfaceIndex);

VOID
RtProtCancelRoutesUpdate(ULONG	    InterfaceIndex);

VOID
RtProtCancelServicesUpdate(ULONG    InterfaceIndex);

VOID
CancelUpdateRequest(HANDLE   hInterface);

DWORD
GetDIMUpdateResult(HANDLE    InterfaceIndex,
		   LPDWORD   UpdateResultp);

VOID
InitUpdateCbs(PICB	icbp);

VOID
AdminEnable(PICB   icbp);

VOID
AdminDisable(PICB   icbp);

VOID
DestroyAllAdapters(VOID);

VOID
DestroyAllInterfaces(VOID);

DWORD
GetServiceCount(VOID);

DWORD
MibCreate(ULONG 	ProtocolId,
	  ULONG 	InputDataSize,
	  PVOID 	InputData);

DWORD
MibDelete(ULONG		ProtocolId,
	  ULONG 	InputDataSize,
	  PVOID 	InputData);
DWORD
MibSet(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData);

DWORD
MibGet(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData);

DWORD
MibGetFirst(ULONG		ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData);
DWORD
MibGetNext(ULONG	ProtocolId,
       ULONG		InputDataSize,
       PVOID		InputData,
       PULONG		OutputDataSize,
       PVOID		OutputData);

DWORD
RequestUpdate(IN HANDLE	    InterfaceIndex,
	      IN HANDLE     hEvent);

DWORD
GetStaticServicesCount(ULONG	    InterfaceIndex);

DWORD
GetStaticRoutesCount(ULONG	    InterfaceIndex);

VOID
DestroyRoutingProtocolCB(PRPCB		   rpcbp);

PRPCB
GetRoutingProtocolCB(DWORD	ProtocolId);

VOID
ConvertAllProtocolRoutesToStatic(ULONG	    InterfaceIndex,
			      ULONG	    RoutingProtocolId);

VOID
ConvertAllServicesToStatic(ULONG	InterfaceIndex);

DWORD
SetRoutingProtocolsGlobalInfo(PIPX_INFO_BLOCK_HEADER	   GlobalInfop);

DWORD
CreateRouteTable(VOID);

DWORD
EnumerateFirstInterfaceIndex(PULONG InterfaceIndexp);

DWORD
EnumerateNextInterfaceIndex(PULONG InterfaceIndexp);

DWORD
RoutingProtocolsEnableIpxInterface(ULONG	    InterfaceIndex);

DWORD
RoutingProtocolsDisableIpxInterface(ULONG	    InterfaceIndex);

DWORD
FwEnableIpxInterface(ULONG	    InterfaceIndex);

DWORD
FwDisableIpxInterface(ULONG	    InterfaceIndex);

DWORD
RoutingProtocolConnectionRequest(ULONG	    ProtocolId,
				 ULONG	    InterfaceIndex);
VOID
DisableStaticRoutes(ULONG	    InterfaceIndex);

VOID
DisableStaticRoute(ULONG	    InterfaceIndex, PUCHAR Network);

VOID
EnableStaticRoutes(ULONG	    InterfaceIndex);

VOID
ExternalEnableInterface(ULONG	    InterfaceIndex);

VOID
ExternalDisableInterface(ULONG	    InterfaceIndex);

NET_INTERFACE_TYPE
MapIpxToNetInterfaceType(PICB		icbp);

VOID
StartTracing(VOID);

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...);

VOID
StopTracing(VOID);

DWORD
RmCreateGlobalRoute(PUCHAR	    Network);

DWORD
RmAddLocalWkstaDialoutInterface(
	    IN	    LPWSTR		    InterfaceNamep,
	    IN	    LPVOID		    InterfaceInfop,
	    IN OUT  PULONG		    InterfaceIndexp);

DWORD
RmDeleteLocalWkstaDialoutInterface(ULONG	InterfaceIndex);

DWORD
RmGetIpxwanInterfaceConfig(ULONG	InterfaceIndex,
			   PULONG	IpxwanConfigRequired);

BOOL
RmIsRoute(PUCHAR	Network);

DWORD
RmGetInternalNetNumber(PUCHAR	    Network);

DWORD 
RmUpdateIpxcpConfig (PIPXCP_ROUTER_CONFIG_PARAMS pParams);

DWORD
I_SetFilters(ULONG	    InterfaceIndex,
	     ULONG	    FilterMode, // inbound or outbound
	     LPVOID	    FilterInfop);

DWORD
I_GetFilters(ULONG	    InterfaceIndex,
	     ULONG	    FilterMode,
	     LPVOID	    FilterInfop,
	     PULONG	    FilterInfoSize);

DWORD
DeleteRouteTable(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtrdbg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtrmgr.c

Abstract:

    The major router management functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//*** TRACE ID FOR ROUTER MANAGER ***

DWORD	    RMTraceID = INVALID_TRACEID;
HANDLE      RMEventLogHdl = NULL;
DWORD       RMEventLogMask = 0;



#if DBG
DWORD	DbgLevel = DEFAULT_DEBUG;
DWORD	DebugLog = 1;
HANDLE	DbgLogFileHandle;


VOID
SsDbgInitialize(VOID)
{
    if (DebugLog == 1) {

	CONSOLE_SCREEN_BUFFER_INFO csbi;
	COORD coord;
	(VOID)AllocConsole( );
	(VOID)GetConsoleScreenBufferInfo(
				     GetStdHandle(STD_OUTPUT_HANDLE),
				     &csbi
				     );
	coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
	coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
	(VOID)SetConsoleScreenBufferSize(
				     GetStdHandle(STD_OUTPUT_HANDLE),
				     coord
				     );
    }

    if(DebugLog > 1) {

	DbgLogFileHandle = CreateFile("\\ipxrtdbg.log",
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_READ,
					 NULL,
					 CREATE_ALWAYS,
					 0,
					 NULL);
    }
}

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    Trace(ROUTER_ALERT, "\nAssertion failed: %s\n  at line %ld of %s\n",
		FailedAssertion, LineNumber, FileName);

    DbgUserBreakPoint( );

} // SsAssert

#endif

#if DBG
VOID
SsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

    if(DbgLogFileHandle != INVALID_HANDLE_VALUE) {

	WriteFile(DbgLogFileHandle, (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // SsPrintf
#endif

VOID
StartTracing(VOID)
{
    RMTraceID = TraceRegisterA("IPXRouterManager");
    RMEventLogHdl = RouterLogRegisterA ("IPXRouterManager");
}

VOID
Trace(ULONG	ComponentID,
      char	*Format,
      ...)
{
    if (RMTraceID!=INVALID_TRACEID) {
        va_list	arglist;

        va_start(arglist, Format);

        TraceVprintfEx(RMTraceID,
	           ComponentID | TRACE_USE_MASK,
	           Format,
	           arglist);

        va_end(arglist);
    }
}

VOID
StopTracing(VOID)
{
    if (RMTraceID!=INVALID_TRACEID)
        TraceDeregister(RMTraceID);
    if (RMEventLogHdl!=NULL)
        RouterLogDeregisterA (RMEventLogHdl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rpal.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rpal.c

Abstract:

    Routing protocols abstraction layer. It abstracts the RIP/SAP or NLSP routing
    protocols interface functions for the rest of the router manager system.

Author:

    Stefan Solomon  04/24/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//
// Service Table Manager Entry Points
//

PIS_SERVICE					    STM_IsService;
PCREATE_SERVICE_ENUMERATION_HANDLE		    STM_CreateServiceEnumerationHandle;
PENUMERATE_GET_NEXT_SERVICE			    STM_EnumerateGetNextService;
PCLOSE_SERVICE_ENUMERATION_HANDLE		    STM_CloseServiceEnumerationHandle;
PGET_SERVICE_COUNT				    STM_GetServiceCount;
PCREATE_STATIC_SERVICE				    STM_CreateStaticService;
PDELETE_STATIC_SERVICE				    STM_DeleteStaticService;
PBLOCK_CONVERT_SERVICES_TO_STATIC		    STM_BlockConvertServicesToStatic;
PBLOCK_DELETE_STATIC_SERVICES			    STM_BlockDeleteStaticServices;
PGET_FIRST_ORDERED_SERVICE			    STM_GetFirstOrderedService;
PGET_NEXT_ORDERED_SERVICE			    STM_GetNextOrderedService;

//
//  Auto-Static Update Entry Points
//

ULONG			    UpdateRoutesProtId;
PDO_UPDATE_ROUTES	    RP_UpdateRoutes;

ULONG			    UpdateServicesProtId;
PDO_UPDATE_SERVICES	    RP_UpdateServices;

//
//  Router Manager Support Functions - Passed to routing protocols at Start
//

SUPPORT_FUNCTIONS	RMSupportFunctions = {

	    RoutingProtocolConnectionRequest,
	    MibCreate,
	    MibDelete,
	    MibSet,
	    MibGet,
	    MibGetFirst,
	    MibGetNext

	    };


//**************************************************************************
//									   *
//	    Routing Protocols Init/Start/Stop Functions			   *
//									   *
//**************************************************************************

DWORD
StartRoutingProtocols(LPVOID	 GlobalInfop,
		      HANDLE	 RoutingProtocolsEvent)
{
    DWORD		rc, i, count, namelen, support;
    HINSTANCE		moduleinstance;
    PRPCB		rpcbp;
    LPVOID		ProtocolGlobalInfop;
    PIPX_GLOBAL_INFO	IpxGlobalInfop;
	MPR_PROTOCOL_0		*RtProtocolsp;
	DWORD				NumRoutingProtocols;

    MPR_ROUTING_CHARACTERISTICS mrcRouting;
    MPR_SERVICE_CHARACTERISTICS mscService;

    // Initialize Routing Protocols List
    //
    InitializeListHead(&RoutingProtocolCBList);

	rc = MprSetupProtocolEnum (PID_IPX, (LPBYTE *)&RtProtocolsp, &NumRoutingProtocols);
	if (rc!=NO_ERROR) {
		Trace (RPAL_TRACE,
			"StartRoutingProtocols:	failed to get routing protocol info: %d",
			rc);
	return ERROR_CAN_NOT_COMPLETE;
    }

	Trace (RPAL_TRACE, "StartRoutingProtocols:	%d protocols installed.",
					NumRoutingProtocols);

    for (i=0; i<NumRoutingProtocols; i++) {

	if (GetInfoEntry(GlobalInfop, RtProtocolsp[i].dwProtocolId)==NULL)
		continue;

        // load library on the dll name provided
        //
	moduleinstance = LoadLibraryW (RtProtocolsp[i].wszDLLName) ;

	if (moduleinstance == NULL) {

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            LPWSTR       pname[1] = {RtProtocolsp[i].wszDLLName};
            RouterLogErrorW (RMEventLogHdl, 
                ROUTERLOG_IPX_CANT_LOAD_PROTOCOL,
                1, pname, rc);
        }
	    Trace(RPAL_TRACE, "StartRoutingProtocols: %ls failed to load: %d\n", RtProtocolsp[i].wszDLLName, GetLastError());
		MprSetupProtocolFree (RtProtocolsp);
	    return ERROR_CAN_NOT_COMPLETE;
        }

	namelen = sizeof(WCHAR) * (wcslen(RtProtocolsp[i].wszDLLName) + 1) ; // +1 for null character

	rpcbp = (PRPCB) GlobalAlloc (GPTR, sizeof(RPCB) + namelen) ;

	if (rpcbp == NULL) {

	    FreeLibrary (moduleinstance) ;
	    Trace(RPAL_TRACE, "StartRoutingProtocols: memory allocation failure\n");

		MprSetupProtocolFree (RtProtocolsp);
	    return ERROR_CAN_NOT_COMPLETE;
	}

    ZeroMemory(rpcbp,
               sizeof(RPCB) + namelen);

	rpcbp->RP_DllName = (PWSTR)((PUCHAR)rpcbp + sizeof(RPCB));
    rpcbp->RP_DllHandle = moduleinstance;
	memcpy (rpcbp->RP_DllName, RtProtocolsp[i].wszDLLName, namelen) ;

    // Loading all entrypoints
	//

    rpcbp->RP_RegisterProtocol = 
        (PREGISTER_PROTOCOL)GetProcAddress(moduleinstance,
                                           REGISTER_PROTOCOL_ENTRY_POINT_STRING)
;
    if(rpcbp->RP_RegisterProtocol == NULL)
    {
        //
        // Could not find the RegisterProtocol entry point
        // Nothing we can do - bail out
        //

        Sleep(0);

		MprSetupProtocolFree (RtProtocolsp);
        Trace(RPAL_TRACE, "StartRoutingProtocols: Could not find RegisterProtocol for %S",
              RtProtocolsp[i].wszDLLName);

	    GlobalFree(rpcbp);
        FreeLibrary(moduleinstance);
        return ERROR_INVALID_FUNCTION;
    }

    ZeroMemory(&mrcRouting,
               sizeof(MPR_ROUTING_CHARACTERISTICS));

    ZeroMemory(&mscService,
               sizeof(MPR_SERVICE_CHARACTERISTICS));

    mrcRouting.dwVersion                = MS_ROUTER_VERSION;
    mrcRouting.dwProtocolId             = RtProtocolsp[i].dwProtocolId;
    mrcRouting.fSupportedFunctionality  = ROUTING|DEMAND_UPDATE_ROUTES;

    mscService.dwVersion                = MS_ROUTER_VERSION;
    mscService.dwProtocolId             = RtProtocolsp[i].dwProtocolId;
    mscService.fSupportedFunctionality  = SERVICES|DEMAND_UPDATE_SERVICES;

    rpcbp->RP_ProtocolId = RtProtocolsp[i].dwProtocolId;

    rc = rpcbp->RP_RegisterProtocol(&mrcRouting,
                                    &mscService);

    if(rc != NO_ERROR)
    {
        Sleep(0);

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            CHAR        num[8];
            LPSTR       pnum[1] = {num};
            _ultoa (rpcbp->RP_ProtocolId, num, 16);
            RouterLogErrorA (RMEventLogHdl,
                ROUTERLOG_IPX_CANT_REGISTER_PROTOCOL,
                1, pnum, rc);
        }

        FreeLibrary(moduleinstance);

	    GlobalFree(rpcbp);

        Trace(RPAL_TRACE, "StartRoutingProtocols: %S returned error %d while registering",
               RtProtocolsp[i].wszDLLName,
               rc);

		MprSetupProtocolFree (RtProtocolsp);
        return rc;
    }

    rpcbp->RP_StartProtocol     = mrcRouting.pfnStartProtocol;
    rpcbp->RP_StopProtocol      = mrcRouting.pfnStopProtocol;
    rpcbp->RP_AddInterface      = mrcRouting.pfnAddInterface;
    rpcbp->RP_DeleteInterface   = mrcRouting.pfnDeleteInterface;
    rpcbp->RP_GetEventMessage   = mrcRouting.pfnGetEventMessage;
    rpcbp->RP_GetIfConfigInfo   = mrcRouting.pfnGetInterfaceInfo;
    rpcbp->RP_SetIfConfigInfo   = mrcRouting.pfnSetInterfaceInfo;
    rpcbp->RP_BindInterface     = mrcRouting.pfnBindInterface;
    rpcbp->RP_UnBindInterface   = mrcRouting.pfnUnbindInterface;
    rpcbp->RP_EnableInterface   = mrcRouting.pfnEnableInterface;
    rpcbp->RP_DisableInterface  = mrcRouting.pfnDisableInterface;
    rpcbp->RP_GetGlobalInfo     = mrcRouting.pfnGetGlobalInfo;
    rpcbp->RP_SetGlobalInfo     = mrcRouting.pfnSetGlobalInfo;
    rpcbp->RP_MibCreate         = mrcRouting.pfnMibCreateEntry;
    rpcbp->RP_MibDelete         = mrcRouting.pfnMibDeleteEntry;
    rpcbp->RP_MibGet            = mrcRouting.pfnMibGetEntry;
    rpcbp->RP_MibSet            = mrcRouting.pfnMibSetEntry;
    rpcbp->RP_MibGetFirst       = mrcRouting.pfnMibGetFirstEntry;
    rpcbp->RP_MibGetNext        = mrcRouting.pfnMibGetNextEntry;

    if (!(rpcbp->RP_RegisterProtocol) ||
        !(rpcbp->RP_StartProtocol)    ||
        !(rpcbp->RP_StopProtocol)     ||
        !(rpcbp->RP_AddInterface)     ||
        !(rpcbp->RP_DeleteInterface)  ||
        !(rpcbp->RP_GetEventMessage)  ||
        !(rpcbp->RP_GetIfConfigInfo)  ||
        !(rpcbp->RP_SetIfConfigInfo)  ||
        !(rpcbp->RP_BindInterface)    ||
        !(rpcbp->RP_UnBindInterface)  ||
        !(rpcbp->RP_EnableInterface)  ||
        !(rpcbp->RP_DisableInterface) ||
        !(rpcbp->RP_GetGlobalInfo)    ||
        !(rpcbp->RP_SetGlobalInfo)    ||
        !(rpcbp->RP_MibCreate)        ||
        !(rpcbp->RP_MibDelete)        ||
        !(rpcbp->RP_MibSet)           ||
        !(rpcbp->RP_MibGet)           ||
        !(rpcbp->RP_MibGetFirst)      ||
        !(rpcbp->RP_MibGetNext))
    {
	    Trace(RPAL_TRACE, "StartRoutingProtocols: %ls failed to load entrypoints",
	    RtProtocolsp[i].wszDLLName);

	    GlobalFree(rpcbp);
	    FreeLibrary (moduleinstance);

        MprSetupProtocolFree (RtProtocolsp);
	   
        return ERROR_CAN_NOT_COMPLETE;
    }

    if(mscService.fSupportedFunctionality & SERVICES) 
    {
        STM_IsService                       = mscService.pfnIsService;
        STM_CreateServiceEnumerationHandle  = mscService.pfnCreateServiceEnumerationHandle;
        STM_EnumerateGetNextService         = mscService.pfnEnumerateGetNextService;
        STM_CloseServiceEnumerationHandle   = mscService.pfnCloseServiceEnumerationHandle;
        STM_GetServiceCount                 = mscService.pfnGetServiceCount;
        STM_CreateStaticService             = mscService.pfnCreateStaticService;
        STM_DeleteStaticService             = mscService.pfnDeleteStaticService;
        STM_BlockConvertServicesToStatic    = mscService.pfnBlockConvertServicesToStatic;
        STM_BlockDeleteStaticServices       = mscService.pfnBlockDeleteStaticServices;
        STM_GetFirstOrderedService          = mscService.pfnGetFirstOrderedService;
        STM_GetNextOrderedService           = mscService.pfnGetNextOrderedService;

        if(!(STM_IsService) ||
           !(STM_CreateServiceEnumerationHandle) ||
           !(STM_EnumerateGetNextService) || 
           !(STM_CloseServiceEnumerationHandle) ||
           !(STM_GetServiceCount) ||
           !(STM_CreateStaticService) || 
           !(STM_DeleteStaticService) || 
           !(STM_BlockConvertServicesToStatic) ||
           !(STM_BlockDeleteStaticServices) ||
           !(STM_GetFirstOrderedService) || 
           !(STM_GetNextOrderedService))
        {
            Trace(RPAL_TRACE, "StartRoutingProtocols: %ls failed to get STM entry points\n",
                  RtProtocolsp[i].wszDLLName);

            GlobalFree(rpcbp);
            FreeLibrary (moduleinstance);

            MprSetupProtocolFree (RtProtocolsp);
            return ERROR_CAN_NOT_COMPLETE;
        }
    }


	if(mrcRouting.fSupportedFunctionality & DEMAND_UPDATE_ROUTES) 
    {
	    RP_UpdateRoutes = mrcRouting.pfnUpdateRoutes;

        if(!RP_UpdateRoutes)
        {
		    Trace(RPAL_TRACE, 
                  "StartRoutingProtocols: %ls failed to get UpdateRoutes entry points\n",
				  RtProtocolsp[i].wszDLLName);

		    GlobalFree(rpcbp);
		    FreeLibrary (moduleinstance);
		    MprSetupProtocolFree (RtProtocolsp);
		    return ERROR_CAN_NOT_COMPLETE;
	    }

	    UpdateRoutesProtId = rpcbp->RP_ProtocolId;
	}

	if(mscService.fSupportedFunctionality & DEMAND_UPDATE_SERVICES) 
    {
        RP_UpdateServices = mscService.pfnUpdateServices;
	   
        if(!RP_UpdateServices)
        {
		    Trace(RPAL_TRACE, 
                  "StartRoutingProtocols: %ls failed to get UpdateServices entry points\n",
				  RtProtocolsp[i].wszDLLName);

		    GlobalFree(rpcbp);
		    FreeLibrary (moduleinstance);
		    MprSetupProtocolFree (RtProtocolsp);
		
            return ERROR_CAN_NOT_COMPLETE;
	    }

	    UpdateServicesProtId = rpcbp->RP_ProtocolId;
	}

	ProtocolGlobalInfop = GetInfoEntry(GlobalInfop, rpcbp->RP_ProtocolId);

	if ((rc = (*rpcbp->RP_StartProtocol)(RoutingProtocolsEvent,
					     &RMSupportFunctions,
					     ProtocolGlobalInfop)) != NO_ERROR) {

        IF_LOG (EVENTLOG_ERROR_TYPE) {
            CHAR        num[8];
            LPSTR       pnum[1] = {num};
            _ultoa (rpcbp->RP_ProtocolId, num, 16);
            RouterLogErrorA (RMEventLogHdl, 
                ROUTERLOG_IPX_CANT_START_PROTOCOL,
                1, pnum, rc);
        }
	    Trace(RPAL_TRACE, "StartRoutingProtocols: %ls failed to start: %d\n",
								RtProtocolsp[i].wszDLLName, rc);

	    GlobalFree(rpcbp);
	    FreeLibrary (moduleinstance);
		MprSetupProtocolFree (RtProtocolsp);
	    return ERROR_CAN_NOT_COMPLETE;
	}

	// Insert this routing protocol in the list of routing protocols
    //
	InsertTailList(&RoutingProtocolCBList, &rpcbp->RP_Linkage);
	RoutingProtocolActiveCount++;
	Trace(RPAL_TRACE, "StartRoutingProtocols: %ls successfully initialized",
					RtProtocolsp[i].wszDLLName);
    }

    if(!RP_UpdateRoutes || !RP_UpdateServices) {

	Trace(RPAL_TRACE, "StartRoutingProtocols: missing update entry point\n");

	MprSetupProtocolFree (RtProtocolsp);
	return ERROR_CAN_NOT_COMPLETE;
    }

	MprSetupProtocolFree (RtProtocolsp);

	Trace(RPAL_TRACE, "");
	
    return NO_ERROR;
}

VOID
StopRoutingProtocols(VOID)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    DWORD			rc;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList) {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_StopProtocol)();
	lep = lep->Flink;
    }
}

//**************************************************************************
//									   *
//	    Routing Protocols Interface Management Functions		   *
//									   *
//**************************************************************************


DWORD
CreateRoutingProtocolsInterfaces(PIPX_INFO_BLOCK_HEADER     InterfaceInfop,
				 PICB			    icbp)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    LPVOID			RpIfInfop;
    NET_INTERFACE_TYPE		NetInterfaceType;
    DWORD			rc;

    NetInterfaceType = MapIpxToNetInterfaceType(icbp);

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	RpIfInfop = GetInfoEntry(InterfaceInfop, rpcbp->RP_ProtocolId);
	if(RpIfInfop == NULL) {

	    return ERROR_CAN_NOT_COMPLETE;
	}

	rc = (*rpcbp->RP_AddInterface)(
                    icbp->InterfaceNamep,
                    icbp->InterfaceIndex,
				    NetInterfaceType,
				    RpIfInfop);

	if(rc != NO_ERROR) {

	    return rc;
	}

	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
DeleteRoutingProtocolsInterfaces(ULONG	    InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {
	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_DeleteInterface)(InterfaceIndex);
	lep = lep->Flink;
    }

    return NO_ERROR;
}

ULONG
SizeOfRoutingProtocolsIfsInfo(ULONG	   InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    ULONG			TotalInfoSize = 0;
    ULONG			RpIfInfoSize = 0;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {
	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_GetIfConfigInfo)(InterfaceIndex, NULL, &RpIfInfoSize);
	// align size on double DWORD boundary - add two's complement for the last three bits
	RpIfInfoSize += ((~RpIfInfoSize) + 1) & 0x7;
	TotalInfoSize += RpIfInfoSize;
	RpIfInfoSize = 0;
	lep = lep->Flink;
    }

    return TotalInfoSize;
}

ULONG
RoutingProtocolsTocCount(VOID)
{
   return(RoutingProtocolActiveCount);
}

/*++

Function:   CreateRoutingProtocolsTocAndInfoEntries

Descr:	    as it says

Arguments:  ibhp - ptr to the info block header
	    InterfaceIndex
	    current_tocepp - ptr to the location of the current TOC ptr; you have
			     to increment this to get to the next TOC -> your TOC!
	    current_NextInfoOffsetp - pointer to the location of the next info entry offset
				      in the info block; you have to use this for your info
				      entry and then to increment it for the next user.
--*/

DWORD
CreateRoutingProtocolsTocAndInfoEntries(PIPX_INFO_BLOCK_HEADER	    ibhp,
					ULONG			    InterfaceIndex,
					PIPX_TOC_ENTRY		    *current_tocepp,
					PULONG			    current_NextInfoOffsetp)
{
    PIPX_TOC_ENTRY		tocep;
    ULONG			NextInfoOffset;
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    ULONG			RpIfInfoSize;
    DWORD			rc;


    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {
	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	// increment the current pointer to table of contents entries so it will
	// point to the next entry
	(*current_tocepp)++;
	tocep = *current_tocepp;

	// create the routing protocol and info toc entry
	tocep->InfoType = rpcbp->RP_ProtocolId;
	tocep->InfoSize = 0;
	tocep->Count = 1;
	tocep->Offset = *current_NextInfoOffsetp;

	rc = (*rpcbp->RP_GetIfConfigInfo)(InterfaceIndex,
					 (LPVOID)((PUCHAR)ibhp + tocep->Offset),
					 &tocep->InfoSize);

	if(rc != ERROR_INSUFFICIENT_BUFFER) {

	    return rc;
	}

	rc = (*rpcbp->RP_GetIfConfigInfo)(InterfaceIndex,
					 (LPVOID)((PUCHAR)ibhp + tocep->Offset),
					 &tocep->InfoSize);

	if(rc != NO_ERROR) {

	    return rc;
	}

	*current_NextInfoOffsetp += tocep->InfoSize;
	// align the next offset on DWORD boundary
	*current_NextInfoOffsetp += (~*current_NextInfoOffsetp + 1) & 0x7;

	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
SetRoutingProtocolsInterfaces(PIPX_INFO_BLOCK_HEADER	   InterfaceInfop,
			      ULONG			    InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    LPVOID			RpIfInfop;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	RpIfInfop = GetInfoEntry(InterfaceInfop, rpcbp->RP_ProtocolId);
	if(RpIfInfop == NULL) {

	    return ERROR_CAN_NOT_COMPLETE;
	}
	(*rpcbp->RP_SetIfConfigInfo)(InterfaceIndex, RpIfInfop);
	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
BindRoutingProtocolsIfsToAdapter(ULONG			    InterfaceIndex,
				 PIPX_ADAPTER_BINDING_INFO  abip)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_BindInterface)(InterfaceIndex, abip);
	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
UnbindRoutingProtocolsIfsFromAdapter(ULONG	InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_UnBindInterface)(InterfaceIndex);
	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
RoutingProtocolsEnableIpxInterface(ULONG	    InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_EnableInterface)(InterfaceIndex);
	lep = lep->Flink;
    }

    return NO_ERROR;
}

DWORD
RoutingProtocolsDisableIpxInterface(ULONG	    InterfaceIndex)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	(*rpcbp->RP_DisableInterface)(InterfaceIndex);
	lep = lep->Flink;
    }

    return NO_ERROR;
}


//**************************************************************************
//									   *
//	    Routing Protocols Services Management Functions		   *
//									   *
//**************************************************************************

DWORD
GetFirstService(DWORD	       OrderingMethod,
		DWORD	       ExclusionFlags,
		PIPX_SERVICE   Servicep)
{
    return(*STM_GetFirstOrderedService)(OrderingMethod, ExclusionFlags, Servicep);
}

DWORD
GetNextService(DWORD	       OrderingMethod,
		DWORD	       ExclusionFlags,
		PIPX_SERVICE   Servicep)
{
    return(*STM_GetNextOrderedService)(OrderingMethod, ExclusionFlags, Servicep);
}


DWORD
CreateStaticService(PICB			    icbp,
		    PIPX_STATIC_SERVICE_INFO	ServiceEntry)
{
    DWORD	    rc;

    rc = (*STM_CreateStaticService)(icbp->InterfaceIndex, ServiceEntry);

    return rc;
}

DWORD
DeleteStaticService(ULONG			InterfaceIndex,
		    PIPX_STATIC_SERVICE_INFO	ServiceEntry)
{
    DWORD	    rc;

    rc = (*STM_DeleteStaticService)(InterfaceIndex, ServiceEntry);

    return rc;
}

HANDLE
CreateStaticServicesEnumHandle(ULONG	InterfaceIndex)
{
    IPX_SERVICE     CriteriaService;
    HANDLE	    EnumHandle;

    if(STM_CreateServiceEnumerationHandle == NULL) {

	return NULL;
    }

    memset(&CriteriaService, 0, sizeof(IPX_SERVICE));

    CriteriaService.InterfaceIndex = InterfaceIndex;
    CriteriaService.Protocol = IPX_PROTOCOL_STATIC;

    EnumHandle = (*STM_CreateServiceEnumerationHandle)(
		       STM_ONLY_THIS_INTERFACE | STM_ONLY_THIS_PROTOCOL,
		       &CriteriaService);

    return EnumHandle;
}

DWORD
GetNextStaticService(HANDLE			EnumHandle,
		     PIPX_STATIC_SERVICE_INFO	StaticSvInfop)
{
    IPX_SERVICE     Service;
    DWORD	    rc;

    if((rc =  (*STM_EnumerateGetNextService)(EnumHandle,
				  &Service)) == NO_ERROR) {

	// fill in the static service structure
	*StaticSvInfop = Service.Server;
    }

    return rc;
}

DWORD
CloseStaticServicesEnumHandle(HANDLE	 EnumHandle)
{
    DWORD	rc = NO_ERROR;

    if(EnumHandle) {

	rc = (*STM_CloseServiceEnumerationHandle)(EnumHandle);
    }

    return rc;
}


DWORD
DeleteAllStaticServices(ULONG	    InterfaceIndex)
{
    if(!STM_BlockDeleteStaticServices) {

      return NO_ERROR;
    }

    return((*STM_BlockDeleteStaticServices)(InterfaceIndex));
}

DWORD
GetServiceCount(VOID)
{
    if(!STM_GetServiceCount) {

       return 0;
    }

    return((*STM_GetServiceCount)());
}

//**************************************************************************
//									   *
//	    Routing Protocols Auto-Static Update Functions		   *
//									   *
//**************************************************************************

DWORD
RtProtRequestRoutesUpdate(ULONG     InterfaceIndex)
{
    return((*RP_UpdateRoutes)(InterfaceIndex));
}

DWORD
RtProtRequestServicesUpdate(ULONG   InterfaceIndex)
{
    return((*RP_UpdateServices)(InterfaceIndex));
}

VOID
DestroyRoutingProtocolCB(PRPCB		rpcbp)
{
    RemoveEntryList(&rpcbp->RP_Linkage);

    FreeLibrary (rpcbp->RP_DllHandle);
    GlobalFree(rpcbp);

    RoutingProtocolActiveCount--;
}

VOID
ConvertAllServicesToStatic(ULONG	InterfaceIndex)
{
    STM_BlockConvertServicesToStatic(InterfaceIndex);
}

DWORD
GetStaticServicesCount(ULONG	    InterfaceIndex)
{
    HANDLE			EnumHandle;
    DWORD			Count;
    IPX_STATIC_SERVICE_INFO	StaticSvInfo;

    EnumHandle = CreateStaticServicesEnumHandle(InterfaceIndex);

    if(EnumHandle == NULL) {

	return 0;
    }

    Count = 0;
    while(GetNextStaticService(EnumHandle, &StaticSvInfo) == NO_ERROR) {

	Count++;
    }

    CloseStaticServicesEnumHandle(EnumHandle);

    return Count;
}

PRPCB
GetRoutingProtocolCB(DWORD	ProtocolId)
{
    PRPCB	    rpcbp;
    PLIST_ENTRY     lep;

    lep = RoutingProtocolCBList.Flink;

    while(lep != &RoutingProtocolCBList)
    {
	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	if(rpcbp->RP_ProtocolId == ProtocolId) {

	    return rpcbp;
	}

	lep = lep->Flink;
    }

    return NULL;
}

BOOL
IsService(USHORT	SvType,
	  PUCHAR	SvName,
	  PIPX_SERVICE	Svp)
{
    return(STM_IsService(SvType, SvName, Svp));
}


DWORD
SetRoutingProtocolsGlobalInfo(PIPX_INFO_BLOCK_HEADER	   GlobalInfop)
{
    PLIST_ENTRY			lep;
    PRPCB			rpcbp;
    LPVOID			RpGlobalInfop;

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList)
    {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	RpGlobalInfop = GetInfoEntry(GlobalInfop, rpcbp->RP_ProtocolId);
	if(RpGlobalInfop == NULL) {

	    return NO_ERROR;
	}

	(*rpcbp->RP_SetGlobalInfo)(RpGlobalInfop);
	lep = lep->Flink;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtrmgr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtrmgr.c

Abstract:

    The major router management functions

Author:

    Stefan Solomon  03/22/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

// ***********	     Local Variables	   ***********
HINSTANCE   IpxCpModuleInstance;


ULONG	WorkerWaitTimeout;

LPVOID	    RouterGlobalInfop;
ULONG	    RouterGlobalInfoSize;


TCHAR       ModuleName[MAX_PATH+1];
HINSTANCE   hModuleReference;

VOID
RoutesUpdateNotification(VOID);

VOID
ServicesUpdateNotification(VOID);

VOID
RouterStopNotification(VOID);

VOID
RoutingProtocolsNotification(VOID);

DWORD
GetRegistryParameters(VOID);

typedef   VOID	(*EVENTHANDLER)(VOID);

EVENTHANDLER evhdlr[MAX_EVENTS] =
{
    AdapterNotification,
    ForwarderNotification,
    RoutingProtocolsNotification,
    RouterStopNotification
};


DWORD
StopRouter(VOID);

DWORD
RouterBootComplete( VOID );

VOID
RouterManagerWorker(VOID);

DWORD
GetGlobalInfo(OUT LPVOID	GlobalInfop,
	      IN OUT LPDWORD	GlobalInfoSizep);


// These prototypes allow us to specify when ipxcp will be initialized
DWORD InitializeIpxCp (HINSTANCE hInstDll);
DWORD CleanupIpxCp (HINSTANCE hInstDll);


BOOL WINAPI
IpxRtrMgrDllEntry(HINSTANCE hInstDll,
		  DWORD fdwReason,
		  LPVOID pReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

        GetModuleFileName (hInstDll, ModuleName,
                    sizeof (ModuleName)/sizeof (ModuleName[0]));
	    SS_DBGINITIALIZE;

	    StartTracing();

            break;

        case DLL_PROCESS_DETACH:

	    StopTracing();

	    // Close the database mutex
	    DeleteCriticalSection (&DatabaseLock);

            break;

        default:

            break;
    }

    return TRUE;
}

const static WCHAR pszIpxStackService[] = L"NwlnkIpx";

//
// Verifies that the ipx stack is started and attempts to start the stack
// if not.
//
DWORD VerifyOrStartIpxStack() {
    SC_HANDLE hSC = NULL, hStack = NULL;
    SERVICE_STATUS Status;
    DWORD dwErr;

    Trace(INIT_TRACE, "VerifyOrStartIpxStack: entered.");
    
    __try {
        // Get a handle to the service controller
        if ((hSC = OpenSCManager (NULL, NULL, GENERIC_READ | GENERIC_EXECUTE)) == NULL)
            return GetLastError();

        // Get a handle to the ipx stack service
        hStack = OpenServiceW (hSC, 
                              pszIpxStackService, 
                              SERVICE_START | SERVICE_QUERY_STATUS);
        if (!hStack)
            return GetLastError();

        // Find out if the service is running
        if (QueryServiceStatus (hStack, &Status) == 0)
            return GetLastError();
    
        // See if the service is running
        if (Status.dwCurrentState != SERVICE_RUNNING) {
            // If it's stopped, start it
            if (Status.dwCurrentState == SERVICE_STOPPED) {
                if (StartService (hStack, 0, NULL) == 0)
                    return GetLastError();

                // Warn that the stack has been started
                IF_LOG (EVENTLOG_WARNING_TYPE) {
                    RouterLogErrorDataW (RMEventLogHdl, 
                        ROUTERLOG_IPX_WRN_STACK_STARTED,
                        0, NULL, 0, NULL);
                }
                Trace(INIT_TRACE, "VerifyOrStartIpxStack: Starting ipx stack...");

                
                // Make sure that the service started.  StartService is not supposed
                // to return until the driver is started.
                if (QueryServiceStatus (hStack, &Status) == 0)
                    return GetLastError();

                if (Status.dwCurrentState != SERVICE_RUNNING)
                    return ERROR_CAN_NOT_COMPLETE;
            }

            // If it's not stopped, don't worry about it.
            else
                return NO_ERROR;
        }

    }
    __finally {
        if (hSC)
            CloseServiceHandle (hSC);
        if (hStack)
            CloseServiceHandle (hStack);
    }
    
    return NO_ERROR;
}


/*++

Function:	    StartRouter

Descr:		    Initializes the router manager database of interfaces and
		    adapters, starts the other IPX router modules, creates the
		    IPX router manager worker thread.

--*/

DWORD
StartRouter(PDIM_ROUTER_INTERFACE	rifp,
	    BOOL			fLANModeOnly,
	    LPVOID			GlobalInfop)
{
    HANDLE		            threadhandle;
    DWORD		            threadid, rc;
    int 		            i;
    BOOL		            ThisMachineOnly, bInternalNetNumOk;
    IPXCP_INTERFACE	        IpxcpInterface;
    PIPX_GLOBAL_INFO	    IpxGlobalInfop;
    PIPX_INFO_BLOCK_HEADER  globalhp;

    // These flags get set to true when their corrosponding components 
    // get started.  They are used to properly clean up.
    BOOL bEventsCreated = FALSE;
    BOOL bRoutTableCreated = FALSE;
    BOOL bRtmStaticObtained = FALSE;
    BOOL bRtmLocalObtained = FALSE;
    BOOL bFwdStarted = FALSE;
    BOOL bAdpManStarted = FALSE;
    BOOL bProtsStarted = FALSE;
    BOOL bGlobalRouteCreated = FALSE;
    BOOL bIpxcpStarted = FALSE;
    BOOL bIpxcpInitted = FALSE;
    BOOL bWorkerThreadCreated = FALSE;

    // Initialize
    Trace(INIT_TRACE, "StartRouter: Entered\n");
    RouterOperState = OPER_STATE_DOWN;

    // [pmay]
    // We need to make sure that the stack is started before westart.  
    if (VerifyOrStartIpxStack() != NO_ERROR) {
        IF_LOG (EVENTLOG_ERROR_TYPE) {
            RouterLogErrorDataW (RMEventLogHdl, 
                ROUTERLOG_IPX_STACK_DISABLED,
                0, NULL, 0, NULL);
        }
        Trace(INIT_TRACE, "StartRouter: Unable to start ipx stack.");
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }
        
    // [pmay]
    // We use this scheme to automatically select the internal network
    // number of the machine we're running on.  If the net number is configured
    // as zero, this function will automatically select a random net num and 
    // verify it's uniqueness on the net that this machine is attached to.
    if (AutoValidateInternalNetNum(&bInternalNetNumOk, INIT_TRACE) == NO_ERROR) {
        if (!bInternalNetNumOk) {
            if (PnpAutoSelectInternalNetNumber(INIT_TRACE) != NO_ERROR) {
                IF_LOG (EVENTLOG_ERROR_TYPE) {
                    RouterLogErrorDataW (RMEventLogHdl, 
                        ROUTERLOG_IPX_AUTO_NETNUM_FAILURE,
                        0, NULL, 0, NULL);
                }
                Trace(INIT_TRACE, "StartRouter: Auto selection of net number failed.");
                return ERROR_CAN_NOT_COMPLETE;
            }
        }
    }

    // This try block will be used to automatically cleanup in the case that 
    // something doesn't start right
    __try {
        // Make sure the parameters are ok
        if(GlobalInfop == NULL) {
            IF_LOG (EVENTLOG_ERROR_TYPE) {
                RouterLogErrorDataW (RMEventLogHdl, 
                    ROUTERLOG_IPX_BAD_GLOBAL_CONFIG,
                    0, NULL, 0, NULL);
            }
    	    Trace(INIT_TRACE, "StartRouter: invalid global info\n");
    	    return ERROR_CAN_NOT_COMPLETE;
        }

        // Read config from registry
        GetRegistryParameters();
        globalhp = (PIPX_INFO_BLOCK_HEADER)GlobalInfop;
        RouterGlobalInfop = GlobalAlloc(GPTR, globalhp->Size);
        RouterGlobalInfoSize = globalhp->Size;
        memcpy(RouterGlobalInfop, GlobalInfop, RouterGlobalInfoSize);
        IpxGlobalInfop =  (PIPX_GLOBAL_INFO)GetInfoEntry((PIPX_INFO_BLOCK_HEADER)GlobalInfop,
    						                             IPX_GLOBAL_INFO_TYPE);

        // Initialize the hash table size
        if(IpxGlobalInfop != NULL) {
            switch (IpxGlobalInfop->RoutingTableHashSize) {
                case IPX_SMALL_ROUTING_TABLE_HASH_SIZE:
                case IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE:
                case IPX_LARGE_ROUTING_TABLE_HASH_SIZE:
    	            RoutingTableHashSize = IpxGlobalInfop->RoutingTableHashSize;
                    Trace(INIT_TRACE, "Setting routing table hash size to %ld\n",
                                        RoutingTableHashSize);
                    break;
                default:
                    Trace(INIT_TRACE, "Using default routing table hash size of %ld\n",
                                        RoutingTableHashSize);
                    break;
            }
            RMEventLogMask = IpxGlobalInfop->EventLogMask;
        }

        // Create router database mutex
    	try {
    		InitializeCriticalSection (&DatabaseLock);
    	}
    	except (EXCEPTION_EXECUTE_HANDLER) {
    		// !!! cannot create database mutex !!!
    		Trace(INIT_TRACE, "InitializeRouter: cannot initialize database lock.\n");
    		return(ERROR_CAN_NOT_COMPLETE);
        }

        // Create the adapter and forwarder notification events
        for (i=0; i < MAX_EVENTS; i++) {
        	g_hEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
    	    if (g_hEvents[i] == NULL) {
                // !!! Log a problem with event creation
    	        return (ERROR_CAN_NOT_COMPLETE);
            }
        }
        bEventsCreated = TRUE;
    
        // Initialize the interfaces and adapters databases
        InitIfDB();
        InitAdptDB();

        // create the IPX routing table
        if(CreateRouteTable() != NO_ERROR) {
    	    Trace(INIT_TRACE, "InitializeRouter: cannot create route table\n");
    	    return(ERROR_CAN_NOT_COMPLETE);
        }
        bRoutTableCreated = TRUE;

        // Get a handle to use later when calling into rtm for static routes
        if((RtmStaticHandle = RtmRegisterClient(RTM_PROTOCOL_FAMILY_IPX,
                          					    IPX_PROTOCOL_STATIC,
    					                        NULL,  // not interested in change notif
    					                        0)) == NULL) 
        {
    	    Trace(INIT_TRACE, "InitializeRouter: cannot register RTM client\n");
    	    return(ERROR_CAN_NOT_COMPLETE);
        }
        bRtmStaticObtained = TRUE;

        // Get a handle to use when calling into the rtm later for local routes
        if((RtmLocalHandle = RtmRegisterClient(RTM_PROTOCOL_FAMILY_IPX,
    					                       IPX_PROTOCOL_LOCAL,
    					                       NULL,  // not interested in change notif
    					                       0)) == NULL) 
        {
    	    Trace(INIT_TRACE, "InitializeRouter: cannot register RTM client\n");
    	    return(ERROR_CAN_NOT_COMPLETE);
        }
        bRtmLocalObtained = TRUE;

        // tell the IPXCP that router has started so we can accept calls from it
        LanOnlyMode = fLANModeOnly;

        // Bind with ipxcp if we are a wan router
        if(!LanOnlyMode) {
            // Load ipxcp
    	    IpxCpModuleInstance = LoadLibrary(IPXCPDLLNAME);
    	    if(IpxCpModuleInstance == NULL) {
                IF_LOG (EVENTLOG_ERROR_TYPE)
                    RouterLogErrorA (RMEventLogHdl, ROUTERLOG_IPX_CANT_LOAD_IPXCP,0, NULL, GetLastError ());
    	        Trace(INIT_TRACE, "StartRouter: cannot load IPXCP DLL\n");
    	        return ERROR_CAN_NOT_COMPLETE;
    	    }

            // Initialize it
            if ((rc = InitializeIpxCp (IpxCpModuleInstance)) != NO_ERROR) {
    	        Trace(INIT_TRACE, "StartRouter: cannot get IpxcpInit Entry Point");
                return rc;
            }
            bIpxcpInitted = TRUE;

            // Bind to it
    	    if(!(IpxcpBind = (PIPXCP_BIND)GetProcAddress(IpxCpModuleInstance, IPXCP_BIND_ENTRY_POINT_STRING))) {
    	        Trace(INIT_TRACE, "StartRouter: cannot get IpxcpBind Entry Point\n");
    	        return ERROR_CAN_NOT_COMPLETE;
    	    }

    	    IpxcpInterface.RmCreateGlobalRoute = RmCreateGlobalRoute;
    	    IpxcpInterface.RmAddLocalWkstaDialoutInterface = RmAddLocalWkstaDialoutInterface;
    	    IpxcpInterface.RmDeleteLocalWkstaDialoutInterface = RmDeleteLocalWkstaDialoutInterface;
    	    IpxcpInterface.RmGetIpxwanInterfaceConfig = RmGetIpxwanInterfaceConfig;
    	    IpxcpInterface.RmIsRoute = RmIsRoute;
    	    IpxcpInterface.RmGetInternalNetNumber = RmGetInternalNetNumber;
    	    IpxcpInterface.RmUpdateIpxcpConfig = RmUpdateIpxcpConfig;

    	    (*IpxcpBind)(&IpxcpInterface);

    	    ThisMachineOnly = IpxcpInterface.Params.ThisMachineOnly;
    	    WanNetDatabaseInitialized = IpxcpInterface.Params.WanNetDatabaseInitialized;
    	    EnableGlobalWanNet = IpxcpInterface.Params.EnableGlobalWanNet;
    	    memcpy(GlobalWanNet, IpxcpInterface.Params.GlobalWanNet, 4);
    	    IpxcpRouterStarted = IpxcpInterface.IpxcpRouterStarted;
    	    IpxcpRouterStopped = IpxcpInterface.IpxcpRouterStopped;
        }

        // check that the forwarder module exists and is ready to run
        if(FwStart(RoutingTableHashSize, ThisMachineOnly)) {
    	    // got a problem initializing the forwarder
            IF_LOG (EVENTLOG_ERROR_TYPE) {
                RouterLogErrorDataW (RMEventLogHdl, ROUTERLOG_IPX_CANT_LOAD_FORWARDER,0, NULL, 0, NULL);
            }
    	    // !!! log an error !!!
    	    Trace(INIT_TRACE, "InitializeRouter: cannot initialize the Forwarder\n");
    	    return(ERROR_CAN_NOT_COMPLETE);
        }
        bFwdStarted = TRUE;

        // start getting the adapter configuration	from the IPX stack
        // this will start adding adapters to the forwader
        if(StartAdapterManager()) {
	        Trace(INIT_TRACE, "InitializeRouter: cannot get the adapters configuration\n");
	        return (ERROR_CAN_NOT_COMPLETE);
        }
        bAdpManStarted = TRUE;

        // set the timeout wait for the router worker thread
        WorkerWaitTimeout = INFINITE;

        // start the routing protocols (rip/sap or nlsp)
        if(StartRoutingProtocols(GlobalInfop,g_hEvents[ROUTING_PROTOCOLS_NOTIFICATION_EVENT])) {
	        Trace(INIT_TRACE, "InitializeRouter: cannot initialize routing protocols\n");
            return(ERROR_CAN_NOT_COMPLETE);
        }
        bProtsStarted = TRUE;

        // send an IOCTl to the Forwarder to notify the router manager of connection
        // requests
        ConnReqOverlapped.hEvent = g_hEvents[FORWARDER_NOTIFICATION_EVENT];
        ConnRequest = (PFW_DIAL_REQUEST)GlobalAlloc (GPTR, DIAL_REQUEST_BUFFER_SIZE);
        if (ConnRequest==NULL) {
		    Trace(INIT_TRACE, "InitializeRouter: Cannot allocate Connecttion Request buffer.\n");
    	    return(ERROR_CAN_NOT_COMPLETE);
        }
        rc = FwNotifyConnectionRequest(ConnRequest,DIAL_REQUEST_BUFFER_SIZE,&ConnReqOverlapped);
        if(rc != NO_ERROR) {
	        Trace(INIT_TRACE, "InitializeRouter: cannot post FwNotifyConnectionRequest IOCtl\n");
            return(ERROR_CAN_NOT_COMPLETE);
        }

        // exchange function table with the DDM
        // first, fill in with our entry points
        rifp->dwProtocolId = PID_IPX;
        rifp->InterfaceConnected = InterfaceConnected;
        rifp->StopRouter = StopRouter;
        rifp->RouterBootComplete = RouterBootComplete;
        rifp->AddInterface = AddInterface;
        rifp->DeleteInterface = DeleteInterface;
        rifp->GetInterfaceInfo = GetInterfaceInfo;
        rifp->SetInterfaceInfo = SetInterfaceInfo;
        rifp->InterfaceNotReachable = InterfaceNotReachable;
        rifp->InterfaceReachable = InterfaceReachable;
        rifp->UpdateRoutes = RequestUpdate;
        rifp->GetUpdateRoutesResult = GetDIMUpdateResult;
        rifp->SetGlobalInfo = SetGlobalInfo;
        rifp->GetGlobalInfo = GetGlobalInfo;
        rifp->MIBEntryCreate = MibCreate;
        rifp->MIBEntryDelete = MibDelete;
        rifp->MIBEntrySet = MibSet;
        rifp->MIBEntryGet = MibGet;
        rifp->MIBEntryGetFirst = MibGetFirst;
        rifp->MIBEntryGetNext = MibGetNext;

        // get its entry points
        ConnectInterface = rifp->ConnectInterface;
        DisconnectInterface = rifp->DisconnectInterface;
        SaveInterfaceInfo = rifp->SaveInterfaceInfo;
        RestoreInterfaceInfo = rifp->RestoreInterfaceInfo;
        RouterStopped = rifp->RouterStopped;
        InterfaceEnabled = rifp->InterfaceEnabled;

        // Tell ipxcp that we have started if appropriate
        if(!LanOnlyMode) {
	        if(WanNetDatabaseInitialized &&EnableGlobalWanNet) {
	            CreateGlobalRoute(GlobalWanNet);
                bGlobalRouteCreated = TRUE;
	        }
	        (*IpxcpRouterStarted)();
            bIpxcpStarted = TRUE;
        }

       // start the Router Manager Worker thread
        if ((threadhandle = CreateThread(NULL,
			                             0,
			                             (LPTHREAD_START_ROUTINE) RouterManagerWorker,
			                             NULL,   
			                             0,
			                             &threadid)) == NULL) 
        {
	        // !!! log error cannot create the worker thread !!!
	        return (ERROR_CAN_NOT_COMPLETE);
        }
        bWorkerThreadCreated = TRUE;

        // all started -> the router is ready to accept interface management
        // apis from DDM, SNMP agent and Sysmon.
        RouterOperState = OPER_STATE_UP;
    }

    // Whenever the above try block exists, the code in this finally block will
    // be executed.  If at that time, the router state is not up, then you know
    // an error condition exists.  This is the time to cleanup in this case.
    __finally {
        if (RouterOperState == OPER_STATE_DOWN) {
            if (bWorkerThreadCreated)
        	    CloseHandle(threadhandle);

            if (bIpxcpStarted)
                (*IpxcpRouterStopped)();

            if (bIpxcpInitted)
                CleanupIpxCp (IpxCpModuleInstance);

            if (bGlobalRouteCreated)
                DeleteGlobalRoute(GlobalWanNet);

            if (bProtsStarted)
                StopRoutingProtocols();

            if (bAdpManStarted)
                StopAdapterManager();

            if (bFwdStarted)
    	        FwStop();

            if (bRtmLocalObtained)
                RtmDeregisterClient (RtmLocalHandle);
                
            if (bRtmStaticObtained)
                RtmDeregisterClient (RtmStaticHandle);

            if (bRoutTableCreated)
                DeleteRouteTable();

            if (bEventsCreated) {
        		for(i=0; i<MAX_EVENTS; i++)
    			    CloseHandle(g_hEvents[i]);
    	    }
        }
    }

    return NO_ERROR;
}


/*++

Function:	StopRouter

Descr:		The router stops its routing functions and unloads, i.e:
		The Forwarder stops forwarding
		The Rip module stops and advertises it has stopped
		    All dynamic routes are deleted and advertised as not available
		    All local and static routes are advertised as not available
		The Sap module stops and advertises it has stopped
		    All dynamic services are deleted and advertised as not available
		    All local and static services are advertised as not available

--*/

DWORD
StopRouter(VOID)
{
    Trace(INIT_TRACE, "StopRouter: Entered\n");

    SetEvent(g_hEvents[STOP_NOTIFICATION_EVENT]);

    return PENDING;
}

/*++

Function:   RouterBootComplete

Descr:      Called by DIM when it has completed adding all the interfaces from
            the registry.
--*/

DWORD
RouterBootComplete( VOID )
{
    Trace(INIT_TRACE, "RouterBootComplete: Entered\n");

    return( NO_ERROR );
}

VOID
RouterStopNotification(VOID)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;

    Trace(INIT_TRACE, "RouterStopNotification: Entered\n");

    // We set the RouterOperState to stopping in critical section to make sure
    // that no DDM call is executing. All DDM calls require this crit sec for
    // starting execution and will check the router state before doing anything

    ACQUIRE_DATABASE_LOCK;

    RouterOperState = OPER_STATE_STOPPING;

    RELEASE_DATABASE_LOCK;

    // we have to make sure no SNMP or Sysmon call is active. We use a ref
    // counter.
    // we also make sure that no work item is pending

    for(;;)
    {
	ACQUIRE_DATABASE_LOCK;

	if((MibRefCounter == 0) && (WorkItemsPendingCounter == 0)) {

	    RELEASE_DATABASE_LOCK;

	    break;
	}

	RELEASE_DATABASE_LOCK;

	Sleep(1000);
    }

    // delete all static routes and services and all local routes
    ACQUIRE_DATABASE_LOCK;

    lep = IndexIfList.Flink;

    while(lep != &IndexIfList)
    {
	icbp = CONTAINING_RECORD(lep, ICB, IndexListLinkage);

	DeleteAllStaticRoutes(icbp->InterfaceIndex);
	DeleteAllStaticServices(icbp->InterfaceIndex);

	// check if oper state UP and admin enabled
	if((icbp->AdminState == ADMIN_STATE_ENABLED) &&
	   (icbp->OperState == OPER_STATE_UP)) {

	    if(memcmp(icbp->acbp->AdapterInfo.Network, nullnet, 4)) {

		DeleteLocalRoute(icbp);
	    }
	}

	lep = lep->Flink;
    }

    RELEASE_DATABASE_LOCK;

    // tell ipxcp that the router is stopping so that it will end calling us
    if(!LanOnlyMode) {

	(*IpxcpRouterStopped)();

	if(EnableGlobalWanNet) {

	    DeleteGlobalRoute(GlobalWanNet);
	}
    }

    // initiate the stopping of the routing protocols
    StopRoutingProtocols();

    return;
}

/*++

Function:	RouterManagerWorker

Descr:		the WORKER THREAD

--*/

VOID
RouterManagerWorker(VOID)
{
    DWORD	 rc;
    DWORD	 signaled_event;

    hModuleReference = LoadLibrary (ModuleName);
    while(TRUE)
    {
	rc = WaitForMultipleObjectsEx(
                MAX_EVENTS,
                g_hEvents,
		FALSE,			 // wait any
		INFINITE,		 // timeout
		TRUE			 // wait alertable, so we can run APCs
                );

	signaled_event = rc - WAIT_OBJECT_0;

	if(signaled_event < MAX_EVENTS)	{

	    // invoke the event handler
	    (*evhdlr[signaled_event])();
	}
    }
}

VOID
RoutingProtocolsNotification(VOID)
{
    PLIST_ENTRY 		lep;
    PRPCB			rpcbp;
    ROUTING_PROTOCOL_EVENTS	RpEvent;
    MESSAGE			RpMessage;
    int 			i;
    DWORD			rc;
    BOOL			RoutingProtocolStopped;

    Trace(INIT_TRACE, " RoutingProtocolsNotification: Entered\n");

    // for each routing protocol get the events and the messages associated
    // with each event

    lep = RoutingProtocolCBList.Flink;
    while(lep != &RoutingProtocolCBList) {

	rpcbp = CONTAINING_RECORD(lep, RPCB, RP_Linkage);
	lep = lep->Flink;

	RoutingProtocolStopped = FALSE;

	while((rc = (*rpcbp->RP_GetEventMessage)(&RpEvent, &RpMessage)) == NO_ERROR)
	{
	    switch(RpEvent) {

		case ROUTER_STOPPED:


		    Trace(INIT_TRACE, "RoutingProtocolNotification: Protocol %x has stopped\n",
				   rpcbp->RP_ProtocolId);

		    RoutingProtocolStopped = TRUE;

		    // remove the routing protocol CB from the list and free it
		    DestroyRoutingProtocolCB(rpcbp);

		    // check if there are still routing protocols to wait for
		    if(IsListEmpty(&RoutingProtocolCBList)) {

			//
			// All Routing Protocols stopped -> Stop the Router
			//

			// Close the Forwarder. This will complete the Forwarder pending
			// connect request IOCTl.
			FwStop();

			// set the current state
			RouterOperState = OPER_STATE_DOWN;

			// Close the IPX stack config port.
			StopAdapterManager();

			// Clean-up the database
			ACQUIRE_DATABASE_LOCK;

			// Remove all adapter control blocks
			DestroyAllAdapters();

			// Remove all interface control blocks
			DestroyAllInterfaces();

			RELEASE_DATABASE_LOCK;

			// Deregister as RTM clients	- this will delete all static and
			// local routes
			RtmDeregisterClient(RtmStaticHandle);
			RtmDeregisterClient(RtmLocalHandle);

			DeleteRouteTable();

			// Close notification events
			for(i=0; i<MAX_EVENTS; i++)
			{
			    CloseHandle(g_hEvents[i]);
			}

			// get rid of global info
			GlobalFree(RouterGlobalInfop);

			// Call DDM to tell it we have stopped
			RouterStopped(PID_IPX, NO_ERROR);


			// Free IPXCP if loaded
            if (IpxCpModuleInstance!=NULL) {
                CleanupIpxCp (IpxCpModuleInstance);
        	    FreeLibrary(IpxCpModuleInstance);
        	}

    	    FreeLibraryAndExitThread(hModuleReference, 0);
		    }

		    break;

		case UPDATE_COMPLETE:

		    Trace(INIT_TRACE, "RoutingProtocolNotification: Protocol %x has completed update\n",
				   rpcbp->RP_ProtocolId);

		    UpdateCompleted(&RpMessage.UpdateCompleteMessage);
		    break;

		default:


		    Trace(INIT_TRACE, "RoutingProtocolNotification: Protocol %x signaled invalid event %d\n",
				   rpcbp->RP_ProtocolId,
				   RpEvent);

		    break;
	    }

	    if(RoutingProtocolStopped) {

		break;
	    }
	}
    }
}


DWORD
SetGlobalInfo(IN LPVOID 	GlobalInfop)
{
    DWORD		      rc;
    PIPX_INFO_BLOCK_HEADER    globalhp;
    PIPX_GLOBAL_INFO	    IpxGlobalInfop;

    if(GlobalInfop == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    GlobalFree(RouterGlobalInfop);
    globalhp = (PIPX_INFO_BLOCK_HEADER)GlobalInfop;
    RouterGlobalInfoSize = globalhp->Size;

    RouterGlobalInfop = GlobalAlloc(GPTR, RouterGlobalInfoSize);

    if(RouterGlobalInfop == NULL) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    memcpy(RouterGlobalInfop, GlobalInfop, RouterGlobalInfoSize);
    IpxGlobalInfop =  (PIPX_GLOBAL_INFO)GetInfoEntry((PIPX_INFO_BLOCK_HEADER)GlobalInfop,
						     IPX_GLOBAL_INFO_TYPE);
    if(IpxGlobalInfop != NULL) {
        // Can only be set at startup
        // RoutingTableHashSize = IpxGlobalInfop->RoutingTableHashSize;
        RMEventLogMask = IpxGlobalInfop->EventLogMask;
    }


    rc = SetRoutingProtocolsGlobalInfo((PIPX_INFO_BLOCK_HEADER)GlobalInfop);

    return rc;
}

DWORD
GetGlobalInfo(OUT LPVOID	GlobalInfop,
	      IN OUT LPDWORD	GlobalInfoSizep)
{
    if((GlobalInfop == NULL) || (*GlobalInfoSizep == 0)) {

	*GlobalInfoSizep = RouterGlobalInfoSize;
	return ERROR_INSUFFICIENT_BUFFER;
    }

    if(RouterGlobalInfoSize > *GlobalInfoSizep) {

	*GlobalInfoSizep = RouterGlobalInfoSize;
	return ERROR_INSUFFICIENT_BUFFER;
    }

    memcpy(GlobalInfop, RouterGlobalInfop, RouterGlobalInfoSize);
    *GlobalInfoSizep = RouterGlobalInfoSize;

    return NO_ERROR;
}
//***
//
// Function:	GetRegistryParameters
//
// Descr:	Reads the parameters from the registry and sets them
//
//***

DWORD
GetRegistryParameters(VOID)
{
    NTSTATUS Status;
    PWSTR RouterManagerParametersPath = L"RemoteAccess\\RouterManagers\\IPX\\Parameters";
    RTL_QUERY_REGISTRY_TABLE	paramTable[2]; // table size = nr of params + 1

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));
    
    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"MaxRoutingTableSize";
    paramTable[0].EntryContext = &MaxRoutingTableSize;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &MaxRoutingTableSize;
    paramTable[0].DefaultLength = sizeof(ULONG);
        
    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_SERVICES,
		 RouterManagerParametersPath,
		 paramTable,
		 NULL,
		 NULL);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\rtrmgr.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtrmgr.h

Abstract:

    This module contains the definitions of the internal control structures
    used by the router manager

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _RTRMGR_
#define _RTRMGR_

//************************************************************************
//									 *
//			 MAIN DATA STRUCTURES				 *
//									 *
//************************************************************************


//*** Interface Control Block ***

typedef struct _ACB * PACB;

typedef struct _UPDATEREQCB {

    ULONG	RoutesReqStatus;
    ULONG	ServicesReqStatus;

}   UPDATEREQCB, *PUPDATEREQCB;

// status definitions for the routes and services req update

#define NO_UPDATE		0
#define UPDATE_PENDING		1
#define UPDATE_SUCCESSFULL	2
#define UPDATE_FAILURE		3

#define DIAL_REQUEST_BUFFER_SIZE    128

typedef struct _ICB {

    LIST_ENTRY			IndexHtLinkage;
    UCHAR			Signature[4];
    ULONG			InterfaceIndex;
    LIST_ENTRY			IndexListLinkage;	 // list of if ordered by index
    ULONG			AdminState;
    ULONG			OperState;
    BOOL			InterfaceReachable;
    ROUTER_INTERFACE_TYPE	DIMInterfaceType;  // interface type for Dim & Co.
    ULONG			MIBInterfaceType;  // interface type for the IPX MIB
    LPWSTR			InterfaceNamep;
    LPWSTR			AdapterNamep;
    PACB			acbp;	// ptr to adapter control block
    ULONG			PacketType;	// used to identify a corresponding adapter
    ULONG			EnableIpxWanNegotiation;
    UPDATEREQCB 		UpdateReq;	// controls update request on this if
    HANDLE			hDIMInterface;	// if handle used by DIM
    HANDLE			DIMUpdateEvent;
    DWORD			UpdateResult;
    BOOL			ConnectionRequestPending;
    } ICB, *PICB;


//*** Adapter Control Block ***

typedef struct _ACB {

    LIST_ENTRY	    IndexHtLinkage;
    UCHAR	    Signature[4];
    ULONG	    AdapterIndex;
    PICB	    icbp; // ptr to interface control block
    LPWSTR	    AdapterNamep;
    ULONG	    AdapterNameLen;
    ADAPTER_INFO    AdapterInfo;

    } ACB, *PACB;

//
// Macros used by update functions
//


#define  ResetUpdateRequest(icbp) {\
	    (icbp)->UpdateReq.RoutesReqStatus = NO_UPDATE;\
	    (icbp)->UpdateReq.ServicesReqStatus = NO_UPDATE;\
	    }

#define  SetUpdateRequestPending(icbp) {\
	    (icbp)->UpdateReq.RoutesReqStatus = UPDATE_PENDING;\
	    (icbp)->UpdateReq.ServicesReqStatus = UPDATE_PENDING;\
	    }

#define  IsUpdateRequestPending(icbp) \
	    (((icbp)->UpdateReq.RoutesReqStatus == UPDATE_PENDING) || \
	     ((icbp)->UpdateReq.ServicesReqStatus == UPDATE_PENDING))

//
// Control Block for each Routing Protocol
//
typedef struct _RPCB {

    LIST_ENTRY			RP_Linkage ;		// Linkage in Routing Prot CBs List
    PWSTR			RP_DllName;		// ptr to string for the dll name
    HINSTANCE       RP_DllHandle;   // DLL module handle
    DWORD			RP_ProtocolId;		// E.g. IPX_PROTOCOL_RIP, etc.
    PREGISTER_PROTOCOL		RP_RegisterProtocol;	// function pointer
    PSTART_PROTOCOL		RP_StartProtocol ;	// function pointer
    PSTOP_PROTOCOL		RP_StopProtocol ;	// function pointer
    PADD_INTERFACE		RP_AddInterface ;	// function pointer
    PDELETE_INTERFACE		RP_DeleteInterface ;	// function pointer
    PGET_EVENT_MESSAGE		RP_GetEventMessage ;	// function pointer
    PSET_INTERFACE_INFO	RP_SetIfConfigInfo ;	// function pointer
    PGET_INTERFACE_INFO	RP_GetIfConfigInfo ;	// function pointer
    PBIND_INTERFACE		RP_BindInterface ;	// function pointer
    PUNBIND_INTERFACE		RP_UnBindInterface ;	// function pointer
    PENABLE_INTERFACE		RP_EnableInterface ;	// function pointer
    PDISABLE_INTERFACE		RP_DisableInterface ;	// function pointer
    PGET_GLOBAL_INFO		RP_GetGlobalInfo ;	// function pointer
    PSET_GLOBAL_INFO		RP_SetGlobalInfo ;	// function pointer
    PMIB_CREATE 		RP_MibCreate ;		// function pointer
    PMIB_DELETE 		RP_MibDelete ;		// function pointer
    PMIB_SET			RP_MibSet ;		// function pointer
    PMIB_GET			RP_MibGet ;		// function pointer
    PMIB_GET_FIRST		RP_MibGetFirst ;	// function pointer
    PMIB_GET_NEXT		RP_MibGetNext ;		// function pointer

} RPCB, *PRPCB;


//************************************************************************
//									 *
//			 MAIN CONSTANTS DEFS				 *
//									 *
//************************************************************************

//
//  Database Lock Operations
//

#define ACQUIRE_DATABASE_LOCK		EnterCriticalSection (&DatabaseLock)

#define RELEASE_DATABASE_LOCK		LeaveCriticalSection (&DatabaseLock)

//
// Interface Hash Table Size
//

#define IF_HASH_TABLE_SIZE		32

//
// Adapter Hash Table Size
//

#define ADAPTER_HASH_TABLE_SIZE 	16

//
// DEFAULT WAIT FOR CONNECTION REQUEST TO TIME OUT
//

#define CONNECTION_REQUEST_TIME 	120000 // 2 minutes in milliseconds

//
// Events for the router manager worker thread to pend on
//

#define ADAPTER_NOTIFICATION_EVENT		0
#define FORWARDER_NOTIFICATION_EVENT		1
#define ROUTING_PROTOCOLS_NOTIFICATION_EVENT	2
#define STOP_NOTIFICATION_EVENT 		3

#define MAX_EVENTS				4

//
// Define the mode in which WAN net numbers are allocated to incoming WAN links
//

// NO_WAN_NET_MODE	    - in this mode we have a LAN/LAN only router.
//
// NUMBERED_WAN_NET_MODE    - in this mode, the WAN net numbers are allocated from
//			      a manually defined pool of net numbers.
//
// UNNUMBERED_WAN_NET_MODE  - in this mode there are no net numbers for the WAN
//			      lines connecting routers and there is a global WAN
//			      net number for all the client lines.
//			      The global client WAN net can be manually defined or
//			      allocated automatically by the router.


#define UNNUMBERED_WAN_NET_MODE		    0
#define NUMBERED_WAN_NET_MODE		    1
#define NO_WAN_NET_MODE 		    2

//
// Update Information Type defs
//

#define ROUTES_UPDATE			    1
#define SERVICES_UPDATE 		    2

// Default max routing table size (bytes)

#define     IPX_MAX_ROUTING_TABLE_SIZE		100000 * sizeof(RTM_IPX_ROUTE)

// IPXCP DLL Name

#define     IPXCPDLLNAME		    "rasppp"

//************************************************************************
//									 *
//			 MAIN GLOBALS DEFS				 *
//									 *
//************************************************************************

extern CRITICAL_SECTION	DatabaseLock;
extern ULONG		InterfaceCount;
extern BOOL		RouterAdminStart;
extern ULONG		RouterOperState;
extern HANDLE		RtmStaticHandle;
extern HANDLE		RtmLocalHandle;
extern PICB		InternalInterfacep;
extern PACB		InternalAdapterp;
extern ULONG		NextInterfaceIndex;
extern UCHAR		InterfaceSignature[];
extern UCHAR		AdapterSignature[];
extern HANDLE		g_hEvents[MAX_EVENTS];
extern ULONG		ConnReqTimeout;
extern LIST_ENTRY	IndexIfHt[IF_HASH_TABLE_SIZE];
extern LIST_ENTRY	IndexIfList;
extern UCHAR		GlobalWanNet[4];
extern ULONG		GlobalInterfaceIndex;
extern LIST_ENTRY	RoutingProtocolCBList;
extern ULONG		RoutingProtocolActiveCount;
extern ULONG		WorkItemsPendingCounter;


extern DWORD
(APIENTRY *ConnectInterface)(IN HANDLE		InterfaceName,
			    IN DWORD		ProtocolId);

extern DWORD
(APIENTRY *DisconnectInterface)(IN HANDLE	InterfaceName,
			       IN DWORD		ProtocolId);

extern DWORD
(APIENTRY *SaveInterfaceInfo)(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          pInterfaceInfo,
		IN	DWORD		cbInterfaceInfoSize);

extern DWORD
(APIENTRY *RestoreInterfaceInfo)(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          lpInterfaceInfo,
		IN	LPDWORD 	lpcbInterfaceInfoSize);

extern VOID
(APIENTRY *RouterStarted)(
                IN      DWORD           dwProtocolId );


extern VOID
(APIENTRY *RouterStopped)(
                IN      DWORD           dwProtocolId,
                IN      DWORD           dwError  ); 
extern VOID
(APIENTRY *InterfaceEnabled)(
            IN      HANDLE          hDIMInterface, 
            IN      DWORD           dwProtocolId,
            IN      BOOL            fEnabled  ); 

extern BOOL	RouterAdminStart;
extern BOOL	RipAdminStart;
extern BOOL	SapAdminStart;
extern ULONG	RouterOperState;
extern ULONG	FwOperState;
extern ULONG	AdptMgrOperState;
extern ULONG	RipOperState;
extern ULONG	SapOperState;
extern HANDLE	    RtmStaticHandle;
extern HANDLE	    RtmLocalHandle;
extern ULONG	RouterStartCount;
extern ULONG	RouterStopCount;
extern ULONG	RouterStartProtocols;
extern LIST_ENTRY     IndexAdptHt[ADAPTER_HASH_TABLE_SIZE];
extern LIST_ENTRY     IndexIfHt[IF_HASH_TABLE_SIZE];
extern ULONG	      MibRefCounter;
extern ULONG	 UpdateRoutesProtId;
extern UCHAR	 nullnet[4];
extern BOOL	 LanOnlyMode;
extern BOOL	 WanNetDatabaseInitialized;
extern BOOL	 EnableGlobalWanNet;
extern ULONG	 RoutingTableHashSize;
extern ULONG	 MaxRoutingTableSize;
extern PFW_DIAL_REQUEST	ConnRequest;
extern OVERLAPPED  ConnReqOverlapped;


extern DWORD	(*IpxcpBind)(PIPXCP_INTERFACE	    IpxcpInterface);

extern VOID	(*IpxcpRouterStarted)(VOID);

extern VOID	(*IpxcpRouterStopped)(VOID);

// NOTE: For the IPX Routing Protocols, the "routing protocol id" is the info
// type used to associate the respective config info with the protocol.
// For instance, IPX_PROTOCOL_RIP as the InfoType field in an IPX_TOC_ENTRY
// passed in AddInterface or SetInterface calls represents the RIP interface info.
// The same in a SetGlobalInfo call represents the RIP Global Info.

// actual structures moved to rtinfo.h to be common with other protocol
// families
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\test\router.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <rasman.h>
#include <dim.h>
#include <routprot.h>
#include <ipxrtdef.h>
#include <utils.h>

// [pmay] this will no longer be neccessary when the ipx router
// is converted to use MprInfo api's.
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;


DIM_ROUTER_INTERFACE dimif;

LPVOID
GetInfoEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	     ULONG			InfoEntryType);

VOID
TestMib(PDIM_ROUTER_INTERFACE dimifp);

VOID
SaveConfiguration(PDIM_ROUTER_INTERFACE dimifp);

VOID
RestoreConfiguration(PDIM_ROUTER_INTERFACE dimifp);

VOID
RouterStopped(DWORD	protid,
	      DWORD	err)
{
    printf("main: RouterStopped: protid 0x%x err 0x%x\n", protid, err);
}

DWORD
SaveInterfaceInfo(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          pInterfaceInfo,
		IN	DWORD		cbInterfaceInfoSize)
{
    printf("Main: SaveInterfaceInfo: entered for Dim if handle %d\n", hDIMInterface);

    return NO_ERROR;
}


HANDLE	    RmEvent;

//*** IPX Router Global Info ***

struct _GlobalInfo {

    IPX_INFO_BLOCK_HEADER	GI_Header;
    IPX_TOC_ENTRY		GI_RipTocEntry;
    IPX_TOC_ENTRY		GI_SapTocEntry;
    IPX_GLOBAL_INFO		GI_IpxGlobalInfo;
    WCHAR			SapName[MAX_DLL_NAME];
    RIP_GLOBAL_INFO		GI_RipGlobalInfo;
    RIP_ROUTE_FILTER_INFO	GI_RipRouteFilter[15];
    SAP_GLOBAL_INFO		GI_SapGlobalInfo;

    } gi;

struct _GlobalInfo  getgi;

PWCHAR	IpxRipNamep = L"IPXRIP";
PWCHAR	IpxSapNamep = L"IPXSAP";

struct _DBG_IF {

    IPX_INFO_BLOCK_HEADER	header;
    IPX_TOC_ENTRY		toc[6];
    IPX_IF_INFO 		ipxifinfo;
    RIP_IF_INFO 		ripifinfo;
    SAP_IF_INFO 		sapifinfo;
    IPXWAN_IF_INFO		ipxwanifinfo;
    IPX_ADAPTER_INFO		adapterinfo;
    IPX_STATIC_ROUTE_INFO	routeinfo[10];
    IPX_STATIC_SERVICE_INFO	srvinfo[10];
    } dbgif;

LPVOID	     dbgifgetp;

WCHAR		MainAdapterName[48];
WCHAR		MainInterfaceName[48];
ULONG		MainInterfaceType = ROUTER_IF_TYPE_DEDICATED;

HANDLE		MainInterfaceHandle;


#define ipxtoc			  dbgif.header.TocEntry[0]
#define riptoc			  dbgif.toc[0]
#define saptoc			  dbgif.toc[1]
#define ipxwantoc		  dbgif.toc[2]
#define adaptertoc		  dbgif.toc[3]
#define routetoc		  dbgif.toc[4]
#define srvtoc			  dbgif.toc[5]

VOID
MainAddInterface(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripifinfop;
    PSAP_IF_INFO	sapifinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    PIPX_STATIC_SERVICE_INFO srvinfop;
    int			i,j;
    BOOL		str = FALSE; // static routes info
    DWORD		rc, update;

    memset(&dbgif, 0, sizeof(dbgif));

    printf("Enter the interface name:");
    scanf("%S", &MainInterfaceName);

    printf("Enter the DIM Interface Handle:");
    scanf("%d", &i);

    printf("Enter interface type (0,1 - wan client, 2- wan router, 3 - lan, 4 - internal):");
    scanf("%d", &MainInterfaceType);

    switch(MainInterfaceType) {

	case 2:

	str = TRUE;
	break;

	case 3:

	printf("Enter LAN Adapter name:");
	scanf("%S", &MainAdapterName);
	break;

	default:

	break;
    }

    printf("Enter update mode on this interface: 1-standard, 2-none, 3-autostatic:");
    scanf("%d", &update);

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    if (str)
	dbgif.header.TocEntriesCount = 7;
    else
	dbgif.header.TocEntriesCount = 6;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = IPX_PROTOCOL_RIP;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    saptoc.InfoType = IPX_PROTOCOL_SAP;
    saptoc.InfoSize = sizeof(SAP_IF_INFO);
    saptoc.Count = 1;
    saptoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = saptoc.Offset + sizeof(SAP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    if (str) {

	routetoc.InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
	routetoc.InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
	routetoc.Count = 3;
	routetoc.Offset = adaptertoc.Offset + adaptertoc.InfoSize;

	srvtoc.InfoType = IPX_STATIC_SERVICE_INFO_TYPE;
	srvtoc.InfoSize = sizeof(IPX_STATIC_SERVICE_INFO);
	srvtoc.Count = 3;
	srvtoc.Offset = (ULONG)((PUCHAR)&dbgif.srvinfo - (PUCHAR)&dbgif);
    }

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosAccept = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = ADMIN_STATE_DISABLED;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 2;
    wcscpy(adapterinfop->AdapterName, MainAdapterName);

    ripifinfop = &dbgif.ripifinfo;

    ripifinfop->AdminState = ADMIN_STATE_ENABLED;
    ripifinfop->UpdateMode = update;
    ripifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    ripifinfop->Supply = ADMIN_STATE_ENABLED;
    ripifinfop->Listen = ADMIN_STATE_ENABLED;
    ripifinfop->EnableGlobalFiltering = ADMIN_STATE_DISABLED;

    sapifinfop = &dbgif.sapifinfo;

    sapifinfop->AdminState = ADMIN_STATE_ENABLED;
    sapifinfop->UpdateMode = update;
    sapifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    sapifinfop->Supply = ADMIN_STATE_ENABLED;
    sapifinfop->Listen = ADMIN_STATE_ENABLED;
    sapifinfop->EnableGlobalFiltering = ADMIN_STATE_DISABLED;

    ipxwaninfop = &dbgif.ipxwanifinfo;
    ipxwaninfop->AdminState = ADMIN_STATE_ENABLED;

    if (str) {

	routeinfop = dbgif.routeinfo;
	srvinfop = dbgif.srvinfo;

	for(j=0; j <3; j++, routeinfop++, srvinfop++)
	{
	    memset(routeinfop->Network, 0, 4);
	    routeinfop->Network[3] = i * 0x10 + j;
	    routeinfop->HopCount = 1;
	    routeinfop->TickCount = 1;
	    memset(routeinfop->NextHopMacAddress, i * 0x10 + j, 6);

	    srvinfop->Type = 4;
	    strcpy(srvinfop->Name, "TEST_STATIC_SERVER00");
	    srvinfop->Name[strlen(srvinfop->Name) - 2] = i + '0';
	    srvinfop->Name[strlen(srvinfop->Name) - 1] = j + '0';
	    memcpy(srvinfop->Network, routeinfop->Network, 4);
	    memset(srvinfop->Node, i * 0x10 + j, 6);
	    memset(srvinfop->Socket, j, 2);
	    srvinfop->HopCount = 2;
	}
    }

    rc = (*dimif.AddInterface)(
			       MainInterfaceName,
			       &dbgif,
			       NULL,
			       NULL,
			       MainInterfaceType,
			       TRUE,
			       (HANDLE)i,
			       &MainInterfaceHandle);

    printf("main: AddInterface returned %d and IPX Interface Index  = %d\n",
	    rc,	MainInterfaceHandle);

}

VOID
MainDeleteInterface(VOID)
{
    ULONG ii;

    printf("Enter IPX Interface Index:");
    scanf("%d", &ii);
    (*dimif.DeleteInterface)((HANDLE)ii);
}

VOID
MainGetInterface(VOID)
{
    ULONG ii;
    DWORD ifinfosize;
    DWORD infiltinfosize, outfiltinfosize;
    DWORD rc;

    printf("Enter IPX Interface Index:");
    scanf("%d", &ii);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)ii,
				NULL,
				&ifinfosize,
				NULL,
				&infiltinfosize,
				NULL,
				&outfiltinfosize);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("main: GetInterfaceInfo failed with rc=%d\n", rc);
	return;
    }

    dbgifgetp = GlobalAlloc(GPTR, ifinfosize);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)ii,
				dbgifgetp,
				&ifinfosize,
				NULL,
				&infiltinfosize,
				NULL,
				&outfiltinfosize);

    if(rc != NO_ERROR) {

	printf("main: GetInterfaceInfo failed on second call with rc=%d\n", rc);
	return;
    }
}

VOID
MainSetInterface(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripinfop;
    PSAP_IF_INFO	sapinfop;
    DWORD		rc;
    ULONG		IfIndex;
    ULONG		AdminState, RipAdminState, RipFilter, Update;
    ULONG		ifinfosize, infiltinfosize, outfiltinfosize;
    PIPX_INFO_BLOCK_HEADER	InterfaceInfop;

    printf("Enter IPX Interface Index:");
    scanf("%d", &IfIndex);

    printf("Enter the new IPX Admin State: 1- ENABLED 2- DISABLED:");
    scanf("%d", &AdminState);

    printf("Enter the new RIP Admin State: 1- ENABLED 2- DISABLED:");
    scanf("%d", &RipAdminState);

    printf("Enter Update Mode on this interface: 1- STANDARD, 2- NONE, 3- AUTO-STATIC:");
    scanf("%d", &Update);

    printf("Enter the RIP global filter action on this if: 1- ENABLED, 2- DISABLED:");
    scanf("%d", &RipFilter);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)IfIndex,
				NULL,
				&ifinfosize,
				NULL,
				&infiltinfosize,
				NULL,
				&outfiltinfosize);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("main: GetInterfaceInfo failed with rc=%d\n", rc);
	return;
    }

    InterfaceInfop = GlobalAlloc(GPTR, ifinfosize);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)IfIndex,
				InterfaceInfop,
				&ifinfosize,
				NULL,
				&infiltinfosize,
				NULL,
				&outfiltinfosize);

    if(rc != NO_ERROR) {

	printf("main: GetInterfaceInfo failed on second call with rc=%d\n", rc);
	return;
    }

    ipxinfop = GetInfoEntry(InterfaceInfop, IPX_INTERFACE_INFO_TYPE);
    ipxinfop->AdminState = AdminState;

    ripinfop = GetInfoEntry(InterfaceInfop, IPX_PROTOCOL_RIP);
    ripinfop->AdminState = RipAdminState;
    ripinfop->UpdateMode = Update;
    ripinfop->EnableGlobalFiltering = RipFilter;

    sapinfop = GetInfoEntry(InterfaceInfop, IPX_PROTOCOL_SAP);
    sapinfop->UpdateMode = Update;


    rc = (*dimif.SetInterfaceInfo)(
			       (HANDLE)IfIndex,
			       InterfaceInfop,
			       NULL,
			       NULL);

    printf("main: SetInterfaceInfo returned %d \n", rc);
}

VOID
MainUpdate(VOID)
{
    ULONG	    IfIndex;
    DWORD	    UpdateResult;
    DWORD	    rc;

    printf("Enter interface index:");
    scanf("%d", &IfIndex);

    RmEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    rc = (*dimif.UpdateRoutes)((HANDLE)IfIndex, RmEvent);

    if(rc != NO_ERROR) {

	printf("UpdateRoutes failed with rc = %d\n", rc);
	return;
    }

    printf("Main: Waiting for the update result ... (for 30 sec)\n");

    rc = WaitForSingleObject(RmEvent, 30000);

    if(rc == WAIT_TIMEOUT) {

	printf("Main: Update wait failed with timeout\n");
	return;
    }

    if((rc = (*dimif.GetUpdateRoutesResult)((HANDLE)IfIndex, &UpdateResult)) != NO_ERROR) {

	printf("Cannot get update result rc = %d\n", rc);
    }
    else
    {
	printf("UpdateResult = %d\n", UpdateResult);
    }

    CloseHandle(RmEvent);
}

VOID
SetRipFilters(VOID)
{
    ULONG			 filtcount, i, netnumber, rc;
    PRIP_ROUTE_FILTER_INFO	 rfip;

    printf("Enter RIP global filtering action: 1-advertise, 2-suppress:");
    scanf("%d", &gi.GI_RipGlobalInfo.RouteFilterAction);

    printf("Enter the number of filters (up to 16):");
    scanf("%d", &filtcount);

    for(i=0, rfip = &gi.GI_RipGlobalInfo.RouteFilter[0];
	i<filtcount;
	i++, rfip++)
    {
	printf("Enter net nr for filter # %d:", i);
	scanf("%x", &netnumber);

	PUTULONG2LONG(rfip->Network, netnumber);
    }

    gi.GI_RipGlobalInfo.RouteFiltersCount = filtcount;

    rc = (*dimif.SetGlobalInfo)(&gi);

    printf("SetGlobalInfo returned %d\n", rc);
}

VOID _cdecl
main(
    IN WORD argc,
    IN LPSTR argv[]
    )

{
    DWORD	rc;
    int 	i;
    PIPX_INFO_BLOCK_HEADER	   ph;
    PIPX_TOC_ENTRY		   tocep;
    PIPX_GLOBAL_INFO		   ipxgp;


    dimif.RouterStopped = RouterStopped;
    dimif.SaveInterfaceInfo = SaveInterfaceInfo;

    ph = &gi.GI_Header;
    ph->Version = 1;
    ph->Size = sizeof(gi);
    ph->TocEntriesCount = 3;

    tocep = ph->TocEntry;
    tocep->InfoType = IPX_GLOBAL_INFO_TYPE;
    tocep->InfoSize = sizeof(IPX_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_IpxGlobalInfo - (PUCHAR)&gi);

    tocep++;

    tocep->InfoType = IPX_PROTOCOL_RIP;
    tocep->InfoSize = sizeof(RIP_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_RipGlobalInfo - (PUCHAR)&gi);

    tocep++;

    tocep->InfoType = IPX_PROTOCOL_SAP;
    tocep->InfoSize = sizeof(SAP_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_SapGlobalInfo - (PUCHAR)&gi);

    ipxgp = &gi.GI_IpxGlobalInfo;
    ipxgp->NumRoutingProtocols = 2;
    wcscpy(ipxgp->DllName, IpxRipNamep);
    wcscpy(gi.SapName, IpxSapNamep);

    for(;;) {

	printf("IPX Router Test Menu:\n");
	printf("1. Start Router\n");
	printf("2. Stop Router\n");
	printf("3. Add Interface\n");
	printf("4. Delete Interface\n");
	printf("5. Get Interface\n");
	printf("6. Set Interface\n");
	printf("7. Update\n");
	printf("8. Save Configuration\n");
	printf("9. Restore Configuration\n");
	printf("10. Rip filters test\n");
	printf("20. MIB Tests\n");
	printf("99. Exit\n");
	printf("Enter your option:");

	scanf("%d", &i);

	switch(i) {

	    case 1:

		rc = StartRouter(&dimif, FALSE, &gi);

		printf("main: StartRouter returned rc=%d\n", rc);
		break;

	    case 2:

		(*dimif.StopRouter)();
		printf("main: StopRouter \n");
		break;

	    case 3:

		MainAddInterface();
		break;

	    case 4:

		MainDeleteInterface();
		break;

	    case 5:

		MainGetInterface();
		break;

	    case 6:

		MainSetInterface();
		break;

	    case 7:

		MainUpdate();
		break;

	    case 8:

		SaveConfiguration(&dimif);
		break;

	    case 9:

		RestoreConfiguration(&dimif);
		break;

	    case 10:

		SetRipFilters();
		break;

	    case 20:

		TestMib(&dimif);
		break;

	    case 99:

		printf("exit\n");
		goto Exit;

	    default:

		break;
	}
    }

Exit:

    ExitProcess(0);
}

/*++

Function:	GetTocEntry
Descr:		Returns a pointer to the specified table of contents entry
		in the interface info block.

--*/



PIPX_TOC_ENTRY
GetTocEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	    ULONG			InfoEntryType)
{
    PIPX_TOC_ENTRY	tocep;
    UINT		i;

    for(i=0, tocep = InterfaceInfop->TocEntry;
	i<InterfaceInfop->TocEntriesCount;
	i++, tocep++) {

	if(tocep->InfoType == InfoEntryType) {

	    return tocep;
	}
    }

    return NULL;
}

/*++

Function:	GetInfoEntry
Descr:		Returns a pointer to the specified info entry in the interface
		control block. If more then one entries, returns a pointer to
		the first one.

--*/

LPVOID
GetInfoEntry(PIPX_INFO_BLOCK_HEADER	InterfaceInfop,
	     ULONG			InfoEntryType)
{
    PIPX_TOC_ENTRY	tocep;

    if(tocep = GetTocEntry(InterfaceInfop, InfoEntryType)) {

	return((LPVOID)((PUCHAR)InterfaceInfop + tocep->Offset));
    }
    else
    {
	return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\test\rtrtest2.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <rasman.h>
#include <dim.h>
#include <routprot.h>
#include <ipxrtdef.h>

// [pmay] this will no longer be neccessary when the ipx router
// is converted to use MprInfo api's.
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;

DIM_ROUTER_INTERFACE dimif;


VOID
TestMib(PDIM_ROUTER_INTERFACE dimifp);

VOID
RouterStopped(DWORD	protid,
	      DWORD	err)
{
    printf("main: RouterStopped: protid 0x%x err 0x%x\n", protid, err);
}


HANDLE	    RmEvent;

//*** IPX Router Global Info ***

struct _GlobalInfo {

    IPX_INFO_BLOCK_HEADER	GI_Header;
    IPX_TOC_ENTRY		GI_RipTocEntry;
    IPX_TOC_ENTRY		GI_SapTocEntry;
    IPX_GLOBAL_INFO		GI_IpxGlobalInfo;
    WCHAR			SapName[MAX_DLL_NAME];
    RIP_GLOBAL_INFO		GI_RipGlobalInfo;
    SAP_GLOBAL_INFO		GI_SapGlobalInfo;

    } gi;

PWCHAR	IpxRipNamep = L"IPXRIP";
PWCHAR	IpxSapNamep = L"NWSAP";

struct _DBG_IF {

    IPX_INFO_BLOCK_HEADER	header;
    IPX_TOC_ENTRY		toc[6];
    IPX_IF_INFO 		ipxifinfo;
    RIP_IF_INFO 		ripifinfo;
    SAP_IF_INFO 		sapifinfo;
    IPXWAN_IF_INFO		ipxwanifinfo;
    IPX_ADAPTER_INFO		adapterinfo;
    IPX_STATIC_ROUTE_INFO	routeinfo[10];
    IPX_STATIC_SERVICE_INFO	srvinfo[10];
    } dbgif;

LPVOID	     dbgifgetp;

WCHAR		MainAdapterName[48];
WCHAR		MainInterfaceName[48];
ULONG		MainInterfaceType = ROUTER_IF_TYPE_DEDICATED;

HANDLE		MainInterfaceHandle;


#define ipxtoc			  dbgif.header.TocEntry[0]
#define riptoc			  dbgif.toc[0]
#define saptoc			  dbgif.toc[1]
#define ipxwantoc		  dbgif.toc[2]
#define adaptertoc		  dbgif.toc[3]
#define routetoc		  dbgif.toc[4]
#define srvtoc			  dbgif.toc[5]

VOID
MainAddInterface(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripifinfop;
    PSAP_IF_INFO	sapifinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    PIPX_STATIC_SERVICE_INFO srvinfop;
    BOOL		Enabled;
    int			i,j;
    BOOL		str = FALSE; // static routes info
    DWORD		rc;

    printf("Enter the interface name:");
    scanf("%S", &MainInterfaceName);

    printf("Enter the DIM Interface Handle:");
    scanf("%d", &i);

    printf("Enter interface type (0,1 - wan client, 2- wan router, 3 - lan, 4 - internal):");
    scanf("%d", &MainInterfaceType);

    switch(MainInterfaceType) {

	case 2:

	str = TRUE;
	break;

	case 3:

	printf("Enter LAN Adapter name:");
	scanf("%S", &MainAdapterName);
	break;

	default:

	break;
    }

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    if (str)
	dbgif.header.TocEntriesCount = 7;
    else
	dbgif.header.TocEntriesCount = 6;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = IPX_PROTOCOL_RIP;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    saptoc.InfoType = IPX_PROTOCOL_SAP;
    saptoc.InfoSize = sizeof(SAP_IF_INFO);
    saptoc.Count = 1;
    saptoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = saptoc.Offset + sizeof(SAP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    if (str) {

	routetoc.InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
	routetoc.InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
	routetoc.Count = 3;
	routetoc.Offset = adaptertoc.Offset + adaptertoc.InfoSize;

	srvtoc.InfoType = IPX_STATIC_SERVICE_INFO_TYPE;
	srvtoc.InfoSize = sizeof(IPX_STATIC_SERVICE_INFO);
	srvtoc.Count = 3;
	srvtoc.Offset = (ULONG)((PUCHAR)&dbgif.srvinfo - (PUCHAR)&dbgif);
    }

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosAccept = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = ADMIN_STATE_DISABLED;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 0;
    wcscpy(adapterinfop->AdapterName, MainAdapterName);

    ripifinfop = &dbgif.ripifinfo;

    ripifinfop->AdminState = ADMIN_STATE_ENABLED;
    ripifinfop->UpdateMode = IPX_STANDARD_UPDATE;
    ripifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    ripifinfop->Supply = ADMIN_STATE_ENABLED;
    ripifinfop->Listen = ADMIN_STATE_ENABLED;
    ripifinfop->EnableGlobalFiltering = ADMIN_STATE_ENABLED;

    sapifinfop = &dbgif.sapifinfo;

    sapifinfop->AdminState = ADMIN_STATE_ENABLED;
    sapifinfop->UpdateMode = IPX_STANDARD_UPDATE;
    sapifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    sapifinfop->Supply = ADMIN_STATE_ENABLED;
    sapifinfop->Listen = ADMIN_STATE_ENABLED;
    sapifinfop->EnableGlobalFiltering = ADMIN_STATE_ENABLED;

    ipxwaninfop = &dbgif.ipxwanifinfo;
    ipxwaninfop->AdminState = ADMIN_STATE_ENABLED;

    if (str) {

	routeinfop = dbgif.routeinfo;
	srvinfop = dbgif.srvinfo;

	for(j=0; j <3; j++, routeinfop++, srvinfop++)
	{
	    memset(routeinfop->Network, 0, 4);
	    routeinfop->Network[3] = i * 0x10 + j;
	    routeinfop->HopCount = 1;
	    routeinfop->TickCount = 1;
	    memset(routeinfop->NextHopMacAddress, i * 0x10 + j, 6);

	    srvinfop->Type = 4;
	    strcpy(srvinfop->Name, "TEST_STATIC_SERVER00");
	    srvinfop->Name[strlen(srvinfop->Name) - 1] = j + '0';
	    memcpy(srvinfop->Network, routeinfop->Network, 4);
	    memset(srvinfop->Node, i * 0x10 + j, 6);
	    memset(srvinfop->Socket, j, 2);
	    srvinfop->HopCount = 2;
	}
    }

    rc = (*dimif.AddInterface)(
			       MainInterfaceName,
			       &dbgif,
			       NULL,
			       MainInterfaceType,
			       TRUE,
			       (HANDLE)i,
			       &MainInterfaceHandle,
			       &Enabled);

    printf("main: AddInterface returned %d and IPX Interface Index  = %d\n",
	    rc,	MainInterfaceHandle);

}

VOID
MainDeleteInterface(VOID)
{
    ULONG ii;

    printf("Enter IPX Interface Index:");
    scanf("%d", &ii);
    (*dimif.DeleteInterface)((HANDLE)ii);
}

VOID
MainGetInterface(VOID)
{
    ULONG ii;
    DWORD ifinfosize;
    DWORD filtinfosize;
    DWORD rc;

    printf("Enter IPX Interface Index:");
    scanf("%d", &ii);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)ii,
				NULL,
				&ifinfosize,
				NULL,
				&filtinfosize);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("main: GetInterfaceInfo failed with rc=%d\n", rc);
	return;
    }

    dbgifgetp = GlobalAlloc(GPTR, ifinfosize);

    rc = (*dimif.GetInterfaceInfo)((HANDLE)ii,
				dbgifgetp,
				&ifinfosize,
				NULL,
				&filtinfosize);

    if(rc != NO_ERROR) {

	printf("main: GetInterfaceInfo failed on second call with rc=%d\n", rc);
	return;
    }
}

VOID
MainSetInterface(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripifinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    BOOL		Enabled;
    int			i,j;
    BOOL		str = FALSE; // static routes info
    DWORD		rc;
    ULONG		IfIndex;

    printf("Enter IPX Interface Index:");
    scanf("%d", &IfIndex);

    printf("Enter DIM Interface Index:");
    scanf("%d", &i);

    printf("Enter interface type (0,1 - wan client, 2- wan router, 3 - lan, 4 - internal):");
    scanf("%d", &MainInterfaceType);

    switch(MainInterfaceType) {

	case 2:

	str = TRUE;
	break;

	default:

	break;
    }

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    if (str)
	dbgif.header.TocEntriesCount = 5;
    else
	dbgif.header.TocEntriesCount = 4;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = IPX_PROTOCOL_RIP;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    if (str) {

	routetoc.InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
	routetoc.InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
	routetoc.Count = 2;
	routetoc.Offset = adaptertoc.Offset + adaptertoc.InfoSize;
    }

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = ADMIN_STATE_DISABLED;
    ipxinfop->NetbiosAccept = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = ADMIN_STATE_DISABLED;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 1;
    wcscpy(adapterinfop->AdapterName, MainAdapterName);

    ripifinfop = &dbgif.ripifinfo;

    ripifinfop->AdminState = ADMIN_STATE_DISABLED;
    ripifinfop->UpdateMode = IPX_STANDARD_UPDATE;
    ripifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    ripifinfop->Supply = ADMIN_STATE_ENABLED;
    ripifinfop->Listen = ADMIN_STATE_ENABLED;
    ripifinfop->EnableGlobalFiltering = ADMIN_STATE_ENABLED;

    ipxwaninfop = &dbgif.ipxwanifinfo;
    ipxwaninfop->AdminState = ADMIN_STATE_ENABLED;

    if (str) {

	routeinfop = dbgif.routeinfo;

	for(j=2; j <4; j++, routeinfop++)
	{
		memset(routeinfop->Network, 0, 4);
		routeinfop->Network[3] = i * 0x10 + j;
		routeinfop->HopCount = 1;
		routeinfop->TickCount = 1;
		memset(routeinfop->NextHopMacAddress, i * 0x10 + j, 6);
	}
    }

    rc = (*dimif.SetInterfaceInfo)(
			       (HANDLE)IfIndex,
			       &dbgif,
			       NULL,
			       &Enabled);

    printf("main: SetInterfaceInfo returned %d \n", rc);

}

VOID
MainSetInterfaceAdminState(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripifinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    BOOL		Enabled;
    int			i,j;
    BOOL		str = FALSE; // static routes info
    DWORD		rc;
    ULONG		IfIndex;
    ULONG		AdminState;

    printf("Enter IPX Interface Index:");
    scanf("%d", &IfIndex);

    printf("Enter the new IPX Admin State: 1- ENABLED 2- DISABLED:");
    scanf("%d", &AdminState);

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    dbgif.header.TocEntriesCount = 4;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = IPX_PROTOCOL_RIP;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = AdminState;
    ipxinfop->NetbiosAccept = ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = ADMIN_STATE_DISABLED;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 1;
    wcscpy(adapterinfop->AdapterName, MainAdapterName);

    ripifinfop = &dbgif.ripifinfo;

    ripifinfop->AdminState = ADMIN_STATE_ENABLED;
    ripifinfop->UpdateMode = IPX_STANDARD_UPDATE;
    ripifinfop->PacketType = IPX_STANDARD_PACKET_TYPE;
    ripifinfop->Supply = ADMIN_STATE_ENABLED;
    ripifinfop->Listen = ADMIN_STATE_ENABLED;
    ripifinfop->EnableGlobalFiltering = ADMIN_STATE_ENABLED;

    ipxwaninfop = &dbgif.ipxwanifinfo;
    ipxwaninfop->AdminState = ADMIN_STATE_ENABLED;

    rc = (*dimif.SetInterfaceInfo)(
			       (HANDLE)IfIndex,
			       &dbgif,
			       NULL,
			       &Enabled);

    printf("main: SetInterfaceInfo returned %d \n", rc);
}


VOID _cdecl
main(
    IN WORD argc,
    IN LPSTR argv[]
    )

{
    DWORD	rc;
    int 	i;
    PIPX_INFO_BLOCK_HEADER	   ph;
    PIPX_TOC_ENTRY		   tocep;
    PIPX_GLOBAL_INFO		   ipxgp;

    RmEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    dimif.RouterStopped = RouterStopped;
    dimif.hEventRmNotification = RmEvent;
    dimif.pGlobalInfo = &gi;

    ph = &gi.GI_Header;
    ph->Version = 1;
    ph->Size = sizeof(gi);
    ph->TocEntriesCount = 3;

    tocep = ph->TocEntry;
    tocep->InfoType = IPX_GLOBAL_INFO_TYPE;
    tocep->InfoSize = sizeof(IPX_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_IpxGlobalInfo - (PUCHAR)&gi);

    tocep++;

    tocep->InfoType = IPX_PROTOCOL_RIP;
    tocep->InfoSize = sizeof(RIP_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_RipGlobalInfo - (PUCHAR)&gi);

    tocep++;

    tocep->InfoType = IPX_PROTOCOL_SAP;
    tocep->InfoSize = sizeof(SAP_GLOBAL_INFO);
    tocep->Count = 1;
    tocep->Offset = (ULONG)((PUCHAR)&gi.GI_SapGlobalInfo - (PUCHAR)&gi);

    ipxgp = &gi.GI_IpxGlobalInfo;
    ipxgp->NumRoutingProtocols = 2;
    wcscpy(ipxgp->DllName, IpxRipNamep);
    wcscpy(gi.SapName, IpxSapNamep);

    for(;;) {

	printf("IPX Router Test Menu:\n");
	printf("1. Start Router\n");
	printf("2. Stop Router\n");
	printf("3. Add Interface\n");
	printf("4. Delete Interface\n");
	printf("5. Get Interface\n");
	printf("6. Set Interface\n");
	printf("7. Set Interface Admin State\n");
	printf("20. MIB Tests\n");
	printf("99. Exit\n");
	printf("Enter your option:");

	scanf("%d", &i);

	switch(i) {

	    case 1:

		rc = StartRouter(&dimif, FALSE);

		printf("main: StartRouter returned rc=%d\n", rc);
		break;

	    case 2:

		(*dimif.StopRouter)();
		printf("main: StopRouter \n");
		break;

	    case 3:

		MainAddInterface();
		break;

	    case 4:

		MainDeleteInterface();
		break;

	    case 5:

		MainGetInterface();
		break;

	    case 6:

		MainSetInterface();
		break;

	    case 7:

		MainSetInterfaceAdminState();
		break;

	    case 20:

		TestMib(&dimif);
		break;

	    case 99:

		printf("exit\n");
		goto Exit;

	    default:

		break;
	}
    }

Exit:

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\update.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    update.c

Abstract:

    The auto-static update routines

Author:

    Stefan Solomon  05/18/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

VOID
SaveUpdate(PVOID	 InterfaceIndex);

VOID
RestoreInterface (PVOID	 InterfaceIndex);

/*++

Function:	RequestUpdate

Descr:		Called to initiate an auto static update of routes and
		services on the specified interface.

--*/

DWORD
RequestUpdate(IN HANDLE	    InterfaceIndex,
	      IN HANDLE     hEvent)
{
    PICB	icbp;
    DWORD	rc;
    BOOL	RoutesUpdateStarted = FALSE;
    BOOL	ServicesUpdateStarted = FALSE;

    Trace(UPDATE_TRACE, "RequestUpdate: Entered for if # %d\n", InterfaceIndex);

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;

	Trace(UPDATE_TRACE, "RequestUpdate: Nonexistent interface with # %d\n", InterfaceIndex);

	return ERROR_INVALID_HANDLE;
    }

    SS_ASSERT(!memcmp(&icbp->Signature, InterfaceSignature, 4));

    // check if the interface is bound to a connected adapter
    if(icbp->OperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;

	Trace(UPDATE_TRACE, "RequestUpdate: adapter not connected on if # %d\n", InterfaceIndex);

	return ERROR_NOT_CONNECTED;
    }

    // check if an update is already pending
    if(IsUpdateRequestPending(icbp)) {

	RELEASE_DATABASE_LOCK;

	Trace(UPDATE_TRACE, "RequestUpdate: update already pending on if # %d\n", InterfaceIndex);

	return ERROR_UPDATE_IN_PROGRESS;
    }

    //
    // ***    Start a new update    ***
    //
    icbp->DIMUpdateEvent = hEvent;

    if((rc = RtProtRequestRoutesUpdate(icbp->InterfaceIndex)) == NO_ERROR) {

	icbp->UpdateReq.RoutesReqStatus = UPDATE_PENDING;
    }
    else
    {

	Trace(UPDATE_TRACE, "RequestUpdate: Routing Update is Disabled\n");
    }

    if((rc = RtProtRequestServicesUpdate(icbp->InterfaceIndex)) == NO_ERROR) {

	icbp->UpdateReq.ServicesReqStatus = UPDATE_PENDING;
    }
    else
    {
	Trace(UPDATE_TRACE, "RequestUpdate: Services Update is Disabled\n");
    }

    // if at least one of the protocols initiated the update, we qualify
    // the request as successfull, else it failed.
    if(!IsUpdateRequestPending(icbp)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    RELEASE_DATABASE_LOCK;
    return PENDING;
}



/*++


Function:	UpdateCompleted

Descr:		Invoked by the router manager worker when the routing protocol
		signals completion of the update request

--*/

VOID
UpdateCompleted(PUPDATE_COMPLETE_MESSAGE    ucmsgp)
{
    PICB		    icbp;
    BOOL		    UpdateDone;
    ULONG		    InterfaceIndex;
    HANDLE		    hDIMInterface;
#if DBG

    char *updttype;

#endif

    Trace(UPDATE_TRACE, "UpdateCompleted: Entered\n");

    UpdateDone = FALSE;

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(ucmsgp->InterfaceIndex)) == NULL) {

	RELEASE_DATABASE_LOCK;

	Trace(UPDATE_TRACE, "UpdateCompleted: Nonexistent interface with # %d\n",
		ucmsgp->InterfaceIndex);

	return;
    }

    InterfaceIndex = icbp->InterfaceIndex;

    // check if we have requested one, if not just discard
    if(!IsUpdateRequestPending(icbp)) {

	RELEASE_DATABASE_LOCK;
	return;
    }

    // fill in the result and check if we're done
    if(ucmsgp->UpdateType == DEMAND_UPDATE_ROUTES) {

	// ROUTES UPDATE
	Trace(UPDATE_TRACE, "UpdateCompleted: Routes update req done for if # %d with status %d\n",
				   ucmsgp->InterfaceIndex,
				   ucmsgp->UpdateStatus);

	if(ucmsgp->UpdateStatus == NO_ERROR) {


	    icbp->UpdateReq.RoutesReqStatus = UPDATE_SUCCESSFULL;

	    // if the update was successfull we delete all the static routes
	    // for this interface, and then CONVERT all the routes added by the
	    // protocol which did the update on this interface to static routes.

	    DeleteAllStaticRoutes(icbp->InterfaceIndex);

	    ConvertAllProtocolRoutesToStatic(icbp->InterfaceIndex, UpdateRoutesProtId);
	}
	else
	{
	    icbp->UpdateReq.RoutesReqStatus = UPDATE_FAILURE;
	}

	if(icbp->UpdateReq.ServicesReqStatus != UPDATE_PENDING) {

	    // we are done
	    UpdateDone = TRUE;
	}
    }
    else
    {
	// SERVICES UPDATE
	Trace(UPDATE_TRACE, "UpdateCompleted: Services update req done for if # %d with status %d\n",
				   ucmsgp->InterfaceIndex,
				   ucmsgp->UpdateStatus);

	if(ucmsgp->UpdateStatus == NO_ERROR) {

	    icbp->UpdateReq.ServicesReqStatus = UPDATE_SUCCESSFULL;

	    // we delete all the static services for this interface and then
	    // CONVERT all the services added by the protocol which did the
	    // update routes on this interface to static services

	    DeleteAllStaticServices(InterfaceIndex);

	    ConvertAllServicesToStatic(InterfaceIndex);
	}
	else
	{
	    icbp->UpdateReq.ServicesReqStatus = UPDATE_FAILURE;
	}

	if(icbp->UpdateReq.RoutesReqStatus != UPDATE_PENDING) {

	    // we are done
	    UpdateDone = TRUE;
	}
    }

    if(UpdateDone) {

	if((icbp->UpdateReq.RoutesReqStatus == UPDATE_SUCCESSFULL) &&
	   (icbp->UpdateReq.ServicesReqStatus == UPDATE_SUCCESSFULL)) {

	    icbp->UpdateResult = NO_ERROR;
	}
	else
	{
	    if((icbp->UpdateReq.RoutesReqStatus == UPDATE_FAILURE) ||
	      (icbp->UpdateReq.ServicesReqStatus == UPDATE_FAILURE)) {

		icbp->UpdateResult = ERROR_CAN_NOT_COMPLETE;
	    }
	    else
	    {
		// this is for the case when one or both protocols couldn't
		// do updates because they were not configured to update.
		icbp->UpdateResult = NO_ERROR;
	    }
	}

	ResetUpdateRequest(icbp);

	if(icbp->MIBInterfaceType != IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

	    SetEvent(icbp->DIMUpdateEvent);
        CloseHandle (icbp->DIMUpdateEvent);
        icbp->DIMUpdateEvent = NULL;
	}
    }

    // complete the update action by signaling DIM the final result
    // and saving the update result on disk

    if(UpdateDone &&
       (icbp->MIBInterfaceType != IF_TYPE_ROUTER_WORKSTATION_DIALOUT)) {

	InterfaceIndex = icbp->InterfaceIndex;

    if(RtlQueueWorkItem((icbp->UpdateResult == NO_ERROR) ? SaveUpdate : RestoreInterface,
                    (PVOID)UlongToPtr(InterfaceIndex), 0) == STATUS_SUCCESS) {

	    WorkItemsPendingCounter++;
	}
    }

    RELEASE_DATABASE_LOCK;
}

/*++

Function:	SaveUpdate

Descr:		Saves the new interface configuration on permanent storage

--*/

VOID
SaveUpdate(PVOID	 InterfaceIndex)
{
    LPVOID	InterfaceInfop = NULL;
    ULONG	InterfaceInfoSize = 0;
    DWORD	rc;
    HANDLE	hDIMInterface;
    PICB	icbp;

    if(RouterOperState != OPER_STATE_UP) {

	goto Exit;
    }

    rc = GetInterfaceInfo((HANDLE)InterfaceIndex,
			      InterfaceInfop,
			      &InterfaceInfoSize);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	// !!! log an error !!!

	goto Exit;
    }

    InterfaceInfop = GlobalAlloc(GPTR, InterfaceInfoSize);

    if(InterfaceInfop == NULL) {

	// !!! log error !!!

	goto Exit;
    }



    rc = GetInterfaceInfo((HANDLE)InterfaceIndex,
			      InterfaceInfop,
			      &InterfaceInfoSize);

    if(rc != NO_ERROR) {

	// !!! log error !!!
	GlobalFree(InterfaceInfop);

	goto Exit;
    }

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;
	goto Exit;
    }

    hDIMInterface = icbp->hDIMInterface;

    RELEASE_DATABASE_LOCK;

    // save the info on disk
    rc = SaveInterfaceInfo(hDIMInterface,
		      PID_IPX,
		      InterfaceInfop,
		      InterfaceInfoSize);

    SS_ASSERT(rc == NO_ERROR);

    GlobalFree(InterfaceInfop);


Exit:

    ACQUIRE_DATABASE_LOCK;

    WorkItemsPendingCounter--;

    RELEASE_DATABASE_LOCK;
}

/*++

Function:	RestoreInterface

Descr:		Restore interface configuration from permanent storage

--*/

VOID
RestoreInterface (PVOID	 InterfaceIndex)
{
    LPVOID	InterfaceInfop = NULL;
    ULONG	InterfaceInfoSize = 0;
    DWORD	rc;
    HANDLE	hDIMInterface;
    PICB	icbp;

    if(RouterOperState != OPER_STATE_UP) {

	goto Exit;
    }

    ACQUIRE_DATABASE_LOCK;

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;
	goto Exit;
    }

    hDIMInterface = icbp->hDIMInterface;

    RELEASE_DATABASE_LOCK;



    // get the info from disk
    InterfaceInfoSize = 0;
    InterfaceInfop = NULL;
    rc = RestoreInterfaceInfo (hDIMInterface,
		      PID_IPX,
		      InterfaceInfop,
		      &InterfaceInfoSize);
    if (rc==ERROR_BUFFER_TOO_SMALL) {
        InterfaceInfop = GlobalAlloc (GMEM_FIXED, InterfaceInfoSize);
        if (InterfaceInfop!=NULL) {
            rc = RestoreInterfaceInfo(hDIMInterface,
		              PID_IPX,
		              InterfaceInfop,
		              &InterfaceInfoSize);
        }
        else
            rc = GetLastError ();
    }

    if (rc == NO_ERROR)
        rc = SetInterfaceInfo (InterfaceIndex, InterfaceInfop);

    if (InterfaceInfop!=NULL)
        GlobalFree(InterfaceInfop);


Exit:

    ACQUIRE_DATABASE_LOCK;

    WorkItemsPendingCounter--;

    RELEASE_DATABASE_LOCK;
}

/*++

Function:	GetDIMUpdateResult

Descr:		Called by DDM to retrieve a message posted for it

--*/

DWORD
GetDIMUpdateResult(IN  HANDLE	    InterfaceIndex,
		   OUT LPDWORD	    UpdateResultp)
{
    PLIST_ENTRY     lep;
    PICB	    icbp;

    ACQUIRE_DATABASE_LOCK;

    if(RouterOperState != OPER_STATE_UP) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    if((icbp = GetInterfaceByIndex(PtrToUlong(InterfaceIndex))) == NULL) {

	RELEASE_DATABASE_LOCK;
	return ERROR_INVALID_PARAMETER;
    }

    // check that the update is not pending
    if(IsUpdateRequestPending(icbp)) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    *UpdateResultp = icbp->UpdateResult;

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\test\rtrtest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <rasman.h>
#include <rasddm.h>
#include <ipxrtdef.h>

// [pmay] this will no longer be neccessary when the ipx router
// is converted to use MprInfo api's.
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;


VOID
MibTest(VOID);

VOID
DbgAdapterEmulation(ULONG	AdapterStatus,
		    ULONG	AdapterIndex,
		    ULONG	InterfaceIndex,
		    ULONG	NdisMedium);

VOID
DbgConnectionRequest(ULONG   ifindex);


DDM_ROUTER_INTERFACE ddmif;

struct _DBG_IF {

    IPX_INFO_BLOCK_HEADER	header;
    IPX_TOC_ENTRY		toc[5];
    IPX_IF_INFO 		ipxifinfo;
    RIP_IF_INFO 		ripifinfo;
    SAP_IF_INFO 		sapifinfo;
    IPXWAN_IF_INFO		ipxwanifinfo;
    IPX_ADAPTER_INFO		adapterinfo;
    WCHAR			adaptername[4];
    IPX_STATIC_ROUTE_INFO	routeinfo[10];
    } dbgif;

struct _DBG_IF			dbgif1;

#define ipxtoc			  dbgif.header.TocEntry[0]
#define riptoc			  dbgif.toc[0]
#define saptoc			  dbgif.toc[1]
#define ipxwantoc		  dbgif.toc[2]
#define adaptertoc		  dbgif.toc[3]
#define routetoc		  dbgif.toc[4]

WCHAR		MainAdapterName[5] = { L'A', L'B', L'C', L'D', L'\0' };
WCHAR		MainInterfaceName[5] = { L'X', L'Y', L'Z', L'0', L'\0' };
ULONG		MainInterfaceType = ROUTER_IF_TYPE_DEDICATED;


HANDLE		MainInterfaceHandle;

VOID
MainAddInterface(VOID)
{
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripinfop;
    PSAP_IF_INFO	sapinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    BOOL		Enabled;
    int			i,j;
    BOOL		str; // static routes info

    printf("Enter interface number:");
    scanf("%d", &i);

    printf("Enter interface type (0,1,2 - wan, 3 - lan, 4 - internal):");
    scanf("%d", &MainInterfaceType);

    if(MainInterfaceType == 2) {
	str = TRUE;
    }
    else
    {
	str = FALSE;
    }

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    if (str)
	dbgif.header.TocEntriesCount = 6;
    else
	dbgif.header.TocEntriesCount = 5;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = RIP_INTERFACE_INFO_TYPE;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    saptoc.InfoType = SAP_INTERFACE_INFO_TYPE;
    saptoc.InfoSize = sizeof(SAP_IF_INFO);
    saptoc.Count = 1;
    saptoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = saptoc.Offset + sizeof(SAP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO) + wcslen(MainAdapterName) * sizeof(WCHAR);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    if (str) {

	routetoc.InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
	routetoc.InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
	routetoc.Count = 3;
	routetoc.Offset = adaptertoc.Offset + adaptertoc.InfoSize;
    }

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = IF_ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosAccept = IF_ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = IF_ADMIN_STATE_DISABLED;

    MainAdapterName[3] = L'0' + i;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 1;
    adapterinfop->AdapterNameLen = (wcslen(MainAdapterName) + 1) * sizeof(WCHAR);
    memcpy(adapterinfop->AdapterName, MainAdapterName, adapterinfop->AdapterNameLen);

    if (str) {

	routeinfop = dbgif.routeinfo;

	for(j=0; j <3; j++, routeinfop++)
	{
		memset(routeinfop->Network, 0, 4);
		routeinfop->Network[3] = i * 0x10 + j;
		routeinfop->HopCount = 1;
		routeinfop->TickCount = 1;
		memset(routeinfop->NextHopMacAddress, i * 0x10 + j, 6);
	}
    }

    MainInterfaceName[3] = L'0' + i;

    MainInterfaceHandle = (*ddmif.AddInterface)(MainInterfaceName,
				       &dbgif,
				       NULL,
				       MainInterfaceType,
				       TRUE,
				       &Enabled);

    printf("main: AddInterface returned 0x%x\n", MainInterfaceHandle);

}

VOID
MainDeleteInterface(VOID)
{
    ULONG ii;

    printf("Enter interface index:");
    scanf("%d", &ii);
    (*ddmif.DeleteInterface)((HANDLE)ii);
}

VOID
MainGetInterface(VOID)
{
    ULONG			ii;
    ULONG			IfInfoSize;
    ULONG			FilterInfoSize;
    IPX_INFO_BLOCK_HEADER	FilterInfo;
    DWORD			rc;

    printf("Enter interface index:");
    scanf("%d", &ii);

    rc = (*ddmif.GetInterfaceInfo)((HANDLE)ii,
			  NULL,
			  &IfInfoSize,
			  NULL,
			  &FilterInfoSize);


    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("MainGetInterface: bad error code rc= %d in first GetInterfaceInfo\n", rc);
	return;
    }

    printf("MainGetInterface: If info len = %d, Filter Info len = %d\n",
	    IfInfoSize, FilterInfoSize);

    rc = (*ddmif.GetInterfaceInfo)((HANDLE)ii,
			  &dbgif1,
			  &IfInfoSize,
			  NULL,
			  &FilterInfoSize);

    if(rc != NO_ERROR) {

	printf("MainGetInterface: bad error code rc= %d in second GetInterfaceInfo\n", rc);
    }
}

VOID
MainSetInterface(VOID)
{
    ULONG		ii;
    PIPX_IF_INFO	ipxinfop;
    PRIP_IF_INFO	ripinfop;
    PSAP_IF_INFO	sapinfop;
    PIPXWAN_IF_INFO	ipxwaninfop;
    PIPX_ADAPTER_INFO	adapterinfop;
    PIPX_STATIC_ROUTE_INFO   routeinfop;
    BOOL		Enabled;
    int			j, ri;
    DWORD		rc;

    printf("Enter if index:");
    scanf("%d", &ii);

    printf("Enter 3-no modif, 4- add a new route, 2- delete a route:");
    scanf("%d", &ri);

    dbgif.header.Version = IPX_ROUTER_VERSION_1;
    dbgif.header.Size = sizeof(dbgif);
    dbgif.header.TocEntriesCount = 6;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&dbgif.ipxifinfo - (PUCHAR)&dbgif);

    riptoc.InfoType = RIP_INTERFACE_INFO_TYPE;
    riptoc.InfoSize = sizeof(RIP_IF_INFO);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    saptoc.InfoType = SAP_INTERFACE_INFO_TYPE;
    saptoc.InfoSize = sizeof(SAP_IF_INFO);
    saptoc.Count = 1;
    saptoc.Offset = riptoc.Offset + sizeof(RIP_IF_INFO);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = saptoc.Offset + sizeof(SAP_IF_INFO);

    adaptertoc.InfoType = IPX_ADAPTER_INFO_TYPE;
    adaptertoc.InfoSize = sizeof(IPX_ADAPTER_INFO) + wcslen(MainAdapterName) * sizeof(WCHAR);
    adaptertoc.Count = 1;
    adaptertoc.Offset = ipxwantoc.Offset + ipxwantoc.InfoSize;

    routetoc.InfoType = IPX_STATIC_ROUTE_INFO_TYPE;
    routetoc.InfoSize = sizeof(IPX_STATIC_ROUTE_INFO);
    routetoc.Count = ri;
    routetoc.Offset = adaptertoc.Offset + adaptertoc.InfoSize;

    ipxinfop = (PIPX_IF_INFO)((PUCHAR)&dbgif + ipxtoc.Offset);
    ipxinfop->AdminState = IF_ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosAccept = IF_ADMIN_STATE_ENABLED;
    ipxinfop->NetbiosDeliver = IF_ADMIN_STATE_DISABLED;

    MainAdapterName[3] = L'0' + (UCHAR)ii;

    adapterinfop = (PIPX_ADAPTER_INFO)((PUCHAR)&dbgif + adaptertoc.Offset);
    adapterinfop->PacketType = 1;
    adapterinfop->AdapterNameLen = (wcslen(MainAdapterName) + 1) * sizeof(WCHAR);
    memcpy(adapterinfop->AdapterName, MainAdapterName, adapterinfop->AdapterNameLen);

    routeinfop = dbgif.routeinfo;

    for(j=0; j <ri; j++, routeinfop++)
    {
	memset(routeinfop->Network, 0, 4);

	routeinfop->Network[3] = (UCHAR)ii * 0x10 + j;
	routeinfop->HopCount = 1;
	routeinfop->TickCount = 1;
	memset(routeinfop->NextHopMacAddress, ii * 0x10 + j, 6);
    }

    rc = (*ddmif.SetInterfaceInfo)((HANDLE)ii,
			       &dbgif,
			       NULL,
			       &Enabled);

    printf("main: SetInterface returned 0x%x\n", rc);

}

VOID
MainEmulateAdapter(VOID)
{
    ULONG	   ai, ii, as, nm;

    printf("Enter adapter index:");
    scanf("%d", &ai);
    printf("Enter interface index:");
    scanf("%d", &ii);
    printf("Enter adapter status (1 - create, 2-delete, 3-connect, 4-disc):");
    scanf("%d", &as);
    printf("Enter adapter medium (0- LAN, 1 - WAN):");
    scanf("%d", &nm);

    DbgAdapterEmulation(as, ai, ii, nm);
}

VOID
MainConnReq(VOID)
{
    ULONG	ii;

    printf("Enter interface index to request connection:");
    scanf("%d", &ii);

    DbgConnectionRequest(ii);
}


VOID
RouterStarted(DWORD	protid)
{
    printf("main: RouterStarted: protid 0x%x\n", protid);
}

VOID
RouterStopped(DWORD	protid,
	      DWORD	err)
{
    printf("main: RouterStopped: protid 0x%x err 0x%x\n", protid, err);
}

DWORD
ConnectInterface(LPWSTR     InterfaceNamep,
		 ULONG	    pid)
{
    printf("Main: ConnectInterface: request to connect if %S\n", InterfaceNamep);
    return NO_ERROR;
}

VOID _cdecl
main(
    IN WORD argc,
    IN LPSTR argv[]
    )

{
    DWORD	rc;
    int 	i;

    ddmif.RouterStarted = RouterStarted;
    ddmif.RouterStopped = RouterStopped;
    ddmif.ConnectInterface = ConnectInterface;

    rc = InitializeRouter(&ddmif);

    printf("main: InitializeRouter returned %x\n", rc);

    for(;;) {

	printf("Router Manager Test Menu:\n");
	printf("1. Start router\n");
	printf("2. Stop router\n");
	printf("3. Add interface\n");
	printf("4. Delete interface\n");
	printf("5. Get interface\n");
	printf("6. Set interface\n");
	printf("7. Emulate adapters - create, connect, disconnect, delete\n");
	printf("8. Clear dbgif1\n");
	printf("9. MIB Test\n");
	printf("10. Connection request test\n");
	printf("99. Exit\n");
	printf("Enter your option:");

	scanf("%d", &i);

	switch(i) {

	    case 1:

		rc = (*ddmif.StartRouter)();
		printf("main: StartRouter rc=0x%x\n", rc);

		break;

	    case 2:

		(*ddmif.StopRouter)();
		printf("main: StopRouter \n");
		break;

	    case 3:

		MainAddInterface();
		break;

	    case 4:

		MainDeleteInterface();
		break;

	    case 5:

		MainGetInterface();
		break;

	    case 6:

		MainSetInterface();
		break;

	    case 7:

		MainEmulateAdapter();
		break;

	    case 8:

		memset(&dbgif1, 0, sizeof(dbgif1));
		break;

	    case 9:

		MibTest();
		break;

	    case 10:

		MainConnReq();
		break;

	    case 99:

		printf("exit\n");
		goto Exit;

	    default:

		break;
	}
    }

Exit:

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\test\testmib.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <rasman.h>
#include <dim.h>
#include <routprot.h>
#include <ipxrtdef.h>

// [pmay] this will no longer be neccessary when the ipx router
// is converted to use MprInfo api's.
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;

VOID
PrintInterface(PIPX_INTERFACE	    ifp);

VOID
PrintRipInterface(PRIP_INTERFACE	    ifp);

typedef struct _RPNAM {

    ULONG	prot;
    PUCHAR	namep;

    } RPNAM, *PRPNAM;

RPNAM	ProtName[] = {

	{ IPX_PROTOCOL_LOCAL, "LOCAL" },
	{ IPX_PROTOCOL_STATIC, "STATIC"	},
	{ IPX_PROTOCOL_RIP, "RIP" },
	{ IPX_PROTOCOL_SAP, "SAP" }
	};

#define MAX_IPX_PROTOCOLS  sizeof(ProtName)/sizeof(RPNAM)

IPX_INTERFACE	    IpxIf;

VOID
GetIpxInterface(PDIM_ROUTER_INTERFACE	dimifp)
{
    ULONG	    ii;
    DWORD	    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD	    IfSize;

    IfSize = sizeof(IPX_INTERFACE);

    printf("Enter interface index:");
    scanf("%d", &ii);

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = ii;

    rc = (*(dimifp->MIBEntryGet))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&IfSize,
				&IpxIf);


    if(rc != NO_ERROR) {

	printf("MibEntryGet: failed rc = %d\n", rc);
	return;
    }

    PrintInterface(&IpxIf);
}

VOID
GetRipInterface(PDIM_ROUTER_INTERFACE	dimifp)
{
    DWORD			rc;
    ULONG			IfSize;
    RIP_MIB_GET_INPUT_DATA	RipMibGetInputData;
    RIP_INTERFACE		RipIf;

    printf("Enter interface index:");
    scanf("%d", &RipMibGetInputData.InterfaceIndex);

    RipMibGetInputData.TableId = RIP_INTERFACE_TABLE;

    rc = (*(dimifp->MIBEntryGet))(
				IPX_PROTOCOL_RIP,
				sizeof(RIP_MIB_GET_INPUT_DATA),
				&RipMibGetInputData,
				&IfSize,
				&RipIf);


    if(rc != NO_ERROR) {

	printf("MibEntryGet: failed rc = %d\n", rc);
	return;
    }

    PrintRipInterface(&RipIf);
}


VOID
GetRipFilters(PDIM_ROUTER_INTERFACE	dimifp)
{
    DWORD			rc;
    ULONG			GlobalInfoSize, i;
    RIP_MIB_GET_INPUT_DATA	RipMibGetInputData;
    PRIP_GLOBAL_INFO		RipGlobalInfop;
    PRIP_ROUTE_FILTER_INFO	rfip;
    char			*action;

    RipMibGetInputData.TableId = RIP_GLOBAL_INFO_ENTRY;

    rc = (*(dimifp->MIBEntryGet))(
				IPX_PROTOCOL_RIP,
				sizeof(RIP_MIB_GET_INPUT_DATA),
				&RipMibGetInputData,
				&GlobalInfoSize,
				NULL);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("MibEntryGet: failed rc = %d\n", rc);
	return;
    }

    RipGlobalInfop = GlobalAlloc(GPTR, GlobalInfoSize);

    rc = (*(dimifp->MIBEntryGet))(
				IPX_PROTOCOL_RIP,
				sizeof(RIP_MIB_GET_INPUT_DATA),
				&RipMibGetInputData,
				&GlobalInfoSize,
				RipGlobalInfop);

    if(rc != NO_ERROR) {

	printf("MibEntryGet: failed rc = %d\n", rc);
	return;
    }

    if(RipGlobalInfop->RouteFiltersCount == 0) {

	printf("No Filters\n");
	return;
    }

    if(RipGlobalInfop->RouteFilterAction == IPX_ROUTE_FILTER_ADVERTISE) {

	action = "ADVERTISE";
    }
    else
    {
	action = "SUPPRESS";
    }

    printf("There are %d RIP filters configured for %s\n",
	    RipGlobalInfop->RouteFiltersCount,
	    action);

    for(i=0, rfip=RipGlobalInfop->RouteFilter;
	i<RipGlobalInfop->RouteFiltersCount;
	i++, rfip++)
    {
	printf("Route filter # %d Network %.2x%.2x%.2x%.2x\n",
	       i,
	       rfip->Network[0],
	       rfip->Network[1],
	       rfip->Network[2],
	       rfip->Network[3]);
    }

    GlobalFree(RipGlobalInfop);
}



VOID
PrintInterface(PIPX_INTERFACE	    ifp)
{
    char *iftype;
    char *admin;
    char *oper;

    switch(ifp->InterfaceType) {

	case IF_TYPE_WAN_WORKSTATION:

	    iftype ="WAN WORKSTATION";
	    break;

	case IF_TYPE_WAN_ROUTER:

	    iftype = "WAN ROUTER";
	    break;

	case IF_TYPE_LAN:

	    iftype = "LAN";
	    break;

	case IF_TYPE_INTERNAL:

	    iftype = "INTERNAL";
	    break;

	default:

	    iftype = "UNKNOWN";
	    break;

    }

    switch(ifp->AdminState) {

	case ADMIN_STATE_ENABLED:

	    admin = "ENABLED";
	    break;

	case ADMIN_STATE_DISABLED:

	    admin = "DISABLED";
	    break;

	default:

	    admin = "UNKNOWN";
	    break;
    }

    switch(ifp->IfStats.IfOperState) {

	case OPER_STATE_UP:

	    oper = "UP";
	    break;

	case OPER_STATE_DOWN:

	    oper = "DOWN";
	    break;

	case OPER_STATE_SLEEPING:

	    oper = "SLEEPING";
	    break;

	default:

	    oper = "UNKNOWN";
	    break;
    }

    printf("\n");
    printf("Interface Index: %d\n", ifp->InterfaceIndex);
    printf("Name: %s\n", ifp->InterfaceName);
    printf("Type: %s\n", iftype);
    printf("Network Number: %.2x%.2x%.2x%.2x\n",
	    ifp->NetNumber[0],
	    ifp->NetNumber[1],
	    ifp->NetNumber[2],
	    ifp->NetNumber[3]);
    printf("Admin State: %s\n", admin);
    printf("Oper State: %s\n\n", oper);
}

#define REPORT_RIP_CONFIG_STATE(report, config)    \
	switch((config)) {\
	case ADMIN_STATE_ENABLED:\
	    (report) = "ENABLED";\
	    break;\
	case ADMIN_STATE_DISABLED:\
	    (report) = "DISABLED";\
	    break;\
	default:\
	    (report) = "UNKNOWN";\
	    break;\
	}

VOID
PrintRipInterface(PRIP_INTERFACE	    ifp)
{
    char *admin;
    char *oper;
    char *filtering;
    char *supply;
    char *listen;
    char *update;

    REPORT_RIP_CONFIG_STATE(admin, ifp->RipIfInfo.AdminState);
    REPORT_RIP_CONFIG_STATE(supply, ifp->RipIfInfo.Supply);
    REPORT_RIP_CONFIG_STATE(listen, ifp->RipIfInfo.Listen);
    REPORT_RIP_CONFIG_STATE(filtering, ifp->RipIfInfo.EnableGlobalFiltering);
    switch(ifp->RipIfStats.RipIfOperState) {

	case OPER_STATE_UP:

	    oper = "UP";
	    break;

	case OPER_STATE_DOWN:

	    oper = "DOWN";
	    break;

	case OPER_STATE_SLEEPING:

	    oper = "SLEEPING";
	    break;

	default:

	    oper = "UNKNOWN";
	    break;
    }
    switch(ifp->RipIfInfo.UpdateMode) {

	case IPX_STANDARD_UPDATE:

	    update = "STANDARD";
	    break;

	case IPX_NO_UPDATE:

	    update = "NO UPDATE";
	    break;

	case IPX_AUTO_STATIC_UPDATE:

	    update = "AUTO-STATIC";
	    break;

	default:

	    break;
    }

    printf("\n");
    printf("Interface Index: %d\n", ifp->InterfaceIndex);
    printf("Admin State: %s\n", admin);
    printf("Oper State: %s\n", oper);
    printf("Supply RIP advertisments: %s\n", supply);
    printf("Listen to RIP advertisments: %s\n", listen);
    printf("Enable Global RIP Filtering: %s\n", filtering);
    printf("Update Mode: %s\n", update);
    printf("RIP packets recv: %d\n", ifp->RipIfStats.RipIfInputPackets);
    printf("RIP packets sent: %d\n\n", ifp->RipIfStats.RipIfOutputPackets);
}

VOID
EnumerateIpxInterfaces(PDIM_ROUTER_INTERFACE   dimifp)
{
    DWORD	   rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD	    IfSize;

    IfSize = sizeof(IPX_INTERFACE);

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 0;

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&IfSize,
				&IpxIf);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    PrintInterface(&IpxIf);

    for(;;)
    {
	MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = IpxIf.InterfaceIndex;

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&IfSize,
				&IpxIf);

	if(rc != NO_ERROR) {

	    printf("EnumerateIpxInterfaces: MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	PrintInterface(&IpxIf);
    }
}


IPX_ROUTE	Route;

VOID
PrintRoute(VOID);

VOID
EnumerateAllBestRoutes(PDIM_ROUTER_INTERFACE   dimifp)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    RtSize;

    RtSize = sizeof(IPX_ROUTE);

    MibGetInputData.TableId = IPX_DEST_TABLE;
    memset(MibGetInputData.MibIndex.RoutingTableIndex.Network, 0, 4);

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&RtSize,
				&Route);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    PrintRoute();

    for(;;)
    {
	memcpy(MibGetInputData.MibIndex.RoutingTableIndex.Network, Route.Network, 4);

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&RtSize,
				&Route);

	if(rc != NO_ERROR) {

	    printf("MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	PrintRoute();
    }
}

VOID
PrintRoute(VOID)
{
    int i;
    PUCHAR     pn = "BOGUS";

    for(i=0; i<MAX_IPX_PROTOCOLS; i++) {

	if(ProtName[i].prot == Route.Protocol) {

	    pn = ProtName[i].namep;
	    break;
	}
    }

    printf("Route: if # 0x%x, prot %s net %.2x%.2x%.2x%.2x ticks %d hops %d nexthop %.2x%.2x%.2x%.2x%.2x%.2x\n",
	    Route.InterfaceIndex,
	    pn,
	    Route.Network[0],
	    Route.Network[1],
	    Route.Network[2],
	    Route.Network[3],
	    Route.TickCount,
	    Route.HopCount,
	    Route.NextHopMacAddress[0],
	    Route.NextHopMacAddress[1],
	    Route.NextHopMacAddress[2],
	    Route.NextHopMacAddress[3],
	    Route.NextHopMacAddress[4],
	    Route.NextHopMacAddress[5]);
}

VOID
EnumerateStaticRoutes(PDIM_ROUTER_INTERFACE	 dimifp)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    RtSize;

    RtSize = sizeof(IPX_ROUTE);

    MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
    MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex = 0;
    memset(MibGetInputData.MibIndex.StaticRoutesTableIndex.Network, 0, 4);

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&RtSize,
				&Route);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    PrintRoute();

    for(;;)
    {
	memcpy(MibGetInputData.MibIndex.StaticRoutesTableIndex.Network, Route.Network, 4);
	MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex = Route.InterfaceIndex;

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&RtSize,
				&Route);

	if(rc != NO_ERROR) {

	    printf("MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	PrintRoute();
    }
}


IPX_SERVICE	    Service;

VOID
PrintService(VOID)
{
    int i;
    PUCHAR     pn = "BOGUS";

    for(i=0; i<MAX_IPX_PROTOCOLS; i++) {

	if(ProtName[i].prot == Service.Protocol) {

	    pn = ProtName[i].namep;
	    break;
	}
    }

    printf("Service if # %d prot %s type %d name %s\n",
	   Service.InterfaceIndex,
	   pn,
	   Service.Server.Type,
	   Service.Server.Name);
}

VOID
EnumerateAllServers(PDIM_ROUTER_INTERFACE	 dimifp)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    SvSize;

    SvSize = sizeof(IPX_SERVICE);

    MibGetInputData.TableId = IPX_SERV_TABLE;
    MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = 0;
    memset(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, 0, 48);

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&SvSize,
				&Service);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    PrintService();

    for(;;)
    {
	MibGetInputData.MibIndex.ServicesTableIndex.ServiceType =  Service.Server.Type;
	memcpy(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, Service.Server.Name, 48);

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&SvSize,
				&Service);

	if(rc != NO_ERROR) {

	    printf("MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	PrintService();
    }
}

VOID
EnumerateAllServersOfType(PDIM_ROUTER_INTERFACE	 dimifp,
			  USHORT		 Type)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    SvSize;

    SvSize = sizeof(IPX_SERVICE);

    MibGetInputData.TableId = IPX_SERV_TABLE;
    MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = Type;
    memset(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, ' ', 40);

    for(;;)
    {
	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&SvSize,
				&Service);

	if(rc != NO_ERROR) {

	    printf("MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	if(Service.Server.Type != Type)
	{
	    return;
	}

	PrintService();
	memcpy(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, Service.Server.Name, 48);
    }
}

VOID
EnumerateStaticServers(PDIM_ROUTER_INTERFACE	 dimifp)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    SvSize;

    SvSize = sizeof(IPX_SERVICE);

    MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
    MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex = 0;
    MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType = 0;
    memset(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, 0, 48);

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&SvSize,
				&Service);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    PrintService();

    for(;;)
    {
	MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex = Service.InterfaceIndex;
	MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType =	Service.Server.Type;
	memcpy(MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName, Service.Server.Name, 48);

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&SvSize,
				&Service);

	if(rc != NO_ERROR) {

	    printf("MIBEntryGetNext failed rc= 0x%x\n", rc);
	    return;
	}

	PrintService();
    }
}

VOID
TestMib(PDIM_ROUTER_INTERFACE	dimifp)
{
    int 	i;
    int 	Type;

    for(;;) {

	printf("    MIB TEST OPTIONS MENU:\n");
	printf("1. MIB TEST - Get IPX interface\n");
	printf("2. MIB TEST - Enumerate IPX Interfaces\n");
	printf("3. MIB TEST - Enumerate all best routes\n");
	printf("4. MIB TEST - Enumerate static routes\n");
	printf("5. MIB TEST - Enumerate all servers\n");
	printf("6. MIB TEST - Enumerate all servers of the specified type\n");
	printf("7. MIB TEST - Enumerate all static servers\n");
	printf("8. MIB TEST - Get RIP Interface\n");
	printf("9. MIB TEST - Get RIP Filters\n");
	printf("99. MIB TEST - return to main menu\n");
	printf("Enter your option:");
	scanf("%d", &i);

	switch(i)
	{
	    case 1:

		GetIpxInterface(dimifp);
		break;

	    case 2:

		EnumerateIpxInterfaces(dimifp);
		break;

	    case 3:

		EnumerateAllBestRoutes(dimifp);
		break;

	    case 4:

		EnumerateStaticRoutes(dimifp);
		break;

	    case 5:

		EnumerateAllServers(dimifp);
		break;

	    case 6:

		printf("Enter server type:");
		scanf("%d", &Type);

		EnumerateAllServersOfType(dimifp, (USHORT)Type);
		break;

	    case 7:

		EnumerateStaticServers(dimifp);
		break;

	    case 8:

		GetRipInterface(dimifp);
		break;

	    case 9:

		GetRipFilters(dimifp);
		break;

	    case 99:

		return;

	    default:

		break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\timer.c ===
//
//  VERY USEFUL TIMER ROUTINES
//

BOOL
RtCreateTimer(IN PHANDLE  TimerHandlep)
{
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);

    Status = NtCreateTimer(TimerHandlep, TIMER_ALL_ACCESS, &ObjA);

    if (!NT_SUCCESS(Status)) {
	SS_PRINT(("Failed to create timer: %X\n", Status));
	return TRUE;
    }

    return FALSE;
}

BOOL
RtDestroyTimer(IN HANDLE	TimerHandle)
{
    NTSTATUS	Status;

    Status = NtClose(TimerHandle);

    if (!NT_SUCCESS(Status)) {
	SS_PRINT(("Failed to create timer: %X\n", Status));
	return TRUE;
    }

    return FALSE;
}

BOOL
RtSetTimer(
    IN HANDLE TimerHandle,
    IN ULONG MillisecondsToExpire,
    IN PTIMER_APC_ROUTINE  TimerRoutine,
    IN PVOID Context
    )
{
    LARGE_INTEGER TimerDueTime;
    NTSTATUS NtStatus;

    //
    //  Figure out the timeout.
    //

    TimerDueTime.QuadPart = Int32x32To64( MillisecondsToExpire, -10000 );

    //
    //  Set the timer to go off when it expires.
    //

    NtStatus = NtSetTimer(TimerHandle,
			  &TimerDueTime,
			  TimerRoutine,
			  Context,
			  NULL);

    if (!NT_SUCCESS(NtStatus)) {

	SS_PRINT(("RtSetTimer: Failed to set timer: 0x%x\n", NtStatus));
	SS_ASSERT(FALSE);

	return TRUE;
    }

    return FALSE;
}


BOOL
RtCancelTimer(
    IN HANDLE	TimerHandle;
    )
{
    NTSTATUS	 NtStatus;

    NtStatus = NtCancelTimer(TimerHandle, NULL);

    if (!NT_SUCCESS(NtStatus)) {

	SS_PRINT(("RtCancelTimer: Failed to cancel timer: 0x%x\n", NtStatus));

	return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\rtrmgr\test\config.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <rasman.h>
#include <dim.h>
#include <routprot.h>
#include <ipxrtdef.h>

// [pmay] this will no longer be neccessary when the ipx router
// is converted to use MprInfo api's.
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;


typedef struct _IF_CONFIG {

    BOOL		   Empty;
    WCHAR		   InterfaceName[48];
    HANDLE		   DimIfHandle;
    ROUTER_INTERFACE_TYPE  IfType;
    ULONG		   IfSize;

    } IF_CONFIG, *PIF_CONFIG;

FILE		    *ConfigFile;

typedef struct	_IF_TYPE_TRANSLATION {

    ROUTER_INTERFACE_TYPE	DimType;
    ULONG			IpxMibType;

    } IF_TYPE_TRANSLATION, *PIF_TYPE_TRANSLATION;

IF_TYPE_TRANSLATION   IfTypeTranslation[] = {

    { ROUTER_IF_TYPE_FULL_ROUTER, IF_TYPE_WAN_ROUTER },
    { ROUTER_IF_TYPE_HOME_ROUTER, IF_TYPE_PERSONAL_WAN_ROUTER },
    { ROUTER_IF_TYPE_DEDICATED,	  IF_TYPE_LAN },
    { ROUTER_IF_TYPE_CLIENT,	  IF_TYPE_WAN_WORKSTATION },
    { ROUTER_IF_TYPE_INTERNAL,	  IF_TYPE_INTERNAL }

   };

#define MAX_IF_TYPES	    sizeof(IfTypeTranslation)/sizeof(IF_TYPE_TRANSLATION)

VOID
SaveInterface(PDIM_ROUTER_INTERFACE	dimifp,
	      PIPX_INTERFACE		IpxIfp);


VOID
SaveConfiguration(PDIM_ROUTER_INTERFACE     dimifp)
{
    DWORD			    rc;
    IPX_MIB_GET_INPUT_DATA	    MibGetInputData;
    DWORD			    IfSize;
    IPX_INTERFACE		    IpxIf;
    IF_CONFIG			    IfConfig;

    // open configuration file
    if((ConfigFile = fopen("c:\\test\\config.bin", "w+b")) == NULL) {

	printf("SaveConfiguration: cannot open config file\n");
	return;
    }

    // get all configured interfaces from the rtrmgr and save them
    IfSize = sizeof(IPX_INTERFACE);

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 0;

    rc = (*(dimifp->MIBEntryGetFirst))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&IfSize,
				&IpxIf);


    if(rc != NO_ERROR) {

	printf("MIBEntryGetFirst: failed rc = %d\n", rc);
	return;
    }

    SaveInterface(dimifp, &IpxIf);

    for(;;)
    {
	MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = IpxIf.InterfaceIndex;

	rc = (*(dimifp->MIBEntryGetNext))(
				IPX_PROTOCOL_BASE,
				sizeof(IPX_MIB_GET_INPUT_DATA),
				&MibGetInputData,
				&IfSize,
				&IpxIf);

	if(rc != NO_ERROR) {

	    printf("EnumerateIpxInterfaces: MIBEntryGetNext failed rc= 0x%x\n", rc);
	    break;
	}

	SaveInterface(dimifp, &IpxIf);
    }

    // done
    IfConfig.Empty = TRUE;

    fwrite(&IfConfig, sizeof(IF_CONFIG), 1, ConfigFile);

    fclose(ConfigFile);
}

VOID
SaveInterface(PDIM_ROUTER_INTERFACE	dimifp,
	      PIPX_INTERFACE		IpxIfp)
{
    DWORD	    rc;
    ULONG	    IfSize = 0;
    ULONG	    InFtSize = 0;
    ULONG	    OutFtSize = 0;
    LPVOID	    IfInfop;
    IF_CONFIG	    IfConfig;
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;
    int 	    i;
    PIF_TYPE_TRANSLATION    ittp;

    rc = (*dimifp->GetInterfaceInfo)((HANDLE)(IpxIfp->InterfaceIndex),
				     NULL,
				     &IfSize,
				     NULL,
				     &InFtSize,
				     NULL,
				     &OutFtSize);

    if(rc != ERROR_INSUFFICIENT_BUFFER) {

	printf("SaveInterface: GetInterfaceInfo failed rc = %d\n", rc);
	return;
    }

    IfInfop = GlobalAlloc(GPTR, IfSize);

    rc = (*dimifp->GetInterfaceInfo)((HANDLE)(IpxIfp->InterfaceIndex),
				     IfInfop,
				     &IfSize,
				     NULL,
				     &InFtSize,
				     NULL,
				     &OutFtSize);

    if(rc != NO_ERROR) {

	printf("SaveInterface: GetInterfaceInfo failed rc = %d\n", rc);
	return;
    }

    // write an IfConfig item followed by the if info
    RtlInitAnsiString(&AnsiString, IpxIfp->InterfaceName);

    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

    memcpy(IfConfig.InterfaceName, UnicodeString.Buffer, UnicodeString.MaximumLength);
    IfConfig.Empty = FALSE;
    IfConfig.DimIfHandle = (HANDLE)IpxIfp->InterfaceIndex;
    IfConfig.IfSize = IfSize;

    for(i=0, ittp=IfTypeTranslation; i<MAX_IF_TYPES; i++, ittp++) {

	if(IpxIfp->InterfaceType == ittp->IpxMibType) {

	    IfConfig.IfType = ittp->DimType;
	    break;
	}
    }

    printf("Saving if index %d size %d\n", IpxIfp->InterfaceIndex, IfSize);

    fwrite(&IfConfig, sizeof(IF_CONFIG), 1, ConfigFile);

    fwrite(IfInfop, IfSize, 1, ConfigFile);

    GlobalFree(IfInfop);

    RtlFreeUnicodeString(&UnicodeString);
}

VOID
RestoreConfiguration(PDIM_ROUTER_INTERFACE     dimifp)
{
    IF_CONFIG			    IfConfig;
    LPVOID			    IfInfop;
    HANDLE			    IfIndex;
    PIF_TYPE_TRANSLATION	    ittp;
    DWORD			    rc;

    // open configuration file
    if((ConfigFile = fopen("c:\\test\\config.bin", "r+b")) == NULL) {

	printf("RestoreConfiguration: cannot open config file\n");
	return;
    }

    fread(&IfConfig, sizeof(IF_CONFIG), 1, ConfigFile);

    while(!IfConfig.Empty)
    {
	IfInfop = GlobalAlloc(GPTR, IfConfig.IfSize);

	fread(IfInfop, IfConfig.IfSize, 1, ConfigFile);

	rc = (*(dimifp->AddInterface))(IfConfig.InterfaceName,
				     IfInfop,
				     NULL,
				     NULL,
				     IfConfig.IfType,
				     TRUE,
				     IfConfig.DimIfHandle,
				     &IfIndex);

	if(rc != NO_ERROR) {

	    printf("RestoreConfiguration: failed with rc = %d\n", rc);
	    return;
	}

	printf("RestoreConfiguration: added if index %d\n", IfIndex);

	fread(&IfConfig, sizeof(IF_CONFIG), 1, ConfigFile);
    }

    fclose(ConfigFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\adaptdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\adaptdb.c

Abstract:

	This module implements interface to net adapter driver
	notification mechanism for standalone (not part of a router) SAP
	agent

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

HANDLE	ConfigEvent;
HANDLE	ConfigPort;

// Interval for periodic update broadcasts (for standalone service only)
ULONG	UpdateInterval = SAP_UPDATE_INTERVAL_DEF;

// Server aging timeout (for standalone service only)
ULONG	WanUpdateMode = SAP_WAN_UPDATE_MODE_DEF;

// Update mode on WAN lines (for standalone service only)
ULONG	WanUpdateInterval = SAP_WAN_UPDATE_INTERVAL_DEF;

// Interval for periodic update broadcasts on WAN lines (for standalone service only)
ULONG	ServerAgingTimeout = SAP_AGING_TIMEOUT_DEF;

// Makes pnp changes to an interface
DWORD SapReconfigureInterface (ULONG idx, 
                               PIPX_ADAPTER_BINDING_INFO pAdapter);


/*++
*******************************************************************
		C r e a t e A d a p t e r P o r t

Routine Description:
	Allocates resources and establishes connection to net adapter
	notification mechanism

Arguments:
	cfgEvent - event to be signalled when adapter configuration changes

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateAdapterPort (
	IN HANDLE		*cfgEvent
	) {
	DWORD						status;
	ADAPTERS_GLOBAL_PARAMETERS	params;

	ConfigEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
	if (ConfigEvent!=NULL) {
		*cfgEvent = ConfigEvent; 
		ConfigPort = IpxCreateAdapterConfigurationPort(
								ConfigEvent,
								&params);
		if (ConfigPort!=INVALID_HANDLE_VALUE) 
			return NO_ERROR;
		else {
			status = GetLastError ();
			Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Failed to create adapter cfg port(gle:%ld).",
									__FILE__, __LINE__, status);
			}
		CloseHandle (ConfigEvent);
		}
	else {
		status = GetLastError ();
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Failed to create cfg event(gle:%ld).",
								__FILE__, __LINE__, status);
		}

	return status;
	}

/*++
*******************************************************************
		D e l e t e A d a p t e r P o r t

Routine Description:
	Dispose of resources and break connection to net adapter
	notification mechanism

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteAdapterPort (
	void
	) {
	IpxDeleteAdapterConfigurationPort (ConfigPort);
	ConfigPort = NULL;
	CloseHandle (ConfigEvent);
	ConfigEvent = NULL;
	}



/*++
*******************************************************************
		P r o c e s s A d a p t e r E v e n t s

Routine Description:
	Dequeues and process adapter configuration change events and maps them
	to interface configuration calls
	This routine should be called when configuration event is signalled

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessAdapterEvents (
	VOID
	) {
	ULONG						cfgStatus;
	ADAPTER_INFO				params;
	ULONG						idx;
	SAP_IF_INFO					info;
	IPX_ADAPTER_BINDING_INFO	adapter;
	NET_INTERFACE_TYPE			InterfaceType;
	DWORD                       dwErr;

	while (IpxGetQueuedAdapterConfigurationStatus (
									ConfigPort,
									&idx,
									&cfgStatus,
									&params)==NO_ERROR) {
		switch (cfgStatus) {
			case ADAPTER_CREATED:
			case ADAPTER_UP:
				Trace (DEBUG_ADAPTERS, "New adapter %d"
								" (addr: %02X%02X%02X%02X:"
								"%02X%02X%02X%02X%02X%02X).",
												idx,
												params.Network[0],
												params.Network[1],
												params.Network[2],
												params.Network[3],
												params.LocalNode[0],
												params.LocalNode[1],
												params.LocalNode[2],
												params.LocalNode[3],
												params.LocalNode[4],
												params.LocalNode[5]);
				info.AdminState = ADMIN_STATE_ENABLED;
				info.PacketType = IPX_STANDARD_PACKET_TYPE;
				info.Supply = ADMIN_STATE_ENABLED;
				info.Listen = ADMIN_STATE_ENABLED;
				info.GetNearestServerReply = ADMIN_STATE_ENABLED;

				IpxNetCpy (adapter.Network, params.Network);
				IpxNodeCpy (adapter.LocalNode, params.LocalNode);
				if (params.NdisMedium==NdisMediumWan) {
					InterfaceType = DEMAND_DIAL;
					switch (WanUpdateMode) {
						case SAP_WAN_NO_UPDATE:
							info.UpdateMode = IPX_NO_UPDATE;
							break;
						case SAP_WAN_CHANGES_ONLY:
							info.UpdateMode = IPX_STANDARD_UPDATE;
							info.PeriodicUpdateInterval = MAXULONG;
							break;
						case SAP_WAN_STANDART_UPDATE:
							info.UpdateMode = IPX_STANDARD_UPDATE;
							info.PeriodicUpdateInterval = WanUpdateInterval*60;
							info.AgeIntervalMultiplier = ServerAgingTimeout/UpdateInterval;
							break;
						}
					IpxNodeCpy (adapter.RemoteNode, params.RemoteNode);
					}
				else {
					InterfaceType = PERMANENT;
					info.UpdateMode = IPX_STANDARD_UPDATE;
					info.PeriodicUpdateInterval = UpdateInterval*60;
					info.AgeIntervalMultiplier = ServerAgingTimeout/UpdateInterval;
					memset (adapter.RemoteNode, 0xFF, sizeof (adapter.RemoteNode));
					}
				adapter.MaxPacketSize = params.MaxPacketSize;
				adapter.AdapterIndex = idx;
				if (((dwErr = SapCreateSapInterface (L"",idx, InterfaceType, &info)) == NO_ERROR)
						&& (SapSetInterfaceEnable (idx, TRUE)==NO_ERROR)) {
					SapBindSapInterfaceToAdapter (idx, &adapter);
					}
			    else if (dwErr == ERROR_ALREADY_EXISTS) {
			        SapReconfigureInterface (idx, &adapter);
    				Trace (DEBUG_ADAPTERS, "Adapter %d has been reconfigured", idx);
			    }
				break;

			case ADAPTER_DOWN:
			case ADAPTER_DELETED:
				Trace (DEBUG_ADAPTERS, "Adapter %d is gone.", idx);
				SapDeleteSapInterface (idx);
				break;
			default:
				Trace (DEBUG_ADAPTERS, "Unknown adapter event %d.", cfgStatus);
			}
		}

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\filters.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\filter.h

Abstract:

	Header file for sap filter handler

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_FILTER_
#define _SAP_FILTER_

#define FILTER_NAME_HASH_SIZE	257
#define FILTER_TYPE_HASH_SIZE	37

#define FILTER_TYPE_SUPPLY		0
#define FILTER_TYPE_LISTEN		1
#define MAX_FILTER_TYPES		2

typedef struct _FILTER_NODE {
		LIST_ENTRY					FN_Link;	// Link in hash table
		ULONG						FN_Index;	// Interface index
		PSAP_SERVICE_FILTER_INFO	FN_Filter;	// Filter info
		} FILTER_NODE, *PFILTER_NODE;

typedef struct _FILTER_TABLE {
		LONG						FT_ReaderCount;
		HANDLE						FT_SyncEvent;
		LIST_ENTRY					FT_AnyAnyList;
		LIST_ENTRY					FT_NameHash[FILTER_NAME_HASH_SIZE];
		LIST_ENTRY					FT_TypeHash[FILTER_TYPE_HASH_SIZE];
		CRITICAL_SECTION			FT_Lock;
		} FILTER_TABLE, *PFILTER_TABLE;

#define ACQUIRE_SHARED_FILTER_TABLE_LOCK(Table) {						\
		EnterCriticalSection (&Table->FT_Lock);							\
		InterlockedIncrement (&Table->FT_ReaderCount);					\
		LeaveCriticalSection (&Table->FT_Lock);							\
		}

#define RELEASE_SHARED_FILTER_TABLE_LOCK(Table) {						\
		if (InterlockedDecrement (&Table->FT_ReaderCount)<0) {			\
			BOOL	__res = SetEvent (&Table->FT_SyncEvent);			\
			ASSERTERRMSG ("Could not set filter table event ", __res);	\
			}															\
		}

#define ACQUIRE_EXCLUSIVE_FILTER_TABLE_LOCK(Table) {					\
		EnterCriticalSection (&Table->FT_Lock);							\
		if (InterlockedDecrement (&Table->FT_ReaderCount)>=0) {			\
			DWORD status = WaitForSingleObject (Table->FT_SyncEvent,	\
													INFINITE);			\
			ASSERTMSG ("Failed wait on filter table event ",			\
											status==WAIT_OBJECT_0);		\
			}															\
		}

#define RELEASE_EXCLUSIVE_FILTER_TABLE_LOCK(Table) {					\
		Table->FT_ReaderCount = 0;										\
		LeaveCriticalSection (&Table->FT_Lock);							\
		}



/*++
*******************************************************************
		C r e a t e F i l t e r T a b l e

Routine Description:
	Allocates resources for filtering

Arguments:
	None
Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateFilterTable (
	void
	);


/*++
*******************************************************************
		D e l e t e F i l t e r T a b l e

Routine Description:
	Disposes of resources assiciated with filtering

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteFilterTable (
	void
	);

/*++
*******************************************************************
		R e p l a c e F i l t e r s

Routine Description:
	Replaces filters in the filter table
Arguments:
	filterType	- type of filters to replace (Listen/Supply)
	oldFilters - block with filters to be removed
	oldCount - number of filters in the block
	newFilters - block with filters to be added
	newCount - number of filter in the block
Return Value:
	None

*******************************************************************
--*/
VOID
ReplaceFilters (
	IN INT				FilterType,				
	IN PFILTER_NODE		oldFilters OPTIONAL,
	IN ULONG			oldCount OPTIONAL,
	IN PFILTER_NODE		newFilters OPTIONAL,
	IN ULONG			newCount OPTIONAL
	);



BOOL
Filter (
	IN INT		FilterType,				
	IN ULONG	InterfaceIndex,
	IN USHORT	Type,
	IN PUCHAR	Name
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\filters.c ===
#include "sapp.h"

#define FilterTypeHash(Type) (Type%FILTER_TYPE_HASH_SIZE)

FILTER_TABLE FilterTables[MAX_FILTER_TYPES];


INT
FilterNameHash (
	PUCHAR		Name
	) {
	INT		i;
	INT		res = 0;

	for (i=0; i<47; i++) {
		Name[i] = (UCHAR)toupper(Name[i]);
		if (Name[i]==0)
			break;
		else
			res += Name[i];
		}
	if ((i==47) && (Name[i]!=0)) {
		Name[i] = 0;
		}
	return res % FILTER_NAME_HASH_SIZE;
	}



/*++
*******************************************************************
		C r e a t e F i l t e r T a b l e

Routine Description:
	Allocates resources for filtering

Arguments:
	None
Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateFilterTable (
	void
	) {
	DWORD	status=NO_ERROR;
	INT		i,j;

	for (j=0; j<MAX_FILTER_TYPES; j++) {
		FilterTables[j].FT_SyncEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
		if (FilterTables[j].FT_SyncEvent!=NULL) {
			InitializeCriticalSection (&FilterTables[j].FT_Lock);
			InitializeListHead (&FilterTables[j].FT_AnyAnyList);
			for (i=0; i<FILTER_NAME_HASH_SIZE; i++)
				InitializeListHead (&FilterTables[j].FT_NameHash[i]);
			for (i=0; i<FILTER_TYPE_HASH_SIZE; i++)
				InitializeListHead (&FilterTables[j].FT_TypeHash[i]);
			FilterTables[j].FT_ReaderCount = 0;
			}
		else {
			status = GetLastError ();
			Trace (DEBUG_FAILURES, "File: %s, line %ld. "
						"Could not create filter table event (gle:%ld).",
										__FILE__, __LINE__, status);
			if (status==NO_ERROR)
				status = ERROR_CAN_NOT_COMPLETE;
			while (--j>=0) {
				CloseHandle (FilterTables[j].FT_SyncEvent);
				DeleteCriticalSection (&FilterTables[j].FT_Lock);
				}
			break;
			}
		}

	return status;
	}
		
/*++
*******************************************************************
		D e l e t e F i l t e r T a b l e

Routine Description:
	Disposes of resources assiciated with filtering

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteFilterTable (
	void
	) {
	INT		j;
	for (j=0; j<MAX_FILTER_TYPES; j++) {
		CloseHandle (FilterTables[j].FT_SyncEvent);
		DeleteCriticalSection (&FilterTables[j].FT_Lock);
		}
	}

/*++
*******************************************************************
		R e p l a c e F i l t e r s

Routine Description:
	Replaces filters in the filter table
Arguments:
	filterType	- type of filters to replace (Listen/Supply)
	oldFilters - block with filters to be removed
	oldCount - number of filters in the block
	newFilters - block with filters to be added
	newCount - number of filter in the block
Return Value:
	None

*******************************************************************
--*/
VOID
ReplaceFilters (
	IN INT				FilterType,				
	IN PFILTER_NODE		oldFilters OPTIONAL,
	IN ULONG			oldCount OPTIONAL,
	IN PFILTER_NODE		newFilters OPTIONAL,
	IN ULONG			newCount OPTIONAL
	) {
	ULONG				i;
	DWORD				status;
	PFILTER_TABLE		Table = &FilterTables[FilterType];

	ASSERT (FilterType<MAX_FILTER_TYPES);

	Trace (DEBUG_FILTERS, "Replacing %s filter block %lx (count: %ld)"
		" with %lx (count: %ld) on interface %ld.",
		(FilterType==FILTER_TYPE_SUPPLY) ? "out" : "in",
		oldFilters, oldFilters ? oldCount : 0,
		newFilters, newFilters ? newCount : 0,
		oldFilters ? oldFilters->FN_Index : newFilters->FN_Index);

	ACQUIRE_EXCLUSIVE_FILTER_TABLE_LOCK(Table);
	if (oldFilters!=NULL) {
		for (i=0; i<oldCount; i++, oldFilters++) {
			RemoveEntryList (&oldFilters->FN_Link);
			}
		}

	if (newFilters!=NULL) {
		for (i=0; i<newCount; i++, newFilters++) {
			PLIST_ENTRY					cur, head;
			PSAP_SERVICE_FILTER_INFO	Filter = newFilters->FN_Filter;

			if (Filter->ServiceName[0]==0) {
				if (Filter->ServiceType==0xFFFF) {
					head = &Table->FT_AnyAnyList;
					cur = head->Flink;
					while (cur!=head) {
						PFILTER_NODE	node = CONTAINING_RECORD (cur,
													FILTER_NODE, FN_Link);
						if (newFilters->FN_Index>=node->FN_Index)
							break;
						cur = cur->Flink;
						}
					}
				else {
					head = &Table->FT_TypeHash [FilterTypeHash (Filter->ServiceType)];
					cur = head->Flink;
					while (cur!=head) {
						PFILTER_NODE	node = CONTAINING_RECORD (cur,
													FILTER_NODE, FN_Link);
						if ((Filter->ServiceType>node->FN_Filter->ServiceType)
								|| ((Filter->ServiceType==node->FN_Filter->ServiceType)
									&& (newFilters->FN_Index>=node->FN_Index)))
							break;
						cur = cur->Flink;
						}
					}
				}
			else {
				head = &Table->FT_NameHash [FilterNameHash (Filter->ServiceName)];
				cur = head->Flink;
				while (cur!=head) {
					PFILTER_NODE	node = CONTAINING_RECORD (cur,
												FILTER_NODE, FN_Link);
					if ((Filter->ServiceType>node->FN_Filter->ServiceType)
							|| ((Filter->ServiceType==node->FN_Filter->ServiceType)
								&& ((newFilters->FN_Index>node->FN_Index)
									|| ((newFilters->FN_Index==node->FN_Index)
										&& (IpxNameCmp (Filter->ServiceName,
												node->FN_Filter->ServiceName)>=0)))))
						break;
					cur = cur->Flink;
					}
				}
			InsertHeadList (cur, &newFilters->FN_Link);
			}
		}
	RELEASE_EXCLUSIVE_FILTER_TABLE_LOCK(Table);
	}			


BOOL
Filter (
	IN INT		FilterType,				
	IN ULONG	InterfaceIndex,
	IN USHORT	Type,
	IN PUCHAR	Name
	) {
	BOOL			res = FALSE;
	PLIST_ENTRY 	cur, head;
	PFILTER_TABLE	Table = &FilterTables[FilterType];

	ASSERT (FilterType<MAX_FILTER_TYPES);

	ACQUIRE_SHARED_FILTER_TABLE_LOCK(Table);

	head = &Table->FT_NameHash [FilterNameHash (Name)];
	cur = head->Flink;
	while (cur!=head) {
		PFILTER_NODE	node = CONTAINING_RECORD (cur, FILTER_NODE, FN_Link);
		if ((node->FN_Filter->ServiceType==0xFFFF)
				|| (Type==node->FN_Filter->ServiceType)) {
			if (InterfaceIndex==node->FN_Index) {
				INT	cmp;
				cmp = IpxNameCmp (Name, node->FN_Filter->ServiceName);
				if (cmp==0) {
					res = TRUE;
					Trace (DEBUG_FILTERS, "%s name filter %04x %.48s matched by server:"
						" %04x %.48s on if %ld.",
						(FilterType==FILTER_TYPE_SUPPLY) ? "Out" : "In",
						node->FN_Filter->ServiceType,
						node->FN_Filter->ServiceName,
						Type, Name, InterfaceIndex);
					break;
					}
				else if (res>0)
					break;
				}
			else if (InterfaceIndex>node->FN_Index)
				break;
			}
		else if (Type>node->FN_Filter->ServiceType)
			break;
		cur = cur->Flink;
		}

	if (!res) {
		head = &Table->FT_TypeHash [FilterTypeHash (Type)];
		cur = head->Flink;
		while (cur!=head) {
			PFILTER_NODE	node = CONTAINING_RECORD (cur, FILTER_NODE, FN_Link);
			if (Type==node->FN_Filter->ServiceType) {
				if ((node->FN_Index==0xFFFFFFFF)
					|| (InterfaceIndex==node->FN_Index)) {
					Trace (DEBUG_FILTERS, "%s type filter %04x matched by server:"
						" %04x %.48s on if %ld.",
						(FilterType==FILTER_TYPE_SUPPLY) ? "Out" : "In",
						node->FN_Filter->ServiceType,
						Type, Name, InterfaceIndex);
					res = TRUE;
					break;
					}
				else if (InterfaceIndex>node->FN_Index)
					break;
				}
			else if (Type>node->FN_Filter->ServiceType)
				break;
			cur = cur->Flink;
			}

		if (!res) {
			head = &Table->FT_AnyAnyList;
			cur = head->Flink;
			while (cur!=head) {
				PFILTER_NODE	node = CONTAINING_RECORD (cur, FILTER_NODE, FN_Link);
				if (InterfaceIndex==node->FN_Index) {
					Trace (DEBUG_FILTERS, "%s any-any filter on interface matched by server:"
						" %04x %.48s on if %ld.",
						(FilterType==FILTER_TYPE_SUPPLY) ? "Out" : "In",
						Type, Name, InterfaceIndex);
					res = TRUE;
					break;
					}
				else if (InterfaceIndex>node->FN_Index)
					break;
				cur = cur->Flink;
				}
			}
		}

	RELEASE_SHARED_FILTER_TABLE_LOCK(Table);
	return res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\asresmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\asresmgr.h

Abstract:

	Header file asyncronous result reporting 

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_ASRESMGR_
#define _SAP_ASRESMGR_

	// Param block used to enqueue asyncronous result message
typedef struct _AR_PARAM_BLOCK {
		LIST_ENTRY					link;	// Link in message queue
		ROUTING_PROTOCOL_EVENTS		event;	// What event is this report for
		MESSAGE						message;// Content of message
		VOID						(* freeRsltCB)(
										struct _AR_PARAM_BLOCK *);
											// Call back routine to be
											// invoked when message is retreived
		} AR_PARAM_BLOCK, *PAR_PARAM_BLOCK;


/*++
*******************************************************************
		C r e a t e R e s u l t Q u e u e

Routine Description:
	Allocates resources for result queue

Arguments:
	NotificationEvent - event to be signalled when queue is not empty

Return Value:
	NO_ERROR - resources were allocated successfully
	other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateResultQueue (
	IN HANDLE		NotificationEvent
	);

/*++
*******************************************************************
		D e l e t e R e s u l t Q u e u e

Routine Description:
	Dispose of resources allocated for result queue

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteResultQueue (
	void
	);

/*++
*******************************************************************
		E n q u e u e R e s u l t
Routine Description:
	Enqueues message in result queue
Arguments:
	rslt - result param block with enqueued message
Return Value:
	None

*******************************************************************
--*/
VOID
EnqueueResult (
	PAR_PARAM_BLOCK		rslt
	);

/*++
*******************************************************************
		S a p G e t E v e n t R e s u l t
Routine Description:
	Gets first message form result queue
Arguments:
	Event - buffer to store event for which this message is intended
	Message - buffer to store message itself
Return Value:
	NO_ERROR - message was dequeued
	ERROR_NO_MORE_ITEMS - no more messages in the queue
*******************************************************************
--*/
DWORD
SapGetEventResult (
	OUT ROUTING_PROTOCOL_EVENTS		*Event,
	OUT	MESSAGE	 					*Message OPTIONAL
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\asresmgr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\asresmgr.c

Abstract:

	Asyncronous result reporting queue manager

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

typedef struct _RESULT_QUEUE {
			CRITICAL_SECTION	RQ_Lock;
			LIST_ENTRY			RQ_Head;
			HANDLE				RQ_Event;
			} RESULT_QUEUE, *PRESULT_QUEUE;

RESULT_QUEUE ResultQueue;
static INT g_iResultInitCount = 0;

VOID
InitializeResultQueue()
{
	ZeroMemory(&ResultQueue, sizeof(ResultQueue));
}

/*++
*******************************************************************
		C r e a t e R e s u l t Q u e u e

Routine Description:
	Allocates resources for result queue

Arguments:
	NotificationEvent - event to be signalled when queue is not empty

Return Value:
	NO_ERROR - resources were allocated successfully
	other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateResultQueue (
	IN HANDLE		NotificationEvent
	) {

    if (g_iResultInitCount > 0)
    {
        return NO_ERROR;
    }
	
	ResultQueue.RQ_Event = NotificationEvent;
	InitializeCriticalSection (&ResultQueue.RQ_Lock);
	InitializeListHead (&ResultQueue.RQ_Head);

    g_iResultInitCount++;

	return NO_ERROR;
	}

/*++
*******************************************************************
		D e l e t e R e s u l t Q u e u e

Routine Description:
	Dispose of resources allocated for result queue

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteResultQueue (
	void
	) {
	while (!IsListEmpty (&ResultQueue.RQ_Head)) {
		PAR_PARAM_BLOCK	rslt = CONTAINING_RECORD (
									ResultQueue.RQ_Head.Flink,
									AR_PARAM_BLOCK,
									link);
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
				"Releasing pending message %d for RM.",
				__FILE__, __LINE__, rslt->event);
		RemoveEntryList (&rslt->link);
		(*rslt->freeRsltCB) (rslt);
		}
	DeleteCriticalSection (&ResultQueue.RQ_Lock);
	ZeroMemory(&ResultQueue, sizeof(ResultQueue));
	g_iResultInitCount--;
	}


/*++
*******************************************************************
		E n q u e u e R e s u l t
Routine Description:
	Enqueues message in result queue
Arguments:
	rslt - result param block with enqueued message
Return Value:
	None

*******************************************************************
--*/
VOID
EnqueueResult (
	PAR_PARAM_BLOCK		rslt
	) {
	BOOL	setEvent;
	EnterCriticalSection (&ResultQueue.RQ_Lock);
	setEvent = IsListEmpty (&ResultQueue.RQ_Head);
	InsertTailList (&ResultQueue.RQ_Head, &rslt->link);
	LeaveCriticalSection (&ResultQueue.RQ_Lock);
	Trace (DEBUG_ASYNCRESULT, "Enqueing message %d for RM.", rslt->event);
	if (setEvent) {
		BOOL	res = SetEvent (ResultQueue.RQ_Event);
		ASSERTERRMSG ("Could not set result event ", res);
		Trace (DEBUG_ASYNCRESULT, "Signaling RM event.");
		}
	}

/*++
*******************************************************************
		S a p G e t E v e n t R e s u l t
Routine Description:
	Gets first message form result queue
Arguments:
	Event - buffer to store event for which this message is intended
	Message - buffer to store message itself
Return Value:
	NO_ERROR - message was dequeued
	ERROR_NO_MORE_ITEMS - no more messages in the queue
*******************************************************************
--*/
DWORD
SapGetEventResult(
	OUT	ROUTING_PROTOCOL_EVENTS		*Event,
	OUT	MESSAGE	 					*Message
	) {
	DWORD	status;
	EnterCriticalSection (&ResultQueue.RQ_Lock);
	if (!IsListEmpty (&ResultQueue.RQ_Head)) {
		PAR_PARAM_BLOCK	rslt = CONTAINING_RECORD (
									ResultQueue.RQ_Head.Flink,
									AR_PARAM_BLOCK,
									link);
		RemoveEntryList (&rslt->link);
		*Event = rslt->event;
		memcpy (Message, &rslt->message, sizeof (*Message));
		status = NO_ERROR;
		LeaveCriticalSection (&ResultQueue.RQ_Lock);
		(*rslt->freeRsltCB) (rslt);
		Trace (DEBUG_ASYNCRESULT, "Reporting event %d to RM");
		}
	else {
		LeaveCriticalSection (&ResultQueue.RQ_Lock);
		status = ERROR_NO_MORE_ITEMS;
		Trace (DEBUG_ASYNCRESULT, "No more items in RM result queue");
		}
	return status;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\intfdb.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\intfdb.h

Abstract:

	Header file for interface maintenance module.

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_INTFDB_
#define _SAP_INTFDB_

#define INTERNAL_INTERFACE_INDEX	0L
#define INTERNAL_ADAPTER_INDEX		0L
#define INVALID_ADAPTER_INDEX 		0xFFFFFFFFL
#define INVALID_INTERFACE_INDEX		0xFFFFFFFFL

// Number of additional recv requests to post when binding the interface
// that has listen enabled
extern ULONG NewRequestsPerInterface;

// Default filtering mode (for standalone service only)
extern UCHAR	FilterOutMode; 

	// Externally visible part of interface control block
typedef struct _INTERFACE_DATA {
    LPWSTR                      name;       // Name
	ULONG						index;		// Unique index
	BOOLEAN						enabled;	// enabled flag
	UCHAR						filterOut;	// supply filtering node
	UCHAR						filterIn;	// listen filtering node
#define SAP_DONT_FILTER				0
#define SAP_FILTER_PERMIT			IPX_SERVICE_FILTER_PERMIT
#define SAP_FILTER_DENY				IPX_SERVICE_FILTER_DENY

#if ((SAP_DONT_FILTER==SAP_FILTER_PERMIT) || (SAP_DONT_FILTER==SAP_FILTER_DENY))
#error "Sap filter constant mismatch!!!!"
#endif

	SAP_IF_INFO					info;		// Configuration info
	IPX_ADAPTER_BINDING_INFO	adapter;	// Net params of adapter
									// to which interface is bound
	SAP_IF_STATS				stats;	// Interface statistics
	} INTERFACE_DATA, *PINTERFACE_DATA;

	// Exported internal network parameters
extern UCHAR INTERNAL_IF_NODE[6];
extern UCHAR INTERNAL_IF_NET[4];

/*++
*******************************************************************
		C r e a t e I n t e r f a c e T a b l e

Routine Description:
		Allocates resources for interface table

Arguments:
		None
Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateInterfaceTable (
	);

/*++
*******************************************************************
		S h u t d o w n I n t e r f a c e s

Routine Description:
	Initiates orderly shutdown of SAP interfaces
	Stop reception of new packets
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ShutdownInterfaces (
	HANDLE		doneEvent
	);

/*++
*******************************************************************
		S t o p I n t e r f a c e s

Routine Description:
	Stops all sap interfaces if not already stopped.
Arguments:
	None

Return Value:
	None

*******************************************************************
--*/
VOID
StopInterfaces (
	void
	);
	
/*++
*******************************************************************
		D e l e t e I n t e r f a c e T a b l e

Routine Description:
	Release all resources associated with interface table

Arguments:
	None

Return Value:
	NO_ERROR - operation completed OK

*******************************************************************
--*/
VOID
DeleteInterfaceTable (
	void
	);

/*++
*******************************************************************
		S a p C r e a t e S a p I n t e r f a c e 

Routine Description:
	Add interface control block for new interface

Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - interface configuration info

Return Value:
	NO_ERROR - interface was created OK
	ERROR_ALREADY_EXISTS - interface with this index already exists
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapCreateSapInterface (
    LPWSTR              InterfaceName,
	ULONG				InterfaceIndex,
	NET_INTERFACE_TYPE	InterfaceType,
	PSAP_IF_INFO		SapIfConfig
	);

/*++
*******************************************************************
		S a p D e l e t e S a p I n t e r f a c e 

Routine Description:
	Delete existing interface control block

Arguments:
	InterfaceIndex - unique number that indentifies the interface

Return Value:
	NO_ERROR - interface was created OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapDeleteSapInterface (
	ULONG InterfaceIndex
	);

/*++
*******************************************************************
		S a p G e t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with interface
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/

DWORD
SapGetSapInterface (
	IN ULONG InterfaceIndex,
	OUT PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	);
	
/*++
*******************************************************************
		S a p S e t S a p I n t e r f a c e 

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - new interface configuration info
Return Value:
	NO_ERROR - config info was changed OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetSapInterface (
	ULONG InterfaceIndex,
	PSAP_IF_INFO SapIfConfig
	);
	
/*++
*******************************************************************
		S a p S e t I n t e r f a c e E n a b l e

Routine Description:
	Enables/disables interface
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	Enable - TRUE-enable, FALSE-disable
Return Value:
	NO_ERROR - config info was changed OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetInterfaceEnable (
	ULONG	InterfaceIndex,
	BOOL	Enable
	);

/*++
*******************************************************************
		S a p S e t I n t e r f a c e F i l t e r s

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetInterfaceFilters (
	IN ULONG			InterfaceIndex,
	IN PSAP_IF_FILTERS	SapIfFilters
	);
	
/*++
*******************************************************************
		S a p G e t I n t e r f a c e F i l t e r s

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapGetInterfaceFilters (
	IN ULONG			InterfaceIndex,
	OUT PSAP_IF_FILTERS SapIfFilters,
	OUT PULONG			FilterBufferSize
	);
	
/*++
*******************************************************************
		S a p B i n d S a p I n t e r f a c e T o A d a p t e r

Routine Description:
	Establishes association between interface and physical adapter
	and starts sap on the interface if its admin state is enabled
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	AdapterInfo - info associated with adapter to bind to
Return Value:
	NO_ERROR - interface was bound OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapBindSapInterfaceToAdapter (
	ULONG			 			InterfaceIndex,
	PIPX_ADAPTER_BINDING_INFO		AdptInternInfo
	);

/*++
*******************************************************************
		S a p U n b i n d S a p I n t e r f a c e F r o m A d a p t e r

Routine Description:
	Breaks association between interface and physical adapter
	and stops sap on the interface if it was on
Arguments:
	InterfaceIndex - unique number that indentifies new interface
Return Value:
	NO_ERROR - interface was bound OK
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapUnbindSapInterfaceFromAdapter (
	ULONG InterfaceIndex
	);
	

/*++
*******************************************************************
	S a p R e q u e s t U p d a t e
Routine Description:
	Initiates update of services information over the interface
	Completion of this update will be indicated by signalling
	NotificationEvent passed at StartProtocol.  GetEventMessage
	can be used then to get the results of autostatic update
Arguments:
	InterfaceIndex - unique index identifying interface to do
		update on
Return Value:
	NO_ERROR	 - operation was initiated ok
	ERROR_INVALID_PARAMETER - the interface does not support updates
	IPX_ERROR_NO_INTERFACE - interface with this index does not exist
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
SapRequestUpdate (
	ULONG		InterfaceIndex
	);

/*++
*******************************************************************
		S a p G e t F i r s t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with first
	interface in InterfaceIndex order
Arguments:
	InterfaceIndex - buffer to store unique number that indentifies interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	IPX_ERROR_NO_INTERFACE - no interfaces in the table
	other - operation failed (windows error code)

*******************************************************************
--*/

DWORD
SapGetFirstSapInterface (
	OUT PULONG InterfaceIndex,
	OUT	PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	);


/*++
*******************************************************************
		S a p G e t N e x t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with first
	interface in following interface with InterfaceIndex order in interface
	index order
Arguments:
	InterfaceIndex - on input - interface number to search from
					on output - interface number of next interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	IPX_ERROR_NO_INTERFACE - no more interfaces in the table
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapGetNextSapInterface (
	IN OUT PULONG InterfaceIndex,
	OUT	PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	);
	
/*++
*******************************************************************
		A c q u i r e I n t e r f a c e R e f e n c e

Routine Description:
	Increments reference count of interface block.
	If reference count is grater than 0, the externally visible
	data in the block are locked (can't be modified)

Arguments:
	intf - pointer to externally visible part of interface control block	

Return Value:
	None

*******************************************************************
--*/
VOID
AcquireInterfaceReference (
	IN PINTERFACE_DATA intf
	);

/*++
*******************************************************************
		R e l e a s e I n t e r f a c e R e f e n c e

Routine Description:
	Decrements reference count of interface block.
	When reference count drops to 0, cleanup routine gets called to
	dispose of all resources allocated at bind time and if interface
	control block is already removed from the table it gets disposed of
	as well

Arguments:
	intf - pointer to externally visible part of interface control block	

Return Value:
	None

*******************************************************************
--*/
VOID
ReleaseInterfaceReference (
	IN PINTERFACE_DATA intf
	);


/*++
*******************************************************************
		G e t I n t e r f a c e R e f e r e n c e 

Routine Description:
	Finds interface control block that bound to adapter and increments reference
	count on it (to prevent it from deletion while it is used).
Arguments:
	AdapterIndex - unique number that indentifies adapter
Return Value:
	Pointer to externally visible part of interface control block
	NULL if no interface is bound to the adapter
*******************************************************************
--*/
PINTERFACE_DATA
GetInterfaceReference (
	ULONG			AdapterIndex
	);
	
/*++
*******************************************************************
		S a p I s S a p I n t e r f a c e 

Routine Description:
	Checks if interface with given index exists
Arguments:
	InterfaceIndex - unique number that indentifies new interface
Return Value:
	TRUE - exist
	FALSE	- does not

*******************************************************************
--*/
BOOL
SapIsSapInterface (
	ULONG InterfaceIndex
	);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\adaptdb.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\adaptdb.h

Abstract:

	Header file for net adapter notification interface

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_ADAPTERDB_
#define _SAP_ADAPTERDB_

// Interval for periodic update broadcasts (for standalone service only)
extern ULONG	UpdateInterval;

// Interval for periodic update broadcasts on WAN lines (for standalone service only)
extern ULONG	ServerAgingTimeout;

// Server aging timeout (for standalone service only)
extern ULONG	WanUpdateMode;

// Interval for periodic update broadcasts on WAN lines (for standalone service only)
extern ULONG	WanUpdateInterval;


/*++
*******************************************************************
		C r e a t e A d a p t e r P o r t

Routine Description:
	Allocate resources and establish connection to net adapter
	notification mechanism

Arguments:
	cfgEvent - event to be signalled when adapter configuration changes

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateAdapterPort (
	IN HANDLE		*cfgEvent
	);


/*++
*******************************************************************
		D e l e t e A d a p t e r P o r t

Routine Description:
	Dispose of resources and break connection to net adapter
	notification mechanism

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteAdapterPort (
	void
	);

/*++
*******************************************************************
		P r o c e s s A d a p t e r E v e n t s

Routine Description:
	Dequeues and process adapter configuration change events and maps them
	to interface configuration calls
	This routine should be called when configuration event is signalled

Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessAdapterEvents (
	VOID
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\intfdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\intfdb.c

Abstract:

	This module maintains IPX interface configuration
	and provides interface configuration API
	for external modules (Router Manager)

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

#define IDB_NUM_OF_INTF_HASH_BUCKETS	256
#define	IDB_NUM_OF_ADPT_HASH_BUCKETS	32

// Number of additional recv requests to post when binding the interface
// that has listen enabled
ULONG NewRequestsPerInterface=SAP_REQUESTS_PER_INTF_DEF;

// Default filtering mode (for standalone service only)
UCHAR	FilterOutMode=SAP_DONT_FILTER; 

#define IntfHashFunction(intf) ((intf)&(IDB_NUM_OF_INTF_HASH_BUCKETS-1))
#define AdptHashFunction(adpt) ((adpt)&(IDB_NUM_OF_ADPT_HASH_BUCKETS-1))

UCHAR INTERNAL_IF_NODE[6] = {0};
UCHAR INTERNAL_IF_NET[4] = {0};


	// Interface control block
typedef struct _INTERFACE_NODE {
		INTERFACE_DATA		IN_Data;		// Externally visible data
		NET_INTERFACE_TYPE	IN_Type;		// Interface type
		PSAP_IF_FILTERS		IN_Filters;		// Filter description array
		PFILTER_NODE		IN_FilterNodes;	// Filter node array hashed in
											// the filter table
		LIST_ENTRY			IN_IntfLink;	// Link in interface table
								// Used to test if interface block is
								// is the table (it is not if Flink==Blink)
		LIST_ENTRY			IN_AdptLink;	// Link in adapter table
		LIST_ENTRY			IN_ListLink;	// Link in interface list
		LONG				IN_RefCount;	// Number of times interface data
								// was referenced, if above 0, interface block
								// can't be deleted (last client that refers
								// it will do this).
		BOOL				IN_InUse;		// Flag that is set when interface
								// is bound. It is reset by the last client
								// that refers to interface after it frees
								// all resources (if any) that were allocated
								// at bind time.  If reference count is zero
								// but this flag is set, the last client that
								// refered to this interface is in process
								// of releasing resources (waiting on critical
								// section to lock interface block) and should
								// be allowed to finish this operation
		} INTERFACE_NODE, *PINTERFACE_NODE;

// Usefull field access macros
#define IN_Name     IN_Data.name
#define IN_IntfIdx	IN_Data.index
#define IN_Info 	IN_Data.info
#define IN_Adpt		IN_Data.adapter
#define IN_AdptIdx	IN_Data.adapter.AdapterIndex
#define IN_Stats 	IN_Data.stats
#define IN_Enabled	IN_Data.enabled
#define IN_FilterIn	IN_Data.filterIn
#define IN_FilterOut IN_Data.filterOut

	// This macro is used to screen interface blocks that were deleted
	// from the table or replaced and must be disposed of by the last
	// user that refers to it
#define IsInterfaceValid(node) IsListEntry(&node->IN_IntfLink)
	// This macro must be used to identify interface blocks that
	// were deleted from the table and must be disposed of by the
	// last user that refers to it
#define InvalidateInterface(node) InitializeListEntry(&node->IN_IntfLink)

	// Table of interface control blocks
typedef struct _INTERFACE_TABLE {
		LONG				IT_NumOfActiveInterfaces;
								// Number of active (enabled and bound)
								// interfaces (we close Adapter port when
								// this number drops to 0)
#if DBG
		LIST_ENTRY			IT_DetachedIntf; // List of interfaces that were
								// removed from the table and await to be
								// disposed of when the last client releases
								// reference to them
#endif
		LIST_ENTRY			IT_IntfHash[IDB_NUM_OF_INTF_HASH_BUCKETS];
								// Interface control blocks hashed by interface
								// index
		LIST_ENTRY			IT_AdptHash[IDB_NUM_OF_ADPT_HASH_BUCKETS];
								// Interface control blocks hashed by adapter
								// index to which corresponding interface is
								// bound
		CRITICAL_SECTION	IT_Lock;	// Interface table data protection
		} INTERFACE_TABLE, *PINTERFACE_TABLE;

	// List of interface blocks in InterfaceIndex order
typedef struct _INTERFACE_LIST {	
		CRITICAL_SECTION	IL_Lock;	// List data protection
		LIST_ENTRY			IL_Head;	// List head
		} INTERFACE_LIST, *PINTERFACE_LIST;

INTERFACE_TABLE InterfaceTable;
INTERFACE_LIST	InterfaceList;
HANDLE			ShutdownDoneEvent=NULL;

// Find if interface control block exists for interface index and
// return pointer to it (node), otherwise return place where
// new interface block should be inserted (cur)
#define if_IsInterfaceNode(InterfaceIndex,node,cur) {				\
	PLIST_ENTRY HashList=&InterfaceTable.IT_IntfHash[				\
								IntfHashFunction(InterfaceIndex)];	\
	EnterCriticalSection (&InterfaceTable.IT_Lock);					\
	cur = HashList->Flink;											\
	while (cur != HashList) {										\
		node = CONTAINING_RECORD (cur, INTERFACE_NODE, IN_IntfLink);\
		if (InterfaceIndex <= node->IN_IntfIdx)						\
			break;													\
		cur = cur->Flink;											\
		}															\
	}																\
	if ((cur==&node->IN_IntfLink)									\
			&& (InterfaceIndex==node->IN_IntfIdx))


// Local prototypes
DWORD
StartInterface (
	PINTERFACE_NODE		node
	);
	
VOID
FreeBindingResources (
	PINTERFACE_NODE	node
	);

DWORD
StopInterface (
	PINTERFACE_NODE		node
	);
#if DBG
VOID
DumpPacket (
	PSAP_BUFFER	packet,
	DWORD		count
	);
#else
#define DumpPacket(packet,count)
#endif

PWCHAR SapDuplicateString (IN PWCHAR pszString) {   
    PWCHAR pszRet;
    DWORD dwLen;

    if (!pszString)
        return NULL;

    dwLen = wcslen (pszString);

    pszRet = GlobalAlloc (GMEM_FIXED, (dwLen * sizeof(WCHAR)) + sizeof(WCHAR));
    if (pszRet) {
        wcscpy (pszRet, pszString);
    }

    return pszRet;
}

VOID SapFreeDuplicatedString (IN PWCHAR pszString) {
    if (pszString)
        GlobalFree (pszString);
}


/*++
*******************************************************************
		C r e a t e I n t e r f a c e T a b l e

Routine Description:
		Allocates resources for interface table

Arguments:
		None
Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateInterfaceTable (
	void
	) {
	INT				i;
	DWORD			status;

		
	InitializeCriticalSection (&InterfaceList.IL_Lock);
	InitializeListHead (&InterfaceList.IL_Head);

	InitializeCriticalSection (&InterfaceTable.IT_Lock);
	for (i=0; i<IDB_NUM_OF_INTF_HASH_BUCKETS; i++)
		InitializeListHead (&InterfaceTable.IT_IntfHash[i]);
	for (i=0; i<IDB_NUM_OF_ADPT_HASH_BUCKETS; i++)
		InitializeListHead (&InterfaceTable.IT_AdptHash[i]);

#if DBG
	InitializeListHead (&InterfaceTable.IT_DetachedIntf);
#endif
	InterfaceTable.IT_NumOfActiveInterfaces = 0;

	return NO_ERROR;
	}

/*++
*******************************************************************
		S h u t d o w n I n t e r f a c e s

Routine Description:
	Initiates orderly shutdown of SAP interfaces
	Stop reception of new packets
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ShutdownInterfaces (
	HANDLE			doneEvent
	) {
	INT			i;


		// Now for each active interface in the table
		// we'll start shoutdown worker which will broadcast
		// all 'deleted' servers and dispose of interface control block
	EnterCriticalSection (&InterfaceList.IL_Lock);
	EnterCriticalSection (&InterfaceTable.IT_Lock);
	ShutdownDoneEvent = doneEvent;
	if (InterfaceTable.IT_NumOfActiveInterfaces==0) {
		Trace (DEBUG_INTERFACES, "All interfaces have been shut down.");
		if (doneEvent!=NULL) {
			BOOL res = SetEvent (doneEvent);
			ASSERTERRMSG ("Could not set shutdown done event ", res);
			}
		}
	else {
		ShutdownDoneEvent = doneEvent;


		for (i=0; i<IDB_NUM_OF_INTF_HASH_BUCKETS; i++) {
			while (!IsListEmpty (&InterfaceTable.IT_IntfHash[i])) {
				PINTERFACE_NODE node = CONTAINING_RECORD (
									InterfaceTable.IT_IntfHash[i].Flink,
									INTERFACE_NODE,
									IN_IntfLink);
				if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
					node->IN_Info.Listen = ADMIN_STATE_DISABLED; // This will prevent deletion
									// of all services associated with
									// interface when it is stopped (done by the caller)
					node->IN_Stats.SapIfOperState = OPER_STATE_STOPPING;
					StopInterface (node);
					}
					// Remove interface control block
				Trace (DEBUG_INTERFACES, "Invalidating interface block: %lX(%d).",
									node, node->IN_IntfIdx);
				RemoveEntryList (&node->IN_IntfLink);
				InvalidateInterface (node);
				RemoveEntryList (&node->IN_ListLink);
					// Dispose only if nobody uses it and not waiting on critical
					// section to dispose of it
				if ((node->IN_RefCount==0)
						&& !node->IN_InUse) {
					Trace (DEBUG_INTERFACES, "Releasing interface block: %lX(%d).",
										node, node->IN_IntfIdx);
					GlobalFree (node);
					}
					// Otherwise, just leave it hang outside of the table
					// till last client releases reference to it
#if DBG
				else	// Keep track of all blocks in debugging mode
					InsertTailList (&InterfaceTable.IT_DetachedIntf,
															&node->IN_ListLink);
#endif
				}
			}
		}
	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	}

/*++
*******************************************************************
		S t o p I n t e r f a c e s

Routine Description:
	Stops all sap interfaces if not already stopped.

Arguments:
	None

Return Value:
	None

*******************************************************************
--*/
VOID
StopInterfaces (
	void
	) {
	INT			i;

		// Delete all interface control blocks
	EnterCriticalSection (&InterfaceList.IL_Lock);
	EnterCriticalSection (&InterfaceTable.IT_Lock);
	for (i=0; i<IDB_NUM_OF_INTF_HASH_BUCKETS; i++) {
		while (!IsListEmpty (&InterfaceTable.IT_IntfHash[i])) {
			PINTERFACE_NODE node = CONTAINING_RECORD (
								InterfaceTable.IT_IntfHash[i].Flink,
								INTERFACE_NODE,
								IN_IntfLink);
			if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
					// Stop all bound interfaces
				node->IN_Info.Listen = ADMIN_STATE_DISABLED; // This will prevent deletion
								// of all services associated with
								// interface when it is stopped (done by the caller)
				node->IN_Stats.SapIfOperState = OPER_STATE_STOPPING;
				StopInterface (node);
				}
				// Remove and dispose of original interface control block
			Trace (DEBUG_INTERFACES, "Invalidating interface block: %lX(%d).",
								node, node->IN_IntfIdx);
			RemoveEntryList (&node->IN_IntfLink);
			InvalidateInterface (node);
			RemoveEntryList (&node->IN_ListLink);
				// Dispose only if nobody uses it and not waiting on critical
				// section to dispose of it
			if ((node->IN_RefCount==0)
					&& !node->IN_InUse) {
				Trace (DEBUG_INTERFACES, "Releasing interface block: %lX(%d).",
									node, node->IN_IntfIdx);
				GlobalFree (node);
				}
				// Otherwise, just leave it hang outside of the table
				// till last client releases reference to it
#if DBG
			else	// Keep track of all blocks in debugging mode
				InsertTailList (&InterfaceTable.IT_DetachedIntf,
														&node->IN_ListLink);
#endif
			}
		}
	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	}

/*++
*******************************************************************
		D e l e t e I n t e r f a c e T a b l e

Routine Description:
	Release all resources associated with interface table

Arguments:
	None

Return Value:
	NO_ERROR - operation completed OK

*******************************************************************
--*/
VOID
DeleteInterfaceTable (
	void
	) {
	DeleteCriticalSection (&InterfaceList.IL_Lock);
	DeleteCriticalSection (&InterfaceTable.IT_Lock);
	}


/*++
*******************************************************************
		A c q u i r e I n t e r f a c e R e f e n c e

Routine Description:
	Increments reference count of interface block.
	If reference count is greater than 0, the externally visible
	data in the block are locked (can't be modified)

Arguments:
	intf - pointer to externally visible part of interface control block	

Return Value:
	None

*******************************************************************
--*/
VOID
AcquireInterfaceReference (
		IN PINTERFACE_DATA intf
		) {
	PINTERFACE_NODE	node = CONTAINING_RECORD(intf,
							 INTERFACE_NODE,
							 IN_Data);

	InterlockedIncrement(&node->IN_RefCount);
	}

/*++
*******************************************************************
		R e l e a s e I n t e r f a c e R e f e n c e

Routine Description:
	Decrements reference count of interface block.
	When reference count drops to 0, cleanup routine gets called to
	dispose of all resources allocated at bind time and if interface
	control block is already removed from the table it gets disposed of
	as well

Arguments:
	intf - pointer to externally visible part of interface control block	

Return Value:
	None

*******************************************************************
--*/
VOID
ReleaseInterfaceReference (
	IN PINTERFACE_DATA intf
	) {
	PINTERFACE_NODE	node = CONTAINING_RECORD (intf,
							 INTERFACE_NODE,
							 IN_Data);

	if (InterlockedDecrement (&node->IN_RefCount)==0) {
			// This is the last client that refered to this interface block
			// It should cleanup all resources allocated at bind time
			// and possibly dispose of interface block itself
		EnterCriticalSection (&InterfaceTable.IT_Lock);
		FreeBindingResources (node);
		if (!IsInterfaceValid(node)) {
			Trace (DEBUG_INTERFACES, "Releasing interface block: %lX(%d).",
								node, node->IN_IntfIdx);
#if DBG
				// Debugging mode code keeps all deleted nodes in 
				// detached list
			RemoveEntryList (&node->IN_ListLink);
#endif
			if (node->IN_Filters!=NULL) {
				if (node->IN_Filters->SupplyFilterCount>0)
					ReplaceFilters (
						FILTER_TYPE_SUPPLY,
						&node->IN_FilterNodes[0],
						node->IN_Filters->SupplyFilterCount,
						NULL,
						0);
				if (node->IN_Filters->ListenFilterCount>0)
					ReplaceFilters (
						FILTER_TYPE_LISTEN,
						&node->IN_FilterNodes[node->IN_Filters->SupplyFilterCount],
						node->IN_Filters->ListenFilterCount,
						NULL,
						0);
				GlobalFree (node->IN_Filters);
				}
            if (node->IN_Name!=NULL)
                SapFreeDuplicatedString (node->IN_Name);
			GlobalFree (node);
			}
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		}
	}

/*++
*******************************************************************
		F r e e B i n d i n g R e s o u r c e s

Routine Description:
	Disposes of all resources allocated at bind time and marks interface
	block as not used.
	Interface Table must be locked when calling this routine (unless
	node is already removed from the table)

Arguments:
	node - pointer to interface control block	

Return Value:
	None

*******************************************************************
--*/
VOID
FreeBindingResources (
	PINTERFACE_NODE	node
	) {
	Trace (DEBUG_INTERFACES, 
				"Releasing binding resources for interface block: %lX(%d).",
						node, node->IN_IntfIdx);
	node->IN_InUse = FALSE;
	if (node->IN_Enabled
		&& (node->IN_Info.AdminState==ADMIN_STATE_ENABLED))
		node->IN_Stats.SapIfOperState = OPER_STATE_SLEEPING;
	else
		node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;


	InterfaceTable.IT_NumOfActiveInterfaces -= 1;
	if (InterfaceTable.IT_NumOfActiveInterfaces==0) {
		Trace (DEBUG_INTERFACES, "All interfaces have been shut down.");
		if (ShutdownDoneEvent!=NULL) {
			BOOL res = SetEvent (ShutdownDoneEvent);
			ASSERTERRMSG ("Could not set shutdown done event ", res);
			ShutdownDoneEvent = NULL;
			}
		}

	}

/*++
*******************************************************************
		G e t I n t e r f a c e R e f e r e n c e 

Routine Description:
	Finds interface control block that bound to adapter and increments reference
	count on it (to prevent it from deletion while it is used).
Arguments:
	AdapterIndex - unique number that indentifies adapter
Return Value:
	Pointer to externally visible part of interface control block
	NULL if no interface is bound to the adapter
*******************************************************************
--*/
PINTERFACE_DATA
GetInterfaceReference (
	ULONG			AdapterIndex
	) {
	PLIST_ENTRY HashList = &InterfaceTable.IT_AdptHash
								[AdptHashFunction(AdapterIndex)];
	PINTERFACE_NODE		node;
	PLIST_ENTRY			cur;

	EnterCriticalSection (&InterfaceTable.IT_Lock);
	cur = HashList->Flink;
	while (cur!=HashList) {
		node = CONTAINING_RECORD (cur, INTERFACE_NODE, IN_AdptLink);
		if (node->IN_AdptIdx==AdapterIndex) {
			InterlockedIncrement (&node->IN_RefCount);
			break;
			}
		cur = cur->Flink;
		}
	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	if (cur!=HashList)
		return &node->IN_Data;
	else
		return NULL;
	}

/*++
*******************************************************************
		S t a r t I n t e r f a c e 

Routine Description:
	Initiate sap on interface
	Interface Table must be locked when calling this routine

Arguments:
	node - pointer to interface control block	

Return Value:
	None

*******************************************************************
--*/
DWORD
StartInterface (
	PINTERFACE_NODE		node
	) {
	DWORD		status = NO_ERROR;

	Trace (DEBUG_INTERFACES, "Starting SAP for interface block: %lX(%d,%d).",
						node, node->IN_IntfIdx, node->IN_AdptIdx);
	node->IN_Stats.SapIfOperState = OPER_STATE_UP;
	node->IN_InUse = TRUE;
		// Create binding reference 
	InterlockedIncrement (&node->IN_RefCount);
	InsertTailList (
			&InterfaceTable.IT_AdptHash[AdptHashFunction(node->IN_AdptIdx)],
			&node->IN_AdptLink);

	InterfaceTable.IT_NumOfActiveInterfaces += 1;

	if ((status==NO_ERROR)
			&& (node->IN_Info.UpdateMode==IPX_STANDARD_UPDATE)) {
		AddRecvRequests (NewRequestsPerInterface);
		if (node->IN_Info.Supply==ADMIN_STATE_ENABLED)
			status = InitBcastItem (&node->IN_Data);
		if ((status==NO_ERROR)
				&& (node->IN_Info.Listen==ADMIN_STATE_ENABLED))
			status = InitSreqItem (&node->IN_Data);
		}

	if (status!=NO_ERROR) {
		node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;
		RemoveEntryList (&node->IN_AdptLink);
		if (node->IN_Info.UpdateMode==IPX_STANDARD_UPDATE) {
			RemoveRecvRequests (NewRequestsPerInterface);
			}

		if (InterlockedDecrement (&node->IN_RefCount)==0)
				// Cleanup binding resources if this is the
				// last reference to the interface control block
			FreeBindingResources (node);
		}
	return status;
	}



/*++
*******************************************************************
		S t o p I n t e r f a c e 

Routine Description:
	Stop sap on interface
	Interface Table must be locked when calling this routine

Arguments:
	node - pointer to interface control block	

Return Value:
	None

*******************************************************************
--*/
DWORD
StopInterface (
	PINTERFACE_NODE		node
	) {
	DWORD		status=NO_ERROR;

	Trace (DEBUG_INTERFACES, "Stopping SAP for interface block: %lX(%d,%d).",
						node, node->IN_IntfIdx, node->IN_AdptIdx);

	if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
			// Set the state of the interface if not already set.
		if (node->IN_Enabled
			&& (node->IN_Info.AdminState==ADMIN_STATE_ENABLED)
			&& (node->IN_Type!=PERMANENT))
			node->IN_Stats.SapIfOperState = OPER_STATE_SLEEPING;
		else
			node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;

		}

	RemoveEntryList (&node->IN_AdptLink);
	if (node->IN_Info.UpdateMode==IPX_STANDARD_UPDATE) {
		RemoveRecvRequests (NewRequestsPerInterface);
		}

	if (InterlockedDecrement (&node->IN_RefCount)==0)
			// Cleanup binding resources if we released the
			// last reference to the interface control block
		FreeBindingResources (node);
	else	// Have clients get in sync fast.
		ExpireLRRequests ((PVOID)UlongToPtr(node->IN_IntfIdx));

		// Delete all services obtained through SAP if we were actually
		// listening to SAP announcements on this interface
	if (node->IN_Info.Listen==ADMIN_STATE_ENABLED) {
		HANDLE enumHdl = CreateListEnumerator (SDB_INTF_LIST_LINK,
										0xFFFF,
										NULL,
										node->IN_IntfIdx,
										IPX_PROTOCOL_SAP,
										SDB_DISABLED_NODE_FLAG);
			// Delete all services obtained through sap
		if (enumHdl!=NULL) {
			EnumerateServers (enumHdl, DeleteAllServersCB, enumHdl);
			DeleteListEnumerator (enumHdl);
			}
		else 
			Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" Could not create enumerator to delete"
					" sap servers for interface: %ld.",
							__FILE__, __LINE__, node->IN_IntfIdx);
		}

	return status;
	}

DWORD WINAPI
UnbindInterface(
	IN ULONG	InterfaceIndex
	);

SetInterfaceConfigInfo(
	IN ULONG	    InterfaceIndex,
	IN PVOID	    InterfaceInfo);

DWORD
UpdateInterfaceState (
	PINTERFACE_NODE		node
	);

DWORD SapUpdateLocalServers ();

// Makes pnp changes to an interface
DWORD SapReconfigureInterface (ULONG InterfaceIndex, 
                               PIPX_ADAPTER_BINDING_INFO pAdapter) 
{
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD dwErr;
	
    Trace (DEBUG_INTERFACES, "SapReconfigureInterface: entered for %d", InterfaceIndex);
    
    // Lock the interface list and get reference to the
    // sought after control node.
    EnterCriticalSection (&InterfaceList.IL_Lock);
	if_IsInterfaceNode(InterfaceIndex, node, cur) {
        // Update the information maintained in the interfaces
        node->IN_Adpt = *pAdapter;
        UpdateInterfaceState ( node );
    }        

    // Unlock
    LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);

    // If the internal network number was updated, go through all
    // local servers and update their control blocks accordingly.
    if (InterfaceIndex == INTERNAL_INTERFACE_INDEX) {
        if ((dwErr = SapUpdateLocalServers ()) != NO_ERROR) {
            Trace (DEBUG_INTERFACES, "ERR: SapUpdateLocalServers returned %x", dwErr);
        }
    }

    return NO_ERROR;
}    

/*++
*******************************************************************
		S a p C r e a t e S a p I n t e r f a c e 

Routine Description:
	Add interface control block for new interface

Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - interface configuration info

Return Value:
	NO_ERROR - interface was created OK
	ERROR_ALREADY_EXISTS - interface with this index already exists
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapCreateSapInterface (
    LPWSTR              InterfaceName,
	ULONG				InterfaceIndex,
	NET_INTERFACE_TYPE	InterfaceType,
	PSAP_IF_INFO		SapIfConfig
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD			status = NO_ERROR;

    EnterCriticalSection (&InterfaceList.IL_Lock);
	if_IsInterfaceNode(InterfaceIndex,node,cur) {
		Trace (DEBUG_INTERFACES, "Interface %ld already exists.",InterfaceIndex);
		status = ERROR_ALREADY_EXISTS;
    }
    else {
		node = (PINTERFACE_NODE)GlobalAlloc (GMEM_FIXED, sizeof (INTERFACE_NODE));
		if (node!=NULL) {
            node->IN_Name = SapDuplicateString (InterfaceName);
            if (node->IN_Name!=NULL) {
		        node->IN_RefCount = 0;
		        node->IN_InUse = FALSE;
                node->IN_Data.name = node->IN_Name;
		        node->IN_IntfIdx = InterfaceIndex;
		        node->IN_AdptIdx = INVALID_ADAPTER_INDEX;
		        node->IN_Enabled = FALSE;
		        node->IN_Type = InterfaceType;
		        node->IN_Filters = NULL;
		        node->IN_FilterNodes = NULL;
		        node->IN_FilterIn = SAP_DONT_FILTER;
		        node->IN_FilterOut = FilterOutMode;
		        node->IN_Stats.SapIfInputPackets = 0;
		        node->IN_Stats.SapIfOutputPackets = 0;
		        if (ARGUMENT_PRESENT(SapIfConfig)) {
			        node->IN_Info = *SapIfConfig;
			        if (node->IN_Enabled
					        && (node->IN_Info.AdminState==ADMIN_STATE_ENABLED))
				        node->IN_Stats.SapIfOperState = OPER_STATE_SLEEPING;
			        else
				        node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;
		        }
		        else
			        node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;
		        InsertTailList (cur, &node->IN_IntfLink);

		        cur = InterfaceList.IL_Head.Flink;
		        while (cur!=&InterfaceList.IL_Head) {
			        if (InterfaceIndex<CONTAINING_RECORD (
						        cur,
						        INTERFACE_NODE,
						        IN_ListLink)->IN_IntfIdx)
				        break;
			        cur = cur->Flink;
			        }
		        InsertTailList (cur, &node->IN_ListLink);
                }
            else {
                GlobalFree (node);
			    status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        else
			status = ERROR_NOT_ENOUGH_MEMORY;
		}
    LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}


/*++
*******************************************************************
		S a p D e l e t e S a p I n t e r f a c e 

Routine Description:
	Delete existing interface control block

Arguments:
	InterfaceIndex - unique number that indentifies the interface
Return Value:
	NO_ERROR - interface was created OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapDeleteSapInterface (
	ULONG 	InterfaceIndex
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD			status;
	HANDLE			enumHdl;

	EnterCriticalSection (&InterfaceList.IL_Lock);
	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
			StopInterface (node);
			}

			// Remove and dispose of interface control block
		Trace (DEBUG_INTERFACES, "Invalidating interface block: %lX(%d).",
							node, node->IN_IntfIdx);
		RemoveEntryList (&node->IN_IntfLink);
		InvalidateInterface (node);
		RemoveEntryList (&node->IN_ListLink);
				// Dispose only if nobody uses it and not waiting on critical
				// section to dispose of it
		if ((node->IN_RefCount==0)
				&& !node->IN_InUse) {
			Trace (DEBUG_INTERFACES, "Releasing interface block: %lX(%d).",
								node, node->IN_IntfIdx);
			if (node->IN_Filters!=NULL) {
				if (node->IN_Filters->SupplyFilterCount>0)
					ReplaceFilters (
						FILTER_TYPE_SUPPLY,
						&node->IN_FilterNodes[0],
						node->IN_Filters->SupplyFilterCount,
						NULL,
						0);
				if (node->IN_Filters->ListenFilterCount>0)
					ReplaceFilters (
						FILTER_TYPE_LISTEN,
						&node->IN_FilterNodes[node->IN_Filters->SupplyFilterCount],
						node->IN_Filters->ListenFilterCount,
						NULL,
						0);
				GlobalFree (node->IN_Filters);
				}
			if (node->IN_Name!=NULL)
                SapFreeDuplicatedString (node->IN_Name);
			GlobalFree (node);
			}
			// Otherwise, just leave it hang outside of the table
			// till last client releases reference to it
#if DBG
		else	// Keep track of all blocks in debugging mode
			InsertTailList (&InterfaceTable.IT_DetachedIntf,
													&node->IN_ListLink);
#endif



		status = NO_ERROR;
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}


/*++
*******************************************************************
		U p d a t e I n t e r f a c e S t a t e

Routine Description:
	Performs neccessary operations to syncronize interface operational state
	with externally set state
Arguments:
	node - interface control block to update
Return Value:
	NO_ERROR - interface was updated OK
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
UpdateInterfaceState (
	PINTERFACE_NODE		node
	) {
	DWORD		status=NO_ERROR;

	if (node->IN_IntfIdx!=INTERNAL_INTERFACE_INDEX) {
		if (node->IN_InUse
				&& (node->IN_AdptIdx!=INVALID_ADAPTER_INDEX)
				&& node->IN_Enabled
				&& (node->IN_Info.AdminState==ADMIN_STATE_ENABLED)
					) { // Interface data is in use and it is going to
						// stay active after the update: THIS IS A CONFIG
						// CHANGE ON THE FLY!!! We'll have to create a new
						// block and invalidate the old one
			PINTERFACE_NODE	newNode = GlobalAlloc (GMEM_FIXED,
												sizeof (INTERFACE_NODE));
			if (newNode==NULL) {
				status = GetLastError ();
				Trace (DEBUG_FAILURES, "File: %s, line %ld."
								"Could not allocate memory to replace"
								" active interface block on set: %ld(gle:%ld).",
									__FILE__, __LINE__, node->IN_IntfIdx, status);
				return status;
				}

				// Transfer external parameters
			newNode->IN_Data = node->IN_Data;
			newNode->IN_Filters = node->IN_Filters;
			newNode->IN_FilterNodes = node->IN_FilterNodes;
				// Setup referencing parameters
			newNode->IN_RefCount = 0;
			newNode->IN_InUse = FALSE;

				// Insert in same place in tables
			InsertTailList (&node->IN_IntfLink, &newNode->IN_IntfLink);
			InsertTailList (&node->IN_ListLink, &newNode->IN_ListLink);
				// Will put in adapter table at start
			InitializeListEntry (&newNode->IN_AdptLink);

			Trace (DEBUG_INTERFACES, 
							"Replacing interface block on SET: %lX(%d).",
								newNode, newNode->IN_IntfIdx);
			status = StartInterface (newNode);
			
			if (status != NO_ERROR)
				node = newNode; // If we failed we'll have to dispose
								// the new interface block and keep
								// the old one

				// Reset this flag to prevent deletion of all services
				// obtained through SAP (we want to keep them despite
				// the change to interface parameters)
			node->IN_Info.Listen = ADMIN_STATE_DISABLED;
				// Prevent deletion of transferred filters and name
			node->IN_Filters = NULL;
            node->IN_Name = NULL;
				// Shutdown interface if it is still active
			if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
				node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;
				StopInterface (node);
				}

				// Remove and dispose of original interface control block
			Trace (DEBUG_INTERFACES, "Invalidating interface block: %lX(%d).",
								node, node->IN_IntfIdx);
			RemoveEntryList (&node->IN_IntfLink);
			InvalidateInterface (node);
			RemoveEntryList (&node->IN_ListLink);
			// Dispose only if nobody uses it and not waiting on critical
			// section to dispose of it
			if ((node->IN_RefCount==0)
					&& !node->IN_InUse) {
				Trace (DEBUG_INTERFACES, "Releasing interface block: %lX(%d).",
									node, node->IN_IntfIdx);
				GlobalFree (node);
				}
				// Otherwise, just leave it hang outside of the table
				// till last client releases reference to it
#if DBG
			else	// Keep track of all blocks in debugging mode
				InsertTailList (&InterfaceTable.IT_DetachedIntf,
													&node->IN_ListLink);
#endif
			}
		else {
			if ((node->IN_Enabled
						&& (node->IN_Info.AdminState==ADMIN_STATE_ENABLED)
						&& (node->IN_AdptIdx!=INVALID_ADAPTER_INDEX))) {
				if (node->IN_Stats.SapIfOperState!=OPER_STATE_UP)
					status = StartInterface (node);
				}
			else {
				if (node->IN_Stats.SapIfOperState==OPER_STATE_UP)
					status = StopInterface (node);
				else {
					if (node->IN_Enabled
						&& (node->IN_Info.AdminState==ADMIN_STATE_ENABLED)
						&& (node->IN_Type!=PERMANENT))
						node->IN_Stats.SapIfOperState = OPER_STATE_SLEEPING;
					else
						node->IN_Stats.SapIfOperState = OPER_STATE_DOWN;
					}
				}
			}
		}
	else {
		Trace (DEBUG_INTERFACES, "Internal interface info updated.");
		IpxNetCpy (INTERNAL_IF_NET, node->IN_Adpt.Network);
		IpxNodeCpy (INTERNAL_IF_NODE, node->IN_Adpt.LocalNode);
		}

	return status;
	}


/*++
*******************************************************************
		S a p S e t I n t e r f a c e E n a b l e

Routine Description:
	Enables/disables interface
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	Enable - TRUE-enable, FALSE-disable
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetInterfaceEnable (
	ULONG	InterfaceIndex,
	BOOL	Enable
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD			status=NO_ERROR;

	EnterCriticalSection (&InterfaceList.IL_Lock); // Don't allow any queries
													// in interface list
													// while we are doing this
	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		HANDLE enumHdl;
		if (node->IN_Enabled!=Enable) {
			node->IN_Enabled = (UCHAR)Enable;
			status = UpdateInterfaceState (node);
			}
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		LeaveCriticalSection (&InterfaceList.IL_Lock);
		
		if (status==NO_ERROR) {
			enumHdl = CreateListEnumerator (SDB_INTF_LIST_LINK,
											0xFFFF,
											NULL,
											node->IN_IntfIdx,
											0xFFFFFFFF,
											Enable ? SDB_DISABLED_NODE_FLAG : 0);
				// Disable/Reenable all services
			if (enumHdl!=NULL) {
				EnumerateServers (enumHdl, Enable
											? EnableAllServersCB
											: DisableAllServersCB, enumHdl);
				DeleteListEnumerator (enumHdl);
				}
			else 
				Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Could not create enumerator to enable/disable"
						" sap servers for interface: %ld.",
								__FILE__, __LINE__, node->IN_IntfIdx);
			}
		}
	else {
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		LeaveCriticalSection (&InterfaceList.IL_Lock);
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	return status;
	}

		

/*++
*******************************************************************
		S a p S e t S a p I n t e r f a c e 

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - new interface configuration info
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetSapInterface (
	ULONG InterfaceIndex,
	PSAP_IF_INFO SapIfConfig
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD			status=NO_ERROR;

	EnterCriticalSection (&InterfaceList.IL_Lock); // Don't allow any queries
													// in interface list
													// while we are doing this

	if_IsInterfaceNode (InterfaceIndex,node,cur) {
			// memcmp on structures!!!  may not work with all compilers
			// but event if it fails, the result will be just an
			// set extra operation
		if (memcmp (&node->IN_Info, SapIfConfig, sizeof (node->IN_Info))!=0) {
			node->IN_Info = *SapIfConfig;
			status = UpdateInterfaceState (node);
			}
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}


/*++
*******************************************************************
		S a p I s S a p I n t e r f a c e 

Routine Description:
	Checks if interface with given index exists
Arguments:
	InterfaceIndex - unique number that indentifies new interface
Return Value:
	TRUE - exist
	FALSE	- does not

*******************************************************************
--*/
BOOL
SapIsSapInterface (
	IN ULONG InterfaceIndex
	) {
	PINTERFACE_NODE	node;
	PLIST_ENTRY		cur;
	BOOL			res;

	if_IsInterfaceNode (InterfaceIndex,node,cur)
		res = TRUE;
	else
		res = FALSE;
	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	return res;
	}

/*++
*******************************************************************
		S a p G e t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with interface
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/

DWORD
SapGetSapInterface (
	IN ULONG InterfaceIndex,
	OUT PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	) {
	PINTERFACE_NODE	node;
	DWORD			status;
	PLIST_ENTRY		cur;

	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		if (ARGUMENT_PRESENT(SapIfConfig))
			*SapIfConfig = node->IN_Info;
		if (ARGUMENT_PRESENT(SapIfStats))
			*SapIfStats = node->IN_Stats;
		status = NO_ERROR;
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	return status;
	}



/*++
*******************************************************************
		S a p G e t F i r s t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with first
	interface in InterfaceIndex order
Arguments:
	InterfaceIndex - buffer to store unique number that indentifies interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	ERROR_NO_MORE_ITEMS - no interfaces in the table
	other - operation failed (windows error code)

*******************************************************************
--*/

DWORD
SapGetFirstSapInterface (
	OUT PULONG InterfaceIndex,
	OUT	PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	) {
	PINTERFACE_NODE		node;
	DWORD				status;

	EnterCriticalSection (&InterfaceList.IL_Lock);
	if (!IsListEmpty (&InterfaceList.IL_Head)) {
		node = CONTAINING_RECORD (InterfaceList.IL_Head.Flink,
								INTERFACE_NODE,
								IN_ListLink);
			// Lock the table to make sure nobody modifies data while
			// we are accessing it
		EnterCriticalSection (&InterfaceTable.IT_Lock);
		*InterfaceIndex = node->IN_IntfIdx;
		if (ARGUMENT_PRESENT(SapIfConfig))
			*SapIfConfig = node->IN_Info;
		if (ARGUMENT_PRESENT(SapIfStats))
			*SapIfStats = node->IN_Stats;
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		status = NO_ERROR;
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_NO_MORE_ITEMS;
		}
	LeaveCriticalSection (&InterfaceList.IL_Lock);

	return status;
	}

/*++
*******************************************************************
		S a p G e t N e x t S a p I n t e r f a c e 

Routine Description:
	Retrieves configuration and statistic info associated with first
	interface in following interface with InterfaceIndex order in interface
	index order
Arguments:
	InterfaceIndex - on input - interface number to search from
					on output - interface number of next interface
	SapIfConfig - buffer to store configuration info
	SapIfStats - buffer to store statistic info
Return Value:
	NO_ERROR - info was retrieved OK
	ERROR_NO_MORE_ITEMS - no more interfaces in the table
	other - operation failed (windows error code)

*******************************************************************
--*/

DWORD
SapGetNextSapInterface (
	IN OUT PULONG InterfaceIndex,
	OUT	PSAP_IF_INFO  SapIfConfig OPTIONAL,
	OUT PSAP_IF_STATS SapIfStats OPTIONAL
	) {
	PINTERFACE_NODE		node;
	PLIST_ENTRY			cur;
	DWORD				status=ERROR_NO_MORE_ITEMS;

	EnterCriticalSection (&InterfaceList.IL_Lock);

	if_IsInterfaceNode(*InterfaceIndex,node,cur) {
		if (node->IN_ListLink.Flink!=&InterfaceList.IL_Head) {
			node = CONTAINING_RECORD (node->IN_ListLink.Flink,
										INTERFACE_NODE,
										IN_ListLink);
			*InterfaceIndex = node->IN_IntfIdx;
			if (ARGUMENT_PRESENT(SapIfConfig))
				*SapIfConfig = node->IN_Info;
			if (ARGUMENT_PRESENT(SapIfStats))
				*SapIfStats = node->IN_Stats;
			status = NO_ERROR;
			}
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		}
	else {
		LeaveCriticalSection (&InterfaceTable.IT_Lock);
		cur = InterfaceList.IL_Head.Flink;
		while (cur!=&InterfaceList.IL_Head) {
			node = CONTAINING_RECORD (cur,
										INTERFACE_NODE,
										IN_ListLink);
			if (*InterfaceIndex<node->IN_IntfIdx)
				break;
			}

		if (cur!=&InterfaceList.IL_Head) {
			EnterCriticalSection (&InterfaceTable.IT_Lock);
			*InterfaceIndex = node->IN_IntfIdx;
			if (ARGUMENT_PRESENT(SapIfConfig))
				*SapIfConfig = node->IN_Info;
			if (ARGUMENT_PRESENT(SapIfStats))
				*SapIfStats = node->IN_Stats;
			LeaveCriticalSection (&InterfaceTable.IT_Lock);
			status = NO_ERROR;
			}
		}

	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}

/*++
*******************************************************************
		S a p S e t I n t e r f a c e F i l t e r s

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapSetInterfaceFilters (
	IN ULONG			InterfaceIndex,
	IN PSAP_IF_FILTERS	SapIfFilters
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_NODE	node;
	DWORD			status=NO_ERROR;

	EnterCriticalSection (&InterfaceList.IL_Lock); // Don't allow any queries
													// in interface list
													// while we are doing this
	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		if (	((node->IN_Filters!=NULL) && (SapIfFilters!=NULL)
			// memcmp on structures!!!  may not work with all compilers
			// but event if it fails, the result will be just an
			// set extra operation
					&& (memcmp (node->IN_Filters, SapIfFilters, 
							FIELD_OFFSET (SAP_IF_FILTERS,ServiceFilter))==0)
					&& (memcmp (&node->IN_Filters->ServiceFilter[0],
							&SapIfFilters->ServiceFilter[0],
							sizeof (SAP_SERVICE_FILTER_INFO)*
								(SapIfFilters->SupplyFilterCount
								+SapIfFilters->ListenFilterCount))==0))
						// Filter info hasn't changed
				|| ((node->IN_Filters==NULL)
					&& ((SapIfFilters==NULL)
						|| (SapIfFilters->SupplyFilterCount
								+SapIfFilters->ListenFilterCount==0))) )
						// There are no filters
			status = NO_ERROR;
		else {
			if ((SapIfFilters!=NULL)
					&& (SapIfFilters->SupplyFilterCount
								+SapIfFilters->ListenFilterCount>0)) {
				PFILTER_NODE	newNodes;
				PSAP_IF_FILTERS	newFilters;
				ULONG			newTotal = SapIfFilters->SupplyFilterCount
											+SapIfFilters->ListenFilterCount;
				newFilters = (PSAP_IF_FILTERS) GlobalAlloc (GMEM_FIXED,
							FIELD_OFFSET (SAP_IF_FILTERS,ServiceFilter[newTotal])
							+sizeof (FILTER_NODE)*newTotal);
				if (newFilters!=NULL) {
					ULONG		i;
					memcpy (newFilters, SapIfFilters,
						FIELD_OFFSET (SAP_IF_FILTERS,ServiceFilter[newTotal]));
					newNodes = (PFILTER_NODE)&newFilters->ServiceFilter[newTotal];
					for (i=0; i<newTotal; i++) {
						newNodes[i].FN_Index = InterfaceIndex;
						newNodes[i].FN_Filter = &newFilters->ServiceFilter[i];
						}
					}
				else {
					status = GetLastError ();
					goto ExitSetFilters;
					}

				if (node->IN_Filters) {
					ReplaceFilters (
								FILTER_TYPE_SUPPLY,
								&node->IN_FilterNodes[0],
								node->IN_Filters->SupplyFilterCount,
								&newNodes[0],
								newFilters->SupplyFilterCount);
					ReplaceFilters (
								FILTER_TYPE_LISTEN,
								&node->IN_FilterNodes[node->IN_Filters->SupplyFilterCount],
								node->IN_Filters->ListenFilterCount,
								&newNodes[newFilters->SupplyFilterCount],
								newFilters->ListenFilterCount);
					}
				else {
					ReplaceFilters (
								FILTER_TYPE_SUPPLY,
								NULL,
								0,
								&newNodes[0],
								newFilters->SupplyFilterCount);
					ReplaceFilters (
								FILTER_TYPE_LISTEN,
								NULL,
								0,
								&newNodes[newFilters->SupplyFilterCount],
								newFilters->ListenFilterCount);
					}
				node->IN_Filters = newFilters;
				node->IN_FilterNodes = newNodes;
				node->IN_FilterOut = newFilters->SupplyFilterCount>0
									? (UCHAR)newFilters->SupplyFilterAction
									: SAP_DONT_FILTER;
				node->IN_FilterIn = newFilters->ListenFilterCount>0
									? (UCHAR)newFilters->ListenFilterAction
									: SAP_DONT_FILTER;
				}
			else {
				ReplaceFilters (
							FILTER_TYPE_SUPPLY,
							&node->IN_FilterNodes[0],
							node->IN_Filters->SupplyFilterCount,
							NULL, 0);

				ReplaceFilters (
							FILTER_TYPE_LISTEN,
							&node->IN_FilterNodes[node->IN_Filters->SupplyFilterCount],
							node->IN_Filters->ListenFilterCount,
							NULL, 0);
				GlobalFree (node->IN_Filters);
				node->IN_Filters = NULL;
				node->IN_FilterNodes = NULL;
				node->IN_FilterIn = node->IN_FilterOut = SAP_DONT_FILTER;
				}
			status = NO_ERROR;
			}
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

ExitSetFilters:

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}


/*++
*******************************************************************
		S a p G e t I n t e r f a c e F i l t e r s

Routine Description:
	Compares existing interface configuration with the new one and
	performs an update if necessary.
Arguments:
Return Value:
	NO_ERROR - config info was changed OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapGetInterfaceFilters (
	IN ULONG			InterfaceIndex,
	OUT PSAP_IF_FILTERS SapIfFilters,
	OUT PULONG			FilterBufferSize
	) {
	PINTERFACE_NODE	node;
	DWORD			status;
	PLIST_ENTRY		cur;

	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		if (node->IN_Filters!=NULL) {
			PSAP_IF_FILTERS info = node->IN_Filters;
			ULONG infoSize
				= FIELD_OFFSET (SAP_IF_FILTERS,
						ServiceFilter[info->SupplyFilterCount
								+info->ListenFilterCount]);
			if (*FilterBufferSize>=infoSize) {
				memcpy (SapIfFilters, info, infoSize);
				status = NO_ERROR;
				}
			else
				status = ERROR_INSUFFICIENT_BUFFER;
			*FilterBufferSize = infoSize;
			}
		else {
			ULONG infoSize = FIELD_OFFSET (SAP_IF_FILTERS, ServiceFilter);
            if (*FilterBufferSize>=infoSize) {
                SapIfFilters->SupplyFilterCount = 0;
                SapIfFilters->SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
                SapIfFilters->ListenFilterCount = 0;
                SapIfFilters->ListenFilterAction = IPX_SERVICE_FILTER_DENY;
				status = NO_ERROR;
            }
            else
				status = ERROR_INSUFFICIENT_BUFFER;
			*FilterBufferSize = infoSize;
			}
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

   	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	return status;
	}


/*++
*******************************************************************
		S a p B i n d S a p I n t e r f a c e T o A d a p t e r

Routine Description:
	Establishes association between interface and physical adapter
	and starts sap on the interface if its admin state is enabled
Arguments:
	InterfaceIndex - unique number that indentifies new interface
	AdapterInfo - info associated with adapter to bind to
Return Value:
	NO_ERROR - interface was bound OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapBindSapInterfaceToAdapter (
	ULONG			 			InterfaceIndex,
	PIPX_ADAPTER_BINDING_INFO	AdptInternInfo
	) {
	PINTERFACE_NODE	node;
	DWORD			status=NO_ERROR;
	PLIST_ENTRY		cur;

	EnterCriticalSection (&InterfaceList.IL_Lock); // Don't allow any queries
													// in interface list
													// while we are doing this
	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		ASSERTMSG ("Interface is already bound ",
						 node->IN_AdptIdx==INVALID_ADAPTER_INDEX);
		node->IN_Adpt = *AdptInternInfo;
		status = UpdateInterfaceState (node);
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}
	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}


/*++
*******************************************************************
		S a p U n b i n d S a p I n t e r f a c e F r o m A d a p t e r

Routine Description:
	Breaks association between interface and physical adapter
	and stops sap on the interface if it was on
Arguments:
	InterfaceIndex - unique number that indentifies new interface
Return Value:
	NO_ERROR - interface was bound OK
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
SapUnbindSapInterfaceFromAdapter (
	ULONG InterfaceIndex
	) {
	PINTERFACE_NODE	node;
	DWORD			status;
	PLIST_ENTRY		cur;

	EnterCriticalSection (&InterfaceList.IL_Lock); // Don't allow any queries
													// in interface list
													// while we are doing this
	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		node->IN_AdptIdx = INVALID_ADAPTER_INDEX;
		if (node->IN_Stats.SapIfOperState==OPER_STATE_UP) {
			status = StopInterface (node);
			}

		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
						" Unknown interface: %ld.",
						__FILE__, __LINE__, InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	LeaveCriticalSection (&InterfaceList.IL_Lock);
	return status;
	}

/*++
*******************************************************************
	S a p R e q u e s t U p d a t e
Routine Description:
	Initiates update of services information over the interface
	Completion of this update will be indicated by signalling
	NotificationEvent passed at StartProtocol.  GetEventMessage
	can be used then to get the results of autostatic update
Arguments:
	InterfaceIndex - unique index identifying interface to do
		update on
Return Value:
	NO_ERROR	 - operation was initiated ok
	ERROR_CAN_NOT_COMPLETE - the interface does not support updates
	ERROR_INVALID_PARAMETER - interface with this index does not exist
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
SapRequestUpdate (
	ULONG		InterfaceIndex
	) {
	PINTERFACE_NODE	node;
	DWORD			status;
	PLIST_ENTRY		cur;

	if_IsInterfaceNode (InterfaceIndex,node,cur) {
		if ((node->IN_Info.UpdateMode==IPX_AUTO_STATIC_UPDATE)
				&& (node->IN_Stats.SapIfOperState==OPER_STATE_UP)) {
			Trace (DEBUG_INTERFACES, "Starting update on interface: %ld.",
														 InterfaceIndex);
			status = InitTreqItem (&node->IN_Data);
			}
		else {
			Trace (DEBUG_FAILURES, "RequestUpdate called on unbound or"
							" 'standard update mode' interface: %ld.",
														 InterfaceIndex);
			status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else {
		Trace (DEBUG_FAILURES, "Unknown interface: %ld.", InterfaceIndex);
		status = ERROR_INVALID_PARAMETER;
		}

	LeaveCriticalSection (&InterfaceTable.IT_Lock);
	return status;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\lpcmgr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\lpcmgr.c

Abstract:

	This module implements LPC interface supported by SAP agent

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

	// Context kept for each client that connects to us
typedef struct _LPC_CLIENT_CONTEXT {
	LIST_ENTRY		LCC_Link;	// Link in client list
	HANDLE			LCC_Port;	// Port through which we talk
	LONG			LCC_RefCount;	// Reference count of this context block
	} LPC_CLIENT_CONTEXT, *PLPC_CLIENT_CONTEXT;

	// Queue of LPC requeuest to be processed and associated synchronization
typedef struct _LPC_QUEUE {
	HANDLE				LQ_Port;		// LPC communication port
	HANDLE				LQ_Thread;		// Thread to wait on LPC port
	PLPC_PARAM_BLOCK	LQ_Request;		// Pending request
	LIST_ENTRY			LQ_ClientList;	// List of connected clients
	CRITICAL_SECTION	LQ_Lock;		// Protection
	} LPC_QUEUE, *PLPC_QUEUE;

LPC_QUEUE	LpcQueue;

DWORD WINAPI
LPCThread (
	LPVOID param
	);

/*++
*******************************************************************
		I n i t i a l i z e L P C S t u f f

Routine Description:
	Allocates resources neccessary to implement LPC interface
Arguments:
	none
Return Value:
	NO_ERROR - port was created OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
InitializeLPCStuff (
	void
	) {
	InitializeCriticalSection (&LpcQueue.LQ_Lock);
	InitializeListHead (&LpcQueue.LQ_ClientList);
	LpcQueue.LQ_Request = NULL;
	LpcQueue.LQ_Port = NULL;
	LpcQueue.LQ_Thread = NULL;
	return NO_ERROR;
	}


/*++
*******************************************************************
		S t a r t L P C

Routine Description:
	Start SAP LPC interface
Arguments:
	None
Return Value:
	NO_ERROR - LPC interface was started OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
StartLPC (
	void
	) {
	DWORD		status;
	UNICODE_STRING		UnicodeName;
	OBJECT_ATTRIBUTES	ObjectAttributes;

    RtlInitUnicodeString(&UnicodeName, NWSAP_BIND_PORT_NAME_W);

    InitializeObjectAttributes(&ObjectAttributes,
						       &UnicodeName,
						       0,
						       NULL,
						       NULL);
	LpcQueue.LQ_Port = NULL;
    status = NtCreatePort(&LpcQueue.LQ_Port,
                 		&ObjectAttributes,
                 		0,
                 		NWSAP_BS_PORT_MAX_MESSAGE_LENGTH,
                 		NWSAP_BS_PORT_MAX_MESSAGE_LENGTH * 32);
	if (NT_SUCCESS(status)) {
		DWORD	threadID;

		LpcQueue.LQ_Thread = CreateThread (
							NULL,
							0,
							&LPCThread,
							NULL,
							0,
							&threadID);

		if (LpcQueue.LQ_Thread!=NULL)
			return NO_ERROR;
		else {
			status = GetLastError ();
			Trace (DEBUG_FAILURES, "File: %s, line %ld."
								" Failed to start LPC thread (%0lx).",
							__FILE__, __LINE__, status);
			}
		NtClose (LpcQueue.LQ_Port);
		LpcQueue.LQ_Port = NULL;
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
							" Failed to create LPC port(%0lx).",
						__FILE__, __LINE__, status);
		}
	return status;
	}


/*++
*******************************************************************
		S h u t d o w n L P C

Routine Description:
	Shuts SAP LPC interface down, closes all active sessions
Arguments:
	None
Return Value:
	NO_ERROR - LPC interface was shutdown OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
ShutdownLPC (
	void
	) {

	EnterCriticalSection (&LpcQueue.LQ_Lock);
	if (LpcQueue.LQ_Thread!=NULL) {
        UNICODE_STRING unistring;
        NTSTATUS status;
        SECURITY_QUALITY_OF_SERVICE qos;
        HANDLE  lpcPortHandle;
        NWSAP_REQUEST_MESSAGE request;

    	LeaveCriticalSection (&LpcQueue.LQ_Lock);
        /** Fill out the security quality of service **/

        qos.Length = sizeof(qos);
        qos.ImpersonationLevel  = SecurityImpersonation;
        qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        qos.EffectiveOnly       = TRUE;

        /** Setup the unicode string of the port name **/

        RtlInitUnicodeString(&unistring, NWSAP_BIND_PORT_NAME_W);

        /** Do the connect **/

        status = NtConnectPort(
                &lpcPortHandle,             /* We get a handle back     */
                &unistring,                 /* Port name to connect to  */
                &qos,                       /* Quality of service       */
                NULL,                       /* Client View              */
                NULL,                       /* Server View              */
                NULL,                       /* MaxMessageLength         */
                NULL,                       /* ConnectionInformation    */
                NULL);                      /* ConnectionInformationLength */

        /** If error - just return it **/

        ASSERT (NT_SUCCESS(status));



        request.MessageType = NWSAP_LPCMSG_STOP;
        request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
        request.PortMessage.u1.s1.TotalLength = sizeof(request);
        request.PortMessage.u2.ZeroInit       = 0;
        request.PortMessage.MessageId         = 0;


        /** Send it and get a response **/

        status = NtRequestPort(
                    lpcPortHandle,
                    (PPORT_MESSAGE)&request);

        ASSERT (NT_SUCCESS(status));

        status = WaitForSingleObject (LpcQueue.LQ_Thread, INFINITE);
        ASSERT (status==WAIT_OBJECT_0);

        CloseHandle (lpcPortHandle);

        EnterCriticalSection (&LpcQueue.LQ_Lock);
		CloseHandle (LpcQueue.LQ_Thread);
		LpcQueue.LQ_Thread = NULL;
		}

	while (!IsListEmpty (&LpcQueue.LQ_ClientList)) {
		PLPC_CLIENT_CONTEXT clientContext = CONTAINING_RECORD (
												LpcQueue.LQ_ClientList.Flink,
												LPC_CLIENT_CONTEXT,
												LCC_Link);
		RemoveEntryList (&clientContext->LCC_Link);
		NtClose (clientContext->LCC_Port);
		clientContext->LCC_RefCount -= 1;
		if (clientContext->LCC_RefCount<0)
			GlobalFree (clientContext);
		}


	if (LpcQueue.LQ_Request!=NULL) {
		BOOL	res;
		LpcQueue.LQ_Request->client = NULL;
		ProcessCompletedLpcRequest (LpcQueue.LQ_Request);
		LpcQueue.LQ_Request = NULL;
		}
	LeaveCriticalSection (&LpcQueue.LQ_Lock);
	
	NtClose (LpcQueue.LQ_Port);
	LpcQueue.LQ_Port = NULL;
	return NO_ERROR;
	}

/*++
*******************************************************************
		D e l e t e L P C S t u f f

Routine Description:
	Disposes of resources allocated for LPC interface
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
DeleteLPCStuff (
	void
	) {
	if (LpcQueue.LQ_Port!=NULL)
		ShutdownLPC ();

	DeleteCriticalSection (&LpcQueue.LQ_Lock);
	}


/*++
*******************************************************************
		L P C T h r e a d
Routine Description:
	Thread to be used to wait for and initially process LPC requests
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD WINAPI
LPCThread (
	LPVOID param
	) {

	while (1) {
		if (InitLPCItem ()!=NO_ERROR)
			// Sleep for a while if there is an error and we have to continue
			Sleep (SAP_ERROR_COOL_OFF_TIME);
		}
	return NO_ERROR;
	}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


		
/*++
*******************************************************************
		P r o c e s s L P C R e q u e s t s

Routine Description:
	Waits for requests on LPC port and processes them
	Client requests that require additional processing by other SAP
	components are enqued into completion queue.
	This routine returns only when it encounters a request that requires
	additional processing or when error occurs
Arguments:
	lreq - LPC parameter block to be filled and posted to completions queue
Return Value:
	NO_ERROR - LPC request was received and posted to completio queue
	other - operation failed (LPC supplied error code)
*******************************************************************
--*/
DWORD
ProcessLPCRequests (
	PLPC_PARAM_BLOCK		lreq
	) {
	DWORD				status;
	PLPC_CLIENT_CONTEXT	clientContext;
	BOOL				res;

    Trace (DEBUG_LPCREQ, "ProcessLPCRequests: entered.");

	EnterCriticalSection (&LpcQueue.LQ_Lock);
	LpcQueue.LQ_Request = lreq;


    Trace (DEBUG_LPCREQ, "ProcessLPCRequests: go lpcqueue lock.");


	while (TRUE) {
		LeaveCriticalSection (&LpcQueue.LQ_Lock);
		status = NtReplyWaitReceivePort(LpcQueue.LQ_Port,
										&clientContext,
										NULL,
										(PPORT_MESSAGE)lreq->request);
		EnterCriticalSection (&LpcQueue.LQ_Lock);
		if (NT_SUCCESS (status)) {
			switch (lreq->request->PortMessage.u2.s2.Type) {
				case LPC_CONNECTION_REQUEST:
					clientContext = (PLPC_CLIENT_CONTEXT)GlobalAlloc (
											GMEM_FIXED,
											sizeof (LPC_CLIENT_CONTEXT));
					if (clientContext!=NULL) {
						clientContext->LCC_Port = NULL;
						clientContext->LCC_RefCount = 0;
					 	status = NtAcceptConnectPort(
					 				&clientContext->LCC_Port,
									clientContext,
									&lreq->request->PortMessage,
									TRUE,
									NULL,
									NULL);
						if (NT_SUCCESS(status)) {
							status = NtCompleteConnectPort (
												clientContext->LCC_Port);
							if (NT_SUCCESS (status)) {
								InsertTailList (&LpcQueue.LQ_ClientList,
												&clientContext->LCC_Link);
								Trace (DEBUG_LPC, "New LPC client: %0lx.", clientContext);
								continue;
								}
							else
								Trace (DEBUG_FAILURES,
									"File: %s, line %ld."
									" Error in complete connect(nts:%0lx)."
									__FILE__, __LINE__, status);
							NtClose (clientContext->LCC_Port);
							}
						else
							Trace (DEBUG_FAILURES, "File: %s, line %ld."
									" Error in accept connect(%0lx)."
									__FILE__, __LINE__, status);
						GlobalFree (clientContext);								
						}
					else {
						HANDLE		Port;
						Trace (DEBUG_FAILURES, "File: %s, line %ld."
							" Could not allocate lpc client block(gle:%ld."
									__FILE__, __LINE__, GetLastError ());

					 	status = NtAcceptConnectPort(
					 				&Port,
									NULL,
									&lreq->request->PortMessage,
									FALSE,
									NULL,
									NULL);
						if (!NT_SUCCESS(status))
							Trace (DEBUG_FAILURES,
								"File: %s, line %ld."
								" Error in reject connect(nts:%0lx)."
									__FILE__, __LINE__, status);
						}

					continue;
		        case LPC_REQUEST:
					lreq->client = (HANDLE)clientContext;
					clientContext->LCC_RefCount += 1;
                    ProcessCompletedLpcRequest (LpcQueue.LQ_Request);
					LpcQueue.LQ_Request = NULL;
					break;
                case LPC_PORT_CLOSED:
		        case LPC_CLIENT_DIED:
					Trace (DEBUG_LPC,
						" LPC client %0lx died.", clientContext);
					RemoveEntryList (&clientContext->LCC_Link);
					NtClose (clientContext->LCC_Port);
					clientContext->LCC_RefCount -= 1;
					if (clientContext->LCC_RefCount<0)
						GlobalFree (clientContext);
					continue;
                case LPC_DATAGRAM:
                    if (lreq->request->MessageType==NWSAP_LPCMSG_STOP) {
                    	LeaveCriticalSection (&LpcQueue.LQ_Lock);
					    Trace (DEBUG_LPC, " Stop message received -> exiting.");
                        ExitThread (0);
                    }
				default:
					Trace (DEBUG_FAILURES,
						"Unknown or not supported lpc message: %ld.",
								lreq->request->PortMessage.u2.s2.Type);
					continue;
				}
			}
		else
			Trace (DEBUG_FAILURES, "File: %s, line %ld."
							" Error on wait lpc request(%0lx).",
							__FILE__, __LINE__,
							status);
		break;
		}
	LeaveCriticalSection (&LpcQueue.LQ_Lock);

	return status;
	}



/*++
*******************************************************************
		S e n d L P C R e p l y

Routine Description:
	Send reply for LPC request
Arguments:
	client - context associated with client to reply to
	request - request to which to reply
	reply - reply to send
Return Value:
	NO_ERROR - LPC reply was sent OK
	other - operation failed (LPC supplied error code)
*******************************************************************
--*/
DWORD
SendLPCReply (
	HANDLE					client,
	PNWSAP_REQUEST_MESSAGE	request,
	PNWSAP_REPLY_MESSAGE	reply
	) {
	DWORD					status;
	PLPC_CLIENT_CONTEXT		clientContext = (PLPC_CLIENT_CONTEXT)client;

	EnterCriticalSection (&LpcQueue.LQ_Lock);
	if (clientContext->LCC_RefCount>0) {
		reply->PortMessage.u1.s1.DataLength =
							sizeof(*reply) - sizeof(PORT_MESSAGE);
		reply->PortMessage.u1.s1.TotalLength = sizeof(*reply);
		reply->PortMessage.u2.ZeroInit = 0;
		reply->PortMessage.ClientId  = request->PortMessage.ClientId;
	    reply->PortMessage.MessageId = request->PortMessage.MessageId;

		status = NtReplyPort(clientContext->LCC_Port, (PPORT_MESSAGE)reply);
		clientContext->LCC_RefCount -= 1;
		}
	else {
		GlobalFree (clientContext);
		status = ERROR_INVALID_HANDLE;
		}
	LeaveCriticalSection (&LpcQueue.LQ_Lock);

	if (!NT_SUCCESS(status))
		Trace (DEBUG_FAILURES,
			"File: %s, line %ld. Error in lpc reply(nts:%0lx).",
			__FILE__, __LINE__, status);
	return status;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\netio.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\netio.c

Abstract:
	This module handles network io for sap agent

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#include "sapp.h"

	// Queues and synchronization associated with net io
typedef struct _IO_QUEUES {
		HANDLE				IQ_AdptHdl;		// Handle to SAP socket port
		HANDLE				IQ_RecvEvent;	// Event signalled when recv completes
#if DBG
		LIST_ENTRY			IQ_SentPackets;	// Packets that are being sent
		LIST_ENTRY			IQ_RcvdPackets;	// Packets that are being received
#endif
		CRITICAL_SECTION	IQ_Lock;		// Queue data protection
		} IO_QUEUES, *PIO_QUEUES;

IO_QUEUES		IOQueues;

VOID CALLBACK
IoCompletionProc (
	DWORD			error,
	DWORD			cbTransferred,
	LPOVERLAPPED	ovlp
	);

	
VOID CALLBACK
SendCompletionProc (
	DWORD			status,
	DWORD			cbSent,
	PIO_PARAM_BLOCK sreq
	);
	
VOID CALLBACK
RecvCompletionProc (
	DWORD			status,
	DWORD			cbSent,
	PIO_PARAM_BLOCK rreq
	);


DWORD
CreateIOQueue (
	HANDLE	*RecvEvent
	) {
	DWORD	status;
	InitializeCriticalSection (&IOQueues.IQ_Lock);
#if DBG
	InitializeListHead (&IOQueues.IQ_SentPackets);
	InitializeListHead (&IOQueues.IQ_RcvdPackets);
#endif
	IOQueues.IQ_AdptHdl = INVALID_HANDLE_VALUE;

	IOQueues.IQ_RecvEvent = CreateEvent (NULL, 
								FALSE,	// auto-reset (reset by recv operation
										// and when thread is signalled (it may
										// not post new request if limit is
										// exceded)
								FALSE,	// not signalled
								NULL);
	if (IOQueues.IQ_RecvEvent!=NULL) {
		INT	i;
		*RecvEvent = IOQueues.IQ_RecvEvent;
		return NO_ERROR;
		}
	else {
		status = GetLastError ();
		Trace (DEBUG_FAILURES,
			"Failed to create recv comp event (gle:%ld)", status);
		}
	DeleteCriticalSection (&IOQueues.IQ_Lock);
	return status;
	}

VOID
DeleteIOQueue (
	VOID
	) {
	CloseHandle (IOQueues.IQ_RecvEvent);
	DeleteCriticalSection (&IOQueues.IQ_Lock);
	}

DWORD
StartIO (
	VOID
	) {
	DWORD	status=NO_ERROR;


	EnterCriticalSection (&IOQueues.IQ_Lock);
	if (IOQueues.IQ_AdptHdl==INVALID_HANDLE_VALUE) {
		USHORT	sockNum;
		IpxSockCpy (&sockNum, IPX_SAP_SOCKET);
		Trace (DEBUG_NET_IO, "Creating socket port.");
		IOQueues.IQ_AdptHdl = CreateSocketPort (sockNum);
		if (IOQueues.IQ_AdptHdl!=INVALID_HANDLE_VALUE) {
			status = NO_ERROR;
			if (! BindIoCompletionCallback(
							IOQueues.IQ_AdptHdl,
							IoCompletionProc,
							0))
            {
                status = GetLastError();
            }
			if (status==NO_ERROR) {
				BOOL res;
				LeaveCriticalSection (&IOQueues.IQ_Lock);
				res = SetEvent (IOQueues.IQ_RecvEvent);
				ASSERTMSG ("Could not set recv event ", res);
				return NO_ERROR;
				}
			else {
				status = GetLastError ();
				Trace (DEBUG_FAILURES,
						"Failed to create completion port (gle:%ld)", status);
				}
			DeleteSocketPort (IOQueues.IQ_AdptHdl);
			IOQueues.IQ_AdptHdl = INVALID_HANDLE_VALUE;
			}
		else {
			status = GetLastError ();
			Trace (DEBUG_FAILURES,
						"Failed to create adapter port (gle:%ld)", status);
            IF_LOG (EVENTLOG_ERROR_TYPE) {
                RouterLogErrorA (RouterEventLogHdl,
                        ROUTERLOG_IPXSAP_SAP_SOCKET_IN_USE,
                        0, NULL, status);

			    }
            }
		}
	LeaveCriticalSection (&IOQueues.IQ_Lock);
	return status;
	}


VOID
StopIO (
	VOID
	) {
	EnterCriticalSection (&IOQueues.IQ_Lock);
	if (IOQueues.IQ_AdptHdl!=INVALID_HANDLE_VALUE) {
		DWORD	status;
		HANDLE	Port = IOQueues.IQ_AdptHdl;
		IOQueues.IQ_AdptHdl = INVALID_HANDLE_VALUE;
		LeaveCriticalSection (&IOQueues.IQ_Lock);

		Trace (DEBUG_NET_IO, "Deleting socket port.");
		DeleteSocketPort (Port);

		}
	else
		LeaveCriticalSection (&IOQueues.IQ_Lock);
	}



/*++
*******************************************************************
		I o C o m p l e t i o n P r o c

Routine Description:
	Called on completion of each io request
Arguments:
	error - result of io
	cbTransferred - number of bytes actually sent
	ovlp - overlapped structure associated with io request 
Return Value:
	None
*******************************************************************
--*/
VOID CALLBACK
IoCompletionProc (
	DWORD			error,
	DWORD			cbTransferred,
	LPOVERLAPPED	ovlp
	) {
	PIO_PARAM_BLOCK	req = CONTAINING_RECORD (ovlp, IO_PARAM_BLOCK, ovlp);
		// Get actual parameters adjusted by the adapter dll
	IpxAdjustIoCompletionParams (ovlp, &cbTransferred, &error);
	(*req->comp)(error, cbTransferred, req);
}

/*++
*******************************************************************
		E n q u e u e S e n d R e q u e s t

Routine Description:
	Sets adapter id field in request io param block and enqueues
	send request to adapter's driver.
Arguments:
	sreq - io parameter block, the following fields must be set:
	intf - pointer to interface external data
	buffer - pointer to buffer that contains data to be sent
	cbBuffer - count of bytes of data in the buffer
Return Value:
	None
*******************************************************************
--*/
VOID
EnqueueSendRequest (
	PIO_PARAM_BLOCK		sreq
	) {
	DWORD			status;

	
	sreq->status = ERROR_IO_PENDING;
	sreq->ovlp.hEvent = NULL;
	sreq->comp = SendCompletionProc;
#if DBG
	EnterCriticalSection (&IOQueues.IQ_Lock);
	InsertTailList (&IOQueues.IQ_SentPackets, &sreq->link);
	LeaveCriticalSection (&IOQueues.IQ_Lock);
#endif
	status = IpxSendPacket (IOQueues.IQ_AdptHdl,
						sreq->adpt,
						sreq->buffer,
						sreq->cbBuffer,
						&sreq->rsvd,
						&sreq->ovlp,
						NULL
						);
		// If request failed and thus completion routine won't be called
		// we'll simulate completion ourselves so that request won't get
		// lost
	if (status!=NO_ERROR)
		SendCompletionProc (status, 0, sreq);
	}


/*++
*******************************************************************
		S e n d C o m p l e t i o n P r o c

Routine Description:
	Called on completion for each sent packet.
	Sets fields of send request io param block and enqueues it to
	completion queue.
Arguments:
	status - result of io
	cbSent - number of bytes actually sent
	context - context associated with send request (IO_PARAM_BLOCK)
Return Value:
	None
*******************************************************************
--*/
VOID CALLBACK
SendCompletionProc (
	DWORD			status,
	DWORD			cbSent,
	PIO_PARAM_BLOCK sreq
	) {
	BOOL			res;
	BOOL			releaseSend = FALSE;

	sreq->compTime = GetTickCount ();
	sreq->status = status;
	if (status!=NO_ERROR) {
#define dstPtr (sreq->buffer+FIELD_OFFSET (SAP_BUFFER, Dst.Network))
		Trace (DEBUG_FAILURES, 	"Error %d while sending to"
				" %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x"
				" on adapter %d.", status,
				*dstPtr, *(dstPtr+1), *(dstPtr+2), *(dstPtr+3),
				*(dstPtr+4), *(dstPtr+5), *(dstPtr+6), *(dstPtr+7), *(dstPtr+8), *(dstPtr+9),
				*(dstPtr+10), *(dstPtr+11),
				sreq->adpt);
#undef dstPtr
		}
	sreq->cbBuffer = cbSent;

#if DBG
		// Maintain queue of posted requests
	EnterCriticalSection (&IOQueues.IQ_Lock);
	RemoveEntryList (&sreq->link);
	LeaveCriticalSection (&IOQueues.IQ_Lock);
#endif
	ProcessCompletedIORequest (sreq);

	}



/*++
*******************************************************************
		E n q u e u e R e c v R e q u e s t

Routine Description:
	Enqueues recv request to be posted to the network driver.
Arguments:
	rreq - io parameter block, the following fields must be set:
	buffer - pointer to buffer to receive data
	cbBuffer - size of the buffer
Return Value:
	TRUE - need more recv requests (number of posted requests is below
				low water mark)
	FALSE - no more requests needed.

*******************************************************************
--*/
VOID
EnqueueRecvRequest (
	PIO_PARAM_BLOCK		rreq
	) {
	DWORD	status;

	rreq->status = ERROR_IO_PENDING;
	rreq->adpt = INVALID_ADAPTER_INDEX;
	rreq->ovlp.hEvent = IOQueues.IQ_RecvEvent;
	rreq->comp = RecvCompletionProc;
#if DBG
	EnterCriticalSection (&IOQueues.IQ_Lock);
	InsertTailList (&IOQueues.IQ_RcvdPackets, &rreq->link);
	LeaveCriticalSection (&IOQueues.IQ_Lock);
#endif
	status = IpxRecvPacket (IOQueues.IQ_AdptHdl,
						rreq->buffer,
						rreq->cbBuffer,
						&rreq->rsvd,
						&rreq->ovlp,
						NULL
						);
	if (status==NO_ERROR) {
		NOTHING;
		}
	else {
		Trace (DEBUG_FAILURES, "Error %d while posting receive packet", status);
			// If request failed and thus completion routine won't be called
			// we'll simulate completion ourselves so that request won't get
			// lost
		RecvCompletionProc (status, 0, rreq);
		}
	}


/*++
*******************************************************************
		R e c v C o m p l e t i o n P r o c

Routine Description:
	Called on completion of each received packet.
	Sets fields of recv request io param block and enqueues it to
	completion queue.
Arguments:
	status - result of io
	cbSent - number of bytes actually sent
	context - context associated with send request (IO_PARAM_BLOCK)
Return Value:
	None
*******************************************************************
--*/
VOID CALLBACK
RecvCompletionProc (
	DWORD			status,
	DWORD			cbRecvd,
	PIO_PARAM_BLOCK	rreq
	) {
	BOOL			completed=TRUE;

	rreq->adpt = GetNicId (&rreq->rsvd);
	rreq->compTime = GetTickCount ();
	rreq->cbBuffer = cbRecvd;
	rreq->status = status;

	if (status!=NO_ERROR)
		Trace (DEBUG_FAILURES, "Error %d while receiving packet on adapter %d.",
						 							status, rreq->adpt);
#if DBG
	EnterCriticalSection (&IOQueues.IQ_Lock);
	RemoveEntryList (&rreq->link);
	LeaveCriticalSection (&IOQueues.IQ_Lock);
#endif
	ProcessCompletedIORequest (rreq);
	}




/*++
*******************************************************************
		D u m p P a c k e t

Routine Description:
	Dumps IPX SAP packet fields to stdio
Arguments:
	Packet  - pointer to IPX SAP packet
	count - size of the packet
Return Value:
	None
*******************************************************************
--*/
/*
#if DBG
VOID
DumpPacket (
	PSAP_BUFFER	packet,
	DWORD		count
	) {
	SS_PRINTF(("Length          : %d.", GETUSHORT (&packet->Length)));
	SS_PRINTF(("Packet type     : %02X.", packet->PacketType));
	SS_PRINTF(("Dest. net       : %02X%02X%02X%02X.",
										packet->Dst.Net[0],
										packet->Dst.Net[1],
										packet->Dst.Net[2],
										packet->Dst.Net[3]));
	SS_PRINTF(("Dest. node      : %02X%02X%02X%02X%02X%02X.",
										packet->Dst.Node[0],
										packet->Dst.Node[1],
										packet->Dst.Node[2],
										packet->Dst.Node[3],
										packet->Dst.Node[4],
										packet->Dst.Node[5]));
	SS_PRINTF(("Dest. socket    : %04X.", GETUSHORT (&packet->Dst.Socket)));
	SS_PRINTF(("Src. net        : %02X%02X%02X%02X.",
										packet->Src.Net[0],
										packet->Src.Net[1],
										packet->Src.Net[2],
										packet->Src.Net[3]));
	SS_PRINTF(("Src. node       : %02X%02X%02X%02X%02X%02X.",
										packet->Src.Node[0],
										packet->Src.Node[1],
										packet->Src.Node[2],
										packet->Src.Node[3],
										packet->Src.Node[4],
										packet->Src.Node[5]));
	SS_PRINTF(("Src. socket     : %04X.", GETUSHORT (&packet->Src.Socket)));
	if (count>=(DWORD)FIELD_OFFSET(SAP_BUFFER, Entries[0])) {
		INT	j;
		SS_PRINTF(("SAP Operation   : %d.", GETUSHORT (&packet->Operation)));
		for (j=0; (j<7) && (count>=(DWORD)FIELD_OFFSET (SAP_BUFFER, Entries[j+1])); j++) {
			SS_PRINTF(("Server type     : %04X.", GETUSHORT (&packet->Entries[j].Type)));
			SS_PRINTF(("Server name     : %.48s.", packet->Entries[j].Name));
			SS_PRINTF(("Server net      : %02X%02X%02X%02X.",
										packet->Entries[j].Network[0],
										packet->Entries[j].Network[1],
										packet->Entries[j].Network[2],
										packet->Entries[j].Network[3]));
			SS_PRINTF(("Server node     : %02X%02X%02X%02X%02X%02X.",
										packet->Entries[j].Node[0],
										packet->Entries[j].Node[1],
										packet->Entries[j].Node[2],
										packet->Entries[j].Node[3],
										packet->Entries[j].Node[4],
										packet->Entries[j].Node[5]));
			SS_PRINTF(("Server socket   : %02X%02X.",
										packet->Entries[j].Socket[0],
										packet->Entries[j].Socket[1]));
			SS_PRINTF(("Server hops     : %d.", GETUSHORT (&packet->Entries[j].HopCount)));
			}
		if ((j==0) && (count>=(DWORD)FIELD_OFFSET (SAP_BUFFER, Entries[0].Name)))
			SS_PRINTF(("Server type     : %04X.", GETUSHORT (&packet->Entries[0].Type)));
		}
	}

#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\netio.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\netio.h

Abstract:

	Header file for net io module.

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_NETIO_
#define _SAP_NETIO_

	// Param block to enqueue io requests
typedef struct _IO_PARAM_BLOCK IO_PARAM_BLOCK, *PIO_PARAM_BLOCK;
struct _IO_PARAM_BLOCK {
		LIST_ENTRY			link;	// Link in internal queues
		ULONG				adpt;	// Adapter index 
		PUCHAR				buffer;	// Data to send/buffer to recv into
		DWORD				cbBuffer; // Size of data/buffer
		DWORD				status;	// Result of IO operation
		DWORD				compTime; // Time (windows time in msec)
									// the request was completed
		OVERLAPPED			ovlp;
		VOID				(CALLBACK *comp)
								(DWORD,DWORD,PIO_PARAM_BLOCK);
		ADDRESS_RESERVED	rsvd;
		};

DWORD
CreateIOQueue (
	HANDLE	*RecvEvent
	);

VOID
DeleteIOQueue (
	VOID
	);

DWORD
StartIO (
	VOID
	);

VOID
StopIO (
	VOID
	);



/*++
*******************************************************************
		E n q u e u e S e n d R e q u e s t

Routine Description:
	Sets adapter id field in request io param block and enqueues
	send request to adapter's driver.
Arguments:
	sreq - io parameter block, the following fields must be set:
			intf - pointer to interface external data
			buffer - pointer to buffer that contains data to be sent
			cbBuffer - count of bytes of data in the buffer
Return Value:
	None

*******************************************************************
--*/
VOID
EnqueueSendRequest (
	IN PIO_PARAM_BLOCK	sreq
	);


/*++
*******************************************************************
		E n q u e u e R e c v R e q u e s t

Routine Description:
	Enqueues recv request to be posted to the network driver.
Arguments:
	rreq - io parameter block, the following fields must be set:
	buffer - pointer to buffer to receive data
	cbBuffer - size of the buffer
Return Value:
	None

*******************************************************************
--*/
VOID
EnqueueRecvRequest (
	PIO_PARAM_BLOCK	rreq
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapdebug.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapdebug.h

Abstract:

	Header file for debugging support module for SAP agent
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_SAPDEBUG
#define _SAP_SAPDEBUG

extern HANDLE RouterEventLogHdl;
extern DWORD   EventLogMask;

#define IF_LOG(Event)                       \
    if ((RouterEventLogHdl!=NULL) && ((Event&EventLogMask)==Event))


	// Debug flags supported by SAP agent componenets
		// Report failures in system routines
#define DEBUG_FAILURES			0x00010000

		// Component wide events and external problems
#define DEBUG_SYNCHRONIZATION	0x00020000
#define DEBUG_SERVERDB			0x00040000
#define DEBUG_INTERFACES		0x00080000
#define DEBUG_TIMER				0x00100000
#define DEBUG_LPC				0x00200000
#define DEBUG_ADAPTERS			0x00400000	// Only one of
#define DEBUG_ASYNCRESULT		0x00400000	// two can be operational
#define DEBUG_NET_IO			0x00800000

		// Workers
#define DEBUG_BCAST				0x01000000
#define DEBUG_SREQ				0x02000000
#define DEBUG_REQ				0x04000000
#define DEBUG_RESP				0x08000000
#define DEBUG_GET_NEAREST		0x10000000
#define DEBUG_LPCREQ			0x20000000
#define DEBUG_TREQ				0x40000000
#define DEBUG_FILTERS			0x80000000


#if DBG
	// Complement assert macros in nt rtl
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}

#define ASSERTERRMSG(msg,exp) 									\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}

#else

#define ASSERTERR(exp)
#define ASSERTERRMSG(msg,exp) 

#endif

/*++
*******************************************************************
		T r a c e
Routine Description:
	Printf debugging info to console/file/debugger
Arguments:
	componentID - id of the component that prints trace info
	format - format string
Return Value:
	None	
*******************************************************************
--*/
VOID
Trace (
	DWORD	componentID,
	CHAR	*format,
	...
	);

/*++
*******************************************************************
		D b g I n i t i a l i z e
Routine Description:
	Initializes debugging support stuff
Arguments:
	hinstDll - dll module instance
Return Value:
	None	
*******************************************************************
--*/
VOID
DbgInitialize (
	HINSTANCE  	hinstDLL
	);

/*++
*******************************************************************
		D b g S t o p
Routine Description:
	Cleanup debugging support stuff
Arguments:
	None
Return Value:
	None	
*******************************************************************
--*/
VOID
DbgStop (
	void
	);
	


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\lpcmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\lpcmgr.h

Abstract:

	Header for SAP LPC manager

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#ifndef _SAP_LPCMGR_
#define _SAP_LPCMGR_

#include "nwsap.h"
#include "saplpc.h"


	// LPC parameters associated with LPC request
typedef struct _LPC_PARAM_BLOCK {
	HANDLE					client;	// Client context
	PNWSAP_REQUEST_MESSAGE	request;// Request block 
	} LPC_PARAM_BLOCK, *PLPC_PARAM_BLOCK;


/*++
*******************************************************************
		I n i t i a l i z e L P C S t u f f

Routine Description:
	Allocates resources neccessary to implement LPC interface
Arguments:
	None
Return Value:
	NO_ERROR - port was created OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
InitializeLPCStuff (
	void
	);

/*++
*******************************************************************
		S t a r t L P C

Routine Description:
	Start SAP LPC interface
Arguments:
	None
Return Value:
	NO_ERROR - LPC interface was started OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
StartLPC (
	void
	);

/*++
*******************************************************************
		S h u t d o w n L P C

Routine Description:
	Shuts SAP LPC interface down, closes all active sessions
Arguments:
	None
Return Value:
	NO_ERROR - LPC interface was shutdown OK
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
ShutdownLPC (
	void
	);

/*++
*******************************************************************
		D e l e t e L P C S t u f f

Routine Description:
	Disposes of resources allocated for LPC interface
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
DeleteLPCStuff (
	void
	);



/*++
*******************************************************************
		P r o c e s s L P C R e q u e s t s

Routine Description:
	Waits for requests on LPC port and processes them
	Client requests that require additional processing by other SAP
	components are enqued into completion queue.
	This routine returns only when it encounters a request that requires
	additional processing or when error occurs
Arguments:
	lreq - LPC parameter block to be filled and posted to completions queue
Return Value:
	NO_ERROR - LPC request was received and posted to completio queue
	other - operation failed (LPC supplied error code)
*******************************************************************
--*/
DWORD
ProcessLPCRequests (
	PLPC_PARAM_BLOCK		item
	);


/*++
*******************************************************************
		S e n d L P C R e p l y

Routine Description:
	Send reply for LPC request
Arguments:
	client - context associated with client to reply to
	request - request to which to reply
	reply - reply to send
Return Value:
	NO_ERROR - LPC reply was sent OK
	other - operation failed (LPC supplied error code)
*******************************************************************
--*/
DWORD
SendLPCReply (
	HANDLE					client,
	PNWSAP_REQUEST_MESSAGE	request,
	PNWSAP_REPLY_MESSAGE	reply
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapdebug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapdebug.c

Abstract:

	This module provides debugging support for SAP agent
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

DWORD	RouterTraceID=INVALID_TRACEID;
HANDLE  RouterEventLogHdl=NULL;
DWORD   EventLogMask;


/*++
*******************************************************************
		D b g I n i t i a l i z e
Routine Description:
	Initializes debugging support stuff
Arguments:
	hinstDll - dll module instance
Return Value:
	None	
*******************************************************************
--*/
VOID
DbgInitialize (
	HINSTANCE  	hinstDLL
	) {
	RouterTraceID = TraceRegisterExA ("IPXSAP", 0);
    RouterEventLogHdl = RouterLogRegisterA ("IPXSAP");
	}


/*++
*******************************************************************
		D b g S t o p
Routine Description:
	Cleanup debugging support stuff
Arguments:
	None
Return Value:
	None	
*******************************************************************
--*/
VOID
DbgStop (
	void
	) {
    if (RouterTraceID!=INVALID_TRACEID)
	    TraceDeregisterA (RouterTraceID);
    if (RouterEventLogHdl!=NULL)
        RouterLogDeregisterA (RouterEventLogHdl);
	}

/*++
*******************************************************************
		T r a c e
Routine Description:
	Printf debugging info to console/file/debugger
Arguments:
	None
Return Value:
	None	
*******************************************************************
--*/
VOID
Trace (
	DWORD	componentID,
	CHAR	*format,
	...
	) {
    if (RouterTraceID!=INVALID_TRACEID) {
	    va_list		list;
	    va_start (list, format);

	    TraceVprintfExA (RouterTraceID,
							     componentID^TRACE_USE_MASK,
							     format,
							     list);
	    va_end (list);
        }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\routerif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\routerif.c

Abstract:

	SAP interface with router (APIs for protocol dll under 
	NT/Cairo router, SNMP MIB support, IPX Service Table Manager)

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

DWORD					    (WINAPI *MIBEntryGet)(
					            IN      DWORD           dwRoutingPid,
								IN      DWORD           dwInEntrySize,
								IN      LPVOID          lpInEntry,
								IN OUT  LPDWORD         lpOutEntrySize,
								OUT     LPVOID          lpOutEntry);



/*++
*******************************************************************
	S T A R T _ P R O T O C O L _  E N T R Y _ P O I N T
Routine Description:
	Starts sap agent
Arguments:
	NotificationEvent - this event will be used to notify router manager
				of completion of lengthly operation
	GlobalInfo - empty
Return Value:
	NO_ERROR - SAP agent was started OK
	ERROR_CAN_NOT_COMPLETE - operation can not be completed
	ERROR_INVALID_PARAMETER - one or more parameters are invalid
	
*******************************************************************
--*/
DWORD WINAPI
StartProtocol(
	IN HANDLE 	NotificationEvent,
    IN PSUPPORT_FUNCTIONS SupportFunctions,
    IN LPVOID   GlobalInfo
	) {
#define sapGlobalInfo ((PSAP_GLOBAL_INFO)GlobalInfo)
    DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if (!RouterIfActive) {
		RouterIfActive = TRUE;
        EventLogMask = sapGlobalInfo->EventLogMask;
		status = CreateResultQueue (NotificationEvent);
		if (status==NO_ERROR) {
			if (!ServiceIfActive) {
				status = CreateAllComponents (NotificationEvent);
				if (status==NO_ERROR) {
                    status = StartSAP ();
					if (status==NO_ERROR) {
						MIBEntryGet = SupportFunctions->MIBEntryGet; 
						status = NO_ERROR;
						goto Success;
						}
					DeleteAllComponents ();
					}
				}
			else {
				StopInterfaces ();
				StopSAP ();
				MIBEntryGet = SupportFunctions->MIBEntryGet;
				goto Success;
				}
			}
		else
			status = ERROR_CAN_NOT_COMPLETE;
        RouterIfActive = FALSE;
		}
	else {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" SAP is already running.",
							__FILE__, __LINE__);
		status = ERROR_CAN_NOT_COMPLETE;
		}

Success:
	LeaveCriticalSection (&OperationalStateLock);
	return status;
#undef sapGlobalInfo
	}



/*++
*******************************************************************
	G E T _ G L O B A L _ I N F O _ E N T R Y _ P O I N T
Routine Description:
	Gets SAP global filter info
Arguments:
	GlobalInfo - buffer to receive global info
	GlobalInfoSize - on input: size of the buffer
					on output: size of global info or size of the
						required buffer if ERROR_INSUFFICIENT_BUFFER
						is returned
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	ERROR_INSUFFICIENT_BUFFER 
	
*******************************************************************
--*/

DWORD WINAPI
GetGlobalInfo(
	IN  PVOID 		GlobalInfo,
	IN OUT PULONG	GlobalInfoSize
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
        if ((*GlobalInfoSize>=sizeof (SAP_GLOBAL_INFO))
                && (GlobalInfo!=NULL)) {
            #define sapGlobalInfo ((PSAP_GLOBAL_INFO)GlobalInfo)
            sapGlobalInfo->EventLogMask = EventLogMask;
            #undef sapGlobalInfo
        }
		*GlobalInfoSize = sizeof (SAP_GLOBAL_INFO);
		status = NO_ERROR;
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	S E T _ G L O B A L _ I N F O _ E N T R Y _ P O I N T
Routine Description:
	Sets SAP global filter info
Arguments:
	GlobalInfo - buffer with receive global info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
SetGlobalInfo(
	IN  PVOID 		GlobalInfo
	) {
#define sapGlobalInfo ((PSAP_GLOBAL_INFO)GlobalInfo)
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
        EventLogMask = sapGlobalInfo->EventLogMask;
		status = NO_ERROR;
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
#undef sapGlobalInfo
	}

/*++
*******************************************************************
		S T O P _ P R O T O C O L _ E N T R Y _ P O I N T
Routine Description:
	Shutdown SAP agent
Arguments:
	None
Return Value:
	NO_ERROR - SAP agent was stopped OK
	ERROR_STOP_PENDING - for asynchronous completion.
	
*******************************************************************
--*/
DWORD WINAPI
StopProtocol(
	void
	) {
	DWORD	status;
	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_STOPPING) {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" SAP is stopping already.",
							__FILE__, __LINE__);
		status = ERROR_PROTOCOL_STOP_PENDING;
		}

	else if (OperationalState==OPER_STATE_DOWN) {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" SAP already stopped or not started.",
							__FILE__, __LINE__);
		status = NO_ERROR;
		}
	else if (!RouterIfActive) {
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" Router interface is not active.",
							__FILE__, __LINE__);
		status = ERROR_CAN_NOT_COMPLETE;
		}
	else {
		RouterIfActive = FALSE;
		StopSAP ();
		status = ERROR_PROTOCOL_STOP_PENDING;
		}
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}
	
/*++
*******************************************************************
		G E T _ E V E N T _ M  E S S A G E _ E N T R Y _ P O I N T
Routine Description:
	Dequeues message associated with completion of asynchronous
	operation signalled by notification event
Arguments:
	Event  - buffer to store event id that produced this message
	Result - buffer to store results specific to completed operation
Return Value:
	NO_ERROR
	ERROR_NO_MORE_ITEMS - no more messages in the queue to report
	
*******************************************************************
--*/
DWORD WINAPI
GetEventMessage(
	OUT ROUTING_PROTOCOL_EVENTS *Event,
	OUT MESSAGE					*Result
	) {
	DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if ((OperationalState==OPER_STATE_UP)
			|| (OperationalState==OPER_STATE_STOPPING)
			|| (OperationalState==OPER_STATE_STARTING)
			)
		status = SapGetEventResult (Event, Result);
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	A D D _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Add interface to sap interface table
Arguments:
	InterfaceIndex - unique number identifying interface to add
	InterfacInfo - interface parameters
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	
*******************************************************************
--*/
DWORD WINAPI 
AddInterface(
    IN LPWSTR       InterfaceName,
	IN ULONG		InterfaceIndex,
	IN NET_INTERFACE_TYPE	InterfaceType,
	IN PVOID		InterfaceInfo
	) {
#define sapInfo (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfInfo)
#define sapFilters (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfFilters)
	DWORD		status;
	UNREFERENCED_PARAMETER(InterfaceType);

	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
		status = SapCreateSapInterface (
                    InterfaceName,
					InterfaceIndex,
					InterfaceType,
					sapInfo);
		if ((status==NO_ERROR)
				&& ((sapFilters->SupplyFilterCount
					+sapFilters->ListenFilterCount)>0))
			status = SapSetInterfaceFilters (InterfaceIndex, sapFilters);

		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
				break;
			case ERROR_ALREADY_EXISTS:
				status = ERROR_INVALID_PARAMETER;
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	
	LeaveCriticalSection (&OperationalStateLock);
	return status;
#undef sapIfInfo
#undef sapIfFilters
	}


/*++
*******************************************************************
		D E L E T E _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Deletes interface from sap interface table and associated services
	from sap service table
Arguments:
	InterfaceIndex - unique number identifying interface to delete
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	
*******************************************************************
--*/
DWORD WINAPI 
DeleteInterface(
	IN ULONG	InterfaceIndex
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapDeleteSapInterface (InterfaceIndex);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_NO_MORE_ITEMS:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}



/*++
*******************************************************************
G E T _ I N T E R F A C E _ C O N F I G _ I N F O _ E N T R Y _ P O I N T
Routine Description:
	Gets interface configuration info from sap interface table
Arguments:
	InterfaceIndex - unique index identifying interface to get info
	InterfaceInfo - buffer to receive interface info
	InterfaceInfoSize - on input: size of the buffer
					on output: size of interface info or size of the
						required buffer if ERROR_INSUFFICIENT_BUFFER
						is returned
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	ERROR_INSUFFICIENT_BUFFER 
	
*******************************************************************
--*/
DWORD WINAPI
GetInterfaceConfigInfo(
	IN ULONG	    InterfaceIndex,
	IN PVOID	    InterfaceInfo,
	IN OUT PULONG	InterfaceInfoSize
	) {
#define sapInfo (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfInfo)
#define sapFilters (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfFilters)
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		if (*InterfaceInfoSize>=sizeof(SAP_IF_INFO)) {
			*InterfaceInfoSize -= sizeof (SAP_IF_INFO);
			status = SapGetSapInterface (InterfaceIndex,
							sapInfo,
							NULL);
			if (status==NO_ERROR)
				status = SapGetInterfaceFilters (InterfaceIndex,
										sapFilters,
										InterfaceInfoSize);
			switch (status) {
				case NO_ERROR:
				case ERROR_INVALID_PARAMETER:
				case ERROR_CAN_NOT_COMPLETE:
				case ERROR_INSUFFICIENT_BUFFER:
					break;
				default:
					status = ERROR_CAN_NOT_COMPLETE;
				}
			}
		else {
			*InterfaceInfoSize = 0;
			status = SapGetInterfaceFilters (InterfaceIndex,
										NULL, InterfaceInfoSize);
			if (status==NO_ERROR)
				status = ERROR_INSUFFICIENT_BUFFER;
			}
		*InterfaceInfoSize += sizeof (SAP_IF_INFO);
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	
	LeaveCriticalSection (&OperationalStateLock);
	return status;
#undef sapIfInfo
#undef sapIfFilters
	}

/*++
*******************************************************************
S E T _ I N T E R F A C E _ C O N F I G _ I N F O _ E N T R Y _ P O I N T
Routine Description:
	Sets interface configuration  info in sap interface table
Arguments:
	InterfaceIndex - unique index identifying interface to get info
	InterfaceInfo - buffer with interface info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
SetInterfaceConfigInfo(
	IN ULONG	    InterfaceIndex,
	IN PVOID	    InterfaceInfo
	) {
#define sapInfo (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfInfo)
#define sapFilters (&((PSAP_IF_CONFIG)InterfaceInfo)->SapIfFilters)
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapSetSapInterface (InterfaceIndex, sapInfo);
		if (status==NO_ERROR)
			status = SapSetInterfaceFilters (InterfaceIndex, sapFilters);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_NO_MORE_ITEMS:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	
	LeaveCriticalSection (&OperationalStateLock);
	return status;
#undef sapIfInfo
#undef sapIfFilters
	}

/*++
*******************************************************************
	B I N D _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Activates sap interface and binds it to the adapter
	Start SAP if interface is configured for standart update mode
Arguments:
	InterfaceIndex - unique index identifying interface to activate
	BindingInfo - bound adpater info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
BindInterface(
	IN ULONG	InterfaceIndex,
	IN PVOID	BindingInfo
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapBindSapInterfaceToAdapter (InterfaceIndex,
						(PIPX_ADAPTER_BINDING_INFO)BindingInfo);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_NO_MORE_ITEMS:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	U N B I N D _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Deactivates sap interface and unbinds it to the adapter
	Stops SAP on interface and deletes all services obtained
	through SAP on this interface form the service table
Arguments:
	InterfaceIndex - unique index identifying interface to deactivate
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
UnbindInterface(
	IN ULONG	InterfaceIndex
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapUnbindSapInterfaceFromAdapter (InterfaceIndex);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_NO_MORE_ITEMS:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}


/*++
*******************************************************************
	E N A B L E _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Reenables SAP operation over the interface
Arguments:
	InterfaceIndex - unique index identifying interface to deactivate
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
EnableInterface(
	IN ULONG	InterfaceIndex
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapSetInterfaceEnable (InterfaceIndex, TRUE);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	D I S A B L E _ I N T E R F A C E _ E N T R Y _ P O I N T
Routine Description:
	Disables SAP operation over the interface
Arguments:
	InterfaceIndex - unique index identifying interface to deactivate
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
DisableInterface(
	IN ULONG	InterfaceIndex
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapSetInterfaceEnable (InterfaceIndex, FALSE);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	D O _ U P D A T E _ S E R V I C E S _ E N T R Y _ P O I N T
Routine Description:
	Initiates update of services information over the interface
	Completion of this update will be indicated by signalling
	NotificationEvent passed at StartProtocol.  GetEventMessage
	can be used then to get the results of autostatic update
Arguments:
	InterfaceIndex - unique index identifying interface to do
		update on
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER
	
*******************************************************************
--*/
DWORD WINAPI
UpdateServices(
	IN ULONG	InterfaceIndex
	) {
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		status = SapRequestUpdate (InterfaceIndex);
		switch (status) {
			case NO_ERROR:
			case ERROR_INVALID_PARAMETER:
			case ERROR_CAN_NOT_COMPLETE:
				break;
			default:
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}


/*++
*******************************************************************
	M I B _ C R E A T E _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to create entries in SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of sap interface info
	InputData - SAP interface info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	
*******************************************************************
--*/
DWORD WINAPI
MibCreate(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData
	) {
	return ERROR_CAN_NOT_COMPLETE;
	}

/*++
*******************************************************************
	M I B _ D E L E T E _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to delete entries in SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of sap interface info
	InputData - SAP interface info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	
*******************************************************************
--*/
DWORD WINAPI 
MibDelete(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData
	) {
#define sapInputData ((PSAP_MIB_SET_INPUT_DATA)InputData)
	DWORD		status;

	if (InputDataSize!=sizeof (SAP_MIB_SET_INPUT_DATA))
		return ERROR_INVALID_PARAMETER;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		switch (sapInputData->TableId) {
			case SAP_INTERFACE_TABLE:
				status = SapDeleteSapInterface (
							sapInputData->SapInterface.InterfaceIndex);
				switch (status) {
					case NO_ERROR:
					case ERROR_INVALID_PARAMETER:
						break;
					case ERROR_ALREADY_EXISTS:
						status = ERROR_INVALID_PARAMETER;
						break;
					default:
						status = ERROR_CAN_NOT_COMPLETE;
					}
				break;
			default:
				status = ERROR_INVALID_PARAMETER;
				break;
				
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
#undef sapInputData
	return status;
	}

/*++
*******************************************************************
	M I B _ S E T _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to set entries in SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of sap interface info
	InputData - SAP interface info
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	
*******************************************************************
--*/
DWORD WINAPI 
MibSet(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData
	) {
#define sapInputData ((PSAP_MIB_SET_INPUT_DATA)InputData)
	DWORD		status;

	if (InputDataSize!=sizeof (SAP_MIB_SET_INPUT_DATA))
		return ERROR_INVALID_PARAMETER;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		switch (sapInputData->TableId) {
			case SAP_INTERFACE_TABLE:
				status = SapSetSapInterface (
							sapInputData->SapInterface.InterfaceIndex,
							&sapInputData->SapInterface.SapIfInfo);
				switch (status) {
					case NO_ERROR:
					case ERROR_INVALID_PARAMETER:
						break;
					case ERROR_ALREADY_EXISTS:
						status = ERROR_INVALID_PARAMETER;
						break;
					default:
						status = ERROR_CAN_NOT_COMPLETE;
					}
				break;
			default:
				status = ERROR_INVALID_PARAMETER;
				break;
				
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
#undef sapInputData
	return status;
	}

/*++
*******************************************************************
	M I B _ G E T _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to get entries from SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of SAP_MIB_GET_INPUT_DATA
	InputData - SAP mib get input data
	OutputDataSize - on input: size of the output buffer
					on output : size of output info or required
						size of output buffer
						if ERROR_INSUFFICIENT_BUFFER returned
	OutputData - buffer to receive output data
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	ERROR_INSUFFICIENT_BUFFER
	
*******************************************************************
--*/
DWORD WINAPI 
MibGet(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData,
	IN OUT PULONG	OutputDataSize,
	OUT PVOID		OutputData
	) {
#define sapInputData ((PSAP_MIB_GET_INPUT_DATA)InputData)
	DWORD		status;

	if (InputDataSize!=sizeof (SAP_MIB_GET_INPUT_DATA))
		return ERROR_INVALID_PARAMETER;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		switch (sapInputData->TableId) {
			case SAP_BASE_ENTRY:
				if (*OutputDataSize>=sizeof (SAP_MIB_BASE)) {
					#define sapOutputData ((PSAP_MIB_BASE)OutputData)
					
					sapOutputData->SapOperState = OperationalState;
					status = NO_ERROR;
					
					#undef sapOutputData
					}
				else
					status = ERROR_INSUFFICIENT_BUFFER;
				*OutputDataSize = sizeof (SAP_MIB_BASE);
				break;

			case SAP_INTERFACE_TABLE:
				if (*OutputDataSize>=sizeof (SAP_INTERFACE)) {
					#define sapOutputData ((PSAP_INTERFACE)OutputData)
					
					status = SapGetSapInterface (
								sapInputData->InterfaceIndex,
								&sapOutputData->SapIfInfo,
								&sapOutputData->SapIfStats);
					switch (status) {
						case NO_ERROR:
							sapOutputData->InterfaceIndex 
								= sapInputData->InterfaceIndex;
                                                        break;
						case ERROR_INVALID_PARAMETER:
							break;
						case ERROR_ALREADY_EXISTS:
							status = ERROR_INVALID_PARAMETER;
							break;
						default:
							status = ERROR_CAN_NOT_COMPLETE;
						}

					#undef sapOutputData
					}
				else
					status = ERROR_INSUFFICIENT_BUFFER;
				*OutputDataSize = sizeof (SAP_INTERFACE);
				break;
			default:
				status = ERROR_INVALID_PARAMETER;
				break;
				
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
#undef sapInputData
	return status;
	}

/*++
*******************************************************************
	M I B _ G E T _ F I R S T _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to get first entries from SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of SAP_MIB_GET_INPUT_DATA
	InputData - SAP mib get input data
	OutputDataSize - on input: size of the output buffer
					on output : size of output info or required
						size of output buffer
						if ERROR_INSUFFICIENT_BUFFER returned
	OutputData - buffer to receive output data
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	ERROR_INSUFFICIENT_BUFFER
	
*******************************************************************
--*/
DWORD  WINAPI
MibGetFirst(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData,
	IN OUT PULONG	OutputDataSize,
	OUT PVOID		OutputData
	) {
#define sapInputData ((PSAP_MIB_GET_INPUT_DATA)InputData)
	DWORD		status;

	if (InputDataSize!=sizeof (SAP_MIB_GET_INPUT_DATA))
		return ERROR_INVALID_PARAMETER;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		switch (sapInputData->TableId) {
			case SAP_INTERFACE_TABLE:
				if (*OutputDataSize>=sizeof (SAP_INTERFACE)) {
					#define sapOutputData ((PSAP_INTERFACE)OutputData)
					
					status = SapGetFirstSapInterface (
								&sapOutputData->InterfaceIndex,
								&sapOutputData->SapIfInfo,
								&sapOutputData->SapIfStats);
					switch (status) {
						case NO_ERROR:
						case ERROR_INVALID_PARAMETER:
						case ERROR_NO_MORE_ITEMS:
							break;
						default:
							status = ERROR_CAN_NOT_COMPLETE;
							break;
						}

					#undef sapOutputData
					}
				else
					status = ERROR_INSUFFICIENT_BUFFER;
				*OutputDataSize = sizeof (SAP_INTERFACE);
				break;
			default:
				status = ERROR_INVALID_PARAMETER;
				break;
				
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
#undef sapInputData
	return status;
	}

/*++
*******************************************************************
	M I B _ G E T _ N E X T _ E N T R Y _ P O I N T
Routine Description:
	Entry point used by SNMP agent to get next entries from SAP
	tables.  Currently the only table supported is Interface Table
	(service table is accessed through router manager)
Arguments:
	InputDataSize - must be size of SAP_MIB_GET_INPUT_DATA
	InputData - SAP mib get input data
	OutputDataSize - on input: size of the output buffer
					on output : size of output info or required
						size of output buffer
						if ERROR_INSUFFICIENT_BUFFER returned
	OutputData - buffer to receive output data
Return Value:
	NO_ERROR
	ERROR_CAN_NOT_COMPLETE
	ERROR_INVALID_PARAMETER 
	ERROR_INSUFFICIENT_BUFFER
	
*******************************************************************
--*/
DWORD WINAPI 
MibGetNext(
	IN ULONG 		InputDataSize,
	IN PVOID 		InputData,
	IN OUT PULONG	OutputDataSize,
	OUT PVOID		OutputData
	) {
#define sapInputData ((PSAP_MIB_GET_INPUT_DATA)InputData)
	DWORD		status;

	if (InputDataSize!=sizeof (SAP_MIB_GET_INPUT_DATA))
		return ERROR_INVALID_PARAMETER;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		switch (sapInputData->TableId) {
			case SAP_INTERFACE_TABLE:
				if (*OutputDataSize>=sizeof (SAP_INTERFACE)) {
					#define sapOutputData ((PSAP_INTERFACE)OutputData)
					sapOutputData->InterfaceIndex 
							= sapInputData->InterfaceIndex;
					status = SapGetNextSapInterface (
								&sapOutputData->InterfaceIndex,
								&sapOutputData->SapIfInfo,
								&sapOutputData->SapIfStats);
					switch (status) {
						case NO_ERROR:
						case ERROR_INVALID_PARAMETER:
						case ERROR_NO_MORE_ITEMS:
							break;
						default:
							status = ERROR_CAN_NOT_COMPLETE;
							break;
						}

					#undef sapOutputData
					}
				else
					status = ERROR_INSUFFICIENT_BUFFER;
				*OutputDataSize = sizeof (SAP_INTERFACE);
				break;
			default:
				status = ERROR_INVALID_PARAMETER;
				break;
				
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
#undef sapInputData
	return status;
	}


DWORD WINAPI
MibSetTrapInfo(
	IN HANDLE   Event,
	IN ULONG	InputDataSize,
	IN PVOID	InputData,
	OUT PULONG	OutputDataSize,
	OUT PVOID	OutputData
	) {
	return ERROR_CAN_NOT_COMPLETE;
	}

DWORD WINAPI
MibGetTrapInfo(
	IN ULONG	InputDataSize,
	IN PVOID	InputData,
	OUT PULONG	OutputDataSize,
	OUT PVOID	OutputData
	) {
	return ERROR_CAN_NOT_COMPLETE;
	}




/*++
*******************************************************************
	C R E A T E _ S T A T I C _ S E R V I C E _ E N T R Y _ P O I N T

Routine Description:
	Adds service of IPX_PROTOCOL_STATIC to the table
Arguments:
	InterfaceIndex - interface on which this server can be reached
	ServiceEntry - server info
Return Value:
	NO_ERROR - server was added ok
	ERROR_CAN_NOT_COMPLETE - SAP agent is down
	other - windows error code

*******************************************************************
--*/
DWORD WINAPI
CreateStaticService(
	IN ULONG						InterfaceIndex,
	IN PIPX_STATIC_SERVICE_INFO		ServiceEntry
	) {
	DWORD				status;
	IPX_SERVER_ENTRY_P	Server;
	IpxServerCpy (&Server, ServiceEntry);

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
        SAP_IF_STATS    ifStats;
        status = SapGetSapInterface (InterfaceIndex, NULL, &ifStats);
        if (status==NO_ERROR) {
		    status = UpdateServer (&Server,
                            InterfaceIndex,
						    IPX_PROTOCOL_STATIC,
                            INFINITE,
                            IPX_BCAST_NODE,
                            (ifStats.SapIfOperState!=OPER_STATE_DOWN)
                                ? 0
                                : SDB_DISABLED_NODE_FLAG,
                            NULL);
            }
        }
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
	D E L E T E _ S T A T I C _ S E R V I C E _ E N T R Y _ P O I N T

Routine Description:
	Deletes service of IPX_PROTOCOL_STATIC from the table
Arguments:
	InterfaceIndex - interface on which this server can be reached
	ServiceEntry - server info
Return Value:
	NO_ERROR - service was deleted ok
	ERROR_CAN_NOT_COMPLETE - SAP agent is down
	other - windows error code

*******************************************************************
--*/
DWORD WINAPI
DeleteStaticService(
	IN ULONG 						InterfaceIndex,
	IN PIPX_STATIC_SERVICE_INFO		ServiceEntry
	) {
	DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		IPX_SERVER_ENTRY_P Server;
		IpxServerCpy (&Server, ServiceEntry);	// Make local copy
		Server.HopCount = IPX_MAX_HOP_COUNT;	// because we need to change
												// one of the fields
		status = UpdateServer (&Server, InterfaceIndex,
					IPX_PROTOCOL_STATIC, INFINITE, IPX_BCAST_NODE, 0, NULL);
		}
	else 
		status = ERROR_CAN_NOT_COMPLETE;
		
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}


/*++
*******************************************************************
B L O C K _ D E L E T E _ S T A T I C _ S E R V I C E S _ E N T R Y _ P O I N T

Routine Description:
	Delete all services of IPX_PROTOCOL_STATIC
	associated with  given interface from the table
Arguments:
	InterfaceIndex - interface index of interest
Return Value:
	NO_ERROR - service was deleted ok
	ERROR_CAN_NOT_COMPLETE - SAP agent is down
	other - windows error code

*******************************************************************
--*/
DWORD WINAPI
BlockDeleteStaticServices(
	IN ULONG 						InterfaceIndex
	) {
	DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		HANDLE	enumHdl = NULL;

		enumHdl = CreateListEnumerator (
									SDB_INTF_LIST_LINK,
									0xFFFF,
									NULL,
									InterfaceIndex,
									IPX_PROTOCOL_STATIC,
									SDB_DISABLED_NODE_FLAG);
		if (enumHdl!=NULL) {
			EnumerateServers (enumHdl, DeleteAllServersCB, enumHdl);
			status = GetLastError ();
			DeleteListEnumerator (enumHdl);
			}
		else
			status = ERROR_CAN_NOT_COMPLETE;
		}
	else 
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}


/*++
*******************************************************************
B L O C K _ C O N V E R T _ S E R V I C E S _ T O _ S T A T I C _ ENTRY_POINT

Routine Description:
	Converts protocol iof all services associated with given interface to
	IPX_PROTOCOL_STATIC
Arguments:
	InterfaceIndex - interface index of interest
Return Value:
	NO_ERROR - service was deleted ok
	ERROR_CAN_NOT_COMPLETE - SAP agent is down
	other - windows error code

*******************************************************************
--*/
DWORD WINAPI
BlockConvertServicesToStatic(
	IN ULONG 						InterfaceIndex
	) {
	DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		HANDLE	enumHdl = NULL;

		enumHdl = CreateListEnumerator (
									SDB_INTF_LIST_LINK,
									0xFFFF,
									NULL,
									InterfaceIndex,
									0xFFFFFFFF,
									0);
		if (enumHdl!=NULL) {
			EnumerateServers (enumHdl, ConvertToStaticCB, enumHdl);
			status = GetLastError ();
			DeleteListEnumerator (enumHdl);
			}
		else
			status = ERROR_CAN_NOT_COMPLETE;
		}
	else 
		status = ERROR_CAN_NOT_COMPLETE;

	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}


/*++
*******************************************************************
		I S _ S E R V I C E _ E N T R Y _ P O I N T

Routine Description:
	Check if service with given type and type is in the service table
	and opianally return parameters of best entry for this service
Arguments:
	Type - IPX Service type
	Name - IPX Service name
	Service - buffer that will be filled with the server info
Return Value:
	TRUE	- server was found
	FALSE	- server was not found or operation failed (call GetLastError()
			to find out the reason for failure if any)

*******************************************************************
--*/
BOOL WINAPI
IsService(
      IN USHORT 	Type,
      IN PUCHAR 	Name,
      OUT PIPX_SERVICE	Service OPTIONAL
	) {
	DWORD				status;
	BOOL				res;
	IPX_SERVER_ENTRY_P	Server;
	ULONG				InterfaceIndex;
	ULONG				Protocol;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		res = QueryServer (Type, Name, 
			&Server, &InterfaceIndex, &Protocol, NULL);
		if (res) {
			if (ARGUMENT_PRESENT (Service)) {
				Service->InterfaceIndex = InterfaceIndex;
				Service->Protocol = Protocol;
				IpxServerCpy (&Service->Server, &Server);
				}
			status = NO_ERROR;
			}
		else
			status = GetLastError ();
		}
	else {
		status = ERROR_CAN_NOT_COMPLETE;
		res = FALSE;
		}

	LeaveCriticalSection (&OperationalStateLock);
	SetLastError (status);
	return res;
	}


/*++
*******************************************************************
C R E A T E _ S E R V I C E _ E N U M E R A T I O N_ H A N D L E_ENTRY_POINT

Routine Description:
	Create handle to start enumeration of the services in the STM table.
Arguments:
  	ExclusionFlags - Flags to limit enumeration to certain
                  	 types of servers
	CriteriaService	- Criteria for exclusion flags
Return Value:
	Enumeration handle
	NULL - if operation failed (call GetLastError () to get reason
			failure)
*******************************************************************
--*/
HANDLE WINAPI
CreateServiceEnumerationHandle(
    IN  DWORD			ExclusionFlags,
    IN	PIPX_SERVICE	CriteriaService
    ) {
	HANDLE		handle;
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		INT	idx;
		if (ExclusionFlags & STM_ONLY_THIS_NAME)
			idx = SDB_HASH_TABLE_LINK;
		else if (ExclusionFlags & STM_ONLY_THIS_TYPE)
			idx = SDB_TYPE_LIST_LINK;
		else if (ExclusionFlags & STM_ONLY_THIS_INTERFACE)
			idx = SDB_INTF_LIST_LINK;
		else
			idx = SDB_HASH_TABLE_LINK;

		handle = CreateListEnumerator (idx,
					(USHORT)((ExclusionFlags & STM_ONLY_THIS_TYPE)
						? CriteriaService->Server.Type : 0xFFFF),
					((ExclusionFlags & STM_ONLY_THIS_NAME)
						? CriteriaService->Server.Name : NULL),
					((ExclusionFlags & STM_ONLY_THIS_INTERFACE)
						? CriteriaService->InterfaceIndex
						: INVALID_INTERFACE_INDEX),
					((ExclusionFlags & STM_ONLY_THIS_PROTOCOL)
						? CriteriaService->Protocol : 0xFFFFFFFFL),
					SDB_DISABLED_NODE_FLAG);
		if (handle!=NULL)
			status = NO_ERROR;
		else
			status = GetLastError ();
		}
	else { 
		status = ERROR_CAN_NOT_COMPLETE;
		handle = NULL;
		}
	LeaveCriticalSection (&OperationalStateLock);
	SetLastError (status);
	return handle;
	}

/*++
*******************************************************************
E N U M E R A T E _ G E T _ N E X T _ S E R V I C E _ E N T R Y _ P O I N T

Routine Description:
	Get next service in the enumeration started by
	CreateServiceEnumerationHandle
Arguments:
	EnumerationHandle - Handle that identifies this
                    enumeration
	Service - buffer to place parameters of next service entry
				to be returned by enumeration
Return Value:
	NO_ERROR - next service was placed in provided buffer or
	ERROR_NO_MORE_ITEMS - there are no more services to be
				returned in the enumeration
	ERROR_CAN_NOT_COMPLETE - operation failed.
*******************************************************************
--*/
DWORD WINAPI
EnumerateGetNextService(
    IN  HANDLE			EnumerationHandle,
    OUT PIPX_SERVICE  	Service
    ) {
	DWORD	status;

	EnterCriticalSection (&OperationalStateLock);
	if (OperationalState==OPER_STATE_UP) {
		if (EnumerateServers (EnumerationHandle, GetOneCB, Service))
			status = NO_ERROR;
		else {
			if (GetLastError()==NO_ERROR)
				status = ERROR_NO_MORE_ITEMS;
			else
				status = ERROR_CAN_NOT_COMPLETE;
			}
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}

/*++
*******************************************************************
C L O S E _ S E R V I C E _ E N U M E R A T I O N _ H A N D L E _ENTRY_POINT

Routine Description:
	Frees resources associated with enumeration.
Arguments:
	EnumerationHandle - Handle that identifies this
                    enumeration
Return Value:
	NO_ERROR - operation succeded
	ERROR_CAN_NOT_COMPLETE - operation failed.
*******************************************************************
--*/
DWORD WINAPI
CloseServiceEnumerationHandle(
    IN  HANDLE   EnumerationHandle
    ) {
	DWORD	status;
	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
		DeleteListEnumerator (EnumerationHandle);
		status = NO_ERROR;
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	return status;
	}
/*++
*******************************************************************
	G E T _ F I R S T _ O R D E R E D _ S E R V I C E _ E N T R Y _ P O I N T

Routine Description:
	Find and return first service in the order specified by the ordering method.
	Search is limited only to certain types of services as specified by the
	exclusion flags end corresponding fields in Server parameter.
	Returns ERROR_NO_MORE_ITEMS if there are no services in the
	table that meet specified criteria.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to specified criteria
 	Server - On input: criteria for exclusion flags
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD WINAPI
GetFirstOrderedService(
    IN  DWORD           OrderingMethod,
    IN  DWORD           ExclusionFlags,
    IN OUT PIPX_SERVICE Service
    ) {
	DWORD				status;
	IPX_SERVER_ENTRY_P	Server;
	IpxServerCpy (&Server, &Service->Server);
	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
		status = GetFirstServer (OrderingMethod, ExclusionFlags,
				&Server, &Service->InterfaceIndex, &Service->Protocol);
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	if (status==NO_ERROR)
		IpxServerCpy (&Service->Server, &Server);
	return status;
	}

/*++
*******************************************************************
	G E T _ N E X T _ O R D E R E D _ S E R V I C E _ E N T R Y _ P O I N T
Routine Description:
	Find and return next service in the order specified by the ordering method.
	Search starts from specified service and is limited only to certain types
	of services as specified by the exclusion flags and corresponding fields 
	in Server parameter.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to fields of Server
 	Server - On input server entry from which to compute the next
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD WINAPI
GetNextOrderedService(
    IN  DWORD           OrderingMethod,
    IN  DWORD           ExclusionFlags,
    IN OUT PIPX_SERVICE	Service
    ) {
	DWORD				status;
	IPX_SERVER_ENTRY_P	Server;
	IpxServerCpy (&Server, &Service->Server);

	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
		status = GetNextServer (OrderingMethod, ExclusionFlags, 
				&Server, &Service->InterfaceIndex, &Service->Protocol);
		}
	else
		status = ERROR_CAN_NOT_COMPLETE;
	LeaveCriticalSection (&OperationalStateLock);
	if (status==NO_ERROR)
		IpxServerCpy (&Service->Server, &Server);
	return status;
	}

/*++
*******************************************************************
	G E T _ S E R V I C E _ C O U N T _ E N T R Y _ P O I N T
Routine Description:
	Returns total number of services is the table
Arguments:
	None
Return Value:
	Number of services in the table
*******************************************************************
--*/
ULONG WINAPI WINAPI
GetServiceCount(
	void
	) {
	DWORD	status;
	ULONG	count;
	EnterCriticalSection (&OperationalStateLock);

	if (OperationalState==OPER_STATE_UP) {
		count = ServerTable.ST_ServerCnt;
		status = ERROR_CAN_NOT_COMPLETE;
		}
	else {
		count = 0;
		status = ERROR_CAN_NOT_COMPLETE;
		}
	LeaveCriticalSection (&OperationalStateLock);
	SetLastError (status);
	return count;
	}


DWORD
GetRouteMetric (
	IN UCHAR	Network[4],
	OUT PUSHORT	Metric
	) {
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	IPX_ROUTE				Route;
	DWORD					RtSize;
	DWORD					rc;

	RtSize = sizeof(IPX_ROUTE);
	MibGetInputData.TableId = IPX_DEST_TABLE;
	IpxNetCpy (MibGetInputData.MibIndex.RoutingTableIndex.Network, Network);

	rc = (*MIBEntryGet) (IPX_PROTOCOL_BASE,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&MibGetInputData,
								&RtSize,
								&Route);
	if (rc==NO_ERROR)
		*Metric = Route.TickCount;

	return rc;
}

/*++
*******************************************************************
    R E G I S T E R _ P R O T O C O L _  E N T R Y _ P O I N T
Routine Description:
    Register protocol dll with router manager
    Identifies protocol handled by the dll and supported functionality
Arguments:
    Protocol - buffer to return protocol ID
    SupportedFunctionality - buffer to set flags indicating functionality
            supported by the dll
Return Value:
    NO_ERROR - SAP agent was started OK
    ERROR_CAN_NOT_COMPLETE - operation can not be completed

*******************************************************************
--*/
DWORD WINAPI
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    if(pRoutingChar->dwProtocolId != IPX_PROTOCOL_SAP)
    {
        return ERROR_NOT_SUPPORTED;
    }

    pRoutingChar->fSupportedFunctionality = 0;
    pServiceChar->fSupportedFunctionality = SERVICES|DEMAND_UPDATE_SERVICES;

    pRoutingChar->pfnStartProtocol    = StartProtocol;
    pRoutingChar->pfnStopProtocol     = StopProtocol;
    pRoutingChar->pfnAddInterface     = AddInterface;
    pRoutingChar->pfnDeleteInterface  = DeleteInterface;
    pRoutingChar->pfnGetEventMessage  = GetEventMessage;
    pRoutingChar->pfnGetInterfaceInfo = GetInterfaceConfigInfo;
    pRoutingChar->pfnSetInterfaceInfo = SetInterfaceConfigInfo;
    pRoutingChar->pfnBindInterface    = BindInterface;
    pRoutingChar->pfnUnbindInterface  = UnbindInterface;
    pRoutingChar->pfnEnableInterface  = EnableInterface;
    pRoutingChar->pfnDisableInterface = DisableInterface;
    pRoutingChar->pfnGetGlobalInfo    = GetGlobalInfo;
    pRoutingChar->pfnSetGlobalInfo    = SetGlobalInfo;
    pRoutingChar->pfnMibCreateEntry   = MibCreate;
    pRoutingChar->pfnMibDeleteEntry   = MibDelete;
    pRoutingChar->pfnMibGetEntry      = MibGet;
    pRoutingChar->pfnMibSetEntry      = MibSet;
    pRoutingChar->pfnMibGetFirstEntry = MibGetFirst;
    pRoutingChar->pfnMibGetNextEntry  = MibGetNext;
    pRoutingChar->pfnUpdateRoutes     = NULL;

    pServiceChar->pfnIsService  = IsService;
    pServiceChar->pfnUpdateServices  = UpdateServices;
    pServiceChar->pfnCreateServiceEnumerationHandle = CreateServiceEnumerationHandle;
    pServiceChar->pfnEnumerateGetNextService = EnumerateGetNextService;
    pServiceChar->pfnCloseServiceEnumerationHandle = CloseServiceEnumerationHandle;
    pServiceChar->pfnGetServiceCount = GetServiceCount;
    pServiceChar->pfnCreateStaticService = CreateStaticService;
    pServiceChar->pfnDeleteStaticService = DeleteStaticService;
    pServiceChar->pfnBlockConvertServicesToStatic = BlockConvertServicesToStatic;
    pServiceChar->pfnBlockDeleteStaticServices = BlockDeleteStaticServices;
    pServiceChar->pfnGetFirstOrderedService = GetFirstOrderedService;
    pServiceChar->pfnGetNextOrderedService = GetNextOrderedService;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\saplpc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\saplpc.h

Abstract:

Author:

    Brian Walker (MCS) 06-30-1993

Revision History:

--*/

#ifndef _NWSAP_LPC_
#define _NWSAP_LPC_

/**
    Structure used to pass LPC messages between the client
    library and the main server.  Note the the PORT_MESSAGE is first
    and that the request and reply structures are VERY similar.
**/

typedef struct _NWSAP_REQUEST_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG MessageType;

    union {

        struct {
            USHORT  ServerType;
            UCHAR   ServerName[48];
            UCHAR   ServerAddr[12];
            BOOL    RespondNearest;
        } AdvApi;

        struct {
            ULONG   ObjectID;
            UCHAR   ObjectName[48];
            USHORT  ObjectType;
            UCHAR   ObjectAddr[12];
            USHORT  ScanType;
        } BindLibApi;

    } Message;

} NWSAP_REQUEST_MESSAGE, *PNWSAP_REQUEST_MESSAGE;


typedef struct _NWSAP_REPLY_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG Error;

    union {

        struct {
            USHORT  ServerType;
            UCHAR   ServerName[48];
            UCHAR   ServerAddr[12];
            BOOL    RespondNearest;
        } AdvApi;

        struct {
            ULONG   ObjectID;
            UCHAR   ObjectName[48];
            USHORT  ObjectType;
            UCHAR   ObjectAddr[12];
            USHORT  ScanType;
        } BindLibApi;

    } Message;
} NWSAP_REPLY_MESSAGE, *PNWSAP_REPLY_MESSAGE;

/** Message Types **/

#define NWSAP_LPCMSG_ADDADVERTISE           0
#define NWSAP_LPCMSG_REMOVEADVERTISE        1
#define NWSAP_LPCMSG_GETOBJECTID            2
#define NWSAP_LPCMSG_GETOBJECTNAME          3
#define NWSAP_LPCMSG_SEARCH                 4
#define NWSAP_LPCMSG_STOP                   0xFFFFFFFF

/** Name of our port **/

#define NWSAP_BIND_PORT_NAME_W   L"\\BaseNamedObjects\\NwSapLpcPort"
#define NWSAP_BIND_PORT_NAME_A    "\\BaseNamedObjects\\NwSapLpcPort"

/** Max message length we need **/

#define NWSAP_BS_PORT_MAX_MESSAGE_LENGTH                                         \
    ( sizeof(NWSAP_REQUEST_MESSAGE) > sizeof(NWSAP_REPLY_MESSAGE) ?    \
         sizeof(NWSAP_REQUEST_MESSAGE) : sizeof(NWSAP_REPLY_MESSAGE) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapdefs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapdefs.h

Abstract:

	Constants and data structures common to all SAP files
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_SAPDEFS
#define _SAP_SAPDEFS

extern UCHAR IPX_SAP_SOCKET[2];		// Defined in workers.c

#define IPX_SAP_PACKET_TYPE		4
#define IPX_SAP_MAX_ENTRY		7
#define IPX_MAX_HOP_COUNT		16

// Operations in IPX SAP
#define SAP_GENERAL_REQ			1
#define SAP_GENERAL_RESP		2
#define SAP_GET_NEAREST_REQ		3
#define SAP_GET_NEAREST_RESP	4

// Time constants
	// IPX specific
#define IPX_SAP_INTERPACKET_GAP		55			// msec


// Registry configurable values (defaults and ranges)
#define SAP_SERVICE_REGISTRY_KEY_STR \
	"System\\CurrentControlSet\\Services\\NwSapAgent"
#define SAP_ROUTER_REGISTRY_KEY_STR \
	"System\\CurrentControlSet\\Services\\RemoteAccess\\RouterManagers\\IPX\\RoutingProtocols\\IPXSAP"


// Interval for periodic update broadcasts (for standalone service only)
#define SAP_UPDATE_INTERVAL_DEF				1			// min
#define SAP_UPDATE_INTERVAL_MIN				1
#define SAP_UPDATE_INTERVAL_MAX				30
#define SAP_UPDATE_INTERVAL_STR				"SendTime"		

// Server aging timeout (for standalone service only)
#define SAP_AGING_TIMEOUT_DEF				3			// min
#define SAP_AGING_TIMEOUT_MIN				3
#define SAP_AGING_TIMEOUT_MAX				90
#define SAP_AGING_TIMEOUT_STR				"EntryTimeout"

// Update mode on WAN lines
#define SAP_WAN_NO_UPDATE					0
#define SAP_WAN_CHANGES_ONLY				1
#define SAP_WAN_STANDART_UPDATE				2
#define SAP_WAN_UPDATE_MODE_DEF				SAP_WAN_NO_UPDATE
#define SAP_WAN_UPDATE_MODE_MIN				SAP_WAN_NO_UPDATE
#define SAP_WAN_UPDATE_MODE_MAX				SAP_WAN_STANDART_UPDATE
#define SAP_WAN_UPDATE_MODE_STR				"WANFilter"

// Interval for periodic update broadcasts on WAN lines (for standalone service only)
#define SAP_WAN_UPDATE_INTERVAL_DEF			1			// min
#define SAP_WAN_UPDATE_INTERVAL_MIN			1
#define SAP_WAN_UPDATE_INTERVAL_MAX			30
#define SAP_WAN_UPDATE_INTERVAL_STR			"WANUpdateTime"		

// Max number of pending recv work items
#define SAP_MAX_UNPROCESSED_REQUESTS_DEF	100
#define SAP_MAX_UNPROCESSED_REQUESTS_MIN	10
#define SAP_MAX_UNPROCESSED_REQUESTS_MAX	1000
#define SAP_MAX_UNPROCESSED_REQUESTS_STR	"MaxRecvBufferLookAhead"

// Whether to respond for internal servers that are not registered with SAP
// through the API calls (for standalone service only)
#define SAP_RESPOND_FOR_INTERNAL_DEF		TRUE
#define SAP_RESPOND_FOR_INTERNAL_MIN		FALSE
#define SAP_RESPOND_FOR_INTERNAL_MAX		TRUE
#define SAP_RESPOND_FOR_INTERNAL_STR		"RespondForInternalServers"

// Delay in response to general reguests for specific server type
// if local servers are included in the packet
#define SAP_DELAY_RESPONSE_TO_GENERAL_DEF	0		// msec
#define SAP_DELAY_RESPONSE_TO_GENERAL_MIN	0
#define SAP_DELAY_RESPONSE_TO_GENERAL_MAX	2000
#define SAP_DELAY_RESPONSE_TO_GENERAL_STR	"DelayRespondToGeneral"

// Delay in sending change broadcasts if packet is not full
#define SAP_DELAY_CHANGE_BROADCAST_DEF		3		// sec
#define SAP_DELAY_CHANGE_BROADCAST_MIN		0
#define SAP_DELAY_CHANGE_BROADCAST_MAX		30
#define SAP_DELAY_CHANGE_BROADCAST_STR		"DelayChangeBroadcast"

// Size of heap reserved for the database
#define SAP_SDB_MAX_HEAP_SIZE_DEF			8	// Meg
#define SAP_SDB_MAX_HEAP_SIZE_MIN			1
#define SAP_SDB_MAX_HEAP_SIZE_MAX			32
#define SAP_SDB_MAX_HEAP_SIZE_STR			"NameTableReservedHeapSize"

// Interval with which to update the sorted list
#define SAP_SDB_SORT_LATENCY_DEF			60	// sec
#define SAP_SDB_SORT_LATENCY_MIN			10	
#define SAP_SDB_SORT_LATENCY_MAX			600
#define SAP_SDB_SORT_LATENCY_STR			"NameTableSortLatency"

// Max number of unsorted servers
#define SAP_SDB_MAX_UNSORTED_DEF			16
#define SAP_SDB_MAX_UNSORTED_MIN			1
#define SAP_SDB_MAX_UNSORTED_MAX			100
#define SAP_SDB_MAX_UNSORTED_STR			"MaxUnsortedNames"
	
// How often to check on pending triggered update
#define SAP_TRIGGERED_UPDATE_CHECK_INTERVAL_DEF	10			// sec
#define SAP_TRIGGERED_UPDATE_CHECK_INTERVAL_MIN	3
#define SAP_TRIGGERED_UPDATE_CHECK_INTERVAL_MAX	60
#define SAP_TRIGGERED_UPDATE_CHECK_INTERVAL_STR "TriggeredUpdateCheckInterval"

// How many requests to send if no response received within check interval
#define SAP_MAX_TRIGGERED_UPDATE_REQUESTS_DEF	3
#define SAP_MAX_TRIGGERED_UPDATE_REQUESTS_MIN	1
#define SAP_MAX_TRIGGERED_UPDATE_REQUESTS_MAX	10
#define SAP_MAX_TRIGGERED_UPDATE_REQUESTS_STR	"MaxTriggeredUpdateRequests"

// Time limit for shutdown broadcast
#define SAP_SHUTDOWN_TIMEOUT_DEF			60			// sec
#define SAP_SHUTDOWN_TIMEOUT_MIN			20
#define SAP_SHUTDOWN_TIMEOUT_MAX			180
#define SAP_SHUTDOWN_TIMEOUT_STR			"ShutdownBroadcastTimeout"

// Number of additional recv requests to post when binding the interface
// that has listen enabled
#define SAP_REQUESTS_PER_INTF_DEF			4
#define SAP_REQUESTS_PER_INTF_MIN			1
#define SAP_REQUESTS_PER_INTF_MAX			256
#define SAP_REQUESTS_PER_INTF_STR			"RequestsPerInterface"

// Minimum number of queued recv requests
#define SAP_MIN_REQUESTS_DEF				16
#define SAP_MIN_REQUESTS_MIN				16
#define SAP_MIN_REQUESTS_MAX				2048
#define SAP_MIN_REQUESTS_STR				"MinimumRequests"

// Time to wait before retrying failed operation that should not fail
#define SAP_ERROR_COOL_OFF_TIME	(3*1000)


#define BINDLIB_NCP_SAP				0xC0000000
#define BINDLIB_NCP_MAX_SAP			0xCFFFFFFF


#pragma pack(push, 1)

typedef struct _IPX_ADDRESS_BLOCK {
	UCHAR			Network[4];
	UCHAR			Node[6];
	UCHAR			Socket[2];
	} IPX_ADDRESS_BLOCK, *PIPX_ADDRESS_BLOCK;

	// Packet typedef for server entry
typedef struct _IPX_SERVER_ENTRY_P {
    USHORT			Type;
    UCHAR			Name[48];
    UCHAR			Network[4];
    UCHAR			Node[6];
    UCHAR			Socket[2];
    USHORT			HopCount;
	} IPX_SERVER_ENTRY_P, *PIPX_SERVER_ENTRY_P;

typedef struct _SAP_BUFFER {
	USHORT				Checksum;
	USHORT				Length;
	UCHAR				TransportCtl;
	UCHAR				PacketType;
	IPX_ADDRESS_BLOCK	Dst;
	IPX_ADDRESS_BLOCK	Src;
	USHORT				Operation;
	IPX_SERVER_ENTRY_P	Entries[IPX_SAP_MAX_ENTRY];
	} SAP_BUFFER, *PSAP_BUFFER;

#pragma pack(pop)


// IPX Server Name copy macro
#define IpxNameCpy(dst,src) strncpy(dst,src,48)
// IPX Server Name comparison
#define IpxNameCmp(name1,name2) strncmp(name1,name2,48)

#define IpxNetCpy(dst,src) *((UNALIGNED ULONG *)(dst)) = *((UNALIGNED ULONG *)(src))
#define IpxNetCmp(net1,net2) memcmp(net1,net2,4)

#define IpxNodeCpy(dst,src) memcpy(dst,src,6)
#define IpxNodeCmp(node1,node2) memcmp(node1,node2,6)

#define IpxSockCpy(dst,src) *((UNALIGNED USHORT *)(dst)) = *((UNALIGNED USHORT *)(src))
#define IpxSockCmp(sock1,sock2) memcmp(sock1,sock2,2)

#define IpxAddrCpy(dst,src) {						\
		IpxNetCpy((dst)->Network,(src)->Network);	\
		IpxNodeCpy((dst)->Node,(src)->Node);		\
		IpxSockCpy((dst)->Socket,(src)->Socket);	\
	}

#define IpxServerCpy(dst,src) {						\
		(dst)->Type = (src)->Type;					\
		IpxNameCpy((dst)->Name,(src)->Name);		\
		IpxNetCpy((dst)->Network,(src)->Network);	\
		IpxNodeCpy((dst)->Node,(src)->Node);		\
		IpxSockCpy((dst)->Socket,(src)->Socket);	\
		(dst)->HopCount = (src)->HopCount;			\
	}

// Conversions from/to on-the-wire format
#define GETUSHORT(src) (			\
	(USHORT)(						\
		(((UCHAR *)(src))[0]<<8)	\
		+ (((UCHAR *)(src))[1])		\
	)								\
)

#define GETULONG(src) (				\
	(ULONG)(						\
		(((UCHAR *)(src))[0]<<24)	\
		+ (((UCHAR *)(src))[1]<<16)	\
		+ (((UCHAR *)(src))[2]<<8)	\
		+ (((UCHAR *)(src))[3])		\
	)								\
)

#define PUTUSHORT(src,dst) {					\
	((UCHAR *)(dst))[0] = ((UCHAR)((src)>>8));	\
	((UCHAR *)(dst))[1] = ((UCHAR)(src));		\
}

#define PUTULONG(src,dst) {						\
	((UCHAR *)(dst))[0] = ((UCHAR)((src)>>24));	\
	((UCHAR *)(dst))[1] = ((UCHAR)((src)>>16));	\
	((UCHAR *)(dst))[2] = ((UCHAR)((src)>>8));	\
	((UCHAR *)(dst))[3] = ((UCHAR)(src));		\
}


// Complement macros in ntrtl.h
#define InitializeListEntry(entry) InitializeListHead(entry)
#define IsListEntry(entry)	(!IsListEmpty(entry))

// Time comparison macro that accounts for possible wraparound
// (maximum time difference is MAXULONG/2 msec (21+ days))
#define IsLater(time1,time2) (((time1)-(time2))<MAXULONG/2)

// Fast round to sec macro (it actually rounds to 1024 msec)
#define RoundUpToSec(msecTime) (((msecTime)&0xFFFFFC00)+0x00000400)

// IPX broadcast node number def
extern UCHAR IPX_BCAST_NODE[6];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapp.h

Abstract:

	SAP agent common include file
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#ifdef UNICODE
#define _UNICODE
#include <stdlib.h>
#endif

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "svcs.h"
#include "lmsname.h"


#include "mprerror.h"
#include "mprlog.h"
#include "ipxrtprt.h"
#include "rtutils.h"

#include "stm.h"
#include "ipxconst.h"
#include "ipxrtdef.h"
#include "ipxsap.h"

#include "adapter.h"

#include "sapdefs.h"
#include "sapdebug.h"
#include "syncpool.h"
#include "adaptdb.h"
#include "intfdb.h"
#include "netio.h"
#include "serverdb.h"
#include "timermgr.h"
#include "lpcmgr.h"
#include "asresmgr.h"
#include "filters.h"
#include "workers.h"
#include "sapmain.h"

#include "ipxanet.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapmain.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapmain.h

Abstract:

	Header file for SAP DLL main module and thread container.

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#ifndef _SAP_SAPMAIN_
#define _SAP_SAPMAIN_

// DLL module instance handle
extern HANDLE	hDLLInstance;
// Handle of main thread
extern HANDLE  MainThreadHdl;
// Operational state of sap agent
extern ULONG	OperationalState;
// Operational state lock to protect from external
// calls in bad states
extern CRITICAL_SECTION OperationalStateLock;
// Are we part of a router
extern volatile BOOLEAN Routing;
// Which external API sets are active
extern volatile BOOLEAN ServiceIfActive;
extern volatile BOOLEAN RouterIfActive;
// Time limit for shutdown broadcast
extern ULONG ShutdownTimeout;


DWORD
GetRouteMetric (
	IN UCHAR	Network[4],
	OUT PUSHORT	Metric
	);

#define GetServerMetric(Server,Metric)						\
	((RouterIfActive)										\
		? GetRouteMetric((Server)->Network, (Metric))		\
		: ((*Metric=(Server)->HopCount), NO_ERROR))


/*++
*******************************************************************
		C r e a t e A l l C o m p o n e n t s
Routine Description:
	Calls all sap componenets with initialization call and compiles an
	array of synchronization objects from objects returned from each
	individual component
Arguments:
	None
Return Value:
	NO_ERROR - component initialization was performed OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
CreateAllComponents (
	HANDLE RMNotificationEvent
	);



/*++
*******************************************************************
		D e l e t e A l l C o m p o n e n t s
Routine Description:
	Releases all resources allocated by SAP agent
Arguments:
	None
Return Value:
	NO_ERROR - SAP agent was unloaded OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
DeleteAllComponents (
	void
	);

/*++
*******************************************************************
		S t a r t S A P
Routine Description:
	Starts SAP threads
Arguments:
	None
Return Value:
	NO_ERROR - threads started OK
	other (windows error code) - start failed
*******************************************************************
--*/
DWORD
StartSAP (
	VOID
	);

/*++
*******************************************************************
		S t o p S A P
Routine Description:
	Signals SAP threads to stop
Arguments:
	No used
Return Value:
	None
*******************************************************************
--*/
VOID
StopSAP (
	void
	);

VOID
ScheduleSvcsWorkItem (
	WORKERFUNCTION	*worker
	);
VOID
ScheduleRouterWorkItem (
	WORKERFUNCTION	*worker
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\sapmain.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\sapmain.c

Abstract:

	 SAP DLL main module and thread container.

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"

// Time limit for shutdown broadcast
ULONG	ShutdownTimeout=SAP_SHUTDOWN_TIMEOUT_DEF;
// Indeces of synchronization objects used to control asynchronous
// subsystems of SAP agent

	// Main thread signalling event
#define STOP_EVENT_IDX					0

#define RECV_COMPLETED_IDX				(STOP_EVENT_IDX+1)
	// Timer queue requires attention
#define TIMER_WAKEUP_IDX				(RECV_COMPLETED_IDX+1)

	// Server table aging queue requires processing
#define SERVER_TABLE_TIMER_IDX			(TIMER_WAKEUP_IDX+1)
	// Server table sorted list requires update
#define SERVER_TABLE_UPDATE_IDX			(SERVER_TABLE_TIMER_IDX+1)
	// Adapter change signalled by network driver (for standalone SAP only)
#define ADAPTER_CHG_IDX					(SERVER_TABLE_UPDATE_IDX+1)

	// Number of syncronization objects
#define ROUTING_NUM_OF_OBJECTS			(SERVER_TABLE_UPDATE_IDX+1)
#define STANDALONE_NUM_OF_OBJECTS		(ADAPTER_CHG_IDX+1)
	
#define MAX_OBJECTS						STANDALONE_NUM_OF_OBJECTS



/* Global Data */
// DLL module instance handle
HANDLE	hDLLInstance;

// Handle of main thread
HANDLE  MainThreadHdl;

// Operational state of the agent
ULONG	OperationalState=OPER_STATE_DOWN;
// Lock that protects changes in the state and state transitions
CRITICAL_SECTION OperationalStateLock;
// TRUE between start and stop service calls
volatile BOOLEAN ServiceIfActive=FALSE;
// TRUE between start and stop protocol calls
volatile BOOLEAN RouterIfActive=FALSE;


// TRUE if sap is part of the router, FALSE for standalone SAP agent
// It is computed based on two values above with RouterIfActive having
// precedence.  In stays where it was during transition periods and changes
// only when transition is completed (it can only be changed by the main 
// thread).
volatile BOOLEAN	Routing=FALSE;


/* Local static data */

// Async subsystem synchronization objects
HANDLE	WaitObjects[MAX_OBJECTS] = {NULL};


// Time we will die at when told to shutdown
ULONG	StopTime;


TCHAR   ModuleName[MAX_PATH+1];

// Local prototypes
BOOL WINAPI DllMain(
    HINSTANCE  	hinstDLL,	
    DWORD  		fdwReason,	
    LPVOID  	lpvReserved 
    );


DWORD WINAPI
MainThread (
	LPVOID param
	);

VOID
ReadRegistry (
	VOID
	);

VOID
InitializeResultQueue();
	
/*++
*******************************************************************
		D l l M a i n
Routine Description:
	Dll entry point to be called from CRTstartup dll entry point (it
		will be actually an entry point for this dll)
Arguments:
	hinstDLL - handle of DLL module 
	fdwReason - reason for calling function 
	lpvReserved - reserved 
Return Value:
	TRUE - process initialization was performed OK
	FALSE - intialization failed
	
*******************************************************************
--*/
BOOL WINAPI DllMain(
    HINSTANCE  	hinstDLL,
    DWORD  		fdwReason,
    LPVOID  	lpvReserved 
    ) {
	STARTUPINFO		info;

	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:	// We are being attached to a new process
			hDLLInstance = hinstDLL;
            GetModuleFileName (hinstDLL, ModuleName,
                        sizeof (ModuleName)/sizeof (ModuleName[0]));
			InitializeCriticalSection (&OperationalStateLock);
			InitializeResultQueue();
			return TRUE;

		case DLL_PROCESS_DETACH:	// The process is exiting
			ASSERT (OperationalState==OPER_STATE_DOWN);
			DeleteCriticalSection (&OperationalStateLock);
		default:					// Not interested in all other cases
			return TRUE;
		}

	}


/*++
*******************************************************************
		C r e a t e A l l C o m p o n e n t s
Routine Description:
	Calls all sap componenets with initialization call and compiles an
	array of synchronization objects from objects returned from each
	individual component
Arguments:
	None
Return Value:
	NO_ERROR - component initialization was performed OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
CreateAllComponents (
	HANDLE RMNotificationEvent
	) {
	DWORD		status;

	DbgInitialize (hDLLInstance);
	ReadRegistry ();
	status = CreateServerTable (
					&WaitObjects[SERVER_TABLE_UPDATE_IDX],
					&WaitObjects[SERVER_TABLE_TIMER_IDX]);
	if (status==NO_ERROR) {
		status = IpxSapCreateTimerQueue (&WaitObjects[TIMER_WAKEUP_IDX]);
		if (status==NO_ERROR) {
			status = CreateInterfaceTable ();
			if (status==NO_ERROR) {
				status = CreateIOQueue (&WaitObjects[RECV_COMPLETED_IDX]);
				if (status==NO_ERROR) {
					status = InitializeLPCStuff ();
					if (status==NO_ERROR) {
						status = CreateFilterTable ();
						if (status==NO_ERROR) {
							status = InitializeWorkers (WaitObjects[RECV_COMPLETED_IDX]);
							if (status==NO_ERROR) {
								WaitObjects[STOP_EVENT_IDX] = 
											CreateEvent (NULL,
															FALSE,	//Autoreset
															FALSE,	// non-signalled
															NULL);
								if (WaitObjects[STOP_EVENT_IDX]!=NULL) {

									if (RMNotificationEvent == NULL)
										status = CreateAdapterPort (&WaitObjects[ADAPTER_CHG_IDX]);
									else
										status = CreateResultQueue (RMNotificationEvent);
									if (status==NO_ERROR)
										return NO_ERROR;
									}
								else {
									status = GetLastError ();
									Trace (DEBUG_FAILURES, "File: %s, line %ld."
										" Could not create stop event (gle:%ld).",
													__FILE__, __LINE__, status);
									}
								DeleteWorkers ();
								}
							DeleteFilterTable ();
							}
						DeleteLPCStuff();
						}
					DeleteIOQueue ();
					}
				DeleteInterfaceTable ();
				}
			IpxSapDeleteTimerQueue ();
			}
		DeleteServerTable ();
		}
	return status;
	}



/*++
*******************************************************************
		D e l e t e A l l C o m p o n e n t s
Routine Description:
	Releases all resources allocated by SAP agent
Arguments:
	None
Return Value:
	NO_ERROR - SAP agent was unloaded OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
DeleteAllComponents (
	void
	) {
	UINT			i;
	DWORD		status;

	EnterCriticalSection (&OperationalStateLock);
	OperationalState = OPER_STATE_DOWN;
	LeaveCriticalSection (&OperationalStateLock);
		// Stop now
	StopTime = GetTickCount ();

	CloseHandle (WaitObjects[STOP_EVENT_IDX]);
	DeleteFilterTable ();
	DeleteLPCStuff ();
	DeleteIOQueue ();
	DeleteInterfaceTable ();
	IpxSapDeleteTimerQueue ();
	DeleteServerTable ();
	DeleteWorkers ();
	DbgStop ();
	return NO_ERROR;
	}

/*++
*******************************************************************
		S t a r t S A P
Routine Description:
	Starts SAP threads
Arguments:
	None
Return Value:
	NO_ERROR - threads started OK
	other (windows error code) - start failed
*******************************************************************
--*/
DWORD
StartSAP (
	VOID
	) {
	DWORD	status;

	status = StartLPC ();
	if (status==NO_ERROR) {
		status = StartIO ();
		if (status==NO_ERROR) {
			DWORD	threadID;
			MainThreadHdl = CreateThread (NULL,
											0,
											&MainThread,
											NULL,
											0,
											&threadID);
			if (MainThreadHdl!=NULL) {
				OperationalState = OPER_STATE_UP;
				return NO_ERROR;
				}
			else {
				status = GetLastError ();
				Trace (DEBUG_FAILURES, "File: %s, line %ld."
					" Failed to launch IO thread (gle:%ld).",
							__FILE__, __LINE__, status);
				}
			StopIO ();
			}
		ShutdownLPC ();
		}

	OperationalState = OPER_STATE_DOWN;
	return status;
	}

/*++
*******************************************************************
		S t o p S A P
Routine Description:
	Signals SAP threads to stop
Arguments:
	No used
Return Value:
	None
*******************************************************************
--*/
VOID
StopSAP (
	void
	) {
	BOOL	res;

	OperationalState = OPER_STATE_STOPPING;
	StopTime = GetTickCount ()+ShutdownTimeout*1000;
	res = SetEvent (WaitObjects[STOP_EVENT_IDX]);
	ASSERTERRMSG ("Could not set stop event in StopSAP ", res);
	}


/*++
*******************************************************************
		R e s u l t R e t r e i v e d C B
Routine Description:
	Async result manager call back routine that signals IO thread when
	stop message is retreived by router manager
Arguments:
	No used
Return Value:
	None
*******************************************************************
--*/
VOID
ResultRetreivedCB (
	PAR_PARAM_BLOCK rslt
	) {
	BOOL res;
	UNREFERENCED_PARAMETER(rslt);
	res = SetEvent (WaitObjects[STOP_EVENT_IDX]);
	ASSERTERRMSG ("Could not set stop event in result retreived CB", res);
	}

/*++
*******************************************************************
		M a i n T h r e a d
Routine Description:
	Thread in which context we'll perform async IO and maintain timer
	queues.
	It is also used to launch and control other threads of SAP agent
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
DWORD WINAPI
MainThread (
	LPVOID param
	) {
	DWORD	    status;
	UINT	    i;
	DWORD	    nObjects;
	HANDLE	    enumHdl;
    HINSTANCE   hModule;

    hModule = LoadLibrary (ModuleName);

Restart:
    Routing = RouterIfActive;
	if (Routing) {
		nObjects = ROUTING_NUM_OF_OBJECTS;
	}
	else {
		nObjects = STANDALONE_NUM_OF_OBJECTS;
	}

	while ((status = WaitForMultipleObjectsEx (
						nObjects,
						WaitObjects,
						FALSE,				// Wait any
						INFINITE,
						TRUE))!=WAIT_OBJECT_0+STOP_EVENT_IDX) {

		switch (status) {
			case WAIT_OBJECT_0+RECV_COMPLETED_IDX:
				InitReqItem ();
				break;
			case WAIT_OBJECT_0+TIMER_WAKEUP_IDX:
				ProcessTimerQueue ();
				break;
			case WAIT_OBJECT_0+SERVER_TABLE_TIMER_IDX:
				ProcessExpirationQueue ();
				break;
			case WAIT_OBJECT_0+SERVER_TABLE_UPDATE_IDX:
				UpdateSortedList ();
				break;
			case WAIT_OBJECT_0+ADAPTER_CHG_IDX:
				if (!RouterIfActive)
					ProcessAdapterEvents ();
				break;
			case WAIT_IO_COMPLETION:
				break;
			default:
				ASSERTMSG ("Unexpected return code from WaitFromObjects"
							" in IO thread ", FALSE);
				break;
			}
		}

	
	enumHdl = CreateListEnumerator (SDB_HASH_TABLE_LINK,
								0xFFFF,
								NULL,
								INVALID_INTERFACE_INDEX,
								0xFFFFFFFF,
								SDB_DISABLED_NODE_FLAG);

	if (ServiceIfActive || RouterIfActive) {
		if (enumHdl!=NULL)
			EnumerateServers (enumHdl, DeleteNonLocalServersCB, enumHdl);
		}
	else {
		ShutdownLPC ();
		if (enumHdl!=NULL)
			EnumerateServers (enumHdl, DeleteAllServersCB, enumHdl);

		}
    if (enumHdl)
    {
	DeleteListEnumerator (enumHdl);
	}

	if (!RouterIfActive) {
		ShutdownInterfaces (WaitObjects[STOP_EVENT_IDX]);

		ExpireTimerQueue ();
		while ((status = WaitForMultipleObjectsEx (
							ROUTING_NUM_OF_OBJECTS,
							WaitObjects,
							FALSE,				// Wait any
							INFINITE,
							TRUE))!=WAIT_OBJECT_0+STOP_EVENT_IDX) {
			switch (status) {
				case WAIT_OBJECT_0+RECV_COMPLETED_IDX:
						// No more recv requests
					break;
				case WAIT_OBJECT_0+TIMER_WAKEUP_IDX:
					ProcessTimerQueue ();
					break;
				case WAIT_OBJECT_0+SERVER_TABLE_TIMER_IDX:
					ProcessExpirationQueue ();
					break;
				case WAIT_OBJECT_0+SERVER_TABLE_UPDATE_IDX:
					UpdateSortedList ();
					break;
				case WAIT_IO_COMPLETION:
					break;
				default:
					ASSERTMSG ("Unexpected return code from WaitForObjects"
							" in IO thread", FALSE);
				}
			}

		if (!ServiceIfActive) {
			StopIO ();
			StopInterfaces ();
			ExpireTimerQueue ();
			ShutdownWorkers (WaitObjects[STOP_EVENT_IDX]);
			while ((status=WaitForSingleObjectEx (
								WaitObjects[STOP_EVENT_IDX],
								INFINITE,
								TRUE))!=WAIT_OBJECT_0) {
				switch (status) {
					case WAIT_IO_COMPLETION:
						break;
					default:
						ASSERTMSG (
							"Unexpected status when waiting for worker shutdown ",
							FALSE);
						break;
					}
				}
			}
		}


	if (Routing) {
			// Signal completion of stop operation to
			// router manager
		static AR_PARAM_BLOCK	ar;
		ar.event = ROUTER_STOPPED;
		ar.freeRsltCB = ResultRetreivedCB;
		EnqueueResult (&ar);
		while ((status = WaitForSingleObjectEx (
							WaitObjects[STOP_EVENT_IDX],
							INFINITE,
							TRUE))!=WAIT_OBJECT_0) {
			switch (status) {
				case WAIT_IO_COMPLETION:
					break;
				default:
					ASSERTMSG (
						"Unexpected status when waiting for router callback ",
						FALSE);
					break;
				}
			}
		DeleteResultQueue ();
		if (ServiceIfActive) {
			status = CreateAdapterPort (&WaitObjects[ADAPTER_CHG_IDX]);
			if (status==NO_ERROR) {
				EnterCriticalSection (&OperationalStateLock);
				OperationalState = OPER_STATE_UP;
				LeaveCriticalSection (&OperationalStateLock);
				goto Restart;
				}
			else
				ServiceIfActive = FALSE;
			}

    	EnterCriticalSection (&OperationalStateLock);
        CloseHandle (MainThreadHdl);
        MainThreadHdl = NULL;
		LeaveCriticalSection (&OperationalStateLock);
		}
	else {
		DeleteAdapterPort ();
		WaitObjects [ADAPTER_CHG_IDX] = NULL;
		if (RouterIfActive) {
			EnterCriticalSection (&OperationalStateLock);
			OperationalState = OPER_STATE_UP;
			LeaveCriticalSection (&OperationalStateLock);
			goto Restart;
			}
		}

    // Make sure all threads get a chance to complete
    Sleep (1000);
	DeleteAllComponents ();
    FreeLibraryAndExitThread (hModule, 0);
	return 0;
	}

#define MYTEXTW1(str) L##str
#define MYTEXTW2(str) MYTEXTW1(str)

#define REGISTRY_PARAM_ENTRY(name,val) {		\
		NULL,									\
			RTL_QUERY_REGISTRY_DIRECT,			\
			MYTEXTW2(name##_STR),				\
			&val,								\
			REG_DWORD,							\
			&val,								\
			sizeof (DWORD)						\
	}

#define REGISTRY_CHECK(name,val)	{									\
	if (val<name##_MIN) {												\
		Trace (DEBUG_FAILURES, name##_STR " is to small %ld!", val);	\
		val = name##_MIN;												\
		}																\
	else if (val>name##_MAX) {											\
		Trace (DEBUG_FAILURES, name##_STR " is to big %ld!", val);		\
		val = name##_MAX;												\
		}																\
	if (val!=name##_DEF)												\
		Trace (DEBUG_FAILURES, name##_STR" is set to %ld.", val);		\
	}

#define REGISTRY_CHECK_DEF(name,val)	{								\
	if (val<name##_MIN) {												\
		Trace (DEBUG_FAILURES, name##_STR " is to small %ld!", val);	\
		val = name##_DEF;												\
		}																\
	else if (val>name##_MAX) {											\
		Trace (DEBUG_FAILURES, name##_STR " is to big %ld!", val);		\
		val = name##_DEF;												\
		}																\
	if (val!=name##_DEF)												\
		Trace (DEBUG_FAILURES, name##_STR " is set to %ld.", val);		\
	}


VOID
ReadRegistry (
	VOID
	) {
	DWORD		rc;
	HKEY		hKey;
static RTL_QUERY_REGISTRY_TABLE	ParamTable[] = {
	{	NULL,
			RTL_QUERY_REGISTRY_SUBKEY,
			L"Parameters" },
	REGISTRY_PARAM_ENTRY (SAP_UPDATE_INTERVAL,	UpdateInterval),
	REGISTRY_PARAM_ENTRY (SAP_AGING_TIMEOUT,	ServerAgingTimeout),
	REGISTRY_PARAM_ENTRY (SAP_WAN_UPDATE_MODE,	WanUpdateMode),
	REGISTRY_PARAM_ENTRY (SAP_WAN_UPDATE_INTERVAL,WanUpdateInterval),
	REGISTRY_PARAM_ENTRY (SAP_MAX_UNPROCESSED_REQUESTS,
												MaxUnprocessedRequests),
	REGISTRY_PARAM_ENTRY (SAP_RESPOND_FOR_INTERNAL,
												RespondForInternalServers),
	REGISTRY_PARAM_ENTRY (SAP_DELAY_RESPONSE_TO_GENERAL,
												DelayResponseToGeneral),
	REGISTRY_PARAM_ENTRY (SAP_DELAY_CHANGE_BROADCAST,
												DelayChangeBroadcast),
	REGISTRY_PARAM_ENTRY (SAP_SDB_MAX_HEAP_SIZE,SDBMaxHeapSize),
	REGISTRY_PARAM_ENTRY (SAP_SDB_SORT_LATENCY,	SDBSortLatency),
	REGISTRY_PARAM_ENTRY (SAP_SDB_MAX_UNSORTED,	SDBMaxUnsortedServers),
	REGISTRY_PARAM_ENTRY (SAP_TRIGGERED_UPDATE_CHECK_INTERVAL,
												TriggeredUpdateCheckInterval),
	REGISTRY_PARAM_ENTRY (SAP_MAX_TRIGGERED_UPDATE_REQUESTS,
												MaxTriggeredUpdateRequests),
	REGISTRY_PARAM_ENTRY (SAP_SHUTDOWN_TIMEOUT,	ShutdownTimeout),
	REGISTRY_PARAM_ENTRY (SAP_REQUESTS_PER_INTF,NewRequestsPerInterface),
	REGISTRY_PARAM_ENTRY (SAP_MIN_REQUESTS,		MinPendingRequests),
	{
		NULL
	}
};

	rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
			TEXT (SAP_ROUTER_REGISTRY_KEY_STR),
			0,
			KEY_READ,
			&hKey
			);
	if ((rc!=NO_ERROR) && !Routing) {
		rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
			TEXT (SAP_SERVICE_REGISTRY_KEY_STR),
			0,
			KEY_READ,
			&hKey
			);
		}

	if (rc==NO_ERROR) {
		NTSTATUS	status;
		status = RtlQueryRegistryValues(
			 RTL_REGISTRY_HANDLE,
			 (PWSTR)hKey,
			 ParamTable,
			 NULL,
			 NULL);
		if (NT_SUCCESS (status)) {
			REGISTRY_CHECK (SAP_UPDATE_INTERVAL,	UpdateInterval);
			REGISTRY_CHECK (SAP_AGING_TIMEOUT,		ServerAgingTimeout);
			REGISTRY_CHECK_DEF (SAP_WAN_UPDATE_MODE, (int)WanUpdateMode);
			REGISTRY_CHECK (SAP_WAN_UPDATE_INTERVAL,WanUpdateInterval);
			REGISTRY_CHECK (SAP_MAX_UNPROCESSED_REQUESTS,
													MaxUnprocessedRequests);
			REGISTRY_CHECK_DEF (SAP_RESPOND_FOR_INTERNAL,
													(int) RespondForInternalServers);
			REGISTRY_CHECK (SAP_DELAY_RESPONSE_TO_GENERAL,
													(int) DelayResponseToGeneral);
			REGISTRY_CHECK (SAP_DELAY_CHANGE_BROADCAST,
												(int) DelayChangeBroadcast);
			REGISTRY_CHECK (SAP_SDB_MAX_HEAP_SIZE,	SDBMaxHeapSize);
			REGISTRY_CHECK (SAP_SDB_SORT_LATENCY,	SDBSortLatency);
			REGISTRY_CHECK (SAP_SDB_MAX_UNSORTED,	SDBMaxUnsortedServers);
			REGISTRY_CHECK (SAP_TRIGGERED_UPDATE_CHECK_INTERVAL,
													TriggeredUpdateCheckInterval);
			REGISTRY_CHECK (SAP_MAX_TRIGGERED_UPDATE_REQUESTS,
													MaxTriggeredUpdateRequests);
			REGISTRY_CHECK (SAP_SHUTDOWN_TIMEOUT,	ShutdownTimeout);
			REGISTRY_CHECK (SAP_REQUESTS_PER_INTF,	NewRequestsPerInterface);
			REGISTRY_CHECK (SAP_MIN_REQUESTS,		MinPendingRequests);
			}
		RegCloseKey (hKey);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\serverdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\serverdb.c

Abstract:

	This module implements SAP Server Table and corresponding API

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#include "sapp.h"

// The table
SERVER_TABLE ServerTable;

// Max number of unsorted servers
ULONG	SDBMaxUnsortedServers=SAP_SDB_MAX_UNSORTED_DEF;

// Interval with which to update the sorted list
ULONG	SDBSortLatency=SAP_SDB_SORT_LATENCY_DEF;

// Size of heap reserved for the database
ULONG	SDBMaxHeapSize=SAP_SDB_MAX_HEAP_SIZE_DEF;

// Local prototypes
BOOL
AcquireAllLocks (
	void
	);
	
VOID
ReleaseAllLocks (
	void
	);

PSERVER_NODE
CreateNode (
	IN PIPX_SERVER_ENTRY_P	Server,
    IN ULONG     			InterfaceIndex,
	IN DWORD				Protocol,
	IN PUCHAR				AdvertisingNode,
	IN PSDB_HASH_LIST		HashList
	);

VOID
ChangeMainNode (
	IN PSERVER_NODE	oldNode,	
	IN PSERVER_NODE	newNode,	
	IN PLIST_ENTRY	serverLink	
	);
	
VOID
DeleteNode (
	IN PSERVER_NODE		node
	);

VOID
DeleteMainNode (
	IN PSERVER_NODE		node
	);

DWORD
DoFindNextNode (
	IN PLIST_ENTRY				cur,
	IN PPROTECTED_LIST			list,
	IN INT						link,
	IN DWORD					ExclusionFlags,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT PULONG				InterfaceIndex OPTIONAL,
	IN OUT PULONG				Protocol OPTIONAL,
	OUT PULONG					ObjectID OPTIONAL
	);

VOID
DoUpdateSortedList (
	void
	);

PLIST_ENTRY
FindIntfLink (
	ULONG	InterfaceIndex
	);

PLIST_ENTRY
FindTypeLink (
	USHORT	Type
	);

PLIST_ENTRY
FindSortedLink (
	USHORT	Type,
	PUCHAR	Name
	);

INT
HashFunction (
	PUCHAR	Name
	);

ULONG
GenerateUniqueID (
	PSDB_HASH_LIST	HashList
	);


/*++
*******************************************************************
		C r e a t e S e r v e r T a b l e

Routine Description:
		Allocates resources for server table management

Arguments:
		UpdateObject - this object will be signalled when 'slow'
					sorted list of servers needs to be updated
					(UpdateSortedList should be called)
		TimerObject - this object will be signalled when server expiration
					queue requires processing (ProcessExpirationQueue should
					be called)

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateServerTable (
	HANDLE				*UpdateObject,
	HANDLE				*TimerObject
	) {
	DWORD				status=NO_ERROR;
	INT					i;
	BOOL				res;

		// Use private heap for server entries
		// to eliminate fragmentation
	ServerTable.ST_Heap = HeapCreate (0, 0, SDBMaxHeapSize*1024*1024);
	if (ServerTable.ST_Heap!=NULL) {
		ServerTable.ST_UpdateTimer = CreateWaitableTimer (
										NULL,
										TRUE,	// Manual reset
										NULL);
		if (ServerTable.ST_UpdateTimer!=NULL) {
			*UpdateObject = ServerTable.ST_UpdateTimer;
						
			ServerTable.ST_ExpirationTimer = CreateWaitableTimer (
										NULL,
										TRUE,	// Manual reset
										NULL);
			if (ServerTable.ST_ExpirationTimer!=NULL) {
				LONGLONG	timeout = 0;
				*TimerObject = ServerTable.ST_ExpirationTimer;

				ServerTable.ST_LastEnumerator = NULL;
				ServerTable.ST_ServerCnt = 0;
				ServerTable.ST_StaticServerCnt = 0;
				ServerTable.ST_TMPListCnt = 0;
				ServerTable.ST_DeletedListCnt = 0;
				ServerTable.ST_UpdatePending = -1;

				InitializeSyncObjPool (&ServerTable.ST_SyncPool);
				InitializeProtectedList (&ServerTable.ST_SortedListPRM);
				InitializeProtectedList (&ServerTable.ST_SortedListTMP);
				InitializeProtectedList (&ServerTable.ST_DeletedList);
				InitializeProtectedList (&ServerTable.ST_TypeList);
				InitializeProtectedList (&ServerTable.ST_IntfList);
				InitializeProtectedList (&ServerTable.ST_ExpirationQueue);
				InitializeProtectedList (&ServerTable.ST_ChangedSvrsQueue);

				for (i=0; i<SDB_NAME_HASH_SIZE; i++) {
					InitializeProtectedList (&ServerTable.ST_HashLists[i].HL_List);
					ServerTable.ST_HashLists[i].HL_ObjectID = i;
					}

				res = SetWaitableTimer (
							ServerTable.ST_UpdateTimer,
							(PLARGE_INTEGER)&timeout,
							0,			// no period
							NULL, NULL,	// no completion
							FALSE);		// no need to resume
				ASSERTMSG ("Could not set update timer ", res);

				res = SetWaitableTimer (
							ServerTable.ST_ExpirationTimer,
							(PLARGE_INTEGER)&timeout,
							0,			// no period
							NULL, NULL,	// no completion
							FALSE);		// no need to resume
				ASSERTMSG ("Could not set expiration timer ", res);

				return NO_ERROR;
				}
			else {
				status = GetLastError ();
				Trace (DEBUG_FAILURES, "File: %s, line: %ld."
							" Could not create expiration timer (gle:%ld).",
													__FILE__, __LINE__, status);
				}
			CloseHandle (ServerTable.ST_UpdateTimer);
			*UpdateObject = NULL;
			}
		else
			{
			status = GetLastError ();
			Trace (DEBUG_FAILURES, "File: %s, line: %ld."
							" Could not create update timer (gle:%ld).",
												__FILE__, __LINE__, status);
			}


		HeapDestroy (ServerTable.ST_Heap);
		}
	else {
		status = GetLastError ();
		Trace (DEBUG_FAILURES, "File: %s, line: %ld."
						" Could not allocate server table heap (gle:%ld).",
												__FILE__, __LINE__, status);
		}

	return status;
	}


/*++
*******************************************************************
		D e l e t e S e r v e r T a b l e

Routine Description:
		Dispose of server table and associated resources

Arguments:

Return Value:
		NO_ERROR - resources were disposed of successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
void
DeleteServerTable (
	void
	) {
	INT					i;
	while (InterlockedIncrement (&ServerTable.ST_UpdatePending)>0) {
		while (ServerTable.ST_UpdatePending!=-1)
			Sleep (100);
		}

	CloseHandle (ServerTable.ST_ExpirationTimer);
	CloseHandle (ServerTable.ST_UpdateTimer);

	DeleteProtectedList (&ServerTable.ST_SortedListPRM);
	DeleteProtectedList (&ServerTable.ST_SortedListTMP);
	DeleteProtectedList (&ServerTable.ST_DeletedList);
	DeleteProtectedList (&ServerTable.ST_TypeList);
	DeleteProtectedList (&ServerTable.ST_IntfList);
	DeleteProtectedList (&ServerTable.ST_ExpirationQueue);
	DeleteProtectedList (&ServerTable.ST_ChangedSvrsQueue);

	for (i=0; i<SDB_NAME_HASH_SIZE; i++) {
		DeleteProtectedList (&ServerTable.ST_HashLists[i].HL_List);
		ServerTable.ST_HashLists[i].HL_ObjectID = i;
		}
	DeleteSyncObjPool (&ServerTable.ST_SyncPool);
	HeapDestroy (ServerTable.ST_Heap); // Will also destroy all server entries
	}


/*++
*******************************************************************
		U p d a t e S e r v e r

Routine Description:
	Update server in the table (If entry for server does not exist and
	hop count parameter is less than 16, it is added to the table, if entry
	for the server exists and hop count parameter is 16, server is marked
	for deletion, otherwise server info is updated).
	
	Sorted list of servers is not updated immediately
	if new server is added or deleted

Arguments:
	Server	- server parameters (as it comes from IPX packet)
	InterfaceIndex - interface through which knowledge of server was obtained
	Protocol - protocol used to obtain server info
	TimeToLive - time in sec before server is aged out (INFINITE for no aging)
	AdvertisingNode - node that from which this server info was received
	NewServer - set to TRUE if server was not in the table before

Return Value:
	NO_ERROR - server was added/updated ok
	other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
UpdateServer (
	IN PIPX_SERVER_ENTRY_P	Server,
    IN ULONG     			InterfaceIndex,
	IN DWORD				Protocol,
	IN ULONG				TimeToLive,
	IN PUCHAR				AdvertisingNode,
	IN INT					Flags,
	OUT BOOL				*NewServer OPTIONAL
	) {
	PSDB_HASH_LIST			HashList;
	PLIST_ENTRY				cur, intfLink=NULL, serverLink=NULL;
	DWORD					status=NO_ERROR;
	PSERVER_NODE			theNode=NULL, mainNode=NULL;
	INT						res;

	//ASSERT ((Flags&(~(SDB_DONT_RESPOND_NODE_FLAG|SDB_DISABLED_NODE_FLAG)))==0); 

	if (Server->Name[0]==0) {
		Trace (DEBUG_SERVERDB, "Illigal server name in UpdateServer.");
		return ERROR_INVALID_PARAMETER;
		}

	if ( Server-> HopCount > IPX_MAX_HOP_COUNT )
	{
		Trace(
			DEBUG_SERVERDB, "\tUpdateServer : Invalid Hop count" 
			"type: %04x, hops: %d, name: %.48s.\n",
			Server->Type,
			Server->HopCount,
			Server->Name
			);

		ASSERTERR( FALSE );

		return ERROR_INVALID_PARAMETER;
	}
	//else
	//{
	//    Trace( DEBUG_SERVERDB, "\tUpdateServer : Hop count ok\n" );
    //}
	
	if (ARGUMENT_PRESENT(NewServer))
		*NewServer = TRUE;
		// First try to locate server in hash list
	HashList = &ServerTable.ST_HashLists[HashFunction (Server->Name)];

	if (!AcquireServerTableList (&HashList->HL_List, TRUE))
		return ERROR_GEN_FAILURE;

	cur = HashList->HL_List.PL_Head.Flink;
	while (cur!=&HashList->HL_List.PL_Head) {
		PSERVER_NODE	node = CONTAINING_RECORD (cur,
										SERVER_NODE,
										N_Links[SDB_HASH_TABLE_LINK]);
		VALIDATE_NODE(node);
		if (!IsEnumerator (node)) {
			if (Server->Type == node->SN_Server.Type) {
				res = IpxNameCmp (Server->Name, node->SN_Server.Name);
				if (res==0) {
					if (ARGUMENT_PRESENT(NewServer))
						*NewServer = FALSE;
						// Loop through all entries in the table for
						// this server
					do {
							// If there is another entry with same interface,
							// remember its position in interface list
							// so new entry can be inserted quickly if 
							// necessary
						if (InterfaceIndex==node->SN_InterfaceIndex)
							intfLink = &node->N_Links[SDB_INTF_LIST_LINK];

						if ((InterfaceIndex==node->SN_InterfaceIndex)
							&& (Protocol == node->SN_Protocol)
							&& (IpxNodeCmp (AdvertisingNode,
										&node->SN_AdvertisingNode)==0)) {
							theNode = node;	// Exact match
							if (((Flags & SDB_DISABLED_NODE_FLAG)
                                        < (node->N_NodeFlags & SDB_DISABLED_NODE_FLAG))
                                   || (((Flags & SDB_DISABLED_NODE_FLAG)
                                            == (node->N_NodeFlags & SDB_DISABLED_NODE_FLAG))
                                        && (Server->HopCount<=node->SN_HopCount))) {
									// Hop count is better, than the that
									// of the rest, ignore them
								if (serverLink==NULL)
									serverLink = &theNode->SN_ServerLink;
								break;
								}
							}
						else {
								// Get the best entry besides the one
								// we are updating
							if (mainNode==NULL)
								mainNode = node;
								// Find the place for added/updated entry
								// in the list of entries for this server
								// (this list is ordered by hop count)
							if ((serverLink==NULL) 
							    && (((Flags & SDB_DISABLED_NODE_FLAG)
                                        < (node->N_NodeFlags & SDB_DISABLED_NODE_FLAG))
                                   || (((Flags & SDB_DISABLED_NODE_FLAG)
                                            == (node->N_NodeFlags & SDB_DISABLED_NODE_FLAG))
                                        && (Server->HopCount<=node->SN_HopCount)))) {
								serverLink = &node->SN_ServerLink;
									// We saw the server and know where
									// to place it, break out
								if (theNode!=NULL)
									break;
								}
							}
						node = CONTAINING_RECORD (node->SN_ServerLink.Flink,
													SERVER_NODE,
													SN_ServerLink);
						VALIDATE_SERVER_NODE(node);
						}
							// Loop until we are back to best entry
					while (!IsMainNode (node));
						
					}
				else if (res<0)
						// No chance to see the server: the hash is ordered
						// be type.name
					break;
				}
			else if (Server->Type<node->SN_Server.Type)
				break;
			}
		cur = cur->Flink;
		}

	if (theNode!=NULL) {
		if ((IpxNetCmp (theNode->SN_Server.Network, Server->Network)!=0)
				|| (IpxNodeCmp (theNode->SN_Server.Node, Server->Node)!=0)
				|| (IpxSockCmp (theNode->SN_Server.Socket, Server->Socket)!=0)
				) {
			Trace (DEBUG_FAILURES,
				"Address change for server %.4x %.48s:\n"
				"        Old - %.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x:%.2x%.2x\n"
				"        New - %.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x:%.2x%.2x",
				Server->Type, Server->Name,
				theNode->SN_Server.Network[0], theNode->SN_Server.Network[1],
					theNode->SN_Server.Network[2], theNode->SN_Server.Network[3],
				theNode->SN_Server.Node[0], theNode->SN_Server.Node[1],
					theNode->SN_Server.Node[2], theNode->SN_Server.Node[3],
					theNode->SN_Server.Node[4], theNode->SN_Server.Node[5],
				theNode->SN_Server.Socket[0], theNode->SN_Server.Socket[1],
				Server->Network[0], Server->Network[1],
				Server->Network[2], Server->Network[3],
				Server->Node[0], Server->Node[1], Server->Node[2],
					Server->Node[3], Server->Node[4], Server->Node[5],
				Server->Socket[0], Server->Socket[1]
				);
            IF_LOG (EVENTLOG_WARNING_TYPE) {
                IPX_ADDRESS_BLOCK   data[2];
                LPSTR               str[1] = {(LPSTR)Server->Name};
                IpxAddrCpy (&data[0], &theNode->SN_Server);
                IpxAddrCpy (&data[1], Server);
                RouterLogWarningDataA (RouterEventLogHdl,
                    ROUTERLOG_IPXSAP_SERVER_ADDRESS_CHANGE,
                    1, str,
                    24, (LPBYTE)data);
                }
			IpxAddrCpy (&theNode->SN_Server, Server);
		    }

			// We already have server in the table
		if (IsDisabledNode (theNode))
				// Just update the hop count
			theNode->SN_HopCount = Server->HopCount;
		else if (((Flags & SDB_DISABLED_NODE_FLAG)
                        != (theNode->N_NodeFlags & SDB_DISABLED_NODE_FLAG))
                  || (Server->HopCount!=theNode->SN_HopCount)) {
				// Its hop count changed, we'll have to do something
			if (AcquireAllLocks ()) {
				theNode->SN_HopCount = Server->HopCount;
				if (mainNode==NULL) {
					// We haven't seen a node that had or has lower hop count
					// theNode is still the best
					if (Server->HopCount==IPX_MAX_HOP_COUNT)
						DeleteMainNode (theNode);
					else {
						if (IsEnumerator (CONTAINING_RECORD (
										ServerTable.ST_ChangedSvrsQueue.PL_Head.Flink,
										SERVER_NODE,
										N_Links[SDB_CHANGE_QUEUE_LINK])))
							ExpireLRRequests ((PVOID)UlongToPtr(InterfaceIndex));
							// Move server to the bottom of change queue
							// so those who enumerate through it
							// notice that it has changed
						RemoveEntryList (&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
						InsertHeadList (&ServerTable.ST_ChangedSvrsQueue.PL_Head,
								&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
						}
					}
				else if (!IsMainNode (theNode)
					 && (serverLink==&theNode->SN_ServerLink)
					 && (Server->HopCount<IPX_MAX_HOP_COUNT))
					 // theNode was not the best and it is going to stay where
					 // it is now.
					;
				else if (IsMainNode (theNode))
						// It was the best node. but we saw something better:
						// mainNode!=NULL (was checked above)
					ChangeMainNode (theNode, mainNode, serverLink);
				else if (serverLink==&mainNode->SN_ServerLink)
						// It is moving before the mainNode - becoming the best
					ChangeMainNode (mainNode, theNode, serverLink);
				else if (Server->HopCount<IPX_MAX_HOP_COUNT) {
						// Just moving around the list of entries for the
						// server
					RemoveEntryList (&theNode->SN_ServerLink);
					if (serverLink!=NULL) {
							// Going before the serverLink
						InsertTailList (serverLink, &theNode->SN_ServerLink);
						}
					else {
							// Going to the end of list (circular list:
							// end is right before the beginning
						InsertTailList (&mainNode->SN_ServerLink,
											&theNode->SN_ServerLink);
						}
					}
				else { // Going away (Server->HopCount>=IPX_MAX_HOP_COUNT)
					DeleteNode (theNode);
					}
				ReleaseAllLocks ();
				}
			else
				status = ERROR_GEN_FAILURE;
			}
			
		}
	else if (Server->HopCount<IPX_MAX_HOP_COUNT) {
			// It is not there and it is not dead.
		if (mainNode==NULL) {
			PLIST_ENTRY		link;
				// Add a brand new server
			theNode = CreateNode (Server, InterfaceIndex, Protocol,
								 			AdvertisingNode, HashList);
			if (theNode!=NULL) {
				if (AcquireAllLocks ()) {
					if (((intfLink=FindIntfLink (InterfaceIndex))!=NULL)
							&& ((link=FindTypeLink (Server->Type))!=NULL)) {
						
						ServerTable.ST_ServerCnt += 1;
						if (theNode->SN_Protocol==IPX_PROTOCOL_STATIC)
							ServerTable.ST_StaticServerCnt += 1;
						SetMainNode (theNode);
							// Insert in every list
						InsertTailList (cur,
										&theNode->N_Links[SDB_HASH_TABLE_LINK]);
						InsertTailList (link,
										&theNode->N_Links[SDB_TYPE_LIST_LINK]);
						InsertTailList (intfLink,
										&theNode->N_Links[SDB_INTF_LIST_LINK]);
						if (IsEnumerator (CONTAINING_RECORD (
										ServerTable.ST_ChangedSvrsQueue.PL_Head.Flink,
										SERVER_NODE,
										N_Links[SDB_CHANGE_QUEUE_LINK])))
							ExpireLRRequests ((PVOID)UlongToPtr(InterfaceIndex));
						InsertHeadList (&ServerTable.ST_ChangedSvrsQueue.PL_Head,
										&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
						link = FindSortedLink (Server->Type, Server->Name);
						InsertTailList (link,
										&theNode->N_Links[SDB_SORTED_LIST_LINK]);
						ServerTable.ST_TMPListCnt += 1;
							// Signal update if too many nodes
						if (ServerTable.ST_TMPListCnt == SDBMaxUnsortedServers)
							UpdateSortedList ();
						}
					else {
						HeapFree (ServerTable.ST_Heap, 0, theNode);
						status = ERROR_NOT_ENOUGH_MEMORY;
						}
					ReleaseAllLocks ();
					}
				else {
					HeapFree (ServerTable.ST_Heap, 0, theNode);
					status = ERROR_GEN_FAILURE;
					}
				}
			else
				status = ERROR_NOT_ENOUGH_MEMORY;
			}

			// Ok, we consider adding it although we have some entries already
		else {
				// Check for duplicates (different addresses)
			if ((IpxNetCmp (mainNode->SN_Server.Network, Server->Network)!=0)
					|| (IpxNodeCmp (mainNode->SN_Server.Node, Server->Node)!=0)
					|| (IpxSockCmp (mainNode->SN_Server.Socket, Server->Socket)!=0)
					) {
				Trace (DEBUG_FAILURES,
					"Duplicate addresses for server %.4x %.48s:\n"
					"        1 - %.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x:%.2x%.2x"
							" from if-%ld, node-%.2x%.2x%.2x%.2x%.2x%.2x\n"
					"        2 - %.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x:%.2x%.2x"
							" from if-%ld, node-%.2x%.2x%.2x%.2x%.2x%.2x",
					Server->Type, Server->Name,
					mainNode->SN_Server.Network[0], mainNode->SN_Server.Network[1],
						mainNode->SN_Server.Network[2], mainNode->SN_Server.Network[3],
					mainNode->SN_Server.Node[0], mainNode->SN_Server.Node[1],
						mainNode->SN_Server.Node[2], mainNode->SN_Server.Node[3],
						mainNode->SN_Server.Node[4], mainNode->SN_Server.Node[5],
					mainNode->SN_Server.Socket[0], mainNode->SN_Server.Socket[1],
					mainNode->SN_InterfaceIndex,
					mainNode->SN_AdvertisingNode[0], mainNode->SN_AdvertisingNode[1],
						mainNode->SN_AdvertisingNode[2], mainNode->SN_AdvertisingNode[3],
						mainNode->SN_AdvertisingNode[4], mainNode->SN_AdvertisingNode[5],
					Server->Network[0], Server->Network[1], 
						Server->Network[2], Server->Network[3],
					Server->Node[0], Server->Node[1], Server->Node[2],
						Server->Node[3], Server->Node[4], Server->Node[5],
					Server->Socket[0], Server->Socket[1],
					InterfaceIndex,
					AdvertisingNode[0], AdvertisingNode[1], AdvertisingNode[2],
						AdvertisingNode[3], AdvertisingNode[4], AdvertisingNode[5]
					);
                IF_LOG (EVENTLOG_WARNING_TYPE) {
                    IPX_ADDRESS_BLOCK   data[2];
                    LPSTR               str[1] = {(LPSTR)Server->Name};
                    IpxAddrCpy (&data[0], &mainNode->SN_Server);
                    IpxAddrCpy (&data[1], Server);
                    RouterLogWarningDataA (RouterEventLogHdl,
                        ROUTERLOG_IPXSAP_SERVER_DUPLICATE_ADDRESSES,
                        1, str,
                        24, (LPBYTE)data);
                    }
			    }

				// Collect all servers when routing
			if (Routing) {
				theNode = CreateNode (Server, InterfaceIndex, Protocol,
								 				AdvertisingNode, HashList);
				if (theNode!=NULL) {
					if (AcquireAllLocks ()) {
						if ((intfLink!=NULL)
								|| ((intfLink=FindIntfLink (InterfaceIndex))!=NULL)) {
							if (theNode->SN_Protocol==IPX_PROTOCOL_STATIC)
								ServerTable.ST_StaticServerCnt += 1;
							InsertTailList (intfLink,
									 &theNode->N_Links[SDB_INTF_LIST_LINK]);
							if ((Server->HopCount<mainNode->SN_HopCount)
									||  IsDisabledNode (mainNode))
									// Replaces the best node
								ChangeMainNode (mainNode, theNode, NULL);
							else if (serverLink!=NULL) {
									// Going before the serverLink
								InsertTailList (serverLink, &theNode->SN_ServerLink);
								}
							else {
									// Going to the end of list (circular list:
									// the end is right before the beginning)
								InsertTailList (&mainNode->SN_ServerLink,
													&theNode->SN_ServerLink);
								}
							}
						else {
							HeapFree (ServerTable.ST_Heap, 0, theNode);
							status = ERROR_GEN_FAILURE;
							}
						ReleaseAllLocks ();
						}
					else {
						HeapFree (ServerTable.ST_Heap, 0, theNode);
						status = ERROR_GEN_FAILURE;
						}
					}
				else
					status = ERROR_NOT_ENOUGH_MEMORY;
				}
			else if (serverLink!=NULL) {
						// If is better than one of ours
				if (AcquireAllLocks ()) {
					if  ((intfLink!=NULL)
							|| ((intfLink=FindIntfLink (InterfaceIndex))!=NULL)) {
							// Replace the worst one (at the end of server list)
						theNode = CONTAINING_RECORD (
												mainNode->SN_ServerLink.Blink,
												SERVER_NODE,
												SN_ServerLink);
						VALIDATE_SERVER_NODE(theNode);

						IpxServerCpy (&theNode->SN_Server, Server);
						IpxNodeCpy (theNode->SN_AdvertisingNode, AdvertisingNode);
						theNode->SN_InterfaceIndex = InterfaceIndex;
						ResetDisabledNode (theNode);
						if (theNode->SN_Protocol!=Protocol) {
							if (Protocol==IPX_PROTOCOL_STATIC)
								ServerTable.ST_StaticServerCnt += 1;
							else if (theNode->SN_Protocol==IPX_PROTOCOL_STATIC)
								ServerTable.ST_StaticServerCnt -= 1;
							theNode->SN_Protocol = Protocol;
							}
						if (intfLink!=&theNode->N_Links[SDB_INTF_LIST_LINK]) {
							RemoveEntryList (&theNode->N_Links[SDB_INTF_LIST_LINK]);
							InsertTailList (intfLink,
											 &theNode->N_Links[SDB_INTF_LIST_LINK]);
							}

						if (theNode==mainNode) {
							if (IsEnumerator (CONTAINING_RECORD (
											ServerTable.ST_ChangedSvrsQueue.PL_Head.Flink,
											SERVER_NODE,
											N_Links[SDB_CHANGE_QUEUE_LINK])))
								ExpireLRRequests ((PVOID)UlongToPtr(InterfaceIndex));
								// It's already the best, just move it to the
								// bottom of change queue
							RemoveEntryList (&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
							InsertHeadList (&ServerTable.ST_ChangedSvrsQueue.PL_Head,
										&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
							}
						else if ((theNode->SN_HopCount < mainNode->SN_HopCount)
									|| IsDisabledNode (mainNode))
								// It replaces the best one
							ChangeMainNode (mainNode, theNode, serverLink);
						else if (serverLink!=&theNode->SN_ServerLink) {
								// It just gets in the middle
							RemoveEntryList (&theNode->SN_ServerLink);
							InsertTailList (serverLink, &theNode->SN_ServerLink);
							}
						}
					else
						status = ERROR_GEN_FAILURE;
					ReleaseAllLocks ();
					}
				else
					status = ERROR_GEN_FAILURE;
				}
			}

		}
		// Update position in expiration queue
	if ((status==NO_ERROR)
			&& (theNode!=NULL)
			&& (Server->HopCount!=IPX_MAX_HOP_COUNT) // theNode could not have
								){		// been deleted or setup for deletion
			// Update flags
		theNode->N_NodeFlags = (theNode->N_NodeFlags & (~(SDB_DISABLED_NODE_FLAG|SDB_DONT_RESPOND_NODE_FLAG)))
								| (Flags & (SDB_DISABLED_NODE_FLAG|SDB_DONT_RESPOND_NODE_FLAG));

		if (AcquireServerTableList (&ServerTable.ST_ExpirationQueue, TRUE)) {
			if (IsListEntry (&theNode->SN_TimerLink))
				RemoveEntryList (&theNode->SN_TimerLink);
			if (TimeToLive!=INFINITE) {
				ASSERTMSG ("Invalid value of time to live ",
								 			TimeToLive*1000<MAXULONG/2);
				theNode->SN_ExpirationTime = 
								GetTickCount()+TimeToLive*1000;
				RoundUpToSec (theNode->SN_ExpirationTime);
									
					// Scan expiration queue from the end (to minimize
					// the number of nodes we have to look through)
				cur = ServerTable.ST_ExpirationQueue.PL_Head.Blink;
				while (cur!=&ServerTable.ST_ExpirationQueue.PL_Head) {
					if (IsLater(theNode->SN_ExpirationTime,
								CONTAINING_RECORD (
									cur,
									SERVER_NODE,
									SN_TimerLink)->SN_ExpirationTime))
						break;
					cur = cur->Blink;
					}
				InsertHeadList (cur, &theNode->SN_TimerLink);
				if (cur==&ServerTable.ST_ExpirationQueue.PL_Head) {
						// Signal timer if server is in the beginning
						// of the list (we need to get a shot
						// earlier than we previously requested)
					LONGLONG	timeout = (LONGLONG)TimeToLive*(1000*(-10000));
					BOOL res = SetWaitableTimer (
									ServerTable.ST_ExpirationTimer,
									(PLARGE_INTEGER)&timeout,
									0,			// no period
									NULL, NULL,	// no completion
									FALSE);		// no need to resume
					ASSERTERRMSG ("Could not set expiraton timer ", res);
					}
				}
			else {
				InitializeListEntry (&theNode->SN_TimerLink);
				}
			ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);
			}
		else
			status = ERROR_GEN_FAILURE;
		}
		

	ReleaseServerTableList (&HashList->HL_List);
	return status;
	}


/*++
*******************************************************************
		C r e a t e N o d e

Routine Description:
	Allocate and initialize new server entry

Arguments:
	Server	- server parameters (as it comes from IPX packet)
	InterfaceIndex - interface through which knowledge of server was obtained
	Protocol - protocol used to obtain server info
	AdvertisingNode - node from which this server info was received
	HashList	- hash list to which this server belongs

Return Value:
	Allocated and initialized entry
	NULL if allocation failed

*******************************************************************
--*/

PSERVER_NODE
CreateNode (
	IN PIPX_SERVER_ENTRY_P	Server,
    IN ULONG     			InterfaceIndex,
	IN DWORD				Protocol,
	IN PUCHAR				AdvertisingNode,
	IN PSDB_HASH_LIST		HashList
	) {
	PSERVER_NODE	theNode;


	theNode = (PSERVER_NODE)HeapAlloc (ServerTable.ST_Heap, 0, sizeof (SERVER_NODE));
	if (theNode==NULL) {
		Trace (DEBUG_FAILURES, 
				"File: %s, line: %ld. Can't allocate server node (gle:%ld).",
											__FILE__, __LINE__, GetLastError ());
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}

	theNode->N_NodeFlags = SDB_SERVER_NODE;
	theNode->SN_HashList = HashList;
	theNode->SN_InterfaceIndex = InterfaceIndex;
	theNode->SN_Protocol = Protocol;
	theNode->SN_ObjectID = SDB_INVALID_OBJECT_ID;
	IpxNodeCpy (theNode->SN_AdvertisingNode, AdvertisingNode);
	theNode->SN_Signature = SDB_SERVER_NODE_SIGNATURE;
	IpxServerCpy (&theNode->SN_Server, Server);
	InitializeListEntry (&theNode->N_Links[SDB_HASH_TABLE_LINK]);
	InitializeListEntry (&theNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
	InitializeListEntry (&theNode->N_Links[SDB_INTF_LIST_LINK]);
	InitializeListEntry (&theNode->N_Links[SDB_TYPE_LIST_LINK]);
	InitializeListEntry (&theNode->N_Links[SDB_SORTED_LIST_LINK]);
	InitializeListEntry (&theNode->SN_ServerLink);
	InitializeListEntry (&theNode->SN_TimerLink);

	return theNode;
	}

/*++
*******************************************************************
		C h a n g e M a i n N o d e

Routine Description:
	Replace best entry for server (moves new best entry to the
	top of the server list, replaces old entry in hash, type,
	and sorted lists. Adds new entry to interface list if it
	is not already there
	All lists used for enumeration should be locked when calling this routine

Arguments:
	oldNode	-	Current best entry
	newNode	-	Node that will become the best
	serverLink	- Where oldNode has to go in server list:
					if newNode not in the list or
						serverLink==&oldNode->SN_ServerLink, oldNode
						gets pushed down by newNode

					if serverLink==NULL, oldNode goes to the end of list

					otherwise it goes before serverLink

Return Value:
	NO_ERROR - server was added/updated ok
	other - reason of failure (windows error code)

*******************************************************************
--*/

VOID
ChangeMainNode (
	IN PSERVER_NODE	oldNode,	
	IN PSERVER_NODE	newNode,	
	IN PLIST_ENTRY	serverLink	
	) {

	ASSERTMSG ("Node is already main ", !IsMainNode (newNode));
	SetMainNode (newNode);
	ASSERTMSG ("Node being reset is not main ", IsMainNode (oldNode));
	ResetMainNode (oldNode);

	if (oldNode->SN_ObjectID!=SDB_INVALID_OBJECT_ID) {
		newNode->SN_ObjectID = oldNode->SN_ObjectID;
		oldNode->SN_ObjectID = SDB_INVALID_OBJECT_ID;
		}

	InsertTailList (&oldNode->N_Links[SDB_HASH_TABLE_LINK],
						&newNode->N_Links[SDB_HASH_TABLE_LINK]);
	RemoveEntryList (&oldNode->N_Links[SDB_HASH_TABLE_LINK]);
	InitializeListEntry (&oldNode->N_Links[SDB_HASH_TABLE_LINK]);

	RemoveEntryList (&oldNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
	InitializeListEntry (&oldNode->N_Links[SDB_CHANGE_QUEUE_LINK]);
	if (IsEnumerator (CONTAINING_RECORD (
					ServerTable.ST_ChangedSvrsQueue.PL_Head.Flink,
					SERVER_NODE,
					N_Links[SDB_CHANGE_QUEUE_LINK])))
		ExpireLRRequests ((PVOID)UlongToPtr(newNode->SN_InterfaceIndex));
	InsertHeadList (&ServerTable.ST_ChangedSvrsQueue.PL_Head,
					&newNode->N_Links[SDB_CHANGE_QUEUE_LINK]);

	InsertTailList (&oldNode->N_Links[SDB_TYPE_LIST_LINK],
						 &newNode->N_Links[SDB_TYPE_LIST_LINK]);
	RemoveEntryList (&oldNode->N_Links[SDB_TYPE_LIST_LINK]);
	InitializeListEntry (&oldNode->N_Links[SDB_TYPE_LIST_LINK]);

	if (!IsListEntry (&newNode->SN_ServerLink)) {
		InsertTailList (&oldNode->SN_ServerLink, &newNode->SN_ServerLink);
		}
	else if (serverLink==&oldNode->SN_ServerLink) {
		RemoveEntryList (&newNode->SN_ServerLink);
		InsertTailList (&oldNode->SN_ServerLink, &newNode->SN_ServerLink);
		}
	else if (serverLink!=NULL) {
		RemoveEntryList (&oldNode->SN_ServerLink);
		InsertHeadList (serverLink, &oldNode->SN_ServerLink);
		}

	if (oldNode->SN_HopCount==IPX_MAX_HOP_COUNT) {
		DeleteNode (oldNode);
		}

	serverLink = FindSortedLink (newNode->SN_Server.Type,
									 newNode->SN_Server.Name);
	if (!IsListEntry (&newNode->N_Links[SDB_SORTED_LIST_LINK])) {
		InsertTailList (serverLink, &newNode->N_Links[SDB_SORTED_LIST_LINK]);
		ServerTable.ST_TMPListCnt += 1;
		if (ServerTable.ST_TMPListCnt == SDBMaxUnsortedServers)
			UpdateSortedList ();
		}
	}

/*++
*******************************************************************
		A c q u i r e A l l L o c k s

Routine Description:
	Acquire locks for all lists that are updated immediately
	when server is added/deleted/updated
Arguments:
	None
Return Value:
	NO_ERROR - server was added/updated ok
	other - reason of failure (windows error code)

*******************************************************************
--*/
BOOL
AcquireAllLocks (
	void
	) {
	if (AcquireServerTableList (&ServerTable.ST_ChangedSvrsQueue, TRUE)) {
		if (AcquireServerTableList (&ServerTable.ST_IntfList, TRUE)) {
			if (AcquireServerTableList (&ServerTable.ST_TypeList, TRUE)) {
				if (AcquireServerTableList (&ServerTable.ST_SortedListTMP, TRUE))
					return TRUE;
				ReleaseServerTableList (&ServerTable.ST_TypeList);
				}
			ReleaseServerTableList (&ServerTable.ST_IntfList);
			}
		ReleaseServerTableList (&ServerTable.ST_ChangedSvrsQueue);
		}
	return FALSE;
	}


/*++
*******************************************************************
		R e l e a s e A l l L o c k s

Routine Description:
	Release locks for all lists that are updated immediately
	when server is added/deleted/updated
Arguments:
	None
Return value:
	None

*******************************************************************
--*/
VOID
ReleaseAllLocks (
	void
	) {
	ReleaseServerTableList (&ServerTable.ST_SortedListTMP);
	ReleaseServerTableList (&ServerTable.ST_TypeList);
	ReleaseServerTableList (&ServerTable.ST_IntfList);
	ReleaseServerTableList (&ServerTable.ST_ChangedSvrsQueue);
	}



/*++
*******************************************************************
		D e l e t e M a i n N o d e

Routine Description:
	Delete entry that was best (it still remains in the table for
	a while until all interested get a chance to learn this
	All lists used for enumeration should be locked when calling this routine
Arguments:
	node - entry to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteMainNode (
	IN PSERVER_NODE		node
	) {
	
	RemoveEntryList (&node->N_Links[SDB_HASH_TABLE_LINK]);
	InitializeListEntry (&node->N_Links[SDB_HASH_TABLE_LINK]);
	RemoveEntryList (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
	InitializeListEntry (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
	RemoveEntryList (&node->N_Links[SDB_INTF_LIST_LINK]);
	InitializeListEntry (&node->N_Links[SDB_INTF_LIST_LINK]);
	RemoveEntryList (&node->N_Links[SDB_TYPE_LIST_LINK]);
	InitializeListEntry (&node->N_Links[SDB_TYPE_LIST_LINK]);
	ServerTable.ST_ServerCnt -= 1;
	if (node->SN_Protocol==IPX_PROTOCOL_STATIC)
		ServerTable.ST_StaticServerCnt -= 1;

	if (ServerTable.ST_LastEnumerator==NULL) {
		ASSERTMSG ("Node being reset is not main ", IsMainNode (node));
		ResetMainNode (node);
		// We won't try to get access to sorted list because it is
		// slow, the entry will be actually removed from it
		// and disposed of when the sorted list is updated
		if (AcquireServerTableList (&ServerTable.ST_DeletedList, TRUE)) {
			InsertTailList (&ServerTable.ST_DeletedList.PL_Head,
						&node->SN_ServerLink);
			ServerTable.ST_DeletedListCnt += 1;
			if (ServerTable.ST_DeletedListCnt==SDBMaxUnsortedServers)
				UpdateSortedList ();
			ReleaseServerTableList (&ServerTable.ST_DeletedList);
			}
			// If we fail in locking we just let it hang around
			// (at least we won't risk damaging the list)
		}
	else {
			// If there are enumerators in change queue, we can't
			// delete the node until they see it
		if (IsEnumerator (CONTAINING_RECORD (
						ServerTable.ST_ChangedSvrsQueue.PL_Head.Flink,
						SERVER_NODE,
						N_Links[SDB_CHANGE_QUEUE_LINK])))
			ExpireLRRequests ((PVOID)UlongToPtr(node->SN_InterfaceIndex));
		InsertHeadList (&ServerTable.ST_ChangedSvrsQueue.PL_Head,
							&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
		}
	}


/*++
*******************************************************************
		D e l e t e N o d e

Routine Description:
	Delete entry that was not the best 
	All lists used for enumeration should be locked when calling this routine
Arguments:
	node - entry to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteNode (
	IN PSERVER_NODE		node
	) {
	RemoveEntryList (&node->N_Links[SDB_INTF_LIST_LINK]);
	InitializeListEntry (&node->N_Links[SDB_INTF_LIST_LINK]);
	RemoveEntryList (&node->SN_ServerLink);
	if (node->SN_Protocol==IPX_PROTOCOL_STATIC)
		ServerTable.ST_StaticServerCnt -= 1;
	if (AcquireServerTableList (&ServerTable.ST_DeletedList, TRUE)) {
			// We won't try to get access to sorted list because it is
			// slow, the entry will be actually removed from it
			// and disposed of when the sorted list is updated
		InsertTailList (&ServerTable.ST_DeletedList.PL_Head,
					&node->SN_ServerLink);
		ServerTable.ST_DeletedListCnt += 1;
		if (ServerTable.ST_DeletedListCnt==SDBMaxUnsortedServers)
			UpdateSortedList ();
		ReleaseServerTableList (&ServerTable.ST_DeletedList);
		}
	else {
			// If we fail in locking we just let it hang around
			// (at least we won't risk damaging the list)
		InitializeListEntry (&node->SN_ServerLink);
		}
	}



/*++
*******************************************************************
		D o U p d a t e S o r t e d L i s t

Routine Description:
	Deletes entries placed in deleted list and merges temporary and
	permanent sorted lists.
	This routine may take some time to execute because it may need to scan
	the whole sorted list that contains all entries in the table
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DoUpdateSortedList (
	void
	) {
	PLIST_ENTRY		cur;
	ULONG			curCount;
	LIST_ENTRY		tempHead;
		// We first lock the 'slow' list
	if (!AcquireServerTableList (&ServerTable.ST_SortedListPRM, TRUE))
				// Failure to acquire sorted list,
				// tell them to retry in a little while
		return ;

		// The following two list are locked for a short period:
			// we'll just delete what needs to be deleted (no searching)
			// and copy and reset temp sorted list

	if (!AcquireServerTableList (&ServerTable.ST_ExpirationQueue, TRUE)) {
		ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
				// Failure to acquire expiration queue,
				// tell them to retry in a little while
		return ;
		}
	
	if (!AcquireServerTableList (&ServerTable.ST_SortedListTMP, TRUE)) {
		ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);
		ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
				// Failure to acquire sorted list,
				// tell them to retry in a little while
		return ;
		}

	if (!AcquireServerTableList (&ServerTable.ST_DeletedList, TRUE)) {
		ReleaseServerTableList (&ServerTable.ST_SortedListTMP);
		ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);
		ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
				// Failure to acquire deleted list,
				// tell them to retry in a little while
		return ;
		}
	
		// Delete what we have to delete
	cur = ServerTable.ST_DeletedList.PL_Head.Flink;
	while (cur != &ServerTable.ST_DeletedList.PL_Head) {
		PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											SN_ServerLink);
		VALIDATE_SERVER_NODE(node);
		cur = cur->Flink;
		RemoveEntryList (&node->SN_ServerLink);
		if (IsListEntry (&node->N_Links[SDB_SORTED_LIST_LINK])) {
			RemoveEntryList (&node->N_Links[SDB_SORTED_LIST_LINK]);
			}
		if (IsListEntry (&node->SN_TimerLink)) {
			RemoveEntryList (&node->SN_TimerLink);
			}
        ASSERTMSG ("Deleted entry is still in hash list ",
            !IsListEntry (&node->N_Links[SDB_HASH_TABLE_LINK]));
        ASSERTMSG ("Deleted entry is still in change queue ",
            !IsListEntry (&node->N_Links[SDB_CHANGE_QUEUE_LINK]));
        ASSERTMSG ("Deleted entry is still in interface list ",
            !IsListEntry (&node->N_Links[SDB_INTF_LIST_LINK]));
        ASSERTMSG ("Deleted entry is still in type list ",
            !IsListEntry (&node->N_Links[SDB_TYPE_LIST_LINK]));
		HeapFree (ServerTable.ST_Heap, 0, node);
		}
	ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);
	ServerTable.ST_DeletedListCnt = 0;
	ReleaseServerTableList (&ServerTable.ST_DeletedList);

		// Now, just copy the head of the temp list,
		// so we won't delay others while processing it
	if (!IsListEmpty (&ServerTable.ST_SortedListTMP.PL_Head)) {
		InsertTailList (&ServerTable.ST_SortedListTMP.PL_Head, &tempHead);
		RemoveEntryList (&ServerTable.ST_SortedListTMP.PL_Head);
		InitializeListHead (&ServerTable.ST_SortedListTMP.PL_Head);
		}
	else
		InitializeListHead (&tempHead);

	ServerTable.ST_TMPListCnt = 0;	// We are going to remove all of them,
	ReleaseServerTableList (&ServerTable.ST_SortedListTMP);


		// Now we start the merge

	cur = ServerTable.ST_SortedListPRM.PL_Head.Flink;
	while (!IsListEmpty (&tempHead)) {
		PSERVER_NODE prmNode = NULL;
		PSERVER_NODE tmpNode;
		
		tmpNode = CONTAINING_RECORD (tempHead.Flink,
								SERVER_NODE,
								N_Links[SDB_SORTED_LIST_LINK]);
		VALIDATE_SERVER_NODE(tmpNode);

		while (cur!=&ServerTable.ST_SortedListPRM.PL_Head) {
			PSERVER_NODE	node = CONTAINING_RECORD (cur,
												SERVER_NODE,
												N_Links[SDB_SORTED_LIST_LINK]);
			VALIDATE_NODE(node);
			if (!IsEnumerator (node)) {
				if (tmpNode->SN_Server.Type==node->SN_Server.Type) {
					INT res = IpxNameCmp (tmpNode->SN_Server.Name,
											node->SN_Server.Name);
					if (res==0) {
						cur = cur->Flink;
						prmNode = node;
						break;
						}
					else if (res<0)
						break;
					}
				else if (tmpNode->SN_Server.Type<node->SN_Server.Type)
					break;
				}
			cur = cur->Flink;
			}

        if (AcquireServerTableList (&tmpNode->SN_HashList->HL_List, TRUE)) {
		    if (AcquireServerTableList (&ServerTable.ST_SortedListTMP, TRUE)) {
			    RemoveEntryList (&tmpNode->N_Links[SDB_SORTED_LIST_LINK]);
			    if (IsMainNode (tmpNode)) {
				    ASSERTMSG ("Node marked as sorted in temp list ",
													    !IsSortedNode (tmpNode));	
				    SetSortedNode (tmpNode);
				    InsertTailList (cur, &tmpNode->N_Links[SDB_SORTED_LIST_LINK]);
				    if (prmNode!=NULL) {
					    ASSERTMSG ("Node not marked as sorted in sorted list ",
													    IsSortedNode (prmNode));	
					    RemoveEntryList (&prmNode->N_Links[SDB_SORTED_LIST_LINK]);
					    InitializeListEntry (&prmNode->N_Links[SDB_SORTED_LIST_LINK]);
					    ResetSortedNode (prmNode);
					    }
				    }
			    else {
				    InitializeListEntry (&tmpNode->N_Links[SDB_SORTED_LIST_LINK]);
				    }


			    ReleaseServerTableList (&ServerTable.ST_SortedListTMP);
			    }
		    else
			    Sleep (SAP_ERROR_COOL_OFF_TIME);
            ReleaseServerTableList (&tmpNode->SN_HashList->HL_List);
            }
		else
			Sleep (SAP_ERROR_COOL_OFF_TIME);
		}
	ReleaseServerTableList (&ServerTable.ST_SortedListPRM);

	}					

VOID APIENTRY
UpdateSortedListWorker (
	PVOID		context
	) {
	do {
		InterlockedExchange (&ServerTable.ST_UpdatePending, 0);
		DoUpdateSortedList ();
		}
	while (InterlockedDecrement (&ServerTable.ST_UpdatePending)>=0);
	}


/*++
*******************************************************************
		U p d a t e S o r t e d L i s t

Routine Description:
	Schedules work item to update sorted list.
	Should be called whenever UpdateObject is signalled
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UpdateSortedList (
	void
	) {
	BOOL		res;
	LONGLONG	timeout=(LONGLONG)SDBSortLatency*(-10000);
	static WORKERFUNCTION	worker=&UpdateSortedListWorker;

	res = SetWaitableTimer (ServerTable.ST_UpdateTimer,
						(PLARGE_INTEGER)&timeout,
						0,			// no period
						NULL, NULL,	// no completion
						FALSE);		// no need to resume
	ASSERTMSG ("Could not set update timer ", res);
	if (InterlockedIncrement (&ServerTable.ST_UpdatePending)==0)
		ScheduleWorkItem (&worker);
	}

/*++
*******************************************************************
		P r o c e s s E x p i r a t i o n Q u e u e

Routine Description:
	Deletes expired servers from the table and set timer object to
	be signalled when next item in expiration queue is due
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessExpirationQueue (
	void
	) {
	ULONG			curTime = GetTickCount ();
	ULONG			dueTime = curTime + MAXULONG/2;
	LONGLONG		timeout;
	BOOL			res;


	if (!AcquireServerTableList (&ServerTable.ST_ExpirationQueue, TRUE))
		return ;

	while (!IsListEmpty (&ServerTable.ST_ExpirationQueue.PL_Head)) {
		PSDB_HASH_LIST	HashList;
		PSERVER_NODE	node = CONTAINING_RECORD (
								ServerTable.ST_ExpirationQueue.PL_Head.Flink,
								SERVER_NODE,
								SN_TimerLink);
		VALIDATE_SERVER_NODE(node);
		if (IsLater(node->SN_ExpirationTime,curTime)) {
			dueTime = node->SN_ExpirationTime;
			break;
			}
		
		HashList = node->SN_HashList;
			// Try to get access to hash list but do not wait because
			// we may create a deadlock
		if (!AcquireServerTableList (&HashList->HL_List, FALSE)) {
				// Hash list is locked, we'll have to release the timer queue
				// and reacquire it again after securing the hash list
			ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);
			if (AcquireServerTableList (&HashList->HL_List, TRUE)) {
				if (AcquireServerTableList (&ServerTable.ST_ExpirationQueue, TRUE)) {
						// Make sure entry is still there
					if (ServerTable.ST_ExpirationQueue.PL_Head.Flink
												!=&node->SN_TimerLink) {
							// Gone already, go to the next one
						ReleaseServerTableList (&HashList->HL_List);
						continue;
						}
					}
				else {
						// Failure to regain expiration queue,
						// tell them to retry in a little while
					ReleaseServerTableList (&HashList->HL_List);
					return ;
					}
				}
			else
				// Failure to acquire hash list,
				// tell them to retry in a little while
				return ;
			}
			// At this point we have hash list and expiration queue locks
			// we can proceed with deletion
		RemoveEntryList (&node->SN_TimerLink);
		InitializeListEntry (&node->SN_TimerLink);
		if (node->SN_HopCount!=IPX_MAX_HOP_COUNT) {
				// It might have been already prepeared for deletion
			if (AcquireAllLocks ()) { // Need to have all locks before changing
									// node info
				node->SN_HopCount = IPX_MAX_HOP_COUNT;
				if (IsMainNode (node)) {
					if (IsListEmpty (&node->SN_ServerLink))
						DeleteMainNode (node);
					else
						ChangeMainNode (
							node,
							CONTAINING_RECORD (
								node->SN_ServerLink.Flink,
								SERVER_NODE,
								SN_ServerLink),
							NULL);
					}
				else
					DeleteNode (node);

				ReleaseAllLocks ();
				}
			}
		ReleaseServerTableList (&HashList->HL_List);
		}
	ReleaseServerTableList (&ServerTable.ST_ExpirationQueue);

	timeout = (LONGLONG)(dueTime-curTime)*(-10000);
	res = SetWaitableTimer (ServerTable.ST_ExpirationTimer,
					(PLARGE_INTEGER)&timeout,
					0,				// no period
					NULL, NULL,		// no completion
					FALSE);			// no need to resume
	ASSERTMSG ("Could not set expiration timer ", res);
	}

			
			

						
/*++
*******************************************************************
		Q u e r y S e r v e r

Routine Description:
	Checks if server with given type and name exists in the table
	Returns TRUE if it does and fills out requested server info
	with data of the best entry for the server
Arguments:
	Type - server type
	Name - server name
	Server - buffer in which to put server info
	InterfaceIndex - buffer in which to put server interface index
	Protocol - buffer in which to put server protocol
	ObjectID - buffer in which to put server object id (number that uniquely
			identifies server (the whole set of entries, not just the best
			one) in the table; it is valid for very long but FINITE period
			of time)
Return Value:
	TRUE	- server was found
	FALSE	- server was not found or operation failed (call GetLastError()
			to find out the reason for failure if any)

*******************************************************************
--*/
BOOL
QueryServer (
	IN 	USHORT					Type,
	IN 	PUCHAR					Name,
	OUT	PIPX_SERVER_ENTRY_P		Server OPTIONAL,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL,
	OUT PULONG					ObjectID OPTIONAL
	) {
	PSDB_HASH_LIST			HashList;
	PLIST_ENTRY				cur;
	PSERVER_NODE			theNode = NULL;
	INT						res;

	if (Name[0]==0) {
		Trace (DEBUG_SERVERDB, "Illigal server name in QueryServer.");
		SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
		}

	HashList = &ServerTable.ST_HashLists[HashFunction (Name)];

	if (!AcquireServerTableList (&HashList->HL_List, TRUE)) {
		SetLastError (ERROR_GEN_FAILURE);
		return FALSE;
		}

	cur = HashList->HL_List.PL_Head.Flink;
	while (cur!=&HashList->HL_List.PL_Head) {
		PSERVER_NODE	node = CONTAINING_RECORD (cur,
										SERVER_NODE,
										N_Links[SDB_HASH_TABLE_LINK]);
		VALIDATE_NODE(node);
		if (!IsEnumerator (node) && !IsDisabledNode (node)
				&& (node->SN_Server.HopCount < IPX_MAX_HOP_COUNT)) {
			if (Type == node->SN_Server.Type) {
				res = IpxNameCmp (Name, node->SN_Server.Name);
				if (res==0) {
					theNode = node;
					break;
					}
				else if (res<0)
					break;
				}
			else if (Type<node->SN_Server.Type)
				break;
			}
		cur = cur->Flink;
		}

	if (theNode!=NULL) {
		if (ARGUMENT_PRESENT (Server))
			IpxServerCpy (Server, &theNode->SN_Server);
		if (ARGUMENT_PRESENT (InterfaceIndex))
			*InterfaceIndex = theNode->SN_InterfaceIndex;
		if (ARGUMENT_PRESENT (Protocol))
			*Protocol = theNode->SN_Protocol;
		if (ARGUMENT_PRESENT (ObjectID)) {
			if (theNode->SN_ObjectID==SDB_INVALID_OBJECT_ID)
				theNode->SN_ObjectID = GenerateUniqueID (theNode->SN_HashList);
			*ObjectID = theNode->SN_ObjectID;
			}
		res = TRUE;
		}
	else {
		SetLastError (NO_ERROR);
		res = FALSE;
		}

	ReleaseServerTableList (&HashList->HL_List);
	return res==TRUE;
	}		

/*++
*******************************************************************
		G e t S e r v e r F r o m I D

Routine Description:
	Returns info for server with specified ID
Arguments:
	ObjectID - server object id (number that uniquely
			identifies server in the table, it is valid for very long
			but FINITE amount of time)
	Server - buffer in which to put server info
	InterfaceIndex - buffer in which to put server interface index
	Protocol - buffer in which to put server protocol
Return Value:
	TRUE	- server was found
	FALSE	- server was not found or operation failed (call GetLastError()
			to find out the reason for failure if any)

*******************************************************************
--*/
BOOL
GetServerFromID (
	IN 	ULONG					ObjectID,
	OUT	PIPX_SERVER_ENTRY_P		Server OPTIONAL,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL
	) {
	PSDB_HASH_LIST			HashList;
	PLIST_ENTRY				cur;
	PSERVER_NODE			theNode = NULL;
	INT						res;

	HashList = &ServerTable.ST_HashLists[ObjectID%SDB_NAME_HASH_SIZE];

	if (!AcquireServerTableList (&HashList->HL_List, TRUE)) {
		SetLastError (ERROR_GEN_FAILURE);
		return FALSE;
		}

	cur = HashList->HL_List.PL_Head.Flink;
	while (cur!=&HashList->HL_List.PL_Head) {
		PSERVER_NODE	node = CONTAINING_RECORD (cur,
										SERVER_NODE,
										N_Links[SDB_HASH_TABLE_LINK]);
		VALIDATE_NODE(node);
		if (!IsEnumerator (node) && !IsDisabledNode (node)
				&& (node->SN_HopCount < IPX_MAX_HOP_COUNT)
				&& (node->SN_ObjectID == ObjectID)) {
			theNode = node;
			break;
			}
		cur = cur->Flink;
		}

	if (theNode!=NULL) {
		if (ARGUMENT_PRESENT (Server))
			IpxServerCpy (Server, &theNode->SN_Server);
		if (ARGUMENT_PRESENT (InterfaceIndex))
			*InterfaceIndex = theNode->SN_InterfaceIndex;
		if (ARGUMENT_PRESENT (Protocol))
			*Protocol = theNode->SN_Protocol;
		res = TRUE;
		}
	else {
		SetLastError (NO_ERROR);
		res = FALSE;
		}

	ReleaseServerTableList (&HashList->HL_List);
	return res==TRUE;
	}		
	
/*++
*******************************************************************
		C r e a t e L i s t E n u m e r a t o r

Routine Description:
	Creates enumerator node that allows scanning through the server
	table lists
Arguments:
	ListIdx	- index of list through which to scan (currently supported lists
			are: hash lists, interface lists, type lists,
			changed servers queue
	Type - limits enumeration to servers of specific type and
			indentifies a particular type list if index is SDB_TYPE_LIST_IDX
			(use 0xFFFF to return all server and/or to go through all
			 type lists)
	Name - limits enumeration to servers with certain name if present
	InterfaceIndex - limits enumeration to servers of specific interface and
			indentifies a particular interface list if index
			is SDB_INTF_LIST_IDX (use INVALID_INTERFACE_INDEX to return all
			server and/or to go through all interface lists)
	Protocol - limits enumeration to servers of certain protocol (0xFFFFFFFF
			- all protocols)
	Flags	 - identifies additional conditions on entries enumerated:
			SDB_MAIN_NODE_FLAG	- only best servers
			SDB_DISABLED_NODE_FLAG - include disabled servers
Return Value:
	Handle that represents the enumeration node
	NULL if specified list does not exist or operation failed
		 (call GetLastError () for the reason of failure if any)

*******************************************************************
--*/
HANDLE
CreateListEnumerator (
	IN	INT						ListIdx,
	IN	USHORT					Type,
	IN	PUCHAR					Name OPTIONAL,
	IN	ULONG					InterfaceIndex,
	IN 	ULONG					Protocol,
	IN	INT						Flags
	) {
	HANDLE			hEnum;
#define enumNode ((PENUMERATOR_NODE)hEnum)

	hEnum = (HANDLE)GlobalAlloc (GPTR, sizeof (ENUMERATOR_NODE));

	if (hEnum==NULL) {
		Trace (DEBUG_FAILURES, 
				"File: %s, line: %ld. Can't allocate enumerator node (gle:%ld).",
										__FILE__, __LINE__, GetLastError ());
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}

	InitializeListEntry (&enumNode->N_Links[ListIdx]);
	enumNode->N_NodeFlags = SDB_ENUMERATION_NODE;
	enumNode->EN_LinkIdx = ListIdx;
	enumNode->EN_InterfaceIndex = InterfaceIndex;
	enumNode->EN_Protocol = Protocol;
	enumNode->EN_Signature = SDB_ENUMERATOR_NODE_SIGNATURE;
	enumNode->EN_Type = Type;
	if (ARGUMENT_PRESENT(Name)) {
		if (Name[0]!=0) {
			enumNode->EN_ListLock = &ServerTable.ST_HashLists[HashFunction(Name)].HL_List;
			IpxNameCpy (enumNode->EN_Name, Name);
			}
		else {
			Trace (DEBUG_SERVERDB, "Illigal server name in CreateListEnumerator.");
			GlobalFree (enumNode);
			SetLastError (ERROR_INVALID_PARAMETER);
			return NULL;
			}
		}
	else
		enumNode->EN_Name[0] = 0;
	enumNode->EN_Flags = Flags;

	switch (ListIdx) {
		case SDB_HASH_TABLE_LINK:
			if (enumNode->EN_Name[0]==0)
				enumNode->EN_ListLock = &ServerTable.ST_HashLists[0].HL_List;
			break;
		case SDB_CHANGE_QUEUE_LINK:
			enumNode->EN_ListLock = &ServerTable.ST_ChangedSvrsQueue;
			break;
		case SDB_INTF_LIST_LINK:
			enumNode->EN_ListLock = &ServerTable.ST_IntfList;
			break;
		case SDB_TYPE_LIST_LINK:
			enumNode->EN_ListLock = &ServerTable.ST_TypeList;
			break;
		default:
			ASSERTMSG ("Invalid list index. ", FALSE);
			GlobalFree (hEnum);
			SetLastError (ERROR_INVALID_PARAMETER);
			return NULL;
		}

	if (!AcquireServerTableList (enumNode->EN_ListLock, TRUE)) {
		GlobalFree (hEnum);
		SetLastError (ERROR_GEN_FAILURE);
		return NULL;
		}

		// All enumeration go in the direction opposite to 
		// direction of insertion to exclude the possibility of
		// returning the same server twice (this may happen if
		// server entry gets deleted and another one is inserted in
		// the same place while client processes the result of
		// enumeration callback
	switch (ListIdx) {
		case SDB_HASH_TABLE_LINK:
			enumNode->EN_ListHead = &enumNode->EN_ListLock->PL_Head;
				// Insert in the tail of the list -> we go backwards
			InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
			break;
		case SDB_CHANGE_QUEUE_LINK:
			enumNode->EN_ListHead = &ServerTable.ST_ChangedSvrsQueue.PL_Head;
				// Insert in the head, because we want client to see only
				// the newly changed servers that will be inserted in the
				// bottom (head) of the list
			InsertHeadList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
				// Increment number of enumerating clients (we remove deleted
				// server entries from the change queue once all enumerating clients
				// get a chance to see it)
			if (ServerTable.ST_LastEnumerator==NULL)
				ServerTable.ST_LastEnumerator = hEnum;
			break;
		case SDB_INTF_LIST_LINK:
			if (enumNode->EN_InterfaceIndex==INVALID_INTERFACE_INDEX) {
				if (!IsListEmpty (&ServerTable.ST_IntfList.PL_Head)) {
					PINTF_NODE intfNode = CONTAINING_RECORD (
												ServerTable.ST_IntfList.PL_Head.Flink,
												INTF_NODE,
												IN_Link);
					enumNode->EN_ListHead = &intfNode->IN_Head;
						// Insert in the tail of the list -> we go backwards
					InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
					break;
					}
					// No interface lists - fall through to error handling
				}
			else {
				enumNode->EN_ListHead = FindIntfLink (InterfaceIndex);
				if (enumNode->EN_ListHead!=NULL) {
						// Insert in the tail of the list -> we go backwards
					InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
					break;
					}
				
				// Interface list could not be found -
				// fall through to error handling
				}	
			GlobalFree (hEnum);
			SetLastError (NO_ERROR);
			hEnum = NULL;
			break;
		case SDB_TYPE_LIST_LINK:
			if (enumNode->EN_Type==0xFFFF) {
				if (!IsListEmpty (&ServerTable.ST_TypeList.PL_Head)) {
					PTYPE_NODE typeNode = CONTAINING_RECORD (
											ServerTable.ST_TypeList.PL_Head.Flink,
											TYPE_NODE,
											TN_Link);
					enumNode->EN_ListHead = &typeNode->TN_Head;
						// Insert in the tail of the list -> we go backwards
					InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
					break;
					}
				// No type lists - fall through to error handling
				}
			else {
				enumNode->EN_ListHead = FindTypeLink (Type);
				if (enumNode->EN_ListHead!=NULL) {
					// Insert in the tail of the list -> we go backwards
					InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
					break;
					}
				// Type list could not be found -
				// fall through to error handling
				}
			GlobalFree (hEnum);
			SetLastError (NO_ERROR);
			hEnum = NULL;
		}

    if (enumNode)
    {
    	ReleaseServerTableList (enumNode->EN_ListLock);
    }    	
#undef enumNode
	return hEnum;
	}


/*++
*******************************************************************
		E n u m e r a t e S e r v e r s

Routine Description:
	Calls callback routine consequtively for servers in the enumerated
	list until told to stop by the callback or end of list is reached
Arguments:
	Enumerator - handle obtained from CreateListEnumerator
	CallBackProc - function to call for each server in the list
	CBParam	 - extra parameter to pass to callback function
Return Value:
	TRUE - if stopped by the callback
	FALSE - if end of list is reached or operation failed (call GetLastError ()
			to find out the reason of failure)

*******************************************************************
--*/
BOOLEAN
EnumerateServers (
	IN	HANDLE						Enumerator,
	IN	EnumerateServersCallBack	CallBackProc,
	IN	LPVOID						CBParam
	) {
#define enumNode ((PENUMERATOR_NODE)Enumerator)	
	BOOL				res=FALSE, bNeedHashLock;
	PSERVER_NODE		node;
	ULONG				releaseTime;

    // The following callbacks need to be invoked with hash table
    // lock held because they modify/delete nodes
    bNeedHashLock = (enumNode->EN_LinkIdx!=SDB_HASH_TABLE_LINK)
            && ((CallBackProc==DeleteAllServersCB)
                || (CallBackProc==DeleteNonLocalServersCB)
                || (CallBackProc==EnableAllServersCB)
                || (CallBackProc==DisableAllServersCB)
                || (CallBackProc==ConvertToStaticCB)
                || (CallBackProc==DeleteAllServersCB));

	VALIDATE_ENUMERATOR_NODE(Enumerator);
	if (!AcquireServerTableList (enumNode->EN_ListLock, TRUE)) {
		SetLastError (ERROR_GEN_FAILURE);
		return FALSE;
		}
	releaseTime = GetTickCount ()+SDB_MAX_LOCK_HOLDING_TIME;

	do { // Loop till told to stop by the callback

		// Don't let client hold the list for too long
		if (IsLater (GetTickCount (),releaseTime)) {
			ReleaseServerTableList (enumNode->EN_ListLock);
#if DBG
			Trace (DEBUG_SERVERDB,
				"Held enumeration lock (%d list) for %ld extra msec",
				enumNode->EN_LinkIdx, GetTickCount ()-releaseTime);
#endif
			AcquireServerTableList (enumNode->EN_ListLock, TRUE);
			releaseTime = GetTickCount ()+SDB_MAX_LOCK_HOLDING_TIME;
			}
			// Check if end of the list is reached
		while (enumNode->N_Links[enumNode->EN_LinkIdx].Blink
										==enumNode->EN_ListHead) {
				// Check if we asked and can go to another list
			switch (enumNode->EN_LinkIdx) {
				case SDB_HASH_TABLE_LINK:
					if ((enumNode->EN_Name[0]==0)
							&&(enumNode->EN_ListHead
								<&ServerTable.ST_HashLists[SDB_NAME_HASH_SIZE-1].HL_List.PL_Head)) {
						RemoveEntryList (
								&enumNode->N_Links[enumNode->EN_LinkIdx]);
						ReleaseServerTableList (enumNode->EN_ListLock);
						enumNode->EN_ListLock = &(CONTAINING_RECORD (
												enumNode->EN_ListLock,
												SDB_HASH_LIST,
												HL_List)+1)->HL_List;
						enumNode->EN_ListHead = &enumNode->EN_ListLock->PL_Head;
						if (!AcquireServerTableList (enumNode->EN_ListLock, TRUE)) {
						    InitializeListEntry (
								    &enumNode->N_Links[enumNode->EN_LinkIdx]);
							SetLastError (ERROR_GEN_FAILURE);
							return FALSE;
							}
						releaseTime = GetTickCount ()
											+SDB_MAX_LOCK_HOLDING_TIME;
						InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
						continue;
						}
					break;
				case SDB_INTF_LIST_LINK:
					if (enumNode->EN_InterfaceIndex
								==INVALID_INTERFACE_INDEX) {
						PINTF_NODE	intfNode = CONTAINING_RECORD (
												enumNode->EN_ListHead,
												INTF_NODE,
												IN_Head);
						if (intfNode->IN_Link.Flink
									!=&ServerTable.ST_IntfList.PL_Head) {
							enumNode->EN_ListHead = &(CONTAINING_RECORD (
												intfNode->IN_Link.Flink,
												INTF_NODE,
												IN_Link)->IN_Head);		
							RemoveEntryList (
								&enumNode->N_Links[enumNode->EN_LinkIdx]);
							InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
							continue;
							}
						}
					break;
				case SDB_TYPE_LIST_LINK:
					if (enumNode->EN_Type == 0xFFFF) {
						PTYPE_NODE	typeNode = CONTAINING_RECORD (
												enumNode->EN_ListHead,
												TYPE_NODE,
												TN_Head);
						if (typeNode->TN_Link.Flink
									!=&ServerTable.ST_TypeList.PL_Head) {
							enumNode->EN_ListHead = &(CONTAINING_RECORD (
												typeNode->TN_Link.Flink,
												TYPE_NODE,
												TN_Link)->TN_Head);		
							RemoveEntryList (
								&enumNode->N_Links[enumNode->EN_LinkIdx]);
							InsertTailList (enumNode->EN_ListHead,
									&enumNode->N_Links[enumNode->EN_LinkIdx]);
							continue;
							}
						}
					break;
				case SDB_CHANGE_QUEUE_LINK:
					break;
				default:
					ASSERTMSG ("Unsupported list index ", FALSE);
				}


				// No more lists or not asked to check all of them
			ReleaseServerTableList (enumNode->EN_ListLock);
			SetLastError (NO_ERROR);
			return FALSE;
			}

		node = CONTAINING_RECORD (enumNode->N_Links[enumNode->EN_LinkIdx].Blink,
								SERVER_NODE,
								N_Links[enumNode->EN_LinkIdx]);
		VALIDATE_NODE(node);
		RemoveEntryList (&enumNode->N_Links[enumNode->EN_LinkIdx]);
		InsertTailList (&node->N_Links[enumNode->EN_LinkIdx],
								&enumNode->N_Links[enumNode->EN_LinkIdx]);
		if (!IsEnumerator(node)
				&& ((enumNode->EN_Flags & SDB_DISABLED_NODE_FLAG) || !IsDisabledNode (node))
				&& (!(enumNode->EN_Flags & SDB_MAIN_NODE_FLAG) || IsMainNode (node))
				&& ((enumNode->EN_InterfaceIndex==INVALID_INTERFACE_INDEX)
					|| (enumNode->EN_InterfaceIndex==node->SN_InterfaceIndex))
				&& ((enumNode->EN_Type==0xFFFF)
					|| (enumNode->EN_Type==node->SN_Type))
				&& ((enumNode->EN_Protocol==0xFFFFFFFF)
					|| (enumNode->EN_Protocol==node->SN_Protocol))
				&& ((enumNode->EN_Name[0]==0)
					|| (IpxNameCmp(enumNode->EN_Name, node->SN_Name)!=0))
				) {

            PSDB_HASH_LIST	HashList;

            if (bNeedHashLock) {
		        HashList = node->SN_HashList;
                    // Release the non-hash table lock to prevent deadlock
		        ReleaseServerTableList (enumNode->EN_ListLock);
                if (!AcquireServerTableList (&HashList->HL_List, TRUE)) {
            	    SetLastError (ERROR_GEN_FAILURE);
                    return FALSE;
                    }
                    // Make sure the node was not deleted when we were
                    // acquiring hash lock
                if (enumNode->N_Links[enumNode->EN_LinkIdx].Flink
                        !=&node->N_Links[enumNode->EN_LinkIdx]) {
                        // Node is gone, continue with the next one
                    ReleaseServerTableList (&HashList->HL_List);
                    if (AcquireServerTableList (enumNode->EN_ListLock, TRUE))
                        continue;
                    else {
            		    SetLastError (ERROR_GEN_FAILURE);
                        return FALSE;
                        }
                    }
                }

				// Check if we need to go through server list
			if (!(enumNode->EN_Flags & SDB_MAIN_NODE_FLAG)
				&& !IsListEmpty (&node->SN_ServerLink)
				&& (enumNode->EN_LinkIdx!=SDB_INTF_LIST_LINK)
					// Interface lists contain all entries anyway
					) {
				PLIST_ENTRY	    cur;
                BOOL            bMainNode;
                cur = node->SN_ServerLink.Blink;
				do {
					PSERVER_NODE    node1 = CONTAINING_RECORD (cur,
											SERVER_NODE,
											SN_ServerLink);
					VALIDATE_SERVER_NODE(node1);
                    bMainNode = IsMainNode (node1);  // It may be deleted in
                                                    // callback
					cur = cur->Blink;
					if (CallBackProc!=NULL) {
						res = (*CallBackProc) (CBParam,
									&node1->SN_Server,
									node1->SN_InterfaceIndex,
									node1->SN_Protocol,
									node1->SN_AdvertisingNode,
									node1->N_NodeFlags
									);
						}
					}
				while (res==FALSE && !bMainNode);

                }

				// Call them with just best entry
			else if (CallBackProc!=NULL) {
				res = (*CallBackProc) (CBParam,
							&node->SN_Server,
							node->SN_InterfaceIndex,
							node->SN_Protocol,
							node->SN_AdvertisingNode,
							node->N_NodeFlags
							);
				}


            if (res==-1) {
                if (bNeedHashLock)
                    ReleaseServerTableList (&HashList->HL_List);
                else
                    ReleaseServerTableList (enumNode->EN_ListLock);
            	SetLastError (ERROR_GEN_FAILURE);
                return FALSE;

                }
            else if (bNeedHashLock) {
                ReleaseServerTableList (&HashList->HL_List);
                if (!AcquireServerTableList (enumNode->EN_ListLock, TRUE)) {
            		SetLastError (ERROR_GEN_FAILURE);
                    return FALSE;
                    }
			    }

			}
			// If enumerating through the change queue, this might be
			// the last who needs to know about deleted server entry,
			// so it will have to actually initiate deletion
		if ((Enumerator==ServerTable.ST_LastEnumerator)
					// make sure the node is still there
				&& (enumNode->N_Links[SDB_CHANGE_QUEUE_LINK].Flink
						== &node->N_Links[SDB_CHANGE_QUEUE_LINK])) {
			if (IsEnumerator(node))
				ServerTable.ST_LastEnumerator = (HANDLE)node;
			else if (node->SN_HopCount==IPX_MAX_HOP_COUNT) {
				ASSERTMSG ("Node being reset is not main ", IsMainNode (node));
				ResetMainNode (node);
				RemoveEntryList (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
				InitializeListEntry (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
                ASSERTMSG ("Deleted node in change queue has subnodes ",
                                !IsListEntry (&node->SN_ServerLink));
				if (AcquireServerTableList (&ServerTable.ST_DeletedList, TRUE)) {
					InsertTailList (&ServerTable.ST_DeletedList.PL_Head,
							&node->SN_ServerLink);
					ServerTable.ST_DeletedListCnt += 1;
					if (ServerTable.ST_DeletedListCnt==SDBMaxUnsortedServers)
						UpdateSortedList ();
					ReleaseServerTableList (&ServerTable.ST_DeletedList);
					}
					// If we fail in locking we just let it hang around
					// (at least we won't risk damaging the list)
				}
			}
		}
	while (!res);

    ASSERT (res==TRUE);

	ReleaseServerTableList (enumNode->EN_ListLock);
	return TRUE;
#undef enumNode
	}

/*++
*******************************************************************
		G e t O n e C B

Routine Description:
	Callback proc for EnumerateServers.
	Copies the first entry with which it is called and stops enumeration
	by returning TRUE
Arguments:
	CBParam - pointer to buffer to which to copy service info
	Server, InterfaceIndex, Protocol, AdvertisingNode - service data
	Flags - ignored
Return Value:
	TRUE
*******************************************************************
--*/
BOOL 
GetOneCB (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define Service ((PIPX_SERVICE)CBParam)
	IpxServerCpy (&Service->Server, Server);
	Service->InterfaceIndex = InterfaceIndex;
	Service->Protocol = Protocol;
	return TRUE;
#undef Service
	} 

/*++
*******************************************************************
		D e l e t e A l l S e r v e r s C B

Routine Description:
	Callback proc for EnumerateServers that deletes all server
	entries with which it is called
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE - deletion succeded, continue
	TRUE - failure to lock SDB list, stop enumeration and return FALSE
		to client (error code is set in this routine)
*******************************************************************
--*/
BOOL
DeleteAllServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
	PSERVER_NODE	node = CONTAINING_RECORD (Server, SERVER_NODE, SN_Server);
	
	if (AcquireAllLocks ()) {
		node->SN_HopCount = IPX_MAX_HOP_COUNT;
		if (IsMainNode (node)) {
			if (IsListEmpty (&node->SN_ServerLink))
				DeleteMainNode (node);
			else
				ChangeMainNode (
					node,
					CONTAINING_RECORD (
						node->SN_ServerLink.Flink,
						SERVER_NODE,
						SN_ServerLink),
					NULL);
			}
		else
			DeleteNode (node);
		ReleaseAllLocks ();
    	return FALSE;
		}
    else {
        return -1;
        }
	} 


BOOL
DeleteNonLocalServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {

	if (InterfaceIndex!=INTERNAL_INTERFACE_INDEX)
		return DeleteAllServersCB (CBParam, Server, InterfaceIndex, Protocol,
									AdvertisingNode, Flags);
	else
		return FALSE;
	}


/*++
*******************************************************************
		E n a b l e A l l S e r v e r s C B

Routine Description:
	Callback proc for EnumerateServers that reenables all server
	entries with which it is called
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE - deletion succeded, continue
	TRUE - failure to lock SDB list, stop enumeration and return FALSE
		to client (error code is set in this routine)
*******************************************************************
--*/
BOOL
EnableAllServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
	PSERVER_NODE	node = CONTAINING_RECORD (Server, SERVER_NODE, SN_Server);
	
	if (AcquireAllLocks ()) {
		if (IsDisabledNode (node)) {
	        ResetDisabledNode (node);
	        if (!IsMainNode (node)) {
		        PSERVER_NODE	node1 = node;
		        do {
			        node1 = CONTAINING_RECORD (
				        node1->SN_ServerLink.Blink,
				        SERVER_NODE,
				        SN_ServerLink);
			        }
		        while (!IsMainNode (node1)
			        && (IsDisabledNode(node1)
				        || (node1->SN_HopCount>node->SN_HopCount)));
		        if (IsMainNode (node1) && (node1->SN_HopCount>node->SN_HopCount))
			        ChangeMainNode (node1, node, NULL);
		        else {
			        RemoveEntryList (&node->SN_ServerLink);
			        InsertHeadList (&node1->SN_ServerLink, &node->SN_ServerLink);
			        }
		        }
	        }
		ReleaseAllLocks ();
        return FALSE;
		}
    else {
	    return -1;
	    }
	} 
/*++
*******************************************************************
		D i s a b l e A l l S e r v e r s C B

Routine Description:
	Callback proc for EnumerateServers that disables all server
	entries with which it is called
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE - deletion succeded, continue
	TRUE - failure to lock SDB list, stop enumeration and return FALSE
		to client (error code is set in this routine)
*******************************************************************
--*/
BOOL
DisableAllServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
	PSERVER_NODE	node = CONTAINING_RECORD (Server, SERVER_NODE, SN_Server);
	
	if (AcquireAllLocks ()) {
		if (!IsDisabledNode (node)) {
	        SetDisabledNode (node);
	        if (IsMainNode (node)) {
		        if (!IsListEmpty (&node->SN_ServerLink)) {
			        ChangeMainNode (
				        node,
				        CONTAINING_RECORD (
					        node->SN_ServerLink.Flink,
					        SERVER_NODE,
					        SN_ServerLink),
					        NULL);
			        }
		        }
	        else {
		        PSERVER_NODE	node1 = node;
		        do {
			        node1 = CONTAINING_RECORD (
				        node1->SN_ServerLink.Blink,
				        SERVER_NODE,
				        SN_ServerLink);
			        }
		        while (!IsMainNode (node1)
			        && !IsDisabledNode(node1));
		        RemoveEntryList (&node->SN_ServerLink);
		        InsertTailList (&node1->SN_ServerLink, &node->SN_ServerLink);
		        }
	        }
		ReleaseAllLocks ();
		}
	else {
		return -1;
		}
            return NO_ERROR;
	} 

/*++
*******************************************************************
		C o n v e r t T o S t a t i c C B

Routine Description:
	Callback proc for EnumerateServers that converts all server
	entries with which it is called to static (changes protocol field to
	static)
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE
*******************************************************************
--*/
BOOL
ConvertToStaticCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define enumNode ((PENUMERATOR_NODE)CBParam)
	PSERVER_NODE	node = CONTAINING_RECORD (Server, SERVER_NODE, SN_Server);
	node->SN_Protocol = IPX_PROTOCOL_STATIC;
    IpxNodeCpy (node->SN_AdvertisingNode, IPX_BCAST_NODE);
#undef enumNode
	return FALSE;
	} 


/*++
*******************************************************************
		D e l e t e L i s t E n u m e r a t o r

Routine Description:
	Releases resources associated with list enumerator (this includes
	server entries that are queued to change queue before being deleted)
Arguments:
	Enumerator - handle obtained from CreateListEnumerator
Return Value:
	None

*******************************************************************
--*/
void
DeleteListEnumerator (
	IN HANDLE 					Enumerator
	) {
#define enumNode ((PENUMERATOR_NODE)Enumerator)	

	if (!AcquireServerTableList (enumNode->EN_ListLock, TRUE))
		return;

	VALIDATE_ENUMERATOR_NODE(Enumerator);
	if (Enumerator==ServerTable.ST_LastEnumerator) {
				// Release all servers marked for deletion
		PLIST_ENTRY	cur = enumNode->N_Links[enumNode->EN_LinkIdx].Blink;
            // Reset to note that there are no enumerators and
            // nodes have to be deleted rigth away.
        ServerTable.ST_LastEnumerator = NULL;

		while (cur!=enumNode->EN_ListHead) {
			PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											N_Links[enumNode->EN_LinkIdx]);
			VALIDATE_NODE(node);
			cur = cur->Blink;
			if (IsEnumerator (node)) {
				ServerTable.ST_LastEnumerator = (HANDLE)node;
				break;
			}
			else if (node->SN_HopCount==IPX_MAX_HOP_COUNT) {
				ASSERTMSG ("Node being reset is not main ", IsMainNode (node));
				ResetMainNode (node);
				RemoveEntryList (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
				InitializeListEntry (&node->N_Links[SDB_CHANGE_QUEUE_LINK]);
                ASSERTMSG ("Deleted node in change queue has subnodes ",
                                !IsListEntry (&node->SN_ServerLink));
				if (AcquireServerTableList (&ServerTable.ST_DeletedList, TRUE)) {
					InsertTailList (&ServerTable.ST_DeletedList.PL_Head,
												&node->SN_ServerLink);
					ServerTable.ST_DeletedListCnt += 1;
					if (ServerTable.ST_DeletedListCnt==SDBMaxUnsortedServers)
						UpdateSortedList ();
					ReleaseServerTableList (&ServerTable.ST_DeletedList);
					}
					// If we fail in locking we just let it hang around
					// (at least we won't risk damaging the list)
				}	
			}
		}

	RemoveEntryList (&enumNode->N_Links[enumNode->EN_LinkIdx]);
	if ((enumNode->EN_LinkIdx==SDB_INTF_LIST_LINK)
			&& IsListEmpty (enumNode->EN_ListHead)) {
		PINTF_NODE	intfNode = CONTAINING_RECORD (
								enumNode->EN_ListHead,
								INTF_NODE,
								IN_Head);
		RemoveEntryList (&intfNode->IN_Link);
		GlobalFree (intfNode);
		}
	ReleaseServerTableList (enumNode->EN_ListLock);
	GlobalFree (Enumerator);
#undef enumNode
	}

/*++
*******************************************************************
	G e t F i r s t S e r v e r

Routine Description:
	Find and return first service in the order specified by the ordering method.
	Search is limited only to certain types of services as specified by the
	exclusion flags end corresponding fields in Server parameter.
	Returns ERROR_NO_MORE_ITEMS if there are no services in the
	table that meet specified criteria.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to specified criteria
 	Server - On input: criteria for exclusion flags
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
GetFirstServer (
    IN  DWORD					OrderingMethod,
    IN  DWORD					ExclusionFlags,
    IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT ULONG				*InterfaceIndex,
	IN OUT ULONG				*Protocol
    ) {
	DWORD				status=NO_ERROR;
	PSDB_HASH_LIST		HashList;
	PPROTECTED_LIST		list;
	INT					link;
	PLIST_ENTRY			cur;

	switch (OrderingMethod) {
		case STM_ORDER_BY_TYPE_AND_NAME:
			break;
		case STM_ORDER_BY_INTERFACE_TYPE_NAME:
			if (!(ExclusionFlags & STM_ONLY_THIS_INTERFACE)) {
				if (!AcquireServerTableList (&ServerTable.ST_IntfList, TRUE))
					return ERROR_GEN_FAILURE;
			
				if (IsListEmpty (&ServerTable.ST_IntfList.PL_Head)) {
					ReleaseServerTableList (&ServerTable.ST_IntfList);
					return ERROR_NO_MORE_ITEMS;
					}
				*InterfaceIndex = CONTAINING_RECORD (
										ServerTable.ST_IntfList.PL_Head.Flink,
										INTF_NODE,
										IN_Link)->IN_InterfaceIndex;
				ReleaseServerTableList (&ServerTable.ST_IntfList);
				}
			break;
		default:
			ASSERTMSG ("Invalid ordering method specified ", FALSE);
			return ERROR_INVALID_PARAMETER;
		}



	if (ExclusionFlags & STM_ONLY_THIS_NAME) {
		HashList = &ServerTable.ST_HashLists[HashFunction (Server->Name)];
		if (!AcquireServerTableList (&HashList->HL_List, TRUE))
			return ERROR_GEN_FAILURE;
		list = &HashList->HL_List;
		link = SDB_HASH_TABLE_LINK;
		}
	else {
		if (ServerTable.ST_UpdatePending==-1)
			DoUpdateSortedList ();
		if (!AcquireServerTableList (&ServerTable.ST_SortedListPRM, TRUE))
			return ERROR_GEN_FAILURE;
		list = &ServerTable.ST_SortedListPRM;
		link = SDB_SORTED_LIST_LINK;
		}
    cur = list->PL_Head.Flink;

	while (TRUE) {

			// We may need to loop through interface lists
		status = DoFindNextNode (cur,
					list,
					link,
					OrderingMethod==STM_ORDER_BY_INTERFACE_TYPE_NAME
						? ExclusionFlags|STM_ONLY_THIS_INTERFACE
						: ExclusionFlags,
					Server,
					InterfaceIndex,
					Protocol,
					NULL
					);
			// If looping through all interfaces in interface order and
			// no items are available, we may need to check another interface
		if ((status==ERROR_NO_MORE_ITEMS)
				&& (OrderingMethod==STM_ORDER_BY_INTERFACE_TYPE_NAME)
				&& !(ExclusionFlags&STM_ONLY_THIS_INTERFACE)) {
			if (!AcquireServerTableList (&ServerTable.ST_IntfList, TRUE)) {
				status = ERROR_GEN_FAILURE;
				break;
				}
			
				// Get next interface in interface list
			cur = ServerTable.ST_IntfList.PL_Head.Flink;
			while (cur!=&ServerTable.ST_IntfList.PL_Head) {
				PINTF_NODE	intfNode = CONTAINING_RECORD (cur,
													INTF_NODE,
													IN_Link);
				if (*InterfaceIndex<intfNode->IN_InterfaceIndex) {
					*InterfaceIndex = intfNode->IN_InterfaceIndex;
					break;
					}
				cur = cur->Flink;
				}
			ReleaseServerTableList (&ServerTable.ST_IntfList);
			if (cur!=&ServerTable.ST_IntfList.PL_Head) {
					// Restart the search with another interface index
				cur = list->PL_Head.Flink;
				continue;
				}
			}

		break;
		}

	if (link==SDB_HASH_TABLE_LINK)
		ReleaseServerTableList (&HashList->HL_List);
	else /* if (link==SDB_SORTED_LIST_LINK) */
		ReleaseServerTableList (&ServerTable.ST_SortedListPRM);

	return status;
	}

/*++
*******************************************************************
	G e t N e x t S e r v e r
Routine Description:
	Find and return next service in the order specified by the ordering method.
	Search starts from specified service and is limited only to certain types
	of services as specified by the exclusion flags and corresponding fields 
	in Server parameter.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to fields of Server
 	Server - On input server entry from which to compute the next
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
GetNextServer (
    IN  DWORD					OrderingMethod,
    IN  DWORD					ExclusionFlags,
    IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT ULONG				*InterfaceIndex,
	IN OUT ULONG				*Protocol
    ) {
	PLIST_ENTRY			cur=NULL;
	PSERVER_NODE		theNode=NULL;
	DWORD				status=NO_ERROR;
	PSDB_HASH_LIST		HashList;
	PPROTECTED_LIST		list;
	INT					link;
	INT					res;

	switch (OrderingMethod) {
		case STM_ORDER_BY_TYPE_AND_NAME:
			break;
		case STM_ORDER_BY_INTERFACE_TYPE_NAME:
			break;
		default:
			ASSERTMSG ("Invalid ordering method specified ", FALSE);
			return ERROR_INVALID_PARAMETER;
		}

	if (!AcquireServerTableList (&ServerTable.ST_SortedListPRM, TRUE))
		return ERROR_GEN_FAILURE;

	if (Server->Name[0]!=0) {
		HashList = &ServerTable.ST_HashLists[HashFunction (Server->Name)];

		if (!AcquireServerTableList (&HashList->HL_List, TRUE)) {
			ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
			return ERROR_GEN_FAILURE;
			}

		cur = HashList->HL_List.PL_Head.Flink;
		while (cur!=&HashList->HL_List.PL_Head) {
			PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											N_Links[SDB_HASH_TABLE_LINK]);
			VALIDATE_NODE(node);
    		if (!IsEnumerator(node)
                    && (!IsDisabledNode (node)
                        || ((ExclusionFlags & STM_ONLY_THIS_PROTOCOL)
                            && (*Protocol==IPX_PROTOCOL_STATIC)))
				    && (node->SN_Server.HopCount<IPX_MAX_HOP_COUNT)) {
				if (Server->Type == node->SN_Server.Type) {
					res = IpxNameCmp (Server->Name, node->SN_Server.Name);
					if ((res==0) && IsSortedNode (node)) {
						theNode = node;
						}
					else if (res<0)
						break;
					}
				else if (Server->Type<node->SN_Server.Type)
					break;
				}
			cur = cur->Flink;
			}

		if (ExclusionFlags&STM_ONLY_THIS_NAME) {
			ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
			if (theNode!=NULL) {
				list = &HashList->HL_List;
				link = SDB_HASH_TABLE_LINK;
				}
			else {
				ReleaseServerTableList (&HashList->HL_List);
				return ERROR_NO_MORE_ITEMS;
				}

			}
		else {
			ReleaseServerTableList (&HashList->HL_List);
			goto DoHardWay;
			}
		}
	else {
	DoHardWay:
		list = &ServerTable.ST_SortedListPRM;
		link = SDB_SORTED_LIST_LINK;
		if (theNode!=NULL)
			cur = theNode->N_Links[SDB_SORTED_LIST_LINK].Flink;
		else {
			cur = ServerTable.ST_SortedListPRM.PL_Head.Flink;
			while (cur!=&ServerTable.ST_SortedListPRM.PL_Head) {
				PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											N_Links[SDB_SORTED_LIST_LINK]);
				VALIDATE_NODE(node);
    		    if (!IsEnumerator(node)
                        && (!IsDisabledNode (node)
                            || ((ExclusionFlags & STM_ONLY_THIS_PROTOCOL)
                                && (*Protocol==IPX_PROTOCOL_STATIC)))
				        && (node->SN_Server.HopCount<IPX_MAX_HOP_COUNT)) {
					if ((Server->Type<node->SN_Server.Type)
							|| ((Server->Type == node->SN_Server.Type)
								&& (IpxNameCmp (Server->Name,
									 node->SN_Server.Name)<0)))
						break;
					}
				cur = cur->Flink;
				}
			}
		}
		

	while (TRUE) {

			// We may need to loop through interface lists
		status = DoFindNextNode (cur,
					list,
					link,
					OrderingMethod==STM_ORDER_BY_INTERFACE_TYPE_NAME
						? ExclusionFlags|STM_ONLY_THIS_INTERFACE
						: ExclusionFlags,
					Server,
					InterfaceIndex,
					Protocol,
					NULL
					);
			// If looping through all interfaces in interface order and
			// no items are available, we may need to check another interface
		if ((status==ERROR_NO_MORE_ITEMS)
				&& (OrderingMethod==STM_ORDER_BY_INTERFACE_TYPE_NAME)
				&& !(ExclusionFlags&STM_ONLY_THIS_INTERFACE)) {
			if (!AcquireServerTableList (&ServerTable.ST_IntfList, TRUE)) {
				status = ERROR_GEN_FAILURE;
				break;
				}
			
				// Get next interface in interface list
			cur = ServerTable.ST_IntfList.PL_Head.Flink;
			while (cur!=&ServerTable.ST_IntfList.PL_Head) {
				PINTF_NODE	intfNode = CONTAINING_RECORD (cur,
													INTF_NODE,
													IN_Link);
				if (*InterfaceIndex<intfNode->IN_InterfaceIndex) {
					*InterfaceIndex = intfNode->IN_InterfaceIndex;
					break;
					}
				cur = cur->Flink;
				}
			ReleaseServerTableList (&ServerTable.ST_IntfList);
			if (cur!=&ServerTable.ST_IntfList.PL_Head) {
					// Restart the search with another interface index
				cur = list->PL_Head.Flink;
				continue;
				}
			}

		break;
		}

	if (link==SDB_HASH_TABLE_LINK)
		ReleaseServerTableList (&HashList->HL_List);
	else /* if (link==SDB_SORTED_LIST_LINK) */
		ReleaseServerTableList (&ServerTable.ST_SortedListPRM);

	return status;
	}


/*++
*******************************************************************
		G e t N e x t S e r v e r F r o m I D

Routine Description:
	Find and return service that follows server with specified ID
	in the type.name order.  
Arguments:
	ObjectID - on input: id of server form which to start the search
				on output: id of returned server
	Type - if not 0xFFFF, search should be limited to only servers
			of specified type
	Server, Protocol, InterfaceIndex - buffer to put returned server info in
Return Value:
	TRUE - server was found
	FALSE - search failed

*******************************************************************
--*/
BOOL
GetNextServerFromID (
	IN OUT PULONG				ObjectID,
	IN  USHORT					Type,
	OUT	PIPX_SERVER_ENTRY_P		Server,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL
	) {
	PSDB_HASH_LIST			HashList;
	PLIST_ENTRY				cur;
	PSERVER_NODE			theNode = NULL;
	DWORD					status=NO_ERROR;

	HashList = &ServerTable.ST_HashLists[(*ObjectID)%SDB_NAME_HASH_SIZE];

	if (*ObjectID==SDB_INVALID_OBJECT_ID) {
		if (ServerTable.ST_UpdatePending==-1)
			DoUpdateSortedList ();
		}
	if (!AcquireServerTableList (&ServerTable.ST_SortedListPRM, TRUE))
		return ERROR_GEN_FAILURE;

	if (*ObjectID!=SDB_INVALID_OBJECT_ID) {
		if (!AcquireServerTableList (&HashList->HL_List, TRUE)) {
			ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
			SetLastError (ERROR_GEN_FAILURE);
			return FALSE;
			}

		cur = HashList->HL_List.PL_Head.Flink;
		while (cur!=&HashList->HL_List.PL_Head) {
			PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											N_Links[SDB_HASH_TABLE_LINK]);
			VALIDATE_NODE(node);
			if (!IsEnumerator (node)  && !IsDisabledNode (node)
					&& (node->SN_HopCount < IPX_MAX_HOP_COUNT)
					&& (node->SN_ObjectID == *ObjectID)) {
				theNode = node;
				break;
				}
			cur = cur->Flink;
			}
		ReleaseServerTableList (&HashList->HL_List);
		if (theNode==NULL) {
			ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
			SetLastError (NO_ERROR);
			return FALSE;
			}
		else if (!IsSortedNode (theNode)) {
			cur = ServerTable.ST_SortedListPRM.PL_Head.Flink;
			while (cur!=&ServerTable.ST_SortedListPRM.PL_Head) {
				PSERVER_NODE	node = CONTAINING_RECORD (cur,
											SERVER_NODE,
											N_Links[SDB_SORTED_LIST_LINK]);
				VALIDATE_NODE(node);
				if (!IsEnumerator(node)  && !IsDisabledNode (node)) {
					if ((theNode->SN_Server.Type<node->SN_Server.Type)
							|| ((theNode->SN_Server.Type == node->SN_Server.Type)
								&& (IpxNameCmp (theNode->SN_Server.Name,
									 				node->SN_Server.Name)<0)))
						break;
					}
				cur = cur->Flink;
				}
			}
		else
			cur = theNode->N_Links[SDB_SORTED_LIST_LINK].Flink;
		}
	else
		cur = ServerTable.ST_SortedListPRM.PL_Head.Flink;
			
	Server->Type = Type;
	status = DoFindNextNode (cur,
					&ServerTable.ST_SortedListPRM,
					SDB_SORTED_LIST_LINK,
					Type==0xFFFF ? 0 : STM_ONLY_THIS_TYPE,
					Server,
					InterfaceIndex,
					Protocol,
					ObjectID
					);
	ReleaseServerTableList (&ServerTable.ST_SortedListPRM);
	return status == NO_ERROR;
	}


/*++
*******************************************************************
		D o F i n d N e x t N o d e

Routine Description:
	Scan through SortedListPRM to find the first entry that matches specified
	cirteria.  Permanent sorted list must be locked before calling
	this routine
Arguments:
	cur - pointer to entry in SortedListPRM from which to start the search
	ExclusionFlags - flags to limit search to certain servers according
					to fields of Server
 	Server, InterfaceIndex, Protocol - on input: search criteria
					on output: data of found server
	ObjectID - object ID of returned server 
Return Value:
	NO_ERROR - server was found that matches the criteria
	ERROR_NO_MORE_ITEMS - no server exist that matches criteria
	other - operation failed (windows error code)
*******************************************************************
--*/
DWORD
DoFindNextNode (
	IN PLIST_ENTRY				cur,
	IN PPROTECTED_LIST			list,
	IN INT						link,
	IN DWORD					ExclusionFlags,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT PULONG				InterfaceIndex OPTIONAL,
	IN OUT PULONG				Protocol OPTIONAL,
	OUT PULONG					ObjectID OPTIONAL
	) {
	while (cur!=&list->PL_Head) {
		PSDB_HASH_LIST	HashList;
		PSERVER_NODE	node = CONTAINING_RECORD (cur,
										SERVER_NODE,
										N_Links[link]);
		VALIDATE_NODE(node);
		if (!IsEnumerator(node)
                && (!IsDisabledNode (node)
                    || ((ExclusionFlags & STM_ONLY_THIS_PROTOCOL)
                            && (*Protocol==IPX_PROTOCOL_STATIC)))
				&& (node->SN_Server.HopCount<IPX_MAX_HOP_COUNT)) {
			if (ExclusionFlags & STM_ONLY_THIS_TYPE) {
				if (Server->Type>node->SN_Type)
					goto DoNextNode;
				else if (Server->Type<node->SN_Type)
					break;
				}

			if (ExclusionFlags & STM_ONLY_THIS_NAME) {
				INT res = IpxNameCmp (Server->Name,node->SN_Name);
				if (res>0)
					goto DoNextNode;
				else if (res<0) {
					if (ExclusionFlags & STM_ONLY_THIS_TYPE)
						break;
					else
						goto DoNextNode;
					}
				}

			HashList = node->SN_HashList;
			if (list!=&HashList->HL_List) {
				if (!AcquireServerTableList (&HashList->HL_List, TRUE))
					return ERROR_GEN_FAILURE;
				}

			do {
				if ((ExclusionFlags &
						STM_ONLY_THIS_PROTOCOL|STM_ONLY_THIS_INTERFACE)
						== (STM_ONLY_THIS_PROTOCOL|STM_ONLY_THIS_INTERFACE)) {
					if ((*Protocol==node->SN_Protocol)
							&& (*InterfaceIndex==node->SN_InterfaceIndex))
						break;
					}
				else if (ExclusionFlags & STM_ONLY_THIS_PROTOCOL) {
					if (*Protocol==node->SN_Protocol)
						break;
					}
				else if (ExclusionFlags & STM_ONLY_THIS_INTERFACE) {
					if (*InterfaceIndex!=node->SN_InterfaceIndex)
						break;
					}
				else
					break;
				node = CONTAINING_RECORD (node->SN_ServerLink.Flink,
											SERVER_NODE, SN_ServerLink);
				VALIDATE_SERVER_NODE(node);
				if (cur==&node->N_Links[link]) {
					if (list!=&HashList->HL_List)
						ReleaseServerTableList (&HashList->HL_List);
					goto DoNextNode;
					}
				}
			while (1);

			IpxServerCpy (Server, &node->SN_Server);
			if (ARGUMENT_PRESENT (ObjectID)) {
				if (node->SN_ObjectID==SDB_INVALID_OBJECT_ID)
					node->SN_ObjectID = GenerateUniqueID (node->SN_HashList);
				*ObjectID = node->SN_ObjectID;
				}
			if (ARGUMENT_PRESENT (InterfaceIndex))
				*InterfaceIndex = node->SN_InterfaceIndex;
			if (ARGUMENT_PRESENT (Protocol))
				*Protocol = node->SN_Protocol;
			if (list!=&HashList->HL_List)
				ReleaseServerTableList (&HashList->HL_List);
			return NO_ERROR;
			}
	DoNextNode:
		cur = cur->Flink;
		}

	return ERROR_NO_MORE_ITEMS;
	}

/*++
*******************************************************************
		F i n d I n t f L i n k

Routine Description:
	Find interface list given an interface index.  Create new interface
	list if one for given index does not exist
	Interface list must be locked when calling this routine
Arguments:
	InterfaceIndex - index to look for
Return Value:
	Head of interface list (link at which new entry can be inserted)
	NULL if list could not be found and creation of new list failed
*******************************************************************
--*/
PLIST_ENTRY
FindIntfLink (
	ULONG	InterfaceIndex
	) {
	PLIST_ENTRY		cur;
	PINTF_NODE		node;

	cur = ServerTable.ST_IntfList.PL_Head.Flink;
	while (cur!=&ServerTable.ST_IntfList.PL_Head) {
		node = CONTAINING_RECORD (cur, INTF_NODE, IN_Link);
		if (InterfaceIndex==node->IN_InterfaceIndex)
			return &node->IN_Head;
		else if (InterfaceIndex<node->IN_InterfaceIndex)
			break;

		cur = cur->Flink;
		}
	node = (PINTF_NODE)GlobalAlloc (GMEM_FIXED, sizeof (INTF_NODE));
	if (node==NULL) {
		Trace (DEBUG_FAILURES,
			"File: %s, line: %ld. Can't allocate interface list node (gle:%ld).",
											__FILE__, __LINE__, GetLastError ());
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}

	node->IN_InterfaceIndex = InterfaceIndex;
	InitializeListHead (&node->IN_Head);
	InsertTailList (cur, &node->IN_Link);

	return &node->IN_Head;
	}


/*++
*******************************************************************
		F i n d T y p e L i n k

Routine Description:
	Find type list given a type value.  Create new type
	list if one for given type does not exist
	Type list must be locked when calling this routine
Arguments:
	Type - type to look for
Return Value:
	Head of type list (link at which new entry can be inserted)
	NULL if list could not be found and creation of new list failed
*******************************************************************
--*/
PLIST_ENTRY
FindTypeLink (
	USHORT	Type
	) {
	PLIST_ENTRY		cur;
	PTYPE_NODE		node;

	cur = ServerTable.ST_TypeList.PL_Head.Flink;
	while (cur!=&ServerTable.ST_TypeList.PL_Head) {
		node = CONTAINING_RECORD (cur, TYPE_NODE, TN_Link);
		if (Type==node->TN_Type)
			return &node->TN_Head;
		else if (Type<node->TN_Type)
			break;

		cur = cur->Flink;
		}
	node = (PTYPE_NODE)GlobalAlloc (GMEM_FIXED, sizeof (TYPE_NODE));
	if (node==NULL) {
		Trace (DEBUG_FAILURES, 
			"File: %s, line: %ld. Can't allocate type list node (gle:%ld).",
										__FILE__, __LINE__, GetLastError ());
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}

	node->TN_Type = Type;
	InitializeListHead (&node->TN_Head);
	InsertTailList (cur, &node->TN_Link);

	return &node->TN_Head;
	}


/*++
*******************************************************************
		F i n d S o r t e d L i n k

Routine Description:
	Find place for server with given type and name in SortedListTMP
	If there is another node there with the same name and type it
	is removed from the list
	SortedListTMP must be locked when calling this routine
Arguments:
	Type - type to look for
	Name - name to look for
Return Value:
	Link in SortedListTMP at which server with given name and type
	should be inserted
	This routine can't fail
*******************************************************************
--*/
PLIST_ENTRY
FindSortedLink (
	USHORT		Type,
	PUCHAR		Name
	) {
	PLIST_ENTRY		cur;
	INT				res;

	cur = ServerTable.ST_SortedListTMP.PL_Head.Flink;
	while (cur!=&ServerTable.ST_SortedListTMP.PL_Head) {
		PSERVER_NODE node = CONTAINING_RECORD (cur,
										 SERVER_NODE,
										 N_Links[SDB_SORTED_LIST_LINK]);
		VALIDATE_SERVER_NODE(node);
		if (Type==node->SN_Type) {
			res = IpxNameCmp (Name, node->SN_Name);
			if (res==0) {
				cur = cur->Flink;
				RemoveEntryList (&node->N_Links[SDB_SORTED_LIST_LINK]);
				InitializeListEntry (&node->N_Links[SDB_SORTED_LIST_LINK]);
				ServerTable.ST_TMPListCnt -= 1;
				break;
				}	
			else if (res<0)
				break;
			}
		else if (Type<node->SN_Type)
			break;

		cur = cur->Flink;
		}

	return cur;
	}


/*++
*******************************************************************
		H a s h F u n c t i o n

Routine Description:
	Computes hash function for given server name.  In addition it normalizes
	length and capitalization of name
Arguments:
	Name - name to process
Return Value:
	Hash value
*******************************************************************
--*/
INT
HashFunction (
	PUCHAR	Name
	) {
	INT		i;
	INT		res = 0;

	for (i=0; i<47; i++) {
		Name[i] = (UCHAR)toupper(Name[i]);
		if (Name[i]==0)
			break;
		else
			res += Name[i];
		}
	if ((i==47) && (Name[i]!=0)) {
		Trace (DEBUG_SERVERDB, "Correcting server name: %.48s.", Name);
		Name[i] = 0;
		}
	return res % SDB_NAME_HASH_SIZE;
	}
		
/*++
*******************************************************************
		G e n e r a t e U n i q u e I D

Routine Description:
	Generates "unique" ULONG for server by combining hash bucket number and
	unique ID of entry in hash list.
	The number is kept with entry until there is a danger of collision
	due to number wraparound
Arguments:
	HashList - hash bucket to generate ID for
Return Value:
	ULONG ID
*******************************************************************
--*/
ULONG
GenerateUniqueID (
	PSDB_HASH_LIST	HashList
	) {
	ULONG	id = HashList->HL_ObjectID;

	HashList->HL_ObjectID = (HashList->HL_ObjectID+SDB_NAME_HASH_SIZE)&SDB_OBJECT_ID_MASK;
			// Make sure we won't assign invalid id
	if (HashList->HL_ObjectID==SDB_INVALID_OBJECT_ID)
		HashList->HL_ObjectID+=SDB_NAME_HASH_SIZE;
			// Create guard zone by invalidating all ID's that are one zone
			// above the zone we just entered
	if (!IsSameObjectIDZone(id, HashList->HL_ObjectID)) {
		PLIST_ENTRY	cur = HashList->HL_List.PL_Head.Flink;
		ULONG		oldMask = (HashList->HL_ObjectID & SDB_OBJECT_ID_ZONE_MASK)
								+ SDB_OBJECT_ID_ZONE_UNIT;
		while (cur!=&HashList->HL_List.PL_Head) {
			PSERVER_NODE	node = CONTAINING_RECORD (cur,
												 SERVER_NODE,
												 N_Links[SDB_HASH_TABLE_LINK]);
			if (!IsEnumerator(node)) {
				if ((node->SN_ObjectID & SDB_OBJECT_ID_ZONE_MASK)==oldMask)
					node->SN_ObjectID = SDB_INVALID_OBJECT_ID;
				}
			}
		cur = cur->Flink;
		}
	return id;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\serverdb.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\serverdb.h

Abstract:

	This is a header file for SAP Server Table management API

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_SERVERDB_
#define _SAP_SERVERDB_


#define SDB_NAME_HASH_SIZE	257

// Max number of unsorted servers
extern ULONG	SDBMaxUnsortedServers;

// Interval with which to update the sorted list
extern ULONG	SDBSortLatency;

// Size of heap reserved for the database
extern ULONG	SDBMaxHeapSize;


#define SDB_SERVER_NODE_SIGNATURE		'NS'
#define SDB_ENUMERATOR_NODE_SIGNATURE	'NE'

#define VALIDATE_NODE(node)						\
	ASSERTMSG ("Server database corrupted ",	\
		IsEnumerator(node)						\
			? (((PENUMERATOR_NODE)(node))->EN_Signature==SDB_ENUMERATOR_NODE_SIGNATURE)\
			: (node->SN_Signature==SDB_SERVER_NODE_SIGNATURE)\
	)

#define VALIDATE_SERVER_NODE(node)						\
	ASSERTMSG ("Server database corrupted ",			\
			node->SN_Signature==SDB_SERVER_NODE_SIGNATURE)

#define VALIDATE_ENUMERATOR_NODE(node)						\
	ASSERTMSG ("Server database corrupted ",				\
			((PENUMERATOR_NODE)(node))->EN_Signature==SDB_ENUMERATOR_NODE_SIGNATURE)

	// Max entries to keep for each server (this limit does not include
	// entries that must be kept for correct iplementation of split-horizon
	// algorithm on looped networks)
#define SDB_MAX_NODES_PER_SERVER			1
	// Max time in msec we allow enumerators to keep the list locked
#define SDB_MAX_LOCK_HOLDING_TIME			1000

#define SDB_INVALID_OBJECT_ID				0xFFFFFFFF
#define SDB_OBJECT_ID_MASK					0x0FFFFFFF
	// Object IDs are subdivided onto 4 zones in the order of ULONG numbers
	// When assigning new IDs we make sure that zone in front of the one
	// from which new IDs get assigned is not used by invalidating object
	// IDs that belong to that zone
#define SDB_OBJECT_ID_ZONE_MASK				0x0C000000
#define SDB_OBJECT_ID_ZONE_UNIT				0x04000000

#define IsSameObjectIDZone(id1,id2) \
			((id1&SDB_OBJECT_ID_ZONE_MASK)==(id2&SDB_OBJECT_ID_ZONE_MASK))

	// Server entry links that can be used for enumeration/searching
#define SDB_HASH_TABLE_LINK					0
	// Entry can only be in one of the sorted lists (temporary
	// or permanent), so we'll use the same link for both
#define SDB_SORTED_LIST_LINK				1  
#define SDB_CHANGE_QUEUE_LINK				2
#define SDB_INTF_LIST_LINK					3
#define SDB_TYPE_LIST_LINK					4
#define SDB_NUM_OF_LINKS					5


#define SDB_ENUMERATOR_FLAG					0x00000001
#define SDB_MAIN_NODE_FLAG					0x00000002
#define SDB_SORTED_NODE_FLAG				0x00000004
#define SDB_DISABLED_NODE_FLAG				0x00000008
#define SDB_DONT_RESPOND_NODE_FLAG			0x00000010

#define SDB_ENUMERATION_NODE	SDB_ENUMERATOR_FLAG
#define SDB_SERVER_NODE			0

#define IsEnumerator(node)	((node)->N_NodeFlags&SDB_ENUMERATOR_FLAG)
#define IsMainNode(node) 	((node)->N_NodeFlags&SDB_MAIN_NODE_FLAG)
#define IsSortedNode(node)	((node)->N_NodeFlags&SDB_SORTED_NODE_FLAG)
#define IsDisabledNode(node) ((node)->N_NodeFlags&SDB_DISABLED_NODE_FLAG)
#define IsNoResponseNode(node)  ((node)->N_NodeFlags&SDB_DONT_RESPOND_NODE_FLAG)

#define SetMainNode(node)	(node)->N_NodeFlags |= SDB_MAIN_NODE_FLAG
#define SetSortedNode(node)	(node)->N_NodeFlags |= SDB_SORTED_NODE_FLAG
#define SetDisabledNode(node) (node)->N_NodeFlags |= SDB_DISABLED_NODE_FLAG
#define SetNoResponseNode(node)  ((node)->N_NodeFlags |= SDB_DONT_RESPOND_NODE_FLAG)

#define ResetMainNode(node)		(node)->N_NodeFlags &= ~SDB_MAIN_NODE_FLAG
#define ResetSortedNode(node)	(node)->N_NodeFlags &= ~SDB_SORTED_NODE_FLAG
#define ResetDisabledNode(node)	(node)->N_NodeFlags &= ~SDB_DISABLED_NODE_FLAG
#define ResetNoResponseNode(node)  ((node)->N_NodeFlags &= ~SDB_DONT_RESPOND_NODE_FLAG)


// Each hash list carries number to be used for generation of Object ID
typedef struct _SDB_HASH_LIST {
			PROTECTED_LIST		HL_List;		// List itself
			ULONG				HL_ObjectID;	// Last used object ID
			} SDB_HASH_LIST, *PSDB_HASH_LIST;

// Both regular server entries and nodes used for enumeration have same
// header
#define NODE_HEADER									\
			INT			N_NodeFlags;				\
			LIST_ENTRY	N_Links[SDB_NUM_OF_LINKS]

// Node of the service table
typedef struct _SERVER_NODE {
	NODE_HEADER;
	LIST_ENTRY			SN_ServerLink;	// Head of/link in the list of entries
										// with same name and type (this list
										// is ordered by hop count)
	LIST_ENTRY			SN_TimerLink;	// Link in timer queue
	ULONG				SN_ObjectID;	// Unique ID
	PSDB_HASH_LIST		SN_HashList;	// Which hash list we belong to
	ULONG				SN_ExpirationTime; // Time when this node should be
										// aged out
	ULONG				SN_InterfaceIndex;
	DWORD				SN_Protocol;
	UCHAR				SN_AdvertisingNode[6];
	USHORT				SN_Signature;	// SN
	IPX_SERVER_ENTRY_P	SN_Server;
	} SERVER_NODE, *PSERVER_NODE;

#define SN_Type					SN_Server.Type
#define SN_Name					SN_Server.Name
#define SN_HopCount				SN_Server.HopCount
#define SN_Net					SN_Server.Network
#define SN_Node					SN_Server.Node
#define SN_Socket				SN_Server.Node


// Node used for enumerations
typedef struct _ENUMERATOR_NODE {
	NODE_HEADER;
	INT					EN_LinkIdx;		// Index of the list we use
	PPROTECTED_LIST		EN_ListLock;	// Pointer to lock of that list
	PLIST_ENTRY			EN_ListHead;	// Head of the list we are
										// enumerating through
	INT					EN_Flags;		// Enumeration flags
	ULONG				EN_InterfaceIndex;// InterfaceIndex to be enumerated
										// (INVALID_INTERFACE_INDEX
										// - all interfaces)
	ULONG				EN_Protocol;	// Protocol to be enumerated
										// (0xFFFFFFFF - all protocols)
	USHORT				EN_Signature;	// 'EN'
	USHORT				EN_Type;		// Type of servers to be enumerated
										// (0xFFFF - all types)
	UCHAR				EN_Name[48];	// Name of servers to be enumerated
										// ("\0" - all names)
	} ENUMERATOR_NODE, *PENUMERATOR_NODE;


	// Node of type list
typedef struct _TYPE_NODE {
			LIST_ENTRY				TN_Link;	// Link in type list
			LIST_ENTRY				TN_Head;	// Head of server list
												// attached to this node
			USHORT					TN_Type;	// Type of servers in the
												// attached list
			} TYPE_NODE, *PTYPE_NODE;

	// Node of interface list
typedef struct _INTF_NODE {
			LIST_ENTRY				IN_Link;	// Link in interface list
			LIST_ENTRY				IN_Head;	// Head of server list
												// attached to this node
			ULONG					IN_InterfaceIndex; // InterfaceIndex of
											// servers in the attached list
			} INTF_NODE, *PINTF_NODE;


	// Data cobined in server table
typedef struct _SERVER_TABLE {
	HGLOBAL				ST_Heap;			// Heap from which to allocate
											// server nodes
	HANDLE				ST_UpdateTimer;		// Update timer (signalled when
											// sorted list needs to be
											// updated
	HANDLE				ST_ExpirationTimer;	// Expiration timer (signalled
											// when expiration queue
											// requires processing
	LONG				ST_UpdatePending;	//
	ULONG				ST_ServerCnt;		// Total number of services
	ULONG				ST_StaticServerCnt; // Total number of static services
	HANDLE				ST_LastEnumerator;
//	ULONG				ST_ChangeEnumCnt;	// Number of enumerators
											// in the changed services queue
											// (nodes marked for deletion are
											// retainted in this queue until
											// all enumerators have seen it)
	ULONG				ST_TMPListCnt;		// Number of entries in temporary
											// sorted list
	ULONG				ST_DeletedListCnt;	//
	PROTECTED_LIST		ST_ExpirationQueue; // Timer queue in expiration order
	PROTECTED_LIST		ST_ChangedSvrsQueue;// Queue of changed services (most
											// recently changed first order)
	PROTECTED_LIST		ST_TypeList;		// Type list
	PROTECTED_LIST		ST_IntfList;		// Interface list
	PROTECTED_LIST		ST_SortedListPRM;	// Permanent type.name.intf.prot
											// sorted list
	PROTECTED_LIST		ST_SortedListTMP;	// Temporary type.name.intf.prot
											// sorted list
	PROTECTED_LIST		ST_DeletedList;		// List of entries to be deleted
								// from the table
	SDB_HASH_LIST		ST_HashLists[SDB_NAME_HASH_SIZE]; // Hash lists
								// (entries are in type.name.intf.prot order)
	SYNC_OBJECT_POOL	ST_SyncPool;		// Pool of synchronization objects
	} SERVER_TABLE, *PSERVER_TABLE;


extern SERVER_TABLE	ServerTable;

#define AcquireServerTableList(list,wait) \
			AcquireProtectedList(&ServerTable.ST_SyncPool,list,wait)

#define ReleaseServerTableList(list) \
			ReleaseProtectedList(&ServerTable.ST_SyncPool,list)

/*++
*******************************************************************
		C r e a t e S e r v e r T a b l e

Routine Description:
		Allocates resources for server table management

Arguments:
		UpdateObject - this object will be signalled when 'slow'
					sorted list of servers needs to be updated
					(UpdateSortedList should be called)
		TimerObject - this object will be signalled when server expiration
					queue requires processing (ProcessExpirationQueue should
					be called)

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
CreateServerTable (
	HANDLE				*UpdateObject,
	HANDLE				*TimerObject
	);


/*++
*******************************************************************
		D e l e t e S e r v e r T a b l e

Routine Description:
		Dispose of server table and associated resources

Arguments:

Return Value:
		NO_ERROR - resources were disposed of successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
void
DeleteServerTable (
	);


/*++
*******************************************************************
		U p d a t e S e r v e r

Routine Description:
	Update server in the table (If entry for server does not exist and
	hop count parameter is less than 16, it is added to the table, if entry
	for the server exists and hop count parameter is 16, server is marked
	for deletion, otherwise server info is updated).
	
	Sorted list of servers is not updated immediately
	if new server is added or deleted

Arguments:
	Server	- server parameters (as it comes from IPX packet)
	InterfaceIndex - interface through which knowledge of server was obtained
	Protocol - protocol used to obtain server info
	TimeToLive - time in sec before server is aged out (INFINITE for no aging)
	AdvertisingNode - node that from which this server info was received
	NewServer - set to TRUE if server was not in the table
Return Value:
	NO_ERROR - server was added/updated ok
	other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
UpdateServer (
	IN PIPX_SERVER_ENTRY_P	Server,
    IN ULONG     			InterfaceIndex,
	IN DWORD				Protocol,
	IN ULONG				TimeToLive,
	IN PUCHAR				AdvertisingNode,
	IN INT					Flags,
	OUT BOOL				*NewServer	OPTIONAL
	);

/*++
*******************************************************************
		U p d a t e S o r t e d L i s t

Routine Description:
	Schedules work item to update sorted list.
	Should be called whenever UpdateObject is signalled
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UpdateSortedList (
	void
	);

/*++
*******************************************************************
		P r o c e s s E x p i r a t i o n Q u e u e

Routine Description:
	Deletes expired servers from the table and set timer object to
	be signalled when next item in expiration queue is due
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessExpirationQueue (
	void
	);

/*++
*******************************************************************
		Q u e r y S e r v e r

Routine Description:
	Checks if server with given type and name exists in the table
	Returns TRUE if it does and fills out requested server info
	with data of the best entry for the server
Arguments:
	Type - server type
	Name - server name
	Server - buffer in which to put server info
	InterfaceIndex - buffer in which to put server interface index
	Protocol - buffer in which to put server protocol
	ObjectID - buffer in which to put server object id (number that uniquely
			identifies server (the whole set of entries, not just the best
			one) in the table; it is valid for very long but FINITE period
			of time)
Return Value:
	TRUE	- server was found
	FALSE	- server was not found or operation failed (call GetLastError()
			to find out the reason for failure if any)

*******************************************************************
--*/
BOOL
QueryServer (
	IN 	USHORT					Type,
	IN 	PUCHAR					Name,
	OUT	PIPX_SERVER_ENTRY_P		Server OPTIONAL,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL,
	OUT	PULONG					ObjectID OPTIONAL
	);

/*++
*******************************************************************
		G e t S e r v e r F r o m I D

Routine Description:
	Returns info for server with specified ID
Arguments:
	ObjectID - server object id (number that uniquely
			identifies server in the table, it is valid for very long
			but FINITE amount of time)
	Server - buffer in which to put server info
	InterfaceIndex - buffer in which to put server interface index
	Protocol - buffer in which to put server protocol
Return Value:
	TRUE	- server was found
	FALSE	- server was not found or operation failed (call GetLastError()
			to find out the reason for failure if any)

*******************************************************************
--*/
BOOL
GetServerFromID (
	IN 	ULONG					ObjectID,
	OUT	PIPX_SERVER_ENTRY_P		Server OPTIONAL,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL
	);

/*++
*******************************************************************
		G e t N e x t S e r v e r F r o m I D

Routine Description:
	Find and return service that follows server with specified ID
	in the type.name order.  
Arguments:
	ObjectID - on input: id of server form which to start the search
				on output: id of returned server
	Type - if not 0xFFFF, search should be limited to only servers
			of specified type
	Server, Protocol, InterfaceIndex - buffer to put returned server info in
Return Value:
	TRUE - server was found
	FALSE - search failed

*******************************************************************
--*/
BOOL
GetNextServerFromID (
	IN OUT PULONG				ObjectID,
	IN  USHORT					Type,
	OUT	PIPX_SERVER_ENTRY_P		Server,
	OUT	PULONG					InterfaceIndex OPTIONAL,
	OUT	PULONG					Protocol OPTIONAL
	);


/*++
*******************************************************************
		C r e a t e L i s t E n u m e r a t o r

Routine Description:
	Creates enumerator node that allows scanning through the server
	table lists
Arguments:
	ListIdx	- index of list through which to scan (currently supported lists
			are: hash lists, interface lists, type lists,
			changed servers queue
	Type - limits enumeration to servers of specific type and
			indentifies a particular type list if index is SDB_TYPE_LIST_IDX
			(use 0xFFFF to return all server and/or to go through all
			 type lists)
	Name - limits enumeration to servers with certain name if present
	InterfaceIndex - limits enumeration to servers of specific interface and
			indentifies a particular interface list if index
			is SDB_INTF_LIST_IDX (use INVALID_INTERFACE_INDEX to return all
			server and/or to go through all interface lists)
	Protocol - limits enumeration to servers of certain protocol (0xFFFFFFFF
			- all protocols)
	Flags	 - identifies additional conditions on entries enumerated:
			SDB_MAIN_NODE_FLAG	- only best servers
			SDB_DISABLED_NODE_FLAG - include disabled servers
Return Value:
	Handle that represents the enumeration node
	NULL if specified list does not exist or operation failed
		 (call GetLastError () for the reason of failure if any)

*******************************************************************
--*/
HANDLE
CreateListEnumerator (
	IN	INT						ListIdx,
	IN	USHORT					Type,
	IN	PUCHAR					Name OPTIONAL,
	IN	ULONG					InterfaceIndex,
	IN 	ULONG					Protocol,
	IN	INT						Flags
	);



/*++
*******************************************************************
		E n u m e r a t i o n C a l l b a c k P r o c

Routine Description:
	Provided as a parameter to EnumerateServers call.
	Gets call with all entries in the enumerated list.
	If there is more than one entry for the server, the callback
	will get them in the order of decreasing hop count (the best entry
	will show up last)
Arguments:
	CBParam	- parameter specified in call to EnumerateServers,
	Server, InterfaceIndex, Protocol, AdvertisingNode - server data
	Flags - flags associated with the node
Return Value:
	TRUE - stop enumeration
	FALSE - continue

*******************************************************************
--*/
typedef
BOOL 
(* EnumerateServersCallBack) (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

/*++
*******************************************************************
		D e l e t e A l l S e r v e r s C B

Routine Description:
	Callback proc for EnumerateServers that deletes all server
	entries with which it is called
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE - deletion succeded, continue
	TRUE - failure to lock SDB list, stop enumeration and return FALSE
		to client (error code is set in this routine)
*******************************************************************
--*/
BOOL
DeleteAllServersCB (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

BOOL
DeleteNonLocalServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

/*++
*******************************************************************
		G e t O n e C B

Routine Description:
	Callback proc for EnumerateServers.
	Copies the first entry with which it is called and stops enumeration
	by returning TRUE
Arguments:
	CBParam - pointer to buffer to which to copy service info
	Server, InterfaceIndex, Protocol, AdvertisingNode - service data
	MainEntry - ignored
Return Value:
	TRUE
*******************************************************************
--*/
BOOL
GetOneCB (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

/*++
*******************************************************************
		C o n v e r t T o S t a t i c C B

Routine Description:
	Callback proc for EnumerateServers that converts all server
	entries with which it is called to static (changes protocol field to
	static)
Arguments:
	CBParam - enumeration handle that identifies enumeration
	Server - pointer to server data inside server node from which node
			itself is computed
Return Value:
	FALSE
*******************************************************************
--*/
BOOL
ConvertToStaticCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

BOOL
EnableAllServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);

BOOL
DisableAllServersCB (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	);
	
/*++
*******************************************************************
		E n u m e r a t e S e r v e r s

Routine Description:
	Calls callback routine consequtively for servers in the enumerated
	list until told to stop by the callback or end of list is reached
Arguments:
	Enumerator - handle obtained from CreateListEnumerator
	CallBackProc - function to call for each server in the list
	CBParam	 - extra parameter to pass to callback function
Return Value:
	TRUE - if stopped by the callback
	FALSE - if end of list is reached or operation failed (call GetLastError ()
			to find out the reason of failure)

*******************************************************************
--*/
BOOLEAN
EnumerateServers (
	IN	HANDLE						Enumerator,	// Existing enumerator
	IN	EnumerateServersCallBack	CallBackProc,// Callback proc
	IN	LPVOID						CBParam		// Parameter to pass to callback
	);

/*++
*******************************************************************
		D e l e t e L i s t E n u m e r a t o r

Routine Description:
	Releases resources associated with list enumerator (this includes
	server entries that are queued to change queue before being deleted)
Arguments:
	Enumerator - handle obtained from CreateListEnumerator
Return Value:
	None

*******************************************************************
--*/
void
DeleteListEnumerator (
	IN HANDLE 					Enumerator
	);

/*++
*******************************************************************
	G e t F i r s t S e r v e r

Routine Description:
	Find and return first service in the order specified by the ordering method.
	Search is limited only to certain types of services as specified by the
	exclusion flags end corresponding fields in Server parameter.
	Returns IPX_ERROR_NO_MORE_ITEMS if there are no services in the
	table that meet specified criteria.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to specified criteria
 	Server - On input: criteria for exclusion flags
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	IPX_ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
GetFirstServer (
    IN  DWORD					OrderingMethod,
    IN  DWORD					ExclusionFlags,
    IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT ULONG				*InterfaceInex,
	IN OUT ULONG				*Protocol
    );

/*++
*******************************************************************
	G e t N e x t S e r v e r
Routine Description:
	Find and return next service in the order specified by the ordering method.
	Search starts from specified service and is limited only to certain types
	of services as specified by the exclusion flags and corresponding fields 
	in Server parameter.
Arguments:
	OrderingMethod - which ordering to consider in determining what is
					the first server
	ExclusionFlags - flags to limit search to certain servers according
					to fields of Server
 	Server - On input server entry from which to compute the next
			 On output: first service entry in the specified order
Return Value:
	NO_ERROR - server was found that meets specified criteria
	IPX_ERROR_NO_MORE_ITEMS - no server exist with specified criteria
	other - operation failed (windows error code)

*******************************************************************
--*/
DWORD
GetNextServer (
    IN  DWORD					OrderingMethod,
    IN  DWORD					ExclusionFlags,
    IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN OUT ULONG				*InterfaceInex,
	IN OUT ULONG				*Protocol
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\syncpool.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\syncpool.h

Abstract:

	Header file for allocation and assigment of
	syncronization objects module
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_SYNCPOOL_
#define _SAP_SYNCPOOL_



// Event with link to store it in the pool
typedef struct _SYNC_OBJECT {
	HANDLE				SO_Event;	// Event itself
	SINGLE_LIST_ENTRY	SO_Link;	// Link to next event in pool
	} SYNC_OBJECT, *PSYNC_OBJECT;

// Pool of synchronization objects
typedef struct _SYNC_OBJECT_POOL {
	CRITICAL_SECTION	SOP_Lock;		// Pool protection
	SINGLE_LIST_ENTRY	SOP_Head;		// Top of the stack
	} SYNC_OBJECT_POOL, *PSYNC_OBJECT_POOL;

// Object that can protect shared resource with a help of
// syncronization object from a pool
typedef struct _PROTECTED_OBJECT {
	PSYNC_OBJECT		PO_Sync;		// Assigned event
	LONG				PO_UseCount;	// Number of user accessing or waiting
#if DBG
	DWORD				PO_Thread;
	ULONG				PO_Time;
	ULONG				PO_Line;
#endif
#ifdef LOG_SYNC_STATS
	ULONG				PO_AccessCount;
	ULONG				PO_WaitCount;
	ULONGLONG			PO_TotalWait;
#endif
	} PROTECTED_OBJECT, *PPROTECTED_OBJECT;

VOID
InitializeSyncObjPool (
	PSYNC_OBJECT_POOL		ObjPool
	);

VOID
DeleteSyncObjPool (
	PSYNC_OBJECT_POOL		ObjPool
	);

// Initializes protected object
// VOID
// InitializeProtectedObj (
//	PPROTECTED_OBJECT	ProtectedObj
//	) 
#ifdef LOG_SYNC_STATS
#define InitializeProtectedObj(ProtectedObj) {			\
					(ProtectedObj)->PO_Sync = NULL; 	\
					(ProtectedObj)->PO_UseCount = -1;	\
					(ProtectedObj)->PO_AccessCount = 0;	\
					(ProtectedObj)->PO_WaitCount = 0;	\
					(ProtectedObj)->PO_TotalWait = 0;	\
					}
#else
#define InitializeProtectedObj(ProtectedObj) {			\
					(ProtectedObj)->PO_Sync = NULL; 	\
					(ProtectedObj)->PO_UseCount = -1;	\
					}
#endif

#ifdef LOG_SYNC_STATS
#define DeleteProtectedObj(ProtectedObj)				\
	DumpProtectedObjStats (ProtectedObj);
VOID
DumpProtectedObjStats (
	PPROTECTED_OBJECT	ProtectedObj
	);
#else
#define DeleteProtectedObj(ProtectedObj)
#endif


BOOL
AcquireProtectedObjWait (
#if DBG
	ULONG				line,
#endif
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	);

BOOL
ReleaseProtectedObjNoWait (
#if DBG
	ULONG				line,
#endif
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	);

HANDLE
GetObjectEvent (
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	);

#if DBG
#ifdef LOG_SYNC_STATS
#define AcquireProtectedObj(pool,obj,wait) (				\
	(InterlockedIncrement(&(obj)->PO_UseCount)==0)			\
		? ((obj)->PO_Line = __LINE__,						\
			(obj)->PO_Thread = GetCurrentThreadId (),		\
			(obj)->PO_Time = GetTickCount (),				\
			InterlockedIncrement (&(obj)->PO_AccessCount),	\
			TRUE)											\
		: (wait												\
			? AcquireProtectedObjWait(__LINE__,pool,obj)	\
			: ReleaseProtectedObjNoWait(__LINE__,pool,obj)  \
			)												\
	)
#else
#define AcquireProtectedObj(pool,obj,wait) (				\
	(InterlockedIncrement(&(obj)->PO_UseCount)==0)			\
		? ((obj)->PO_Line = __LINE__,						\
			(obj)->PO_Thread = GetCurrentThreadId (),		\
			(obj)->PO_Time = GetTickCount (),				\
			TRUE)											\
		: (wait												\
			? AcquireProtectedObjWait(__LINE__,pool,obj)	\
			: ReleaseProtectedObjNoWait(__LINE__,pool,obj)  \
			)												\
	)
#endif
#define ReleaseProtectedObj(pool,obj) (						\
	((((GetTickCount()-(obj)->PO_Time)<5000)				\
				? 0											\
				: Trace (DEBUG_FAILURES,					\
					"Held lock for %ld sec in %s at %ld.\n",\
					(GetTickCount()-(obj)->PO_Time)/1000,	\
					__FILE__, __LINE__)),					\
			(InterlockedDecrement(&(obj)->PO_UseCount)<0))	\
		? TRUE												\
		: SetEvent (GetObjectEvent(pool,obj))				\
	)
#else
#define AcquireProtectedObj(pool,obj,wait) (				\
	(InterlockedIncrement(&(obj)->PO_UseCount)==0)			\
		? (TRUE)											\
		: (wait												\
			? AcquireProtectedObjWait(pool,obj)				\
			: ReleaseProtectedObjNoWait(pool,obj)	        \
			)												\
	)
#define ReleaseProtectedObj(pool,obj) (						\
	(InterlockedDecrement(&(obj)->PO_UseCount)<0)			\
		? TRUE												\
		: SetEvent (GetObjectEvent(pool,obj))				\
	)
#endif



	// Special case for protection of doubly-linked lists
typedef struct _PROTECTED_LIST {
	PROTECTED_OBJECT	PL_PObj;
	LIST_ENTRY			PL_Head;
	} PROTECTED_LIST, *PPROTECTED_LIST;

#define InitializeProtectedList(ProtectedList) {				\
			InitializeProtectedObj(&(ProtectedList)->PL_PObj);	\
			InitializeListHead(&(ProtectedList)->PL_Head);		\
			}

#define AcquireProtectedList(ObjPool,ProtectedList,wait)	\
			AcquireProtectedObj(ObjPool,&(ProtectedList)->PL_PObj,wait)

#define ReleaseProtectedList(ObjPool,ProtectedList)			\
			ReleaseProtectedObj(ObjPool,&(ProtectedList)->PL_PObj)

#define DeleteProtectedList(ProtectedList)					\
			DeleteProtectedObj(&(ProtectedList)->PL_PObj);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\svcsif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\routing\ipx\sap\svcsif.c

Abstract:

    SAP interface with service controller
    (API for standalone SAP agent part of services.exe)

Author:

    Vadim Eydelman  05-15-1995

Revision History:

--*/

#include "sapp.h"

// SAP service status (when operating standalone outside of router)
SERVICE_STATUS_HANDLE   ServiceStatusHandle;
SERVICE_STATUS          ServiceStatus;
volatile HANDLE         ServiceThreadHdl;

VOID
ServiceMain (
    DWORD                   argc,
    LPTSTR                  argv[]
    );


VOID APIENTRY
ResumeServiceThread (
    ULONG_PTR   param
    ) {
    return ;
}


VOID
ServiceHandler (
    DWORD   fdwControl
    ) {
    ASSERT (ServiceStatusHandle!=0);

    EnterCriticalSection (&OperationalStateLock);
    switch (fdwControl) {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
#if DBG
            DbgPrint ("IPXSAP: Service control stop/shutdown.\n");
#endif
            if (ServiceIfActive) {
                ServiceIfActive = FALSE;
                if (ServiceThreadHdl!=NULL) {
                    BOOL    res;
                    HANDLE  localHdl = ServiceThreadHdl;
                    ServiceThreadHdl = NULL;
#if DBG
                    DbgPrint ("IPXSAP: Resuming service thread.\n");
#endif
                    res = QueueUserAPC (
                                ResumeServiceThread,
                                localHdl,
                                0);
                    ASSERTMSG ("Could not queue APC to service thread ", res);
                    CloseHandle (localHdl);
                    }
                ServiceStatus.dwCheckPoint += 1;
                ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                }
            else
                Trace (DEBUG_FAILURES,
                        "SAP service has already been told to stop.");
            break;

        case SERVICE_CONTROL_INTERROGATE:
#if DBG
            DbgPrint ("IPXSAP: Service control interrogate.\n");
#endif
            switch (OperationalState) {
                case OPER_STATE_UP:
                    if (ServiceIfActive)
                        ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                    else
                        ServiceStatus.dwCurrentState = SERVICE_STOPPED;
                    break;
                case OPER_STATE_STARTING:
                    if (ServiceIfActive) {
                        ServiceStatus.dwCheckPoint += 1;
                        ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
                        }
                    else
                        ServiceStatus.dwCurrentState = SERVICE_STOPPED;
                    break;
                case OPER_STATE_STOPPING:
                    if (ServiceIfActive)
                            // This is the case when router is being stopped
                            // SAP will be restarted soon
                        ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                    else {
                        ServiceStatus.dwCheckPoint += 1;
                        ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                        }
                    break;
                case OPER_STATE_DOWN:
                    if (ServiceIfActive) {
                            // This is the case when service is being started
                        ServiceStatus.dwCheckPoint += 1;
                        ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
                        }
                    else
                        ServiceStatus.dwCurrentState = SERVICE_STOPPED;
                    break;
                default:
                    ASSERTMSG ("SAP is in unknown state ", FALSE);
                }
            break;
        default:
            Trace (DEBUG_FAILURES,
                    "Service control handler called with unknown"
                    " or unsupported code %d.", fdwControl);
            break;

        }
#if DBG
    DbgPrint ("IPXSAP: Service control setting current state to %d.\n",
                            ServiceStatus.dwCurrentState);
#endif
    SetServiceStatus (ServiceStatusHandle, &ServiceStatus);
    LeaveCriticalSection (&OperationalStateLock);
    }


/*++
*******************************************************************
        S e r v i c e M a i n
Routine Description:
    Entry point to be called by service controller to start SAP agent
    (when SAP is not part of the router but is a standalone service,
    though running in the router process)
Arguments:
    argc - number of string arguments passed to service
    argv - array of string arguments passed to service
Return Value:
    None
*******************************************************************
--*/
VOID
ServiceMain (
    DWORD   argc,
    LPWSTR  argv[]
    ) {
    DWORD       rc;

    ServiceStatusHandle = RegisterServiceCtrlHandler (
                            TEXT("nwsapagent"), ServiceHandler);
    if (!ServiceStatusHandle)
    {
        return;
    }

    ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

    rc = DuplicateHandle (GetCurrentProcess (),
                            GetCurrentThread (),
                            GetCurrentProcess (),
                            (HANDLE *)&ServiceThreadHdl,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS );
    ASSERTMSG ("Could not duplicate service thread handle ", rc);

    EnterCriticalSection (&OperationalStateLock);
    ServiceIfActive = TRUE;

    if (RouterIfActive) {
        ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
        ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                         | SERVICE_ACCEPT_SHUTDOWN;
        SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

        LeaveCriticalSection (&OperationalStateLock);
#if DBG
        DbgPrint ("IPXSAP: Suspending service thread.\n");
#endif
        while (ServiceThreadHdl!=NULL) {
            SleepEx (INFINITE, TRUE);
#if DBG
            DbgPrint ("IPXSAP: Service thread awakened.\n");
#endif
            }
#if DBG
        DbgPrint ("IPXSAP: Service thread resumed.\n");
#endif
        EnterCriticalSection (&OperationalStateLock);
        if (!RouterIfActive) {
            if (OperationalState==OPER_STATE_UP)
                StopSAP ();
            LeaveCriticalSection (&OperationalStateLock);
#if DBG
            DbgPrint ("IPXSAP: Waiting for main thread to exit.\n");
#endif
            rc = WaitForSingleObject (MainThreadHdl, INFINITE);
            ASSERTMSG ("Unexpected result from wait for sap main thread ",
                                    rc== WAIT_OBJECT_0);
            EnterCriticalSection (&OperationalStateLock);
            CloseHandle (MainThreadHdl);
            MainThreadHdl = NULL;
            }
        }
    else {
        BOOL bInternalNetNumOk;

        // [pmay]
        // We use this scheme to automatically select the internal network
        // number of the machine we're running on.  If the net number is configured
        // as zero, this function will automatically select a random net num and
        // verify it's uniqueness on the net that this machine is attached to.
        DbgInitialize (hDLLInstance);
        if (AutoValidateInternalNetNum(&bInternalNetNumOk, DEBUG_ADAPTERS) == NO_ERROR) {
            if (!bInternalNetNumOk) {
                if (PnpAutoSelectInternalNetNumber(DEBUG_ADAPTERS) != NO_ERROR)
                    Trace(DEBUG_ADAPTERS, "StartRouter: Auto selection of net number failed.");
                else
                    AutoWaitForValidIntNetNum (10, NULL);
            }
        }

        ServiceStatus.dwWin32ExitCode = CreateAllComponents (NULL);
        if (ServiceStatus.dwWin32ExitCode==NO_ERROR) {
            // We use the thread that we were launched in
            // as IO thread
            ServiceStatus.dwWin32ExitCode = StartSAP ();
            if (ServiceStatus.dwWin32ExitCode==NO_ERROR) {
                LeaveCriticalSection (&OperationalStateLock);

                ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                                 | SERVICE_ACCEPT_SHUTDOWN;
                SetServiceStatus (ServiceStatusHandle, &ServiceStatus);

#if DBG
                DbgPrint ("IPXSAP: Suspending service thread.\n");
#endif
                while (ServiceThreadHdl!=NULL) {
                    SleepEx (INFINITE, TRUE);
#if DBG
                    DbgPrint ("IPXSAP: Service thread awakened.\n");
#endif
                    }
#if DBG
                DbgPrint ("IPXSAP: Service thread resumed.\n");
#endif

                EnterCriticalSection (&OperationalStateLock);
                ServiceIfActive = FALSE;
                if (!RouterIfActive) {
                    if (OperationalState==OPER_STATE_UP)
                        StopSAP ();
                    LeaveCriticalSection (&OperationalStateLock);
#if DBG
                    DbgPrint ("IPXSAP: Waiting for main thread to exit.\n");
#endif
                    rc = WaitForSingleObject (MainThreadHdl, INFINITE);
                    ASSERTMSG ("Unexpected result from wait for sap main thread ",
                                            rc== WAIT_OBJECT_0);
                    EnterCriticalSection (&OperationalStateLock);
                    }
                CloseHandle (MainThreadHdl);
                MainThreadHdl = NULL;
                }
            else {
                DeleteAllComponents ();
                }
            }
        }
    ServiceIfActive = FALSE;
    LeaveCriticalSection (&OperationalStateLock);

#if DBG
    DbgPrint ("IPXSAP: Service stopped.\n");
#endif
    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus (ServiceStatusHandle, &ServiceStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\syncpool.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\syncpool.c

Abstract:

	This module handles dynamic allocation and assigment of
	syncronization objects
Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/

#include "sapp.h"


/*++
*******************************************************************
		I n i t i a l i z e S y n c O b j P o o l
Routine Description:
	Initialize pool of syncronization objects
Arguments:
	objPool - pointer to object pool structure to be initialized
Return Value:
	None	
*******************************************************************
--*/
VOID
InitializeSyncObjPool (
	PSYNC_OBJECT_POOL		ObjPool
	) {
	InitializeCriticalSection (&ObjPool->SOP_Lock);
	ObjPool->SOP_Head.Next = NULL;
	}


/*++
*******************************************************************
		D e l e t e S y n c O b j P o o l
Routine Description:
	Disposes of resources associated with sync obj pool
Arguments:
	objPool - pointer to object pool structure to be cleand up
Return Value:
	None	
*******************************************************************
--*/
VOID
DeleteSyncObjPool (
	PSYNC_OBJECT_POOL		ObjPool
	) {
	PSINGLE_LIST_ENTRY		cur;

	while (ObjPool->SOP_Head.Next!=NULL) {
		cur = PopEntryList (&ObjPool->SOP_Head);
		CloseHandle (CONTAINING_RECORD (cur,
								 SYNC_OBJECT,
								 SO_Link)->SO_Event);
		GlobalFree (CONTAINING_RECORD (cur,
								 SYNC_OBJECT,
								 SO_Link));
		}
	DeleteCriticalSection (&ObjPool->SOP_Lock);
	}


HANDLE
GetObjectEvent (
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	) {
	DWORD			status;		// Status of OS calls
	PSYNC_OBJECT	sync;

	EnterCriticalSection (&ObjPool->SOP_Lock);
	if (ProtectedObj->PO_Sync==NULL) {	// if there is no event to wait on,
									// get one
									// First see if one is available
									// in the stack
		PSINGLE_LIST_ENTRY 	cur = PopEntryList (&ObjPool->SOP_Head);

		if (cur==NULL) {		// No, we'll have to create one
			sync = (PSYNC_OBJECT)GlobalAlloc (
									GMEM_FIXED,
									sizeof (SYNC_OBJECT));
            if (sync == NULL)
            {
                LeaveCriticalSection(&ObjPool->SOP_Lock);
                return NULL;
            }

			sync->SO_Event = CreateEvent (NULL,
											FALSE,	// Auto reset event
											FALSE,	// Initially nonsignaled
											NULL);
			ASSERT (sync->SO_Event!=NULL);


			}
		else
			sync = CONTAINING_RECORD (cur, SYNC_OBJECT, SO_Link);
		ProtectedObj->PO_Sync = sync;
		}
	else
		sync = ProtectedObj->PO_Sync;
			// Now as we set up the object to wait, we can leave critical
			// section and wait on event
	LeaveCriticalSection (&ObjPool->SOP_Lock);
	return sync->SO_Event;
	}

BOOL
AcquireProtectedObjWait (
#if DBG
	ULONG				line,
#endif
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	) {
#ifdef LOG_SYNC_STATS
	ULONG			startTime = GetTickCount ();
#endif
	DWORD			status;		// Status of OS calls
	BOOLEAN			result;		// Result of operation
	HANDLE			event = GetObjectEvent (ObjPool, ProtectedObj);
	while (TRUE) {
		status = WaitForSingleObject (
							event,
							60000*(ProtectedObj->PO_UseCount+1));
		if (status!=WAIT_TIMEOUT)
			break;
		else {
#if DBG
			SYSTEMTIME	localTime;
			ULONGLONG	takenTime;
			GetLocalTime (&localTime);
			SystemTimeToFileTime (&localTime, (PFILETIME)&takenTime);
			takenTime -= (GetTickCount ()-ProtectedObj->PO_Time)*10000i64;
			FileTimeToSystemTime ((PFILETIME)&takenTime, &localTime);
#endif

			Trace (DEBUG_FAILURES
#if DBG
				|TRACE_USE_MSEC
#endif
				,"Timed out on lock:%lx (cnt:%d)"
#if DBG
				", taken at:%02u:%02u:%02u:%03u by:%ld(%lx)"
#endif
#ifdef LOG_SYNC_STATS
				", waited:%ld sec"
#endif
				").",
				ProtectedObj,
				ProtectedObj->PO_UseCount
#if DBG
				,localTime.wHour, localTime.wMinute, localTime.wSecond,
				localTime.wMilliseconds, ProtectedObj->PO_Thread,
				ProtectedObj->PO_Thread
#endif
#ifdef LOG_SYNC_STATS
				,(GetTickCount ()-startTime)/1000
#endif
				);
			}
		}
	ASSERTERRMSG ("Wait event failed.", status==WAIT_OBJECT_0);
	
#if DBG
	ProtectedObj->PO_Line = line;
	ProtectedObj->PO_Thread = GetCurrentThreadId ();
#endif

	EnterCriticalSection (&ObjPool->SOP_Lock);
	if ((ProtectedObj->PO_UseCount==0)
			&& (ProtectedObj->PO_Sync!=NULL)) {
		PushEntryList (&ObjPool->SOP_Head, &ProtectedObj->PO_Sync->SO_Link);
		ProtectedObj->PO_Sync = NULL;
		}
#ifdef LOG_SYNC_STATS
	ProtectedObj->PO_WaitCount += 1;
	ProtectedObj->PO_TotalWait += (GetTickCount () - startTime);
#endif
	LeaveCriticalSection (&ObjPool->SOP_Lock);

	return TRUE;
	}


BOOL
ReleaseProtectedObjNoWait (
#if DBG
	ULONG				line,
#endif
	PSYNC_OBJECT_POOL	ObjPool,	
	PPROTECTED_OBJECT	ProtectedObj
	) {
    if (InterlockedDecrement (&ProtectedObj->PO_UseCount)==0) {
	    EnterCriticalSection (&ObjPool->SOP_Lock);
	    if ((ProtectedObj->PO_UseCount==0)
			    && (ProtectedObj->PO_Sync!=NULL)) {
		    PushEntryList (&ObjPool->SOP_Head, &ProtectedObj->PO_Sync->SO_Link);
		    ProtectedObj->PO_Sync = NULL;
		    }
	    LeaveCriticalSection (&ObjPool->SOP_Lock);
        }

    return FALSE;
    }

#ifdef LOG_SYNC_STATS
VOID
DumpProtectedObjStats (
	PPROTECTED_OBJECT	ProtectedObj
	) {
	Trace (TRACE_USE_MASK,
		"Lock: %lx, accessed: %ld, waited on: %d, average wait: %i64d.",
		ProtectedObj,
		ProtectedObj->PO_AccessCount, ProtectedObj->PO_WaitCount,
		(ProtectedObj->PO_WaitCount>0)
			? (ULONGLONG)(ProtectedObj->PO_TotalWait/ProtectedObj->PO_WaitCount)
			: 0i64);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\timermgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\timermgr.h

Abstract:

	Timer queue manager for SAP agent. Header file

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_TIMERMGR_
#define _SAP_TIMERMGR_

	// Timer request parameters
typedef struct _TM_PARAM_BLOCK TM_PARAM_BLOCK, *PTM_PARAM_BLOCK;
struct _TM_PARAM_BLOCK {
		LIST_ENTRY		link;
		BOOL			(*ExpirationCheckProc) (PTM_PARAM_BLOCK, PVOID);
		DWORD			dueTime;
		};


/*++
*******************************************************************
		C r e a t e T i m e r Q u e u e

Routine Description:
		Allocates resources for timer queue

Arguments:
	wakeObject - sync object, to be signalled when
			timer manager needs a shot to process its queue

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
IpxSapCreateTimerQueue (
	HANDLE			*wakeObject
	);


/*++
*******************************************************************
		D e l e t e T i m e r Q u e u e

Routine Description:
	Releases all resources associated with timer queue

Arguments:
	None

Return Value:
	NO_ERROR - operation completed OK

*******************************************************************
--*/
VOID
IpxSapDeleteTimerQueue (
	void
	);

/*++
*******************************************************************
		E x p i r e T i m e r Q u e u e

Routine Description:
	Expires (completes) all requests in timer queue
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
ExpireTimerQueue (
	void
	);

/*++
*******************************************************************
		E x p i r e L R R e q u s t s

Routine Description:
	Expires (completes) Low Resolution timer requests
	that return true from expiration check routine
Arguments:
	context	- context to pass to expiration check routine
Return Value:
	None
*******************************************************************
--*/
VOID
ExpireLRRequests (
	PVOID	context
	);



/*++
*******************************************************************
		P r o c e s s T i m e r Q u e u e

Routine Description:
	Process timer queues and moves expired requests to completion queue
	This routine should be called when wake object is signalled
Arguments:
	None

Return Value:
	None
*******************************************************************
--*/
VOID
ProcessTimerQueue (
	void
	);

/*++
*******************************************************************
		A d d H R T i m e r R e q u e s t

Routine Description:
	Enqueues request for hi-res timer (delay in order of msec)
Arguments:
	treq - timer parameter block: dueTime  field must be set
Return Value:
	None

*******************************************************************
--*/
VOID
AddHRTimerRequest (
	PTM_PARAM_BLOCK			item
	);

/*++
*******************************************************************
		A d d L R T i m e r R e q u e s t

Routine Description:
	Enqueues request for lo-res timer (delay in order of sec)
Arguments:
	treq - timer parameter block: dueTime  field must be set
Return Value:
	None
*******************************************************************
--*/
VOID
AddLRTimerRequest (
	PTM_PARAM_BLOCK			item
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\workers.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\workers.c

Abstract:

	This module implement all SAP agent work items

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"


// Max number of pending recv work items
LONG	MaxUnprocessedRequests=SAP_MAX_UNPROCESSED_REQUESTS_DEF;

// Minimum number of queued recv requests
LONG	MinPendingRequests = SAP_MIN_REQUESTS_DEF;


// How often to check on pending triggered update
ULONG TriggeredUpdateCheckInterval=SAP_TRIGGERED_UPDATE_CHECK_INTERVAL_DEF;

// How many requests to send if no response received within check interval
ULONG MaxTriggeredUpdateRequests=SAP_MAX_TRIGGERED_UPDATE_REQUESTS_DEF;

// Whether to respond for internal servers that are not registered with SAP
// through the API calls (for standalone service only)
ULONG RespondForInternalServers=SAP_RESPOND_FOR_INTERNAL_DEF;

// Delay in response to general reguests for specific server type
// if local servers are included in the packet
ULONG DelayResponseToGeneral=SAP_DELAY_RESPONSE_TO_GENERAL_DEF;

// Delay in sending change broadcasts if packet is not full
ULONG DelayChangeBroadcast=SAP_DELAY_CHANGE_BROADCAST_DEF;

UCHAR IPX_BCAST_NODE[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
UCHAR IPX_SAP_SOCKET[2] = {0x04, 0x52};
UCHAR IPX_INVALID_NET[4] = {0};
UCHAR IPX_INVALID_NODE[6] = {0};

#define SetupIpxSapPacket(packet,oper,net,node,sock)	\
	(packet)->PacketType = IPX_SAP_PACKET_TYPE;			\
	PUTUSHORT (oper, &(packet)->Operation);				\
	IpxNetCpy ((packet)->Dst.Network, net);				\
	IpxNodeCpy ((packet)->Dst.Node, node);				\
	IpxSockCpy ((packet)->Dst.Socket, sock);

typedef struct _WORKER_QUEUE {
		LONG				WQ_WorkerCount;
		LONG				WQ_RequestQuota;
		LONG				WQ_RequestExtra;
		LIST_ENTRY			WQ_Queue;
		HANDLE				WQ_Heap;
		HANDLE				WQ_DoneEvent;
		HANDLE				WQ_RecvEvent;
		} WORKER_QUEUE, *PWORKER_QUEUE;

WORKER_QUEUE		WorkerQueue;

	// Work item that obtains and processes SAP requests
typedef struct _REQ_ITEM {
		IO_WORKER			iow;
		SAP_BUFFER			packet;
		} REQ_ITEM, *PREQ_ITEM;


	// Work item that generates responses for SAP general requests
typedef struct _RESP_ITEM {
		PINTERFACE_DATA		intf;
		USHORT				svrType;	// Type of servers requested
		BOOLEAN				bcast;		// Is destination a broadcast
								// address ?
		HANDLE				hEnum;	// Enumeration handle to keep
								// track of sent servers
		IO_WORKER			iow;
		TIMER_WORKER		tmw;
		SAP_BUFFER			packet;
		} RESP_ITEM, *PRESP_ITEM;

	// Work item that generates responses for SAP GETNEAREST requests
typedef struct _GNEAR_ITEM {
		PINTERFACE_DATA		intf;
		IO_WORKER			iow;
		SAP_BUFFER			packet;
		} GNEAR_ITEM, *PGNEAR_ITEM;

	// Work item that sends SAP general requests
typedef struct _SREQ_ITEM {
		PINTERFACE_DATA		intf;
		IO_WORKER			iow;
		SAP_BUFFER			packet;
		} SREQ_ITEM, *PSREQ_ITEM;


	// Work item that generates periodic and change broadcasts
typedef struct _BCAST_ITEM {
		IO_WORKER			iow;
		TIMER_WORKER		tmw;
		PINTERFACE_DATA		intf;
		DWORD				nextBcast;	// Time (windows time in msec) for
								// next broadcast
		INT					delayedSvrCount; // Number of servers already
								// in the packet that were delayed because
								// packet wasn't full
		DWORD				delayedSendTime; // Time until packet was delayed
								// because it wasn't full
		HANDLE				chngEnum;	// Enumeration hadnle that keeps
								// track of chnagd servers
		HANDLE				perdEnum;	// Enumeration handle that keeps
								// track of servers during periodic 
								// broadcasts
		SAP_BUFFER			packet;
		} BCAST_ITEM, *PBCAST_ITEM;

	// Work item that gets and processes LPC requests
typedef struct _LPC_ITEM {
		LPC_WORKER				lpcw;
		NWSAP_REQUEST_MESSAGE	request;
		} LPC_ITEM, *PLPC_ITEM;

typedef struct _TREQ_ITEM {
		IO_WORKER			iow;
		TIMER_WORKER		tmw;
		AR_PARAM_BLOCK		ar;
		PINTERFACE_DATA		intf;
		ULONG				pktCount;
		ULONG				resend;
		ULONG				listenSave;
		ULONG				intervalSave;
		SAP_BUFFER			packet;
		} TREQ_ITEM, *PTREQ_ITEM;


typedef union _WORK_ITEM {
		REQ_ITEM		req;
		LPC_ITEM		lpc;
		BCAST_ITEM		bcast;
		SREQ_ITEM		sreq;
		TREQ_ITEM		treq;
		GNEAR_ITEM		gnear;
		RESP_ITEM		resp;
		} WORK_ITEM, *PWORK_ITEM;


// Parameter block passed to enumeration call back filter procedures
typedef struct _GR_FILTER_PARAMS {
		INT					svrIdx;			// Index of server info in SAP packet
		BOOLEAN				localSvr;		// Local server included in the packet
		USHORT				localHopCount;	// Hop count used to track servers local
							// to the interface that may prevent use from broad-
							// casting info of same server obtained on different
							// interface
		PINTERFACE_DATA		intf;		// Pointer to interface data
		PSAP_BUFFER			packet;			// Packet to be filled
		} GR_FILTER_PARAMS, *PGR_FILTER_PARAMS;

typedef struct _GN_FILTER_PARAMS {
		BOOLEAN				found;		// flag indicating the one server was found
		USHORT				localHopCount;	// Hop count used to track servers local
							// to the interface that may prevent use from broad-
							// casting info of same server obtained on different
							// interface
		PINTERFACE_DATA		intf;		// Pointer to interface data
		PSAP_BUFFER			packet;			// Packet to be filled
		} GN_FILTER_PARAMS, *PGN_FILTER_PARAMS;

// Parameters used to construct a list of servers that 
// need their internal network information updated.
typedef struct _SERVER_INTERNAL_UPDATE_NODE {
	ULONG	InterfaceIndex;
	ULONG	Protocol;
	PUCHAR	AdvertisingNode;
	INT		Flags;
	IPX_SERVER_ENTRY_P Server;
	struct _SERVER_INTERNAL_UPDATE_NODE * pNext;
} SERVER_INTERNAL_UPDATE_NODE;	

#define AllocateWorker(worker,type) 												\
		((worker=(type *)HeapAlloc(WorkerQueue.WQ_Heap, 0,  sizeof (WORK_ITEM)))	\
			? InterlockedIncrement (&WorkerQueue.WQ_WorkerCount)					\
			: 0)

#define DeallocateWorker(worker) {										\
		HeapFree (WorkerQueue.WQ_Heap, 0, worker);						\
		if (InterlockedDecrement (&WorkerQueue.WQ_WorkerCount)<0) {		\
			BOOL	res = SetEvent (WorkerQueue.WQ_DoneEvent);			\
			ASSERTERRMSG ("Can't set workers done event ", res);		\
			}															\
		}


// Local prototypes
VOID APIENTRY
ProcessReqItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessRespIOItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessRespTMItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessGnearItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessBcastIOItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessBcastTMItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessShutItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessSreqItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessSreqItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessLPCItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessTreqIOItem (
	PVOID		worker
	);
VOID APIENTRY
ProcessTreqTMItem (
	PVOID		worker
	);
VOID APIENTRY
FreeTreqItem (
	PAR_PARAM_BLOCK	rslt
	);

/*++
*******************************************************************
		I n i t i a l i z e W o r k e r s

Routine Description:
	Initialize heap to be used for allocation of work items
Arguments:
	None
Return Value:
	NO_ERROR - heap was initialized  OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitializeWorkers (
	HANDLE	RecvEvent
	) {
	DWORD		status;
	
	if (MaxUnprocessedRequests<(MinPendingRequests*11/10)) {
		MaxUnprocessedRequests = MinPendingRequests*11/10; 
		Trace (DEBUG_FAILURES,
			"Set "SAP_MAX_UNPROCESSED_REQUESTS_STR" to %d (10%% above "
			SAP_MIN_REQUESTS_STR")", MaxUnprocessedRequests);
		}

	WorkerQueue.WQ_WorkerCount = 0;
	WorkerQueue.WQ_RequestQuota = MaxUnprocessedRequests;
	WorkerQueue.WQ_RequestExtra = -MinPendingRequests;
	WorkerQueue.WQ_DoneEvent = NULL;
	WorkerQueue.WQ_RecvEvent = RecvEvent;
	WorkerQueue.WQ_Heap = HeapCreate (0, 0, 0);
	if (WorkerQueue.WQ_Heap!=NULL) {
		return NO_ERROR;
		}
	else {
		status = GetLastError ();
		Trace (DEBUG_FAILURES,
			 "File: %s, line %ld. Could not allocate worker's heap (gle:%ld).",
									__FILE__, __LINE__, status);
		}
	return status;
	}

/*++
*******************************************************************
		S h u t d o w n W o r k e r s

Routine Description:
	Stops new worker creation and signals event when all
	workers are deleted
Arguments:
	doneEvent - event to be signalled when all workers are deleted
Return Value:
	None
	
*******************************************************************
--*/
VOID
ShutdownWorkers (
	IN HANDLE	doneEvent
	) {
	WorkerQueue.WQ_DoneEvent = doneEvent;

	if (InterlockedDecrement (&WorkerQueue.WQ_WorkerCount)<0) {
		BOOL	res = SetEvent (WorkerQueue.WQ_DoneEvent);
		ASSERTERRMSG ("Can't set workers done event ", res);
		}
	}

/*++
*******************************************************************
		D e l e t e W o r k e r s

Routine Description:
	Deletes heap used for work items (and thus all work items as well)
Arguments:
	None
Return Value:
	None
	
*******************************************************************
--*/
VOID
DeleteWorkers (
	void
	) {
	ASSERT (WorkerQueue.WQ_WorkerCount==-1);
	HeapDestroy (WorkerQueue.WQ_Heap);
	}

    
/*++
*******************************************************************
		H o p C o u n t F i l t e r

Routine Description:
	Server enumeration callback proc that filters out servers with high hop
	(<=15 for same interface, <15 for rest)
Arguments:
	CBParam - enumeration callback parameter (param block above)
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	TRUE (to stop enumeration) when sap packet gets filled up,
	FALSE otherwise
*******************************************************************
--*/
BOOL
HopCountFilter (
	IN LPVOID					CBParam,
	IN PIPX_SERVER_ENTRY_P		Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define params ((PGR_FILTER_PARAMS)CBParam)

	ASSERTMSG ("To many servers ", params->svrIdx<IPX_SAP_MAX_ENTRY);

	if ((InterfaceIndex!=INTERNAL_INTERFACE_INDEX)
			|| (IpxNetCmp (Server->Network, IPX_INVALID_NET)!=0)
				&& ((Protocol==IPX_PROTOCOL_LOCAL)
					|| Routing
					|| RespondForInternalServers)) {
		if ((Server->HopCount<IPX_MAX_HOP_COUNT-1)
				|| ((InterfaceIndex==params->intf->index) 
					&& (Server->HopCount<IPX_MAX_HOP_COUNT)) ) {
			if ((params->intf->filterOut==SAP_DONT_FILTER)
					|| ((params->intf->filterOut==SAP_FILTER_PERMIT)
							&& Filter (FILTER_TYPE_SUPPLY, 
								params->intf->index, Server->Type, Server->Name))
					|| ((params->intf->filterOut==SAP_FILTER_DENY)
							&& !Filter (FILTER_TYPE_SUPPLY, 
								params->intf->index, Server->Type, Server->Name)))	{
				IpxServerCpy (&params->packet->Entries[params->svrIdx], Server);
				PUTUSHORT (Server->Type, &params->packet->Entries[params->svrIdx].Type);
				if (InterfaceIndex==params->intf->index) {
					PUTUSHORT (Server->HopCount, 
						&params->packet->Entries[params->svrIdx].HopCount);
					}
				else {
										 
					PUTUSHORT (Server->HopCount+1, 
						&params->packet->Entries[params->svrIdx].HopCount);
					}
				params->svrIdx += 1;
				if (InterfaceIndex==INTERNAL_INTERFACE_INDEX)
					params->localSvr = TRUE;
//				Trace (DEBUG_ENTRIES, "\tAdding server, type: %04x, name: %.48s, hops: %d.",
//									Server->Type, Server->Name, Server->HopCount);
				if (params->svrIdx>=IPX_SAP_MAX_ENTRY)
					return TRUE;
				}
			}
		}
	
#undef params
	return FALSE;
	}

/*++
*******************************************************************
		S p l i t H o r i z o n H o p C o u n t F i l t e r

Routine Description:
	Server enumeration callback proc that filters out servers with high hop
	(<15) and applies split horizon algorithm based on interface index
Arguments:
	CBParam - enumeration callback parameter (param block above)
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	TRUE (to stop enumeration) when sap packet gets filled up,
	FALSE otherwise
*******************************************************************
--*/
BOOL
SplitHorizonHopCountFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define params ((PGR_FILTER_PARAMS)CBParam)
	ASSERTMSG ("To many servers ", params->svrIdx<IPX_SAP_MAX_ENTRY);
	if (Flags & SDB_MAIN_NODE_FLAG) {
			// Only send entries that are not received through local interface
			// and that do not have entry with equal hop count on local interface
		if (((InterfaceIndex!=INTERNAL_INTERFACE_INDEX)
				|| (IpxNetCmp (Server->Network, IPX_INVALID_NET)!=0)
					&& ((Protocol==IPX_PROTOCOL_LOCAL)
						|| Routing
						|| RespondForInternalServers))
				&& (InterfaceIndex!=params->intf->index)
				&& (Server->HopCount<params->localHopCount)
				&&  ((params->intf->filterOut==SAP_DONT_FILTER)
						|| ((params->intf->filterOut==SAP_FILTER_PERMIT)
							&& Filter (FILTER_TYPE_SUPPLY, 
								params->intf->index, Server->Type, Server->Name))
						|| ((params->intf->filterOut==SAP_FILTER_DENY)
							&& !Filter (FILTER_TYPE_SUPPLY,
								params->intf->index, Server->Type, Server->Name))))	{
			IpxServerCpy (&params->packet->Entries[params->svrIdx], Server);
			PUTUSHORT (Server->Type,
				&params->packet->Entries[params->svrIdx].Type);
			PUTUSHORT (Server->HopCount+1,
					&params->packet->Entries[params->svrIdx].HopCount);
			if (InterfaceIndex==INTERNAL_INTERFACE_INDEX)
				params->localSvr = TRUE;
			params->svrIdx += 1;
//			Trace (DEBUG_ENTRIES, "\tAdding server, type: %04x, name: %.48s, hops: %d.",
//								Server->Type, Server->Name, Server->HopCount);
			if (params->svrIdx>=IPX_SAP_MAX_ENTRY)
				return TRUE;
			}
			// Make sure we won't send deleted servers
		params->localHopCount = IPX_MAX_HOP_COUNT-1;
		}
	else if (InterfaceIndex==params->intf->index) {
		params->localHopCount = Server->HopCount; // Remember hop count of entry
												// on local interface
//		Trace (DEBUG_ENTRIES, "\tBackup server entry, type: %04x, name: %.48s, hops: %d.",
//				Server->Type, Server->Name, Server->HopCount);
		}

#undef params
	return FALSE;
	}



/*++
*******************************************************************
		S p l i t H o r i z o n F i l t e r

Routine Description:
	Server enumeration callback proc that  applies split horizon algorithm
	based on interface index to filter out enumerated servers
Arguments:
	CBParam - enumeration callback parameter (param block above)
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	TRUE (to stop enumeration) when sap packet gets filled up,
	FALSE otherwise
*******************************************************************
--*/
BOOL
SplitHorizonFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define params ((PGR_FILTER_PARAMS)CBParam)

	ASSERTMSG ("To many servers ", params->svrIdx<IPX_SAP_MAX_ENTRY);
	if (Flags&SDB_MAIN_NODE_FLAG) {
			// Only send entries that are not received through local interface
			// and that do not have entry with equal hop count on local interface
		if ( (((InterfaceIndex==INTERNAL_INTERFACE_INDEX)
						&& (IpxNetCmp (Server->Network, IPX_INVALID_NET)!=0)
							&& ((Protocol==IPX_PROTOCOL_LOCAL)
								|| Routing
								|| RespondForInternalServers))
					|| (InterfaceIndex!=params->intf->index))
				&& (Server->HopCount<params->localHopCount)
					&& ((params->intf->filterOut==SAP_DONT_FILTER)
						|| ((params->intf->filterOut==SAP_FILTER_PERMIT)
								&& Filter (FILTER_TYPE_SUPPLY, 
									params->intf->index, Server->Type, Server->Name))
						|| ((params->intf->filterOut==SAP_FILTER_DENY)
								&& !Filter (FILTER_TYPE_SUPPLY, 
									params->intf->index, Server->Type, Server->Name))) ){
			IpxServerCpy (&params->packet->Entries[params->svrIdx], Server);
			PUTUSHORT (Server->Type,
						&params->packet->Entries[params->svrIdx].Type);
			if ((Server->HopCount<IPX_MAX_HOP_COUNT)
                    && !(Flags&SDB_DISABLED_NODE_FLAG)) {
				PUTUSHORT (Server->HopCount+1,
					&params->packet->Entries[params->svrIdx].HopCount);
			}
			else {
				PUTUSHORT (IPX_MAX_HOP_COUNT,
						&params->packet->Entries[params->svrIdx].HopCount);
			}
			if (InterfaceIndex==INTERNAL_INTERFACE_INDEX)
				params->localSvr = TRUE;
			params->svrIdx += 1;
//			Trace (DEBUG_ENTRIES, "\tAdding server, type: %04x, name: %.48s, hops: %d.",
//								Server->Type, Server->Name, Server->HopCount);
			if (params->svrIdx>=IPX_SAP_MAX_ENTRY)
				return TRUE;
			}
		params->localHopCount = IPX_MAX_HOP_COUNT+1;
		}
	else if ((InterfaceIndex==params->intf->index)
            && !(Flags&SDB_DISABLED_NODE_FLAG)) {
		params->localHopCount = Server->HopCount;
//		Trace (DEBUG_ENTRIES,"\tBackup server entry, type: %04x, name: %.48s, hops: %d.",
//				Server->Type, Server->Name, Server->HopCount);
		}

#undef params
	return FALSE;
	}

/*++
*******************************************************************
		S p l i t H o r i z o n F i l t e r

Routine Description:
	Server enumeration callback proc that  applies split horizon algorithm
	based on interface index to filter out enumerated servers
	and only gets deleted servers (HopCount=16)
Arguments:
	CBParam - enumeration callback parameter (param block above)
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	TRUE (to stop enumeration) when sap packet gets filled up,
	FALSE otherwise
*******************************************************************
--*/
BOOL
SplitHorizonDeletedFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define params ((PGR_FILTER_PARAMS)CBParam)

	ASSERTMSG ("To many servers ", params->svrIdx<IPX_SAP_MAX_ENTRY);
	if (Flags&SDB_MAIN_NODE_FLAG) {
			// Only send entries that are not received through local interface
			// and that do not have entry with equal hop count on local interface
		if (((Server->HopCount>=IPX_MAX_HOP_COUNT)
					|| (Flags&SDB_DISABLED_NODE_FLAG))
				&& (((InterfaceIndex==INTERNAL_INTERFACE_INDEX)
						&& (IpxNetCmp (Server->Network, IPX_INVALID_NET)!=0)
							&& ((Protocol==IPX_PROTOCOL_LOCAL)
								|| Routing
								|| RespondForInternalServers))
					|| (InterfaceIndex!=params->intf->index))
				&& ((params->intf->filterOut==SAP_DONT_FILTER)
					|| ((params->intf->filterOut==SAP_FILTER_PERMIT)
							&& Filter (FILTER_TYPE_SUPPLY, 
								params->intf->index, Server->Type, Server->Name))
					|| ((params->intf->filterOut==SAP_FILTER_DENY)
							&& !Filter (FILTER_TYPE_SUPPLY, 
								params->intf->index, Server->Type, Server->Name))) ){
			IpxServerCpy (&params->packet->Entries[params->svrIdx], Server);
			PUTUSHORT (Server->Type,
						&params->packet->Entries[params->svrIdx].Type);
			PUTUSHORT (IPX_MAX_HOP_COUNT,
						&params->packet->Entries[params->svrIdx].HopCount);

			params->svrIdx += 1;
//			Trace (DEBUG_ENTRIES, "\tAdding server, type: %04x, name: %.48s, hops: %d.",
//								Server->Type, Server->Name, Server->HopCount);
			if (params->svrIdx>=IPX_SAP_MAX_ENTRY)
				return TRUE;
			}
		}

#undef params
	return FALSE;
	}

/*++
*******************************************************************
		G e t N e a r e s t F i l t e r

Routine Description:
	Server enumeration callback proc that gets internal server if there is one or
	server with lowest hop count not on the local interface
Arguments:
	CBParam - enumeration callback parameter (param block above)
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	TRUE (to stop enumeration) when it finds first internal server,
	FALSE otherwise
*******************************************************************
--*/
BOOL
GetNearestFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define params ((PGN_FILTER_PARAMS)CBParam)

	if (((InterfaceIndex==INTERNAL_INTERFACE_INDEX) 
				&& !(Flags&SDB_DONT_RESPOND_NODE_FLAG)
				&& (IpxNetCmp (Server->Network, IPX_INVALID_NET)!=0)
					&& ((Protocol==IPX_PROTOCOL_LOCAL)
						|| Routing
						|| RespondForInternalServers))
			|| ((InterfaceIndex!=params->intf->index)
			    && (Server->HopCount<params->localHopCount))) {
		if ((params->intf->filterOut==SAP_DONT_FILTER)
				|| ((params->intf->filterOut==SAP_FILTER_PERMIT)
						&& Filter (FILTER_TYPE_SUPPLY, 
							params->intf->index, Server->Type, Server->Name))
				|| ((params->intf->filterOut==SAP_FILTER_DENY)
						&& !Filter (FILTER_TYPE_SUPPLY, 
							params->intf->index, Server->Type, Server->Name))) {
			IpxServerCpy (&params->packet->Entries[0], Server);
			PUTUSHORT (Server->Type, &params->packet->Entries[0].Type);
			PUTUSHORT (Server->HopCount+1,
					&params->packet->Entries[0].HopCount);
//			Trace (DEBUG_ENTRIES, "\tGetting server, type: %04x, name: %.48s, hops: %d.",
//								Server->Type, Server->Name, Server->HopCount);
			params->found = TRUE;
			params->localHopCount = Server->HopCount;
			if (InterfaceIndex==INTERNAL_INTERFACE_INDEX)
				return TRUE;
			}
		}

#undef params
	return FALSE;
	}

/*++
*******************************************************************
		C o u n t S e r v e r s F i l t e r

Routine Description:
	Server enumeration callback proc that count servers with which it
	is called back
Arguments:
	CBParam - pointer to counter
	Server, InterfaceIndex, Protocol, AdvertisingNode, Flags - server info
Return Value:
	FALSE to tell SDB to continue enumeration
*******************************************************************
--*/
BOOL
CountServersFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags
	) {
#define count ((ULONG *)CBParam)
	if (Protocol==IPX_PROTOCOL_SAP)
		*count += 1;
	return FALSE;
#undef count
	}


VOID
AddRecvRequests (
	LONG	count
	) {
	InterlockedExchangeAdd (&WorkerQueue.WQ_RequestQuota, count);
	if (InterlockedExchangeAdd (&WorkerQueue.WQ_RequestExtra, (-count))<count) {
		BOOL res = SetEvent (WorkerQueue.WQ_RecvEvent);
		ASSERTMSG ("Could not set recv event ", res);
		}
	else {
		BOOL res = ResetEvent (WorkerQueue.WQ_RecvEvent);
		ASSERTMSG ("Could not reset recv event ", res);
		}
	}

VOID
RemoveRecvRequests (
	LONG	count
	) {
	InterlockedExchangeAdd (&WorkerQueue.WQ_RequestQuota, (-count));
	if (InterlockedExchangeAdd (&WorkerQueue.WQ_RequestExtra, count)>(-count)) {
		BOOL res = ResetEvent (WorkerQueue.WQ_RecvEvent);
		ASSERTMSG ("Could not reset recv event ", res);
		}
	}


/*++
*******************************************************************
		I n i t R e q I t e m

Routine Description:
	Allocate and initialize IO request item
	Enqueue the request
Arguments:
	None
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitReqItem (
	VOID
	) {
	PREQ_ITEM		reqItem;

	do {
		if (InterlockedDecrement (&WorkerQueue.WQ_RequestQuota)<0) {
			InterlockedIncrement (&WorkerQueue.WQ_RequestQuota);
			return NO_ERROR;
			}

		if (!AllocateWorker (reqItem, REQ_ITEM)) {
			Trace (DEBUG_FAILURES,
				"File: %s, line %ld. Could not allocate request item (gle:%ld).",
										__FILE__, __LINE__, GetLastError ());
			InterlockedIncrement (&WorkerQueue.WQ_RequestQuota);
			return ERROR_NOT_ENOUGH_MEMORY;
			}
		
		reqItem->iow.worker = ProcessReqItem;
		reqItem->iow.io.buffer = (PUCHAR)&reqItem->packet;
		reqItem->iow.io.cbBuffer = sizeof (reqItem->packet);
		Trace (DEBUG_REQ, "Generated receive request: %08lx.", reqItem);
		EnqueueRecvRequest (&reqItem->iow.io);
		}
	while (InterlockedIncrement (&WorkerQueue.WQ_RequestExtra)<0);

	return NO_ERROR;
	}


/*++
*******************************************************************
		P r o c e s s R e q I t e m

Routine Description:
	Process received request
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessReqItem (
	PVOID		worker
	) {
	PREQ_ITEM		reqItem = CONTAINING_RECORD (worker, REQ_ITEM, iow.worker);
	INT				i;
	PINTERFACE_DATA	intf;
	LONG			count;

	Trace (DEBUG_REQ, "Processing received request item %08lx on adpt: %d.",
								reqItem, reqItem->iow.io.adpt);

	count = InterlockedDecrement (&WorkerQueue.WQ_RequestExtra);

	if ((OperationalState==OPER_STATE_UP)
			&& (reqItem->iow.io.status==NO_ERROR)) {

		if (count<0) {
			BOOL	res = SetEvent (WorkerQueue.WQ_RecvEvent);
			ASSERTMSG ("Failed to set recv event ", res);
			}

		intf = GetInterfaceReference (reqItem->iow.io.adpt);
		if (intf!=NULL) {
			PSAP_BUFFER		packet = &reqItem->packet;
			if ((IpxNodeCmp (packet->Src.Node, intf->adapter.LocalNode)!=0)
					|| (IpxSockCmp (packet->Src.Socket, IPX_SAP_SOCKET)!=0)
					|| (IpxNetCmp (packet->Src.Network, intf->adapter.Network)!=0)) {
				InterlockedIncrement (&intf->stats.SapIfInputPackets);
				packet->Length = GETUSHORT(&packet->Length);
				if (packet->Length>reqItem->iow.io.cbBuffer)
					packet->Length = (USHORT)reqItem->iow.io.cbBuffer;

				if (reqItem->iow.io.status==NO_ERROR) {
					if (packet->Length
							>=	(FIELD_OFFSET (SAP_BUFFER, Operation)
									+sizeof(packet->Operation))) {
						packet->Operation = GETUSHORT(&packet->Operation);
						switch (packet->Operation) {
							case SAP_GENERAL_REQ:
								Trace (DEBUG_REQ, "\tGeneral request received for type: %04x.",
													GETUSHORT (&packet->Entries[0].Type));
								if (intf->info.Supply==ADMIN_STATE_ENABLED) {
									PIPX_SERVER_ENTRY_P	pEntry = packet->Entries;
									if (packet->Length >= (FIELD_OFFSET (
												SAP_BUFFER,	Entries[0].Type)
												+sizeof (pEntry->Type))) {
										pEntry->Type = GETUSHORT (&pEntry->Type);
										InitRespItem (intf,
													pEntry->Type,
													&packet->Src,
													memcmp (
															packet->Dst.Node,
															IPX_BCAST_NODE,
															sizeof (IPX_BCAST_NODE))
														==0);
										}
									}
								break;
							case SAP_GENERAL_RESP:
								Trace (DEBUG_REQ, "\tGeneral response received.");
								if (intf->info.Listen==ADMIN_STATE_ENABLED) {
									PIPX_SERVER_ENTRY_P	pEntry = packet->Entries;
									for (i=0; (i<IPX_SAP_MAX_ENTRY)
												&& ((PUCHAR)&pEntry[1]-(PUCHAR)packet
														<=packet->Length);
											i++,pEntry++) {
										pEntry->Type = GETUSHORT (&pEntry->Type);
										if ((intf->filterIn==SAP_DONT_FILTER)
											|| ((intf->filterIn==SAP_FILTER_PERMIT)
												&& Filter (FILTER_TYPE_LISTEN,
													intf->index,
													pEntry->Type, pEntry->Name))
											|| ((intf->filterIn==SAP_FILTER_DENY)
												&& !Filter (FILTER_TYPE_LISTEN,
													intf->index,
													pEntry->Type, pEntry->Name))) {
											if ((IpxNodeCmp (packet->Src.Node, intf->adapter.LocalNode)!=0)
													|| (IpxNetCmp (packet->Src.Network, intf->adapter.Network)!=0)) {
												USHORT	Metric;
												if (GetServerMetric (pEntry, &Metric)==NO_ERROR)
													pEntry->HopCount = GETUSHORT (&pEntry->HopCount);
												else
													pEntry->HopCount = IPX_MAX_HOP_COUNT;
												UpdateServer (
														pEntry,
														intf->index,
														IPX_PROTOCOL_SAP,
														(intf->info.PeriodicUpdateInterval!=MAXULONG)
															? (intf->info.PeriodicUpdateInterval
																*intf->info.AgeIntervalMultiplier)
															: INFINITE,
														packet->Src.Node,
														0,
														NULL
														);
												}
											else {
												if (GETUSHORT (&pEntry->HopCount)<IPX_MAX_HOP_COUNT)
													pEntry->HopCount = 0;
												else
													pEntry->HopCount = IPX_MAX_HOP_COUNT;
												IpxNetCpy (pEntry->Network, INTERNAL_IF_NET);
												IpxNodeCpy (pEntry->Node, INTERNAL_IF_NODE);
												UpdateServer (
														pEntry,
														INTERNAL_INTERFACE_INDEX,
														IPX_PROTOCOL_SAP,
														ServerAgingTimeout*60,
														IPX_BCAST_NODE,
														0,
														NULL
														);
												}
	//										Trace (DEBUG_ENTRIES, "\tInserting server,"
	//													" type: %04x, hops: %d, name: %.48s.",
	//													pEntry->Type,
	//													pEntry->HopCount,
	//													pEntry->Name);
											if (((intf->stats.SapIfOperState!=OPER_STATE_UP)
													|| (OperationalState!=OPER_STATE_UP))
													&& (IpxNetCmp (pEntry->Network, INTERNAL_IF_NET)!=0)) {
												pEntry->HopCount = IPX_MAX_HOP_COUNT;
												UpdateServer (
														pEntry,
														intf->index,
														IPX_PROTOCOL_SAP,
														INFINITE,
														packet->Src.Node,
														0,
														NULL
														);
												break;
												}
											} // End if filter path
										} // end for
								
									} // end if Listening
								break;

							case SAP_GET_NEAREST_REQ:
								Trace (DEBUG_REQ, "\tGet nearest server request received.");
								if (intf->info.GetNearestServerReply==ADMIN_STATE_ENABLED) {
									PIPX_SERVER_ENTRY_P	pEntry = packet->Entries;
									if (packet->Length >= (FIELD_OFFSET (
												SAP_BUFFER,	Entries[0].Type)
												+sizeof (pEntry->Type))) {
										pEntry->Type = GETUSHORT (&pEntry->Type);
										InitGnearItem (intf, pEntry->Type, &packet->Src);
										}
									}
								break;
							case SAP_GET_NEAREST_RESP:
								Trace (DEBUG_FAILURES, "\tGet nearest server response received"
                                            " from %.2x%.2x%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x.%.2x%.2x"
                                            " (I never ask for it).",
                                            packet->Src.Network[0], packet->Src.Network[1],
                                                packet->Src.Network[2], packet->Src.Network[3],
                                            packet->Src.Node[0], packet->Src.Node[1],
                                                packet->Src.Node[2], packet->Src.Node[3],
                                                packet->Src.Node[4], packet->Src.Node[5],
                                            packet->Src.Socket[0], packet->Src.Socket[1]);
								break;
							default:
								Trace (DEBUG_FAILURES,  "Packet with operation %d"
                                            " from %.2x%.2x%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x.%.2x%.2x ignored.",
											packet->Operation,
                                            packet->Src.Network[0], packet->Src.Network[1],
                                                packet->Src.Network[2], packet->Src.Network[3],
                                            packet->Src.Node[0], packet->Src.Node[1],
                                                packet->Src.Node[2], packet->Src.Node[3],
                                                packet->Src.Node[4], packet->Src.Node[5],
                                            packet->Src.Socket[0], packet->Src.Socket[1]);
								break;
							}
						}
					else
						Trace (DEBUG_FAILURES, "File: %s, line %ld. Invalid packet.", __FILE__, __LINE__);
					}
				// else Receive failure - reported by io layer
				}
			// else Loopback packet
			ReleaseInterfaceReference (intf);
			}
		// else Unknown interface - reported by io layer

		if (InterlockedIncrement (&WorkerQueue.WQ_RequestExtra)<=0) {
			Trace (DEBUG_REQ, "Requeing receive request item %08lx.", reqItem);
			reqItem->iow.io.cbBuffer = sizeof (reqItem->packet);
			EnqueueRecvRequest (&reqItem->iow.io);
			return;
			}
		else
			InterlockedDecrement (&WorkerQueue.WQ_RequestExtra);
		}
	// else Packet received with error or OperationalState is not UP
	
	Trace (DEBUG_REQ, "Freeing receive request item %08lx.", reqItem);
	InterlockedIncrement (&WorkerQueue.WQ_RequestQuota);
	DeallocateWorker (reqItem);
	}

VOID APIENTRY
SendResponse (
	PRESP_ITEM		respItem
	) {
	GR_FILTER_PARAMS	params;

	if (respItem->iow.io.status==NO_ERROR) {
		Trace (DEBUG_RESP, 
				"Filling response item %08lx on interface: %d, for type: %04x.",
									respItem,
									respItem->intf->index,
									respItem->svrType);

		params.svrIdx = 0;
		params.intf = respItem->intf;
		params.packet = &respItem->packet;
		params.localHopCount = IPX_MAX_HOP_COUNT-1;
		params.localSvr = FALSE;
		EnumerateServers (respItem->hEnum,
						respItem->bcast
							 ? SplitHorizonHopCountFilter // Bcast - use split horizon
							 : HopCountFilter, // Send all best servers (except duplicate entries
						 						// on looped networks)
						(LPVOID)&params);

		respItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[params.svrIdx]);
		PUTUSHORT (respItem->iow.io.cbBuffer, &respItem->packet.Length);
		respItem->iow.io.adpt = respItem->intf->adapter.AdapterIndex;

		if ((params.svrIdx!=0)
				&& (respItem->intf->stats.SapIfOperState==OPER_STATE_UP)
				&& (OperationalState==OPER_STATE_UP)) {
			EnqueueSendRequest (&respItem->iow.io);
			return;
			}
		}

	Trace (DEBUG_RESP, 
		"Freeing general response item %08lx for interface: %d.",
								respItem, respItem->intf->index);
	ReleaseInterfaceReference (respItem->intf);
	DeleteListEnumerator (respItem->hEnum);
	DeallocateWorker (respItem);
	}
			

/*++
*******************************************************************
		I n i t R e s p I t e m

Routine Description:
	Allocate and initialize SAP response item
	Calls ProcessRespIOItem to fill the packet and send it
Arguments:
	intf - pointer to interface control block to send on
	svrType - type of servers to put in response packet
	dst - where to send the response packet
	bcast - are we responding to broadcasted request
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitRespItem (
	PINTERFACE_DATA		intf,
	USHORT				svrType,
	PIPX_ADDRESS_BLOCK	dst,
	BOOL				bcast
	) {
	PRESP_ITEM		respItem;
	DWORD			status;

	if (!AllocateWorker (respItem, RESP_ITEM)) {
		Trace (DEBUG_FAILURES,
			 "File: %s, line %ld. Could not allocate response item (gle:%ld).",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}
	
	AcquireInterfaceReference (intf); // Make sure interface block is locked
	respItem->hEnum = CreateListEnumerator (
						(svrType!=0xFFFF)
							 ? SDB_TYPE_LIST_LINK	// Just servers of one type
							 : SDB_HASH_TABLE_LINK,	// All servers
						svrType,
						NULL,
						(!Routing && bcast) // Respond with only local
											// servers if not routing and
											// request was a broadcast
							? INTERNAL_INTERFACE_INDEX
							: INVALID_INTERFACE_INDEX,
						0xFFFFFFFF,
						0);						// All entries, so we can
								// detect duplicate servers on looped networks
	if (respItem->hEnum==NULL) {
		status = GetLastError ();
		ReleaseInterfaceReference (intf);
		DeallocateWorker (respItem);
		return status;
		}

	respItem->iow.worker = ProcessRespIOItem;
	respItem->iow.io.buffer = (PUCHAR)&respItem->packet;
	respItem->iow.io.status = NO_ERROR;
	respItem->tmw.worker = ProcessRespTMItem;
	respItem->tmw.tm.ExpirationCheckProc = NULL;
	respItem->intf = intf;
	SetupIpxSapPacket(&respItem->packet, SAP_GENERAL_RESP,
						dst->Network, dst->Node, dst->Socket);
	respItem->svrType = svrType;
	respItem->bcast = (UCHAR)bcast;

	Trace (DEBUG_RESP, "Generated general response item %08lx for interface %d.",
								 respItem, respItem->intf->index);
	if (DelayResponseToGeneral>0) {
		Trace (DEBUG_RESP, 
			"Delaying general response item %08lx for interface: %d.",
									respItem, respItem->intf->index);
		respItem->tmw.tm.dueTime = GetTickCount ()+DelayResponseToGeneral;
		AddHRTimerRequest (&respItem->tmw.tm);
		}
	else
		SendResponse (respItem);

	return NO_ERROR;
	}



/*++
*******************************************************************
		P r o c e s s R e s p I O I t e m

Routine Description:
	Generate and send response packet
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessRespIOItem (
	PVOID		worker
	) {
	PRESP_ITEM			respItem = CONTAINING_RECORD (worker, RESP_ITEM, iow.worker);

	Trace (DEBUG_RESP, 
			"Processing general response tm item %08lx on interface: %d.",
								respItem, respItem->intf->index);
	if (respItem->iow.io.status==NO_ERROR)
		InterlockedIncrement (&respItem->intf->stats.SapIfOutputPackets);

	if ( (respItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			&& (OperationalState==OPER_STATE_UP)) {
		if (GetTickCount()-respItem->iow.io.compTime<IPX_SAP_INTERPACKET_GAP) {
			respItem->tmw.tm.dueTime = respItem->iow.io.compTime
											+ IPX_SAP_INTERPACKET_GAP;
			AddHRTimerRequest (&respItem->tmw.tm);
			}
		else
			SendResponse (respItem);
		}
	else {
		Trace (DEBUG_RESP, 
			"Freeing general response item %08lx for interface: %d.",
									respItem, respItem->intf->index);
		ReleaseInterfaceReference (respItem->intf);
		DeleteListEnumerator (respItem->hEnum);
		DeallocateWorker (respItem);
		}
	}


VOID APIENTRY
ProcessRespTMItem (
	PVOID		worker
	) {
	PRESP_ITEM			respItem = CONTAINING_RECORD (worker, RESP_ITEM, tmw.worker);
	Trace (DEBUG_RESP, 
			"Processing general response tm item %08lx on interface: %d.",
								respItem, respItem->intf->index);
	if ( (respItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			&& (OperationalState==OPER_STATE_UP)) {
		SendResponse (respItem);
	}
	else {
		Trace (DEBUG_RESP, 
			"Freeing general response item %08lx for interface: %d.",
									respItem, respItem->intf->index);
		ReleaseInterfaceReference (respItem->intf);
		DeleteListEnumerator (respItem->hEnum);
		DeallocateWorker (respItem);
		}
	}


/*++
*******************************************************************
		D e l e t e B c a s t I t e m

Routine Description:
	Disposes of resources associated with broadcast work item
Arguments:
	bcastItem - pointer to broadcast work item
Return Value:
	None
*******************************************************************
--*/
VOID
DeleteBcastItem (
	PBCAST_ITEM		bcastItem
	) {
	Trace (DEBUG_BCAST, "Freeing broadcast item %08lx for interface: %d.",
												bcastItem, bcastItem->intf->index);
	if (bcastItem->chngEnum!=NULL)
		DeleteListEnumerator (bcastItem->chngEnum);
	if ((bcastItem->perdEnum!=NULL)
			&& (bcastItem->perdEnum!=INVALID_HANDLE_VALUE))
		DeleteListEnumerator (bcastItem->perdEnum);
	ReleaseInterfaceReference (bcastItem->intf);
	DeallocateWorker (bcastItem);
	}

/*++
*******************************************************************
		D o B r o a d c a s t

Routine Description:
	Check for and broadcast changed servers
	Check if it is time to do periodic broadcast and start it if so
Arguments:
	bcastItem - pointer to broadcast work item
Return Value:
	None
*******************************************************************
--*/
VOID
DoBroadcast (
	PBCAST_ITEM		bcastItem
	) {
	GR_FILTER_PARAMS	params;
	BOOLEAN				periodic;

	params.svrIdx = bcastItem->delayedSvrCount;
	params.intf = bcastItem->intf;
	params.packet = &bcastItem->packet;

	if (	((bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP)
				&& ((bcastItem->perdEnum!=NULL) // we are already in the middle of
											// broadcast
					|| IsLater(GetTickCount (),bcastItem->nextBcast))) // or it is
											// time to start a new one
			|| ((bcastItem->intf->stats.SapIfOperState==OPER_STATE_STOPPING)
											// or interface is being stopped, so
											// we need to broadcast the whole
											// table as deleted
				&& (bcastItem->perdEnum!=INVALID_HANDLE_VALUE))
											// This value in the periodic
											// enumeration handle field means
											// that we are already done
											// with this broadcast
							 ) {

		Trace (DEBUG_BCAST, "Checking for deleted servers on interface: %d.",
														params.intf->index);
		EnumerateServers (bcastItem->chngEnum, SplitHorizonDeletedFilter, &params);

		if (bcastItem->perdEnum==NULL) { // Need to start new boradcast
			Trace (DEBUG_BCAST, "Starting broadcast enumeration on interface: %d (@ %ld).",
							bcastItem->intf->index, bcastItem->nextBcast);
			if (Routing)	// Router installation: broadcast all servers
				bcastItem->perdEnum = CreateListEnumerator (
												SDB_HASH_TABLE_LINK,
												0xFFFF,
												NULL,
												INVALID_INTERFACE_INDEX,
												0xFFFFFFFF,
												0);
			else	// Standalone SAP agent: only internal servers
				bcastItem->perdEnum = CreateListEnumerator (
												SDB_INTF_LIST_LINK,
												0xFFFF,
												NULL,
												INTERNAL_INTERFACE_INDEX,
										 		0xFFFFFFFF,
												0);


					// Set the time for next broadcast
			bcastItem->nextBcast += 
				bcastItem->intf->info.PeriodicUpdateInterval*1000;
			}

		if ((params.svrIdx<IPX_SAP_MAX_ENTRY)
				&& (bcastItem->perdEnum!=NULL)
				&& (bcastItem->perdEnum!=INVALID_HANDLE_VALUE)) {
			Trace (DEBUG_BCAST, "Adding broadcast servers on interface: %d.", 
															params.intf->index);
			params.localHopCount = IPX_MAX_HOP_COUNT-1;
			params.localSvr = FALSE;
			if (!EnumerateServers (bcastItem->perdEnum, 
										SplitHorizonHopCountFilter,
										&params)) {
					// All broadcast servers sent, dispose enumeration handle
				DeleteListEnumerator (bcastItem->perdEnum);
				Trace (DEBUG_BCAST, "Broadcast enumeration finished on interface:"
								" %d (@ %ld, next @ %ld).",
								bcastItem->intf->index,
								GetTickCount (),
								bcastItem->nextBcast);
				if (bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP)
					bcastItem->perdEnum = NULL;
				else // Nore that broadcast of the whole table is done
					bcastItem->perdEnum = INVALID_HANDLE_VALUE;
				}
			}
		if (bcastItem->intf->stats.SapIfOperState==OPER_STATE_STOPPING) {
			INT		i;
			for (i=0; i<params.svrIdx; i++) {
				 PUTUSHORT (IPX_MAX_HOP_COUNT, &bcastItem->packet.Entries[i].HopCount);
				}
			}
		periodic = TRUE;
	 	}
	else
		periodic = FALSE;

	if ((params.svrIdx<IPX_SAP_MAX_ENTRY)
			&& (bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP)) {
		if (bcastItem->delayedSvrCount==0)
			bcastItem->delayedSendTime = GetTickCount ()+DelayChangeBroadcast*1000;
		Trace (DEBUG_BCAST, "Checking for changed servers on interface: %d.",
															params.intf->index);
		params.localHopCount = IPX_MAX_HOP_COUNT+1;
		EnumerateServers (bcastItem->chngEnum, SplitHorizonFilter, &params);
		}

	if ((params.svrIdx>0)
			&& (periodic 
				|| (params.svrIdx==IPX_SAP_MAX_ENTRY)
				|| IsLater (GetTickCount (), bcastItem->delayedSendTime))) {
		bcastItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[params.svrIdx]);
		PUTUSHORT (bcastItem->iow.io.cbBuffer, &bcastItem->packet.Length);
		bcastItem->iow.io.adpt = bcastItem->intf->adapter.AdapterIndex;
		bcastItem->delayedSvrCount = 0;
		Trace (DEBUG_BCAST, "Broadcasting %d servers on interface: %d.",
											params.svrIdx, params.intf->index);
		EnqueueSendRequest (&bcastItem->iow.io);
		}
	else if (bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP) {
			// Nothing to send, go wait in the timer queue
		bcastItem->delayedSvrCount = params.svrIdx;
		if (bcastItem->delayedSvrCount>0) {
			Trace (DEBUG_BCAST, "Delaying change broadcast on interface: %d (%d servers in the packet).",
							params.intf->index, bcastItem->delayedSvrCount);
			bcastItem->tmw.tm.dueTime = bcastItem->delayedSendTime;
			}
		else {
			bcastItem->tmw.tm.dueTime = bcastItem->nextBcast;
			Trace (DEBUG_BCAST, "Nothing to send, waiting for next broadcast time on interface: %d.",
							params.intf->index);
			}
		AddLRTimerRequest (&bcastItem->tmw.tm);
		}
	else
			// Interface is down or stopping and there are no more stuff to
			// broadcast, -> go away
		DeleteBcastItem (bcastItem);
		
	}


BOOL
CheckBcastInterface (
	PTM_PARAM_BLOCK	tm,
	PVOID			context
	) {
	PBCAST_ITEM		bcastItem = CONTAINING_RECORD (tm, BCAST_ITEM, tmw.tm);
	if (bcastItem->intf->stats.SapIfOperState!=OPER_STATE_UP)
		return TRUE;
	else if (bcastItem->intf->index!=PtrToUlong(context))
		return TRUE;
	else
		return FALSE;
	}



/*++
*******************************************************************
		I n i t B c a s t I t e m

Routine Description:
	Allocate and initialize broadcast item
Arguments:
	intf - pointer to interface control block to send on
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitBcastItem (
	PINTERFACE_DATA			intf
	) {
	PBCAST_ITEM		bcastItem;
	DWORD			status;
	
	if (!AllocateWorker (bcastItem, BCAST_ITEM)) {
		Trace (DEBUG_FAILURES,
			 "File: %s, line %ld. Could not allocate broadcast item (gle:%ld).",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}

	bcastItem->chngEnum = CreateListEnumerator (
											SDB_CHANGE_QUEUE_LINK,
											0xFFFF,
											NULL,
											Routing 
												? INVALID_INTERFACE_INDEX
												: INTERNAL_INTERFACE_INDEX,
											0xFFFFFFFF,
											SDB_DISABLED_NODE_FLAG);
	if (bcastItem->chngEnum==NULL) {
		status = GetLastError ();
		DeallocateWorker (bcastItem);
		return status;
		}

	AcquireInterfaceReference (intf);
	bcastItem->intf = intf;
	bcastItem->iow.worker = ProcessBcastIOItem;
	bcastItem->iow.io.buffer = (PUCHAR)&bcastItem->packet;
	bcastItem->tmw.worker = ProcessBcastTMItem;
	bcastItem->tmw.tm.ExpirationCheckProc = CheckBcastInterface;
	bcastItem->perdEnum = NULL;
	bcastItem->delayedSvrCount = 0;
	SetupIpxSapPacket(&bcastItem->packet, SAP_GENERAL_RESP,
						bcastItem->intf->adapter.Network,
						IPX_BCAST_NODE,
						IPX_SAP_SOCKET);
	bcastItem->nextBcast = GetTickCount ();

	Trace (DEBUG_BCAST, "Generated broadcast item %08lx for interface %d.",
										bcastItem, bcastItem->intf->index);
	DoBroadcast (bcastItem);
	return NO_ERROR;
	}

/*++
*******************************************************************
		P r o c e s s B c a s t I O I t e m

Routine Description:
	Processes broadcast work item that just completed send
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessBcastIOItem (
	PVOID		worker
	) {
	PBCAST_ITEM		bcastItem = CONTAINING_RECORD (worker, BCAST_ITEM, iow.worker);
	ULONG curTime = GetTickCount ();

	Trace (DEBUG_BCAST, "Processing broadcast io item for interface: %d.",
												bcastItem->intf->index);
	// Make sure interface is still up
	if (bcastItem->iow.io.status==NO_ERROR) {
		InterlockedIncrement (&bcastItem->intf->stats.SapIfOutputPackets);
			// Make sure we do not send periodic broadcast packets to fast
		if ((curTime-bcastItem->iow.io.compTime<IPX_SAP_INTERPACKET_GAP)
				&& (bcastItem->perdEnum!=NULL)) {
			bcastItem->tmw.tm.dueTime = bcastItem->iow.io.compTime
											+ IPX_SAP_INTERPACKET_GAP;
			AddHRTimerRequest (&bcastItem->tmw.tm);
			}
		else
			DoBroadcast (bcastItem);
		}
	else if (bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP) {
		// Last sent io failed, we better wait before sending next one
		bcastItem->tmw.tm.dueTime = curTime+SAP_ERROR_COOL_OFF_TIME;
		AddLRTimerRequest (&bcastItem->tmw.tm);
		}
	else
		// Interface is stopping or down on error, go away
		DeleteBcastItem (bcastItem);
	}

/*++
*******************************************************************
		P r o c e s s B c a s t T M I t e m

Routine Description:
	Processes broadcast work item that just completed wait in timer queue
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessBcastTMItem (
	PVOID		worker
	) {
	PBCAST_ITEM		bcastItem = CONTAINING_RECORD (worker, BCAST_ITEM, tmw.worker);

	Trace (DEBUG_BCAST, "Processing broadcast tm item for interface: %d.",
												bcastItem->intf->index);
	if ((bcastItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			|| (bcastItem->intf->stats.SapIfOperState==OPER_STATE_STOPPING))
		DoBroadcast (bcastItem);
	else // Interface is down, go away
		DeleteBcastItem (bcastItem);

	}

/*++
*******************************************************************
		I n i t S r e q I t e m

Routine Description:
	Allocate and initialize send request item (send SAP request on interface)
Arguments:
	intf - pointer to interface control block to send on
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitSreqItem (
	PINTERFACE_DATA			intf
	) {
	PSREQ_ITEM		sreqItem;
	
	if (!AllocateWorker (sreqItem, SREQ_ITEM)) {
		Trace (DEBUG_FAILURES, 
					"File: %s, line %ld. Could not allocate send request item (gle:%ld.",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}

	AcquireInterfaceReference (intf);
	sreqItem->intf = intf;
	sreqItem->iow.worker = ProcessSreqItem;
	sreqItem->iow.io.buffer = (PUCHAR)&sreqItem->packet;
	SetupIpxSapPacket(&sreqItem->packet, SAP_GENERAL_REQ,
						sreqItem->intf->adapter.Network,
						IPX_BCAST_NODE,
						IPX_SAP_SOCKET);
	sreqItem->packet.Entries[0].Type = 0xFFFF;
	sreqItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[0].Type)
								+sizeof (sreqItem->packet.Entries[0].Type);
	PUTUSHORT (sreqItem->iow.io.cbBuffer, &sreqItem->packet.Length);
	sreqItem->iow.io.adpt = sreqItem->intf->adapter.AdapterIndex;

	Trace (DEBUG_SREQ, "Generated general request item: %08lx on interface: %d.",
										sreqItem, sreqItem->intf->index);
	if ((sreqItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			&& (OperationalState==OPER_STATE_UP)) {
		EnqueueSendRequest (&sreqItem->iow.io);
		return NO_ERROR;
		}
	else {
			// Interface got changed or deleted
		Trace (DEBUG_SREQ,
			 "Freing general request item: %08lx for changed or deleted interface %ld.",
			 									sreqItem, sreqItem->intf->index);
		ReleaseInterfaceReference (sreqItem->intf);
		DeallocateWorker (sreqItem);
		return ERROR_INVALID_HANDLE;
		}
	
	}

/*++
*******************************************************************
		P r o c e s s S r e q I t e m

Routine Description:
	Processes send request work item that just completed io
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessSreqItem (
	PVOID		worker
	) {
	PSREQ_ITEM		sreqItem = CONTAINING_RECORD (worker, SREQ_ITEM, iow.worker);
	if (sreqItem->iow.io.status==NO_ERROR)
		InterlockedIncrement (&sreqItem->intf->stats.SapIfOutputPackets);
	Trace (DEBUG_SREQ, "Freeing general request item %08lx.", sreqItem);
		// Just release all resources
	ReleaseInterfaceReference (sreqItem->intf);
	DeallocateWorker (sreqItem);
	}


/*++
*******************************************************************
		I n i t L P C I t e m

Routine Description:
	Allocate and initialize LPC work item
Arguments:
	None
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitLPCItem (
	void
	) {
	PLPC_ITEM		lpcItem;
	
	if (!AllocateWorker (lpcItem, LPC_ITEM)) {
		Trace (DEBUG_FAILURES, "File: %s, line %ld. Could not allocate lpc item (gle:%ld.",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}

	lpcItem->lpcw.lpc.request = &lpcItem->request;
	lpcItem->lpcw.worker = ProcessLPCItem;
	Trace (DEBUG_LPCREQ, "Generated lpc request item %08lx.", lpcItem);
		// Posts request and awaits completion
	return ProcessLPCRequests (&lpcItem->lpcw.lpc);
	}


/*++
*******************************************************************
		P r o c e s s L P C I t e m

Routine Description:
	Processes LPC request and sends reply
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessLPCItem (
	PVOID		worker
	) {
	PLPC_ITEM			lpcItem = CONTAINING_RECORD (worker, LPC_ITEM, lpcw.worker);
	IPX_SERVER_ENTRY_P	server;
	NWSAP_REPLY_MESSAGE	reply;
	DWORD				status;
	BOOL				newServer;

	Trace (DEBUG_LPCREQ, "Processing lpc request for client: %08lx.",
													 lpcItem->lpcw.lpc.client);
	if (lpcItem->lpcw.lpc.client==NULL) {
		Trace (DEBUG_LPCREQ, "Freeing lpc item %08lx.", lpcItem);
		DeallocateWorker (lpcItem);
		return;
		}
		

	switch (lpcItem->request.MessageType) {
		case NWSAP_LPCMSG_ADDADVERTISE:
			server.Type = lpcItem->request.Message.AdvApi.ServerType;
			IpxNameCpy (server.Name, lpcItem->request.Message.AdvApi.ServerName);
			IpxAddrCpy (&server, (PIPX_ADDRESS_BLOCK)lpcItem->request.Message.AdvApi.ServerAddr);
				// If net or node number are not set, use internal network
				// parameters that we obtained from the adapter
			if ((IpxNetCmp (server.Network, IPX_INVALID_NET)==0)
					|| (IpxNodeCmp (server.Node, IPX_INVALID_NODE)==0)) {
				IpxNetCpy (server.Network, INTERNAL_IF_NET);
				IpxNodeCpy (server.Node, INTERNAL_IF_NODE);
			}

			server.HopCount = 0;
			status = UpdateServer (&server,
								INTERNAL_INTERFACE_INDEX,
								IPX_PROTOCOL_LOCAL,
								INFINITE,
								IPX_BCAST_NODE,
								lpcItem->request.Message.AdvApi.RespondNearest
									? 0
									: SDB_DONT_RESPOND_NODE_FLAG,
								&newServer);
			switch (status) {
				case NO_ERROR:
					if (newServer)
						reply.Error = SAPRETURN_SUCCESS;
					else
						reply.Error = SAPRETURN_EXISTS;
					IpxAddrCpy ((PIPX_ADDRESS_BLOCK)reply.Message.AdvApi.ServerAddr, &server);
					Trace (DEBUG_LPCREQ, "\t%s server: type %04x, name %.48s.",
										newServer ? "added" : "updated",
										server.Type, server.Name);
					break;
				case ERROR_NOT_ENOUGH_MEMORY:
				default:
					reply.Error = SAPRETURN_NOMEMORY;
					break;
				}
			break;

		case NWSAP_LPCMSG_REMOVEADVERTISE:
			server.Type = lpcItem->request.Message.AdvApi.ServerType;
			IpxNameCpy (server.Name, lpcItem->request.Message.AdvApi.ServerName);
			IpxAddrCpy (&server, (PIPX_ADDRESS_BLOCK)lpcItem->request.Message.AdvApi.ServerAddr);
				// If net or node number are not set, use internal network
				// parameters that we obtained from the adapter
			if ((IpxNetCmp (server.Network, IPX_INVALID_NET)==0)
					|| (IpxNodeCmp (server.Node, IPX_INVALID_NODE)==0)) {
				IpxNetCpy (server.Network, INTERNAL_IF_NET);
				IpxNodeCpy (server.Node, INTERNAL_IF_NODE);
				}
			server.HopCount = IPX_MAX_HOP_COUNT;
			Trace (DEBUG_LPCREQ, "About to call UpdateServer because of NWSAP_LPCMSG_REMOVEADVERTISE");
			status = UpdateServer (&server,
								INTERNAL_INTERFACE_INDEX,
								IPX_PROTOCOL_LOCAL,
								INFINITE,
								IPX_BCAST_NODE,
								0,
								&newServer);
			switch (status) {
				case NO_ERROR:
					if (newServer)
						reply.Error = SAPRETURN_NOTEXIST;
					else
						reply.Error = SAPRETURN_SUCCESS;
					Trace (DEBUG_LPCREQ, "\t%s server: type %04x, name %.48s.",
										newServer ? "already gone" : "deleted",
										server.Type, server.Name);
					break;
				case ERROR_NOT_ENOUGH_MEMORY:
				default:
					reply.Error = SAPRETURN_NOMEMORY;
					break;
				}
			break;

		case NWSAP_LPCMSG_GETOBJECTID:
			if (QueryServer(
							lpcItem->request.Message.BindLibApi.ObjectType,
							lpcItem->request.Message.BindLibApi.ObjectName,
							NULL,
							NULL,
							NULL,
							&reply.Message.BindLibApi.ObjectID)) {
//				Trace (DEBUG_ENTRIES, "\tgot id %0lx for server: type %04x, name %.48s.",
//								reply.Message.BindLibApi.ObjectID,
//								lpcItem->request.Message.BindLibApi.ObjectType,
//								lpcItem->request.Message.BindLibApi.ObjectName);
				reply.Message.BindLibApi.ObjectID |= BINDLIB_NCP_SAP;
				reply.Error = SAPRETURN_SUCCESS;
				}
			else {
				Trace (DEBUG_LPCREQ, "\tno server: type %04x, name %.48s.",
								lpcItem->request.Message.BindLibApi.ObjectType,
								lpcItem->request.Message.BindLibApi.ObjectName);
				switch (GetLastError ()) {
					case NO_ERROR:
						reply.Error = SAPRETURN_NOTEXIST;
						break;
					case ERROR_NOT_ENOUGH_MEMORY:
					default:
						reply.Error = SAPRETURN_NOMEMORY;
						break;
					}
				}

			break;

		case NWSAP_LPCMSG_GETOBJECTNAME:
			if (((lpcItem->request.Message.BindLibApi.ObjectID
							 & BINDLIB_NCP_SAP)==BINDLIB_NCP_SAP)
					&& (lpcItem->request.Message.BindLibApi.ObjectID
								<BINDLIB_NCP_MAX_SAP)) {
				reply.Message.BindLibApi.ObjectID = 
							lpcItem->request.Message.BindLibApi.ObjectID 
									& SDB_OBJECT_ID_MASK;
				if (GetServerFromID(
								reply.Message.BindLibApi.ObjectID,
								&server,
								NULL,
								NULL)) {
					reply.Error = SAPRETURN_SUCCESS;
					reply.Message.BindLibApi.ObjectID |= BINDLIB_NCP_SAP;
					reply.Message.BindLibApi.ObjectType = server.Type;
					IpxNameCpy (reply.Message.BindLibApi.ObjectName, server.Name);
					IpxAddrCpy ((PIPX_ADDRESS_BLOCK)reply.Message.BindLibApi.ObjectAddr, &server);
//					Trace (DEBUG_ENTRIES, 
//									"\tgot server: type %04x, name %.48s from id %0lx.",
//									reply.Message.BindLibApi.ObjectType,
//									reply.Message.BindLibApi.ObjectName,
//									lpcItem->request.Message.BindLibApi.ObjectID);
					}
				else {
					switch (GetLastError ()) {
						case NO_ERROR:
							Trace (DEBUG_LPCREQ, "\tno server for id %0lx.",
									lpcItem->request.Message.BindLibApi.ObjectID);
							reply.Error = SAPRETURN_NOTEXIST;
							break;
						case ERROR_NOT_ENOUGH_MEMORY:
						default:
							reply.Error = SAPRETURN_NOMEMORY;
							break;
						}
					}
				}
			else {
				Trace (DEBUG_LPCREQ, "\tInvalid object id in get name request %0lx.",
						lpcItem->request.Message.BindLibApi.ObjectID);
				reply.Error = SAPRETURN_NOTEXIST;
				}
			break;

		case NWSAP_LPCMSG_SEARCH:
			if ((lpcItem->request.Message.BindLibApi.ObjectID
								== SDB_INVALID_OBJECT_ID)
					|| (((lpcItem->request.Message.BindLibApi.ObjectID
							 & BINDLIB_NCP_SAP)==BINDLIB_NCP_SAP)
						&& (lpcItem->request.Message.BindLibApi.ObjectID
								<BINDLIB_NCP_MAX_SAP))) {
				if (lpcItem->request.Message.BindLibApi.ObjectID
														== SDB_INVALID_OBJECT_ID)
					reply.Message.BindLibApi.ObjectID = SDB_INVALID_OBJECT_ID;
				else
					reply.Message.BindLibApi.ObjectID = 
							lpcItem->request.Message.BindLibApi.ObjectID 
									& SDB_OBJECT_ID_MASK;
				if (GetNextServerFromID (
								&reply.Message.BindLibApi.ObjectID,
								lpcItem->request.Message.BindLibApi.ScanType,
								&server,
								NULL,
								NULL)) {
					reply.Message.BindLibApi.ObjectID |= BINDLIB_NCP_SAP;
					reply.Error = SAPRETURN_SUCCESS;
					reply.Message.BindLibApi.ObjectType = server.Type;
					IpxNameCpy (reply.Message.BindLibApi.ObjectName, server.Name);
					IpxAddrCpy ((PIPX_ADDRESS_BLOCK)reply.Message.BindLibApi.ObjectAddr, &server);
//					Trace (DEBUG_ENTRIES, 
//						"\tgot next server: type %04x, name %.48s, id %0lx from id %0lx.",
//									reply.Message.BindLibApi.ObjectType,
//									reply.Message.BindLibApi.ObjectName,
//									reply.Message.BindLibApi.ObjectID,
//									lpcItem->request.Message.BindLibApi.ObjectID);
					}
				else {
					switch (GetLastError ()) {
						case NO_ERROR:
							Trace (DEBUG_LPCREQ, "\tno next server for id %0lx.",
									lpcItem->request.Message.BindLibApi.ObjectID);
							reply.Error = SAPRETURN_NOTEXIST;
							break;
						case ERROR_NOT_ENOUGH_MEMORY:
						default:
							reply.Error = SAPRETURN_NOMEMORY;
							break;
						}
					}
				}
			else {
				Trace (DEBUG_LPCREQ, "\tInvalid object id in get next request %0lx.",
						lpcItem->request.Message.BindLibApi.ObjectID);
				reply.Error = SAPRETURN_NOTEXIST;
				}
					
			break;

		default:
			Trace (DEBUG_FAILURES, "Got unknown LPC SAP msg: %d.",
									lpcItem->request.MessageType );
			reply.Error = 1;
			break;
		}
	SendLPCReply (lpcItem->lpcw.lpc.client, &lpcItem->request, &reply);
	Trace (DEBUG_LPCREQ, "Freeing lpc item %08lx.", lpcItem);
	DeallocateWorker (lpcItem);
	}
	

/*++
*******************************************************************
		I n i t G n e a r I t e m

Routine Description:
	Allocate and initialize GETNEAREST response work item
Arguments:
	intf - pointer to interface control block to send on
	svrType - type of servers to put in response packet
	dst - where to send the response packet
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitGnearItem (
	PINTERFACE_DATA		intf,
	USHORT				svrType,
	PIPX_ADDRESS_BLOCK	dst
	) {
	DWORD				status;
	GN_FILTER_PARAMS	params;
	HANDLE				hEnum;
	PGNEAR_ITEM			gnearItem;

	if (!AllocateWorker (gnearItem, GNEAR_ITEM)) {
		Trace (DEBUG_FAILURES, 
				"File: %s, line %ld. Could not allocate get nearest response item (gle:%ld.",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}

	AcquireInterfaceReference (intf);
	gnearItem->intf = intf;

	Trace (DEBUG_GET_NEAREST,
			"Generated get nearest response item %08lx for server of type: %04x on interface: %ld.",
												gnearItem, svrType, intf->index);
	hEnum = CreateListEnumerator (
						SDB_TYPE_LIST_LINK,
						svrType,
						NULL,
						Routing
							? INVALID_INTERFACE_INDEX
							: INTERNAL_INTERFACE_INDEX,
					 	0xFFFFFFFF,
						SDB_MAIN_NODE_FLAG);
	if (hEnum==NULL) {
		status = GetLastError ();
		ReleaseInterfaceReference (intf);
		DeallocateWorker (gnearItem);
		return status;
		}


	params.found = FALSE;
	params.intf = gnearItem->intf;
	params.packet = &gnearItem->packet;
	params.localHopCount = IPX_MAX_HOP_COUNT-1;
    EnumerateServers (hEnum, GetNearestFilter, (LPVOID)&params);
	DeleteListEnumerator (hEnum);
	

	if (params.found) {
		gnearItem->iow.worker = ProcessGnearItem;
		gnearItem->iow.io.buffer = (PUCHAR)&gnearItem->packet;
		gnearItem->intf = intf;

		SetupIpxSapPacket(&gnearItem->packet, SAP_GET_NEAREST_RESP,
							dst->Network, dst->Node, dst->Socket);
		gnearItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[1]);
		PUTUSHORT (gnearItem->iow.io.cbBuffer, &gnearItem->packet.Length);

		gnearItem->iow.io.adpt = gnearItem->intf->adapter.AdapterIndex;
		Trace (DEBUG_GET_NEAREST,
			"Sending get nearest reply (type %04x, name:%.48s, hops:%d) on interface %ld.",
							GETUSHORT (&gnearItem->packet.Entries[0].Type),
							gnearItem->packet.Entries[0].Name,
							GETUSHORT (&gnearItem->packet.Entries[0].HopCount),
							intf->index);
		if ((gnearItem->intf->stats.SapIfOperState==OPER_STATE_UP)
				&& (OperationalState==OPER_STATE_UP)) {
			EnqueueSendRequest (&gnearItem->iow.io);
			return NO_ERROR;
			}
		}

	Trace (DEBUG_GET_NEAREST,
			 "Freeing get nearest response item %08lx (nothing to reply) for interface %ld.",
									gnearItem, gnearItem->intf->index);
	ReleaseInterfaceReference (gnearItem->intf);
	DeallocateWorker (gnearItem);
	return NO_ERROR;
	}


/*++
*******************************************************************
		P r o c e s s G n e a r I t e m

Routine Description:
	Processes completed GETNEAREST work item
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessGnearItem (
	PVOID		worker
	) {
	PGNEAR_ITEM		gnearItem = CONTAINING_RECORD (worker, GNEAR_ITEM, iow.worker);

	if (gnearItem->iow.io.status==NO_ERROR)
		InterlockedIncrement (&gnearItem->intf->stats.SapIfOutputPackets);
	Trace (DEBUG_GET_NEAREST, "Freeing get nearest response item %08lx for interface %ld.",
									gnearItem, gnearItem->intf->index);
	ReleaseInterfaceReference (gnearItem->intf);
	DeallocateWorker (gnearItem);
	}

BOOL
CheckInterfaceDown (
	PTM_PARAM_BLOCK	tm,
	PVOID			context
	) {
	PTREQ_ITEM		treqItem = CONTAINING_RECORD (tm, TREQ_ITEM, tmw.tm);
	return treqItem->intf->stats.SapIfOperState!=OPER_STATE_UP;
	}



/*++
*******************************************************************
		I n i t T r e q I t e m

Routine Description:
	Allocate and initialize triggered request item (send SAP request on interface
	and wait for responces to arrive)
Arguments:
	intf - pointer to interface control block to send on
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitTreqItem (
	PINTERFACE_DATA			intf
	) {
	PTREQ_ITEM		treqItem;
	HANDLE			enumHdl;


	enumHdl = CreateListEnumerator (
						SDB_INTF_LIST_LINK,
						0xFFFF,
						NULL,
						intf->index,
						IPX_PROTOCOL_SAP,
						SDB_DISABLED_NODE_FLAG);
	if (enumHdl==NULL)
		return GetLastError ();

	EnumerateServers (enumHdl, DeleteAllServersCB, enumHdl);
	DeleteListEnumerator (enumHdl);
	
	if (!AllocateWorker (treqItem, TREQ_ITEM)) {
		Trace (DEBUG_FAILURES, 
				"File: %s, line %ld. Could not allocate triggered request item (gle:%ld).",
									__FILE__, __LINE__, GetLastError ());
		return ERROR_NOT_ENOUGH_MEMORY;
		}

	AcquireInterfaceReference (intf);
	treqItem->intf = intf;
	treqItem->iow.worker = ProcessTreqIOItem;
	treqItem->iow.io.buffer = (PUCHAR)&treqItem->packet;
	treqItem->tmw.worker = ProcessTreqTMItem;
	treqItem->tmw.tm.ExpirationCheckProc = CheckInterfaceDown;

	SetupIpxSapPacket(&treqItem->packet, SAP_GENERAL_REQ,
						treqItem->intf->adapter.Network,
						IPX_BCAST_NODE,
						IPX_SAP_SOCKET);
	treqItem->packet.Entries[0].Type = 0xFFFF;
	treqItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[0].Type)
								+sizeof (treqItem->packet.Entries[0].Type);
	PUTUSHORT (treqItem->iow.io.cbBuffer, &treqItem->packet.Length);
	treqItem->iow.io.adpt = treqItem->intf->adapter.AdapterIndex;
	treqItem->listenSave = treqItem->intf->info.Listen;
	treqItem->intf->info.Listen = ADMIN_STATE_ENABLED;
	treqItem->intervalSave = treqItem->intf->info.PeriodicUpdateInterval;
	treqItem->intf->info.PeriodicUpdateInterval = MAXULONG;
	treqItem->resend = 0;
	treqItem->pktCount = treqItem->intf->stats.SapIfInputPackets;


	Trace (DEBUG_TREQ, "Generated triggered request item %08lx on interface %d.",
										treqItem, treqItem->intf->index);
	if ((treqItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			&& (OperationalState==OPER_STATE_UP)) {
		EnqueueSendRequest (&treqItem->iow.io);
		return NO_ERROR;
		}
	else {
			// Interface got changed or deleted
		Trace (DEBUG_TREQ, 
			"Freeing triggered request item %08lx for changed or deleted interface %ld.",
							treqItem, treqItem->intf->index);
		treqItem->intf->info.Listen = treqItem->listenSave;
		treqItem->intf->info.PeriodicUpdateInterval = treqItem->intervalSave;
		ReleaseInterfaceReference (treqItem->intf);
		DeallocateWorker (treqItem);
		return ERROR_CAN_NOT_COMPLETE;
		}
	}

/*++
*******************************************************************
		R e t u r n U p d a t e R e s u l t

Routine Description:
	Sets up parameter block and enquues results of update to
	async result queue
Arguments:
	treqItem - pointer to triggered request item that has completed the update
	status - result of update performted by treqItem
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
VOID
ReturnUpdateResult (
	PTREQ_ITEM		treqItem,
	DWORD			status
	) {
	Trace (DEBUG_TREQ, "Reporting triggered request result (res:%d, count:%d)"
					" for interface: %d.",
								status,
								treqItem->pktCount,
								treqItem->intf->index);
	treqItem->ar.event = UPDATE_COMPLETE;
	treqItem->ar.message.UpdateCompleteMessage.InterfaceIndex
									 = treqItem->intf->index;
	treqItem->ar.message.UpdateCompleteMessage.UpdateType = DEMAND_UPDATE_SERVICES;
	treqItem->ar.message.UpdateCompleteMessage.UpdateStatus = status;
	treqItem->ar.freeRsltCB = &FreeTreqItem;

	treqItem->intf->info.Listen = treqItem->listenSave;
	treqItem->intf->info.PeriodicUpdateInterval = treqItem->intervalSave;
	ReleaseInterfaceReference (treqItem->intf);
	
	EnqueueResult (&treqItem->ar);
	}

/*++
*******************************************************************
		P r o c e s s T r e q I O I t e m

Routine Description:
	Processes triggered request work item that just completed io
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessTreqIOItem (
	PVOID		worker
	) {
	PTREQ_ITEM		treqItem = CONTAINING_RECORD (worker, TREQ_ITEM, iow.worker);
	HANDLE			hEnum;

	if (treqItem->iow.io.status==NO_ERROR)
		InterlockedIncrement (&treqItem->intf->stats.SapIfOutputPackets);

	Trace (DEBUG_TREQ, "Processing triggered request io item for interface: %d.",
												treqItem->intf->index);
	if ((treqItem->intf->stats.SapIfOperState==OPER_STATE_UP)
			&& (OperationalState==OPER_STATE_UP)) {
		treqItem->resend += 1;
		treqItem->tmw.tm.dueTime = GetTickCount ()
									 + TriggeredUpdateCheckInterval*1000;
		AddLRTimerRequest (&treqItem->tmw.tm);
		return;
		}

	ReturnUpdateResult (treqItem, ERROR_CAN_NOT_COMPLETE);
	}

/*++
*******************************************************************
		P r o c e s s T r e q T M I t e m

Routine Description:
	Processes triggered request work item that just completed timer wait
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID APIENTRY
ProcessTreqTMItem (
	PVOID		worker
	) {
	PTREQ_ITEM		treqItem = CONTAINING_RECORD (worker, TREQ_ITEM, tmw.worker);
	ULONG			count = treqItem->intf->stats.SapIfInputPackets;

	Trace (DEBUG_TREQ, "Processing triggered request tm item for interface: %d.",
												treqItem->intf->index);
	if ((treqItem->intf->stats.SapIfOperState==OPER_STATE_UP)
    		&& (OperationalState==OPER_STATE_UP)) {
		if (treqItem->pktCount!=count) {
			Trace (DEBUG_TREQ,
					 "\t%d more packets received during last check period.",
					 treqItem->intf->stats.SapIfInputPackets - treqItem->pktCount);
			treqItem->pktCount = count;
			treqItem->tmw.tm.dueTime = GetTickCount ()
								 + TriggeredUpdateCheckInterval*1000;
			AddLRTimerRequest (&treqItem->tmw.tm);
			}
        else if (treqItem->resend<MaxTriggeredUpdateRequests) {
			Trace (DEBUG_TREQ,
					 "\tresending update request (%d request).",
					 treqItem->resend+1);
			treqItem->iow.io.cbBuffer = FIELD_OFFSET (SAP_BUFFER, Entries[0].Type)
									+sizeof (treqItem->packet.Entries[0].Type);
			EnqueueSendRequest (&treqItem->iow.io);
			}
		else
			ReturnUpdateResult (treqItem, NO_ERROR);
		return;
		}

	ReturnUpdateResult (treqItem, ERROR_CAN_NOT_COMPLETE);
	}

/*++
*******************************************************************
		P r o c e s s T r e q A R I t e m

Routine Description:
	Processes triggered request work item that was reported to client
	in result queue
Arguments:
	worker - pointer to work item to process
Return Value:
	None
	
*******************************************************************
--*/
VOID
FreeTreqItem (
	PAR_PARAM_BLOCK	rslt
	)  {
	PTREQ_ITEM		treqItem = CONTAINING_RECORD (rslt, TREQ_ITEM, ar);

	Trace (DEBUG_TREQ, "Freeing triggered request item %08lx.", treqItem);
	DeallocateWorker (treqItem);
	}





/*++
*******************************************************************
 S a p B u i l d I n t  e r n a l U p d a t e L  i s t F i l t e r

Routine Description:
	Server enumeration callback proc createas a list of local servers
	that need to have their internal network numbers updated.

Arguments:
	CBParam - pointer to a list of SERVER_INTERNAL_UPDATE_NODE's
	
Return Value:
	TRUE (to stop enumeration)
	FALSE otherwise
*******************************************************************
--*/
BOOL SapBuildInternalUpdateListFilter (
	IN LPVOID					CBParam,
	IN OUT PIPX_SERVER_ENTRY_P	Server,
	IN ULONG					InterfaceIndex,
	IN ULONG					Protocol,
	IN PUCHAR					AdvertisingNode,
	IN INT						Flags) 
{
    IPX_SERVER_ENTRY_P TempServer;
    SERVER_INTERNAL_UPDATE_NODE * pNew, **ppList;

    // Get the list that we're dealing with                                  
    ppList = (SERVER_INTERNAL_UPDATE_NODE**)CBParam;

    // If this is a local server with an out of date network number
    // stored, then add it to the list of servers to update.
	if (InterfaceIndex == INTERNAL_INTERFACE_INDEX) {
    	if (IpxNetCmp (Server->Network, INTERNAL_IF_NET) != 0) {
    	    // Send some trace
    		Trace (DEBUG_SERVERDB, "Updating local server: %s  %x%x%x%x:%x%x%x%x%x%x:%x%x", 
    		                        Server->Name,
    		                        Server->Network[0], Server->Network[1], Server->Network[2], Server->Network[3], 
    		                        Server->Node[0], Server->Node[1], Server->Node[2], Server->Node[3], Server->Node[4], Server->Node[5],
    		                        Server->Socket[0], Server->Socket[1]
    		                        );
    		                        
            // Create and initialize the new node
            pNew = HeapAlloc (ServerTable.ST_Heap, 0, sizeof (SERVER_INTERNAL_UPDATE_NODE));
            if (!pNew)
                return TRUE;
            CopyMemory (&(pNew->Server), Server, sizeof (IPX_SERVER_ENTRY_P));
            pNew->InterfaceIndex = InterfaceIndex;
            pNew->Protocol = Protocol;
            pNew->AdvertisingNode = AdvertisingNode;
            pNew->Flags = Flags;

            // Insert the flag in the list
            if (*ppList)
                pNew->pNext = *ppList;
            else
                pNew->pNext = NULL;
            *ppList = pNew;
    	}
    	
	}
	
    return FALSE;
}

// 
// When the internal network number changes, we need to update the
// control blocks of the internal servers.
//
DWORD SapUpdateLocalServers () {
    SERVER_INTERNAL_UPDATE_NODE * pList = NULL, * pCur;
    BOOL bNewServer = FALSE;
    HANDLE hEnum;
    
	Trace (DEBUG_SERVERDB, "SapUpdateLocalServers: entered.");
	
    // Create a list enumerator that goes through all
    // servers in the table.
	hEnum = CreateListEnumerator (
				 SDB_HASH_TABLE_LINK,	
				 0xFFFF,
 				 NULL,
				 INVALID_INTERFACE_INDEX,
				 0xFFFFFFFF,
				 0);
	if (hEnum == NULL)
		return GetLastError ();

	// Enumerate the servers sending them through a filter
	// that updates their network number and node
	EnumerateServers (hEnum, SapBuildInternalUpdateListFilter, (LPVOID)&pList);
	DeleteListEnumerator (hEnum);

    // pList will now point to a list of servers that need to have 
    // their information updated.
    while (pList) {
        pCur = pList;
        
		// Send out a broadcast that the local server is now 
        // unreachable
		pCur->Server.HopCount = IPX_MAX_HOP_COUNT;
		UpdateServer ( &(pCur->Server),
		               pCur->InterfaceIndex,
		               pCur->Protocol,
		               INFINITE,
		               pCur->AdvertisingNode,
		               pCur->Flags,
		               &bNewServer );
		Trace (DEBUG_SERVERDB, "%s has been marked with hop count 16", pCur->Server.Name);
		               
		// Update the network and node number and advertise that 
		// it is available
	    IpxNetCpy (pCur->Server.Network, INTERNAL_IF_NET);
		IpxNodeCpy (pCur->Server.Node, INTERNAL_IF_NODE);
		pCur->Server.HopCount = 0;
		UpdateServer ( &(pCur->Server),
		               pCur->InterfaceIndex,
		               pCur->Protocol,
		               INFINITE,
		               pCur->AdvertisingNode,
		               pCur->Flags,
		               &bNewServer );
		Trace (DEBUG_SERVERDB, "%s has been updated.", pCur->Server.Name);

        // Cleanup
		pList = pList->pNext;
		HeapFree (ServerTable.ST_Heap, 0, pCur);
    }

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\workers.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\workers.h

Abstract:

	Header file for  agent work items

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#ifndef _SAP_WORKERS_
#define _SAP_WORKERS_

	
// Max number of pending recv work items
extern LONG MaxUnprocessedRequests;

// Minimum number of queued recv requests
extern LONG	MinPendingRequests;

// How often to check on pending triggered update
extern ULONG TriggeredUpdateCheckInterval;
// How many requests to send if no response received within check interval
extern ULONG MaxTriggeredUpdateRequests;

// Whether to respond for internal servers that are not registered with SAP
// through the API calls (for standalone service only)
extern ULONG RespondForInternalServers;

// Delay in response to general reguests for specific server type
// if local servers are included in the packet
extern ULONG DelayResponseToGeneral;

// Delay in sending change broadcasts if packet is not full
extern ULONG DelayChangeBroadcast;

	// Workers that are enqueued for io processing
typedef struct _IO_WORKER {
		WORKERFUNCTION		worker;
		IO_PARAM_BLOCK		io;
		} IO_WORKER, *PIO_WORKER;

	// Workers that are enqueued for timer processing
typedef struct _TIMER_WORKER {
		WORKERFUNCTION		worker;
		TM_PARAM_BLOCK		tm;
		} TIMER_WORKER, *PTIMER_WORKER;

	// Workers that are enqueued to receive LPC request
typedef struct _LPC_WORKER {
		WORKERFUNCTION		worker;
		LPC_PARAM_BLOCK		lpc;
		} LPC_WORKER, *PLPC_WORKER;
/*
VOID
ScheduleWorkItem (
	WORKERFUNCTION *worker
	);
*/
#define ScheduleWorkItem(worker) RtlQueueWorkItem(*worker,worker,0)

#define ProcessCompletedIORequest(ioreq) \
		ScheduleWorkItem (&CONTAINING_RECORD(ioreq,IO_WORKER,io)->worker)

#define ProcessCompletedTimerRequest(tmreq) \
		ScheduleWorkItem (&CONTAINING_RECORD(tmreq,TIMER_WORKER,tm)->worker);

#define ProcessCompletedLpcRequest(lpcreq) \
		ScheduleWorkItem (&CONTAINING_RECORD(lpcreq,LPC_WORKER,lpc)->worker)


/*++
*******************************************************************
		I n i t i a l i z e W o r k e r s

Routine Description:
	Initialize heap to be used for allocation of work items
Arguments:
	None
Return Value:
	NO_ERROR - heap was initialized  OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitializeWorkers (
	HANDLE	RecvEvent
	);

/*++
*******************************************************************
		S h u t d o w n W o r k e r s

Routine Description:
	Stops new worker creation and signals event when all
	workers are deleted
Arguments:
	doneEvent - event to be signalled when all workers are deleted
Return Value:
	None
	
*******************************************************************
--*/
VOID
ShutdownWorkers (
	IN HANDLE	doneEvent
	);
	
/*++
*******************************************************************
		D e l e t e W o r k e r s

Routine Description:
	Deletes heap used for work items
Arguments:
	None
Return Value:
	None
	
*******************************************************************
--*/
VOID
DeleteWorkers (
	void
	);


VOID
AddRecvRequests (
	LONG	count
	);

VOID
RemoveRecvRequests (
	LONG	count
	);

/*++
*******************************************************************
		I n i t R e q I t e m

Routine Description:
	Allocate and initialize IO request item
	Enqueue the request
Arguments:
	None
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitReqItem (
	void
	);


/*++
*******************************************************************
		I n i t R e s p I t e m

Routine Description:
	Allocate and initialize SAP response item
	Call ProcessRespItem to fill the packet and send it
Arguments:
	intf - pointer to interface control block to send on
	svrType - type of servers to put in response packet
	dst - where to send the response packet
	bcast - are we responding to broadcasted request
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitRespItem (
	PINTERFACE_DATA		intf,
	USHORT				svrType,
	PIPX_ADDRESS_BLOCK	dst,
	BOOL				bcast
	);

/*++
*******************************************************************
		I n i t G n e a r I t e m

Routine Description:
	Allocate and initialize GETNEAREST response work item
Arguments:
	intf - pointer to interface control block to send on
	svrType - type of servers to put in response packet
	dst - where to send the response packet
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitGnearItem (
	PINTERFACE_DATA		intf,
	USHORT				svrType,
	PIPX_ADDRESS_BLOCK	dest
	);
	
/*++
*******************************************************************
		I n i t B c a s t I t e m

Routine Description:
	Allocate and initialize broadcast item
Arguments:
	intf - pointer to interface control block to send on
	chngEnum - enumeration handle in SDB change queue to track changed servers
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitBcastItem (
	PINTERFACE_DATA		intf
	);

/*++
*******************************************************************
		I n i t S r e q I t e m

Routine Description:
	Allocate and initialize send request item (send SAP request on interface)
Arguments:
	intf - pointer to interface control block to send on
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitSreqItem (
	PINTERFACE_DATA		intf
	);


/*++
*******************************************************************
		I n i t L P C I t e m

Routine Description:
	Allocate and initialize LPC work item
Arguments:
	None
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitLPCItem (
	void
	);

/*++
*******************************************************************
		I n i t T r e q I t e m

Routine Description:
	Allocate and initialize triggered request item (send SAP request on interface
	and wait for responces to arrive)
Arguments:
	intf - pointer to interface control block to send on
Return Value:
	NO_ERROR - item was initialized and enqueued OK
	other - operation failed (windows error code)
	
*******************************************************************
--*/
DWORD
InitTreqItem (
	PINTERFACE_DATA			intf
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\timermgr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

	net\routing\ipx\sap\timermgr.c

Abstract:

	Timer queue manager for SAP agent.

Author:

	Vadim Eydelman  05-15-1995

Revision History:

--*/
#include "sapp.h"


	// Timer queues and associated synchronization
typedef struct _TIMER_QUEUES {
		LIST_ENTRY				hrQueue;	// Hi-res quueue (msec)
		LIST_ENTRY				lrQueue;	// Lo-res queue (sec)
		HANDLE					timer;		// NT timer signalled when
											// one or more items in the
											// timer queue have expired
		CRITICAL_SECTION		lock;		// Protection
		} TIMER_QUEUES, *PTIMER_QUEUES;



TIMER_QUEUES TimerQueues;

/*++
*******************************************************************
		C r e a t e T i m e r Q u e u e

Routine Description:
		Allocates resources for timer queue

Arguments:
	wakeObject - sync object, to be signalled when
			timer manager needs a shot process its timer queue

Return Value:
		NO_ERROR - resources were allocated successfully
		other - reason of failure (windows error code)

*******************************************************************
--*/
DWORD
IpxSapCreateTimerQueue (
	HANDLE			*wakeObject
	) {
	DWORD			status;

	status = NtCreateTimer (&TimerQueues.timer, TIMER_ALL_ACCESS,
								NULL, NotificationTimer);
	if (NT_SUCCESS (status)) {
		*wakeObject = TimerQueues.timer;

		InitializeCriticalSection (&TimerQueues.lock);
		InitializeListHead (&TimerQueues.hrQueue);
		InitializeListHead (&TimerQueues.lrQueue);
		return NO_ERROR;
		}
	else
		Trace (DEBUG_FAILURES, "File: %s, line %ld."
							" Failed to create timer (nts:%lx).",
								__FILE__, __LINE__, status);
	return status;
	}
				
/*++
*******************************************************************
		E x p i r e T i m e r Q u e u e

Routine Description:
	Expires (completes) all requests in timer queue
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
ExpireTimerQueue (
	void
	) {
	BOOLEAN			res;

	Trace (DEBUG_TIMER, "Expiring timer queue.");
	EnterCriticalSection (&TimerQueues.lock);
	while (!IsListEmpty (&TimerQueues.hrQueue)) {
		PTM_PARAM_BLOCK treq = CONTAINING_RECORD (TimerQueues.hrQueue.Flink,
										TM_PARAM_BLOCK,
										link);
		RemoveEntryList (&treq->link);
		ProcessCompletedTimerRequest (treq);
		}

	while (!IsListEmpty (&TimerQueues.lrQueue)) {
		PTM_PARAM_BLOCK treq = CONTAINING_RECORD (TimerQueues.lrQueue.Flink,
										TM_PARAM_BLOCK,
										link);
		RemoveEntryList (&treq->link);
		ProcessCompletedTimerRequest (treq);
		}

	LeaveCriticalSection (&TimerQueues.lock);
	}


/*++
*******************************************************************
		E x p i r e L R R e q u s t s

Routine Description:
	Expires (completes) Low Resolution timer requests
	that return true from expiration check routine
Arguments:
	context	- context to pass to expiration check routine
Return Value:
	None
*******************************************************************
--*/
VOID
ExpireLRRequests (
	PVOID	context
	) {
	BOOLEAN			res;
	PLIST_ENTRY		cur;

	Trace (DEBUG_TIMER, "Expire LR timer request call with context %08lx.", context);
	EnterCriticalSection (&TimerQueues.lock);
	cur = TimerQueues.lrQueue.Flink;
	while (cur!=&TimerQueues.lrQueue) {
		PTM_PARAM_BLOCK treq = CONTAINING_RECORD (cur,
										TM_PARAM_BLOCK,
										link);
		cur = cur->Flink;
		if ((treq->ExpirationCheckProc!=NULL)
				&& (*treq->ExpirationCheckProc)(treq, context)) {
			RemoveEntryList (&treq->link);
			ProcessCompletedTimerRequest (treq);
			}
		}

	LeaveCriticalSection (&TimerQueues.lock);

	}



/*++
*******************************************************************
		D e l e t e T i m e r Q u e u e

Routine Description:
	Release all resources associated with timer queue

Arguments:
	None

Return Value:
	NO_ERROR - operation completed OK

*******************************************************************
--*/
VOID
IpxSapDeleteTimerQueue (
	void
	) {
	NtClose (TimerQueues.timer);
	DeleteCriticalSection (&TimerQueues.lock);
	}



/*++
*******************************************************************
		P r o c e s s T i m e r Q u e u e

Routine Description:
	Process timer queues and moves expired requests to completion queue
	This routine should be called when wake object is signalled
Arguments:
	None

Return Value:
	None
*******************************************************************
--*/
VOID
ProcessTimerQueue (
	void
	) {
	ULONG			curTime = GetTickCount ();
	ULONG			dueTime = curTime+MAXULONG/2;
	LONGLONG		timeout;
	DWORD			status;
		
	EnterCriticalSection (&TimerQueues.lock);
	while (!IsListEmpty (&TimerQueues.hrQueue)) {
		PTM_PARAM_BLOCK treq = CONTAINING_RECORD (TimerQueues.hrQueue.Flink,
										TM_PARAM_BLOCK,
										link);
		if (IsLater(curTime,treq->dueTime)) {
			RemoveEntryList (&treq->link);
			ProcessCompletedTimerRequest (treq);
			}
		else {
			dueTime = treq->dueTime;
			break;
			}
		}

	while (!IsListEmpty (&TimerQueues.lrQueue)) {
		PTM_PARAM_BLOCK treq = CONTAINING_RECORD (TimerQueues.lrQueue.Flink,
										TM_PARAM_BLOCK,
										link);
		if (IsLater(curTime,treq->dueTime)) {
			RemoveEntryList (&treq->link);
			ProcessCompletedTimerRequest (treq);
			}
		else {
			if (IsLater(dueTime,treq->dueTime))
				dueTime = treq->dueTime;
			break;
			}
		}

	timeout = ((LONGLONG)(dueTime-curTime))*(-10000);
	status = NtSetTimer (TimerQueues.timer,
							 (PLARGE_INTEGER)&timeout,
							 NULL, NULL, FALSE, 0, NULL);
	ASSERTMSG ("Could not set timer ", NT_SUCCESS (status));
	LeaveCriticalSection (&TimerQueues.lock);

	}


/*++
*******************************************************************
		A d d H R T i m e r R e q u e s t

Routine Description:
	Enqueue request for hi-res timer (delay in order of msec)
Arguments:
	treq - timer parameter block: dueTime  field must be set
Return Value:
	None

*******************************************************************
--*/
VOID
AddHRTimerRequest (
	PTM_PARAM_BLOCK			treq
	) {
	PLIST_ENTRY			cur;

	EnterCriticalSection (&TimerQueues.lock);
	
	cur = TimerQueues.hrQueue.Blink;
	while (cur!=&TimerQueues.hrQueue) {
		PTM_PARAM_BLOCK node = CONTAINING_RECORD (cur, TM_PARAM_BLOCK, link);
		if (IsLater(treq->dueTime,node->dueTime))
			break;
		cur = cur->Blink;
		}

	InsertHeadList (cur, &treq->link);
	if (cur==&TimerQueues.hrQueue) {
		ULONG	delay = treq->dueTime-GetTickCount ();
		LONGLONG timeout = (delay>MAXULONG/2) ? 0 : ((LONGLONG)delay*(-10000));
		DWORD status = NtSetTimer (TimerQueues.timer,
									(PLARGE_INTEGER)&timeout,
									 NULL, NULL, FALSE, 0, NULL);
		ASSERTMSG ("Could not set timer ", NT_SUCCESS (status));
		}
	LeaveCriticalSection (&TimerQueues.lock);
	}

/*++
*******************************************************************
		A d d L R T i m e r R e q u e s t

Routine Description:
	Enqueue request for lo-res timer (delay in order of sec)
Arguments:
	treq - timer parameter block: dueTime  field must be set
Return Value:
	None
*******************************************************************
--*/
VOID
AddLRTimerRequest (
	PTM_PARAM_BLOCK			treq
	) {
	PLIST_ENTRY			cur;

	RoundUpToSec (treq->dueTime);
	EnterCriticalSection (&TimerQueues.lock);
	
	cur = TimerQueues.lrQueue.Blink;
	while (cur!=&TimerQueues.lrQueue) {
		PTM_PARAM_BLOCK node = CONTAINING_RECORD (cur, TM_PARAM_BLOCK, link);
		if (IsLater(treq->dueTime,node->dueTime))
			break;
		cur = cur->Blink;
		}

	InsertHeadList (cur, &treq->link);
	if ((cur==&TimerQueues.lrQueue)
			&& IsListEmpty (&TimerQueues.hrQueue)) {
		ULONG	delay = treq->dueTime-GetTickCount ();
		LONGLONG timeout = (delay>MAXULONG/2) ? 0 : ((LONGLONG)delay*(-10000));
		DWORD status = NtSetTimer (TimerQueues.timer,
									(PLARGE_INTEGER)&timeout,
									 NULL, NULL, FALSE, 0, NULL);
		ASSERTMSG ("Could not set timer ", NT_SUCCESS (status));
		}
	LeaveCriticalSection (&TimerQueues.lock);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\client\advapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\advapi.c

Abstract:

    This routine handles the Advertise API for the SAP Agent

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/*++
*******************************************************************
        S a p A d d A d v e r t i s e

Routine Description:

        This routine adds an entry to the list of servers
        that we advertise.

Arguments:
            ServerName = Ptr to AsciiZ server name
            ServerType = USHORT of object type to add
            ServerAddr = Ptr to 12 byte aerver address
            RespondNearest = TRUE  = Use me for respond nearest call
                             FALSE = Don't use me for respond nearest call

Return Value:

            SAPRETURN_SUCCESS  - Added OK
            SAPRETURN_NOMEMORY - Error allocating memory
            SAPRETURN_EXISTS   - Already exists in list
            SAPRETURN_NOTINIT  - SAP Agent is not running
*******************************************************************
--*/

INT
SapAddAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType,
	IN PUCHAR ServerAddr,
    IN BOOL   RespondNearest)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not running - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Make sure name is not too long **/

    if (strlen(ServerName) > NWSAP_MAXNAME_LENGTH) {
        return SAPRETURN_INVALIDNAME;
    }

    /** Build the Add Advertise message **/

    request.MessageType = NWSAP_LPCMSG_ADDADVERTISE;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.AdvApi.ServerName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.AdvApi.ServerName, ServerName);
    memcpy(request.Message.AdvApi.ServerAddr, ServerAddr, 12);
    request.Message.AdvApi.ServerType = ServerType;
    request.Message.AdvApi.RespondNearest = RespondNearest;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    memcpy(ServerAddr, reply.Message.AdvApi.ServerAddr, 12);

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p R e m o v e A d v e r t i s e

Routine Description:

        This routine removes an entry to the list of servers
        that we advertise.

Arguments:
            ServerName = Ptr to AsciiZ server name
            ServerType = USHORT of object type to remove

Return Value:

            SAPRETURN_SUCCESS  - Added OK
            SAPRETURN_NOTEXIST - Entry does not exist in list
            SAPRETURN_NOTINIT  - SAP Agent is not running
*******************************************************************
--*/

INT
SapRemoveAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not running - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Make sure name is not too long **/

    if (strlen(ServerName) > NWSAP_MAXNAME_LENGTH) {
        return SAPRETURN_INVALIDNAME;
    }

    /** Build the Add Advertise message **/

    request.MessageType = NWSAP_LPCMSG_REMOVEADVERTISE;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.AdvApi.ServerName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.AdvApi.ServerName, ServerName);
    request.Message.AdvApi.ServerType = ServerType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\client\precomp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\precomp.h

Abstract:

    Include files for the SAP Agent library

Author:

    Brian Walker (MCS)	13-Jun-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdlib.h>
#include <nwsap.h>
#include "..\saplpc.h"

/** Global Variables **/

extern INT SapLibInitialized;
extern HANDLE SapXsPortHandle;

#define NWSAP_MAXNAME_LENGTH    47

/** Functions **/






=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\client\bindlib.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\bindlib.c

Abstract:

    This routine handles the BindLib API for the SAP Agent

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


/*++
*******************************************************************
        S a p G e t O b j e c t N a m e

Routine Description:

        This routine converts an Object ID into an Object Name
        and Type.

Arguments:
            ObjectID   = Object ID to convert
            ObjectName = Ptr to where to store 48 byte object name
            ObjectType = Ptr to where to store the object type
            ObjectAddr = Ptr to where to store NET_ADDRESS (12 bytes)

            ObjectName, ObjectType, ObjectAddr can be NULL.

Return Value:

            SAPRETURN_SUCCESS  = OK - name and type are filled in
            SAPRETURN_NOTEXIST = Invalid object id.
*******************************************************************
--*/

INT
SapGetObjectName(
    IN ULONG   ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN PUCHAR  ObjectAddr)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_GETOBJECTNAME;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;
    request.PortMessage.MessageId         = 0;

    request.Message.BindLibApi.ObjectID = ObjectID;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    if (ObjectType)
        *ObjectType = reply.Message.BindLibApi.ObjectType;

    if (ObjectName)
        memcpy(ObjectName, reply.Message.BindLibApi.ObjectName, NWSAP_MAXNAME_LENGTH+1);

    if (ObjectAddr)
        memcpy(ObjectAddr, reply.Message.BindLibApi.ObjectAddr, 12);

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p G e t O b j e c t I D

Routine Description:

        This routine converts a name and type into an object ID.

Arguments:
            ObjectName = Ptr to AsciiZ object name (Must be uppercase)
            ObjectType = Object type to look for
            ObjectID   = Ptr to where to store the object ID.

Return Value:

            SAPRETURN_SUCCESS  = OK - Object ID is filled in
            SAPRETURN_NOTEXIST = Name/Type not found
*******************************************************************
--*/

INT
SapGetObjectID(
    IN PUCHAR ObjectName,
    IN USHORT ObjectType,
	IN PULONG ObjectID)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** If the name is too long - error **/

    if (strlen(ObjectName) > NWSAP_MAXNAME_LENGTH)
        return SAPRETURN_INVALIDNAME;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_GETOBJECTID;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    memset(request.Message.BindLibApi.ObjectName, 0, NWSAP_MAXNAME_LENGTH+1);
    strcpy(request.Message.BindLibApi.ObjectName, ObjectName);
    request.Message.BindLibApi.ObjectType = ObjectType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    *ObjectID = reply.Message.BindLibApi.ObjectID;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}


/*++
*******************************************************************
        S a p S c a n O b j e c t

Routine Description:

        This routine is used to scan thru the database list.

Arguments:
            ObjectID   = Ptr to last Object ID we saw.  On first call
                         this should point to a 0xFFFFFFFF.
            ObjectName = Ptr to where to store 48 byte object name
            ObjectType = Ptr to where to store the object type
            ScanType   = Object Type that we are scanning for
                         (0xFFFF = All)

            ObjectName, ObjectType can be NULL.

Return Value:

            SAPRETURN_SUCCESS  = OK - name and type are filled in
                                 ObjectID has the object ID of this entry.
            SAPRETURN_NOTEXIST = Invalid object id.
*******************************************************************
--*/

INT
SapScanObject(
    IN PULONG  ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN USHORT  ScanType)
{
    NTSTATUS status;
    NWSAP_REQUEST_MESSAGE request;
    NWSAP_REPLY_MESSAGE reply;

    /** If not initialized - return error **/

    if (!SapLibInitialized)
        return SAPRETURN_NOTINIT;

    /** Build the Get Object Name message **/

    request.MessageType = NWSAP_LPCMSG_SEARCH;
    request.PortMessage.u1.s1.DataLength  = (USHORT)(sizeof(request) - sizeof(PORT_MESSAGE));
    request.PortMessage.u1.s1.TotalLength = sizeof(request);
    request.PortMessage.u2.ZeroInit       = 0;

    request.Message.BindLibApi.ObjectID = *ObjectID;
    request.Message.BindLibApi.ScanType = ScanType;

    /** Send it and get a response **/

    status = NtRequestWaitReplyPort(
                SapXsPortHandle,
                (PPORT_MESSAGE)&request,
                (PPORT_MESSAGE)&reply);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    /** If we got a SAP error - return it **/

    if (reply.Error)
        return reply.Error;

    /** Return the entry **/

    if (ObjectType)
        *ObjectType = reply.Message.BindLibApi.ObjectType;

    if (ObjectName)
        memcpy(ObjectName, reply.Message.BindLibApi.ObjectName, NWSAP_MAXNAME_LENGTH+1);

    *ObjectID = reply.Message.BindLibApi.ObjectID;

    /** All Done OK **/

    return SAPRETURN_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\client\init.c ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\svcdlls\nwsap\client\init.c

Abstract:

    This routine initializes the SAP Library

Author:

    Brian Walker (MCS) 06-15-1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/** Global Variables **/

INT SapLibInitialized = 0;
HANDLE SapXsPortHandle;


/*++
*******************************************************************
        S a p L i b I n i t

Routine Description:

        This routine initializes the SAP interface for a program

Arguments:
            None

Return Value:

            0 = Ok
            Else = Error
*******************************************************************
--*/

DWORD
SapLibInit(
    VOID)
{
    UNICODE_STRING unistring;
    NTSTATUS status;
    SECURITY_QUALITY_OF_SERVICE qos;

    /** If already initialized - return ok **/

    if (SapLibInitialized) {
        return 0;
    }

    /** Connect the port **/

    /** Fill out the security quality of service **/

    qos.Length = sizeof(qos);
    qos.ImpersonationLevel  = SecurityImpersonation;
    qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    qos.EffectiveOnly       = TRUE;

    /** Setup the unicode string of the port name **/

    RtlInitUnicodeString(&unistring, NWSAP_BIND_PORT_NAME_W);

    /** Do the connect **/

    status = NtConnectPort(
            &SapXsPortHandle,           /* We get a handle back     */
            &unistring,                 /* Port name to connect to  */
            &qos,                       /* Quality of service       */
            NULL,                       /* Client View              */
            NULL,                       /* Server View              */
            NULL,                       /* MaxMessageLength         */
            NULL,                       /* ConnectionInformation    */
            NULL);                      /* ConnectionInformationLength */

    /** If error - just return it **/

    if (!NT_SUCCESS(status))
        return status;

    /** All Done **/

    SapLibInitialized = 1;
    return 0;
}


/*++
*******************************************************************
        S a p L i b S h u t d o w n

Routine Description:

        This routine shuts down the SAP interface for a program

Arguments:
            None

Return Value:

            0 = Ok
            Else = Error
*******************************************************************
--*/

DWORD
SapLibShutdown(
    VOID)
{
    /** If not initialized - leave **/

    if (!SapLibInitialized)
        return 0;

    /** Close the port **/

    NtClose(SapXsPortHandle);

    /** All Done **/

    SapLibInitialized = 0;
    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\test\testdlg.h ===
#define IDE_INTERFACE_E             304
#define IDE_PROTOCOL_E              306
#define IDC_INTERFACE               303
#define IDC_PROTOCOL                305
#define IDC_NAME                    307
#define IDE_NAME_E                  308
#define IDC_TYPE                    309
#define IDL_RESULT                  311
#define IDB_HANDLE_ENUM             313
#define IDB_MIB_ENUM                314
#define IDB_GET_NEXT                315
#define IDB_DELETE                  316
#define IDE_TYPE_E                  323
#define IDE_NETWORK_M               324
#define IDE_NODE_M                  325
#define IDE_SOCKET_M                326
#define IDB_ADD                     327
#define IDE_NAME_M                  328
#define IDE_TYPE_M                  330
#define IDE_PROTOCOL_M              331
#define IDE_INTERFACE_M             332
#define IDG_MODIFICATION            333
#define IDB_BLOCK_DELETE            334
#define IDB_BLOCK_CONVERT           335
#define IDD_SDB_TEST                300
#define IDR_TYPE_NAME               301
#define IDR_INTERFACE               302
#define IDG_ORDERING                312
#define IDLB_SERVICES               317
#define IDE_HOP_COUNT_M             329
#define IDG_ENUM_CRITERIA           310
#define IDG_ENUM_ACTIONS            318
#define IDB_START                   319
#define IDB_STOP                    320
#define IDG_FILTERS                 321
#define IDB_SET_FILTERS             322
#define IDC_ADVERTISE               336
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\debug.h ===
#ifndef _SNMP_MIPXMIB_
#define _SNMP_MIPXMIB_

#define DBG_LOAD				0x00000001
#define DBG_IPXBASE				0x00000010
#define DBG_IPXINTERFACES		0x00000020
#define DBG_DESTTABLE			0x00000040
#define DBG_STATICROUTES		0x00000080
#define DBG_SERVERTABLE			0x00000100
#define DBG_STATICSERVERS		0x00000200

#define DBG_RIPSAPBASE			0x00001000
#define DBG_RIPINTERFACES		0x00002000
#define DBG_SAPINTERFACES		0x00004000

#define DBG_NIPXBASICSYSENTRY	0x00010000
#define DBG_NIPXADVSYSENTRY		0x00020000
#define DBG_NIPXCIRCENTRY		0x00040000
#define DBG_NIPXDESTENTRY		0x00080000
#define DBG_NIPXSTATICRTENTRY	0x00100000
#define DBG_NIPXSERVENTRY		0x00200000
#define DBG_NIPXDESTSERVENTRY	0x00400000
#define DBG_NIPXSTATICSERVENTRY	0x00800000

#define DEF_DBGLEVEL			0x00000001

#if DBG

	extern	DWORD	DbgLevel;
	#define DbgTrace(level,args)	\
		do {						\
			if (level&&DbgLevel)	\
				DbgPrint args;		\
		}							\
		while (0)
#else	// if DBG

	#define DbgTrace(level,args)

#endif	// if DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mipxe.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mipxe.h

Abstract:

    ms-ipx mib entry indeces

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_MIPXE_
#define _SNMP_MIPXE_


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_mipxBase                         0
#define mi_mipxBaseOperState                mi_mipxBase+1                      
#define mi_mipxBasePrimaryNetNumber         mi_mipxBaseOperState+1
#define mi_mipxBaseNode                     mi_mipxBasePrimaryNetNumber+1
#define mi_mipxBaseSysName                  mi_mipxBaseNode+1
#define mi_mipxBaseMaxPathSplits            mi_mipxBaseSysName+1
#define mi_mipxBaseIfCount                  mi_mipxBaseMaxPathSplits+1
#define mi_mipxBaseDestCount                mi_mipxBaseIfCount+1
#define mi_mipxBaseServCount                mi_mipxBaseDestCount+1
#define mi_mipxInterface                    mi_mipxBaseServCount+1
#define mi_mipxIfTable                      mi_mipxInterface+1
#define mi_mipxIfEntry                      mi_mipxIfTable+1
#define mi_mipxIfIndex                      mi_mipxIfEntry+1
#define mi_mipxIfAdminState                 mi_mipxIfIndex+1
#define mi_mipxIfOperState                  mi_mipxIfAdminState+1
#define mi_mipxIfAdapterIndex               mi_mipxIfOperState+1
#define mi_mipxIfName                       mi_mipxIfAdapterIndex+1
#define mi_mipxIfType                       mi_mipxIfName+1
#define mi_mipxIfLocalMaxPacketSize         mi_mipxIfType+1
#define mi_mipxIfMediaType                  mi_mipxIfLocalMaxPacketSize+1
#define mi_mipxIfNetNumber                  mi_mipxIfMediaType+1
#define mi_mipxIfMacAddress                 mi_mipxIfNetNumber+1
#define mi_mipxIfDelay                      mi_mipxIfMacAddress+1
#define mi_mipxIfThroughput                 mi_mipxIfDelay+1
#define mi_mipxIfIpxWanEnable               mi_mipxIfThroughput+1
#define mi_mipxIfNetbiosAccept              mi_mipxIfIpxWanEnable+1
#define mi_mipxIfNetbiosDeliver             mi_mipxIfNetbiosAccept+1
#define mi_mipxIfInHdrErrors                mi_mipxIfNetbiosDeliver+1
#define mi_mipxIfInFilterDrops              mi_mipxIfInHdrErrors+1
#define mi_mipxIfInNoRoutes                 mi_mipxIfInFilterDrops+1
#define mi_mipxIfInDiscards                 mi_mipxIfInNoRoutes+1
#define mi_mipxIfInDelivers                 mi_mipxIfInDiscards+1
#define mi_mipxIfOutFilterDrops             mi_mipxIfInDelivers+1
#define mi_mipxIfOutDiscards                mi_mipxIfOutFilterDrops+1
#define mi_mipxIfOutDelivers                mi_mipxIfOutDiscards+1
#define mi_mipxIfInNetbiosPackets           mi_mipxIfOutDelivers+1
#define mi_mipxIfOutNetbiosPackets          mi_mipxIfInNetbiosPackets+1
#define mi_mipxForwarding                   mi_mipxIfOutNetbiosPackets+1
#define mi_mipxDestTable                    mi_mipxForwarding+1
#define mi_mipxDestEntry                    mi_mipxDestTable+1
#define mi_mipxDestNetNum                   mi_mipxDestEntry+1
#define mi_mipxDestProtocol                 mi_mipxDestNetNum+1
#define mi_mipxDestTicks                    mi_mipxDestProtocol+1
#define mi_mipxDestHopCount                 mi_mipxDestTicks+1
#define mi_mipxDestNextHopIfIndex           mi_mipxDestHopCount+1
#define mi_mipxDestNextHopMacAddress        mi_mipxDestNextHopIfIndex+1
#define mi_mipxDestFlags                    mi_mipxDestNextHopMacAddress+1
#define mi_mipxStaticRouteTable             mi_mipxDestFlags+1
#define mi_mipxStaticRouteEntry             mi_mipxStaticRouteTable+1
#define mi_mipxStaticRouteIfIndex           mi_mipxStaticRouteEntry+1
#define mi_mipxStaticRouteNetNum            mi_mipxStaticRouteIfIndex+1
#define mi_mipxStaticRouteEntryStatus       mi_mipxStaticRouteNetNum+1
#define mi_mipxStaticRouteTicks             mi_mipxStaticRouteEntryStatus+1
#define mi_mipxStaticRouteHopCount          mi_mipxStaticRouteTicks+1
#define mi_mipxStaticRouteNextHopMacAddress mi_mipxStaticRouteHopCount+1
#define mi_mipxServices                     mi_mipxStaticRouteNextHopMacAddress+1
#define mi_mipxServTable                    mi_mipxServices+1
#define mi_mipxServEntry                    mi_mipxServTable+1
#define mi_mipxServType                     mi_mipxServEntry+1
#define mi_mipxServName                     mi_mipxServType+1
#define mi_mipxServProtocol                 mi_mipxServName+1
#define mi_mipxServNetNum                   mi_mipxServProtocol+1
#define mi_mipxServNode                     mi_mipxServNetNum+1
#define mi_mipxServSocket                   mi_mipxServNode+1
#define mi_mipxServHopCount                 mi_mipxServSocket+1
#define mi_mipxStaticServTable              mi_mipxServHopCount+1
#define mi_mipxStaticServEntry              mi_mipxStaticServTable+1
#define mi_mipxStaticServIfIndex            mi_mipxStaticServEntry+1
#define mi_mipxStaticServType               mi_mipxStaticServIfIndex+1
#define mi_mipxStaticServName               mi_mipxStaticServType+1
#define mi_mipxStaticServEntryStatus        mi_mipxStaticServName+1
#define mi_mipxStaticServNetNum             mi_mipxStaticServEntryStatus+1
#define mi_mipxStaticServNode               mi_mipxStaticServNetNum+1
#define mi_mipxStaticServSocket             mi_mipxStaticServNode+1
#define mi_mipxStaticServHopCount           mi_mipxStaticServSocket+1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxIfEntry table (1.3.6.1.4.1.311.1.8.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mipxIfEntry                      25
#define ni_mipxIfEntry                      1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxDestEntry table (1.3.6.1.4.1.311.1.8.3.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mipxDestEntry                    7
#define ni_mipxDestEntry                    1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticRouteEntry table (1.3.6.1.4.1.311.1.8.3.2.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mipxStaticRouteEntry             6
#define ni_mipxStaticRouteEntry             2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServEntry table (1.3.6.1.4.1.311.1.8.4.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mipxServEntry                    7
#define ni_mipxServEntry                    2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticServEntry table (1.3.6.1.4.1.311.1.8.4.2.1)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mipxStaticServEntry              8
#define ni_mipxStaticServEntry              3


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\sap\test\testsap.c ===
#include "testdlg.h"
#include "sapp.h"

VOID
ProcessAdapterEvents (
	VOID
	);

BOOL
ProcessUpdateEvents (
	VOID
	);

BOOL CALLBACK
SDBDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);
   	
HINSTANCE				hDLL;
HINSTANCE				hModule;
HINSTANCE				hUtil;

PREGISTER_PROTOCOL		RegisterProtocolProc;
PSTART_PROTOCOL			StartProtocolProc;
PSTOP_PROTOCOL			StopProtocolProc;
PGET_GLOBAL_INFO		GetGlobalInfoProc;
PSET_GLOBAL_INFO		SetGlobalInfoProc;
PADD_INTERFACE			AddInterfaceProc;
PDELETE_INTERFACE		DeleteInterfaceProc;
PGET_EVENT_MESSAGE		GetEventMessageProc;
PACTIVATE_INTERFACE		ActivateInterfaceProc;
PDEACTIVATE_INTERFACE	DeactivateInterfaceProc;
PDO_UPDATE_SERVICES		DoUpdateServicesProc;

PIS_SERVICE							IsServiceProc;
PCREATE_SERVICE_ENUMERATION_HANDLE	CreateServiceEnumerationHandleProc;
PENUMERATE_GET_NEXT_SERVICE			EnumerateGetNextServiceProc;
PCLOSE_SERVICE_ENUMERATION_HANDLE	CloseServiceEnumerationHandleProc;
PCREATE_STATIC_SERVICE				CreateStaticServiceProc;
PDELETE_STATIC_SERVICE				DeleteStaticServiceProc;
PBLOCK_CONVERT_SERVICES_TO_STATIC	BlockConvertServicesToStaticProc;
PBLOCK_DELETE_STATIC_SERVICES		BlockDeleteStaticServicesProc;
PGET_FIRST_ORDERED_SERVICE			GetFirstOrderedServiceProc;
PGET_NEXT_ORDERED_SERVICE			GetNextOrderedServiceProc;

SERVICE_STATUS			RouterStatus;
SERVICE_STATUS_HANDLE 	RouterHdl;
CRITICAL_SECTION		RouterLock;


PSVCS_SERVICE_DLL_ENTRY				ServiceEntryProc;

HANDLE	WaitObjects[2];
#define	ConfigEvent (WaitObjects[0])
#define	NotificEvent (WaitObjects[1])
HWND SDBDlg=NULL;

VOID RouterMain(
	DWORD		dwArgc, 
    LPTSTR		*lpszArgv  
	);

VOID ServiceMain(
    DWORD  dwArgc,	// number of arguments 
    LPTSTR  *lpszArgv 	// address of array of argument string pointers  
   );

#define SERVICE_ROUTER TEXT("Router")

HANDLE	ConfigPort=INVALID_HANDLE_VALUE;
int _cdecl main (
	int argv,
	char **argc
	) {
	DWORD						status;
	STARTUPINFO					sInfo;
	static SERVICE_TABLE_ENTRY	svcEntries[] = {
					{SERVICE_NWSAP, ServiceMain},
					{SERVICE_ROUTER, RouterMain},
					{NULL, NULL}
					};
	HANDLE						RMThreadHdl;
	DWORD						id;	

	GetStartupInfo (&sInfo);
	hModule = LoadLibrary (sInfo.lpTitle);
	ASSERTERR (hModule!=NULL);

	hUtil = LoadLibrary (TEXT("rtutils.dll"));
	ASSERTERR (hUtil!=NULL);

	hDLL = LoadLibrary (TEXT("ipxsap.dll"));
	ASSERTERR (hDLL!=NULL);

	if (StartServiceCtrlDispatcher (svcEntries))
		DbgPrint ("Service dispatcher done.\n");
	else
		DbgPrint ("StartServiceCtrlDispatcher failed (gle:%ld).\n",
											GetLastError ());
				
	FreeLibrary (hDLL);
	FreeLibrary (hModule);
	FreeLibrary (hUtil);

	return 0;
	}
	

VOID WINAPI
RouterHandler(
	DWORD		fdwControl 
	) {
	DWORD status;

	EnterCriticalSection (&RouterLock);
	switch (fdwControl) {
		case SERVICE_CONTROL_STOP:
		case SERVICE_CONTROL_SHUTDOWN:
			IpxDeleteAdapterConfigurationPort (ConfigPort);
			ResetEvent (ConfigEvent);
			ConfigPort = INVALID_HANDLE_VALUE;
			status = (*StopProtocolProc) ();
			DbgPrint ("Stop protocol returned status %0lx.\n", status);
			RouterStatus.dwCurrentState = SERVICE_STOP_PENDING;
		        // break not put on purpose
	
		case SERVICE_CONTROL_INTERROGATE:
			if ((RouterStatus.dwCurrentState==SERVICE_START_PENDING)
					|| (RouterStatus.dwCurrentState==SERVICE_STOP_PENDING)) {
				RouterStatus.dwCheckPoint += 1;
				RouterStatus.dwWaitHint = 60;
				}
			break;
		default:
			DbgPrint ("Service control handler called with unknown"
					" or unsupported code %d.\n", fdwControl);
			break;

		}
	SetServiceStatus (RouterHdl, &RouterStatus);
	LeaveCriticalSection (&RouterLock);
	}

VOID RouterMain(
	DWORD		dwArgc, 
    LPTSTR		*lpszArgv  
	) {
	MSG			msg;
	DWORD		status;
	ADAPTERS_GLOBAL_PARAMETERS	params;
	SAP_GLOBAL_INFO		sapGlobalInfo;
	ULONG		ProtID;
	DWORD		Funct;

	InitializeCriticalSection (&RouterLock);
    RouterHdl = RegisterServiceCtrlHandler (SERVICE_ROUTER, &RouterHandler);
	if (RouterHdl) {
		EnterCriticalSection (&RouterLock);
		RouterStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
		RouterStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP
											| SERVICE_ACCEPT_SHUTDOWN;
		RouterStatus.dwWin32ExitCode = NO_ERROR;
		RouterStatus.dwServiceSpecificExitCode = NO_ERROR;
		RouterStatus.dwCheckPoint = 0;
		RouterStatus.dwWaitHint = 60;
		RouterStatus.dwCurrentState = SERVICE_START_PENDING;
		LeaveCriticalSection (&RouterLock);

		SetServiceStatus (RouterHdl, &RouterStatus);

		RegisterProtocolProc = (PREGISTER_PROTOCOL)
						GetProcAddress (hDLL,
							 REGISTER_PROTOCOL_ENTRY_POINT_STRING);
		ASSERTERR (RegisterProtocolProc!=NULL);

		StartProtocolProc = (PSTART_PROTOCOL)			
						GetProcAddress (hDLL,
							 START_PROTOCOL_ENTRY_POINT_STRING);
		ASSERTERR (StartProtocolProc!=NULL);

		StopProtocolProc = (PSTOP_PROTOCOL)			
						GetProcAddress (hDLL,
							 STOP_PROTOCOL_ENTRY_POINT_STRING);
		ASSERTERR (StopProtocolProc!=NULL);

		GetGlobalInfoProc = (PGET_GLOBAL_INFO)			
						GetProcAddress (hDLL,
							 GET_GLOBAL_INFO_ENTRY_POINT_STRING);
		ASSERTERR (GetGlobalInfoProc!=NULL);

		SetGlobalInfoProc = (PSET_GLOBAL_INFO)			
						GetProcAddress (hDLL,
							 SET_GLOBAL_INFO_ENTRY_POINT_STRING);
		ASSERTERR (SetGlobalInfoProc!=NULL);

		AddInterfaceProc = (PADD_INTERFACE)			
						GetProcAddress (hDLL,
							 ADD_INTERFACE_ENTRY_POINT_STRING);
		ASSERTERR (AddInterfaceProc!=NULL);

		DeleteInterfaceProc = (PDELETE_INTERFACE)		
						GetProcAddress (hDLL,
							 DELETE_INTERFACE_ENTRY_POINT_STRING);
		ASSERTERR (DeleteInterfaceProc!=NULL);

		GetEventMessageProc = (PGET_EVENT_MESSAGE)		
						GetProcAddress (hDLL,
							 GET_EVENT_MESSAGE_ENTRY_POINT_STRING);
		ASSERTERR (GetEventMessageProc!=NULL);

		ActivateInterfaceProc = (PACTIVATE_INTERFACE)		
						GetProcAddress (hDLL,
							 ACTIVATE_INTERFACE_ENTRY_POINT_STRING);
		ASSERTERR (ActivateInterfaceProc!=NULL);

		DeactivateInterfaceProc = (PDEACTIVATE_INTERFACE)
						GetProcAddress (hDLL,
							 DEACTIVATE_INTERFACE_ENTRY_POINT_STRING);
		ASSERTERR (DeactivateInterfaceProc!=NULL);

		DoUpdateServicesProc = (PDO_UPDATE_SERVICES)		
						GetProcAddress (hDLL,
							 DO_UPDATE_SERVICES_ENTRY_POINT_STRING);
		ASSERTERR (DoUpdateServicesProc!=NULL);

		IsServiceProc = (PIS_SERVICE)		
						GetProcAddress (hDLL,
							IS_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (IsServiceProc!=NULL);

		CreateServiceEnumerationHandleProc = (PCREATE_SERVICE_ENUMERATION_HANDLE)		
						GetProcAddress (hDLL,
							CREATE_SERVICE_ENUMERATION_HANDLE_ENTRY_POINT_STRING);
		ASSERTERR (CreateServiceEnumerationHandleProc!=NULL);

		EnumerateGetNextServiceProc = (PENUMERATE_GET_NEXT_SERVICE)		
						GetProcAddress (hDLL,
							 ENUMERATE_GET_NEXT_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (EnumerateGetNextServiceProc!=NULL);

		CloseServiceEnumerationHandleProc = (PCLOSE_SERVICE_ENUMERATION_HANDLE)		
						GetProcAddress (hDLL,
							 CLOSE_SERVICE_ENUMERATION_HANDLE_ENTRY_POINT_STRING);
		ASSERTERR (CloseServiceEnumerationHandleProc!=NULL);

		CreateStaticServiceProc = (PCREATE_STATIC_SERVICE)		
						GetProcAddress (hDLL,
							 CREATE_STATIC_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (CreateStaticServiceProc!=NULL);

		DeleteStaticServiceProc = (PDELETE_STATIC_SERVICE)		
						GetProcAddress (hDLL,
							 DELETE_STATIC_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (DeleteStaticServiceProc!=NULL);

		BlockConvertServicesToStaticProc = (PBLOCK_CONVERT_SERVICES_TO_STATIC)		
						GetProcAddress (hDLL,
							 BLOCK_CONVERT_SERVICES_TO_STATIC_ENTRY_POINT_STRING);
		ASSERTERR (BlockConvertServicesToStaticProc!=NULL);

		BlockDeleteStaticServicesProc = (PBLOCK_DELETE_STATIC_SERVICES)		
						GetProcAddress (hDLL,
							 BLOCK_DELETE_STATIC_SERVICES_ENTRY_POINT_STRING);
		ASSERTERR (BlockDeleteStaticServicesProc!=NULL);

		GetFirstOrderedServiceProc = (PGET_FIRST_ORDERED_SERVICE)		
						GetProcAddress (hDLL,
							 GET_FIRST_ORDERED_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (GetFirstOrderedServiceProc!=NULL);

		GetNextOrderedServiceProc = (PGET_NEXT_ORDERED_SERVICE)		
						GetProcAddress (hDLL,
							 GET_NEXT_ORDERED_SERVICE_ENTRY_POINT_STRING);
		ASSERTERR (GetNextOrderedServiceProc!=NULL);


		NotificEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
		ASSERTERR (NotificEvent!=NULL);
		ConfigEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
		ASSERTERR (ConfigEvent!=NULL);

		SDBDlg = CreateDialog (hModule,
									MAKEINTRESOURCE (IDD_SDB_TEST),
									NULL,
									&SDBDlgProc);
		ASSERTERR (SDBDlg!=NULL);

		ConfigPort = IpxCreateAdapterConfigurationPort(
											ConfigEvent,
											&params);
		ASSERT (ConfigPort!=INVALID_HANDLE_VALUE);

		status = (*RegisterProtocolProc) (&ProtID, &Funct);
		ASSERTMSG ("Error registering SAP dll ", status == NO_ERROR);
		ASSERT (ProtID==IPX_PROTOCOL_SAP);
		ASSERT (Funct==(SERVICES|DEMAND_UPDATE_SERVICES));

		sapGlobalInfo.ServiceFiltersCount = 0;
		status = (*StartProtocolProc) (NotificEvent, &sapGlobalInfo);
		if (status==NO_ERROR) {
			EnterCriticalSection (&RouterLock);
			RouterStatus.dwCurrentState = SERVICE_RUNNING;
			LeaveCriticalSection (&RouterLock);
			SetServiceStatus (RouterHdl, &RouterStatus);

			msg.message = 0;
			while (msg.message!=WM_QUIT) {
				status = MsgWaitForMultipleObjects (2,
												WaitObjects,
												FALSE,
												INFINITE,
												QS_ALLINPUT);
				if (status==WAIT_OBJECT_0)
					ProcessAdapterEvents ();
				else if (status==WAIT_OBJECT_0+1) {
					ProcessUpdateEvents ();
					}
				else if (status==(WAIT_OBJECT_0+2)) {
					while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
						if (msg.message==WM_QUIT) {
							break;
							}
						else if (!IsWindow(SDBDlg)
							|| !IsDialogMessage(SDBDlg, &msg)) {
							TranslateMessage (&msg);
							DispatchMessage (&msg);
							}
						}
					}
				else
					DbgPrint ("wait returned status: %ld.", status);
				}
			}
		CloseHandle (ConfigEvent);
		CloseHandle (NotificEvent);

		RouterStatus.dwCurrentState = SERVICE_STOPPED;
		SetServiceStatus (RouterHdl, &RouterStatus);
		}
	}




VOID ServiceMain(
	DWORD		dwArgc, 
    LPTSTR		*lpszArgv  
	) {
	ServiceEntryProc = (PSVCS_SERVICE_DLL_ENTRY)
					GetProcAddress (hDLL, SVCS_ENTRY_POINT_STRING);
	ASSERTERR (ServiceEntryProc!=NULL);

	(*ServiceEntryProc) (dwArgc, lpszArgv, NULL, NULL);
	}



VOID
ProcessAdapterEvents (
	VOID
	) {
	ULONG						cfgStatus;
	ADAPTER_INFO				params;
	ULONG						idx;
	SAP_IF_INFO					info;
	IPX_ADAPTER_BINDING_INFO	adapter;

	while (IpxGetQueuedAdapterConfigurationStatus (
									ConfigPort,
									&idx,
									&cfgStatus,
									&params)==NO_ERROR) {
		switch (cfgStatus) {
			case ADAPTER_CREATED:
			case ADAPTER_UP:
				DbgPrint ("\nNew Adapter : %d.\n", idx);
				info.AdminState = ADMIN_STATE_ENABLED;
				info.PacketType = IPX_STANDARD_PACKET_TYPE;
				if (params.NdisMedium!=NdisMediumWan) {
					params.InterfaceIndex = idx;
					info.UpdateMode = IPX_STANDARD_UPDATE;
					info.Supply = TRUE;
					info.Listen = TRUE;
					info.GetNearestServerReply = TRUE;
					memset (adapter.RemoteNode, 0xFF, sizeof (adapter.RemoteNode));
					}
				else {
					info.UpdateMode = IPX_AUTO_STATIC_UPDATE;
					info.Supply = FALSE;
					info.Listen = FALSE;
					info.GetNearestServerReply = TRUE;
					IpxNodeCpy (adapter.RemoteNode, params.RemoteNode);
					}
				info.EnableGlobalFiltering = FALSE;

				adapter.AdapterIndex = idx;
				IpxNetCpy (adapter.Network, params.Network);
				IpxNodeCpy (adapter.LocalNode, params.LocalNode);
				adapter.MaxPacketSize = params.MaxPacketSize;
				DbgPrint ("Creating interface: %d.\n", idx);
				if ((*AddInterfaceProc) (params.InterfaceIndex,
												 &info)==NO_ERROR) {
					DbgPrint ("Binding interface: %d.\n", idx);
					(*ActivateInterfaceProc) (params.InterfaceIndex,
												 &adapter);
					if (info.UpdateMode==IPX_AUTO_STATIC_UPDATE) {
						DbgPrint ("Updating interface: %d.", 
							 params.InterfaceIndex);
						(*DoUpdateServicesProc)
									 (params.InterfaceIndex);
						}
					}
				break;

			case ADAPTER_DOWN:
			case ADAPTER_DELETED:
				DbgPrint ("\nAdapter %d is gone - deleting interface.\n", idx);
				(*DeleteInterfaceProc) (idx);
				break;
			}
		}

	}

BOOL
ProcessUpdateEvents (
	VOID
	) {
	MESSAGE						result;
	ROUTING_PROTOCOL_EVENTS		event;
	TCHAR						buf[128];

	while ((*GetEventMessageProc) (&event, &result)==NO_ERROR) {
		switch (event) {
			case ROUTER_STOPPED:
				DestroyWindow (SDBDlg);
				SDBDlg = NULL;
				EnterCriticalSection (&RouterLock);
				RouterStatus.dwCurrentState = SERVICE_STOPPED;
				LeaveCriticalSection (&RouterLock);
				return TRUE;
			case UPDATE_COMPLETE:
				_stprintf (buf, TEXT ("Update completed on interface: %d")
						TEXT(" with status: %d."),
						result.UpdateCompleteMessage.InterfaceIndex,
						result.UpdateCompleteMessage.UpdateStatus);
				MessageBox (SDBDlg,
					buf,
					TEXT (GET_EVENT_MESSAGE_ENTRY_POINT_STRING),
					MB_OK|MB_ICONINFORMATION);
				break;
			default:
				_stprintf (buf, TEXT ("Unknown event reported %ld."), event);
				MessageBox (SDBDlg,
					buf,
					TEXT (GET_EVENT_MESSAGE_ENTRY_POINT_STRING),
					MB_OK|MB_ICONEXCLAMATION);
				break;
			
			}
		}
	return FALSE;
	}

								
VOID
PrintServiceToLB (
	HWND			hLB,
	INT				idx,
	PIPX_SERVICE	Service
	);

VOID
ReadServiceFromLB (
	HWND			hLB,
	INT				idx,
	PIPX_SERVICE	Service
	);

VOID
ReadEnumerationParameters (
	HWND			hDlg,
	DWORD			*Order,
	DWORD			*Flags,
	PIPX_SERVICE	Service
	);

VOID
ReadServiceParameters (
	HWND			hDlg,
	PIPX_SERVICE	Service
	);

BOOL CALLBACK
SDBDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL			res = FALSE;
	IPX_SERVICE		Service;
	INT				idx,i;
	HANDLE			enumHdl;
	DWORD			status;
	TCHAR			buf[64];
	DWORD			Order, Flags;
	RECT			rect;
						
	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
				// Get window a chance to report its MINMAXINFO
			GetWindowRect (hDlg, &rect);
			MoveWindow (hDlg, rect.left, rect.top, rect.right, rect.bottom, FALSE);
			EnableWindow (GetDlgItem (hDlg, IDB_ADD), FALSE);
			EnableWindow (GetDlgItem (hDlg, IDB_DELETE), FALSE);
			EnableWindow (GetDlgItem (hDlg, IDB_SET_FILTERS), FALSE);
			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					res = TRUE;
					break;
				case IDC_INTERFACE:
					EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					EnableWindow (GetDlgItem (hDlg, IDB_BLOCK_CONVERT),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					EnableWindow (GetDlgItem (hDlg, IDB_BLOCK_DELETE),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					res = TRUE;
					break;
				case IDC_PROTOCOL:
					EnableWindow (GetDlgItem (hDlg, IDE_PROTOCOL_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					res = TRUE;
					break;
				case IDC_TYPE:
					EnableWindow (GetDlgItem (hDlg, IDE_TYPE_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					res = TRUE;
					break;
				case IDC_NAME:
					EnableWindow (GetDlgItem (hDlg, IDE_NAME_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					res = TRUE;
					break;
				case IDB_HANDLE_ENUM:
					EnableWindow (GetDlgItem (hDlg, IDB_ADD), FALSE);
					EnableWindow (GetDlgItem (hDlg, IDB_DELETE), FALSE);
					EnableWindow (GetDlgItem (hDlg, IDB_SET_FILTERS), FALSE);
					SendDlgItemMessage (hDlg, IDLB_SERVICES, LB_RESETCONTENT, 0, 0);
					ReadEnumerationParameters (hDlg, &Order, &Flags, &Service);
					enumHdl = (*CreateServiceEnumerationHandleProc) (Flags,
																	&Service);
					if (enumHdl!=NULL) {
						while ((status=(*EnumerateGetNextServiceProc) (
												enumHdl, &Service))==NO_ERROR) {
							
							PrintServiceToLB (GetDlgItem (hDlg, IDLB_SERVICES), -1, &Service);
							}

						if (status!=IPX_ERROR_NO_MORE_ITEMS) {
							_stprintf (buf, TEXT("Error: %ld."), status);
							MessageBox (hDlg, buf,
							 TEXT(ENUMERATE_GET_NEXT_SERVICE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);

							}

						status = (*CloseServiceEnumerationHandleProc) (enumHdl);
						if (status!=NO_ERROR) {
							_stprintf (buf, TEXT("Error: %ld."), status);
							MessageBox (hDlg, buf,
							 TEXT(CLOSE_SERVICE_ENUMERATION_HANDLE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);

							}
						}
					else {
						_stprintf (buf, TEXT("Error: %ld."), GetLastError ());
						MessageBox (hDlg, buf,
							 TEXT(CREATE_SERVICE_ENUMERATION_HANDLE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);

						}
					res = TRUE;
					break;
				case IDB_MIB_ENUM:
					EnableWindow (GetDlgItem (hDlg, IDB_ADD), FALSE);
					EnableWindow (GetDlgItem (hDlg, IDB_DELETE), FALSE);
					EnableWindow (GetDlgItem (hDlg, IDB_SET_FILTERS), FALSE);
					SendDlgItemMessage (hDlg, IDLB_SERVICES, LB_RESETCONTENT, 0, 0);
					ReadEnumerationParameters (hDlg, &Order, &Flags, &Service);
					status = (*GetFirstOrderedServiceProc) (Order, Flags,
															 &Service);
					while (status==NO_ERROR) {
						PrintServiceToLB (GetDlgItem (hDlg, IDLB_SERVICES), -1, &Service);
						status = (*GetNextOrderedServiceProc) (Order, Flags,
															 &Service);
						}

					if (status!=IPX_ERROR_NO_MORE_ITEMS) {
						_stprintf (buf, TEXT("Error: %ld."), status);
						MessageBox (hDlg, buf,
								 TEXT(GET_NEXT_ORDERED_SERVICE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;
				case IDB_BLOCK_DELETE:
					ReadEnumerationParameters (hDlg, &Order, &Flags, &Service);
					status = (*BlockDeleteStaticServicesProc) (
											Service.InterfaceIndex);

					if (status!=NO_ERROR) {
						_stprintf (buf, TEXT("Error: %ld."), status);
						MessageBox (hDlg, buf,
							TEXT(BLOCK_DELETE_STATIC_SERVICES_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;
				case IDB_BLOCK_CONVERT:
					ReadEnumerationParameters (hDlg, &Order, &Flags, &Service);
					status = (*BlockConvertServicesToStaticProc) (
											Service.InterfaceIndex);

					if (status!=NO_ERROR) {
						_stprintf (buf, TEXT("Error: %ld."), status);
						MessageBox (hDlg, buf,
						 TEXT(BLOCK_CONVERT_SERVICES_TO_STATIC_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;
				case IDB_ADD:
					ReadServiceFromLB (GetDlgItem (hDlg, IDLB_SERVICES), idx, &Service);
					status = (*CreateStaticServiceProc) (
											Service.InterfaceIndex,
											&Service.Server);

					if (status!=NO_ERROR) {
						_stprintf (buf, TEXT("Error: %ld."), status);
						MessageBox (hDlg, buf,
								TEXT(CREATE_STATIC_SERVICE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;
					
				case IDB_DELETE:
					ReadServiceFromLB (GetDlgItem (hDlg, IDLB_SERVICES), idx, &Service);
					status = (*DeleteStaticServiceProc) (
											Service.InterfaceIndex,
											&Service.Server);

					if (status!=NO_ERROR) {
						_stprintf (buf, TEXT("Error: %ld."), status);
						MessageBox (hDlg, buf,
								TEXT(DELETE_STATIC_SERVICE_ENTRY_POINT_STRING),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;

				case IDB_SET_FILTERS:
					idx = SendMessage (GetDlgItem (hDlg, IDLB_SERVICES),
														 LB_GETSELCOUNT, 0, 0);
					if (idx>0) {
						LPINT			items;
						PSAP_GLOBAL_INFO sapGlobalInfo =
							 (PSAP_GLOBAL_INFO)GlobalAlloc (GMEM_FIXED,
								FIELD_OFFSET (SAP_GLOBAL_INFO,SapServiceFilter)+
								sizeof (SAP_SERVICE_FILTER_INFO)*idx);
						if (sapGlobalInfo!=NULL) {
							items = (LPINT)sapGlobalInfo;
							idx = SendMessage (GetDlgItem (hDlg, IDLB_SERVICES),
									LB_GETSELITEMS, (WPARAM)idx, (LPARAM)items);
							if (idx!=LB_ERR) {
								for (i=idx-1; i>=0; i--)
									sapGlobalInfo->SapServiceFilter[i].FilterIndex
													= items[i];
								for (i=0; i<idx; i++) {
									ReadServiceFromLB (
										GetDlgItem (hDlg, IDLB_SERVICES),
										sapGlobalInfo->SapServiceFilter[i].FilterIndex,
										&Service);
									sapGlobalInfo->SapServiceFilter[i].ServiceType
													=Service.Server.Type;
									IpxNameCpy (
										sapGlobalInfo->SapServiceFilter[i].ServiceName,
										Service.Server.Name);
									}
								sapGlobalInfo->ServiceFiltersCount = idx;
								sapGlobalInfo->ServiceFiltersAction = 
									IsDlgButtonChecked (hDlg, IDC_ADVERTISE)
										? IPX_SERVICE_FILTER_ADVERTISE
										: IPX_SERVICE_FILTER_SUPRESS;
								status = (*SetGlobalInfoProc) (sapGlobalInfo);
								if (status!=NO_ERROR) {
									_stprintf (buf, TEXT("Error: %ld."), status);
									MessageBox (hDlg, buf,
											TEXT(SET_GLOBAL_INFO_ENTRY_POINT_STRING),
											 MB_OK|MB_ICONEXCLAMATION);
									}
								}
							else {
								MessageBox (hDlg, TEXT("LB_ERR!") ,
										TEXT("LB_GETSELITEMS"),
										 MB_OK|MB_ICONEXCLAMATION);
								}
							}
						else {
							_stprintf (buf, TEXT("Error: %ld."), GetLastError ());
							MessageBox (hDlg, buf,
									TEXT("GlobalAlloc"),
									 MB_OK|MB_ICONEXCLAMATION);
							}
						GlobalFree (sapGlobalInfo);
						}
					else {
						MessageBox (hDlg, TEXT("No Items selected"),
								TEXT("LB_GETSELCOUNT"),
								 MB_OK|MB_ICONEXCLAMATION);
						}
					res = TRUE;
					break;
				case IDLB_SERVICES:
					switch (HIWORD(wParam)) {
						case LBN_DBLCLK:
							idx = SendMessage ((HWND)lParam, LB_GETCARETINDEX, 0, 0);
							if (idx!=LB_ERR) {
								ReadServiceFromLB ((HWND)lParam, idx, &Service);
								res = (*IsServiceProc) (Service.Server.Type,
												 Service.Server.Name,
												 &Service);
								if (res) {
									SendMessage ((HWND)lParam, LB_DELETESTRING, idx, 0);
									PrintServiceToLB ((HWND)lParam, idx, &Service); 
									}
								else {
									status = GetLastError ();
									if (status!=NO_ERROR) {
										_stprintf (buf, TEXT("Error: %ld."), status);
										MessageBox (hDlg, buf,
											TEXT(IS_SERVICE_ENTRY_POINT_STRING),
											MB_OK|MB_ICONEXCLAMATION);
										}
									}
								}
							break;
						case LBN_SELCHANGE:
							idx = SendMessage ((HWND)lParam, LB_GETSELCOUNT, 0, 0);
							EnableWindow (GetDlgItem (hDlg, IDB_ADD), idx==1);
							EnableWindow (GetDlgItem (hDlg, IDB_DELETE), idx==1);
							EnableWindow (GetDlgItem (hDlg, IDB_SET_FILTERS), idx>0);
							break;
						
						}
					res = TRUE;
					break;
				}
			break;
		case WM_SIZE:
			GetWindowRect (GetDlgItem (hDlg, IDLB_SERVICES), &rect);
			MapWindowPoints (HWND_DESKTOP, hDlg, (POINT *)&rect, 2);
			rect.bottom = HIWORD (lParam)-4;
			MoveWindow (GetDlgItem (hDlg, IDLB_SERVICES), rect.left, rect.top,
						rect.right-rect.left, rect.bottom-rect.top, TRUE);
			res = FALSE;
			break;
		case WM_GETMINMAXINFO:
			if (((PMINMAXINFO)lParam)->ptMinTrackSize.x
					!=((PMINMAXINFO)lParam)->ptMaxTrackSize.x) {
				GetWindowRect (hDlg, &rect);
				((PMINMAXINFO)lParam)->ptMinTrackSize.x = rect.right-rect.left;
				((PMINMAXINFO)lParam)->ptMinTrackSize.y = rect.bottom-rect.top;
				((PMINMAXINFO)lParam)->ptMaxTrackSize.x = rect.right-rect.left;
				}
			res = FALSE;
			break;
		case WM_DESTROY:
			PostQuitMessage (0);
			res = TRUE;
			break;
		}

	return res;
	}

VOID
PrintServiceToLB (
	HWND			hLB,
	INT				idx,
	PIPX_SERVICE	Service
	) {
	TCHAR	buf[128];

	_stprintf (buf,
			TEXT ("%3d ")
				TEXT ("%5X ")
				TEXT ("%02X%02X%02X%02X ")
				TEXT ("%02X%02X%02X%02X%02X%02X ")
				TEXT ("%02X%02X ")
				TEXT ("%2d ")
				TEXT ("%04X ")
				TEXT ("%-47hs"),
			Service->InterfaceIndex,
			Service->Protocol,
			Service->Server.Network[0],
				Service->Server.Network[1],
				Service->Server.Network[2],
				Service->Server.Network[3],
			Service->Server.Node[0],
				Service->Server.Node[1],
				Service->Server.Node[2],
				Service->Server.Node[3],
				Service->Server.Node[4],
				Service->Server.Node[5],
			Service->Server.Socket[0],
				Service->Server.Socket[1],
			Service->Server.HopCount,
			Service->Server.Type,
			Service->Server.Name);
	SendMessage (hLB, LB_INSERTSTRING, (WPARAM)idx, (LPARAM)buf);
	}

VOID
ReadServiceFromLB (
	HWND			hLB,
	INT				idx,
	PIPX_SERVICE	Service
	) {
	TCHAR	buf[128];
	
	SendMessage (hLB, LB_GETTEXT, (WPARAM)idx, (LPARAM)buf);
	_stscanf (buf,
			TEXT ("%3d ")
				TEXT ("%5X ")
				TEXT ("%2X%2X%2X%2X ")
				TEXT ("%2X%2X%2X%2X%2X%2X ")
				TEXT ("%2X%2X ")
				TEXT ("%2d ")
				TEXT ("%4X ")
				TEXT ("%47h[\001-\377]"),
			&Service->InterfaceIndex,
			&Service->Protocol,
			&Service->Server.Network[0],
				&Service->Server.Network[1],
				&Service->Server.Network[2],
				&Service->Server.Network[3],
			&Service->Server.Node[0],
				&Service->Server.Node[1],
				&Service->Server.Node[2],
				&Service->Server.Node[3],
				&Service->Server.Node[4],
				&Service->Server.Node[5],
			&Service->Server.Socket[0],
				&Service->Server.Socket[1],
			&Service->Server.HopCount,
			&Service->Server.Type,
			&Service->Server.Name);
	return;
	}

VOID
ReadEnumerationParameters (
	HWND			hDlg,
	DWORD			*Order,
	DWORD			*Flags,
	PIPX_SERVICE	Service
	) {
	TCHAR			buf[64];

	if (IsDlgButtonChecked (hDlg, IDR_TYPE_NAME))
		*Order = STM_ORDER_BY_TYPE_AND_NAME;
	else if (IsDlgButtonChecked (hDlg, IDR_INTERFACE))
		*Order = STM_ORDER_BY_INTERFACE_TYPE_NAME;
	else {
		SendDlgItemMessage (hDlg, IDR_TYPE_NAME, BM_SETCHECK, (WPARAM)1, 0);
		*Order = STM_ORDER_BY_TYPE_AND_NAME;
		}

	*Flags = 0;
	if (IsDlgButtonChecked (hDlg, IDC_INTERFACE)) {
		*Flags |= STM_ONLY_THIS_INTERFACE;
		GetDlgItemText (hDlg, IDE_INTERFACE_E, buf, sizeof(buf)/sizeof (TCHAR));
		_stscanf (buf, TEXT ("%d"), &Service->InterfaceIndex);
		}

	if (IsDlgButtonChecked (hDlg, IDC_PROTOCOL)) {
		*Flags |= STM_ONLY_THIS_PROTOCOL;
		GetDlgItemText (hDlg, IDE_PROTOCOL_E, buf, sizeof(buf)/sizeof (TCHAR));
		_stscanf (buf, TEXT ("%x"), &Service->Protocol);
		}

	if (IsDlgButtonChecked (hDlg, IDC_TYPE)) {
		*Flags |= STM_ONLY_THIS_TYPE;
		GetDlgItemText (hDlg, IDE_TYPE_E, buf, sizeof(buf)/sizeof (TCHAR));
		_stscanf (buf, TEXT ("%hx"), &Service->Server.Type);
		}

	if (IsDlgButtonChecked (hDlg, IDC_NAME)) {
		*Flags |= STM_ONLY_THIS_NAME;
		GetDlgItemText (hDlg, IDE_NAME_E, buf, sizeof(buf)/sizeof (TCHAR));
		_stscanf (buf, TEXT ("%47h[\001-\277]"), Service->Server.Name);
		}

	return;
	}

/*
VOID
ReadServiceParameters (
	HWND			hDlg,
	PIPX_SERVICE	Service
	) {
	TCHAR			buf[64];
	INT				n, i;
	TCHAR			*p;


	GetDlgItemText (hDlg, IDE_INTERFACE_M, buf, sizeof(buf)/sizeof (TCHAR));
	_stscanf (buf, TEXT ("%x"), &Service->InterfaceIndex);

	GetDlgItemText (hDlg, IDE_PROTOCOL_M, buf, sizeof(buf)/sizeof (TCHAR));
	_stscanf (buf, TEXT ("%x"), &Service->Protocol);

	GetDlgItemText (hDlg, IDE_TYPE_M, buf, sizeof(buf)/sizeof (TCHAR));
	_stscanf (buf, TEXT ("%hx"), &Service->Server.Type);

	GetDlgItemText (hDlg, IDE_NAME_M, buf, sizeof(buf)/sizeof (TCHAR));
	_stscanf (buf, TEXT ("%47h[\001-\277]"), Service->Server.Name);

	GetDlgItemText (hDlg, IDE_NETWORK_M, buf, sizeof(buf)/sizeof (TCHAR));
	for (i=0, p=buf, n=0; i<sizeof (Service->Server.Network); i++, p+=n) {
		INT val;
		if (_stscanf (p, TEXT("%2X%n"), &val, &n)==1) 
			Service->Server.Network[i] = (UCHAR)val;
		else
			Service->Server.Network[i] = 0;
		}

	GetDlgItemText (hDlg, IDE_NODE_M, buf, sizeof(buf)/sizeof (TCHAR));
	for (i=0, p=buf, n=0; i<sizeof (Service->Server.Node); i++, p+=n) {
		INT val;
		if (_stscanf (p, TEXT("%2X%n"), &val, &n)==1)
			Service->Server.Node[i] = (UCHAR)val;
		else
			Service->Server.Node[i] = 0;
		}

	GetDlgItemText (hDlg, IDE_SOCKET_M, buf, sizeof(buf)/sizeof (TCHAR));
	for (i=0, p=buf, n=0; i<sizeof (Service->Server.Socket); i++, p+=n) {
		INT val;
		if (_stscanf (p, TEXT("%2X%n"), &val, &n)==1)
			Service->Server.Socket[i] = (UCHAR)val;
		else
			Service->Server.Socket[i] = 0;
		}

	GetDlgItemText (hDlg, IDE_HOP_COUNT_M, buf, sizeof(buf)/sizeof (TCHAR));
	_stscanf (buf, TEXT ("%hd"), &Service->Server.HopCount);

	return;
	}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mripsape.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mripsape.h

Abstract:

    ms-ripsap mib entry indeces

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_MRIPSAPE_
#define _SNMP_MRIPSAPE_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#define mi_mripsapBase                      0
#define mi_mripsapBaseRipOperState          mi_mripsapBase+1
#define mi_mripsapBaseSapOperState          mi_mripsapBaseRipOperState+1
#define mi_mripsapInterface                 mi_mripsapBaseSapOperState+1
#define mi_mripIfTable                      mi_mripsapInterface+1
#define mi_mripIfEntry                      mi_mripIfTable+1
#define mi_mripIfIndex                      mi_mripIfEntry+1
#define mi_mripIfAdminState                 mi_mripIfIndex+1
#define mi_mripIfOperState                  mi_mripIfAdminState+1
#define mi_mripIfUpdateMode                 mi_mripIfOperState+1
#define mi_mripIfUpdateInterval             mi_mripIfUpdateMode+1
#define mi_mripIfAgeMultiplier              mi_mripIfUpdateInterval+1
#define mi_mripIfSupply                     mi_mripIfAgeMultiplier+1
#define mi_mripIfListen                     mi_mripIfSupply+1
#define mi_mripIfOutPackets                 mi_mripIfListen+1
#define mi_mripIfInPackets                  mi_mripIfOutPackets+1
#define mi_msapIfTable                      mi_mripIfInPackets+1
#define mi_msapIfEntry                      mi_msapIfTable+1
#define mi_msapIfIndex                      mi_msapIfEntry+1
#define mi_msapIfAdminState                 mi_msapIfIndex+1
#define mi_msapIfOperState                  mi_msapIfAdminState+1
#define mi_msapIfUpdateMode                 mi_msapIfOperState+1
#define mi_msapIfUpdateInterval             mi_msapIfUpdateMode+1
#define mi_msapIfAgeMultiplier              mi_msapIfUpdateInterval+1
#define mi_msapIfSupply                     mi_msapIfAgeMultiplier+1
#define mi_msapIfListen                     mi_msapIfSupply+1
#define mi_msapIfGetNearestServerReply      mi_msapIfListen+1
#define mi_msapIfOutPackets                 mi_msapIfGetNearestServerReply+1
#define mi_msapIfInPackets                  mi_msapIfOutPackets+1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_mripIfEntry                      10
#define ni_mripIfEntry                      1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_msapIfEntry                      11
#define ni_msapIfEntry                      1


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mipxf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mipxf.h

Abstract:

    Header for ms-ipx instrumentation callbacks and associated data structures
	

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_MIPXF_
#define _SNMP_MIPXF_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxBase group (1.3.6.1.4.1.311.1.8.1)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxBase(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxBase {
    AsnAny	mipxBaseOperState;
    AsnAny	mipxBasePrimaryNetNumber;
    AsnAny	mipxBaseNode;
    AsnAny	mipxBaseSysName;
    AsnAny	mipxBaseMaxPathSplits;               
    AsnAny	mipxBaseIfCount;
    AsnAny	mipxBaseDestCount;
    AsnAny	mipxBaseServCount;
	BYTE	PrimaryNetVal[4];
	BYTE	NodeVal[6];
	BYTE	SysNameVal[48];
} buf_mipxBase;

#define gf_mipxBaseOperState                get_mipxBase
#define gf_mipxBasePrimaryNetNumber         get_mipxBase
#define gf_mipxBaseNode                     get_mipxBase
#define gf_mipxBaseSysName                  get_mipxBase
#define gf_mipxBaseMaxPathSplits            get_mipxBase
#define gf_mipxBaseIfCount                  get_mipxBase
#define gf_mipxBaseDestCount                get_mipxBase
#define gf_mipxBaseServCount                get_mipxBase

#define gb_mipxBaseOperState                buf_mipxBase
#define gb_mipxBasePrimaryNetNumber         buf_mipxBase
#define gb_mipxBaseNode                     buf_mipxBase
#define gb_mipxBaseSysName                  buf_mipxBase
#define gb_mipxBaseMaxPathSplits            buf_mipxBase
#define gb_mipxBaseIfCount                  buf_mipxBase
#define gb_mipxBaseDestCount                buf_mipxBase
#define gb_mipxBaseServCount                buf_mipxBase

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxInterface group (1.3.6.1.4.1.311.1.8.2)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxIfEntry table (1.3.6.1.4.1.311.1.8.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxIfEntry {
    AsnAny	mipxIfIndex;          
    AsnAny	mipxIfAdminState;     
    AsnAny	mipxIfOperState;      
    AsnAny	mipxIfAdapterIndex;   
    AsnAny	mipxIfName;           
    AsnAny	mipxIfType;           
    AsnAny	mipxIfLocalMaxPacketSize;
    AsnAny	mipxIfMediaType;      
    AsnAny	mipxIfNetNumber;      
    AsnAny	mipxIfMacAddress;     
    AsnAny	mipxIfDelay;          
    AsnAny	mipxIfThroughput;     
    AsnAny	mipxIfIpxWanEnable;  
    AsnAny	mipxIfNetbiosAccept;  
    AsnAny	mipxIfNetbiosDeliver; 
    AsnAny	mipxIfInHdrErrors;    
    AsnAny	mipxIfInFilterDrops;  
    AsnAny	mipxIfInNoRoutes;     
    AsnAny	mipxIfInDiscards;     
    AsnAny	mipxIfInDelivers;     
    AsnAny	mipxIfOutFilterDrops; 
    AsnAny	mipxIfOutDiscards;    
    AsnAny	mipxIfOutDelivers;    
    AsnAny	mipxIfInNetbiosPackets;
    AsnAny	mipxIfOutNetbiosPackets;
	BYTE	NameVal[48];
	BYTE	NetNumberVal[4];
	BYTE	MacAddressVal[6];
} buf_mipxIfEntry;

#define gf_mipxIfIndex                      get_mipxIfEntry
#define gf_mipxIfAdminState                 get_mipxIfEntry
#define gf_mipxIfOperState                  get_mipxIfEntry
#define gf_mipxIfAdapterIndex               get_mipxIfEntry
#define gf_mipxIfName                       get_mipxIfEntry
#define gf_mipxIfType                       get_mipxIfEntry
#define gf_mipxIfLocalMaxPacketSize         get_mipxIfEntry
#define gf_mipxIfMediaType                  get_mipxIfEntry
#define gf_mipxIfNetNumber                  get_mipxIfEntry
#define gf_mipxIfMacAddress                 get_mipxIfEntry
#define gf_mipxIfDelay                      get_mipxIfEntry
#define gf_mipxIfThroughput                 get_mipxIfEntry
#define gf_mipxIfIpxWanEnable               get_mipxIfEntry
#define gf_mipxIfNetbiosAccept              get_mipxIfEntry
#define gf_mipxIfNetbiosDeliver             get_mipxIfEntry
#define gf_mipxIfInHdrErrors                get_mipxIfEntry
#define gf_mipxIfInFilterDrops              get_mipxIfEntry
#define gf_mipxIfInNoRoutes                 get_mipxIfEntry
#define gf_mipxIfInDiscards                 get_mipxIfEntry
#define gf_mipxIfInDelivers                 get_mipxIfEntry
#define gf_mipxIfOutFilterDrops             get_mipxIfEntry
#define gf_mipxIfOutDiscards                get_mipxIfEntry
#define gf_mipxIfOutDelivers                get_mipxIfEntry
#define gf_mipxIfInNetbiosPackets           get_mipxIfEntry
#define gf_mipxIfOutNetbiosPackets          get_mipxIfEntry
                                            
#define gb_mipxIfIndex                      buf_mipxIfEntry
#define gb_mipxIfAdminState                 buf_mipxIfEntry
#define gb_mipxIfOperState                  buf_mipxIfEntry
#define gb_mipxIfAdapterIndex               buf_mipxIfEntry
#define gb_mipxIfName                       buf_mipxIfEntry
#define gb_mipxIfType                       buf_mipxIfEntry
#define gb_mipxIfLocalMaxPacketSize         buf_mipxIfEntry
#define gb_mipxIfMediaType                  buf_mipxIfEntry
#define gb_mipxIfNetNumber                  buf_mipxIfEntry
#define gb_mipxIfMacAddress                 buf_mipxIfEntry
#define gb_mipxIfDelay                      buf_mipxIfEntry
#define gb_mipxIfThroughput                 buf_mipxIfEntry
#define gb_mipxIfIpxWanEnable               buf_mipxIfEntry
#define gb_mipxIfNetbiosAccept              buf_mipxIfEntry
#define gb_mipxIfNetbiosDeliver             buf_mipxIfEntry
#define gb_mipxIfInHdrErrors                buf_mipxIfEntry
#define gb_mipxIfInFilterDrops              buf_mipxIfEntry
#define gb_mipxIfInNoRoutes                 buf_mipxIfEntry
#define gb_mipxIfInDiscards                 buf_mipxIfEntry
#define gb_mipxIfInDelivers                 buf_mipxIfEntry
#define gb_mipxIfOutFilterDrops             buf_mipxIfEntry
#define gb_mipxIfOutDiscards                buf_mipxIfEntry
#define gb_mipxIfOutDelivers                buf_mipxIfEntry
#define gb_mipxIfInNetbiosPackets           buf_mipxIfEntry
#define gb_mipxIfOutNetbiosPackets          buf_mipxIfEntry

UINT
set_mipxIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_mipxIfEntry {
    AsnAny	mipxIfIndex;          
    AsnAny	mipxIfAdminState;     
    AsnAny	mipxIfNetNumber;      
    AsnAny	mipxIfMacAddress;     
    AsnAny	mipxIfIpxWanEnable;  
    AsnAny	mipxIfNetbiosAccept;  
    AsnAny	mipxIfNetbiosDeliver; 
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
} sav_mipxIfEntry;

#define sf_mipxIfIndex                      set_mipxIfEntry
#define sf_mipxIfAdminState                 set_mipxIfEntry
#define sf_mipxIfNetNumber                  set_mipxIfEntry
#define sf_mipxIfMacAddress                 set_mipxIfEntry
#define sf_mipxIfIpxWanEnable               set_mipxIfEntry
#define sf_mipxIfNetbiosAccept              set_mipxIfEntry
#define sf_mipxIfNetbiosDeliver             set_mipxIfEntry

#define sb_mipxIfIndex                      sav_mipxIfEntry
#define sb_mipxIfAdminState                 sav_mipxIfEntry
#define sb_mipxIfNetNumber                  sav_mipxIfEntry
#define sb_mipxIfMacAddress                 sav_mipxIfEntry
#define sb_mipxIfIpxWanEnable               sav_mipxIfEntry
#define sb_mipxIfNetbiosAccept              sav_mipxIfEntry
#define sb_mipxIfNetbiosDeliver             sav_mipxIfEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxForwarding group (1.3.6.1.4.1.311.1.8.3)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxDestEntry table (1.3.6.1.4.1.311.1.8.3.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxDestEntry {
    AsnAny	mipxDestNetNum;         
    AsnAny	mipxDestProtocol;       
    AsnAny	mipxDestTicks;          
    AsnAny	mipxDestHopCount;       
    AsnAny	mipxDestNextHopIfIndex; 
    AsnAny	mipxDestNextHopMacAddress;
    AsnAny	mipxDestFlags;
	BYTE	NetNumVal[4];
	BYTE	NextHopMacAddressVal[6];
} buf_mipxDestEntry;

#define gf_mipxDestNetNum                   get_mipxDestEntry
#define gf_mipxDestProtocol                 get_mipxDestEntry
#define gf_mipxDestTicks                    get_mipxDestEntry
#define gf_mipxDestHopCount                 get_mipxDestEntry
#define gf_mipxDestNextHopIfIndex           get_mipxDestEntry
#define gf_mipxDestNextHopMacAddress        get_mipxDestEntry
#define gf_mipxDestFlags                    get_mipxDestEntry

#define gb_mipxDestNetNum                   buf_mipxDestEntry
#define gb_mipxDestProtocol                 buf_mipxDestEntry
#define gb_mipxDestTicks                    buf_mipxDestEntry
#define gb_mipxDestHopCount                 buf_mipxDestEntry
#define gb_mipxDestNextHopIfIndex           buf_mipxDestEntry
#define gb_mipxDestNextHopMacAddress        buf_mipxDestEntry
#define gb_mipxDestFlags                    buf_mipxDestEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticRouteEntry table (1.3.6.1.4.1.311.1.8.3.2.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxStaticRouteEntry {
    AsnAny	mipxStaticRouteIfIndex;        
    AsnAny	mipxStaticRouteNetNum;         
    AsnAny	mipxStaticRouteEntryStatus;    
    AsnAny	mipxStaticRouteTicks;          
    AsnAny	mipxStaticRouteHopCount;       
    AsnAny	mipxStaticRouteNextHopMacAddress;
	BYTE	NetNumVal[4];
	BYTE	NextHopMacAddressVal[6];
} buf_mipxStaticRouteEntry;

#define gf_mipxStaticRouteIfIndex           get_mipxStaticRouteEntry
#define gf_mipxStaticRouteNetNum            get_mipxStaticRouteEntry
#define gf_mipxStaticRouteEntryStatus       get_mipxStaticRouteEntry
#define gf_mipxStaticRouteTicks             get_mipxStaticRouteEntry
#define gf_mipxStaticRouteHopCount          get_mipxStaticRouteEntry
#define gf_mipxStaticRouteNextHopMacAddress get_mipxStaticRouteEntry

#define gb_mipxStaticRouteIfIndex           buf_mipxStaticRouteEntry
#define gb_mipxStaticRouteNetNum            buf_mipxStaticRouteEntry
#define gb_mipxStaticRouteEntryStatus       buf_mipxStaticRouteEntry
#define gb_mipxStaticRouteTicks             buf_mipxStaticRouteEntry
#define gb_mipxStaticRouteHopCount          buf_mipxStaticRouteEntry
#define gb_mipxStaticRouteNextHopMacAddress buf_mipxStaticRouteEntry

UINT
set_mipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_mipxStaticRouteEntry {
    AsnAny	mipxStaticRouteIfIndex;        
    AsnAny	mipxStaticRouteNetNum;         
    AsnAny	mipxStaticRouteEntryStatus;    
    AsnAny	mipxStaticRouteTicks;          
    AsnAny	mipxStaticRouteHopCount;       
    AsnAny	mipxStaticRouteNextHopMacAddress;
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN ActionFlag;
} sav_mipxStaticRouteEntry;

#define sf_mipxStaticRouteIfIndex           set_mipxStaticRouteEntry
#define sf_mipxStaticRouteNetNum            set_mipxStaticRouteEntry
#define sf_mipxStaticRouteEntryStatus       set_mipxStaticRouteEntry
#define sf_mipxStaticRouteTicks             set_mipxStaticRouteEntry
#define sf_mipxStaticRouteHopCount          set_mipxStaticRouteEntry
#define sf_mipxStaticRouteNextHopMacAddress set_mipxStaticRouteEntry
        
#define sb_mipxStaticRouteIfIndex           sav_mipxStaticRouteEntry
#define sb_mipxStaticRouteNetNum            sav_mipxStaticRouteEntry
#define sb_mipxStaticRouteEntryStatus       sav_mipxStaticRouteEntry
#define sb_mipxStaticRouteTicks             sav_mipxStaticRouteEntry
#define sb_mipxStaticRouteHopCount          sav_mipxStaticRouteEntry
#define sb_mipxStaticRouteNextHopMacAddress sav_mipxStaticRouteEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServices group (1.3.6.1.4.1.311.1.8.4)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServEntry table (1.3.6.1.4.1.311.1.8.4.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxServEntry {
    AsnAny	mipxServType;  
    AsnAny	mipxServName;  
    AsnAny	mipxServProtocol;
    AsnAny	mipxServNetNum;
    AsnAny	mipxServNode;  
    AsnAny	mipxServSocket;
    AsnAny	mipxServHopCount;
	BYTE	TypeVal[2];
	BYTE	NameVal[48];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_mipxServEntry;

#define gf_mipxServType                     get_mipxServEntry
#define gf_mipxServName                     get_mipxServEntry
#define gf_mipxServProtocol                 get_mipxServEntry
#define gf_mipxServNetNum                   get_mipxServEntry
#define gf_mipxServNode                     get_mipxServEntry
#define gf_mipxServSocket                   get_mipxServEntry
#define gf_mipxServHopCount                 get_mipxServEntry

#define gb_mipxServType                     buf_mipxServEntry
#define gb_mipxServName                     buf_mipxServEntry
#define gb_mipxServProtocol                 buf_mipxServEntry
#define gb_mipxServNetNum                   buf_mipxServEntry
#define gb_mipxServNode                     buf_mipxServEntry
#define gb_mipxServSocket                   buf_mipxServEntry
#define gb_mipxServHopCount                 buf_mipxServEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticServEntry table (1.3.6.1.4.1.311.1.8.4.2.1)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mipxStaticServEntry {
    AsnAny	mipxStaticServIfIndex;  
    AsnAny	mipxStaticServType;     
    AsnAny	mipxStaticServName;     
    AsnAny	mipxStaticServEntryStatus;
    AsnAny	mipxStaticServNetNum;   
    AsnAny	mipxStaticServNode;     
    AsnAny	mipxStaticServSocket;   
    AsnAny	mipxStaticServHopCount; 
	BYTE	TypeVal[2];
	BYTE	NameVal[48];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_mipxStaticServEntry;

#define gf_mipxStaticServIfIndex            get_mipxStaticServEntry
#define gf_mipxStaticServType               get_mipxStaticServEntry
#define gf_mipxStaticServName               get_mipxStaticServEntry
#define gf_mipxStaticServEntryStatus        get_mipxStaticServEntry
#define gf_mipxStaticServNetNum             get_mipxStaticServEntry
#define gf_mipxStaticServNode               get_mipxStaticServEntry
#define gf_mipxStaticServSocket             get_mipxStaticServEntry
#define gf_mipxStaticServHopCount           get_mipxStaticServEntry

#define gb_mipxStaticServIfIndex            buf_mipxStaticServEntry
#define gb_mipxStaticServType               buf_mipxStaticServEntry
#define gb_mipxStaticServName               buf_mipxStaticServEntry
#define gb_mipxStaticServEntryStatus        buf_mipxStaticServEntry
#define gb_mipxStaticServNetNum             buf_mipxStaticServEntry
#define gb_mipxStaticServNode               buf_mipxStaticServEntry
#define gb_mipxStaticServSocket             buf_mipxStaticServEntry
#define gb_mipxStaticServHopCount           buf_mipxStaticServEntry

UINT
set_mipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_mipxStaticServEntry {
    AsnAny	mipxStaticServIfIndex;  
    AsnAny	mipxStaticServType;     
    AsnAny	mipxStaticServName;     
    AsnAny	mipxStaticServEntryStatus;
    AsnAny	mipxStaticServNetNum;   
    AsnAny	mipxStaticServNode;     
    AsnAny	mipxStaticServSocket;   
    AsnAny	mipxStaticServHopCount; 
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN ActionFlag;
} sav_mipxStaticServEntry;

#define sf_mipxStaticServIfIndex            set_mipxStaticServEntry
#define sf_mipxStaticServType               set_mipxStaticServEntry
#define sf_mipxStaticServName               set_mipxStaticServEntry
#define sf_mipxStaticServEntryStatus        set_mipxStaticServEntry
#define sf_mipxStaticServNetNum             set_mipxStaticServEntry
#define sf_mipxStaticServNode               set_mipxStaticServEntry
#define sf_mipxStaticServSocket             set_mipxStaticServEntry
#define sf_mipxStaticServHopCount           set_mipxStaticServEntry

#define sb_mipxStaticServIfIndex            sav_mipxStaticServEntry
#define sb_mipxStaticServType               sav_mipxStaticServEntry
#define sb_mipxStaticServName               sav_mipxStaticServEntry
#define sb_mipxStaticServEntryStatus        sav_mipxStaticServEntry
#define sb_mipxStaticServNetNum             sav_mipxStaticServEntry
#define sb_mipxStaticServNode               sav_mipxStaticServEntry
#define sb_mipxStaticServSocket             sav_mipxStaticServEntry
#define sb_mipxStaticServHopCount           sav_mipxStaticServEntry

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mripsapf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mripsapf.h

Abstract:

    Header for ms-ripsap instrumentation callbacks and associated data structures
	

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_MRIPSAPF_
#define _SNMP_MRIPSAPF_


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapBase group (1.3.6.1.4.1.311.1.9.1)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripsapBase(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mripsapBase {
    AsnAny	mripsapBaseRipOperState;
    AsnAny	mripsapBaseSapOperState;
} buf_mripsapBase;

#define gf_mripsapBaseRipOperState          get_mripsapBase
#define gf_mripsapBaseSapOperState          get_mripsapBase

#define gb_mripsapBaseRipOperState          buf_mripsapBase
#define gb_mripsapBaseSapOperState          buf_mripsapBase


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapInterface group (1.3.6.1.4.1.311.1.9.2)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_mripIfEntry {
    AsnAny	mripIfIndex;
    AsnAny	mripIfAdminState;
    AsnAny	mripIfOperState;
    AsnAny	mripIfUpdateMode;
    AsnAny	mripIfUpdateInterval;
    AsnAny	mripIfAgeMultiplier;
    AsnAny	mripIfSupply;
    AsnAny	mripIfListen;
    AsnAny	mripIfOutPackets;
    AsnAny	mripIfInPackets;
} buf_mripIfEntry;

#define gf_mripIfIndex                      get_mripIfEntry
#define gf_mripIfAdminState                 get_mripIfEntry
#define gf_mripIfOperState                  get_mripIfEntry
#define gf_mripIfUpdateMode                 get_mripIfEntry
#define gf_mripIfUpdateInterval             get_mripIfEntry
#define gf_mripIfAgeMultiplier              get_mripIfEntry
#define gf_mripIfSupply                     get_mripIfEntry
#define gf_mripIfListen                     get_mripIfEntry
#define gf_mripIfOutPackets                 get_mripIfEntry
#define gf_mripIfInPackets                  get_mripIfEntry

#define gb_mripIfIndex                      buf_mripIfEntry
#define gb_mripIfAdminState                 buf_mripIfEntry
#define gb_mripIfOperState                  buf_mripIfEntry
#define gb_mripIfUpdateMode                 buf_mripIfEntry
#define gb_mripIfUpdateInterval             buf_mripIfEntry
#define gb_mripIfAgeMultiplier              buf_mripIfEntry
#define gb_mripIfSupply                     buf_mripIfEntry
#define gb_mripIfListen                     buf_mripIfEntry
#define gb_mripIfOutPackets                 buf_mripIfEntry
#define gb_mripIfInPackets                  buf_mripIfEntry

UINT
set_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_mripIfEntry {
    AsnAny	mripIfIndex;
    AsnAny	mripIfAdminState;
    AsnAny	mripIfUpdateMode;
    AsnAny	mripIfUpdateInterval;
    AsnAny	mripIfAgeMultiplier;
    AsnAny	mripIfSupply;
    AsnAny	mripIfListen;
	RIP_MIB_SET_INPUT_DATA	MibSetInputData;
} sav_mripIfEntry;

#define sf_mripIfIndex                      set_mripIfEntry
#define sf_mripIfAdminState                 set_mripIfEntry
#define sf_mripIfUpdateMode                 set_mripIfEntry
#define sf_mripIfUpdateInterval             set_mripIfEntry
#define sf_mripIfAgeMultiplier              set_mripIfEntry
#define sf_mripIfSupply                     set_mripIfEntry
#define sf_mripIfListen                     set_mripIfEntry

#define sb_mripIfIndex                      sav_mripIfEntry
#define sb_mripIfAdminState                 sav_mripIfEntry
#define sb_mripIfUpdateMode                 sav_mripIfEntry
#define sb_mripIfUpdateInterval             sav_mripIfEntry
#define sb_mripIfAgeMultiplier              sav_mripIfEntry
#define sb_mripIfSupply                     sav_mripIfEntry
#define sb_mripIfListen                     sav_mripIfEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_msapIfEntry {
    AsnAny	msapIfIndex;
    AsnAny	msapIfAdminState;
    AsnAny	msapIfOperState;
    AsnAny	msapIfUpdateMode;
    AsnAny	msapIfUpdateInterval;
    AsnAny	msapIfAgeMultiplier;
    AsnAny	msapIfSupply;
    AsnAny	msapIfListen;
    AsnAny	msapIfGetNearestServerReply;
    AsnAny	msapIfOutPackets;
    AsnAny	msapIfInPackets;
} buf_msapIfEntry;

#define gf_msapIfIndex                      get_msapIfEntry
#define gf_msapIfAdminState                 get_msapIfEntry
#define gf_msapIfOperState                  get_msapIfEntry
#define gf_msapIfUpdateMode                 get_msapIfEntry
#define gf_msapIfUpdateInterval             get_msapIfEntry
#define gf_msapIfAgeMultiplier              get_msapIfEntry
#define gf_msapIfSupply                     get_msapIfEntry
#define gf_msapIfListen                     get_msapIfEntry
#define gf_msapIfGetNearestServerReply      get_msapIfEntry
#define gf_msapIfOutPackets                 get_msapIfEntry
#define gf_msapIfInPackets                  get_msapIfEntry

#define gb_msapIfIndex                      buf_msapIfEntry
#define gb_msapIfAdminState                 buf_msapIfEntry
#define gb_msapIfOperState                  buf_msapIfEntry
#define gb_msapIfUpdateMode                 buf_msapIfEntry
#define gb_msapIfUpdateInterval             buf_msapIfEntry
#define gb_msapIfAgeMultiplier              buf_msapIfEntry
#define gb_msapIfSupply                     buf_msapIfEntry
#define gb_msapIfListen                     buf_msapIfEntry
#define gb_msapIfGetNearestServerReply      buf_msapIfEntry
#define gb_msapIfOutPackets                 buf_msapIfEntry
#define gb_msapIfInPackets                  buf_msapIfEntry

UINT
set_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_msapIfEntry {
    AsnAny	msapIfIndex;
    AsnAny	msapIfAdminState;
    AsnAny	msapIfUpdateMode;
    AsnAny	msapIfUpdateInterval;
    AsnAny	msapIfAgeMultiplier;
    AsnAny	msapIfSupply;
    AsnAny	msapIfListen;
    AsnAny	msapIfGetNearestServerReply;
	SAP_MIB_SET_INPUT_DATA	MibSetInputData;
} sav_msapIfEntry;

#define sf_msapIfIndex                      set_msapIfEntry
#define sf_msapIfAdminState                 set_msapIfEntry
#define sf_msapIfUpdateMode                 set_msapIfEntry
#define sf_msapIfUpdateInterval             set_msapIfEntry
#define sf_msapIfAgeMultiplier              set_msapIfEntry
#define sf_msapIfSupply                     set_msapIfEntry
#define sf_msapIfListen                     set_msapIfEntry
#define sf_msapIfGetNearestServerReply      set_msapIfEntry

#define sb_msapIfIndex                      sav_msapIfEntry
#define sb_msapIfAdminState                 sav_msapIfEntry
#define sb_msapIfUpdateMode                 sav_msapIfEntry
#define sb_msapIfUpdateInterval             sav_msapIfEntry
#define sb_msapIfAgeMultiplier              sav_msapIfEntry
#define sb_msapIfSupply                     sav_msapIfEntry
#define sb_msapIfListen                     sav_msapIfEntry
#define sb_msapIfGetNearestServerReply      sav_msapIfEntry


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mripsapf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mripsap.c

Abstract:

    ms-ripsap instrumentation callbacks.

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#include "precomp.h"




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapBase group (1.3.6.1.4.1.311.1.9.1)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripsapBase(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Beb	((buf_mripsapBase *)objectArray)
	RIP_MIB_GET_INPUT_DATA	RipMibGetInputData;
	SAP_MIB_GET_INPUT_DATA	SapMibGetInputData;
	PRIPMIB_BASE			RipBep = NULL;
	PSAP_MIB_BASE			SapBep = NULL;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GET:
		RipMibGetInputData.TableId = RIP_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_RIP,
								&RipMibGetInputData,
								sizeof(RIP_MIB_GET_INPUT_DATA),
								&RipBep,
								&BeSize);
								
        if (rc == NO_ERROR && RipBep == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
        								
		if (rc==NO_ERROR) {
			SetAsnInteger (&Beb->mripsapBaseRipOperState, RipBep->RIPOperState);
			MprAdminMIBBufferFree (RipBep);
			SapMibGetInputData.TableId = SAP_BASE_ENTRY;
			rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&SapMibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&SapBep,
									&BeSize);
			if (rc==NO_ERROR && SapBep) {
				SetAsnInteger (&Beb->mripsapBaseSapOperState, SapBep->SapOperState);
				MprAdminMIBBufferFree (SapBep);
				DbgTrace (DBG_RIPSAPBASE,
					("MRIPSAP-Base: Get request succeded.\n"));
				return MIB_S_SUCCESS;
			}
			else {
				*errorIndex = 1;
				DbgTrace (DBG_RIPSAPBASE,
					("MRIPSAP-Base: Get SapOperState failed with error %ld.\n", rc));
				return MIB_S_ENTRY_NOT_FOUND;
			}
		}
		else {
			*errorIndex = 0;
			DbgTrace (DBG_RIPSAPBASE,
				("MRIPSAP-Base: Get RipOperState failed with error %ld.\n", rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_GETNEXT:
		DbgTrace (DBG_IPXBASE,
				("MRIPSAP-Base:Get called with GET_FIRST/GET_NEXT for scalar.\n"));
		return MIB_S_INVALID_PARAMETER;

	default:
		DbgTrace (DBG_RIPSAPBASE,
				("MRIPSAP-Base: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Beb
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapInterface group (1.3.6.1.4.1.311.1.9.2)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((buf_mripIfEntry *)objectArray)
	PRIP_INTERFACE			Ifp;
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = RIP_INTERFACE_TABLE;
	MibGetInputData.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ifb->mripIfIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Ifb->mripIfIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ifb->mripIfIndex.asnType)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_RIPINTERFACES,
					("MRIPSAP-mripIf: Get(%d) request succeded for if %ld->%ld.\n",
					 actionId,
					MibGetInputData.InterfaceIndex,
					Ifp->InterfaceIndex));
		ForceAsnInteger (&Ifb->mripIfIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ifb->mripIfAdminState, Ifp->RipIfInfo.AdminState);
		SetAsnInteger (&Ifb->mripIfOperState, Ifp->RipIfStats.RipIfOperState);
		SetAsnInteger (&Ifb->mripIfUpdateMode, Ifp->RipIfInfo.UpdateMode);
		SetAsnInteger (&Ifb->mripIfUpdateInterval, Ifp->RipIfInfo.PeriodicUpdateInterval);
		SetAsnInteger (&Ifb->mripIfAgeMultiplier, Ifp->RipIfInfo.AgeIntervalMultiplier);
		SetAsnInteger (&Ifb->mripIfSupply, Ifp->RipIfInfo.Supply);
		SetAsnInteger (&Ifb->mripIfListen, Ifp->RipIfInfo.Listen);
		SetAsnCounter (&Ifb->mripIfInPackets, Ifp->RipIfStats.RipIfInputPackets);
		SetAsnCounter (&Ifb->mripIfOutPackets, Ifp->RipIfStats.RipIfOutputPackets);
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_RIPINTERFACES,
			("MRIPSAP-mripIf: End of table reached on GETNEXT request for if %ld.\n",
				MibGetInputData.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_RIPINTERFACES,
			("MRIPSAP-mripIf: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ifb
}

UINT
set_mripIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((sav_mripIfEntry *)objectArray)
	PRIP_INTERFACE			Ifp;
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
											Ifb->mripIfIndex.asnType);
		MibGetInputData.TableId = RIP_INTERFACE_TABLE;
		MibGetInputData.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ifb->mripIfIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_RIP,
									&MibGetInputData,
									sizeof(RIP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
									
        if (rc == NO_ERROR && Ifp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
									
		if (rc==NO_ERROR) {
			Ifb->MibSetInputData.RipInterface = *Ifp;
			Ifb->MibSetInputData.RipInterface.RipIfInfo.AdminState
				= (ULONG)GetAsnInteger(&Ifb->mripIfAdminState,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.AdminState);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.UpdateMode
				= (ULONG)GetAsnInteger(&Ifb->mripIfUpdateMode,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.UpdateMode);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.PeriodicUpdateInterval
				= (ULONG)GetAsnInteger(&Ifb->mripIfUpdateInterval,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.PeriodicUpdateInterval);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.AgeIntervalMultiplier
				= (ULONG)GetAsnInteger(&Ifb->mripIfAgeMultiplier,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.AgeIntervalMultiplier);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.Supply
				= (ULONG)GetAsnInteger(&Ifb->mripIfSupply,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.Supply);
			Ifb->MibSetInputData.RipInterface.RipIfInfo.Listen
				= (ULONG)GetAsnInteger(&Ifb->mripIfListen,
					Ifb->MibSetInputData.RipInterface.RipIfInfo.Listen);
			MprAdminMIBBufferFree (Ifp);
			DbgTrace (DBG_RIPINTERFACES, ("MRIPSAP-mripIf: Validated if %ld\n",
						MibGetInputData.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf: Validate failed on if %ld with error %ld\n",
				MibGetInputData.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_RIP,
								&Ifb->MibSetInputData,
								sizeof(RIP_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_RIPINTERFACES, ("MRIPSAP-mripIf: Set succeded on if %ld\n",
					Ifb->MibSetInputData.RipInterface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_RIPINTERFACES,
				("MRIPSAP-mripIf: Set failed on if %ld with error %ld\n",
					Ifb->MibSetInputData.RipInterface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_RIPINTERFACES,
				("MMRIPSAP-mripIf: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ifb
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((buf_msapIfEntry *)objectArray)
	PSAP_INTERFACE			Ifp;
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = SAP_INTERFACE_TABLE;
	MibGetInputData.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ifb->msapIfIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Ifb->msapIfIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ifb->msapIfIndex.asnType)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_SAPINTERFACES,
					("MRIPSAP-msapIf: Get(%d) request succeded for if %ld->%ld.\n",
					actionId,
					MibGetInputData.InterfaceIndex,
					Ifp->InterfaceIndex));
		ForceAsnInteger (&Ifb->msapIfIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ifb->msapIfAdminState, Ifp->SapIfInfo.AdminState);
		SetAsnInteger (&Ifb->msapIfOperState, Ifp->SapIfStats.SapIfOperState);
		SetAsnInteger (&Ifb->msapIfUpdateMode, Ifp->SapIfInfo.UpdateMode);
		SetAsnInteger (&Ifb->msapIfUpdateInterval, Ifp->SapIfInfo.PeriodicUpdateInterval);
		SetAsnInteger (&Ifb->msapIfAgeMultiplier, Ifp->SapIfInfo.AgeIntervalMultiplier);
		SetAsnInteger (&Ifb->msapIfSupply, Ifp->SapIfInfo.Supply);
		SetAsnInteger (&Ifb->msapIfListen, Ifp->SapIfInfo.Listen);
		SetAsnInteger (&Ifb->msapIfGetNearestServerReply,
										Ifp->SapIfInfo.GetNearestServerReply);
		SetAsnCounter (&Ifb->msapIfInPackets, Ifp->SapIfStats.SapIfInputPackets);
		SetAsnCounter (&Ifb->msapIfOutPackets, Ifp->SapIfStats.SapIfOutputPackets);
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_SAPINTERFACES,
			("MRIPSAP-msapIf: End of table reached on GETNEXT request for if %ld.\n",
				MibGetInputData.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_SAPINTERFACES,
			("MRIPSAP-msapIf: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ifb
}

UINT
set_msapIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((sav_msapIfEntry *)objectArray)
	PSAP_INTERFACE			Ifp;
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
											Ifb->msapIfIndex.asnType);
		MibGetInputData.TableId = SAP_INTERFACE_TABLE;
		MibGetInputData.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ifb->msapIfIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_SAP,
									&MibGetInputData,
									sizeof(SAP_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
									
        if (rc == NO_ERROR && Ifp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
        
		if (rc==NO_ERROR) {
			Ifb->MibSetInputData.SapInterface = *Ifp;
			Ifb->MibSetInputData.SapInterface.SapIfInfo.AdminState
				= (ULONG)GetAsnInteger(&Ifb->msapIfAdminState,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.AdminState);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.UpdateMode
				= (ULONG)GetAsnInteger(&Ifb->msapIfUpdateMode,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.UpdateMode);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.PeriodicUpdateInterval
				= (ULONG)GetAsnInteger(&Ifb->msapIfUpdateInterval,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.PeriodicUpdateInterval);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.AgeIntervalMultiplier
				= (ULONG)GetAsnInteger(&Ifb->msapIfAgeMultiplier,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.AgeIntervalMultiplier);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.Supply
				= (ULONG)GetAsnInteger(&Ifb->msapIfSupply,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.Supply);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.Listen
				= (ULONG)GetAsnInteger(&Ifb->msapIfListen,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.Listen);
			Ifb->MibSetInputData.SapInterface.SapIfInfo.GetNearestServerReply
				= (ULONG)GetAsnInteger(&Ifb->msapIfGetNearestServerReply,
					Ifb->MibSetInputData.SapInterface.SapIfInfo.GetNearestServerReply);
			MprAdminMIBBufferFree (Ifp);
			DbgTrace (DBG_SAPINTERFACES, ("MRIPSAP-msapIf: Validated if %ld\n",
						MibGetInputData.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf: Validate failed on if %ld with error %ld\n",
				MibGetInputData.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_SAP,
								&Ifb->MibSetInputData,
								sizeof(SAP_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_SAPINTERFACES, ("MRIPSAP-msapIf: Set succeded on if %ld\n",
					Ifb->MibSetInputData.SapInterface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_SAPINTERFACES,
				("MRIPSAP-msapIf: Set failed on if %ld with error %ld\n",
					Ifb->MibSetInputData.SapInterface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_SAPINTERFACES,
				("MMRIPSAP-msapIf: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ifb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\nipxe.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipxe.h

Abstract:

    Novell-ipx mib entry indeces

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/


#ifndef _SNMP_NIPXE_
#define _SNMP_NIPXE_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_nipxSystem						0

#define mi_nipxBasicSysTable				mi_nipxSystem+1
#define mi_nipxBasicSysEntry				mi_nipxBasicSysTable+1

#define mi_nipxBasicSysInstance				mi_nipxBasicSysEntry+1
#define mi_nipxBasicSysExistState			mi_nipxBasicSysInstance+1
#define mi_nipxBasicSysNetNumber			mi_nipxBasicSysExistState+1
#define mi_nipxBasicSysNode					mi_nipxBasicSysNetNumber+1
#define mi_nipxBasicSysName					mi_nipxBasicSysNode+1
#define mi_nipxBasicSysInReceives			mi_nipxBasicSysName+1
#define mi_nipxBasicSysInHdrErrors			mi_nipxBasicSysInReceives+1
#define mi_nipxBasicSysInUnknownSockets		mi_nipxBasicSysInHdrErrors+1
#define mi_nipxBasicSysInDiscards			mi_nipxBasicSysInUnknownSockets+1
#define mi_nipxBasicSysInBadChecksums		mi_nipxBasicSysInDiscards+1
#define mi_nipxBasicSysInDelivers			mi_nipxBasicSysInBadChecksums+1
#define mi_nipxBasicSysNoRoutes				mi_nipxBasicSysInDelivers+1
#define mi_nipxBasicSysOutRequests			mi_nipxBasicSysNoRoutes+1
#define mi_nipxBasicSysOutMalformedRequests	mi_nipxBasicSysOutRequests+1
#define mi_nipxBasicSysOutDiscards			mi_nipxBasicSysOutMalformedRequests+1
#define mi_nipxBasicSysOutPackets			mi_nipxBasicSysOutDiscards+1
#define mi_nipxBasicSysConfigSockets		mi_nipxBasicSysOutPackets+1
#define mi_nipxBasicSysOpenSocketFails		mi_nipxBasicSysConfigSockets+1

#define mi_nipxAdvSysTable					mi_nipxBasicSysOpenSocketFails+1
#define mi_nipxAdvSysEntry					mi_nipxAdvSysTable+1

#define mi_nipxAdvSysInstance				mi_nipxAdvSysEntry+1
#define mi_nipxAdvSysMaxPathSplits			mi_nipxAdvSysInstance+1
#define mi_nipxAdvSysMaxHops				mi_nipxAdvSysMaxPathSplits+1
#define mi_nipxAdvSysInTooManyHops			mi_nipxAdvSysMaxHops+1
#define mi_nipxAdvSysInFiltered				mi_nipxAdvSysInTooManyHops+1
#define mi_nipxAdvSysInCompressDiscards		mi_nipxAdvSysInFiltered+1
#define mi_nipxAdvSysNETBIOSPackets			mi_nipxAdvSysInCompressDiscards+1
#define mi_nipxAdvSysForwPackets			mi_nipxAdvSysNETBIOSPackets+1
#define mi_nipxAdvSysOutFiltered			mi_nipxAdvSysForwPackets+1
#define mi_nipxAdvSysOutCompressDiscards	mi_nipxAdvSysOutFiltered+1
#define mi_nipxAdvSysCircCount				mi_nipxAdvSysOutCompressDiscards+1
#define mi_nipxAdvSysDestCount				mi_nipxAdvSysCircCount+1
#define mi_nipxAdvSysServCount				mi_nipxAdvSysDestCount+1


#define mi_nipxCircuit						mi_nipxAdvSysServCount+1

#define mi_nipxCircTable					mi_nipxCircuit+1
#define mi_nipxCircEntry					mi_nipxCircTable+1

#define mi_nipxCircSysInstance				mi_nipxCircEntry+1
#define mi_nipxCircIndex					mi_nipxCircSysInstance+1
#define mi_nipxCircExistState				mi_nipxCircIndex+1
#define mi_nipxCircOperState				mi_nipxCircExistState+1
#define mi_nipxCircIfIndex					mi_nipxCircOperState+1
#define mi_nipxCircName						mi_nipxCircIfIndex+1
#define mi_nipxCircType						mi_nipxCircName+1
#define mi_nipxCircDialName					mi_nipxCircType+1
#define mi_nipxCircLocalMaxPacketSize		mi_nipxCircDialName+1
#define mi_nipxCircCompressState			mi_nipxCircLocalMaxPacketSize+1
#define mi_nipxCircCompressSlots			mi_nipxCircCompressState+1
#define mi_nipxCircStaticStatus				mi_nipxCircCompressSlots+1
#define mi_nipxCircCompressedSent			mi_nipxCircStaticStatus+1
#define mi_nipxCircCompressedInitSent		mi_nipxCircCompressedSent+1
#define mi_nipxCircCompressedRejectsSent	mi_nipxCircCompressedInitSent+1
#define mi_nipxCircUncompressedSent			mi_nipxCircCompressedRejectsSent+1
#define mi_nipxCircCompressedReceived		mi_nipxCircUncompressedSent+1
#define mi_nipxCircCompressedInitReceived	mi_nipxCircCompressedReceived+1
#define mi_nipxCircCompressedRejectsReceived mi_nipxCircCompressedInitReceived+1
#define mi_nipxCircUncompressedReceived		mi_nipxCircCompressedRejectsReceived+1
#define mi_nipxCircMediaType				mi_nipxCircUncompressedReceived+1
#define mi_nipxCircNetNumber				mi_nipxCircMediaType+1
#define mi_nipxCircStateChanges				mi_nipxCircNetNumber+1
#define mi_nipxCircInitFails				mi_nipxCircStateChanges+1
#define mi_nipxCircDelay					mi_nipxCircInitFails+1
#define mi_nipxCircThroughput				mi_nipxCircDelay+1
#define mi_nipxCircNeighRouterName			mi_nipxCircThroughput+1
#define mi_nipxCircNeighInternalNetNum		mi_nipxCircNeighRouterName+1


#define mi_nipxForwarding					mi_nipxCircNeighInternalNetNum+1

#define mi_nipxDestTable					mi_nipxForwarding+1
#define mi_nipxDestEntry					mi_nipxDestTable+1

#define mi_nipxDestSysInstance				mi_nipxDestEntry+1
#define mi_nipxDestNetNum					mi_nipxDestSysInstance+1
#define mi_nipxDestProtocol					mi_nipxDestNetNum+1
#define mi_nipxDestTicks					mi_nipxDestProtocol+1
#define mi_nipxDestHopCount					mi_nipxDestTicks+1
#define mi_nipxDestNextHopCircIndex			mi_nipxDestHopCount+1
#define mi_nipxDestNextHopNICAddress		mi_nipxDestNextHopCircIndex+1
#define mi_nipxDestNextHopNetNum			mi_nipxDestNextHopNICAddress+1

#define mi_nipxStaticRouteTable				mi_nipxDestNextHopNetNum+1
#define mi_nipxStaticRouteEntry				mi_nipxStaticRouteTable+1

#define mi_nipxStaticRouteSysInstance		mi_nipxStaticRouteEntry+1
#define mi_nipxStaticRouteCircIndex			mi_nipxStaticRouteSysInstance+1
#define mi_nipxStaticRouteNetNum			mi_nipxStaticRouteCircIndex+1
#define mi_nipxStaticRouteExistState		mi_nipxStaticRouteNetNum+1
#define mi_nipxStaticRouteTicks				mi_nipxStaticRouteExistState+1
#define mi_nipxStaticRouteHopCount			mi_nipxStaticRouteTicks+1


#define mi_nipxServices						mi_nipxStaticRouteHopCount+1

#define mi_nipxServTable					mi_nipxServices+1
#define mi_nipxServEntry					mi_nipxServTable+1

#define mi_nipxServSysInstance				mi_nipxServEntry+1
#define mi_nipxServType						mi_nipxServSysInstance+1
#define mi_nipxServName						mi_nipxServType+1
#define mi_nipxServProtocol					mi_nipxServName+1
#define mi_nipxServNetNum					mi_nipxServProtocol+1
#define mi_nipxServNode						mi_nipxServNetNum+1
#define mi_nipxServSocket					mi_nipxServNode+1
#define mi_nipxServHopCount					mi_nipxServSocket+1

#define mi_nipxDestServTable				mi_nipxServHopCount+1
#define mi_nipxDestServEntry				mi_nipxDestServTable+1

#define mi_nipxDestServSysInstance			mi_nipxDestServEntry+1
#define mi_nipxDestServNetNum				mi_nipxDestServSysInstance+1
#define mi_nipxDestServNode					mi_nipxDestServNetNum+1
#define mi_nipxDestServSocket				mi_nipxDestServNode+1
#define mi_nipxDestServName					mi_nipxDestServSocket+1
#define mi_nipxDestServType					mi_nipxDestServName+1
#define mi_nipxDestServProtocol				mi_nipxDestServType+1
#define mi_nipxDestServHopCount				mi_nipxDestServProtocol+1

#define mi_nipxStaticServTable				mi_nipxDestServHopCount+1
#define mi_nipxStaticServEntry				mi_nipxStaticServTable+1

#define mi_nipxStaticServSysInstance		mi_nipxStaticServEntry+1
#define mi_nipxStaticServCircIndex			mi_nipxStaticServSysInstance+1
#define mi_nipxStaticServType				mi_nipxStaticServCircIndex+1
#define mi_nipxStaticServName				mi_nipxStaticServType+1
#define mi_nipxStaticServExistState			mi_nipxStaticServName+1
#define mi_nipxStaticServNetNum				mi_nipxStaticServExistState+1
#define mi_nipxStaticServNode				mi_nipxStaticServNetNum+1
#define mi_nipxStaticServSocket				mi_nipxStaticServNode+1
#define mi_nipxStaticServHopCount			mi_nipxStaticServSocket+1

//nipxTraps		


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxBasicSysEntry                18
#define ni_nipxBasicSysEntry                1


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxAdvSysEntry                  13
#define ni_nipxAdvSysEntry                  1


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxCircEntry                    28
#define ni_nipxCircEntry                    2


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxDestEntry                    8
#define ni_nipxDestEntry                    2


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.2.1)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxStaticRouteEntry             6
#define ni_nipxStaticRouteEntry             3


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxServEntry                    8
#define ni_nipxServEntry                    3


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxDestServEntry                8
#define ni_nipxDestServEntry                6


///////////////////////////////////////////////////////////////////////////////
//													                         //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_nipxStaticServEntry              9
#define ni_nipxStaticServEntry              4


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\mipxf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mipxf.c

Abstract:

    ms-ipx instrumentation callbacks.

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/
#include "precomp.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxBase group (1.3.6.1.4.1.311.1.8.1)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxBase(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Beb	((buf_mipxBase *)objectArray)
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			Bep;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GET:
		MibGetInputData.TableId = IPX_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Bep,
								&BeSize);
        if (rc == NO_ERROR && Bep == NULL)
        {
            return MIB_S_ENTRY_NOT_FOUND;
        }
		if (rc==NO_ERROR) {
			SetAsnInteger (&Beb->mipxBaseOperState, Bep->OperState);
			SetAsnOctetString (&Beb->mipxBasePrimaryNetNumber, Beb->PrimaryNetVal,
						Bep->PrimaryNetNumber, sizeof (Beb->PrimaryNetVal));
			SetAsnOctetString (&Beb->mipxBaseNode, Beb->NodeVal,
						Bep->Node, sizeof (Beb->NodeVal));
			SetAsnDispString (&Beb->mipxBaseSysName, Beb->SysNameVal,
						Bep->SysName, sizeof (Beb->SysNameVal));
			SetAsnInteger (&Beb->mipxBaseMaxPathSplits, Bep->MaxPathSplits);
			SetAsnInteger (&Beb->mipxBaseIfCount, Bep->IfCount);
			SetAsnInteger (&Beb->mipxBaseDestCount, Bep->DestCount);
			SetAsnInteger (&Beb->mipxBaseServCount, Bep->ServCount);
			MprAdminMIBBufferFree (Bep);
			DbgTrace (DBG_IPXBASE,	("MIPX-Base: Get request succeded.\n"));
			return MIB_S_SUCCESS;
		}
		else {
			*errorIndex = 0;
			DbgTrace (DBG_IPXBASE,
				("MIPX-Base: Get request failed with error %ld.\n", rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_GETNEXT:
		DbgTrace (DBG_IPXBASE,
				("MIPX-Base:Get called with GET_FIRST/GET_NEXT for scalar.\n"));
		return MIB_S_INVALID_PARAMETER;
	default:
		DbgTrace (DBG_IPXBASE,
				("MIPX-Base:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Beb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxInterface group (1.3.6.1.4.1.311.1.8.2)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxIfEntry table (1.3.6.1.4.1.311.1.8.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((buf_mipxIfEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ifb->mipxIfIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Ifb->mipxIfIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ifb->mipxIfIndex.asnType)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_IPXINTERFACES,
				("MIPX-if:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_IPXINTERFACES, ("MIPX-if: Get(%d) request succeded for if %ld->%ld.\n",
				actionId,
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex,
				Ifp->InterfaceIndex));
		ForceAsnInteger (&Ifb->mipxIfIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ifb->mipxIfAdminState, Ifp->AdminState);
		SetAsnInteger (&Ifb->mipxIfOperState, Ifp->IfStats.IfOperState);
		SetAsnInteger (&Ifb->mipxIfAdapterIndex, Ifp->AdapterIndex);
		SetAsnDispString (&Ifb->mipxIfName, Ifb->NameVal,
						Ifp->InterfaceName, sizeof (Ifb->NameVal));
		SetAsnInteger (&Ifb->mipxIfType, Ifp->InterfaceType);
		SetAsnInteger (&Ifb->mipxIfLocalMaxPacketSize, Ifp->IfStats.MaxPacketSize);
		SetAsnInteger (&Ifb->mipxIfMediaType, Ifp->MediaType);
		SetAsnOctetString (&Ifb->mipxIfNetNumber, Ifb->NetNumberVal,
						Ifp->NetNumber, sizeof (Ifb->NetNumberVal));
		SetAsnOctetString (&Ifb->mipxIfMacAddress, Ifb->MacAddressVal,
						Ifp->MacAddress, sizeof (Ifb->MacAddressVal));
		SetAsnInteger (&Ifb->mipxIfDelay, Ifp->Delay);
		SetAsnInteger (&Ifb->mipxIfThroughput, Ifp->Throughput);
		SetAsnInteger (&Ifb->mipxIfIpxWanEnable, Ifp->EnableIpxWanNegotiation);
		SetAsnInteger (&Ifb->mipxIfNetbiosAccept, Ifp->NetbiosAccept);
		SetAsnInteger (&Ifb->mipxIfNetbiosDeliver, Ifp->NetbiosDeliver);
		SetAsnCounter (&Ifb->mipxIfInHdrErrors, Ifp->IfStats.InHdrErrors);
		SetAsnCounter (&Ifb->mipxIfInFilterDrops, Ifp->IfStats.InFiltered);
		SetAsnCounter (&Ifb->mipxIfInNoRoutes, Ifp->IfStats.InNoRoutes);
		SetAsnCounter (&Ifb->mipxIfInDiscards, Ifp->IfStats.InDiscards);
		SetAsnCounter (&Ifb->mipxIfInDelivers, Ifp->IfStats.InDelivers);
		SetAsnCounter (&Ifb->mipxIfOutFilterDrops, Ifp->IfStats.OutFiltered);
		SetAsnCounter (&Ifb->mipxIfOutDiscards, Ifp->IfStats.OutDiscards);
		SetAsnCounter (&Ifb->mipxIfOutDelivers, Ifp->IfStats.OutDelivers);
		SetAsnCounter (&Ifb->mipxIfInNetbiosPackets, Ifp->IfStats.NetbiosReceived);
		SetAsnCounter (&Ifb->mipxIfOutNetbiosPackets, Ifp->IfStats.NetbiosSent);
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_IPXINTERFACES,
			("MIPX-if: End of table reached on GETFIRST/GETNEXT request for if %ld.\n",
								MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_IPXINTERFACES,
			("MIPX-if: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ifb
}

UINT
set_mipxIfEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ifb	((sav_mipxIfEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
											Ifb->mipxIfIndex.asnType);
		MibGetInputData.TableId = IPX_INTERFACE_TABLE;
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ifb->mipxIfIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
        if (rc == NO_ERROR && Ifp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
		if (rc==NO_ERROR) {
			Ifb->MibSetInputData.MibRow.Interface = *Ifp;
			Ifb->MibSetInputData.MibRow.Interface.AdminState
				= (ULONG)GetAsnInteger(&Ifb->mipxIfAdminState,
					Ifb->MibSetInputData.MibRow.Interface.AdminState);
			GetAsnOctetString (
				Ifb->MibSetInputData.MibRow.Interface.NetNumber,
				&Ifb->mipxIfNetNumber,
				sizeof (Ifb->MibSetInputData.MibRow.Interface.NetNumber),
				NULL);
			GetAsnOctetString (
				Ifb->MibSetInputData.MibRow.Interface.MacAddress,
				&Ifb->mipxIfMacAddress,
				sizeof (Ifb->MibSetInputData.MibRow.Interface.MacAddress),
				NULL);
			Ifb->MibSetInputData.MibRow.Interface.EnableIpxWanNegotiation
				= (ULONG)GetAsnInteger (&Ifb->mipxIfIpxWanEnable,
					Ifb->MibSetInputData.MibRow.Interface.EnableIpxWanNegotiation);
			Ifb->MibSetInputData.MibRow.Interface.NetbiosAccept
				= (ULONG)GetAsnInteger (&Ifb->mipxIfNetbiosAccept,
					Ifb->MibSetInputData.MibRow.Interface.NetbiosAccept);
			Ifb->MibSetInputData.MibRow.Interface.NetbiosDeliver
				= (ULONG)GetAsnInteger (&Ifb->mipxIfNetbiosDeliver,
					Ifb->MibSetInputData.MibRow.Interface.NetbiosDeliver);
			MprAdminMIBBufferFree (Ifp);
			DbgTrace (DBG_IPXINTERFACES, ("MIPX-if: Validated if %ld\n",
						MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_IPXINTERFACES,
				("MIPX-if: Validate failed on if %ld with error %ld\n",
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Ifb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_IPXINTERFACES, ("MIPX-if: Set succeded on if %ld\n",
					Ifb->MibSetInputData.MibRow.Interface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_IPXINTERFACES,
				("MIPX-if: Set failed on if %ld with error %ld\n",
					Ifb->MibSetInputData.MibRow.Interface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_IPXINTERFACES,
				("MIPX-if:Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ifb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxForwarding group (1.3.6.1.4.1.311.1.8.3)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxDestEntry table (1.3.6.1.4.1.311.1.8.3.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Rtb	((buf_mipxDestEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_DEST_TABLE;
	GetAsnOctetString (MibGetInputData.MibIndex.RoutingTableIndex.Network,
				&Rtb->mipxDestNetNum,
				sizeof (MibGetInputData.MibIndex.RoutingTableIndex.Network),
				ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
											Rtb->mipxDestNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Rtb->mipxDestNetNum.asnType) {
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Rtb->mipxDestNetNum);
			}
		}
		else
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
		break;
	default:
		DbgTrace (DBG_DESTTABLE,
				("MIPX-dest:Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_DESTTABLE, 
				("MIPX-dest: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x.\n", actionId,
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3]));
		ForceAsnOctetString (&Rtb->mipxDestNetNum, Rtb->NetNumVal,
							Rtp->Network, sizeof (Rtb->NetNumVal));
        switch (Rtp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Rtb->mipxDestProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Rtb->mipxDestProtocol, 5);
            break;
        case IPX_PROTOCOL_RIP:
		    SetAsnInteger (&Rtb->mipxDestProtocol, 3);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Rtb->mipxDestProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Rtb->mipxDestProtocol, 1);  // other
            break;
        }
		SetAsnInteger (&Rtb->mipxDestTicks, Rtp->TickCount);          
		SetAsnInteger (&Rtb->mipxDestHopCount, Rtp->HopCount);
		SetAsnInteger (&Rtb->mipxDestNextHopIfIndex, Rtp->InterfaceIndex);
		SetAsnOctetString (&Rtb->mipxDestNextHopMacAddress, Rtb->NextHopMacAddressVal,
							Rtp->NextHopMacAddress, sizeof (Rtb->NextHopMacAddressVal));
		SetAsnInteger (&Rtb->mipxDestFlags, Rtp->Flags);
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_DESTTABLE,
				("MIPX-dest: End of table reached on GETFIRST/GETNEXT request"
					" for network %.2x%.2x%.2x%.2x.\n",
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3]));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_DESTTABLE,
				("MIPX-dest: Get request for network %.2x%.2x%.2x%.2x"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3], rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Rtb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticRouteEntry table (1.3.6.1.4.1.311.1.8.3.2.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Rtb	((buf_mipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
	MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Rtb->mipxStaticRouteIfIndex, ZERO_INTERFACE_INDEX);
	GetAsnOctetString (
		MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
		&Rtb->mipxStaticRouteNetNum,
		sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
		ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
				Rtb->mipxStaticRouteIfIndex.asnType
				&&Rtb->mipxStaticRouteNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Rtb->mipxStaticRouteIfIndex.asnType) {
			if (!Rtb->mipxStaticRouteNetNum.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Rtp,
											&RtSize);
				if (rc==NO_ERROR)
					break;
			}

			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				if (Rtb->mipxStaticRouteNetNum.asnType) {
					FreeAsnString (&Rtb->mipxStaticRouteNetNum);
				}
			}
		}
		else {
			ASSERTMSG ("Second index is present but first is not ",
								!Rtb->mipxStaticRouteNetNum.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		}
		break;
	default:
		DbgTrace (DBG_STATICROUTES,
				("MIPX-staticRoutes: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Rtp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_STATICROUTES,
				("MIPX-staticRoutes: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x on if %ld\n", actionId,
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Rtb->mipxStaticRouteIfIndex, Rtp->InterfaceIndex);
		ForceAsnOctetString (&Rtb->mipxStaticRouteNetNum, Rtb->NetNumVal,
							Rtp->Network, sizeof (Rtb->NetNumVal));
		SetAsnInteger (&Rtb->mipxStaticRouteEntryStatus, MIPX_EXIST_STATE_CREATED);
		SetAsnInteger (&Rtb->mipxStaticRouteTicks, Rtp->TickCount);          
		SetAsnInteger (&Rtb->mipxStaticRouteHopCount, Rtp->HopCount);
		SetAsnOctetString (&Rtb->mipxStaticRouteNextHopMacAddress, Rtb->NextHopMacAddressVal,
							Rtp->NextHopMacAddress, sizeof (Rtb->NextHopMacAddressVal));
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
										actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_STATICROUTES,
				("MIPX-staticRoutes: End of table reached on GETFIRST/GETNEXT request for network"
					" %.2x%.2x%.2x%.2x on if %ld.\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_STATICROUTES,
				("MIPX-staticRoutes: Get request for network %.2x%.2x%.2x%.2x."
					" on if %ld failed with error %ld.\n", 
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Rtb
}

UINT
set_mipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Rtb	((sav_mipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
			Rtb->mipxStaticRouteIfIndex.asnType&&Rtb->mipxStaticRouteIfIndex.asnType);
		MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
		MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Rtb->mipxStaticRouteIfIndex,INVALID_INTERFACE_INDEX);
		GetAsnOctetString (
			MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
			&Rtb->mipxStaticRouteNetNum,
			sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
			ZERO_NET_NUM);
		Rtb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Rtb->mipxStaticRouteEntryStatus,
			MIPX_EXIST_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
        if (rc == NO_ERROR && Rtp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
        }
		if (rc==NO_ERROR) {
			Rtb->MibSetInputData.MibRow.Route = *Rtp;
			if (Rtb->ActionFlag == MIPX_EXIST_STATE_CREATED)
				Rtb->ActionFlag = MIPX_EXIST_STATE_NOACTION;
			MprAdminMIBBufferFree (Rtp);
			DbgTrace (DBG_STATICROUTES,
				("MIPX-static routes: Validated"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		}
		else if (Rtb->ActionFlag == MIPX_EXIST_STATE_CREATED) {
			DbgTrace (DBG_STATICROUTES,
				("MIPX-static routes: Prepared to add"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
			Rtb->MibSetInputData.MibRow.Route.InterfaceIndex
				= (ULONG)GetAsnInteger (&Rtb->mipxStaticRouteIfIndex,
					INVALID_INTERFACE_INDEX);
			GetAsnOctetString (Rtb->MibSetInputData.MibRow.Route.Network,
					&Rtb->mipxStaticRouteNetNum,
					sizeof (Rtb->MibSetInputData.MibRow.Route.Network),
					ZERO_NET_NUM);
			Rtb->MibSetInputData.MibRow.Route.Protocol = IPX_PROTOCOL_STATIC;
			Rtb->MibSetInputData.MibRow.Route.Flags = 0;
			Rtb->MibSetInputData.MibRow.Route.TickCount = MAXSHORT;
			Rtb->MibSetInputData.MibRow.Route.HopCount = 15;
			memset (Rtb->MibSetInputData.MibRow.Route.NextHopMacAddress,
					0xFF,
					sizeof (Rtb->MibSetInputData.MibRow.Route.NextHopMacAddress));
		}
		else {
			DbgTrace (DBG_STATICROUTES,
				("MIPX-static routes: Validate failed"
				" for network %.2x.2x.2x.2x on if %ld with error %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex,rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		Rtb->MibSetInputData.MibRow.Route.TickCount
			= (USHORT)GetAsnInteger (&Rtb->mipxStaticRouteTicks,
				Rtb->MibSetInputData.MibRow.Route.TickCount);
		Rtb->MibSetInputData.MibRow.Route.HopCount
			= (USHORT)GetAsnInteger (&Rtb->mipxStaticRouteHopCount,
				Rtb->MibSetInputData.MibRow.Route.HopCount);
		GetAsnOctetString (Rtb->MibSetInputData.MibRow.Route.NextHopMacAddress,
					&Rtb->mipxStaticRouteNextHopMacAddress,
					sizeof (Rtb->MibSetInputData.MibRow.Route.NextHopMacAddress),
					NULL);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Rtb->ActionFlag) {
		case MIPX_EXIST_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Rtb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_DELETED:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Rtb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_CREATED:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Rtb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}
		if (rc==NO_ERROR) {
			DbgTrace (DBG_STATICROUTES, 
				("MIPX-static routes: Set succeded for"
					" network %.2x.2x.2x.2x on if %ld\n",
				Rtb->MibSetInputData.MibRow.Route.Network[0],
				Rtb->MibSetInputData.MibRow.Route.Network[1],
				Rtb->MibSetInputData.MibRow.Route.Network[2],
				Rtb->MibSetInputData.MibRow.Route.Network[3],
				Rtb->MibSetInputData.MibRow.Route.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_STATICROUTES, 
				("MIPX-static routes: Set failed for"
					" network %.2x.2x.2x.2x on if %ld with error %ld\n",
				Rtb->MibSetInputData.MibRow.Route.Network[0],
				Rtb->MibSetInputData.MibRow.Route.Network[1],
				Rtb->MibSetInputData.MibRow.Route.Network[2],
				Rtb->MibSetInputData.MibRow.Route.Network[3],
				Rtb->MibSetInputData.MibRow.Route.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_STATICROUTES,
				("MIPX-static routes: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Rtb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServices group (1.3.6.1.4.1.311.1.8.4)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServEntry table (1.3.6.1.4.1.311.1.8.4.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Svb	((buf_mipxServEntry *)objectArray)
	PIPX_SERVICE			Svp, SvpCur;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;
	INT						lenPrev, lenNext, lenCur;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_SERV_TABLE;
	MibGetInputData.MibIndex.ServicesTableIndex.ServiceType
		= GetAsnServType (&Svb->mipxServType, ZERO_SERVER_TYPE);
	GetAsnDispString (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
			&Svb->mipxServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
					Svb->mipxServType.asnType && Svb->mipxServName.asnType);
			
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Svb->mipxServType.asnType) {
			if (!Svb->mipxServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					FreeAsnString (&Svb->mipxServType);
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Svb->mipxServType);
				if (Svb->mipxServName.asnType) {
					FreeAsnString (&Svb->mipxServName);
				}
			}
		}
		else {
			ASSERTMSG ("Second index is present but first is not ",
											!Svb->mipxServName.asnType);
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_SERVERTABLE,
				("MIPX-servers: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_SERVERTABLE, 
				("MIPX-servers: Get(%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s.\n", actionId,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name));
		ForceAsnServType (&Svb->mipxServType, Svb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Svb->mipxServName, Svb->NameVal,
					Svp->Server.Name, sizeof (Svb->NameVal));
        switch (Svp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Svb->mipxServProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Svb->mipxServProtocol, 5);
            break;
        case IPX_PROTOCOL_SAP:
		    SetAsnInteger (&Svb->mipxServProtocol, 6);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Svb->mipxServProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Svb->mipxServProtocol, 1);  // other
            break;
        }
		SetAsnInteger (&Svb->mipxServProtocol, Svp->Protocol);
		SetAsnOctetString (&Svb->mipxServNetNum, Svb->NetNumVal,
					Svp->Server.Network, sizeof (Svb->NetNumVal));
		SetAsnOctetString (&Svb->mipxServNode, Svb->NodeVal,
					Svp->Server.Node, sizeof (Svb->NodeVal));
		SetAsnOctetString (&Svb->mipxServSocket, Svb->SocketVal,
					Svp->Server.Socket, sizeof (Svb->SocketVal));
		SetAsnInteger (&Svb->mipxServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_SERVERTABLE,
				("MIPX-servers: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s.\n",
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_SERVERTABLE,
				("MIPX-servers: Get request for service %.4x-%.48s"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Svb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticServEntry table (1.3.6.1.4.1.311.1.8.4.2.1)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_mipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Svb	((buf_mipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
	MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Svb->mipxStaticServIfIndex,
			ZERO_INTERFACE_INDEX);
	MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
		= GetAsnServType (&Svb->mipxStaticServType, ZERO_SERVER_TYPE);
	GetAsnDispString (
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
		&Svb->mipxStaticServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Svb->mipxStaticServIfIndex.asnType
							&&Svb->mipxStaticServType.asnType
							&&Svb->mipxStaticServName.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Svb->mipxStaticServIfIndex.asnType) {
			if (!Svb->mipxStaticServType.asnType
					|| !Svb->mipxStaticServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					if (Svb->mipxStaticServType.asnType) {
						FreeAsnString (&Svb->mipxStaticServType);
					}
					if (Svb->mipxStaticServName.asnType) {
						FreeAsnString (&Svb->mipxStaticServName);
					}
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
			if (rc==NO_ERROR) {
				if (Svb->mipxStaticServType.asnType) {
					FreeAsnString (&Svb->mipxStaticServType);
				}
				if (Svb->mipxStaticServName.asnType) {
					FreeAsnString (&Svb->mipxStaticServName);
				}
			}
		}
		else {
			ASSERTMSG ("Second or third indeces present but first is not ",
							!Svb->mipxStaticServType.asnType
							&&!Svb->mipxStaticServName.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: Get called with unsupported action code %d.\n",
			actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Svp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: Get (%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s on if %ld.\n", actionId,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Svb->mipxStaticServIfIndex, Svp->InterfaceIndex);
		ForceAsnServType (&Svb->mipxStaticServType, Svb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Svb->mipxStaticServName, Svb->NameVal,
							Svp->Server.Name, sizeof (Svb->NameVal));
		SetAsnInteger (&Svb->mipxStaticServEntryStatus, MIPX_EXIST_STATE_CREATED);
		SetAsnOctetString (&Svb->mipxStaticServNetNum, Svb->NetNumVal,
							Svp->Server.Network, sizeof (Svb->NetNumVal));
		SetAsnOctetString (&Svb->mipxStaticServNode, Svb->NodeVal,
							Svp->Server.Node, sizeof (Svb->NodeVal));
		SetAsnOctetString (&Svb->mipxStaticServSocket, Svb->SocketVal,
							Svp->Server.Socket, sizeof (Svb->SocketVal));
		SetAsnInteger (&Svb->mipxStaticServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
											actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_STATICSERVERS,
			("MIPX-static servers: Get request for service %.4x-%.48s"
					" on if %ld failed with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Svb
}

UINT
set_mipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Svb	((sav_mipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
						Svb->mipxStaticServIfIndex.asnType
						&&Svb->mipxStaticServType.asnType
						&&Svb->mipxStaticServName.asnType);
		MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
		MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Svb->mipxStaticServIfIndex,
				INVALID_INTERFACE_INDEX);
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
			= GetAsnServType (&Svb->mipxStaticServType, INVALID_SERVER_TYPE);
		GetAsnDispString (
			MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
			&Svb->mipxStaticServName,
			INVALID_SERVER_NAME);
		Svb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Svb->mipxStaticServEntryStatus,
			MIPX_EXIST_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
        if (rc == NO_ERROR && Svp == NULL)
        {
            return MIB_S_ENTRY_NOT_FOUND;
        }
									
		if (rc==NO_ERROR) {
			Svb->MibSetInputData.MibRow.Service = *Svp;
			if (Svb->ActionFlag == MIPX_EXIST_STATE_CREATED)
				Svb->ActionFlag = MIPX_EXIST_STATE_NOACTION;
			MprAdminMIBBufferFree (Svp);
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Validated"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		}
		else if (Svb->ActionFlag == MIPX_EXIST_STATE_CREATED) {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Prepared to add"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
			Svb->MibSetInputData.MibRow.Service.InterfaceIndex
				= (ULONG) GetAsnInteger (&Svb->mipxStaticServIfIndex,
					INVALID_INTERFACE_INDEX);
			Svb->MibSetInputData.MibRow.Service.Protocol = IPX_PROTOCOL_STATIC;
			Svb->MibSetInputData.MibRow.Service.Server.Type
				= GetAsnServType (&Svb->mipxStaticServType,
					INVALID_SERVER_TYPE);
			GetAsnDispString (
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				&Svb->mipxStaticServName,
				INVALID_SERVER_NAME);
			memset (Svb->MibSetInputData.MibRow.Service.Server.Network, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Network));
			memset (Svb->MibSetInputData.MibRow.Service.Server.Node, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Node));
			memset (Svb->MibSetInputData.MibRow.Service.Server.Socket, 0,
					sizeof (Svb->MibSetInputData.MibRow.Service.Server.Socket));
			Svb->MibSetInputData.MibRow.Service.Server.HopCount = 15;
		}
		else {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Network,
			&Svb->mipxStaticServNetNum,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Network),
			NULL);
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Node,
			&Svb->mipxStaticServNode,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Node),
			NULL);
		GetAsnOctetString (Svb->MibSetInputData.MibRow.Service.Server.Socket,
			&Svb->mipxStaticServSocket,
			sizeof (Svb->MibSetInputData.MibRow.Service.Server.Socket),
			NULL);
		Svb->MibSetInputData.MibRow.Service.Server.HopCount =
			(USHORT)GetAsnInteger (&Svb->mipxStaticServHopCount,
			Svb->MibSetInputData.MibRow.Service.Server.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Svb->ActionFlag) {
		case MIPX_EXIST_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_DELETED:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_CREATED:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Svb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}

		if (rc==NO_ERROR) {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set succeded"
					" for service %.4x-%.48s on if %ld.\n",
				Svb->MibSetInputData.MibRow.Service.Server.Type,
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				Svb->MibSetInputData.MibRow.Service.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set failed for"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				Svb->MibSetInputData.MibRow.Service.Server.Type,
				Svb->MibSetInputData.MibRow.Service.Server.Name,
				Svb->MibSetInputData.MibRow.Service.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_STATICSERVERS,
				("MIPX-static servers: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Svb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\nipxf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipx.h

Abstract:

    Header for Novell-ipx instrumentation callbacks and associated data structures

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#ifndef _SNMP_NIPXF_
#define _SNMP_NIPXF_




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxBasicSysEntry {
	AsnAny	nipxBasicSysInstance;
	AsnAny	nipxBasicSysExistState;
	AsnAny	nipxBasicSysNetNumber;
	AsnAny	nipxBasicSysNode;
	AsnAny	nipxBasicSysName;
	AsnAny	nipxBasicSysInReceives;
	AsnAny	nipxBasicSysInHdrErrors;
	AsnAny	nipxBasicSysInUnknownSockets;
	AsnAny	nipxBasicSysInDiscards;
	AsnAny	nipxBasicSysInBadChecksums;
	AsnAny	nipxBasicSysInDelivers;
	AsnAny	nipxBasicSysNoRoutes;
	AsnAny	nipxBasicSysOutRequests;
	AsnAny	nipxBasicSysOutMalformedRequests;
	AsnAny	nipxBasicSysOutDiscards;
	AsnAny	nipxBasicSysOutPackets;
	AsnAny	nipxBasicSysConfigSockets;
	AsnAny	nipxBasicSysOpenSocketFails;
	BYTE	NetNumberVal[4];
	BYTE	NodeVal[6];
	BYTE	NameVal[48];
} buf_nipxBasicSysEntry;

#define gf_nipxBasicSysInstance				get_nipxBasicSysEntry
#define gf_nipxBasicSysExistState			get_nipxBasicSysEntry
#define gf_nipxBasicSysNetNumber			get_nipxBasicSysEntry
#define gf_nipxBasicSysNode					get_nipxBasicSysEntry
#define gf_nipxBasicSysName					get_nipxBasicSysEntry
#define gf_nipxBasicSysInReceives			get_nipxBasicSysEntry
#define gf_nipxBasicSysInHdrErrors			get_nipxBasicSysEntry
#define gf_nipxBasicSysInUnknownSockets		get_nipxBasicSysEntry
#define gf_nipxBasicSysInDiscards			get_nipxBasicSysEntry
#define gf_nipxBasicSysInBadChecksums		get_nipxBasicSysEntry
#define gf_nipxBasicSysInDelivers			get_nipxBasicSysEntry
#define gf_nipxBasicSysNoRoutes				get_nipxBasicSysEntry
#define gf_nipxBasicSysOutRequests			get_nipxBasicSysEntry
#define gf_nipxBasicSysOutMalformedRequests	get_nipxBasicSysEntry
#define gf_nipxBasicSysOutDiscards			get_nipxBasicSysEntry
#define gf_nipxBasicSysOutPackets			get_nipxBasicSysEntry
#define gf_nipxBasicSysConfigSockets		get_nipxBasicSysEntry
#define gf_nipxBasicSysOpenSocketFails		get_nipxBasicSysEntry

#define gb_nipxBasicSysInstance				buf_nipxBasicSysEntry
#define gb_nipxBasicSysExistState			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNetNumber			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNode					buf_nipxBasicSysEntry
#define gb_nipxBasicSysName					buf_nipxBasicSysEntry
#define gb_nipxBasicSysInReceives			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInHdrErrors			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInUnknownSockets		buf_nipxBasicSysEntry
#define gb_nipxBasicSysInDiscards			buf_nipxBasicSysEntry
#define gb_nipxBasicSysInBadChecksums		buf_nipxBasicSysEntry
#define gb_nipxBasicSysInDelivers			buf_nipxBasicSysEntry
#define gb_nipxBasicSysNoRoutes				buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutRequests			buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutMalformedRequests	buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutDiscards			buf_nipxBasicSysEntry
#define gb_nipxBasicSysOutPackets			buf_nipxBasicSysEntry
#define gb_nipxBasicSysConfigSockets		buf_nipxBasicSysEntry
#define gb_nipxBasicSysOpenSocketFails		buf_nipxBasicSysEntry

/*
	All values in nipxBasicSysEntry are implemented as read-only
UINT
set_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxBasicSysEntry {
	AsnAny	nipxBasicSysInstance;
	AsnAny	nipxBasicSysExistState;
	AsnAny	nipxBasicSysNetNumber;
	AsnAny	nipxBasicSysNode;
	AsnAny	nipxBasicSysName;
} sav_nipxBasicSysEntry;

#define sf_nipxBasicSysInstance				set_nipxBasicSysEntry
#define sf_nipxBasicSysExistState			set_nipxBasicSysEntry
#define sf_nipxBasicSysNetNumber			set_nipxBasicSysEntry
#define sf_nipxBasicSysNode					set_nipxBasicSysEntry
#define sf_nipxBasicSysName					set_nipxBasicSysEntry

#define sb_nipxBasicSysInstance				sav_nipxBasicSysEntry
#define sb_nipxBasicSysExistState			sav_nipxBasicSysEntry
#define sb_nipxBasicSysNetNumber			sav_nipxBasicSysEntry
#define sb_nipxBasicSysNode					sav_nipxBasicSysEntry
#define sb_nipxBasicSysName					sav_nipxBasicSysEntry
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxAdvSysEntry {
	AsnAny	nipxAdvSysInstance;
	AsnAny	nipxAdvSysMaxPathSplits;
	AsnAny	nipxAdvSysMaxHops;
	AsnAny	nipxAdvSysInTooManyHops;
	AsnAny	nipxAdvSysInFiltered;
	AsnAny	nipxAdvSysInCompressDiscards;
	AsnAny	nipxAdvSysNETBIOSPackets;
	AsnAny	nipxAdvSysForwPackets;
	AsnAny	nipxAdvSysOutFiltered;
	AsnAny	nipxAdvSysOutCompressDiscards;
	AsnAny	nipxAdvSysCircCount;
	AsnAny	nipxAdvSysDestCount;
	AsnAny	nipxAdvSysServCount;
} buf_nipxAdvSysEntry;

#define gf_nipxAdvSysInstance				get_nipxAdvSysEntry
#define gf_nipxAdvSysMaxPathSplits			get_nipxAdvSysEntry
#define gf_nipxAdvSysMaxHops				get_nipxAdvSysEntry
#define gf_nipxAdvSysInTooManyHops			get_nipxAdvSysEntry
#define gf_nipxAdvSysInFiltered				get_nipxAdvSysEntry
#define gf_nipxAdvSysInCompressDiscards		get_nipxAdvSysEntry
#define gf_nipxAdvSysNETBIOSPackets			get_nipxAdvSysEntry
#define gf_nipxAdvSysForwPackets			get_nipxAdvSysEntry
#define gf_nipxAdvSysOutFiltered			get_nipxAdvSysEntry
#define gf_nipxAdvSysOutCompressDiscards	get_nipxAdvSysEntry
#define gf_nipxAdvSysCircCount				get_nipxAdvSysEntry
#define gf_nipxAdvSysDestCount				get_nipxAdvSysEntry
#define gf_nipxAdvSysServCount				get_nipxAdvSysEntry

#define gb_nipxAdvSysInstance				buf_nipxAdvSysEntry
#define gb_nipxAdvSysMaxPathSplits			buf_nipxAdvSysEntry
#define gb_nipxAdvSysMaxHops				buf_nipxAdvSysEntry
#define gb_nipxAdvSysInTooManyHops			buf_nipxAdvSysEntry
#define gb_nipxAdvSysInFiltered				buf_nipxAdvSysEntry
#define gb_nipxAdvSysInCompressDiscards		buf_nipxAdvSysEntry
#define gb_nipxAdvSysNETBIOSPackets			buf_nipxAdvSysEntry
#define gb_nipxAdvSysForwPackets			buf_nipxAdvSysEntry
#define gb_nipxAdvSysOutFiltered			buf_nipxAdvSysEntry
#define gb_nipxAdvSysOutCompressDiscards	buf_nipxAdvSysEntry
#define gb_nipxAdvSysCircCount				buf_nipxAdvSysEntry
#define gb_nipxAdvSysDestCount				buf_nipxAdvSysEntry
#define gb_nipxAdvSysServCount				buf_nipxAdvSysEntry

/*
	All values in nipxAdvSysEntry are implemented as read-only
UINT
set_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxAdvSysEntry {
	AsnAny	nipxAdvSysInstance;
	AsnAny	nipxAdvSysMaxPathSplits;
	AsnAny	nipxAdvSysMaxHops;
} sav_nipxAdvSysEntry;

#define sf_nipxAdvSysInstance				set_nipxAdvSysEntry
#define sf_nipxAdvSysMaxPathSplits			set_nipxAdvSysEntry
#define sf_nipxAdvSysMaxHops				set_nipxAdvSysEntry

#define sb_nipxAdvSysInstance				sav_nipxAdvSysEntry
#define sb_nipxAdvSysMaxPathSplits			sav_nipxAdvSysEntry
#define sb_nipxAdvSysMaxHops				sav_nipxAdvSysEntry
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxCircEntry {
	AsnAny	nipxCircSysInstance;
	AsnAny	nipxCircIndex;
	AsnAny	nipxCircExistState;
	AsnAny	nipxCircOperState;
	AsnAny	nipxCircIfIndex;
	AsnAny	nipxCircName;
	AsnAny	nipxCircType;
	AsnAny	nipxCircDialName;
	AsnAny	nipxCircLocalMaxPacketSize;
	AsnAny	nipxCircCompressState;
	AsnAny	nipxCircCompressSlots;
	AsnAny	nipxCircStaticStatus;
	AsnAny	nipxCircCompressedSent;
	AsnAny	nipxCircCompressedInitSent;
	AsnAny	nipxCircCompressedRejectsSent;
	AsnAny	nipxCircUncompressedSent;
	AsnAny	nipxCircCompressedReceived;
	AsnAny	nipxCircCompressedInitReceived;
	AsnAny	nipxCircCompressedRejectsReceived;
	AsnAny	nipxCircUncompressedReceived;
	AsnAny	nipxCircMediaType;
	AsnAny	nipxCircNetNumber;
	AsnAny	nipxCircStateChanges;
	AsnAny	nipxCircInitFails;
	AsnAny	nipxCircDelay;
	AsnAny	nipxCircThroughput;
	AsnAny	nipxCircNeighRouterName;
	AsnAny	nipxCircNeighInternalNetNum;
	BYTE	NameVal[48];
	BYTE	DialNameVal[48];
	BYTE	MediaTypeVal[2];
	BYTE	NetNumberVal[4];
	BYTE	NeighRouterNameVal[48];
	BYTE	NeighInternalNetNumVal[4];
} buf_nipxCircEntry;

#define gf_nipxCircSysInstance				get_nipxCircEntry
#define gf_nipxCircIndex					get_nipxCircEntry
#define gf_nipxCircExistState				get_nipxCircEntry
#define gf_nipxCircOperState				get_nipxCircEntry
#define gf_nipxCircIfIndex					get_nipxCircEntry
#define gf_nipxCircName						get_nipxCircEntry
#define gf_nipxCircType						get_nipxCircEntry
#define gf_nipxCircDialName					get_nipxCircEntry
#define gf_nipxCircLocalMaxPacketSize		get_nipxCircEntry
#define gf_nipxCircCompressState			get_nipxCircEntry
#define gf_nipxCircCompressSlots			get_nipxCircEntry
#define gf_nipxCircStaticStatus				get_nipxCircEntry
#define gf_nipxCircCompressedSent			get_nipxCircEntry
#define gf_nipxCircCompressedInitSent		get_nipxCircEntry
#define gf_nipxCircCompressedRejectsSent	get_nipxCircEntry
#define gf_nipxCircUncompressedSent			get_nipxCircEntry
#define gf_nipxCircCompressedReceived		get_nipxCircEntry
#define gf_nipxCircCompressedInitReceived	get_nipxCircEntry
#define gf_nipxCircCompressedRejectsReceived get_nipxCircEntry
#define gf_nipxCircUncompressedReceived		get_nipxCircEntry
#define gf_nipxCircMediaType				get_nipxCircEntry
#define gf_nipxCircNetNumber				get_nipxCircEntry
#define gf_nipxCircStateChanges				get_nipxCircEntry
#define gf_nipxCircInitFails				get_nipxCircEntry
#define gf_nipxCircDelay					get_nipxCircEntry
#define gf_nipxCircThroughput				get_nipxCircEntry
#define gf_nipxCircNeighRouterName			get_nipxCircEntry
#define gf_nipxCircNeighInternalNetNum		get_nipxCircEntry

#define gb_nipxCircSysInstance				buf_nipxCircEntry
#define gb_nipxCircIndex					buf_nipxCircEntry
#define gb_nipxCircExistState				buf_nipxCircEntry
#define gb_nipxCircOperState				buf_nipxCircEntry
#define gb_nipxCircIfIndex					buf_nipxCircEntry
#define gb_nipxCircName						buf_nipxCircEntry
#define gb_nipxCircType						buf_nipxCircEntry
#define gb_nipxCircDialName					buf_nipxCircEntry
#define gb_nipxCircLocalMaxPacketSize		buf_nipxCircEntry
#define gb_nipxCircCompressState			buf_nipxCircEntry
#define gb_nipxCircCompressSlots			buf_nipxCircEntry
#define gb_nipxCircStaticStatus				buf_nipxCircEntry
#define gb_nipxCircCompressedSent			buf_nipxCircEntry
#define gb_nipxCircCompressedInitSent		buf_nipxCircEntry
#define gb_nipxCircCompressedRejectsSent	buf_nipxCircEntry
#define gb_nipxCircUncompressedSent			buf_nipxCircEntry
#define gb_nipxCircCompressedReceived		buf_nipxCircEntry
#define gb_nipxCircCompressedInitReceived	buf_nipxCircEntry
#define gb_nipxCircCompressedRejectsReceived buf_nipxCircEntry
#define gb_nipxCircUncompressedReceived		buf_nipxCircEntry
#define gb_nipxCircMediaType				buf_nipxCircEntry
#define gb_nipxCircNetNumber				buf_nipxCircEntry
#define gb_nipxCircStateChanges				buf_nipxCircEntry
#define gb_nipxCircInitFails				buf_nipxCircEntry
#define gb_nipxCircDelay					buf_nipxCircEntry
#define gb_nipxCircThroughput				buf_nipxCircEntry
#define gb_nipxCircNeighRouterName			buf_nipxCircEntry
#define gb_nipxCircNeighInternalNetNum		buf_nipxCircEntry

UINT
set_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxCircEntry {
	AsnAny	nipxCircSysInstance;		// implemented as read-only
	AsnAny	nipxCircIndex;				// implemented as read-only
//	AsnAny	nipxCircExistState;			// implemented as read-only
	AsnAny	nipxCircOperState;
//	AsnAny	nipxCircIfIndex;			// implemented as read-only
//	AsnAny	nipxCircName;				// implemented as read-only
//	AsnAny	nipxCircType;				// implemented as read-only
//	AsnAny	nipxCircDialName;			// implemented as read-only
//	AsnAny	nipxCircLocalMaxPacketSize;	// implemented as read-only
//	AsnAny	nipxCircCompressState;		// implemented as read-only
//	AsnAny	nipxCircCompressSlots;		// implemented as read-only
//	AsnAny	nipxCircStaticStatus;		// implemented as read-only
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
} sav_nipxCircEntry;

#define sf_nipxCircSysInstance				set_nipxCircEntry
#define sf_nipxCircIndex					set_nipxCircEntry
//#define sf_nipxCircExistState				set_nipxCircEntry
#define sf_nipxCircOperState				set_nipxCircEntry
//#define sf_nipxCircIfIndex				set_nipxCircEntry
//#define sf_nipxCircName					set_nipxCircEntry
//#define sf_nipxCircType					set_nipxCircEntry
//#define sf_nipxCircDialName				set_nipxCircEntry
//#define sf_nipxCircLocalMaxPacketSize		set_nipxCircEntry
//#define sf_nipxCircCompressState			set_nipxCircEntry
//#define sf_nipxCircCompressSlots			set_nipxCircEntry
//#define sf_nipxCircStaticStatus			set_nipxCircEntry

#define sb_nipxCircSysInstance				sav_nipxCircEntry
#define sb_nipxCircIndex					sav_nipxCircEntry
//#define sb_nipxCircExistState				sav_nipxCircEntry
#define sb_nipxCircOperState				sav_nipxCircEntry
//#define sb_nipxCircIfIndex				sav_nipxCircEntry
//#define sb_nipxCircName					sav_nipxCircEntry
//#define sb_nipxCircType					sav_nipxCircEntry
//#define sb_nipxCircDialName				sav_nipxCircEntry
//#define sb_nipxCircLocalMaxPacketSize		sav_nipxCircEntry
//#define sb_nipxCircCompressState			sav_nipxCircEntry
//#define sb_nipxCircCompressSlots			sav_nipxCircEntry
//#define sb_nipxCircStaticStatus			sav_nipxCircEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxDestEntry {
	AsnAny	nipxDestSysInstance;
	AsnAny	nipxDestNetNum;
	AsnAny	nipxDestProtocol;
	AsnAny	nipxDestTicks;
	AsnAny	nipxDestHopCount;
	AsnAny	nipxDestNextHopCircIndex;
	AsnAny	nipxDestNextHopNICAddress;
	AsnAny	nipxDestNextHopNetNum;
	BYTE	NetNumVal[4];
	BYTE	NextHopNICAddressVal[6];
	BYTE	NextHopNetNumVal[4];
} buf_nipxDestEntry;

#define gf_nipxDestSysInstance				get_nipxDestEntry
#define gf_nipxDestNetNum					get_nipxDestEntry
#define gf_nipxDestProtocol					get_nipxDestEntry
#define gf_nipxDestTicks					get_nipxDestEntry
#define gf_nipxDestHopCount					get_nipxDestEntry
#define gf_nipxDestNextHopCircIndex			get_nipxDestEntry
#define gf_nipxDestNextHopNICAddress		get_nipxDestEntry
#define gf_nipxDestNextHopNetNum			get_nipxDestEntry

#define gb_nipxDestSysInstance				buf_nipxDestEntry
#define gb_nipxDestNetNum					buf_nipxDestEntry
#define gb_nipxDestProtocol					buf_nipxDestEntry
#define gb_nipxDestTicks					buf_nipxDestEntry
#define gb_nipxDestHopCount					buf_nipxDestEntry
#define gb_nipxDestNextHopCircIndex			buf_nipxDestEntry
#define gb_nipxDestNextHopNICAddress		buf_nipxDestEntry
#define gb_nipxDestNextHopNetNum			buf_nipxDestEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxStaticRouteEntry {
	AsnAny	nipxStaticRouteSysInstance;
	AsnAny	nipxStaticRouteCircIndex;
	AsnAny	nipxStaticRouteNetNum;
	AsnAny	nipxStaticRouteExistState;
	AsnAny	nipxStaticRouteTicks;
	AsnAny	nipxStaticRouteHopCount;
	BYTE	NetNumVal[4];
} buf_nipxStaticRouteEntry;

#define gf_nipxStaticRouteSysInstance		get_nipxStaticRouteEntry
#define gf_nipxStaticRouteCircIndex			get_nipxStaticRouteEntry
#define gf_nipxStaticRouteNetNum			get_nipxStaticRouteEntry
#define gf_nipxStaticRouteExistState		get_nipxStaticRouteEntry
#define gf_nipxStaticRouteTicks				get_nipxStaticRouteEntry
#define gf_nipxStaticRouteHopCount			get_nipxStaticRouteEntry

#define gb_nipxStaticRouteSysInstance		buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteCircIndex			buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteNetNum			buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteExistState		buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteTicks				buf_nipxStaticRouteEntry
#define gb_nipxStaticRouteHopCount			buf_nipxStaticRouteEntry

UINT
set_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxStaticRouteEntry {
	AsnAny	nipxStaticRouteSysInstance;
	AsnAny	nipxStaticRouteCircIndex;
	AsnAny	nipxStaticRouteNetNum;
	AsnAny	nipxStaticRouteExistState;
	AsnAny	nipxStaticRouteTicks;
	AsnAny	nipxStaticRouteHopCount;
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN	ActionFlag;
} sav_nipxStaticRouteEntry;

#define sf_nipxStaticRouteSysInstance		set_nipxStaticRouteEntry
#define sf_nipxStaticRouteCircIndex			set_nipxStaticRouteEntry
#define sf_nipxStaticRouteNetNum			set_nipxStaticRouteEntry
#define sf_nipxStaticRouteExistState		set_nipxStaticRouteEntry
#define sf_nipxStaticRouteTicks				set_nipxStaticRouteEntry
#define sf_nipxStaticRouteHopCount			set_nipxStaticRouteEntry

#define sb_nipxStaticRouteSysInstance		sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteCircIndex			sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteNetNum			sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteExistState		sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteTicks				sav_nipxStaticRouteEntry
#define sb_nipxStaticRouteHopCount			sav_nipxStaticRouteEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxServEntry {
	AsnAny	nipxServSysInstance;
	AsnAny	nipxServType;
	AsnAny	nipxServName;
	AsnAny	nipxServProtocol;
	AsnAny	nipxServNetNum;
	AsnAny	nipxServNode;
	AsnAny	nipxServSocket;
	AsnAny	nipxServHopCount;
	BYTE	TypeVal[2];
	BYTE	NameVal[48];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_nipxServEntry;

#define gf_nipxServSysInstance				get_nipxServEntry
#define gf_nipxServType						get_nipxServEntry
#define gf_nipxServName						get_nipxServEntry
#define gf_nipxServProtocol					get_nipxServEntry
#define gf_nipxServNetNum					get_nipxServEntry
#define gf_nipxServNode						get_nipxServEntry
#define gf_nipxServSocket					get_nipxServEntry
#define gf_nipxServHopCount					get_nipxServEntry

#define gb_nipxServSysInstance				buf_nipxServEntry
#define gb_nipxServType						buf_nipxServEntry
#define gb_nipxServName						buf_nipxServEntry
#define gb_nipxServProtocol					buf_nipxServEntry
#define gb_nipxServNetNum					buf_nipxServEntry
#define gb_nipxServNode						buf_nipxServEntry
#define gb_nipxServSocket					buf_nipxServEntry
#define gb_nipxServHopCount					buf_nipxServEntry


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxDestServEntry {
	AsnAny	nipxDestServSysInstance;
	AsnAny	nipxDestServNetNum;
	AsnAny	nipxDestServNode;
	AsnAny	nipxDestServSocket;
	AsnAny	nipxDestServName;
	AsnAny	nipxDestServType;
	AsnAny	nipxDestServProtocol;
	AsnAny	nipxDestServHopCount;
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
	BYTE	NameVal[48];
	BYTE	TypeVal[2];
} buf_nipxDestServEntry;

#define gf_nipxDestServSysInstance			get_nipxDestServEntry
#define gf_nipxDestServNetNum				get_nipxDestServEntry
#define gf_nipxDestServNode					get_nipxDestServEntry
#define gf_nipxDestServSocket				get_nipxDestServEntry
#define gf_nipxDestServName					get_nipxDestServEntry
#define gf_nipxDestServType					get_nipxDestServEntry
#define gf_nipxDestServProtocol				get_nipxDestServEntry
#define gf_nipxDestServHopCount				get_nipxDestServEntry

#define gb_nipxDestServSysInstance			buf_nipxDestServEntry
#define gb_nipxDestServNetNum				buf_nipxDestServEntry
#define gb_nipxDestServNode					buf_nipxDestServEntry
#define gb_nipxDestServSocket				buf_nipxDestServEntry
#define gb_nipxDestServName					buf_nipxDestServEntry
#define gb_nipxDestServType					buf_nipxDestServEntry
#define gb_nipxDestServProtocol				buf_nipxDestServEntry
#define gb_nipxDestServHopCount				buf_nipxDestServEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_nipxStaticServEntry {
	AsnAny	nipxStaticServSysInstance;
	AsnAny	nipxStaticServCircIndex;
	AsnAny	nipxStaticServType;
	AsnAny	nipxStaticServName;
	AsnAny	nipxStaticServExistState;
	AsnAny	nipxStaticServNetNum;
	AsnAny	nipxStaticServNode;
	AsnAny	nipxStaticServSocket;
	AsnAny	nipxStaticServHopCount;
	BYTE	NameVal[48];
	BYTE	TypeVal[2];
	BYTE	NetNumVal[4];
	BYTE	NodeVal[6];
	BYTE	SocketVal[2];
} buf_nipxStaticServEntry;

#define gf_nipxStaticServSysInstance		get_nipxStaticServEntry
#define gf_nipxStaticServCircIndex			get_nipxStaticServEntry
#define gf_nipxStaticServType				get_nipxStaticServEntry
#define gf_nipxStaticServName				get_nipxStaticServEntry
#define gf_nipxStaticServExistState			get_nipxStaticServEntry
#define gf_nipxStaticServNetNum				get_nipxStaticServEntry
#define gf_nipxStaticServNode				get_nipxStaticServEntry
#define gf_nipxStaticServSocket				get_nipxStaticServEntry
#define gf_nipxStaticServHopCount			get_nipxStaticServEntry

#define gb_nipxStaticServSysInstance		buf_nipxStaticServEntry
#define gb_nipxStaticServCircIndex			buf_nipxStaticServEntry
#define gb_nipxStaticServType				buf_nipxStaticServEntry
#define gb_nipxStaticServName				buf_nipxStaticServEntry
#define gb_nipxStaticServExistState			buf_nipxStaticServEntry
#define gb_nipxStaticServNetNum				buf_nipxStaticServEntry
#define gb_nipxStaticServNode				buf_nipxStaticServEntry
#define gb_nipxStaticServSocket				buf_nipxStaticServEntry
#define gb_nipxStaticServHopCount			buf_nipxStaticServEntry

UINT
set_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _sav_nipxStaticServEntry {
	AsnAny	nipxStaticServSysInstance;
	AsnAny	nipxStaticServCircIndex;
	AsnAny	nipxStaticServType;
	AsnAny	nipxStaticServName;
	AsnAny	nipxStaticServExistState;
	AsnAny	nipxStaticServNetNum;
	AsnAny	nipxStaticServNode;
	AsnAny	nipxStaticServSocket;
	AsnAny	nipxStaticServHopCount;
	IPX_MIB_SET_INPUT_DATA	MibSetInputData;
	BOOLEAN	ActionFlag;
} sav_nipxStaticServEntry;

#define sf_nipxStaticServSysInstance		set_nipxStaticServEntry
#define sf_nipxStaticServCircIndex			set_nipxStaticServEntry
#define sf_nipxStaticServType				set_nipxStaticServEntry
#define sf_nipxStaticServName				set_nipxStaticServEntry
#define sf_nipxStaticServExistState			set_nipxStaticServEntry
#define sf_nipxStaticServNetNum				set_nipxStaticServEntry
#define sf_nipxStaticServNode				set_nipxStaticServEntry
#define sf_nipxStaticServSocket				set_nipxStaticServEntry
#define sf_nipxStaticServHopCount			set_nipxStaticServEntry

#define sb_nipxStaticServSysInstance		sav_nipxStaticServEntry
#define sb_nipxStaticServCircIndex			sav_nipxStaticServEntry
#define sb_nipxStaticServType				sav_nipxStaticServEntry
#define sb_nipxStaticServName				sav_nipxStaticServEntry
#define sb_nipxStaticServExistState			sav_nipxStaticServEntry
#define sb_nipxStaticServNetNum				sav_nipxStaticServEntry
#define sb_nipxStaticServNode				sav_nipxStaticServEntry
#define sb_nipxStaticServSocket				sav_nipxStaticServEntry
#define sb_nipxStaticServHopCount			sav_nipxStaticServEntry


#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\nipxf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nipxf.c

Abstract:

    Novell-ipx instrumentation callbacks.

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Bseb	((buf_nipxBasicSysEntry *)objectArray)
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			Bep;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Bseb->nipxBasicSysInstance,NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXBASICSYSENTRY, ("NIPX-BSE: ipxBasicSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GETNEXT:
		if (!Bseb->nipxBasicSysInstance.asnType) {
			ForceAsnInteger (&Bseb->nipxBasicSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
			rc = MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXBASICSYSENTRY,
				("NIPX-BSE: End of table reached on GETFIRST/GETNEXT request for instance %ld.\n",
									GetAsnInteger (&Bseb->nipxBasicSysInstance,NIPX_INVALID_SYS_INSTANCE)));
			rc = MIB_S_NO_MORE_ENTRIES;
			break;
		}

	case MIB_ACTION_GET:
		MibGetInputData.TableId = IPX_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Bep,
								&BeSize);
		if (rc==NO_ERROR) {
			SetAsnInteger (&Bseb->nipxBasicSysExistState, NIPX_STATE_ON);
			SetAsnOctetString (&Bseb->nipxBasicSysNetNumber, Bseb->NetNumberVal,
						Bep->PrimaryNetNumber, sizeof (Bseb->NetNumberVal));
			SetAsnOctetString (&Bseb->nipxBasicSysNode, Bseb->NodeVal,
						Bep->Node, sizeof (Bseb->NodeVal));
			SetAsnDispString (&Bseb->nipxBasicSysName, Bseb->NameVal,
						Bep->SysName, sizeof (Bseb->NameVal));
			SetAsnCounter (&Bseb->nipxBasicSysInReceives, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInHdrErrors, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInUnknownSockets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInDiscards, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInBadChecksums, 0);
			SetAsnCounter (&Bseb->nipxBasicSysInDelivers, 0);
			SetAsnCounter (&Bseb->nipxBasicSysNoRoutes, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutRequests, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutMalformedRequests, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutDiscards, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOutPackets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysConfigSockets, 0);
			SetAsnCounter (&Bseb->nipxBasicSysOpenSocketFails, 0);
			MprAdminMIBBufferFree (Bep);
			DbgTrace (DBG_NIPXBASICSYSENTRY, ("NIPX-BSE: Get request succeded.\n"));
			rc = MIB_S_SUCCESS;
		}
		else {
		    // 
		    // pmay.  Added this so mib walk wouldn't fail with
		    // GENERR.
		    //
		    rc = MIB_S_NO_MORE_ENTRIES;
		}
		break;
	default:
		DbgTrace (DBG_NIPXBASICSYSENTRY, 
				("NIPX-BSE: Get called with unsupported action code %d.\n",
				actionId));
		rc = MIB_S_INVALID_PARAMETER;
		break;
	}

	return rc;
#undef Bseb
}


/*
	All values in nipxBasicSysEntry are implemented as read-only
UINT
set_nipxBasicSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	return MIB_S_ENTRY_NOT_FOUND;
}
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Aseb	((buf_nipxAdvSysEntry *)objectArray)
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			Bep;
	DWORD					rc;
	ULONG					BeSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Aseb->nipxAdvSysInstance,NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXADVSYSENTRY, ("NIPX-ASE: nipxAdvSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_GETNEXT:
		if (!Aseb->nipxAdvSysInstance.asnType) {
			ForceAsnInteger (&Aseb->nipxAdvSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		}
		else {
			DbgTrace (DBG_NIPXADVSYSENTRY,
				("NIPX-ASE: End of table reached on GETFIRST/GETNEXT request for instance %ld.\n",
									GetAsnInteger (&Aseb->nipxAdvSysInstance,NIPX_INVALID_SYS_INSTANCE)));
			rc = MIB_S_NO_MORE_ENTRIES;
			break;
		}

	case MIB_ACTION_GET:
		MibGetInputData.TableId = IPX_BASE_ENTRY;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Bep,
								&BeSize);
		if (rc == NO_ERROR && Bep != NULL) {
			SetAsnInteger (&Aseb->nipxAdvSysMaxPathSplits, Bep->MaxPathSplits);
			SetAsnInteger (&Aseb->nipxAdvSysMaxHops, 16);
			SetAsnCounter (&Aseb->nipxAdvSysInTooManyHops, 0);
			SetAsnCounter (&Aseb->nipxAdvSysInFiltered, 0);
			SetAsnCounter (&Aseb->nipxAdvSysInCompressDiscards, 0);
			SetAsnCounter (&Aseb->nipxAdvSysNETBIOSPackets, 0);
			SetAsnCounter (&Aseb->nipxAdvSysForwPackets, 0);
			SetAsnCounter (&Aseb->nipxAdvSysOutFiltered, 0);
			SetAsnCounter (&Aseb->nipxAdvSysOutCompressDiscards, 0);
			SetAsnCounter (&Aseb->nipxAdvSysCircCount, Bep->IfCount);
			SetAsnCounter (&Aseb->nipxAdvSysDestCount, Bep->DestCount);
			SetAsnCounter (&Aseb->nipxAdvSysServCount, Bep->ServCount);
			MprAdminMIBBufferFree (Bep);
			DbgTrace (DBG_NIPXADVSYSENTRY, ("NIPX-ASE: Get request succeded.\n"));
		}
		else {
		    // 
		    // pmay.  Added this so mib walk wouldn't fail with
		    // GENERR.
		    //
		    rc = MIB_S_NO_MORE_ENTRIES;
		}
		break;
	default:
		DbgTrace (DBG_NIPXADVSYSENTRY, 
				("NIPX-ASE: Get called with unsupported action code %d.\n",
				actionId));
		rc = MIB_S_INVALID_PARAMETER;
		break;
	}
	return rc;
#undef Aseb
}

/*
	All values in nipxAdvSysEntry are implemented as read-only
UINT
set_nipxAdvSysEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	return MIB_S_ENTRY_NOT_FOUND;
}
*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ceb	((buf_nipxCircEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	if (GetAsnInteger (&Ceb->nipxCircSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: nipxCircSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex 
				= (ULONG)GetAsnInteger (&Ceb->nipxCircIndex, ZERO_INTERFACE_INDEX);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Ceb->nipxCircSysInstance.asnType
							&&Ceb->nipxCircIndex.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Ceb->nipxCircIndex.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Ceb->nipxCircSysInstance.asnType);
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		}
		else
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		
		break;
	default:
		DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Ifp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Get(%d) request succeded for if %ld->%ld.\n",
				actionId,
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex,
				Ifp->InterfaceIndex));
		ForceAsnInteger (&Ceb->nipxCircSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Ceb->nipxCircIndex, Ifp->InterfaceIndex);
		SetAsnInteger (&Ceb->nipxCircExistState, NIPX_STATE_ON);
		SetAsnInteger (&Ceb->nipxCircOperState, Ifp->IfStats.IfOperState);
		SetAsnInteger (&Ceb->nipxCircIfIndex, Ifp->AdapterIndex);
		SetAsnDispString (&Ceb->nipxCircName, Ceb->NameVal,
						Ifp->InterfaceName, sizeof (Ceb->NameVal));
		switch (Ifp->InterfaceType) {
		case IF_TYPE_OTHER:
		case IF_TYPE_INTERNAL:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_OTHER);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						"", sizeof (Ceb->DialNameVal));
			break;
		case IF_TYPE_LAN:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_BCAST);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						"", sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						"", sizeof (Ceb->NeighRouterNameVal));
			break;
		case IF_TYPE_WAN_ROUTER:
		case IF_TYPE_PERSONAL_WAN_ROUTER:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_DYNAMIC);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						Ifp->InterfaceName, sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						Ifp->InterfaceName, sizeof (Ceb->NeighRouterNameVal));
						
			break;

		case IF_TYPE_WAN_WORKSTATION:
		case IF_TYPE_ROUTER_WORKSTATION_DIALOUT:
		case IF_TYPE_STANDALONE_WORKSTATION_DIALOUT:
			SetAsnInteger (&Ceb->nipxCircType, NIPX_CIRCTYPE_WANWS);
			SetAsnDispString (&Ceb->nipxCircDialName, Ceb->DialNameVal,
						Ifp->InterfaceName, sizeof (Ceb->DialNameVal));
			SetAsnDispString (&Ceb->nipxCircNeighRouterName, Ceb->NeighRouterNameVal,
						"", sizeof (Ceb->NeighRouterNameVal));
			break;
		}

		SetAsnInteger (&Ceb->nipxCircLocalMaxPacketSize, Ifp->IfStats.MaxPacketSize);
		SetAsnInteger (&Ceb->nipxCircCompressState, NIPX_STATE_OFF);
		SetAsnInteger (&Ceb->nipxCircCompressSlots, 16);
		SetAsnInteger (&Ceb->nipxCircStaticStatus, NIPX_STATIC_STATUS_UNKNOWN);
		SetAsnCounter (&Ceb->nipxCircCompressedSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedInitSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedRejectsSent, 0);
		SetAsnCounter (&Ceb->nipxCircUncompressedSent, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedReceived, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedInitReceived, 0);
		SetAsnCounter (&Ceb->nipxCircCompressedRejectsReceived, 0);
		SetAsnCounter (&Ceb->nipxCircUncompressedReceived, 0);
		SetAsnMediaType (&Ceb->nipxCircMediaType, Ceb->MediaTypeVal, Ifp->MediaType);
		SetAsnOctetString (&Ceb->nipxCircNetNumber, Ceb->NetNumberVal,
						Ifp->NetNumber, sizeof (Ceb->NetNumberVal));
		SetAsnCounter (&Ceb->nipxCircStateChanges, 0);
		SetAsnCounter (&Ceb->nipxCircInitFails, 0);
		SetAsnInteger (&Ceb->nipxCircDelay, Ifp->Delay);
		SetAsnInteger (&Ceb->nipxCircThroughput, Ifp->Throughput);
		SetAsnOctetString (&Ceb->nipxCircNeighInternalNetNum, Ceb->NeighInternalNetNumVal,
						ZERO_NET_NUM, sizeof (Ceb->NeighInternalNetNumVal));
					
		MprAdminMIBBufferFree (Ifp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXCIRCENTRY,
			("NIPX-Circ: End of table reached on GETFIRST/GETNEXT request for if %ld.\n",
								MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXCIRCENTRY,
			("NIPX-Circ: Get request for if %ld failed with error %ld.\n", 
			MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Ceb
}

UINT
set_nipxCircEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Ceb	((sav_nipxCircEntry *)objectArray)
	PIPX_INTERFACE			Ifp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					IfSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Ceb->nipxCircSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: nipxCircSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	
	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
							Ceb->nipxCircSysInstance.asnType
							&&Ceb->nipxCircIndex.asnType);
		MibGetInputData.TableId = IPX_INTERFACE_TABLE;
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
				=  (ULONG)GetAsnInteger (&Ceb->nipxCircIndex, INVALID_INTERFACE_INDEX);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Ifp,
									&IfSize);
		if ((rc==NO_ERROR) && (Ifp != NULL)) {
			Ceb->MibSetInputData.MibRow.Interface = *Ifp;
			MprAdminMIBBufferFree (Ifp);
			if (Ceb->nipxCircOperState.asnType) {
				switch (GetAsnInteger(&Ceb->nipxCircOperState, OPER_STATE_SLEEPING)) {
				case OPER_STATE_DOWN:
					Ceb->MibSetInputData.MibRow.Interface.AdminState = ADMIN_STATE_DISABLED;
					break;
				case OPER_STATE_UP:
					Ceb->MibSetInputData.MibRow.Interface.AdminState = ADMIN_STATE_ENABLED;
					break;
				default:
					DbgTrace (DBG_NIPXCIRCENTRY,
						("NIPX-Circ: Validate failed: invalid oper state: %d.\n",
						GetAsnInteger(&Ceb->nipxCircOperState, OPER_STATE_SLEEPING)));
					return MIB_S_INVALID_PARAMETER;
				}
			}
			DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Validated if %ld.\n",
						MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Validate failed on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
	case MIB_ACTION_SET:
		rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Ceb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXCIRCENTRY, ("NIPX-Circ: Set succeded on if %ld\n",
					Ceb->MibSetInputData.MibRow.Interface.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Set failed on if %ld with error %ld\n",
					Ceb->MibSetInputData.MibRow.Interface.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXCIRCENTRY,
				("NIPX-Circ: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Ceb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Deb	((buf_nipxDestEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Deb->nipxDestSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXDESTENTRY, ("NIPX-Dest: nipxDestSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_DEST_TABLE;
	GetAsnOctetString (MibGetInputData.MibIndex.RoutingTableIndex.Network,
				&Deb->nipxDestNetNum,
				sizeof (MibGetInputData.MibIndex.RoutingTableIndex.Network),
				ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
						Deb->nipxDestSysInstance.asnType
						&&Deb->nipxDestNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Deb->nipxDestNetNum.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Deb->nipxDestSysInstance.asnType);
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Deb->nipxDestNetNum);
			}
		}
		else
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
		break;
	default:
		DbgTrace (DBG_NIPXDESTENTRY,
			("NIPX-Dest: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x.\n", actionId,
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3]));
		ForceAsnInteger (&Deb->nipxDestSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnOctetString (&Deb->nipxDestNetNum, Deb->NetNumVal,
							Rtp->Network, sizeof (Deb->NetNumVal));
        switch (Rtp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Deb->nipxDestProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Deb->nipxDestProtocol, 5);
            break;
        case IPX_PROTOCOL_RIP:
		    SetAsnInteger (&Deb->nipxDestProtocol, 3);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Deb->nipxDestProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Deb->nipxDestProtocol, 1);  // other
            break;
        }
		SetAsnInteger (&Deb->nipxDestTicks, Rtp->TickCount);          
		SetAsnInteger (&Deb->nipxDestHopCount, Rtp->HopCount);
		SetAsnInteger (&Deb->nipxDestNextHopCircIndex, Rtp->InterfaceIndex);
		SetAsnOctetString (&Deb->nipxDestNextHopNICAddress, Deb->NextHopNICAddressVal,
							Rtp->NextHopMacAddress, sizeof (Deb->NextHopNICAddressVal));
		SetAsnOctetString (&Deb->nipxDestNextHopNetNum, Deb->NextHopNetNumVal,
							ZERO_NET_NUM, sizeof (Deb->NextHopNetNumVal));
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: End of table reached on GETFIRST/GETNEXT request"
					" for network %.2x%.2x%.2x%.2x.\n",
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3]));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXDESTENTRY,
				("NIPX-Dest: Get request for network %.2x%.2x%.2x%.2x"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.RoutingTableIndex.Network[0],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[1],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[2],
				MibGetInputData.MibIndex.RoutingTableIndex.Network[3], rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Deb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sreb	((buf_nipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: nipxStaticRouteSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
	MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex, ZERO_INTERFACE_INDEX);
	GetAsnOctetString (
		MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
		&Sreb->nipxStaticRouteNetNum,
		sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
		ZERO_NET_NUM);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Sreb->nipxStaticRouteSysInstance.asnType
							&&Sreb->nipxStaticRouteCircIndex.asnType
							&&Sreb->nipxStaticRouteNetNum.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Sreb->nipxStaticRouteCircIndex.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Sreb->nipxStaticRouteSysInstance.asnType);
			if (!Sreb->nipxStaticRouteNetNum.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Rtp,
											&RtSize);
				if (rc==NO_ERROR)
					break;
			}

			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Rtp,
										&RtSize);
			if (rc==NO_ERROR) {
				if (Sreb->nipxStaticRouteNetNum.asnType) {
					FreeAsnString (&Sreb->nipxStaticRouteNetNum);
				}
			}
		}
		else {
			ASSERTMSG ("Third index is present but second is not ",
								!Sreb->nipxStaticRouteNetNum.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(IPX_MIB_GET_INPUT_DATA),
								&Rtp,
								&RtSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}

    if (rc == NO_ERROR && Rtp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }

	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get(%d) request succeded for net"
					" %.2x%.2x%.2x%.2x -> %.2x%.2x%.2x%.2x on if %ld\n", actionId,
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				Rtp->Network[0],
				Rtp->Network[1],
				Rtp->Network[2],
				Rtp->Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Sreb->nipxStaticRouteCircIndex, Rtp->InterfaceIndex);
		ForceAsnOctetString (&Sreb->nipxStaticRouteNetNum, Sreb->NetNumVal,
							Rtp->Network, sizeof (Sreb->NetNumVal));
		SetAsnInteger (&Sreb->nipxStaticRouteExistState, NIPX_STATE_ON);
		SetAsnInteger (&Sreb->nipxStaticRouteTicks, Rtp->TickCount);          
		SetAsnInteger (&Sreb->nipxStaticRouteHopCount, Rtp->HopCount);
		MprAdminMIBBufferFree (Rtp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
										actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: End of table reached on GETFIRST/GETNEXT request for network"
					" %.2x%.2x%.2x%.2x on if %ld.\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 1;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Get request for network %.2x%.2x%.2x%.2x."
					" on if %ld failed with error %ld.\n", 
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Sreb
}

UINT
set_nipxStaticRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sreb	((sav_nipxStaticRouteEntry *)objectArray)
	PIPX_ROUTE				Rtp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					RtSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sreb->nipxStaticRouteSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: nipxStaticRouteSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
						Sreb->nipxStaticRouteCircIndex.asnType
						&&Sreb->nipxStaticRouteNetNum.asnType);
		MibGetInputData.TableId = IPX_STATIC_ROUTE_TABLE;
		MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex,INVALID_INTERFACE_INDEX);
		GetAsnOctetString (
			MibGetInputData.MibIndex.StaticRoutesTableIndex.Network,
			&Sreb->nipxStaticRouteNetNum,
			sizeof (MibGetInputData.MibIndex.StaticRoutesTableIndex.Network),
			INVALID_NET_NUM);
		Sreb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Sreb->nipxStaticRouteExistState,
			NIPX_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Rtp,
									&RtSize);
        if (rc == NO_ERROR && Rtp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Validate failed"
					" for network %.2x.2x.2x.2x on if %ld with error %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex,rc));
			return MIB_S_ENTRY_NOT_FOUND;
        }
		if (rc==NO_ERROR) {
			Sreb->MibSetInputData.MibRow.Route = *Rtp;
			if (Sreb->ActionFlag == NIPX_STATE_ON)
				Sreb->ActionFlag = NIPX_STATE_NOACTION;
			MprAdminMIBBufferFree (Rtp);
			DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: Validated"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
		}
		else if (Sreb->ActionFlag == MIPX_EXIST_STATE_CREATED) {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
					("NIPX-staticRoutes: Prepared to add"
					" network %.2x.2x.2x.2x on if %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex));
			Sreb->MibSetInputData.MibRow.Route.InterfaceIndex
				= (ULONG)GetAsnInteger (&Sreb->nipxStaticRouteCircIndex,
					INVALID_INTERFACE_INDEX);
			GetAsnOctetString (Sreb->MibSetInputData.MibRow.Route.Network,
					&Sreb->nipxStaticRouteNetNum,
					sizeof (Sreb->MibSetInputData.MibRow.Route.Network),
					NULL);
			Sreb->MibSetInputData.MibRow.Route.Protocol = IPX_PROTOCOL_STATIC;
			Sreb->MibSetInputData.MibRow.Route.Flags = 0;
			Sreb->MibSetInputData.MibRow.Route.TickCount = MAXSHORT;
			Sreb->MibSetInputData.MibRow.Route.HopCount = 15;
			memset (Sreb->MibSetInputData.MibRow.Route.NextHopMacAddress,
					0xFF,
					sizeof (Sreb->MibSetInputData.MibRow.Route.NextHopMacAddress));
		}
		else {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Validate failed"
					" for network %.2x.2x.2x.2x on if %ld with error %ld\n",
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[0],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[1],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[2],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.Network[3],
				MibGetInputData.MibIndex.StaticRoutesTableIndex.InterfaceIndex,rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		Sreb->MibSetInputData.MibRow.Route.TickCount
			= (USHORT)GetAsnInteger (&Sreb->nipxStaticRouteTicks,
				Sreb->MibSetInputData.MibRow.Route.TickCount);
		Sreb->MibSetInputData.MibRow.Route.HopCount
			= (USHORT)GetAsnInteger (&Sreb->nipxStaticRouteHopCount,
				Sreb->MibSetInputData.MibRow.Route.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Sreb->ActionFlag) {
		case MIPX_EXIST_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_DELETED:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case MIPX_EXIST_STATE_CREATED:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sreb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}
		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set succeded for"
					" network %.2x.2x.2x.2x on if %ld\n",
				Sreb->MibSetInputData.MibRow.Route.Network[0],
				Sreb->MibSetInputData.MibRow.Route.Network[1],
				Sreb->MibSetInputData.MibRow.Route.Network[2],
				Sreb->MibSetInputData.MibRow.Route.Network[3],
				Sreb->MibSetInputData.MibRow.Route.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set failed for"
					" network %.2x.2x.2x.2x on if %ld with error %ld\n",
				Sreb->MibSetInputData.MibRow.Route.Network[0],
				Sreb->MibSetInputData.MibRow.Route.Network[1],
				Sreb->MibSetInputData.MibRow.Route.Network[2],
				Sreb->MibSetInputData.MibRow.Route.Network[3],
				Sreb->MibSetInputData.MibRow.Route.InterfaceIndex, rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXSTATICRTENTRY,
				("NIPX-staticRoutes: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Sreb
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Seb	((buf_nipxServEntry *)objectArray)
	PIPX_SERVICE			Svp, SvpCur;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;
	INT						lenPrev, lenNext, lenCur;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Seb->nipxServSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSERVENTRY, ("NIPX-Serv: nipxServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_SERV_TABLE;
	MibGetInputData.MibIndex.ServicesTableIndex.ServiceType
		= GetAsnServType (&Seb->nipxServType, ZERO_SERVER_TYPE);
	GetAsnDispString (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
			&Seb->nipxServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
					Seb->nipxServSysInstance.asnType
					&&Seb->nipxServType.asnType
					&& Seb->nipxServName.asnType);
			
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Seb->nipxServType.asnType) {
			ASSERTMSG ("Second index is present but first is not ",
								Seb->nipxServSysInstance.asnType);

			if (!Seb->nipxServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					FreeAsnString (&Seb->nipxServType);
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
			if (rc==NO_ERROR) {
				FreeAsnString (&Seb->nipxServType);
				if (Seb->nipxServName.asnType) {
					FreeAsnString (&Seb->nipxServName);
				}
			}
		}
		else {
			ASSERTMSG ("Third index is present but second is not ",
									!Seb->nipxServName.asnType);
			rc = MprAdminMIBEntryGetFirst(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSERVENTRY,
			("NIPX-Serv: Get called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: Get(%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s.\n", actionId,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name));
		ForceAsnInteger (&Seb->nipxServSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnServType (&Seb->nipxServType, Seb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Seb->nipxServName, Seb->NameVal,
					Svp->Server.Name, sizeof (Seb->NameVal));
        switch (Svp->Protocol) {
        case IPX_PROTOCOL_LOCAL:
	    	SetAsnInteger (&Seb->nipxServProtocol, 2);
            break;
        case IPX_PROTOCOL_STATIC:
    		SetAsnInteger (&Seb->nipxServProtocol, 5);
            break;
        case IPX_PROTOCOL_SAP:
		    SetAsnInteger (&Seb->nipxServProtocol, 6);
            break;
        case IPX_PROTOCOL_NLSP:
		    SetAsnInteger (&Seb->nipxServProtocol, 4);
            break;
        default:
    		SetAsnInteger (&Seb->nipxServProtocol, 1);  // other
            break;
        }
		SetAsnOctetString (&Seb->nipxServNetNum, Seb->NetNumVal,
					Svp->Server.Network, sizeof (Seb->NetNumVal));
		SetAsnOctetString (&Seb->nipxServNode, Seb->NodeVal,
					Svp->Server.Node, sizeof (Seb->NodeVal));
		SetAsnOctetString (&Seb->nipxServSocket, Seb->SocketVal,
					Svp->Server.Socket, sizeof (Seb->SocketVal));
		SetAsnInteger (&Seb->nipxServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
												actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s.\n",
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSERVENTRY,
				("NIPX-Serv: Get request for service %.4x-%.48s"
					" failed with error %ld.\n", 
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName, rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Seb
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxDestServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
	switch (actionId) {
	case MIB_ACTION_GET:
		return MIB_S_ENTRY_NOT_FOUND;
	case MIB_ACTION_GETNEXT:
		return MIB_S_NO_MORE_ENTRIES;
	default:
		return MIB_S_INVALID_PARAMETER;
	}
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sseb	((buf_nipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}

	if (GetAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_DEFAULT_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY, ("NIPX-StaticServ: nipxStaticServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}

	MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
	MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
		= (ULONG)GetAsnInteger (&Sseb->nipxStaticServCircIndex,
			ZERO_INTERFACE_INDEX);
	MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
		= GetAsnServType (&Sseb->nipxStaticServType, ZERO_SERVER_TYPE);
	GetAsnDispString (
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
		&Sseb->nipxStaticServName, ZERO_SERVER_NAME);

	switch (actionId) {
	case MIB_ACTION_GET:
		ASSERTMSG ("No index in GET request for table ",
							Sseb->nipxStaticServSysInstance.asnType
							&&Sseb->nipxStaticServCircIndex.asnType
							&&Sseb->nipxStaticServType.asnType
							&&Sseb->nipxStaticServName.asnType);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		break;
	case MIB_ACTION_GETNEXT:
		if (Sseb->nipxStaticServCircIndex.asnType) {
			if (!Sseb->nipxStaticServType.asnType
					|| !Sseb->nipxStaticServName.asnType) {
				rc = MprAdminMIBEntryGet(g_MibServerHandle,
											PID_IPX,
											IPX_PROTOCOL_BASE,
											&MibGetInputData,
											sizeof(IPX_MIB_GET_INPUT_DATA),
											&Svp,
											&SvSize);
				if (rc==NO_ERROR) {
					if (Sseb->nipxStaticServType.asnType) {
						FreeAsnString (&Sseb->nipxStaticServType);
					}
					if (Sseb->nipxStaticServName.asnType) {
						FreeAsnString (&Sseb->nipxStaticServName);
					}
					break;
				}
			}
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
			if (rc==NO_ERROR) {
				if (Sseb->nipxStaticServType.asnType) {
					FreeAsnString (&Sseb->nipxStaticServType);
				}
				if (Sseb->nipxStaticServName.asnType) {
					FreeAsnString (&Sseb->nipxStaticServName);
				}
			}
		}
		else {
			ASSERTMSG ("Third or fourth indeces present but first is not ",
							!Sseb->nipxStaticServType.asnType
							&&!Sseb->nipxStaticServName.asnType);
			rc = MprAdminMIBEntryGetFirst (g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
		}
		break;
	default:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get called with unsupported action code %d.\n",
			actionId));
		return MIB_S_INVALID_PARAMETER;
	}
    if (rc == NO_ERROR && Svp == NULL)
    {
        rc = ERROR_CAN_NOT_COMPLETE;
    }
	switch (rc) {
	case NO_ERROR:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get (%d) request succeded for service"
					" %.4x-%.48s -> %.4x-%.48s on if %ld.\n", actionId,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				Svp->Server.Type, Svp->Server.Name,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		ForceAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_DEFAULT_SYS_INSTANCE);
		ForceAsnInteger (&Sseb->nipxStaticServCircIndex, Svp->InterfaceIndex);
		ForceAsnServType (&Sseb->nipxStaticServType, Sseb->TypeVal, Svp->Server.Type);
		ForceAsnDispString (&Sseb->nipxStaticServName, Sseb->NameVal,
							Svp->Server.Name, sizeof (Sseb->NameVal));
		SetAsnInteger (&Sseb->nipxStaticServExistState, NIPX_STATE_ON);
		SetAsnOctetString (&Sseb->nipxStaticServNetNum, Sseb->NetNumVal,
							Svp->Server.Network, sizeof (Sseb->NetNumVal));
		SetAsnOctetString (&Sseb->nipxStaticServNode, Sseb->NodeVal,
							Svp->Server.Node, sizeof (Sseb->NodeVal));
		SetAsnOctetString (&Sseb->nipxStaticServSocket, Sseb->SocketVal,
							Svp->Server.Socket, sizeof (Sseb->SocketVal));
		SetAsnInteger (&Sseb->nipxStaticServHopCount, Svp->Server.HopCount);
		MprAdminMIBBufferFree (Svp);
		return MIB_S_SUCCESS;
	case ERROR_NO_MORE_ITEMS:
		ASSERTMSG ("ERROR_NO_MORE_ITEMS returned, but request is not GETNEXT ",
											actionId==MIB_ACTION_GETNEXT);
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: End of table reached on GETFIRST/GETNEXT request"
					" for service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		return MIB_S_NO_MORE_ENTRIES;
	default:
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
			("NIPX-StaticServ: Get request for service %.4x-%.48s"
					" on if %ld failed with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
		return MIB_S_ENTRY_NOT_FOUND;
	}
#undef Sseb

}

UINT
set_nipxStaticServEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    ) {
#define Sseb	((sav_nipxStaticServEntry *)objectArray)
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;

	if (!EnsureRouterConnection()) {
		*errorIndex = 0;
		return MIB_S_ENTRY_NOT_FOUND;
	}
	if (GetAsnInteger (&Sseb->nipxStaticServSysInstance, NIPX_INVALID_SYS_INSTANCE)!=NIPX_DEFAULT_SYS_INSTANCE) {
		*errorIndex = 0;
		DbgTrace (DBG_NIPXSTATICSERVENTRY, ("NIPX-StaticServ: nipxStaticServSysInstance is not 0.\n"));
		return MIB_S_ENTRY_NOT_FOUND;
	}


	switch (actionId) {
	case MIB_ACTION_VALIDATE:
		ASSERTMSG ("No index in VALIDATE request for table ",
							Sseb->nipxStaticServSysInstance.asnType
							&&Sseb->nipxStaticServCircIndex.asnType
							&&Sseb->nipxStaticServType.asnType
							&&Sseb->nipxStaticServName.asnType);
		MibGetInputData.TableId = IPX_STATIC_SERV_TABLE;
		MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex
			= (ULONG)GetAsnInteger (&Sseb->nipxStaticServCircIndex,
				INVALID_INTERFACE_INDEX);
		MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType
			= GetAsnServType (&Sseb->nipxStaticServType, INVALID_SERVER_TYPE);
		GetAsnDispString (
			MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
			&Sseb->nipxStaticServName,
			INVALID_SERVER_NAME);
		Sseb->ActionFlag
			= (BOOLEAN)GetAsnInteger (&Sseb->nipxStaticServExistState,
			NIPX_STATE_NOACTION);
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
        if (rc == NO_ERROR && Svp == NULL)
        {
            rc = ERROR_CAN_NOT_COMPLETE;
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
        }			
		if (rc==NO_ERROR) {
			Sseb->MibSetInputData.MibRow.Service = *Svp;
			if (Sseb->ActionFlag == NIPX_STATE_ON)
				Sseb->ActionFlag = NIPX_STATE_NOACTION;
			MprAdminMIBBufferFree (Svp);
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validated"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
		}
		else if (Sseb->ActionFlag == NIPX_STATE_ON) {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Prepared to add"
					" service %.4x-%.48s on if %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex));
			Sseb->MibSetInputData.MibRow.Service.InterfaceIndex
				= (ULONG) GetAsnInteger (&Sseb->nipxStaticServCircIndex,
					INVALID_INTERFACE_INDEX);
			Sseb->MibSetInputData.MibRow.Service.Protocol = IPX_PROTOCOL_STATIC;
			Sseb->MibSetInputData.MibRow.Service.Server.Type
				= GetAsnServType (&Sseb->nipxStaticServType,
					INVALID_SERVER_TYPE);
			GetAsnDispString (
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				&Sseb->nipxStaticServName,
				INVALID_SERVER_NAME);
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Network, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Network));
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Node, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Node));
			memset (Sseb->MibSetInputData.MibRow.Service.Server.Socket, 0,
					sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Socket));
			Sseb->MibSetInputData.MibRow.Service.Server.HopCount = 15;
		}
		else {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Validate failed"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceType,
				MibGetInputData.MibIndex.StaticServicesTableIndex.ServiceName,
				MibGetInputData.MibIndex.StaticServicesTableIndex.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Network,
			&Sseb->nipxStaticServNetNum,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Network),
			NULL);
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Node,
			&Sseb->nipxStaticServNode,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Node),
			NULL);
		GetAsnOctetString (Sseb->MibSetInputData.MibRow.Service.Server.Socket,
			&Sseb->nipxStaticServSocket,
			sizeof (Sseb->MibSetInputData.MibRow.Service.Server.Socket),
			NULL);
		Sseb->MibSetInputData.MibRow.Service.Server.HopCount =
			(USHORT)GetAsnInteger (&Sseb->nipxStaticServHopCount,
			Sseb->MibSetInputData.MibRow.Service.Server.HopCount);
		return MIB_S_SUCCESS;
	case MIB_ACTION_SET:
		switch (Sseb->ActionFlag) {
		case NIPX_STATE_NOACTION:
			rc = MprAdminMIBEntrySet (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case NIPX_STATE_OFF:
			rc = MprAdminMIBEntryDelete (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		case NIPX_STATE_ON:
			rc = MprAdminMIBEntryCreate (g_MibServerHandle,
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&Sseb->MibSetInputData,
								sizeof(IPX_MIB_SET_INPUT_DATA));
			break;
		}

		if (rc==NO_ERROR) {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set succeded"
					" for service %.4x-%.48s on if %ld.\n",
				Sseb->MibSetInputData.MibRow.Service.Server.Type,
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				Sseb->MibSetInputData.MibRow.Service.InterfaceIndex));
			return MIB_S_SUCCESS;
		}
		else {
			DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set failed for"
					" for service %.4x-%.48s on if %ld with error %ld.\n",
				Sseb->MibSetInputData.MibRow.Service.Server.Type,
				Sseb->MibSetInputData.MibRow.Service.Server.Name,
				Sseb->MibSetInputData.MibRow.Service.InterfaceIndex,
				rc));
			return MIB_S_ENTRY_NOT_FOUND;
		}

	case MIB_ACTION_CLEANUP:
		return MIB_S_SUCCESS;
	default:
		DbgTrace (DBG_NIPXSTATICSERVENTRY,
				("NIPX-StaticServ: Set called with unsupported action code %d.\n",
				actionId));
		return MIB_S_INVALID_PARAMETER;
	}
#undef Sseb
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\precomp.h ===
#ifdef UNICODE
#define _UNICODE
#include <stdlib.h>
#endif

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <malloc.h>
#include <snmp.h>
#include <snmpexts.h>

#include "mprapi.h"
#include "dim.h"
#include "ipxrtprt.h"
#include "ipxrtdef.h"

#include "mipxe.h"
#include "mipxf.h"
#include "mripsape.h"
#include "mripsapf.h"
#include "nipxe.h"
#include "nipxf.h"
#include "rtipxmib.h"

#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\svccache.h ===
#ifndef _SNMP_SVCCACHE_
#define _SNMP_SVCCACHE_


DWORD
GetNextServiceSorted (
	USHORT			type,
	PUCHAR			name,
	PIPX_SERVICE	*pSvp
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\rtipxmib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rtipxmib.h

Abstract:

    Common include file for all IPX MIB instrumentations support by router

Author:

    Vadim Eydelman (vadime) 30-May-1996

Revision History:

--*/



#ifndef _SNMP_RTIPXMIB_
#define _SNMP_RTIPXMIB_


// Macros for converting MIB fields from SNMP master agent format
// to router structures 
#define GetAsnInteger(srcBuf,defVal)\
    (((srcBuf)->asnType)			\
		? (srcBuf)->asnValue.number	\
		: defVal)

#define SetAsnInteger(dstBuf,val)						\
	if ((dstBuf)->asnType) {                            \
		ASSERT((dstBuf)->asnType==ASN_INTEGER);			\
		(dstBuf)->asnValue.number = (AsnInteger)(val);	\
	}

#define ForceAsnInteger(dstBuf,val) {				\
	(dstBuf)->asnType = ASN_INTEGER;				\
	(dstBuf)->asnValue.number = (AsnInteger)(val);	\
	}



#define GetAsnCounter(srcBuf,defVal)\
    (((srcBuf)->asnType)			\
		? (srcBuf)->asnValue.counter\
		: defVal)

#define SetAsnCounter(dstBuf,val)						\
    if ((dstBuf)->asnType) {                            \
		ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);	\
		(dstBuf)->asnValue.counter = (AsnCounter)(val);	\
	}

#define ForceAsnCounter(dstBuf,val) {				\
	(dstBuf)->asnType = ASN_RFC1155_COUNTER;		\
	(dstBuf)->asnValue.counter = (AsnCounter)(val);	\
	}




#define GetAsnServType(srcBuf,defVal)						\
    (USHORT)(((srcBuf)->asnType)							\
		? ((((srcBuf)->asnValue.string.length>0)			\
			? (srcBuf)->asnValue.string.stream[1]			\
			: 0)											\
			+ (((srcBuf)->asnValue.string.length>1)			\
				? (((srcBuf)->asnValue.string.stream[0])<<8)\
				: 0))										\
		: defVal)

#define SetAsnServType(dstBuf,buffer,val)						\
    if ((dstBuf)->asnType) {                                \
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);			\
		(dstBuf)->asnValue.string.length = 2;				\
		(buffer)[1] = (BYTE)(val&0xFF);						\
		(buffer)[0] = (BYTE)((val>>8)&0xFF);				\
		(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
		(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}

#define ForceAsnServType(dstBuf,buffer,val) {				\
	(dstBuf)->asnType = ASN_OCTETSTRING;				\
	(dstBuf)->asnValue.string.length = 2;				\
	(buffer)[1] = (BYTE)(val&0xFF);						\
	(buffer)[0] = (BYTE)((val>>8)&0xFF);				\
	(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
	(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}



#define GetAsnMediaType(srcBuf,defVal)						\
    (USHORT)(((srcBuf)->asnType)							\
		? ((((srcBuf)->asnValue.string.length>0)			\
			? (srcBuf)->asnValue.string.stream[0]			\
			: 0)											\
			+ (((srcBuf)->asnValue.string.length>1)			\
				? (((srcBuf)->asnValue.string.stream[1])<<8)\
				: 0))										\
		: defVal)

#define SetAsnMediaType(dstBuf,buffer,val)						\
    if ((dstBuf)->asnType) {                                \
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);			\
		(dstBuf)->asnValue.string.length = 2;				\
		(buffer)[0] = (BYTE)(val&0xFF);						\
		(buffer)[1] = (BYTE)((val>>8)&0xFF);				\
		(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
		(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}

#define ForceAsnMediaType(dstBuf,buffer,val) {				\
	(dstBuf)->asnType = ASN_OCTETSTRING;				\
	(dstBuf)->asnValue.string.length = 2;				\
	(buffer)[0] = (BYTE)(val&0xFF);						\
	(buffer)[1] = (BYTE)((val>>8)&0xFF);				\
	(dstBuf)->asnValue.string.stream = (BYTE *)buffer;	\
	(dstBuf)->asnValue.string.dynamic = FALSE;			\
	}



#define GetAsnOctetString(dst,srcBuf,maxlen,defVal)			\
	(((srcBuf)->asnType)									\
		? (memset (&(dst)[(srcBuf)->asnValue.string.length],\
				0, maxlen-(srcBuf)->asnValue.string.length),\
			memcpy (dst,(srcBuf)->asnValue.string.stream,	\
				(srcBuf)->asnValue.string.length))			\
		: (defVal ? memcpy (dst, defVal, maxlen) : NULL))

#define SetAsnOctetString(dstBuf,buffer,src,len)							\
    if ((dstBuf)->asnType) {												\
		ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);							\
		(dstBuf)->asnValue.string.length = len;								\
		(dstBuf)->asnValue.string.stream = (BYTE *)memcpy (buffer,src,len);	\
		(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}

#define ForceAsnOctetString(dstBuf,buffer,src,len) {					\
	(dstBuf)->asnType = ASN_OCTETSTRING;								\
	(dstBuf)->asnValue.string.length = len;								\
	(dstBuf)->asnValue.string.stream = (BYTE *)memcpy (buffer,src,len);	\
	(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}




#define GetAsnDispString(dst,srcBuf,defVal)					\
	(((srcBuf)->asnType)									\
		? ((dst)[(srcBuf)->asnValue.string.length] = 0,		\
			strncpy (dst,(srcBuf)->asnValue.string.stream,	\
						(srcBuf)->asnValue.string.length))	\
		: (defVal ? strcpy (dst,defVal) : ((dst)[0] = 0, NULL)))

#define SetAsnDispString(dstBuf,buffer,src,len)								\
    if ((dstBuf)->asnType) {                                                \
		ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING);					\
		(dstBuf)->asnValue.string.length = strlen(src);						\
		if ((dstBuf)->asnValue.string.length>len)							\
			(dstBuf)->asnValue.string.length = len;							\
		(dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,		\
										(dstBuf)->asnValue.string.length);	\
		(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}

#define ForceAsnDispString(dstBuf,buffer,src,len) {						\
	(dstBuf)->asnType = ASN_RFC1213_DISPSTRING;							\
	(dstBuf)->asnValue.string.length = strlen(src);						\
	if ((dstBuf)->asnValue.string.length>len)							\
		(dstBuf)->asnValue.string.length = len;							\
	(dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,		\
									(dstBuf)->asnValue.string.length);	\
	(dstBuf)->asnValue.string.dynamic = FALSE;							\
	}



#define FreeAsnString(buf)	{								\
	if ((buf)->asnValue.string.dynamic)						\
		SNMP_free ((buf)->asnValue.string.stream);			\
	}


// Constants shared by several MIB instrumetnations
#define ZERO_INTERFACE_INDEX			0
#define INVALID_INTERFACE_INDEX			0xFFFFFFFF

extern UCHAR	ZERO_NET_NUM[4];
#define INVALID_NET_NUM					ZERO_NET_NUM

#define ZERO_SERVER_TYPE				0x0000
#define INVALID_SERVER_TYPE				0xFFFF

extern UCHAR	ZERO_SERVER_NAME[1];
#define INVALID_SERVER_NAME				ZERO_SERVER_NAME


#define MIPX_EXIST_STATE_NOACTION		0
#define MIPX_EXIST_STATE_DELETED		1
#define MIPX_EXIST_STATE_CREATED		2

#define NIPX_INVALID_SYS_INSTANCE		0xFFFFFFFF
#define NIPX_DEFAULT_SYS_INSTANCE		0

#define NIPX_STATE_NOACTION				0
#define NIPX_STATE_OFF					1
#define NIPX_STATE_ON					2

#define NIPX_CIRCTYPE_OTHER				1
#define NIPX_CIRCTYPE_BCAST				2
#define NIPX_CIRCTYPE_PTTOPT			3
#define NIPX_CIRCTYPE_WANRIP			4
#define NIPX_CIRCTYPE_UNNUMBEREDRIP		5
#define NIPX_CIRCTYPE_DYNAMIC			6
#define NIPX_CIRCTYPE_WANWS				7

#define NIPX_STATIC_STATUS_UNKNOWN		1
#define NIPX_STATIC_STATUS_CURRENT		2
#define NIPX_STATIC_STATUS_CHANGED		3
#define NIPX_STATIC_STATUS_READ			4
#define NIPX_STATIC_STATUS_READING		5
#define NIPX_STATIC_STATUS_WRITE		6
#define NIPX_STATIC_STATUS_WRITING		7


extern MIB_SERVER_HANDLE		g_MibServerHandle;
DWORD
ConnectToRouter (
    VOID
    );

BOOL EnsureRouterConnection();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\rtipxmib.c ===
#include "precomp.h"

DWORD					g_uptimeReference;
MIB_SERVER_HANDLE		g_MibServerHandle = 0;
CRITICAL_SECTION        g_ConnectionLock;
UCHAR	ZERO_NET_NUM[4] = {0,0,0,0};
UCHAR	ZERO_SERVER_NAME[1] = {0};

#if DBG
// DWORD					DbgLevel=DEF_DBGLEVEL;
DWORD DbgLevel=0xffffffff;
#endif




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ms_mipx[]                   = {1,3,6,1,4,1,311,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxBase group (1.3.6.1.4.1.311.1.8.1)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxBase[]                  = {1};
static UINT ids_mipxBaseOperState[]         = {1,1,0};
static UINT ids_mipxBasePrimaryNetNumber[]  = {1,2,0};
static UINT ids_mipxBaseNode[]              = {1,3,0};
static UINT ids_mipxBaseSysName[]           = {1,4,0};
static UINT ids_mipxBaseMaxPathSplits[]     = {1,5,0};
static UINT ids_mipxBaseIfCount[]           = {1,6,0};
static UINT ids_mipxBaseDestCount[]         = {1,7,0};
static UINT ids_mipxBaseServCount[]         = {1,8,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxInterface group (1.3.6.1.4.1.311.1.8.2)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxInterface[]             = {2};
static UINT ids_mipxIfTable[]               = {2,1};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxIfEntry table (1.3.6.1.4.1.311.1.8.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxIfEntry[]               = {2,1,1};
static UINT ids_mipxIfIndex[]               = {2,1,1,1};
static UINT ids_mipxIfAdminState[]          = {2,1,1,2};
static UINT ids_mipxIfOperState[]           = {2,1,1,3};
static UINT ids_mipxIfAdapterIndex[]        = {2,1,1,4};
static UINT ids_mipxIfName[]                = {2,1,1,5};
static UINT ids_mipxIfType[]                = {2,1,1,6};
static UINT ids_mipxIfLocalMaxPacketSize[]  = {2,1,1,7};
static UINT ids_mipxIfMediaType[]           = {2,1,1,8};
static UINT ids_mipxIfNetNumber[]           = {2,1,1,9};
static UINT ids_mipxIfMacAddress[]          = {2,1,1,10};
static UINT ids_mipxIfDelay[]               = {2,1,1,11};
static UINT ids_mipxIfThroughput[]          = {2,1,1,12};
static UINT ids_mipxIfIpxWanEnable[]	    = {2,1,1,13};
static UINT ids_mipxIfNetbiosAccept[]       = {2,1,1,14};
static UINT ids_mipxIfNetbiosDeliver[]      = {2,1,1,15};
static UINT ids_mipxIfInHdrErrors[]         = {2,1,1,16};
static UINT ids_mipxIfInFilterDrops[]       = {2,1,1,17};
static UINT ids_mipxIfInNoRoutes[]          = {2,1,1,18};
static UINT ids_mipxIfInDiscards[]          = {2,1,1,19};
static UINT ids_mipxIfInDelivers[]          = {2,1,1,20};
static UINT ids_mipxIfOutFilterDrops[]      = {2,1,1,21};
static UINT ids_mipxIfOutDiscards[]         = {2,1,1,22};
static UINT ids_mipxIfOutDelivers[]         = {2,1,1,23};
static UINT ids_mipxIfInNetbiosPackets[]    = {2,1,1,24};
static UINT ids_mipxIfOutNetbiosPackets[]   = {2,1,1,25};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxForwarding group (1.3.6.1.4.1.311.1.8.3)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxForwarding[]            = {3};
static UINT ids_mipxDestTable[]             = {3,1};
static UINT ids_mipxStaticRouteTable[]      = {3,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxDestEntry table (1.3.6.1.4.1.311.1.8.3.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxDestEntry[]             = {3,1,1};
static UINT ids_mipxDestNetNum[]            = {3,1,1,1};
static UINT ids_mipxDestProtocol[]          = {3,1,1,2};
static UINT ids_mipxDestTicks[]             = {3,1,1,3};
static UINT ids_mipxDestHopCount[]          = {3,1,1,4};
static UINT ids_mipxDestNextHopIfIndex[]    = {3,1,1,5};
static UINT ids_mipxDestNextHopMacAddress[] = {3,1,1,6};
static UINT ids_mipxDestFlags[]             = {3,1,1,7};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticRouteEntry table (1.3.6.1.4.1.311.1.8.3.2.1)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxStaticRouteEntry[]      = {3,2,1};
static UINT ids_mipxStaticRouteIfIndex[]    = {3,2,1,1};
static UINT ids_mipxStaticRouteNetNum[]     = {3,2,1,2};
static UINT ids_mipxStaticRouteEntryStatus[]= {3,2,1,3};
static UINT ids_mipxStaticRouteTicks[]      = {3,2,1,4};
static UINT ids_mipxStaticRouteHopCount[]   = {3,2,1,5};
static UINT ids_mipxStaticRouteNextHopMacAddress[]= {3,2,1,6};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServices group (1.3.6.1.4.1.311.1.8.4)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxServices[]              = {4};
static UINT ids_mipxServTable[]             = {4,1};
static UINT ids_mipxStaticServTable[]       = {4,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxServEntry table (1.3.6.1.4.1.311.1.8.4.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxServEntry[]             = {4,1,1};
static UINT ids_mipxServType[]              = {4,1,1,1};
static UINT ids_mipxServName[]              = {4,1,1,2};
static UINT ids_mipxServProtocol[]          = {4,1,1,3};
static UINT ids_mipxServNetNum[]            = {4,1,1,4};
static UINT ids_mipxServNode[]              = {4,1,1,5};
static UINT ids_mipxServSocket[]            = {4,1,1,6};
static UINT ids_mipxServHopCount[]          = {4,1,1,7};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mipxStaticServEntry table (1.3.6.1.4.1.311.1.8.4.2.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mipxStaticServEntry[]       = {4,2,1};
static UINT ids_mipxStaticServIfIndex[]     = {4,2,1,1};
static UINT ids_mipxStaticServType[]        = {4,2,1,2};
static UINT ids_mipxStaticServName[]        = {4,2,1,3};
static UINT ids_mipxStaticServEntryStatus[] = {4,2,1,4};
static UINT ids_mipxStaticServNetNum[]      = {4,2,1,5};
static UINT ids_mipxStaticServNode[]        = {4,2,1,6};
static UINT ids_mipxStaticServSocket[]      = {4,2,1,7};
static UINT ids_mipxStaticServHopCount[]    = {4,2,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_ms_mipx[] = {
    MIB_GROUP(mipxBase),
        MIB_INTEGER(mipxBaseOperState),
        MIB_OCTETSTRING_L(mipxBasePrimaryNetNumber,4,4),
        MIB_OCTETSTRING_L(mipxBaseNode,6,6),
        MIB_OCTETSTRING_L(mipxBaseSysName,0,48),
        MIB_INTEGER_L(mipxBaseMaxPathSplits,1,32),
        MIB_INTEGER(mipxBaseIfCount),
        MIB_INTEGER(mipxBaseDestCount),
        MIB_INTEGER(mipxBaseServCount),
    MIB_GROUP(mipxInterface),
        MIB_TABLE_ROOT(mipxIfTable),
            MIB_TABLE_ENTRY(mipxIfEntry),
                MIB_INTEGER(mipxIfIndex),
                MIB_INTEGER_RW(mipxIfAdminState),
                MIB_INTEGER(mipxIfOperState),
                MIB_INTEGER(mipxIfAdapterIndex),
                MIB_OCTETSTRING_L(mipxIfName,0,48),
                MIB_INTEGER(mipxIfType),
                MIB_INTEGER(mipxIfLocalMaxPacketSize),
                MIB_INTEGER(mipxIfMediaType),
                MIB_OCTETSTRING_L(mipxIfNetNumber,4,4),
                MIB_OCTETSTRING_L(mipxIfMacAddress,6,6),
                MIB_INTEGER(mipxIfDelay),
                MIB_INTEGER(mipxIfThroughput),
                MIB_INTEGER_RW(mipxIfIpxWanEnable),
                MIB_INTEGER_RW(mipxIfNetbiosAccept),
                MIB_INTEGER_RW(mipxIfNetbiosDeliver),
                MIB_COUNTER(mipxIfInHdrErrors),
                MIB_COUNTER(mipxIfInFilterDrops),
                MIB_COUNTER(mipxIfInNoRoutes),
                MIB_COUNTER(mipxIfInDiscards),
                MIB_COUNTER(mipxIfInDelivers),
                MIB_COUNTER(mipxIfOutFilterDrops),
                MIB_COUNTER(mipxIfOutDiscards),
                MIB_COUNTER(mipxIfOutDelivers),
                MIB_COUNTER(mipxIfInNetbiosPackets),
                MIB_COUNTER(mipxIfOutNetbiosPackets),
    MIB_GROUP(mipxForwarding),
        MIB_TABLE_ROOT(mipxDestTable),
            MIB_TABLE_ENTRY(mipxDestEntry),
                MIB_OCTETSTRING_L(mipxDestNetNum,4,4),
                MIB_INTEGER(mipxDestProtocol),
                MIB_INTEGER(mipxDestTicks),
                MIB_INTEGER(mipxDestHopCount),
                MIB_INTEGER(mipxDestNextHopIfIndex),
                MIB_OCTETSTRING_L(mipxDestNextHopMacAddress,6,6),
                MIB_INTEGER_L(mipxDestFlags,0,3),
        MIB_TABLE_ROOT(mipxStaticRouteTable),
            MIB_TABLE_ENTRY(mipxStaticRouteEntry),
                MIB_INTEGER(mipxStaticRouteIfIndex),
                MIB_OCTETSTRING_L(mipxStaticRouteNetNum,4,4),
                MIB_INTEGER_RW(mipxStaticRouteEntryStatus),
                MIB_INTEGER_RW(mipxStaticRouteTicks),
                MIB_INTEGER_RW(mipxStaticRouteHopCount),
                MIB_OCTETSTRING_RW_L(mipxStaticRouteNextHopMacAddress,6,6),
    MIB_GROUP(mipxServices),
        MIB_TABLE_ROOT(mipxServTable),
            MIB_TABLE_ENTRY(mipxServEntry),
                MIB_OCTETSTRING_L(mipxServType,2,2),
                MIB_OCTETSTRING_L(mipxServName,1,48),
                MIB_INTEGER(mipxServProtocol),
                MIB_OCTETSTRING_L(mipxServNetNum,4,4),
                MIB_OCTETSTRING_L(mipxServNode,6,6),
                MIB_OCTETSTRING_L(mipxServSocket,2,2),
                MIB_INTEGER(mipxServHopCount),
        MIB_TABLE_ROOT(mipxStaticServTable),
            MIB_TABLE_ENTRY(mipxStaticServEntry),
                MIB_INTEGER(mipxStaticServIfIndex),
                MIB_OCTETSTRING_L(mipxStaticServType,2,2),
                MIB_OCTETSTRING_L(mipxStaticServName,1,48),
                MIB_INTEGER_RW(mipxStaticServEntryStatus),
                MIB_OCTETSTRING_RW_L(mipxStaticServNetNum,4,4),
                MIB_OCTETSTRING_RW_L(mipxStaticServNode,6,6),
                MIB_OCTETSTRING_RW_L(mipxStaticServSocket,2,2),
                MIB_INTEGER_RW(mipxStaticServHopCount),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_ms_mipx[] = {
    MIB_TABLE(ms_mipx,mipxIfEntry,NULL),
    MIB_TABLE(ms_mipx,mipxDestEntry,NULL),
    MIB_TABLE(ms_mipx,mipxStaticRouteEntry,NULL),
    MIB_TABLE(ms_mipx,mipxServEntry,NULL),
    MIB_TABLE(ms_mipx,mipxStaticServEntry,NULL)
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ms_mripsap[]                = {1,3,6,1,4,1,311,1,9};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapBase group (1.3.6.1.4.1.311.1.9.1)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static UINT ids_mripsapBase[]               = {1};
static UINT ids_mripsapBaseRipOperState[]   = {1,1,0};
static UINT ids_mripsapBaseSapOperState[]   = {1,2,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripsapInterface group (1.3.6.1.4.1.311.1.9.2)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mripsapInterface[]          = {2};

static UINT ids_mripIfTable[]               = {2,1};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// mripIfEntry table (1.3.6.1.4.1.311.1.9.2.1.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_mripIfEntry[]               = {2,1,1};
static UINT ids_mripIfIndex[]               = {2,1,1,1};
static UINT ids_mripIfAdminState[]          = {2,1,1,2};
static UINT ids_mripIfOperState[]           = {2,1,1,3};
static UINT ids_mripIfUpdateMode[]          = {2,1,1,4};
static UINT ids_mripIfUpdateInterval[]      = {2,1,1,5};
static UINT ids_mripIfAgeMultiplier[]       = {2,1,1,6};
static UINT ids_mripIfSupply[]				= {2,1,1,7};
static UINT ids_mripIfListen[]              = {2,1,1,8};
static UINT ids_mripIfOutPackets[]          = {2,1,1,9};
static UINT ids_mripIfInPackets[]           = {2,1,1,10};


static UINT ids_msapIfTable[]               = {2,2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// msapIfEntry table (1.3.6.1.4.1.311.1.9.2.2.1)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_msapIfEntry[]               = {2,2,1};
static UINT ids_msapIfIndex[]               = {2,2,1,1};
static UINT ids_msapIfAdminState[]          = {2,2,1,2};
static UINT ids_msapIfOperState[]           = {2,2,1,3};
static UINT ids_msapIfUpdateMode[]          = {2,2,1,4};
static UINT ids_msapIfUpdateInterval[]      = {2,2,1,5};
static UINT ids_msapIfAgeMultiplier[]       = {2,2,1,6};
static UINT ids_msapIfSupply[]				= {2,2,1,7};
static UINT ids_msapIfListen[]              = {2,2,1,8};
static UINT ids_msapIfGetNearestServerReply[]= {2,2,1,9};
static UINT ids_msapIfOutPackets[]          = {2,2,1,10};
static UINT ids_msapIfInPackets[]           = {2,2,1,11};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_ms_mripsap[] = {
    MIB_GROUP(mripsapBase),
        MIB_INTEGER(mripsapBaseRipOperState),
        MIB_INTEGER(mripsapBaseSapOperState),
    MIB_GROUP(mripsapInterface),
        MIB_TABLE_ROOT(mripIfTable),
            MIB_TABLE_ENTRY(mripIfEntry),
                MIB_INTEGER(mripIfIndex),
                MIB_INTEGER_RW(mripIfAdminState),
                MIB_INTEGER(mripIfOperState),
                MIB_INTEGER_RW(mripIfUpdateMode),
                MIB_INTEGER_RW(mripIfUpdateInterval),
                MIB_INTEGER_RW(mripIfAgeMultiplier),
                MIB_INTEGER_RW(mripIfSupply),
                MIB_INTEGER_RW(mripIfListen),
                MIB_COUNTER(mripIfOutPackets),
                MIB_COUNTER(mripIfInPackets),
        MIB_TABLE_ROOT(msapIfTable),
            MIB_TABLE_ENTRY(msapIfEntry),
                MIB_INTEGER(msapIfIndex),
                MIB_INTEGER_RW(msapIfAdminState),
                MIB_INTEGER(msapIfOperState),
                MIB_INTEGER_RW(msapIfUpdateMode),
                MIB_INTEGER_RW(msapIfUpdateInterval),
                MIB_INTEGER_RW(msapIfAgeMultiplier),
                MIB_INTEGER_RW(msapIfSupply),
                MIB_INTEGER_RW(msapIfListen),
                MIB_INTEGER_RW(msapIfGetNearestServerReply),
                MIB_COUNTER(msapIfOutPackets),
                MIB_COUNTER(msapIfInPackets),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_ms_mripsap[] = {
    MIB_TABLE(ms_mripsap,mripIfEntry,NULL),
    MIB_TABLE(ms_mripsap,msapIfEntry,NULL)
};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nv_nipx[]                    = {1,3,6,1,4,1,23,2,5};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxSystem group (1.3.6.1.4.1.23.2.5.1)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxSystem[]                 = {1};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxBasicSysEntry table (1.3.6.1.4.1.23.2.5.1.1.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static UINT ids_nipxBasicSysTable[]			={1,1};
static UINT ids_nipxBasicSysEntry[]			={1,1,1};
static UINT ids_nipxBasicSysInstance[]		={1,1,1,1};
static UINT ids_nipxBasicSysExistState[]	={1,1,1,2};
static UINT ids_nipxBasicSysNetNumber[]		={1,1,1,3};
static UINT ids_nipxBasicSysNode[]			={1,1,1,4};
static UINT ids_nipxBasicSysName[]			={1,1,1,5};
static UINT ids_nipxBasicSysInReceives[]	={1,1,1,6};
static UINT ids_nipxBasicSysInHdrErrors[]	={1,1,1,7};
static UINT ids_nipxBasicSysInUnknownSockets[]={1,1,1,8};
static UINT ids_nipxBasicSysInDiscards[]	={1,1,1,9};
static UINT ids_nipxBasicSysInBadChecksums[]={1,1,1,10};
static UINT ids_nipxBasicSysInDelivers[]	={1,1,1,11};
static UINT ids_nipxBasicSysNoRoutes[]		={1,1,1,12};
static UINT ids_nipxBasicSysOutRequests[]	={1,1,1,13};
static UINT ids_nipxBasicSysOutMalformedRequests[]={1,1,1,14};
static UINT ids_nipxBasicSysOutDiscards[]	={1,1,1,15};
static UINT ids_nipxBasicSysOutPackets[]	={1,1,1,16};
static UINT ids_nipxBasicSysConfigSockets[]	={1,1,1,17};
static UINT ids_nipxBasicSysOpenSocketFails[]={1,1,1,18};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxAdvSysEntry table (1.3.6.1.4.1.23.2.5.1.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxAdvSysTable[]			={1,2};
static UINT ids_nipxAdvSysEntry[]			={1,2,1};
static UINT ids_nipxAdvSysInstance[]		={1,2,1,1};
static UINT ids_nipxAdvSysMaxPathSplits[]	={1,2,1,2};
static UINT ids_nipxAdvSysMaxHops[]			={1,2,1,3};
static UINT ids_nipxAdvSysInTooManyHops[]	={1,2,1,4};
static UINT ids_nipxAdvSysInFiltered[]		={1,2,1,5};
static UINT ids_nipxAdvSysInCompressDiscards[]={1,2,1,6};
static UINT ids_nipxAdvSysNETBIOSPackets[]	={1,2,1,7};
static UINT ids_nipxAdvSysForwPackets[]		={1,2,1,8};
static UINT ids_nipxAdvSysOutFiltered[]		={1,2,1,9};
static UINT ids_nipxAdvSysOutCompressDiscards[]={1,2,1,10};
static UINT ids_nipxAdvSysCircCount[]		={1,2,1,11};
static UINT ids_nipxAdvSysDestCount[]		={1,2,1,12};
static UINT ids_nipxAdvSysServCount[]		={1,2,1,13};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircuit group (1.3.6.1.4.1.23.2.5.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxCircuit[]					={2};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxCircEntry table (1.3.6.1.4.1.23.2.5.2.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxCircTable[]				={2,1};
static UINT ids_nipxCircEntry[]				={2,1,1};
static UINT ids_nipxCircSysInstance[]		={2,1,1,1};
static UINT ids_nipxCircIndex[]				={2,1,1,2};
static UINT ids_nipxCircExistState[]		={2,1,1,3};
static UINT ids_nipxCircOperState[]			={2,1,1,4};
static UINT ids_nipxCircIfIndex[]			={2,1,1,5};
static UINT ids_nipxCircName[]				={2,1,1,6};
static UINT ids_nipxCircType[]				={2,1,1,7};
static UINT ids_nipxCircDialName[]			={2,1,1,8};
static UINT ids_nipxCircLocalMaxPacketSize[]={2,1,1,9};
static UINT ids_nipxCircCompressState[]		={2,1,1,10};
static UINT ids_nipxCircCompressSlots[]		={2,1,1,11};
static UINT ids_nipxCircStaticStatus[]		={2,1,1,12};
static UINT ids_nipxCircCompressedSent[]	={2,1,1,13};
static UINT ids_nipxCircCompressedInitSent[]={2,1,1,14};
static UINT ids_nipxCircCompressedRejectsSent[]={2,1,1,15};
static UINT ids_nipxCircUncompressedSent[]	={2,1,1,16};
static UINT ids_nipxCircCompressedReceived[]={2,1,1,17};
static UINT ids_nipxCircCompressedInitReceived[]={2,1,1,18};
static UINT ids_nipxCircCompressedRejectsReceived[]={2,1,1,19};
static UINT ids_nipxCircUncompressedReceived[]={2,1,1,20};
static UINT ids_nipxCircMediaType[]			={2,1,1,21};
static UINT ids_nipxCircNetNumber[]			={2,1,1,22};
static UINT ids_nipxCircStateChanges[]		={2,1,1,23};
static UINT ids_nipxCircInitFails[]			={2,1,1,24};
static UINT ids_nipxCircDelay[]				={2,1,1,25};
static UINT ids_nipxCircThroughput[]		={2,1,1,26};
static UINT ids_nipxCircNeighRouterName[]	={2,1,1,27};
static UINT ids_nipxCircNeighInternalNetNum[]={2,1,1,28};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxForwarding group (1.3.6.1.4.1.23.2.5.3)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxForwarding[]			={3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestEntry table (1.3.6.1.4.1.23.2.5.3.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxDestTable[]				={3,1};
static UINT ids_nipxDestEntry[]				={3,1,1};
static UINT ids_nipxDestSysInstance[]		={3,1,1,1};
static UINT ids_nipxDestNetNum[]			={3,1,1,2};
static UINT ids_nipxDestProtocol[]			={3,1,1,3};
static UINT ids_nipxDestTicks[]				={3,1,1,4};
static UINT ids_nipxDestHopCount[]			={3,1,1,5};
static UINT ids_nipxDestNextHopCircIndex[]	={3,1,1,6};
static UINT ids_nipxDestNextHopNICAddress[]	={3,1,1,7};
static UINT ids_nipxDestNextHopNetNum[]		={3,1,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ids_nipxStaticRouteEntry table (1.3.6.1.4.1.23.2.5.3.1.2)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxStaticRouteTable[]		={3,2};
static UINT ids_nipxStaticRouteEntry[]		={3,2,1};
static UINT ids_nipxStaticRouteSysInstance[]={3,2,1,1};
static UINT ids_nipxStaticRouteCircIndex[]	={3,2,1,2};
static UINT ids_nipxStaticRouteNetNum[]		={3,2,1,3};
static UINT ids_nipxStaticRouteExistState[]	={3,2,1,4};
static UINT ids_nipxStaticRouteTicks[]		={3,2,1,5};
static UINT ids_nipxStaticRouteHopCount[]	={3,2,1,6};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServices group (1.3.6.1.4.1.23.2.5.4)                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxServices[]				={4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxServEntry table (1.3.6.1.4.1.23.2.5.4.1.1)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxServTable[]				={4,1};
static UINT ids_nipxServEntry[]				={4,1,1};
static UINT ids_nipxServSysInstance[]		={4,1,1,1};
static UINT ids_nipxServType[]				={4,1,1,2};
static UINT ids_nipxServName[]				={4,1,1,3};
static UINT ids_nipxServProtocol[]			={4,1,1,4};
static UINT ids_nipxServNetNum[]			={4,1,1,5};
static UINT ids_nipxServNode[]				={4,1,1,6};
static UINT ids_nipxServSocket[]			={4,1,1,7};
static UINT ids_nipxServHopCount[]			={4,1,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxDestServEntry table (1.3.6.1.4.1.23.2.5.4.2.1)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxDestServTable[]			={4,2};
static UINT ids_nipxDestServEntry[]			={4,2,1};
static UINT ids_nipxDestServSysInstance[]	={4,2,1,1};
static UINT ids_nipxDestServNetNum[]		={4,2,1,2};
static UINT ids_nipxDestServNode[]			={4,2,1,3};
static UINT ids_nipxDestServSocket[]		={4,2,1,4};
static UINT ids_nipxDestServName[]			={4,2,1,5};
static UINT ids_nipxDestServType[]			={4,2,1,6};
static UINT ids_nipxDestServProtocol[]		={4,2,1,7};
static UINT ids_nipxDestServHopCount[]		={4,2,1,8};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// nipxStaticServEntry table (1.3.6.1.4.1.23.2.5.4.3.1)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_nipxStaticServTable[]		={4,3};
static UINT ids_nipxStaticServEntry[]		={4,3,1};
static UINT ids_nipxStaticServSysInstance[]	={4,3,1,1};
static UINT ids_nipxStaticServCircIndex[]	={4,3,1,2};
static UINT ids_nipxStaticServType[]		={4,3,1,3};
static UINT ids_nipxStaticServName[]		={4,3,1,4};
static UINT ids_nipxStaticServExistState[]	={4,3,1,5};
static UINT ids_nipxStaticServNetNum[]		={4,3,1,6};
static UINT ids_nipxStaticServNode[]		={4,3,1,7};
static UINT ids_nipxStaticServSocket[]		={4,3,1,8};
static UINT ids_nipxStaticServHopCount[]	={4,3,1,9};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_nv_nipx[] = {
	MIB_GROUP(nipxSystem),
		MIB_TABLE_ROOT(nipxBasicSysTable),
			MIB_TABLE_ENTRY(nipxBasicSysEntry),
				MIB_INTEGER(nipxBasicSysInstance),
				MIB_INTEGER(nipxBasicSysExistState),
				MIB_OCTETSTRING_L(nipxBasicSysNetNumber,4,4),
				MIB_OCTETSTRING_L(nipxBasicSysNode,6,6),
				MIB_OCTETSTRING_L(nipxBasicSysName,0,48),
				MIB_COUNTER(nipxBasicSysInReceives),
				MIB_COUNTER(nipxBasicSysInHdrErrors),
				MIB_COUNTER(nipxBasicSysInUnknownSockets),
				MIB_COUNTER(nipxBasicSysInDiscards),
				MIB_COUNTER(nipxBasicSysInBadChecksums),
				MIB_COUNTER(nipxBasicSysInDelivers),
				MIB_COUNTER(nipxBasicSysNoRoutes),
				MIB_COUNTER(nipxBasicSysOutRequests),
				MIB_COUNTER(nipxBasicSysOutMalformedRequests),
				MIB_COUNTER(nipxBasicSysOutDiscards),
				MIB_COUNTER(nipxBasicSysOutPackets),
				MIB_COUNTER(nipxBasicSysConfigSockets),
				MIB_COUNTER(nipxBasicSysOpenSocketFails),
		MIB_TABLE_ROOT(nipxAdvSysTable),
			MIB_TABLE_ENTRY(nipxAdvSysEntry),
				MIB_INTEGER(nipxAdvSysInstance),
				MIB_INTEGER(nipxAdvSysMaxPathSplits),
				MIB_INTEGER(nipxAdvSysMaxHops),
				MIB_COUNTER(nipxAdvSysInTooManyHops),
				MIB_COUNTER(nipxAdvSysInFiltered),
				MIB_COUNTER(nipxAdvSysInCompressDiscards),
				MIB_COUNTER(nipxAdvSysNETBIOSPackets),
				MIB_COUNTER(nipxAdvSysForwPackets),
				MIB_COUNTER(nipxAdvSysOutFiltered),
				MIB_COUNTER(nipxAdvSysOutCompressDiscards),
				MIB_COUNTER(nipxAdvSysCircCount),
				MIB_COUNTER(nipxAdvSysDestCount),
				MIB_COUNTER(nipxAdvSysServCount),
	MIB_GROUP(nipxCircuit),
		MIB_TABLE_ROOT(nipxCircTable),
			MIB_TABLE_ENTRY(nipxCircEntry),
				MIB_INTEGER(nipxCircSysInstance),
				MIB_INTEGER(nipxCircIndex),
				MIB_INTEGER(nipxCircExistState),
				MIB_INTEGER_RW(nipxCircOperState),
				MIB_INTEGER(nipxCircIfIndex),
				MIB_OCTETSTRING_L(nipxCircName,0,48),
				MIB_INTEGER(nipxCircType),
				MIB_OCTETSTRING_L(nipxCircDialName,0,48),
				MIB_INTEGER(nipxCircLocalMaxPacketSize),
				MIB_INTEGER(nipxCircCompressState),
				MIB_INTEGER(nipxCircCompressSlots),
				MIB_INTEGER(nipxCircStaticStatus),
				MIB_COUNTER(nipxCircCompressedSent),
				MIB_COUNTER(nipxCircCompressedInitSent),
				MIB_COUNTER(nipxCircCompressedRejectsSent),
				MIB_COUNTER(nipxCircUncompressedSent),
				MIB_COUNTER(nipxCircCompressedReceived),
				MIB_COUNTER(nipxCircCompressedInitReceived),
				MIB_COUNTER(nipxCircCompressedRejectsReceived),
				MIB_COUNTER(nipxCircUncompressedReceived),
				MIB_OCTETSTRING_L(nipxCircMediaType,2,2),
				MIB_OCTETSTRING_L(nipxCircNetNumber,4,4),
				MIB_COUNTER(nipxCircStateChanges),
				MIB_COUNTER(nipxCircInitFails),
				MIB_INTEGER(nipxCircDelay),
				MIB_INTEGER(nipxCircThroughput),
				MIB_OCTETSTRING_L(nipxCircNeighRouterName,0,48),
				MIB_OCTETSTRING_L(nipxCircNeighInternalNetNum,4,4),
	MIB_GROUP(nipxForwarding),
		MIB_TABLE_ROOT(nipxDestTable),
			MIB_TABLE_ENTRY(nipxDestEntry),
				MIB_INTEGER(nipxDestSysInstance),
				MIB_OCTETSTRING_L(nipxDestNetNum,4,4),
				MIB_INTEGER(nipxDestProtocol),
				MIB_INTEGER(nipxDestTicks),
				MIB_INTEGER(nipxDestHopCount),
				MIB_INTEGER(nipxDestNextHopCircIndex),
				MIB_OCTETSTRING_L(nipxDestNextHopNICAddress,6,6),
				MIB_OCTETSTRING_L(nipxDestNextHopNetNum,4,4),
		MIB_TABLE_ROOT(nipxStaticRouteTable),
			MIB_TABLE_ENTRY(nipxStaticRouteEntry),
				MIB_INTEGER(nipxStaticRouteSysInstance),
				MIB_INTEGER(nipxStaticRouteCircIndex),
				MIB_OCTETSTRING_RW_L(nipxStaticRouteNetNum,4,4),
				MIB_INTEGER_RW(nipxStaticRouteExistState),
				MIB_INTEGER_RW(nipxStaticRouteTicks),
				MIB_INTEGER_RW(nipxStaticRouteHopCount),
	MIB_GROUP(nipxServices),
		MIB_TABLE_ROOT(nipxServTable),
			MIB_TABLE_ENTRY(nipxServEntry),
				MIB_INTEGER(nipxServSysInstance),
				MIB_OCTETSTRING_L(nipxServType,2,2),
				MIB_OCTETSTRING_L(nipxServName,1,48),
				MIB_INTEGER(nipxServProtocol),
				MIB_OCTETSTRING_L(nipxServNetNum,4,4),
				MIB_OCTETSTRING_L(nipxServNode,6,6),
				MIB_OCTETSTRING_L(nipxServSocket,2,2),
				MIB_INTEGER(nipxServHopCount),
		MIB_TABLE_ROOT(nipxDestServTable),
			MIB_TABLE_ENTRY(nipxDestServEntry),
				MIB_INTEGER(nipxDestServSysInstance),
				MIB_OCTETSTRING_L(nipxDestServNetNum,4,4),
				MIB_OCTETSTRING_L(nipxDestServNode,6,6),
				MIB_OCTETSTRING_L(nipxDestServSocket,2,2),
				MIB_OCTETSTRING_L(nipxDestServName,1,48),
				MIB_OCTETSTRING_L(nipxDestServType,2,2),
				MIB_INTEGER(nipxDestServProtocol),
				MIB_INTEGER(nipxDestServHopCount),
		MIB_TABLE_ROOT(nipxStaticServTable),
			MIB_TABLE_ENTRY(nipxStaticServEntry),
				MIB_INTEGER(nipxStaticServSysInstance),
				MIB_INTEGER(nipxStaticServCircIndex),
				MIB_OCTETSTRING_RW_L(nipxStaticServType,2,2),
				MIB_OCTETSTRING_RW_L(nipxStaticServName,1,48),
				MIB_INTEGER_RW(nipxStaticServExistState),
				MIB_OCTETSTRING_RW_L(nipxStaticServNetNum,4,4),
				MIB_OCTETSTRING_RW_L(nipxStaticServNode,6,6),
				MIB_OCTETSTRING_RW_L(nipxStaticServSocket,2,2),
				MIB_INTEGER_RW(nipxStaticServHopCount),
	MIB_END()
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib table list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_nv_nipx[] = {
    MIB_TABLE(nv_nipx,nipxBasicSysEntry,NULL),
    MIB_TABLE(nv_nipx,nipxAdvSysEntry,NULL),
    MIB_TABLE(nv_nipx,nipxCircEntry,NULL),
    MIB_TABLE(nv_nipx,nipxDestEntry,NULL),
	MIB_TABLE(nv_nipx,nipxStaticRouteEntry,NULL),
    MIB_TABLE(nv_nipx,nipxServEntry,NULL),
    MIB_TABLE(nv_nipx,nipxDestServEntry,NULL),
    MIB_TABLE(nv_nipx,nipxStaticServEntry,NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// [pmay] This array must have its elements ordered lexigraphically or else
// snmp service will get confused.  This may be a bug on snmp's part.
SnmpMibView v_rtipx[3] =	{
	MIB_VIEW(nv_nipx),
	MIB_VIEW(ms_mipx),
	MIB_VIEW(ms_mripsap)
};

UINT viewIndex = 0;    
SnmpTfxHandle tfxHandle;

#define NUM_VIEWS (sizeof(v_rtipx)/sizeof(SnmpMibView))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// snmp extension entry points                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DbgTrace (DBG_LOAD, ("\nMIPX: SnmpExtensionInit: entered, nv= %d vi= %d\n", NUM_VIEWS, viewIndex));
     
    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    tfxHandle = SnmpTfxOpen(3,v_rtipx);

    // validate handle
    if (tfxHandle == NULL) {
        DbgTrace (DBG_LOAD, ("MIPX: TfxOpen, result: %ld", GetLastError()));
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_rtipx[viewIndex++].viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}


BOOL 
SnmpExtensionInitEx(
    OUT AsnObjectIdentifier * lpNextSupportedView
    )
{
    // check if there are views to register
    BOOL fMoreViews = (viewIndex < NUM_VIEWS);

    DbgTrace (DBG_LOAD, ("MIPX: SnmpExtensionInitEx: entered, nv= %d, vi= %d, fm=%d\n", NUM_VIEWS, viewIndex, fMoreViews));

    if (fMoreViews) {

        // pass back next supported view to master 
        *lpNextSupportedView = v_rtipx[viewIndex++].viewOid;
    } 

    // report status
    return fMoreViews;
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


/*++
*******************************************************************
		D l l M a i n
Routine Description:
	Dll entry point to be called from CRTstartup dll entry point (it
		will be actually an entry point for this dll)
Arguments:
	hinstDLL - handle of DLL module 
	fdwReason - reason for calling function 
	lpvReserved - reserved 
Return Value:
	TRUE - process initialization was performed OK
	FALSE - intialization failed
	
*******************************************************************
--*/
BOOL WINAPI DllMain(
    HINSTANCE  	hinstDLL,
    DWORD  		fdwReason,
    LPVOID  	lpvReserved 
    ) {
	switch (fdwReason) {
	case DLL_PROCESS_ATTACH:	// We are being attached to a new process
		InitializeCriticalSection (&g_ConnectionLock);
        ConnectToRouter ();
		DbgTrace (DBG_LOAD, ("MIPX: Loaded %x", g_MibServerHandle));
		return TRUE;

	case DLL_PROCESS_DETACH:	// The process is exiting
		if (g_MibServerHandle!=0)
			MprAdminMIBServerDisconnect (g_MibServerHandle);
		DeleteCriticalSection (&g_ConnectionLock);
		DbgTrace (DBG_LOAD, ("MIPX: Unloaded\n"));
	default:					// Not interested in all other cases
		return TRUE;
	}
}

//
// Tests whether the remoteaccess service is running.
//
DWORD IsServiceRunning (
        IN PBOOL pbIsRunning)
{
    *pbIsRunning = MprAdminIsServiceRunning(NULL);
    return NO_ERROR;
}

DWORD
ConnectToRouter (
    VOID
    ) {
    DWORD rc;
    BOOL bServiceRunning; 

    // Check to see if the service is running
    //
    if ((rc = IsServiceRunning (&bServiceRunning)) != NO_ERROR)
        return NO_ERROR;

    // If not, return an error
    if (!bServiceRunning) {
        EnterCriticalSection (&g_ConnectionLock);
        g_MibServerHandle = 0;
        LeaveCriticalSection (&g_ConnectionLock);
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // If we're already connected, return
    else if (g_MibServerHandle)
        return NO_ERROR;
    
    EnterCriticalSection (&g_ConnectionLock);
    if (g_MibServerHandle==0) {
        rc = MprAdminMIBServerConnect (NULL, &g_MibServerHandle);
    	if (rc!=NO_ERROR)
	    	g_MibServerHandle = 0;	// Indicates that we are not connected
        DbgTrace (DBG_LOAD, ("MIPX: Connect to router, result: %ld", rc));
    }
    else
        rc = NO_ERROR;
    LeaveCriticalSection (&g_ConnectionLock);
    
    return rc;
}

//
// Returns TRUE if the router connection is stable, false
// otherwise.
//
BOOL EnsureRouterConnection() {
    return (ConnectToRouter() == NO_ERROR);
    // If we haven't connected, attempt to do so
    //if (g_MibServerHandle == NULL) {
    //    if (ConnectToRouter() == NO_ERROR)
    //        return TRUE;
    //    return FALSE;
    // }

    // If we have a valid handle, m
    //
    //    ? TRUE                                  
    //    : (ConnectToRouter ()==NO_ERROR)        
    // )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ipx\snmp\svccache.c ===
#include "precomp.h"

typedef struct _SERVICE_CACHE_ENTRY SERVICE_CACHE_ENTRY, *PSERVICE_CACHE_ENTRY;
struct _SERVICE_CACHE_ENTRY {
	PIPX_SERVICE			svc;
	PSERVICE_CACHE_ENTRY	next;
};



#define NUM_SERVICE_CACHES	2
#define CACHE_VALID_TIME		1800000000i64
PSERVICE_CACHE_ENTRY	ServiceCache[NUM_SERVICE_CACHES][48];
LONGLONG				ServiceCacheTimeStamp[NUM_SERVICE_CACHES] = {
									-CACHE_VALID_TIME,
									-CACHE_VALID_TIME};

USHORT					ServiceCacheType[NUM_SERVICE_CACHES];
INT						LastServiceCache = 0;


DWORD
GetNextServiceSorted (
	USHORT			type,
	PUCHAR			name,
	PIPX_SERVICE	*pSvp
	) {
	INT						idx = strlen (name);
	LONGLONG				CurTime;
	PIPX_SERVICE			Svp;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD					rc;
	ULONG					SvSize;
	INT						i,j;

	MibGetInputData.TableId = IPX_SERV_TABLE;
	GetSystemTimeAsFileTime ((LPFILETIME)&CurTime);

	while (TRUE) {
		j = LastServiceCache;
		while (CurTime-ServiceCacheTimeStamp[j]<=CACHE_VALID_TIME) {
			INT		j1;
			if (type==ServiceCacheType[j]) {
				for (i=idx; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
					PSERVICE_CACHE_ENTRY	cur=ServiceCache[j][i];
					while ((cur!=NULL) && (idx==i) && (strcmp (name,cur->svc->Server.Name)>=0))
						cur = cur->next;
					if (cur!=NULL) {
						*pSvp = cur->svc;
						return NO_ERROR;
					}
				}
			
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = type;
				memset (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
						0xFF,
						sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)-1);
				MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[
					sizeof (MibGetInputData.MibIndex.ServicesTableIndex.ServiceName)-1] = 0;
				rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
										PID_IPX,
										IPX_PROTOCOL_BASE,
										&MibGetInputData,
										sizeof(IPX_MIB_GET_INPUT_DATA),
										&Svp,
										&SvSize);
				if (rc==NO_ERROR) {
					j = LastServiceCache;
					type = Svp->Server.Type;
					name = (PUCHAR)"\0";
					idx = 0;
					MprAdminMIBBufferFree (Svp);
					continue;
				}
				else
					return rc;
			}
			j1=(j+1)%NUM_SERVICE_CACHES;
			if (j1!=LastServiceCache)
				j = j1;
			else
				break;
		}

		MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = type;
		MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[0] = 1;
		MibGetInputData.MibIndex.ServicesTableIndex.ServiceName[1] = 0;
		rc = MprAdminMIBEntryGet(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		if (rc!=NO_ERROR)
			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		if (rc!=NO_ERROR)
			return rc;
		do {
			for (i=0; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
				PSERVICE_CACHE_ENTRY	cur;
				while (ServiceCache[j][i]!=NULL) {
					cur = ServiceCache[j][i];
					MprAdminMIBBufferFree (cur->svc);
					ServiceCache[j][i] = cur->next;
					free (cur);
				}
			}
			ServiceCacheTimeStamp[j] = CurTime-CACHE_VALID_TIME;
			j = (j+1)%NUM_SERVICE_CACHES;
			if (j==LastServiceCache)
				break;
		}
		while (CurTime-ServiceCacheTimeStamp[j]>CACHE_VALID_TIME);

		j = (j+(NUM_SERVICE_CACHES-1))%NUM_SERVICE_CACHES;

		MibGetInputData.MibIndex.ServicesTableIndex.ServiceType = Svp->Server.Type;
		do {
			PSERVICE_CACHE_ENTRY	cur;
			cur = (PSERVICE_CACHE_ENTRY)malloc (sizeof (SERVICE_CACHE_ENTRY));
			if (cur!=NULL) {
				i = strlen ((PCHAR)Svp->Server.Name);
				cur->svc = Svp;
				cur->next = ServiceCache[j][i];
				ServiceCache[j][i] = cur;
			}
			else {
				MprAdminMIBBufferFree (Svp);
				return ERROR_NOT_ENOUGH_MEMORY;
			}

			strcpy (
				(PCHAR)MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
				(PCHAR)Svp->Server.Name);

			rc = MprAdminMIBEntryGetNext(g_MibServerHandle,
									PID_IPX,
									IPX_PROTOCOL_BASE,
									&MibGetInputData,
									sizeof(IPX_MIB_GET_INPUT_DATA),
									&Svp,
									&SvSize);
		}
		while ((rc==NO_ERROR)
			&& (Svp->Server.Type==MibGetInputData.MibIndex.ServicesTableIndex.ServiceType));

		if (rc==NO_ERROR)
			MprAdminMIBBufferFree (Svp);
		Svp = NULL;
		for (i=0; i<sizeof (ServiceCache[0])/sizeof (ServiceCache[0][0]); i++) {
			PSERVICE_CACHE_ENTRY	cur,prev=ServiceCache[j][i];
			ServiceCache[j][i] = NULL;
			while (prev!=NULL) {
				cur = prev;
				prev = cur->next;
				cur->next = ServiceCache[j][i];
				ServiceCache[j][i] = cur;
			}
			if ((type<MibGetInputData.MibIndex.ServicesTableIndex.ServiceType)
					&& (Svp==NULL) && (ServiceCache[j][i]!=NULL))
				Svp = ServiceCache[j][i]->svc;
		}

		GetSystemTimeAsFileTime ((LPFILETIME)&CurTime);
		ServiceCacheTimeStamp[j] = CurTime;
		ServiceCacheType[j] = MibGetInputData.MibIndex.ServicesTableIndex.ServiceType;
		LastServiceCache = j;
		
		if (Svp!=NULL) {
			*pSvp = Svp;
			return NO_ERROR;
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\enum.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: enum.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Enumeration functions.
//============================================================================


#ifndef _ENUM_H_
#define _ENUM_H_

//----------------------------------------------------------------------------
//
// GROUP_ENUMERATOR
//
//  dwLastGroup         Last group returned by this enumeration.
//
//  dwLastGroupMask     Mask associated with the group in dwLastGroup.
//
//  dwLastSource        Last source returned by this enumeration.
//
//  dwLastSourceMask    Mask associated with the group in dwLastSource.
//
//  dwSignature         Signature to mark this as a valid enumerator
//
//----------------------------------------------------------------------------


typedef struct _GROUP_ENUMERATOR
{
    DWORD           dwLastGroup;

    DWORD           dwLastGroupMask;

    DWORD           dwLastSource;

    DWORD           dwLastSourceMask;

    BOOL            bEnumBegun;

    DWORD           dwSignature;

} GROUP_ENUMERATOR, *PGROUP_ENUMERATOR;


#define MGM_ENUM_SIGNATURE      'ESig'


//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
);


//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
);


//----------------------------------------------------------------------------
// VerifyEnumeratorHandle
//
//----------------------------------------------------------------------------

PGROUP_ENUMERATOR
VerifyEnumeratorHandle(
    IN              HANDLE                  hEnum
);


//----------------------------------------------------------------------------
// GetNextGroupMemberships
//
//----------------------------------------------------------------------------

DWORD
GetNextGroupMemberships(
    IN              PGROUP_ENUMERATOR       pgeEnum,
    IN OUT          PDWORD                  pdwBufferSize,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries
);


//----------------------------------------------------------------------------
// GetNextMembershipsForThisGroup
//
//----------------------------------------------------------------------------

DWORD
GetNextMembershipsForThisGroup(
    IN              PGROUP_ENTRY            pge,
    IN OUT          PGROUP_ENUMERATOR       pgeEnum,
    IN              BOOL                    bIncludeFirst,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              DWORD                   dwMaxEntries
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\enum.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: enum.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Enumeration functions exported to IP Router Manager.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


DWORD
GetGroupMfes(
    IN              PGROUP_ENTRY            pge,
    IN              DWORD                   dwStartSource,
    IN OUT          PBYTE                   pbBuffer,
    IN              DWORD                   dwBufferSize,
    IN OUT          PDWORD                  pdwSize,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
);


VOID
CopyMfe(
    IN              PGROUP_ENTRY            pge,
    IN              PSOURCE_ENTRY           pse,
    IN  OUT         PBYTE                   pb,
    IN              DWORD                   dwFlags
);



//
// MFE enumeration
//

//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
)
{

    BOOL                bGrpLock = FALSE, bGrpEntryLock = FALSE;
    
    DWORD               dwErr = NO_ERROR, dwGrpBucket, dwSrcBucket, dwSizeReqd,
                        dwInd;

    PGROUP_ENTRY        pge;

    PSOURCE_ENTRY       pse;

    POUT_IF_ENTRY       poie;

    PLIST_ENTRY         ple, pleHead;



    TRACEENUM3( 
        ENUM, "ENTERED GetMfe : %x, %x, Stats : %x", pmimm-> dwGroup, 
        pmimm-> dwSource, dwFlags
        );
    
    do
    {
        //
        // Find group entry
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimm-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = TRUE;
        
        pleHead = GROUP_BUCKET_HEAD( dwGrpBucket );

        pge = GetGroupEntry( pleHead, pmimm-> dwGroup, 0 );

        if ( pge == NULL )
        {
            //
            // group entry not found, quit 
            //

            dwErr = ERROR_NOT_FOUND;

            break;
        }


        //
        // acquire group entry lock and release group bucket lock
        //
        
        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;


        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = FALSE;

        
        //
        // Find Source entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( pmimm-> dwSource, pmimm-> dwSrcMask );

        pleHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        pse = GetSourceEntry( pleHead, pmimm-> dwSource, pmimm-> dwSrcMask );

        if ( pse == NULL )
        {
            //
            // Source entry not found, quit
            //

            dwErr = ERROR_NOT_FOUND;

            break;
        }
        
        
        //
        // check buffersize requirements 
        //

        dwSizeReqd = ( dwFlags ) ?
                        ( (dwFlags == MGM_MFE_STATS_0) ?
                           SIZEOF_MIB_MFE_STATS( pse-> dwMfeIfCount ) :
                           SIZEOF_MIB_MFE_STATS_EX( 
                            pse-> dwMfeIfCount ) ) :
                        SIZEOF_MIB_MFE( pse-> dwMfeIfCount );

        if ( *pdwBufferSize < dwSizeReqd )
        {
            //
            // buffer supplied is too small to fit the MFE
            //
            
            *pdwBufferSize = dwSizeReqd;

            dwErr = ERROR_INSUFFICIENT_BUFFER;

            break;
        }

        
        //
        // if mfe statistics have been requested and
        //    mfe is in the kernel 
        //      get it 
        //

        if ( dwFlags && pse-> bInForwarder )
        {
            GetMfeFromForwarder( pge, pse );
        }

#if 1
        CopyMfe( pge, pse, pbBuffer, dwFlags );
#else        
        //
        // copy base MFE into user supplied buffer
        //

        pmimms = ( PMIB_IPMCAST_MFE_STATS ) pbBuffer;

        pmimms-> dwGroup            = pge-> dwGroupAddr;
        pmimms-> dwSource           = pse-> dwSourceAddr;
        pmimms-> dwSrcMask          = pse-> dwSourceMask;

        pmimms-> dwInIfIndex        = pse-> dwInIfIndex;
        pmimms-> dwUpStrmNgbr       = pse-> dwUpstreamNeighbor;
        pmimms-> dwInIfProtocol     = pse-> dwInProtocolId;

        pmimms-> dwRouteProtocol    = pse-> dwRouteProtocol;
        pmimms-> dwRouteNetwork     = pse-> dwRouteNetwork;
        pmimms-> dwRouteMask        = pse-> dwRouteMask;
        
        pmimms-> ulNumOutIf         = pse-> imsStatistics.ulNumOutIf;
        pmimms-> ulInPkts           = pse-> imsStatistics.ulInPkts;
        pmimms-> ulInOctets         = pse-> imsStatistics.ulInOctets;
        pmimms-> ulPktsDifferentIf  = pse-> imsStatistics.ulPktsDifferentIf;
        pmimms-> ulQueueOverflow    = pse-> imsStatistics.ulQueueOverflow;

        
        MgmElapsedSecs( &pse-> liCreationTime, &pmimms-> ulUpTime );
                                        
        pmimms-> ulExpiryTime = pse-> dwTimeOut - pmimms-> ulUpTime;


        //
        // copy all the OIL entries
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimms-> rgmiosOutStats[ dwInd ].dwOutIfIndex = 
                poie-> imosIfStats.dwOutIfIndex;
                
            pmimms-> rgmiosOutStats[ dwInd ].dwNextHopAddr = 
                poie-> imosIfStats.dwNextHopAddr;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulTtlTooLow = 
                poie-> imosIfStats.ulTtlTooLow;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulFragNeeded = 
                poie-> imosIfStats.ulFragNeeded;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulOutPackets = 
                poie-> imosIfStats.ulOutPackets;
                
            pmimms-> rgmiosOutStats[ dwInd ].ulOutDiscards = 
                poie-> imosIfStats.ulOutDiscards;
        }
#endif

    } while ( FALSE );


    //
    // release locks are appropriate
    //
    
    if ( bGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }


    TRACEENUM1( ENUM, "LEAVING GetMfe :: %x", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// GetNextMfe
//
//----------------------------------------------------------------------------

DWORD
GetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
)
{

    BOOL            bFound, bgeLock = FALSE;
    
    DWORD           dwGrpBucket, dwErr = NO_ERROR, dwBufferLeft, 
                    dwStartSource, dwSize;

    PBYTE           pbStart;
    
    PGROUP_ENTRY    pge;
    
    PLIST_ENTRY     ple, pleMasterHead, pleGrpBucket;

    

    TRACEENUM2( 
        ENUM, "ENTERED GetNextMfe (G, S) = (%x, %x)", pmimmStart-> dwGroup, 
        pmimmStart-> dwSource 
        );


    do
    {
        //
        // 1. Lock group hash bucket.
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimmStart-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                
        //
        // 2. merge temp and master lists
        //      - Lock temp list
        //      - merge temp with master list
        //      - unlock temp list
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );

        ACQUIRE_MASTER_GROUP_LOCK_SHARED();

        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();


        pleMasterHead = MASTER_GROUP_LIST_HEAD();

        ple = pleMasterHead-> Flink;

        //
        // To retrieve the next set of group entries in lexicographic order, 
        // given a group entry (in this case specified by pmimmStart-> dwGroup)
        // the master group list must be walked from the head until either 
        // the group entry specified is found or the next "higher" group entry 
        // is found.  This is expensive.
        //
        // As an optimization the group specified (pmimmStart-> dwGroup) is
        // looked up in the group hash table.  If an entry is found, then the
        // group entry contains links into the master (lexicographic) group
        // list. These links can the used to determine the next entries in 
        // the group list.  This way we can quickly find an group entry in
        // the master list rather than walk the master group list from the
        // beginning.
        //
        // It should be noted that in case the group entry specified in not
        // present in the group hash table, it will be necessary to walk the
        // master group list from the start.
        //
        // Each group entry is present in two lists, the hash bucket list 
        // and either temp group list or the master group list.
        //
        // For this optimization to "work", it must be ensured that an entry
        // present in the hash table is also present in the master
        // group list.  To ensure this the temp group list is merged into
        // the master group list before searching the group hash table for
        // the specified entry.
        //

        
        //
        // At this point the group under consideration (pmimmStart-> dwGroup),
        // cannot be added to either the hash bucket or master group list
        // if it is not already present because both the group hash bucket lock
        // and the master list lock have been acquired.
        //

        //
        // 3. find group entry in the hash list
        //

        pleGrpBucket = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        pge = GetGroupEntry( pleGrpBucket, pmimmStart-> dwGroup, 0 );

        if ( pge != NULL )
        {
            //
            // group entry for pmimmStart-> dwGroup is present. lock the entry.
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bgeLock = TRUE;

            //
            // release group hash bucket lock
            //

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        }
        
        else
        {
            
            //
            // group entry is not present in the hash table, which implies
            // that the group entry is not present at all.
            //

            //
            // release group hash bucket lock
            //

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
            
            //
            // 3.1 Walk master list from the start to determine the next 
            //     highest group entry.
            //

            bFound = FindGroupEntry( 
                        pleMasterHead, pmimmStart-> dwGroup, 0,
                        &pge, FALSE
                        );

            if ( !bFound && pge == NULL )
            {
                //
                // No more group entries left to enumerate
                //

                dwErr = ERROR_NO_MORE_ITEMS;

                RELEASE_MASTER_GROUP_LOCK_SHARED();

                break;
            }


            //
            // Next group entry found.  lock it
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bgeLock = TRUE;

            bIncludeFirst = TRUE;
        }


        //
        // At this point we have the group entry we want which is
        // either the one for pmimmStart-> dwGroup OR the next higher
        // one (if there is no group entry for pmimmStart-> Group).
        //

        //
        // 4. Now get as many source entries as will fit into 
        //    the buffer provided.
        //

        dwBufferLeft    = *pdwBufferSize;

        pbStart         = pbBuffer;

        *pdwNumEntries  = 0;

        dwStartSource   = ( bIncludeFirst ) ? 0 : pmimmStart-> dwSource;

        dwSize          = 0;

        
        while ( ( dwErr = GetGroupMfes( pge, dwStartSource, pbStart, 
                              dwBufferLeft, &dwSize, pdwNumEntries, 
                              bIncludeFirst, dwFlags ) ) 
                == ERROR_MORE_DATA )
        {
            //
            // more data items will fit into this buffer, but no more 
            // source entries available in this group entry
            //
            // 4.1 Move forward to next group entry.
            //

            pbStart         += dwSize;

            dwBufferLeft    -= dwSize;

            dwSize          = 0;

            dwStartSource   = 0;

            
            //
            // 4.1.1 Release this group entry lock
            //
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


            //
            // 4.1.2 get next entry lock
            //

            ple = pge-> leGrpList.Flink;

            if ( ple == pleMasterHead )
            {
                //
                // No more group entries in the master group list.
                // All MFEs have been exhausted. So quit.
                //
                
                dwErr = ERROR_NO_MORE_ITEMS;

                bgeLock = FALSE;
                
                break;
            }

            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpList );

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

            dwStartSource = 0;

            bIncludeFirst = TRUE;
        }


        //
        // 5. you have packed as much as possible into the buffer
        //
        //  Clean up and return the correct error code.
        //
        
        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }


        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // ran out of buffer.  If there is at least one Mfe
            // packed into the buffer provided then it is ok.
            //

            if ( *pdwNumEntries != 0 )
            {
                dwErr = ERROR_MORE_DATA;
            }

            else
            {
                //
                // not even one entry could be packed into the buffer
                // return the size required for this so that an
                // appropriately sized buffer can be allocated for the
                // next call.
                //

                *pdwBufferSize = dwSize;
            }
        }

        RELEASE_MASTER_GROUP_LOCK_SHARED();
        
    } while ( FALSE );


    TRACEENUM1( ENUM, "LEAVING GetNextMfe : %x", dwErr );

    return dwErr;
}



//----------------------------------------------------------------------------
//
// GetGroupMfes
//
// Retrieves as many MFEs for a group starting at the specified source.
// Assumes that the group entry is locked.
//----------------------------------------------------------------------------

DWORD
GetGroupMfes(
    IN              PGROUP_ENTRY            pge,
    IN              DWORD                   dwStartSource,
    IN OUT          PBYTE                   pbBuffer,
    IN              DWORD                   dwBufferSize,
    IN OUT          PDWORD                  pdwSize,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              BOOL                    bIncludeFirst,
    IN              DWORD                   dwFlags
)
{

    BOOL            bFound;
    
    DWORD           dwErr = ERROR_MORE_DATA, dwSrcBucket,
                    dwSizeReqd, dwInd;

    PSOURCE_ENTRY   pse = NULL;

    PLIST_ENTRY     pleMasterHead, pleSrcBucket, ple = NULL,
                    pleSrc;
    
    POUT_IF_ENTRY   poie = NULL;


    TRACEENUM2( 
        ENUM, "ENTERED GetGroupMfes : %x, %x", 
        pge-> dwGroupAddr, dwStartSource
        );

    do
    {
        //
        // merge temp and group source lists
        //

        MergeTempAndMasterSourceLists( pge );

        
        //
        // similar to the group lookup, optimize the source lookup
        // by first trying to find the source entry in the source
        // hash table.  
        //
        // If found in the hash table then use the entry's links 
        // the into master source list to find next entry.
        //
        // if not found in the hash table walk the master list from
        // the beginning to determine the next entry.
        //

        pleMasterHead   = MASTER_SOURCE_LIST_HEAD( pge );

        dwSrcBucket     = SOURCE_TABLE_HASH( dwStartSource, 0 );

        pleSrcBucket    = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );


        bFound = FindSourceEntry( pleSrcBucket, dwStartSource, 0, &pse, TRUE );

        if ( !bFound )
        {
            //
            // source entry is not present in the hash table
            // Walk the master source list from the start.
            //

            pse = NULL;
            
            FindSourceEntry( pleMasterHead, 0, 0, &pse, FALSE );


            //
            // No next entry found in the master list.  Implies
            // no more sources in the master source list for this group.
            //
            
            if ( pse == NULL )
            {
                break;
            }
        }

        else
        {
            //
            // Entry for starting source found in hash table.
            // Use its links into the master list to get next entry.
            //

            if ( !bIncludeFirst )
            {
                ple = pse-> leSrcList.Flink;

                pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcList );
            }
        }


        //
        // At this point the entry pointed to by pse is the first entry
        // the needs to be packed into the buffer supplied.  Starting
        // with this source entry keep packing MFEs into the
        // buffer till there are no more MFEs for this group.
        //
        
        pleSrc = &pse-> leSrcList;

        //
        // while there are source entries for this group entry
        //
        
        while ( pleSrc != pleMasterHead )
        {
            pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );


            //
            // Is this source entry an MFE
            //
            
            if ( !IS_VALID_INTERFACE( pse-> dwInIfIndex, 
                    pse-> dwInIfNextHopAddr ) )
            {
                pleSrc = pleSrc-> Flink;

                continue;
            }


            //
            // This source entry is an MFE also.
            //

            //
            // Check if enough space left in the buffer to fit this MFE.
            //
            // If not and not a single MFE is present in the buffer then
            // return the size required to fit this MFE.
            //
            
            dwSizeReqd = ( dwFlags ) ? 
                            ( ( dwFlags == MGM_MFE_STATS_0 ) ?
                                SIZEOF_MIB_MFE_STATS( pse-> dwMfeIfCount ) :
                                SIZEOF_MIB_MFE_STATS_EX( 
                                    pse-> dwMfeIfCount 
                                ) ) :
                            SIZEOF_MIB_MFE( pse-> dwMfeIfCount );

            if ( dwBufferSize < dwSizeReqd )
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;

                if ( *pdwNumEntries == 0 )
                {
                    *pdwSize = dwSizeReqd;
                }

                break;
            }


            //
            // If MFE stats have been requested and
            //    MFE is present in the forwarder
            //      get them.
            //

            if ( dwFlags && pse-> bInForwarder )
            {
                //
                // MFE is currently in the forwarder.  Query it and update
                // stats user mode.
                //

                GetMfeFromForwarder( pge, pse );
            }

            
            //
            // copy base MFE into user supplied buffer
            //


            CopyMfe( pge, pse, pbBuffer, dwFlags );

            pbBuffer        += dwSizeReqd;

            dwBufferSize    -= dwSizeReqd;

            *pdwSize        += dwSizeReqd;

            (*pdwNumEntries)++;

            pleSrc           = pleSrc-> Flink;
        }
        
    } while ( FALSE );


    TRACEENUM2( ENUM, "LEAVING GetGroupsMfes : %d %d", *pdwNumEntries, dwErr );

    return dwErr;
}


//============================================================================
// Group Enumeration
//
//============================================================================


PGROUP_ENUMERATOR
VerifyEnumeratorHandle(
    IN              HANDLE                  hEnum
)
{

    DWORD                       dwErr;
    
    PGROUP_ENUMERATOR           pgeEnum;


    
    pgeEnum = (PGROUP_ENUMERATOR) 
                        ( ( (ULONG_PTR) hEnum ) 
                                ^ (ULONG_PTR) MGM_ENUM_HANDLE_TAG );

    try
    {
        if ( pgeEnum-> dwSignature != MGM_ENUM_SIGNATURE )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE0( ANY, "Invalid Enumeration handle" );

            pgeEnum = NULL;
        }
    }
    
    except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? 
                                   EXCEPTION_EXECUTE_HANDLER :
                                   EXCEPTION_CONTINUE_SEARCH )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        TRACE0( ANY, "Invalid enumeration handle" );
        
        pgeEnum = NULL;
    }

    return pgeEnum;
}


//
// Get Memberships for buckets
//

DWORD
GetNextGroupMemberships(
    IN              PGROUP_ENUMERATOR       pgeEnum,
    IN OUT          PDWORD                  pdwBufferSize,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries
)
{

    BOOL            bIncludeFirst = TRUE, bFound;

    DWORD           dwMaxEntries, dwGrpBucket, dwErr = ERROR_NO_MORE_ITEMS;

    PGROUP_ENTRY    pge = NULL;

    PSOURCE_GROUP_ENTRY psge;
    
    PLIST_ENTRY     ple, pleGrpHead;


    
    do
    {
        //
        // Compute the number of entries that will fit into the buffer
        //

        dwMaxEntries = (*pdwBufferSize) / sizeof( SOURCE_GROUP_ENTRY );


        //
        // STEP I :
        //

        //
        // position the start of the GetNext to the group entry that was
        // the last enumerated by the previous GetNext operation
        //

        //
        // Find the last group entry retrieved by the previous get operation. 
        //

        dwGrpBucket = GROUP_TABLE_HASH( 
                        pgeEnum-> dwLastGroup, pgeEnum-> dwLastGroupMask 
                        );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        bFound = FindGroupEntry( 
                    pleGrpHead, pgeEnum-> dwLastGroup, 
                    pgeEnum-> dwLastGroupMask, &pge, TRUE
                    );

        if ( bFound )
        {
            //
            // group entry found
            //
            
            bIncludeFirst = !pgeEnum-> bEnumBegun;
        }

        

        //
        // last group entry retrieved by previous getnext is no 
        // longer present
        //

        //
        // check if there are any more group entries present in 
        // the same bucket
        //

        else if ( pge != NULL )
        {
            //
            // Next group entry in the same group bucket.  
            // For a new group start from the first source bucket, 
            // first source entry. 
            //

            pgeEnum-> dwLastSource      = 0;
            pgeEnum-> dwLastSourceMask  = 0;
        }

        
        else // ( pge == NULL )
        {
            //
            // no more entries in this group bucket, move to next
            // non-empty group bucket entry.
            //

            //
            // skip empty buckets in the group hash table
            //
            
            do
            {
                RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

                dwGrpBucket++;

                if ( dwGrpBucket >= GROUP_TABLE_SIZE ) 
                {
                    //
                    // Entire hash table has been traversed, quit
                    //

                    break;
                }

                //
                // Move to next group bucket
                //
                
                ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );


                //
                // Check if any group entries present
                //
                
                if ( !IsListEmpty( pleGrpHead ) )
                {
                    //
                    // group bucket has at least on group entry
                    //
                    
                    pge = CONTAINING_RECORD( 
                            pleGrpHead-> Flink, GROUP_ENTRY, leGrpHashList
                            );

                    //
                    // For a new group start from the first source bucket, 
                    // first source entry. 
                    //

                    pgeEnum-> dwLastSource      = 0;
                    pgeEnum-> dwLastSourceMask  = 0;

                    break;
                }

                //
                // Empty group bucket, move to next one
                //
                
            } while ( TRUE );
        }
        

        //
        // if all hash buckets have been traversed, quit.
        //
        
        if ( dwGrpBucket >= GROUP_TABLE_SIZE )
        {
            break;
        }
        

        //
        // STEP II:
        //

        //
        // start retrieving group membership entries
        //

#pragma prefast(suppress: 11, pge will be initialized else we would broken out above (PREFast bug 758))
        ple = &pge-> leGrpHashList;
        

        //
        // Walk each hash bucket starting from dwGrpBucket to GROUP_TABLE_SIZE
        //

        while ( dwGrpBucket < GROUP_TABLE_SIZE )
        {
            //
            // For each group hash table bucket
            //
            
            while ( ple != pleGrpHead )
            {
                //
                // For each group entry in the bucket
                //

                pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

                ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
                
                dwErr = GetNextMembershipsForThisGroup( 
                            pge, pgeEnum, bIncludeFirst, pbBuffer,
                            pdwNumEntries, dwMaxEntries
                            );

                RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
                
                if ( dwErr == ERROR_MORE_DATA )
                {
                    //
                    // User supplied buffer is full.
                    //

                    break;
                }
                

                //
                // Move to next entry
                //
                
                ple = ple-> Flink;

                //
                // Next group entry in the same group bucket.  
                // For a new group start from the first source bucket, 
                // first source entry. 
                //
                
                pgeEnum-> dwLastSource = 0;
                
                pgeEnum-> dwLastSourceMask = 0;

                bIncludeFirst = TRUE;
            }

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

            if ( dwErr == ERROR_MORE_DATA )
            {
                break;
            }


            //
            // Move to next group bucket
            //
            
            dwGrpBucket++;

            //
            // skip empty group hash buckets
            //
            
            while ( dwGrpBucket < GROUP_TABLE_SIZE )
            {
                ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                pleGrpHead = GROUP_BUCKET_HEAD( dwGrpBucket );

                if ( !IsListEmpty( pleGrpHead ) )
                {
                    break;
                }

                RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

                dwGrpBucket++;
            } 

            
            if ( dwGrpBucket >= GROUP_TABLE_SIZE )
            {
                //
                // All group buckets have traversed.  End of enumeration
                //
                
                dwErr = ERROR_NO_MORE_ITEMS;
            }

            else
            {
                //
                // New group hash bucket, start from source entry 0.
                //
                
                ple = pleGrpHead-> Flink;
                
                pgeEnum-> dwLastSource      = 0;
                pgeEnum-> dwLastSourceMask  = 0;
                bIncludeFirst               = TRUE;
            }            
        }
        
    } while ( FALSE );

    pgeEnum-> bEnumBegun    = TRUE;


    //
    // Store the position where the enumeration ended
    //
    
    psge = (PSOURCE_GROUP_ENTRY) pbBuffer;

    if ( *pdwNumEntries )
    {
        pgeEnum-> dwLastSource      = psge[ *pdwNumEntries - 1 ].dwSourceAddr;
        
        pgeEnum-> dwLastSourceMask  = psge[ *pdwNumEntries - 1 ].dwSourceMask;
        
        pgeEnum-> dwLastGroup       = psge[ *pdwNumEntries - 1 ].dwGroupAddr;
        
        pgeEnum-> dwLastGroupMask   = psge[ *pdwNumEntries - 1 ].dwGroupMask;
    }

    else
    {
        pgeEnum-> dwLastSource      = 0xFFFFFFFF;
        
        pgeEnum-> dwLastSourceMask  = 0xFFFFFFFF;
        
        pgeEnum-> dwLastGroup       = 0xFFFFFFFF;
        
        pgeEnum-> dwLastGroupMask   = 0xFFFFFFFF;
    }
    
    return dwErr;
}


//----------------------------------------------------------------------------
// GetMemberships for Group
//
//----------------------------------------------------------------------------

DWORD
GetNextMembershipsForThisGroup(
    IN              PGROUP_ENTRY            pge,
    IN OUT          PGROUP_ENUMERATOR       pgeEnum,
    IN              BOOL                    bIncludeFirst,
    IN OUT          PBYTE                   pbBuffer,
    IN OUT          PDWORD                  pdwNumEntries,
    IN              DWORD                   dwMaxEntries
)
{

    BOOL                    bFound;
    
    DWORD                   dwErr = ERROR_NO_MORE_ITEMS, dwSrcBucket;

    PSOURCE_GROUP_ENTRY     psgBuffer;
    
    PSOURCE_ENTRY           pse = NULL;
    
    PLIST_ENTRY             pleSrcHead, ple;

    
    
    do
    {

        if ( *pdwNumEntries >= dwMaxEntries )
        {
            //
            // quit here.
            //

            dwErr = ERROR_MORE_DATA;

            break;
        }

        
        psgBuffer = (PSOURCE_GROUP_ENTRY) pbBuffer;
        

        //
        // STEP I:
        // Position start of enumeration  
        //

        dwSrcBucket = SOURCE_TABLE_HASH( 
                        pgeEnum-> dwLastSource, pgeEnum-> dwLastSourceMask 
                        );
                        
        pleSrcHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        bFound = FindSourceEntry(
                    pleSrcHead, pgeEnum-> dwLastSource, 
                    pgeEnum-> dwLastSourceMask, &pse, TRUE
                    );

        if ( bFound )
        {
            if ( ( bIncludeFirst ) && !IsListEmpty( &pse-> leOutIfList ) )
            {
                //
                // the first group membership found.
                //

                psgBuffer[ *pdwNumEntries ].dwSourceAddr = pse-> dwSourceAddr;
                
                psgBuffer[ *pdwNumEntries ].dwSourceMask = pse-> dwSourceMask;

                psgBuffer[ *pdwNumEntries ].dwGroupAddr   = pge-> dwGroupAddr;

                psgBuffer[ (*pdwNumEntries)++ ].dwGroupMask  = pge-> dwGroupMask;
                
                if ( *pdwNumEntries >= dwMaxEntries )
                {
                    //
                    // buffer full. quit here.
                    //

                    dwErr = ERROR_MORE_DATA;

                    break;
                }

                //
                // move to next source
                //

                ple = pse-> leSrcHashList.Flink;
            }

            else
            {
                ple = pse-> leSrcHashList.Flink;
            }
        }

        else if ( pse != NULL )
        {
            ple = &pse-> leSrcHashList;
        }

        else
        {
            ple = pleSrcHead-> Flink;
        }

        
        //
        // STEP II:
        //
        // enumerate group memberships
        //

        while ( *pdwNumEntries < dwMaxEntries ) 
        {
            //
            // for each source bucket
            //
            
            while ( ( ple != pleSrcHead ) && 
                    ( *pdwNumEntries < dwMaxEntries ) )
            {
                //
                // for each source entry in the bucket
                //

                //
                // if group membership exists for this source
                //

                pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );
                
                if ( !IsListEmpty( &pse-> leOutIfList ) )
                {
                    psgBuffer[ *pdwNumEntries ].dwSourceAddr = 
                        pse-> dwSourceAddr;
                    
                    psgBuffer[ *pdwNumEntries ].dwSourceMask = 
                        pse-> dwSourceMask;

                    psgBuffer[ *pdwNumEntries ].dwGroupAddr   = 
                        pge-> dwGroupAddr;

                    psgBuffer[ (*pdwNumEntries)++ ].dwGroupMask  = 
                        pge-> dwGroupMask;
                    
                    if ( *pdwNumEntries >= dwMaxEntries )
                    {
                        dwErr = ERROR_MORE_DATA;
                    }
                }

                ple = ple-> Flink;
            }

            dwSrcBucket++;

            if ( dwSrcBucket < SOURCE_TABLE_SIZE )
            {
                pleSrcHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

                ple = pleSrcHead-> Flink;
            }

            else
            {
                //
                // all source buckets for this group have been 
                // traversed.  quit this group entry
                //
                
                break;
            }
        }
        
    } while ( FALSE );

    return dwErr;
}


//----------------------------------------------------------------------------
// Copy the MFE (optionally with stats) 
//
//----------------------------------------------------------------------------

VOID
CopyMfe(
    IN              PGROUP_ENTRY            pge,
    IN              PSOURCE_ENTRY           pse,
    IN  OUT         PBYTE                   pb,
    IN              DWORD                   dwFlags
)
{
    DWORD                   dwInd;
    
    PLIST_ENTRY             ple, pleHead;
    
    POUT_IF_ENTRY           poie;
    
    PMIB_IPMCAST_MFE        pmimm = NULL;

    PMIB_IPMCAST_MFE_STATS  pmimms = NULL;

    PMIB_IPMCAST_OIF_STATS  pmimos = NULL;
   
    //
    // copy base MFE into user supplied buffer
    //

    if ( dwFlags )
    {
        //
        // Need to base MFE
        //

        pmimms = ( PMIB_IPMCAST_MFE_STATS ) pb;

        pmimms-> dwGroup            = pge-> dwGroupAddr;
        pmimms-> dwSource           = pse-> dwSourceAddr;
        pmimms-> dwSrcMask          = pse-> dwSourceMask;

        pmimms-> dwInIfIndex        = pse-> dwInIfIndex;
        pmimms-> dwUpStrmNgbr       = pse-> dwUpstreamNeighbor;
        pmimms-> dwInIfProtocol     = pse-> dwInProtocolId;
        
        pmimms-> dwRouteProtocol    = pse-> dwRouteProtocol;
        pmimms-> dwRouteNetwork     = pse-> dwRouteNetwork;
        pmimms-> dwRouteMask        = pse-> dwRouteMask;
        
        MgmElapsedSecs( &pse-> liCreationTime, &pmimms-> ulUpTime );

        pmimms-> ulExpiryTime = pse-> dwTimeOut - pmimms-> ulUpTime;
        

        //
        // Copy incoming stats
        //
        
        pmimms-> ulNumOutIf         = pse-> dwMfeIfCount;
        pmimms-> ulInPkts           = pse-> imsStatistics.ulInPkts;
        pmimms-> ulInOctets         = pse-> imsStatistics.ulInOctets;
        pmimms-> ulPktsDifferentIf  = pse-> imsStatistics.ulPktsDifferentIf;
        pmimms-> ulQueueOverflow    = pse-> imsStatistics.ulQueueOverflow;

        if ( dwFlags & MGM_MFE_STATS_1 )
        {
            PMIB_IPMCAST_MFE_STATS_EX  pmimmsex = 
                ( PMIB_IPMCAST_MFE_STATS_EX ) pb;

            pmimmsex-> ulUninitMfe      = pse-> imsStatistics.ulUninitMfe;
            pmimmsex-> ulNegativeMfe    = pse-> imsStatistics.ulNegativeMfe;
            pmimmsex-> ulInDiscards     = pse-> imsStatistics.ulInDiscards;
            pmimmsex-> ulInHdrErrors    = pse-> imsStatistics.ulInHdrErrors;
            pmimmsex-> ulTotalOutPackets= pse-> imsStatistics.ulTotalOutPackets;

            pmimos = pmimmsex-> rgmiosOutStats;
        }

        else
        {
            pmimos = pmimms-> rgmiosOutStats;
        }

        //
        // copy all the OIL entries
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimos[ dwInd ].dwOutIfIndex = poie-> dwIfIndex;
            pmimos[ dwInd ].dwNextHopAddr = poie-> dwIfNextHopAddr;

            //
            // Copy outgoing stats
            //
            
            pmimos[ dwInd ].ulTtlTooLow = poie-> imosIfStats.ulTtlTooLow;
            pmimos[ dwInd ].ulFragNeeded = poie-> imosIfStats.ulFragNeeded;
            pmimos[ dwInd ].ulOutPackets = poie-> imosIfStats.ulOutPackets;
            pmimos[ dwInd ].ulOutDiscards = poie-> imosIfStats.ulOutDiscards;
        }
    }

    else
    {
        //
        // Need to copy non-stats MFE structure only
        //

        pmimm = (PMIB_IPMCAST_MFE) pb;

        pmimm-> dwGroup             = pge-> dwGroupAddr;
        pmimm-> dwSource            = pse-> dwSourceAddr;
        pmimm-> dwSrcMask           = pse-> dwSourceMask;

        pmimm-> dwInIfIndex         = pse-> dwInIfIndex;
        pmimm-> dwUpStrmNgbr        = pse-> dwUpstreamNeighbor;
        pmimm-> dwInIfProtocol      = pse-> dwInProtocolId;

        pmimm-> dwRouteProtocol     = pse-> dwRouteProtocol;
        pmimm-> dwRouteNetwork      = pse-> dwRouteNetwork;
        pmimm-> dwRouteMask         = pse-> dwRouteMask;
        
        pmimm-> ulNumOutIf          = pse-> dwMfeIfCount;

        MgmElapsedSecs( &pse-> liCreationTime, &pmimm-> ulUpTime );

        pmimm-> ulExpiryTime = pse-> dwTimeOut - pmimm-> ulUpTime;


        //
        // copy all the OIL entries minus the stats
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink, dwInd = 0; 
              ple != pleHead; 
              ple = ple-> Flink, dwInd++ )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

            pmimm-> rgmioOutInfo[ dwInd ].dwOutIfIndex = 
                poie-> dwIfIndex;
                
            pmimm-> rgmioOutInfo[ dwInd ].dwNextHopAddr = 
                poie-> dwIfNextHopAddr;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\defs.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: ipmgm.h
//
// History:
//      V Raman Aug-6-1997  Created.
//
// Contains type definitions and declarations for IP MGM.
//============================================================================

#ifndef _MGMDEFS_H_
#define _MGMDEFS_H_


#define MGM_CLIENT_HANDLE_TAG       ('MGMc' << 8)

#define MGM_ENUM_HANDLE_TAG         ('MGMe' << 8)

//----------------------------------------------------------------------------
// Protocol constants
//----------------------------------------------------------------------------

#define INVALID_PROTOCOL_ID         0xffffffff
#define INVALID_COMPONENT_ID        0xffffffff

#define IS_VALID_PROTOCOL( a, b ) \
        (a) != INVALID_PROTOCOL_ID && (b) != INVALID_COMPONENT_ID

#define IS_PROTOCOL_IGMP( p )  \
        ( (p)-> dwProtocolId == PROTO_IP_IGMP )

#define IS_ROUTING_PROTOCOL( p )  \
        !IS_PROTOCOL_IGMP( p )

#define IS_PROTOCOL_ID_IGMP( i ) \
        (i) == PROTO_IP_IGMP

//----------------------------------------------------------------------------
// Interface constants
//----------------------------------------------------------------------------

#define INVALID_INTERFACE_INDEX     0x0
#define INVALID_NEXT_HOP_ADDR       0x0

#define IS_VALID_INTERFACE( a, b )  \
        (a) != INVALID_INTERFACE_INDEX


//----------------------------------------------------------------------------
// Wildcard source/group macros
//----------------------------------------------------------------------------

#define WILDCARD_GROUP              0x0
#define WILDCARD_GROUP_MASK         0x0

#define WILDCARD_SOURCE             0x0
#define WILDCARD_SOURCE_MASK        0x0


#define IS_WILDCARD_GROUP( a, b )   (a) == WILDCARD_GROUP

#define IS_WILDCARD_SOURCE( a, b )  (a) == WILDCARD_SOURCE


//----------------------------------------------------------------------------
// Time conversion constants and macros
//----------------------------------------------------------------------------

#define SYSTIME_UNITS_PER_MSEC      (1000 * 10)
#define SYSTIME_UNITS_PER_SEC       (1000 * SYSTIME_UNITS_PER_MSEC)
#define SYSTIME_UNITS_PER_MINUTE    (60 * SYSTIME_UNITS_PER_SEC)

#define EXPIRY_INTERVAL             15 * 60 * 1000

#define ROUTE_CHECK_INTERVAL        \
        SYSTIME_UNITS_PER_MINUTE / SYSTIME_UNITS_PER_MSEC


#define MgmQuerySystemTime(p)   NtQuerySystemTime((p))

#define MgmSetExpiryTime(p, i)                                              \
{                                                                           \
    LARGE_INTEGER __li = { i };                                             \
    *(p) = RtlLargeIntegerAdd( *(p), __li );                                \
}


#define MgmElapsedTime( p, q, u )                                           \
{                                                                           \
    LARGE_INTEGER __li1, __li2;                                             \
    ULONG         __rem;                                                    \
    MgmQuerySystemTime( &__li1);                                            \
    __li2 = RtlLargeIntegerSubtract( __li1, *(p) );                         \
    __li1 = RtlExtendedLargeIntegerDivide( __li2, u, &__rem );              \
    *(q) = __li1.LowPart;                                                   \
}

#define MgmElapsedSecs( p, q )      \
        MgmElapsedTime( p, q, SYSTIME_UNITS_PER_SEC )


#define TIMER_TABLE_MAX_SIZE        16


//----------------------------------------------------------------------------
// IP address manipulation macros
//  Bolade's macro.
//----------------------------------------------------------------------------

//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )


//
// IPv4 mask len
//

#define IPv4_ADDR_LEN            32

#endif // _MGMDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\forward.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: forward.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Wrapper functions for callbacks into IP Router Manager.
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


VOID
GetMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    BOOL                        bFound;
    
    DWORD                       dwErr = NO_ERROR, dwInd;

    PLIST_ENTRY                 ple, pleHead;
    
    POUT_IF_ENTRY               poie = NULL;
    
    PIPMCAST_MFE_STATS          pimms = NULL;

    
    TRACEFORWARD4(
        FORWARD, "ENTERED GetMfeFromForwarder : Group : %x, %x : Source : "
        "%x, %x : ", pge-> dwGroupAddr, pge-> dwGroupMask, pse-> dwSourceAddr,
        pse-> dwSourceMask
        );

    
    do
    {
        //
        // if MFE is not in forwarder, do not get it
        //

        if ( !pse-> bInForwarder )
        {
            break;    
        }

        
        //
        // Allocate large enough buffer and set up query
        //

        pimms = MGM_ALLOC( SIZEOF_MFE_STATS( pse-> dwMfeIfCount ) );

        if ( pimms == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "GetMfeFromForwarder : Failed to create MFE of size : %x",
                SIZEOF_MFE_STATS( pse-> dwMfeIfCount )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimms, SIZEOF_MFE_STATS( pse-> dwMfeIfCount ) );

        pimms-> dwGroup     = pge-> dwGroupAddr;

        pimms-> dwSource    = pse-> dwSourceAddr;
        
        pimms-> dwSrcMask   = pse-> dwSourceMask;

        pimms-> ulNumOutIf  = pse-> dwMfeIfCount;


        //
        // Get MFE
        //

        dwErr = GET_MFE_CALLBACK()( pimms );
        
        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "GetMfeFromForwarder : Failed to get MFE from forwarder"
                ": %x", dwErr
                );

            break;            
        }


        //
        // Update base MFE statistics
        //

        RtlCopyMemory( &pse-> imsStatistics, pimms, SIZEOF_BASIC_MFE_STATS );


    TRACEFORWARD4( 
        FORWARD, "Group : %x, Source : %x, In Interface : %x, #out if : %x",
        pimms-> dwGroup, pimms-> dwSource, pimms-> dwInIfIndex, pimms-> ulNumOutIf
        );

    TRACEFORWARD4( 
        FORWARD, "In Packets : %d, In Bytes : %d, Diff i/f : %d, Q overflow : %d",
        pimms-> ulInPkts, pimms-> ulInOctets, pimms-> ulPktsDifferentIf, 
        pimms-> ulQueueOverflow
        );
            
        
        //
        // Update statistics for each outgoing interface
        //

        pleHead = &pse-> leMfeIfList;
        

        //
        // for each outgoing interface in the MFE present in the KMF
        //
        
        for ( dwInd = 0; dwInd < pimms-> ulNumOutIf; dwInd++ )
        {
            //
            // find the outgoing interface in the MFE maintained
            // by MGM and update the statistics based on what is
            // retrieved by the kernel mode forwarder
            //

            bFound  = FALSE;

            ple     = pleHead-> Flink;

            
            while ( ple != pleHead )
            {
                poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

                //
                // Check if interface has a valid next hop address (non zero)
                // - if it does then assume RAS client interface and do 
                //   the interface matching based on (Interface index +
                //   Next Hop )
                //
                // - otherwise just do it based on the Interface Index
                //
                
                bFound = ( poie-> dwIfIndex == 
                           pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex );
                
                if ( poie-> dwIfNextHopAddr )
                {
                    bFound = bFound &&
                             ( poie-> dwIfNextHopAddr ==
                               pimms-> rgiosOutStats[ dwInd ].dwNextHopAddr );
                }


                if ( bFound )
                {
                    //
                    // Outgoing Interface found in MFE in MGM
                    //
                    
                    break;
                }

                ple = ple-> Flink;
            }


            if ( bFound )
            {
                //
                // Update outgoing interface statistics in MGM
                //

                poie-> imosIfStats.dwOutIfIndex = 
                    pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex;

                poie-> imosIfStats.dwNextHopAddr = 
                    pimms-> rgiosOutStats[ dwInd ].dwNextHopAddr;

                    
                poie-> imosIfStats.ulTtlTooLow   = 
                    pimms-> rgiosOutStats[ dwInd ].ulTtlTooLow;

                poie-> imosIfStats.ulFragNeeded  = 
                    pimms-> rgiosOutStats[ dwInd ].ulFragNeeded;
                    
                poie-> imosIfStats.ulOutPackets  = 
                    pimms-> rgiosOutStats[ dwInd ].ulOutPackets;
                    
                poie-> imosIfStats.ulOutDiscards = 
                    pimms-> rgiosOutStats[ dwInd ].ulOutDiscards;

                TRACEFORWARD4( 
                    FORWARD, "Out If : %d, Frag : %d, Out packets : %d, Out discards : %d",
                    pimms-> rgiosOutStats[ dwInd ].dwOutIfIndex,
                    pimms-> rgiosOutStats[ dwInd ].ulFragNeeded,
                    pimms-> rgiosOutStats[ dwInd ].ulOutPackets,
                    pimms-> rgiosOutStats[ dwInd ].ulOutDiscards
                    );
            }
        }

    } while ( FALSE );


    if ( pimms != NULL )
    {
        MGM_FREE( pimms );
    }

    
    TRACEFORWARD0( FORWARD, "LEAVING GetMfeFromForwarder" );
}


//----------------------------------------------------------------------------
// AddMfeToForwarder
//
//
//----------------------------------------------------------------------------

VOID
AddMfeToForwarder( 
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse, 
    DWORD                       dwTimeout
)
{

    DWORD                       dwErr = NO_ERROR, dwInd = 0;

    PIPMCAST_MFE                pimm = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PLIST_ENTRY                 ple = NULL, pleHead = NULL;

    

    TRACEFORWARD6(
        FORWARD, "ENTERED AddMfeToForwarder : source : %x, %x : Group : "
        "%x, %x : #(out if) : %d : Timeout : %x", pge-> dwGroupAddr, 
        pge-> dwGroupMask, pse-> dwSourceAddr, pse-> dwSourceMask, 
        pse-> dwMfeIfCount, dwTimeout
        );


    do
    {
        //
        // Allocate appropriate sized MFE.
        //

        pimm = MGM_ALLOC( SIZEOF_MFE( pse-> dwMfeIfCount ) );

        if ( pimm == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "AddMfeToForwarder : Failed to create MFE of size : %x",
                SIZEOF_MFE( pse-> dwMfeIfCount )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimm, SIZEOF_MFE( pse-> dwMfeIfCount ) );
    

        //
        // fill it up
        //

        pimm-> dwGroup          = pge-> dwGroupAddr;

        pimm-> dwSource         = pse-> dwSourceAddr;

        pimm-> dwSrcMask        = pse-> dwSourceMask;

        pimm-> dwInIfIndex      = (pse-> dwMfeIfCount) ? pse-> dwInIfIndex : 0;

        pimm-> ulNumOutIf       = pse-> dwMfeIfCount;

        pimm-> ulTimeOut        = ( pse-> dwMfeIfCount ) ? 0 : dwTimeout;


        //
        // populate the outgoing interface list
        //

        pleHead = &pse-> leMfeIfList;
        
        for ( ple = pleHead-> Flink ; ple != pleHead; ple = ple-> Flink )
        {
            poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );
            
            pimm-> rgioOutInfo[ dwInd ].dwOutIfIndex = poie-> dwIfIndex;


            if ( poie-> dwIfNextHopAddr )
            {
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr = 
                    poie-> dwIfNextHopAddr;
            }

            else
            {
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr = pimm-> dwGroup;
            }

            TRACEFORWARD2( 
                FORWARD, "AddMfeToForwarder : Out interface %x, next hop %x", 
                pimm-> rgioOutInfo[ dwInd ].dwOutIfIndex,
                pimm-> rgioOutInfo[ dwInd ].dwNextHopAddr
                );

            pimm-> rgioOutInfo[ dwInd++ ].dwDialContext = 0;
            
        }


        //
        // invoke callback into the IP router manager
        //

        if ( IS_ADD_MFE_CALLBACK() )
        {
            ADD_MFE_CALLBACK() ( pimm );
        }

        MGM_FREE( pimm );
        
    } while ( FALSE );
    

    TRACEFORWARD1( FORWARD, "LEAVING AddMfeToForwarder %x", dwErr );
    
    return;
}



//----------------------------------------------------------------------------
// DeleteMfeFromForwarder
//
//
//----------------------------------------------------------------------------

VOID
DeleteMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    DWORD                       dwErr = NO_ERROR;

    PIPMCAST_DELETE_MFE         pimdm = NULL;
    


    TRACEFORWARD4(
        FORWARD, "ENTERED DeleteMfeToForwarder : source : %x, %x : Group : "
        "%x, %x : Timeout : %x", pge-> dwGroupAddr, pge-> dwGroupMask, 
        pse-> dwSourceAddr, pse-> dwSourceMask
        );
        
    do
    {

        //
        // Allocate appropriate sized MFE.
        //

        pimdm = MGM_ALLOC( sizeof( IPMCAST_DELETE_MFE ) );

        if ( pimdm == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "DeleteMfeFromForwarder : Failed to create MFE of size :"
                " %x", sizeof( IPMCAST_DELETE_MFE )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pimdm, sizeof( IPMCAST_DELETE_MFE ) );

        
        //
        // fill it up
        //

        pimdm-> dwGroup         = pge-> dwGroupAddr;

        pimdm-> dwSource        = pse-> dwSourceAddr;

        pimdm-> dwSrcMask       = pse-> dwSourceMask;


        //
        // invoke callback into the IP router manager
        //

        if ( IS_DELETE_MFE_CALLBACK() )
        {
            DELETE_MFE_CALLBACK() ( pimdm );
        }

        MGM_FREE( pimdm );


    } while ( FALSE );

    
    TRACEFORWARD1( FORWARD, "LEAVING DeleteMfeToForwarder %x", dwErr );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\group.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: group.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// routines that manipulate (source, group) entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


DWORD
AddToGroupList(
    PGROUP_ENTRY                pge
);


DWORD
AddToSourceList(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);


//----------------------------------------------------------------------------
// CreateGroupEntry
//
// Creates a new group entry and inserts it into the appropriate location. 
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

DWORD
CreateGroupEntry(
    PLIST_ENTRY                 pleHashList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge
)
{
    PGROUP_ENTRY                pge = NULL;

    DWORD                       dwErr = NO_ERROR, dwInd, dwSize;



    TRACEGROUP2( 
        GROUP, "ENTERED CreateGroupEntry : %x, %x", 
        dwGroupAddr, dwGroupMask 
        );


    do
    {
        //
        // Allocate and initialize a new entry
        //

        dwSize = sizeof( GROUP_ENTRY ) + 
                 ( SOURCE_TABLE_SIZE - 1) * sizeof( LIST_ENTRY );

        pge = MGM_ALLOC( dwSize );
        
        if ( pge == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CreateGroupEntry : failed to allocate group entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pge, dwSize );


        pge-> dwGroupAddr       = dwGroupAddr;

        pge-> dwGroupMask       = dwGroupMask;

        pge-> dwSourceCount     = 0;

        pge-> dwNumTempEntries  = 0;

        pge-> pmrwlLock         = NULL;
        

        //
        // Initialize all source lists
        //
        
        for ( dwInd = 0; dwInd < SOURCE_TABLE_SIZE; dwInd++ )
        {
            InitializeListHead( &( pge-> pleSrcHashTable[ dwInd ] ) );
        }

        InitializeListHead( &( pge-> leSourceList ) );

        InitializeListHead( &( pge-> leTempSrcList ) );


        //
        // Insert into the group hash list
        //

        InitializeListHead( &(pge-> leGrpHashList ) );

        InsertTailList( pleHashList, &( pge-> leGrpHashList ) );


        //--------------------------------------------------------------------
        // Insert group entry into the lexicographically sorted list 
        //--------------------------------------------------------------------
        
        InitializeListHead( &( pge-> leGrpList ) );


        //
        // Insert into temp list. 
        //

        AddToGroupList( pge );
        

        *ppge = pge;
        
    } while( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateGroupEntry : %x", dwErr );
        
    return dwErr;
}


//----------------------------------------------------------------------------
// GetGroupEntry
//
// retrieves specified entry.  NULL if not present.
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

PGROUP_ENTRY
GetGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask
)
{
    PGROUP_ENTRY                pge = NULL;
    
    if ( FindGroupEntry( pleGroupList, dwGroupAddr, dwGroupMask, &pge, TRUE ) )
    {
        return pge;
    }
    
    return NULL;
}


//----------------------------------------------------------------------------
// DeleteGroupEntry
//
// Assumes all sources for this group have been deleted.
//----------------------------------------------------------------------------

VOID
DeleteGroupEntry(
    PGROUP_ENTRY                pge
)
{

    TRACEGROUP2( 
        GROUP, "ENTERED DeleteGroupEntry : %x, %x", 
        pge-> dwGroupAddr, pge-> dwGroupMask 
        );
        
    RemoveEntryList( &pge-> leGrpHashList );


    //
    // remove from lex. list
    //
    
    ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

    ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE();

    ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


    RemoveEntryList( &pge-> leGrpList );

    
    RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

    RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE();

    RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

    
    MGM_FREE( pge );
    
    TRACEGROUP0( GROUP, "LEAVING DeleteGroupEntry" );
}



//----------------------------------------------------------------------------
// FindGroupEntry
//
// Finds the entry for the specified group.  
//
// If entry is found the ppge parameter returns a pointer to the 
// specified group entry.  
//
// If entry is not found the ppge parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the group list specified by pleGroupList is empty then ppge is set
// to NULL.
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

BOOL
FindGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge,
    BOOL                        bHashList
)
{

    PLIST_ENTRY                 ple = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    BOOL                        bFound = FALSE;

    INT                         iCmp;
    

    TRACEGROUP2( 
        GROUP, "ENTERED FindGroupEntry : %x, %x", dwGroupAddr, dwGroupMask 
        );


    *ppge = NULL;

    
    //
    // scan group bucket.  Group entries are arranged in increasing order
    // of group addr.
    //

    for ( ple = pleGroupList-> Flink; 
          ple != pleGroupList; 
          ple = ple-> Flink )
    {
        if ( bHashList )
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );
        }

        else
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpList );
        }
        

        if ( INET_CMP( pge-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            bFound = FALSE;
        }

        else
        {
            bFound = TRUE;
        }
        
        *ppge = pge;

        break;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING FindGroupEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// CreateSourceEntry
//
// Creates a new source entry and inserts it into its appropriate location.
//----------------------------------------------------------------------------

DWORD
CreateSourceEntry(
    PGROUP_ENTRY                pge,
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse
)
{

    DWORD                       dwErr = NO_ERROR;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2( 
        GROUP, "ENTERED CreateSourceEntry : %x %x", 
        dwSourceAddr, dwSourceMask 
        );


    do
    {
        //
        // allocate group entry.
        //

        pse = MGM_ALLOC( sizeof( SOURCE_ENTRY ) );

        if ( pse == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, 
                "CreateSourceEntry : failed to allocate source entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pse, sizeof( SOURCE_ENTRY ) );

        
        //
        // Init. fields
        //

        pse-> dwSourceAddr          = dwSourceAddr;
        pse-> dwSourceMask          = dwSourceMask;

        pse-> dwInIfIndex           = INVALID_INTERFACE_INDEX;
        pse-> dwInIfNextHopAddr     = INVALID_NEXT_HOP_ADDR;
        pse-> dwUpstreamNeighbor    = 0;

        pse-> dwInProtocolId        = INVALID_PROTOCOL_ID;
        pse-> dwInComponentId       = INVALID_COMPONENT_ID;

        pse-> bInForwarder          = FALSE;
        pse-> dwInUse               = 0;

        pse-> dwTimeOut             = 0;
        pse-> liCreationTime.QuadPart = 0;

        RtlZeroMemory( 
            &pse-> imsStatistics, sizeof( IPMCAST_MFE_STATS ) 
            );

            
        //
        // Outgoing interface list, mfe list are empty.
        //

        pse-> dwOutIfCount = 0;

        pse-> dwOutCompCount = 0;
        
        InitializeListHead( &pse-> leOutIfList );

        InitializeListHead( &pse-> leScopedIfList );


        pse-> dwMfeIfCount = 0;

        InitializeListHead( &pse-> leMfeIfList );
        

        //
        // Insert entry into appropriate source lists 
        //

        InitializeListHead( &pse-> leSrcHashList );

        InsertTailList( pleSrcList, &pse-> leSrcHashList );


        //--------------------------------------------------------------------
        // Insert source entry into the lexicographically sorted list 
        //--------------------------------------------------------------------

        InitializeListHead( &pse-> leSrcList );
        
        AddToSourceList( pge, pse );


        *ppse = pse;

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateSourceEntry : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// GetSourceEntry
//
//
//----------------------------------------------------------------------------

PSOURCE_ENTRY
GetSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask
)
{
    PSOURCE_ENTRY               pse = NULL;
    
    if ( FindSourceEntry( pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE ) )
    {
        return pse;
    }

    return NULL;
}


//----------------------------------------------------------------------------
// DeleteSourceEntry
//
//
//----------------------------------------------------------------------------

VOID
DeleteSourceEntry(
    PSOURCE_ENTRY               pse
)
{
    TRACEGROUP2( 
        GROUP, "ENTERED DeleteSourceEntry : %x, %x", 
        pse-> dwSourceAddr, pse-> dwSourceMask 
        );
    
    RemoveEntryList( &pse-> leSrcHashList );

    RemoveEntryList( &pse-> leSrcList );
    
    MGM_FREE( pse );

    TRACEGROUP0( GROUP, "LEAVING DeleteSourceEntry" );
}


//----------------------------------------------------------------------------
// FindSourceEntry
//
// Find specified source entry in the bucket.  
//
// If entry is found the ppse parameter returns a pointer to the 
// specified source entry.  
//
// If entry is not found the ppse parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the source list specified by pleSrcList is empty then ppse is set
// to NULL.
//
//----------------------------------------------------------------------------

BOOL
FindSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse,
    BOOL                        bHashList
)
{

    BOOL            bFound = FALSE;

    INT             iCmp;

    PLIST_ENTRY     ple = NULL;
    
    PSOURCE_ENTRY   pse = NULL;


    TRACEGROUP3( 
        GROUP, "ENTERED FindSourceEntry : %x, %x, %x", 
        dwSourceAddr, dwSourceMask, bHashList
        );



    *ppse = NULL;


    //
    // walk the source list and find the specified source entry
    //

    for ( ple = pleSrcList-> Flink; ple != pleSrcList; ple = ple-> Flink )
    {
        if ( bHashList )
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );
        }

        else
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcList );
        }
        

        if ( INET_CMP( pse-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            bFound = FALSE;
        }
        
        else
        {
            bFound = TRUE;
        }

        *ppse = pse;
        
        break;
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING FindSourceEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// CreateOutInterfaceEntry
//
// This function creates an outgoing interface entry for source.
//----------------------------------------------------------------------------

DWORD
CreateOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
)
{

    POUT_IF_ENTRY               poie = NULL;

    DWORD                       dwErr = NO_ERROR;


    TRACEGROUP5(
        GROUP, "ENTERED CreateOutInterfaceEntry : Interface : %x, %x : "
        "Protocol : %x, %x, IGMP : %x", dwIfIndex, dwIfNextHopAddr,
        dwProtocolId, dwComponentId, bIGMP
        );

        
    do
    {
        *ppoie = NULL;

        
        //
        // allocate out interface entry
        //
        
        poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

        if ( poie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( ANY, "CreateOutInterfaceEntry : Could not allocate"
                         "out interface entry %x", dwErr );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // initialize entry
        //

        ZeroMemory( poie, sizeof( OUT_IF_ENTRY ) );
        

        poie-> dwIfIndex        = dwIfIndex;

        poie-> dwIfNextHopAddr  = dwIfNextHopAddr;

        poie-> dwProtocolId     = dwProtocolId;

        poie-> dwComponentId    = dwComponentId;

        poie-> wForward         = 1;


        if ( bIGMP )
        {
            SET_ADDED_BY_IGMP( poie );
            poie-> wNumAddsByIGMP = 1;
        }

        else
        {
            SET_ADDED_BY_PROTOCOL( poie );
            poie-> wNumAddsByRP = 1;
        }


        //
        // insert into the out interface list
        //
        
        InsertTailList( pleOutIfList, &poie-> leIfList );

        *ppoie = poie;

        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING CreateOutInterfaceEntry : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

POUT_IF_ENTRY
GetOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
)
{
    POUT_IF_ENTRY               poie = NULL;
    BOOL                        bNewComp = FALSE;

    
    if ( FindOutInterfaceEntry( 
            pleOutIfList, dwIfIndex, dwIfNextHopAddr, dwProtocolId,
            dwComponentId, &bNewComp, &poie ) )
    {
        return poie;
    }

    return NULL;
    
}


//----------------------------------------------------------------------------
// DeleteOutInterfaceEntry
//
// Deletes an outgoing interface entry from the OIL of a source entry.
//----------------------------------------------------------------------------

VOID
DeleteOutInterfaceEntry(
    POUT_IF_ENTRY               poie
)
{
    TRACEGROUP2( 
        GROUP, "ENTERED DeleteOutInterfaceEntry : Interface %x, %x",
        poie-> dwIfIndex, poie-> dwIfNextHopAddr
        );
        
    RemoveEntryList( &poie-> leIfList );

    MGM_FREE( poie );

    TRACEGROUP0( GROUP, "LEAVING DeleteOutInterfaceEntry" );
}


//----------------------------------------------------------------------------
// FindOutInterfaceEntry
//
// If entry is found the ppoie parameter returns a pointer to the 
// specified interface entry.  
//
// If entry is not found the ppoie parameter is set to the "following" entry.
// This serves as an insertion spot in case a new entry is to inserted when
// none is found.
// 
// if the interface list specified by pleOutIfList is empty then ppoie is set
// to NULL.
//
//----------------------------------------------------------------------------

BOOL
FindOutInterfaceEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PBOOL                       pbNewComponent,   
    POUT_IF_ENTRY *             ppoie
)
{

    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;

    PLIST_ENTRY                 ple = NULL;
    
    POUT_IF_ENTRY               poie = NULL;



    TRACEGROUP4( 
        GROUP, "ENTERED FindOutInterfaceEntry : %x %x, Protocol %x %x", 
        dwIfIndex, dwIfNextHopAddr, dwProtocolId, dwComponentId
        );

        
    *ppoie = NULL;
    *pbNewComponent = TRUE;

    //
    // Scan the out going interface list.
    // The outgoing interface list is ordered by ( protocol, component) Id
    // and within each protocol component by (interface id, next hop addr)
    //

    for ( ple = pleIfList-> Flink; ple != pleIfList; ple = ple-> Flink )
    {
        poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        //
        // is same protocol
        //

        if ( poie-> dwProtocolId < dwProtocolId )
        {
            continue;
        }

        else if ( poie-> dwProtocolId > dwProtocolId )
        {
            //
            // Interface entry not found
            //

            *ppoie = poie;
            break;
        }


        //
        // same protocol
        //
            
        //
        // is same component
        //

        if ( poie-> dwComponentId < dwComponentId ) 
        {
            continue;
        }

        else if ( poie-> dwComponentId > dwComponentId )
        {
            //
            // Interface entry not found
            //

            *ppoie = poie;
            break;
        }


        //
        // same component
        //

        *pbNewComponent = FALSE;
        

        //
        // is same interface
        //

        if ( poie-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( poie-> dwIfIndex > dwIfIndex )
        {
            //
            // interface not found
            //

            *ppoie = poie;
            break;
        }


        //
        // is same next hop addr
        // to do IP address comparison function.
        //

        if ( INET_CMP( poie-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // interface not found
            //
                
            *ppoie = poie;
            break;
        }


        //
        // at last, got the interface
        //

        *ppoie = poie;
        bFound = TRUE;
        break;
    }


    TRACEGROUP1( GROUP, "LEAVING FindOutInterfaceEntry : %x", bFound );
    
    return bFound;
}



//----------------------------------------------------------------------------
// AddInterfaceToSourceEntry
//
// This function adds an interface to the outgoing interface list of a 
// (source, group) entry.  For an (S, G) entry the corresponding mfe outgoing
// interface list is also updated to reflect this addition.  For a (*, G) enry, 
// the mfe outgoing interface list for all source entries is updated,
// and for a (*, *) entry mfes for all sources, for all groups are updated.
//
//----------------------------------------------------------------------------

DWORD
AddInterfaceToSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP,
    PBOOL                       pbUpdateMfe,
    PLIST_ENTRY                 pleSourceList
)
{
    DWORD                       dwGrpBucket, dwSrcBucket;

    DWORD                       dwErr = NO_ERROR;
    
    BOOL                        bFound = FALSE, bNewGrp = FALSE, 
                                bNewSrc = FALSE, bNewComp = FALSE,
                                bUpdateMfe = TRUE, bgeLock = FALSE;

    PPROTOCOL_ENTRY             ppeEntry = NULL;
    
    PGROUP_ENTRY                pge = NULL, pgeNew = NULL;

    PSOURCE_ENTRY               pse = NULL, pseNew = NULL;

    POUT_IF_ENTRY               poie = NULL, poiePrev = NULL;

    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL, 
                                ple = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToSourceEntry : Group %x, %x",
        dwGroupAddr, dwGroupMask
        );

    TRACEGROUP2( GROUP, "Source : %x, %x", dwSourceAddr, dwSourceMask );

    TRACEGROUP2( GROUP, "Interface : %x, %x", dwIfIndex, dwIfNextHopAddr );
    

    do
    {
        *pbUpdateMfe = FALSE;
        
        //
        // Lock group bucket
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );


        //
        // find group entry
        //

        pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        bFound = FindGroupEntry( 
                    pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE 
                    );

        if ( !bFound )
        {
            //
            // No existing entry for this group
            // create a group entry.
            //

            if ( pge == NULL )
            {
                //
                // group bucket is null
                //
                
                dwErr = CreateGroupEntry( 
                            pleGrpList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            else
            {
                dwErr = CreateGroupEntry( 
                            &pge-> leGrpHashList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            
            if ( dwErr != NO_ERROR )
            {
                break;
            }
            
            pge = pgeNew;

            bNewGrp = TRUE;
        }


        //
        // find source entry
        //

        //
        // lock the group entry first
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bgeLock = TRUE;
        
        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        bFound = FindSourceEntry( 
                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                    );

        if ( !bFound )
        {
            //
            // create the source entry
            //

            if ( pse == NULL )
            {
                //
                // source bucket is null
                //
                
                dwErr = CreateSourceEntry( 
                            pge, pleSrcList, dwSourceAddr, dwSourceMask, 
                            &pseNew
                        );
            }

            else
            {
                dwErr = CreateSourceEntry( 
                            pge, &pse-> leSrcHashList, dwSourceAddr, 
                            dwSourceMask, &pseNew
                        );
            }

            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse = pseNew;

            pge-> dwSourceCount++;

            bNewSrc = TRUE;
        }


        //
        // Check if the group been added falls with a scoped boundary
        // on this interface
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK() ( dwIfIndex, dwGroupAddr ) )
        {
            //
            // Group is administratively scoped on this interface
            // Insert the interface into the list of scoped interfaces
            //

            bFound = FindOutInterfaceEntry( 
                        &pse-> leScopedIfList, dwIfIndex, dwIfNextHopAddr, 
                        ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp,
                        &poie 
                        );

            if ( !bFound )
            {
                //
                // Interface not present in scoped interfaces list.
                // add it.
                //

                TRACEGROUP0( GROUP, "Group entry scoped & added" );

                ple = ( poie == NULL ) ? &pse-> leScopedIfList :
                                         &poie-> leIfList;

                dwErr = CreateOutInterfaceEntry(
                            ple, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId, 
                            bIGMP, &poie
                            );

                if ( dwErr == NO_ERROR )
                {
                    //
                    // increment the out i/f count
                    //

                    pse-> dwOutIfCount++;
                }
            }

            else
            {
                //
                // Interface already present in scoped interface list.
                // Since IGMP and a Routing protocol could be running
                // on this interface, it is possibly that this interface
                // was added by IGMP and is now being added by the routing
                // protocol or vice versa.  Make sure to set the right
                // flags and update join counts.
                //

                TRACEGROUP0( GROUP, "Group entry scoped & updated" );
                
                if ( bIGMP )
                {
                    SET_ADDED_BY_IGMP( poie );
                    poie-> wNumAddsByIGMP = 1;
                }

                else
                {
                    SET_ADDED_BY_PROTOCOL( poie );
                    poie-> wNumAddsByRP = 1;
                }

                dwErr = NO_ERROR;
            }

            TRACEGROUP1( GROUP, "Group entry scoped : %lx", dwErr );

            break;
        }


        //
        // Find interface entry in OIL
        //

        bFound = FindOutInterfaceEntry( 
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, &poie
                    );

        if ( !bFound )
        {
            //
            // Create interface entry 
            //

            if ( poie == NULL )
            {
                dwErr = CreateOutInterfaceEntry( 
                            &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId, 
                            bIGMP, &poie
                            );
            }
            
            else
            {
                dwErr = CreateOutInterfaceEntry( 
                            &poie-> leIfList, dwIfIndex, dwIfNextHopAddr,
                            ppe-> dwProtocolId, ppe-> dwComponentId,
                            bIGMP, &poie
                            );
            }

            
            if ( dwErr != NO_ERROR )
            {
                break;
            }


            //
            // update count of number of outgoing interfaces and
            // count of number of routing protocol components that
            // have added interfaces to the out going i/f list
            //
            
            pse-> dwOutIfCount++;


            if ( bNewComp )
            {
                pse-> dwOutCompCount++;

                InvokeJoinAlertCallbacks( pge, pse, poie, bIGMP, ppe );
            }

            
        }
        
        else
        {
            //
            // interface entry found in the out interface list
            //

            if ( bIGMP )
            {
                //
                // interface entry is being added by IGMP
                //
                
                //
                // if interface entry was previously added by
                // IGMP, no further processing is necessary (no mfe updates)
                //
                
                if ( IS_ADDED_BY_IGMP( poie ) )
                {
                    bUpdateMfe = FALSE;
                }

                else
                {
                    //
                    // flag interface as added by IGMP
                    //
                    
                    SET_ADDED_BY_IGMP( poie );
                    
                    poie-> wNumAddsByIGMP = 1;


                    //
                    // inform routing protocol (if any) that co-exists with IGMP
                    // on this interface
                    //

                    if ( IS_ROUTING_PROTOCOL( ppe )  &&
                         IS_LOCAL_JOIN_ALERT( ppe ) )
                    {
                        LOCAL_JOIN_ALERT( ppe )(
                                dwSourceAddr, dwSourceMask, dwGroupAddr, 
                                dwGroupMask, dwIfIndex, dwIfNextHopAddr
                            );
                    }
                }
            }

            else
            {
                //
                // Interface is being added by routing protocol
                //
                
                //
                // if interface entry was previously added by the 
                // routing protocol, no further processing is necessary.
                // 
                
                if ( IS_ADDED_BY_PROTOCOL( poie ) )
                {
                    bUpdateMfe = FALSE;
                }


                //
                // flag interface as added by routing protocol
                //
                
                SET_ADDED_BY_PROTOCOL( poie );

                poie-> wNumAddsByRP = 1;
            }
        }

    } while ( FALSE );


    //
    // error finding/creating the entry
    //

    if ( dwErr != NO_ERROR )
    {
        if ( bNewSrc )
        {
            DeleteSourceEntry( pse );
        }

        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        if ( bNewGrp )
        {
            DeleteGroupEntry( pge );
        }

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        
        return dwErr;
    }
    

    //------------------------------------------------------------------------
    //
    // MFE Update
    //
    //------------------------------------------------------------------------

    if ( !bUpdateMfe )
    {
        if ( bgeLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        return dwErr;
    }
    
    //
    // Is the source entry that was updated an MFE ?
    // 
    // If so update the OIL for the MFE.
    //

    if ( IS_VALID_INTERFACE( pse-> dwInIfIndex, pse-> dwInIfNextHopAddr )  )
    {
        //
        // TO BE DONE :
        //  Invoke CREATION_ALERT for MFE.
        //
        
        AddInterfaceToSourceMfe( 
            pge, pse, dwIfIndex, dwIfNextHopAddr, 
            ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP, NULL
            );
    }

    //
    //  Is this a wildcard (source, group) entry, if so you
    //  need update the OIL of all (source, group) with this
    //  interface.
    //

    if ( IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) )
    {
        //
        // you are in for the big kahuna
        //

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        *pbUpdateMfe = TRUE;
    }

    else if ( IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // you 're in for a kahuna all right. But big nahh.
        //

        *pbUpdateMfe = TRUE;

        AddInterfaceToGroupMfe (
            pge, dwIfIndex, dwIfNextHopAddr,
            ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP,
            FALSE, pleSourceList
        );

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }

    else
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }

    TRACEGROUP1( GROUP, "LEAVING AddInterfaceToSourceEntry %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// AddInterfaceToAllMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//----------------------------------------------------------------------------

VOID
AddInterfaceToAllMfeInGroupBucket(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    DWORD                       dwInd,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
)
{
    PLIST_ENTRY                 ple = NULL, pleGrpList = NULL;

    PGROUP_ENTRY                pge = NULL;

    
    TRACEGROUP3(
        GROUP, "ENTERED (%d) AddInterfaceToAllMfeInGroupBucket : %x, %x",
        dwInd, dwIfIndex, dwIfNextHopAddr
        );

    //
    // lock the group bucket
    //

    ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwInd );


    //
    // for each group entry in the bucket
    //

    pleGrpList = GROUP_BUCKET_HEAD( dwInd );
    
    for ( ple = pleGrpList-> Flink;
          ple != pleGrpList;
          ple = ple-> Flink )
    {
        pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

        AddInterfaceToGroupMfe(
            pge, dwIfIndex, dwIfNextHopAddr,
            dwProtocolId, dwComponentId, bIGMP,
            bAdd, pleSourceList
            );
            
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    //
    // release group lock
    //
    
    RELEASE_GROUP_LOCK_EXCLUSIVE( dwInd );

    TRACEGROUP0( GROUP, "LEAVING AddInterfaceToAllMfeInGroupBucket" );

    return;
}



//----------------------------------------------------------------------------
// AddInterfaceToAllGroupMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//
// Assumes that the group bucket is locked.
//----------------------------------------------------------------------------

VOID
AddInterfaceToGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
)
{
    PLIST_ENTRY                 pleSource, pleSrcHead;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToGroupMfe : Group %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask
        );


    MergeTempAndMasterSourceLists( pge );

    //
    // For each source in this bucket
    //

    pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );
    
    for ( pleSource = pleSrcHead-> Flink;
          pleSource != pleSrcHead;
          pleSource = pleSource-> Flink )
    {
        pse = CONTAINING_RECORD( 
                pleSource, SOURCE_ENTRY, leSrcList
                );

        //
        // check for valid incoming interface ==> this 
        // is an MFE too.
        //

        if ( !IS_VALID_INTERFACE( 
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
        {
            continue;
        }

        if ( bAdd ) 
        {
            if ( IsForwardingEnabled(
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pleSourceList
                    ) )
            {
                AddInterfaceToSourceMfe(
                    pge, pse, dwIfIndex, dwIfNextHopAddr,
                    dwProtocolId, dwComponentId, bIGMP, NULL
                    );
            }
        }
        
        else
        {
            AddToCheckForCreationAlertList(
                pge-> dwGroupAddr, pge-> dwGroupMask,
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                pleSourceList
                );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING AddInterfaceToGroupMfe" );

    return;
}


//----------------------------------------------------------------------------
// AddInterfaceToSourceMfe
//
// This functions adds an interface the outgoing interface of a MFE. Duh 
//----------------------------------------------------------------------------

VOID
AddInterfaceToSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
)
{
    BOOL                        bFound = FALSE, bNegativeEntry = FALSE,
                                bNewComp = FALSE;

    DWORD                       dwErr = NO_ERROR;
                                
    PPROTOCOL_ENTRY             ppe = NULL;

    POUT_IF_ENTRY               poie = NULL, poieNew = NULL;
    
    PLIST_ENTRY                 pleOutList = NULL;

    MGM_IF_ENTRY                mie;
    

    TRACEGROUP2(
        GROUP, "ENTERED AddInterfaceToSourecMfe : Source : %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask
        );

    do
    {
        //
        // check if the interface being added to the MFE is the same
        // as the incoming interface.  If so quit.
        //

        if ( ( pse-> dwInIfIndex == dwIfIndex ) &&
             ( pse-> dwInIfNextHopAddr == dwIfNextHopAddr ) )
        {
            break;
        }


        //
        // Check if the incoming interface has a scoped boundary on it.
        // If it is, then this is a negative MFE that should remain
        // negative, even if outgoing interfaces are present for this
        // group.  This ensures that group traffic is not forwarded from
        // outside the scope into the scope.
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK()( pse-> dwInIfIndex, pge-> dwGroupAddr ) )
        {
            TRACE2( 
                GROUP, "Group %lx scoped on incoming i/f %lx", 
                pge-> dwGroupAddr, pse-> dwInIfIndex
                );
                
            break;
        }
        

#if 0        
        //
        // invoke creation alert to the protocol on the interface (being
        // added to the MFE) to make sure that we should be adding this 
        // interface to the OIL of the MFE)
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), dwProtocolId, dwComponentId
                );

        if ( ppe == NULL )
        {
            break;
        }


        mie.dwIfIndex           = dwIfIndex;
        
        mie.dwIfNextHopAddr     = dwIfNextHopAddr;
        
        mie.bIsEnabled          = TRUE;

        if ( IS_CREATION_ALERT( ppe ) )
        {
            CREATION_ALERT( ppe ) (
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                1, &mie
                );

            if ( !mie.bIsEnabled )
            {
                TRACE2( 
                    GROUP, "Interface %x, %x pruned by protocol",
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr
                    );

                break;
            }
        }
        
#endif
        //
        // check if interface already exists in OIL
        //
        
        pleOutList = &pse-> leMfeIfList;

        bFound = FindOutInterfaceEntry( 
                    pleOutList, dwIfIndex, dwIfNextHopAddr, 
                    dwProtocolId, dwComponentId, &bNewComp, &poie
                    );

        if ( !bFound )
        {
            //
            // create a new entry
            //

            if ( poie == NULL )
            {
                //
                // This is the first interface in the outgoing list.
                // This implies that the entry was previously a NEGATIVE mfe
                //

                bNegativeEntry = TRUE;
                
                dwErr = CreateOutInterfaceEntry(
                            pleOutList, dwIfIndex, dwIfNextHopAddr,
                            dwProtocolId, dwComponentId, bIGMP, &poieNew
                            );
            }

            else
            {
                dwErr = CreateOutInterfaceEntry(
                            &poie-> leIfList, dwIfIndex, dwIfNextHopAddr, 
                            dwProtocolId, dwComponentId, bIGMP, &poieNew
                            );
            }
            
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse-> dwMfeIfCount++;
        }

        else
        {
            //
            // Interface entry already exists in the outgoing interface
            // list of the mfe.
            //
            // update reference counts
            //

            if ( bIGMP )
            {
                //
                // Interface added by IGMP
                //
                
                SET_ADDED_BY_IGMP( poie );
                poie-> wNumAddsByIGMP++;
            }

            else
            {
                SET_ADDED_BY_PROTOCOL( poie );
                poie-> wNumAddsByRP++;
            }

            break;
        }


        //
        // If the outgoing interface list was empty before this interface 
        // entry was added implying a negative mfe, send JOIN_ALERT callback
        // to the protocol owning the incoming interface
        //

        if ( bNegativeEntry )
        {
            TRACEGROUP0( GROUP, "MFE was preivously a negative mfe" );

            //
            // get the protocol component owning the incoming interface
            //

            ppe = GetProtocolEntry(
                    &ig.mllProtocolList.leHead,
                    pse-> dwInProtocolId, pse-> dwInComponentId 
                    );

            if ( ppe == NULL )
            {
                TRACE2( 
                    ANY, 
                    "AddInterfaceToSourceMfe : cannot find protocol component :"
                    " %x, %x", pse-> dwInProtocolId, pse-> dwInComponentId
                    );

                LOGERR0( 
                    PROTOCOL_NOT_FOUND, ERROR_NOT_FOUND 
                    );
                    
                break;
            }


            //
            // invoke the new member alert
            //
            
            if ( IS_JOIN_ALERT( ppe ) )
            {
                JOIN_ALERT( ppe )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask, FALSE
                );
            }
        }


        //
        // If a new interface was added to the OIL of the MFE &&
        // if MFE is present in the forwarder, 
        //      update the forwarder entry
        //

        if ( !bFound && pse-> bInForwarder )
        {
            AddMfeToForwarder( pge, pse, 0 );
        }
        
    } while ( FALSE );


    if ( ppoie != NULL )
    {
        *ppoie = poieNew;
    }

    
    TRACEGROUP0( GROUP, "LEAVING AddInterfacetoSourceMfe" );


    return;
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromSource
//
//
// This function deletes an interface from the outgoing interface list of a 
// (source, group) entry.  For an (S, G) entry the corresponding mfe outgoing
// interface list is also updated to reflect this deletion.  For a (*, G) enry,
// the mfe outgoing interface list for all source entries is updated,
// and for a (*, *) entry mfes for all sources, for all groups are updated.
//----------------------------------------------------------------------------

VOID
DeleteInterfaceFromSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP
)
{

    DWORD                       dwGrpBucket, dwSrcBucket;
    
    BOOL                        bFound = FALSE, bNewComp = FALSE,
                                bUpdateMfe = FALSE, bGrpLock = FALSE,
                                bGrpEntryLock = FALSE;

    PPROTOCOL_ENTRY             ppeEntry = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL, 
                                ple = NULL, pleProtocol = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromSourceEntry : Group %x, %x",
        dwGroupAddr, dwGroupMask
        );

    TRACEGROUP2( GROUP, "Source : %x, %x", dwSourceAddr, dwSourceMask );

    TRACEGROUP2( GROUP, "Interface : %x, %x", dwIfIndex, dwIfNextHopAddr );
    

    do
    {
        //--------------------------------------------------------------------
        // Interface deletion from source entry
        //--------------------------------------------------------------------
        
        //
        // Lock group bucket
        //

        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        bGrpLock = TRUE;
        

        //
        // Find group entry
        //
        
        pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );

        bFound = FindGroupEntry( 
                    pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                    );

        if ( !bFound )
        {
            break;
        }

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;
        
                    
        //
        // Found group entry, find source entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );
        
        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        
        bFound = FindSourceEntry(
                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                    );

        if ( !bFound )
        {
            break;
        }
                    

        //
        // Found source entry, find interface entry in the 
        // outgoing list
        //

        bFound = FindOutInterfaceEntry( 
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                    &poie
                    );

        if ( !bFound )
        {
            //
            // Interface not found in OIL.  Check if this interface
            // has a scoped boundary for this group.  If so delete it
            // from the scoped list and quit.
            //

            bFound = FindOutInterfaceEntry( 
                        &pse-> leScopedIfList, dwIfIndex, dwIfNextHopAddr, 
                        ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                        &poie
                        );

            if ( bFound )
            {
                //
                // clear appropriate counts/flags on the interface
                //
                
                TRACEGROUP0( GROUP, "Scoped interface" );

                if ( bIGMP )
                {
                    poie-> wNumAddsByIGMP = 0;
                    CLEAR_ADDED_BY_IGMP( poie );
                }

                else
                {
                    poie-> wNumAddsByRP = 0;
                    CLEAR_ADDED_BY_PROTOCOL( poie );
                }


                //
                // Delete this interface if counts are zero
                //

                if ( !IS_ADDED_BY_IGMP( poie ) &&
                     !IS_ADDED_BY_PROTOCOL( poie ) )
                {
                    TRACEGROUP0( GROUP, "Scoped interface deleted" );

                    DeleteOutInterfaceEntry( poie );
                    poie = NULL;


                    //
                    // Decrement OIF count.  If count is 0, and this
                    // source is not an MFE, delete the source entry
                    //
                    
                    pse-> dwOutIfCount--;

                    if ( ( pse-> dwOutIfCount == 0 ) &&
                         !IS_VALID_INTERFACE( 
                            pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
                    {
                        DeleteSourceEntry( pse );

                        pse = NULL;

                        pge-> dwSourceCount--;
                    }


                    //
                    // if there are no more sources for this group, remove 
                    // group entry
                    //
                    
                    if ( pge-> dwSourceCount == 0 )
                    {
                        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                        bGrpEntryLock = FALSE;
                        
                        DeleteGroupEntry( pge );
                        pge = NULL;
                    }
                }
            }
            
            break;
        }


        //
        // Outgoing interface found.  decrement ref counts.
        //

        if ( bIGMP && IS_ADDED_BY_IGMP( poie ) )
        {
            poie-> wNumAddsByIGMP = 0;

            CLEAR_ADDED_BY_IGMP( poie );

            bUpdateMfe = TRUE;

            if ( IS_LOCAL_LEAVE_ALERT( ppe ) )
            {
                LOCAL_LEAVE_ALERT( ppe )(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwIfIndex, dwIfNextHopAddr
                    );
            }
        }

        else if ( !bIGMP && IS_ADDED_BY_PROTOCOL( poie ) )
        {
            poie-> wNumAddsByRP = 0;
            
            CLEAR_ADDED_BY_PROTOCOL( poie );

            bUpdateMfe = TRUE;
        }

    } while( FALSE );


    //
    // if interface was not found in the outgoing interface list
    //      of specified (source, group) entry   OR
    // No interface was deleted
    // return right here.
    //
    
    if ( !bFound || !bUpdateMfe )
    {
        if ( bGrpEntryLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }
        
        if ( bGrpLock )
        {
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

        return;
    }



    do
    {
        //
        // if no more reference to this interface entry, delete it.
        //

        if ( !IS_ADDED_BY_IGMP( poie ) &&
             !IS_ADDED_BY_PROTOCOL( poie ) )
        {
            DeleteOutInterfaceEntry( poie );

            poie = NULL;
            

            //
            // Update interface and component counts
            //
            
            pse-> dwOutIfCount--;


            //
            // check if this interface deletion has resulted in decreasing
            // the number of protocol components that have added interfaces
            // to the OIL.
            //
            // To do this try to find the interface we just deleted again, in
            // the OIL and see if bNewComp is set to TRUE.
            //
            // if bNewComp == TRUE, then the interface just deleted was
            // the last interface in the OIL for the protocol component.
            //

            bNewComp = FALSE;
            
            FindOutInterfaceEntry(
                    &pse-> leOutIfList, dwIfIndex, dwIfNextHopAddr, 
                    ppe-> dwProtocolId, ppe-> dwComponentId, &bNewComp, 
                    &poie
                );


            if ( bNewComp )
            {
                pse-> dwOutCompCount--;

                InvokePruneAlertCallbacks( 
                    pge, pse, dwIfIndex, dwIfNextHopAddr, ppe 
                    );
            }
        }


        //--------------------------------------------------------------------
        // source/group entry deletion
        //--------------------------------------------------------------------

        //
        // If there are no more interfaces in the OIL and this source
        // is not an MFE, the source entry can be deleted
        //

        if ( ( pse-> dwOutIfCount == 0 ) &&
             !IS_VALID_INTERFACE( 
                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
        {
            DeleteSourceEntry( pse );

            pse = NULL;

            pge-> dwSourceCount--;
        }


        //
        // if there are no more sources for this group, remove group entry
        //
        
        if ( pge-> dwSourceCount == 0 )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            DeleteGroupEntry( pge );
            pge = NULL;
        }


        //--------------------------------------------------------------------
        // MFE update 
        //--------------------------------------------------------------------
        
        if ( IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) )
        {
            //
            // (*, *) entry
            //

            if ( pge != NULL )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

            DeleteInterfaceFromAllMfe(
                dwIfIndex, dwIfNextHopAddr,
                ppe-> dwProtocolId, ppe-> dwComponentId, bIGMP
                );
        }

        else if ( IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
        {
            //
            // (*, G) entry
            //

            if ( pge != NULL )
            {
                DeleteInterfaceFromGroupMfe(
                    pge, dwIfIndex, dwIfNextHopAddr, ppe-> dwProtocolId,
                    ppe-> dwComponentId, bIGMP
                    );

                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

        else
        {
            //
            // (S, G) entry.
            //

            //
            // Does this (S, G) entry have a corresponding MFE ?
            // Check to see if it has a valid incoming interface
            //

            if ( pse != NULL &&
                 IS_VALID_INTERFACE( 
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
            {
                DeleteInterfaceFromSourceMfe( 
                    pge, pse, dwIfIndex, dwIfNextHopAddr, ppe-> dwProtocolId,
                    ppe-> dwComponentId, bIGMP, FALSE
                    );
            }

            if ( pge != NULL )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }
            
            RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
        }

    } while ( FALSE );


    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromSourceEntry" );


    return;
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromAllMfe
//
// This function is invoked when an interface is deleted from the outgoing
// list of a (*, *) entry.  It walks the entire group table and updates
// every mfe for every source to reflect the deletion of this interface.
//----------------------------------------------------------------------------


VOID
DeleteInterfaceFromAllMfe(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
)
{
    DWORD                       dwInd;

    PGROUP_ENTRY                pge = NULL;

    PLIST_ENTRY                 ple = NULL;
    
    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromAllMfe : %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    //
    // for each group bucket
    //

    for ( dwInd = 0; dwInd < GROUP_TABLE_SIZE; dwInd++ )
    {
        //
        // for each group
        //

        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwInd );


        for ( ple = ig.pmllGrpHashTable[ dwInd ].leHead.Flink;
              ple != &ig.pmllGrpHashTable[ dwInd ].leHead;
              ple = ple-> Flink )
        {
            pge = CONTAINING_RECORD( ple, GROUP_ENTRY, leGrpHashList );

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            DeleteInterfaceFromGroupMfe(
                pge, dwIfIndex, dwIfNextHopAddr, dwProtocolId, 
                dwComponentId, bIGMP
                );

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwInd );
    }
    
    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromAllMfe" );
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromGroupMfe
//
// This function is invoked when an interface is deleted from the outgoing
// list of a (*, G) or (*, *) entry.  It walks all the sources for a group
// and updates every mfe to reflect the deletion of this interface.
//----------------------------------------------------------------------------


VOID
DeleteInterfaceFromGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
)
{
    DWORD                       dwInd = 0;

    PLIST_ENTRY                 ple = NULL;

    PSOURCE_ENTRY               pse = NULL;

    
    TRACEGROUP2(
        GROUP, "ENTERED DeleteInterfaceFromGroupMfe : Group : %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask 
        );


    //
    // for each bucket
    //

    for ( dwInd = 0; dwInd < SOURCE_TABLE_SIZE; dwInd++ )
    {
        //
        // for each source entry.
        //

        for ( ple = pge-> pleSrcHashTable[ dwInd ].Flink;
              ple != &pge-> pleSrcHashTable[ dwInd ];
              ple = ple-> Flink )
        {
            pse = CONTAINING_RECORD( ple, SOURCE_ENTRY, leSrcHashList );

            if ( !IS_VALID_INTERFACE( 
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr ) )
            {
                continue;
            }

            DeleteInterfaceFromSourceMfe(
                pge, pse, dwIfIndex, dwIfNextHopAddr, 
                dwProtocolId, dwComponentId, bIGMP, FALSE
                );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromGroupMfe" );
}


//----------------------------------------------------------------------------
// DeleteInterfaceFromSourceMfe
//
// This function deletes an interface from the mfe outgoing list
//----------------------------------------------------------------------------

VOID
DeleteInterfaceFromSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bDel
)
{
    BOOL                        bFound, bNewComp, bUpdateForwarder = FALSE;

    DWORD                       dwTimeOut = 0, dwTimerQ;
    
    POUT_IF_ENTRY               poie = NULL;

    PPROTOCOL_ENTRY             ppe = NULL;

    
    TRACEGROUP4(
        GROUP, "ENTERED DeleteInterfaceFromSourceMfe : Source %x, %x"
        "Interface %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask, dwIfIndex, dwIfNextHopAddr
        );

    
    //
    // delete interface from the mfe outgoing interface list
    //
        
    bFound = FindOutInterfaceEntry( 
                &pse-> leMfeIfList, dwIfIndex, dwIfNextHopAddr, 
                dwProtocolId, dwComponentId, &bNewComp, &poie
                );

    if ( bFound )
    {
        //
        // decrement the reference counts
        //

        if ( bIGMP && IS_ADDED_BY_IGMP( poie ) )
        {
            poie-> wNumAddsByIGMP--;

            if ( poie-> wNumAddsByIGMP == 0 )
            {
                CLEAR_ADDED_BY_IGMP( poie );
            }
        }

        else if ( !bIGMP && IS_ADDED_BY_PROTOCOL( poie ) )
        {
            poie-> wNumAddsByRP--;

            if ( poie-> wNumAddsByRP == 0 )
            {
                CLEAR_ADDED_BY_PROTOCOL( poie );
            }
        }


        //
        // This interface is not required by either IGMP or the 
        // routing protocol on the interface, delete it
        //
        
        if ( bDel ||
             ( !IS_ADDED_BY_IGMP( poie ) && !IS_ADDED_BY_PROTOCOL( poie ) ) )
            
        {
            DeleteOutInterfaceEntry( poie );

            poie = NULL;

            bUpdateForwarder = pse-> bInForwarder;

            pse-> dwMfeIfCount--;
        }

        
        //--------------------------------------------------------------------
        // NEGATIVE mfe check
        // if mfe out interface list is empty
        //--------------------------------------------------------------------

        if ( IsListEmpty( &pse-> leMfeIfList ) )
        {
            TRACEGROUP0( GROUP, "MFE OIL is empty ==> Negative Mfe" );

            
            //
            // Invoke delete member callback for component that
            // owns the incoming interface.
            //

            ppe = GetProtocolEntry( 
                    &ig.mllProtocolList.leHead, pse-> dwInProtocolId, 
                    pse-> dwInComponentId
                    );

            if ( ppe == NULL )
            {
                TRACE2( 
                    ANY, 
                    "DeleteInterfaceFromSourceMfe : Protocol not found"
                    "%x, %x",
                    pse-> dwInProtocolId, pse-> dwInComponentId
                    );
            }

            else if ( IS_PRUNE_ALERT( ppe ) )
            {
                PRUNE_ALERT( ppe ) (
                    pse-> dwSourceAddr, pse-> dwSourceMask, 
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                    FALSE, &dwTimeOut
                    );

                //
                // Reset the timerout value for this MFE to reflect
                // the timer value for the negative MFE
                //

                dwTimerQ = TIMER_TABLE_HASH( pge-> dwGroupAddr );
                                
                RtlUpdateTimer( 
                    TIMER_QUEUE_HANDLE( dwTimerQ ), pse-> hTimer,
                    dwTimeOut, 0
                    );
            }
        }


        //--------------------------------------------------------------------
        // Forwarder update
        //--------------------------------------------------------------------
        
        if ( bUpdateForwarder )
        {
            //
            // router manager callback to set updated mfe to forwarder
            //

            AddMfeToForwarder( pge, pse, dwTimeOut );
        }
    }

    TRACEGROUP0( GROUP, "LEAVING DeleteInterfaceFromSourceMfe" );
}



//----------------------------------------------------------------------------
// LookupAndDeleteYourMfe
//
// 
//----------------------------------------------------------------------------

VOID
LookupAndDeleteYourMfe(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bDeleteTimer,
    PDWORD                      pdwInIfIndex            OPTIONAL,
    PDWORD                      pdwInIfNextHopAddr      OPTIONAL
)
{

    BOOL                        bGrpEntryLock = FALSE;
    
    DWORD                       dwGrpBucket, dwSrcBucket, dwTimerQ;

    PLIST_ENTRY                 pleBucket = NULL;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;


    TRACEGROUP4(
        GROUP, "ENTERED LookupAndDeleteYourMfe : "
        "Group %x, %x, Source %x, %x", 
        dwGroupAddr, dwGroupMask, dwSourceAddr, dwSourceMask
        );

        
    do
    {
        //
        // lock group bucket
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
        
        ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

        pleBucket = GROUP_BUCKET_HEAD( dwGrpBucket );


        //
        // get group entry
        //
        
        pge = GetGroupEntry( pleBucket, dwGroupAddr, dwGroupMask );

        if ( pge == NULL )
        {
            TRACE2( 
                ANY, "LookupAndDeleteYourMfe : Could not find group entry"
                "%x, %x", dwGroupAddr, dwGroupMask
                );
                
            break;                
        }


        //
        // get source entry
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bGrpEntryLock = TRUE;
        
        
        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleBucket = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        
        pse = GetSourceEntry( pleBucket, dwSourceAddr, dwSourceMask );

        if ( pse == NULL )
        {
            TRACE2( 
                ANY, "LookupAndDeleteYourMfe : Could not find source entry"
                "%x, %x", dwGroupAddr, dwGroupMask
                );
                
            break;                
        }


        //
        // save in i/f index/nhop addr if required
        //

        if ( pdwInIfIndex != NULL )
        {
            *pdwInIfIndex = pse-> dwInIfIndex;
        }

        if ( pdwInIfIndex != NULL )
        {
            *pdwInIfNextHopAddr = pse-> dwInIfNextHopAddr;
        }

        
        //
        // remove Mfe
        //
        
        DeleteMfe( pge, pse );


        //
        // Cancel the expiry timer for the MFE is required
        //
        
        if ( bDeleteTimer && ( pse-> hTimer != NULL ) )
        {
            dwTimerQ = TIMER_TABLE_HASH( dwGroupAddr );
            
            RtlDeleteTimer( TIMER_QUEUE_HANDLE( dwTimerQ ), pse-> hTimer, NULL );

            pse-> hTimer = NULL;
        }

        
        //
        // if there are no source specific joins for this source,
        // the this source entry is no longer required.
        //

        if ( IsListEmpty( &pse-> leOutIfList ) )
        {
            DeleteSourceEntry( pse );

            pge-> dwSourceCount--;
        }

    
        //
        // if there are no sources remaining for this group
        // delete the group entry
        //
        
        if ( pge-> dwSourceCount == 0 )
        {
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bGrpEntryLock = FALSE;

            DeleteGroupEntry( pge );

        }
        
    } while ( FALSE );


    if ( bGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }
    
    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );

    TRACEGROUP0( GROUP, "LEAVING LookupAndDeleteYourMfe" );
}



//----------------------------------------------------------------------------
// DeleteMfe
//
// 
//----------------------------------------------------------------------------

VOID
DeleteMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{
    PLIST_ENTRY                 ple = NULL;

    POUT_IF_ENTRY               poie = NULL;

    
    //
    // Delete all outgoing interfaces from the MFE outgoing list
    //

    while ( !IsListEmpty( &pse-> leMfeIfList ) )
    {
        ple = RemoveHeadList( &pse-> leMfeIfList );

        poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        DeleteOutInterfaceEntry( poie );
    }


    //
    // reset incoming interface and protocol component
    //
    
    pse-> dwInIfIndex = INVALID_INTERFACE_INDEX;

    pse-> dwInIfNextHopAddr = INVALID_NEXT_HOP_ADDR;

    pse-> dwInProtocolId = INVALID_PROTOCOL_ID;

    pse-> dwInComponentId = INVALID_COMPONENT_ID;


    //
    // Update mfe
    //
    
    if ( pse-> bInForwarder )
    {
        DeleteMfeFromForwarder( pge, pse );
    }
}


//----------------------------------------------------------------------------
// AddToGroupList
//
// 
//----------------------------------------------------------------------------

DWORD
AddToGroupList(
    PGROUP_ENTRY                pge
)
{

    DWORD                       dwErr = NO_ERROR;

    PGROUP_ENTRY                pgeNext = NULL;

    PLIST_ENTRY                 pleTempGrpList = NULL;



    TRACEGROUP2(
        GROUP, "ENTERED AddToGroupList : %x, %x", pge-> dwGroupAddr, 
        pge-> dwGroupMask
        );

        
    //
    // Lock Temp List
    //

    ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

    
    do
    {
        //
        // Find appropriate place to insert new entry. 
        //

        pleTempGrpList = TEMP_GROUP_LIST_HEAD();
    
        if ( FindGroupEntry( 
                pleTempGrpList, pge-> dwGroupAddr, pge-> dwGroupMask,
                &pgeNext, FALSE
                ) )
        {
            dwErr = ERROR_ALREADY_EXISTS;
            
            TRACE2( 
                GROUP, "AddToGroupList Group Entry already exists for : %x, %x",
                pge-> dwGroupAddr, pge-> dwGroupMask
                );

            break;
        }


        //
        // Insert new group entry into temp list
        //

        if ( pgeNext != NULL )
        {
            InsertTailList( &pgeNext-> leGrpList, &pge-> leGrpList );
        }
        else
        {
            InsertTailList( pleTempGrpList, &pge-> leGrpList );
        }

        ig.dwNumTempEntries++;


        //
        // if temp list size exceeds thresholds
        // - merge temp list with master group list
        //

        if ( ig.dwNumTempEntries > TEMP_GROUP_LIST_MAXSIZE )
        {
            MergeTempAndMasterGroupLists( pleTempGrpList );
        }

    } while ( FALSE );

    
    //
    // Unlock temp list
    //

    RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();


    TRACEGROUP1( GROUP, "LEAVING AddToGroupList %d", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// MergeWithMasterGroupList
//
// Assumes the temp list is exclusively locked 
//----------------------------------------------------------------------------

VOID
MergeTempAndMasterGroupLists(
    PLIST_ENTRY                 pleTempList
)
{

    PLIST_ENTRY                 pleMasterHead = NULL, pleMaster = NULL,
                                pleTempHead = NULL;

    PGROUP_ENTRY                pgeMaster = NULL, pgeTemp = NULL;

    
    INT                         iCmp;

    
    TRACEGROUP0( GROUP, "ENTERED MergeTempAndMasterGroupLists" );

    
    //
    // Lock Master Group List
    //

    ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE();


    do
    {
        //
        // Merge temp list
        //

        if ( IsListEmpty( pleTempList ) )
        {
            break;
        }


        pleMasterHead = MASTER_GROUP_LIST_HEAD();

        pleMaster = pleMasterHead-> Flink;


        //
        // for each entry in the temp list
        //

        while ( !IsListEmpty( pleTempList ) )
        {
            //
            // Remove entry from the temp list
            //

            pleTempHead = RemoveHeadList( pleTempList );
            

            //
            // Insert entry from temp list into the master list
            //

            pgeTemp = CONTAINING_RECORD( 
                    pleTempHead, GROUP_ENTRY, leGrpList 
                    );


            //
            // find its location in the master list
            //
            
            if ( IsListEmpty( pleMasterHead ) )
            {
                //
                // first element in master list, insert w/o searching
                //
                
                InsertTailList( pleMasterHead, pleTempHead );

                pleMaster = pleMasterHead-> Flink;

                continue;
            }

            //
            // At least one element present in the Master list
            //
            
            while ( pleMaster != pleMasterHead )
            {
                pgeMaster = CONTAINING_RECORD(
                            pleMaster, GROUP_ENTRY, leGrpList
                            );

                if ( INET_CMP( 
                        pgeTemp-> dwGroupAddr, pgeMaster-> dwGroupAddr, iCmp
                        ) < 0 )
                {
                    break;
                }

                pleMaster = pleMaster-> Flink;
            }

            
            InsertTailList( pleMaster, pleTempHead );
        }

        ig.dwNumTempEntries = 0;

    } while ( FALSE );


    //
    // Unlock master list
    //

    RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE();

    TRACEGROUP0( GROUP, "LEAVING MergeTempAndMasterGroupLists" );
}


//----------------------------------------------------------------------------
// AddToSourceList
//
// Assumes the group entry is exclusively locked 
//----------------------------------------------------------------------------

DWORD
AddToSourceList(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
)
{

    DWORD           dwErr = NO_ERROR;

    PLIST_ENTRY     pleTempSrcList;

    PSOURCE_ENTRY   pseTemp = NULL;
    

    
    TRACEGROUP2( 
        GROUP, "ENTERED AddToSourceList : %x, %x",
        pse-> dwSourceAddr, pse-> dwSourceMask
        );

    do
    {
        //
        // Insert source entry into temp list
        //

        pleTempSrcList = TEMP_SOURCE_LIST_HEAD( pge );

        if ( FindSourceEntry( pleTempSrcList, pse-> dwSourceAddr,
                              pse-> dwSourceMask, &pseTemp, FALSE ) )
        {
            dwErr = ERROR_ALREADY_EXISTS;
            
            TRACE2( 
                GROUP, "AddToGroupList Source Entry already exists for : %x, %x",
                pse-> dwSourceAddr, pse-> dwSourceMask
                );

            break;
        }


        if ( pseTemp != NULL )
        {
            InsertTailList( &pseTemp-> leSrcList, &pse-> leSrcList );
        }

        else
        {
            InsertTailList( &pge-> leTempSrcList, &pse-> leSrcList );
        }


        //
        // if temp source list size if larger than the threshold
        //

        pge-> dwNumTempEntries++;

        if ( pge-> dwNumTempEntries > TEMP_SOURCE_LIST_MAXSIZE )
        {
            MergeTempAndMasterSourceLists( pge );
        }
        
    } while ( FALSE );


    TRACEGROUP1( GROUP, "LEAVING AddToSourceList : %d", dwErr );

    return dwErr;
}



//----------------------------------------------------------------------------
// MergeWithMasterSourceList
//
// Assumes the group entry is exclusively locked 
//----------------------------------------------------------------------------

VOID
MergeTempAndMasterSourceLists(
    PGROUP_ENTRY                pge
)
{
    INT                         iCmp;
    
    PSOURCE_ENTRY               pseTemp = NULL, pseMaster = NULL;

    PLIST_ENTRY                 pleTemp, pleSrcHead, pleSrc, pleHead;
    

    TRACEGROUP2( 
        GROUP, "ENTERED MergeWithMasterSourceList : %x, %x",
        pge-> dwGroupAddr, pge-> dwGroupMask
        );

        
    do
    {
        //
        // if temp list is entry, quit.
        //

        pleTemp = TEMP_SOURCE_LIST_HEAD( pge );

        if ( pge-> dwNumTempEntries == 0 )
        {
            break;
        }

        
        //
        // Remove each entry from the temp list and
        // insert it into the master list in order
        //

        pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

        pleSrc = pleSrcHead-> Flink;
        

        while ( !IsListEmpty( pleTemp ) )
        {
            pleHead = RemoveHeadList( pleTemp );

            pseTemp = CONTAINING_RECORD( 
                        pleHead, SOURCE_ENTRY, leSrcList
                        );

            if ( IsListEmpty( pleSrcHead ) )
            {
                //
                // first element in source master list
                //

                InsertTailList( pleSrcHead, pleHead );

                pleSrc = pleSrcHead-> Flink;

                continue;
            }


            //
            // at least one source present in master source list
            //
            
            while ( pleSrc != pleSrcHead )
            {

                pseMaster = CONTAINING_RECORD( 
                                pleSrc, SOURCE_ENTRY, leSrcList
                                );

                if ( INET_CMP( pseTemp-> dwSourceAddr, 
                               pseMaster-> dwSourceAddr, iCmp ) < 0 )
                {
                    break;  
                }

                pleSrc = pleSrc-> Flink;
            }

            InsertTailList( pleSrc, pleHead );
        }

        pge-> dwNumTempEntries = 0;
        
    } while ( TRUE );


    TRACEGROUP0( GROUP, "LEAVING MergeWithMasterSourceList" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\forward.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: forward.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Declarations for wrapper functions for callbacks into IP Router Manager.
// These functions represent the interface for MGM to the kernel mode
// forwarder.
//============================================================================


#ifndef _FORWARD_H_
#define _FORWARD_H_

VOID
GetMfeFromForwarder(
);


VOID
AddMfeToForwarder( 
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse, 
    DWORD                       dwTimeout
);


VOID
DeleteMfeFromForwarder(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);

//
// New Packet recevied API.  Used to notify MGM of packet arrival.
// MGM creates an MFE in response to this.
//

DWORD
MgmNewPacketReceived(
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwInIfIndex,
    IN              DWORD                   dwInIfNextHopAddr,
    IN              DWORD                   dwHdrSize,
    IN              PBYTE                   pbPacketHdr
);


DWORD 
WrongIfFromForwarder(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
);


#endif // _FORWARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\if.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: if.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Declarations for routines that manipulate interface entries
//============================================================================


#ifndef _IF_H_
#define _IF_H_

#include <mgm.h>

//----------------------------------------------------------------------------
// IF_ENTRY
//
// For each interface owned by a routing protocol an interface entry 
// is created in the interface table.
//
// dwIfIndex            -       Interface index
//
// dwNextHopAddr        -       Next hop IP address, used to distinguish
//                              dial-in interfaces that are all connected
//                              on the same RAS Server Interface.
//
// dwOwningProtocol     -       Protocol id of routing protocol that
//                              owns this interface.
//
// dwOwningComponent    -       Component of protocol.
//
// wAddedByFlag         -       Flag indicating if the interface entry was
//                              added by the routing protocol / IGMP / both.
//
// leOutIfList          -       list of (source, group) entries that reference
//                              this interface in their outgoing interface list
//
// leInIfList           -       list of (source, group) entries that reference
//                              this interface as their incoming interface
//----------------------------------------------------------------------------

typedef struct _IF_ENTRY
{
    LIST_ENTRY                  leIfHashList;

    DWORD                       dwIfIndex;

    DWORD                       dwIfNextHopAddr;

    DWORD                       dwOwningProtocol;

    DWORD                       dwOwningComponent;

    WORD                        wAddedByFlag;

    LIST_ENTRY                  leOutIfList;

    LIST_ENTRY                  leInIfList;

} IF_ENTRY, *PIF_ENTRY;



//----------------------------------------------------------------------------
// IF_REFERENCE_ENTRY
//
// Each interface maintains a list of (source, group) entries that refer 
// to this interface.  Each entry in this reference list stores the
// source, group info and a flag to determine what protocol caused this 
// reference.  Protocol could be IGMP/some routing protocol or both.
//
// Fields descriptions are left as an exercise to the reader.
//
//----------------------------------------------------------------------------

typedef struct _IF_REFERENCE_ENTRY
{
    LIST_ENTRY                  leRefList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    WORD                        wAddedByFlag;
    
} IF_REFERENCE_ENTRY, *PIF_REFERENCE_ENTRY;


DWORD
CreateIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
);


VOID
DeleteIfEntry(
    PIF_ENTRY                   pieEntry
);


PIF_ENTRY
GetIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr
);


BOOL
FindIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    PIF_ENTRY *                 ppie
);

DWORD
AddSourceToOutList(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);


VOID
AddSourceToRefList(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);


VOID
DeleteSourceFromRefList(
    PLIST_ENTRY                 pleIfRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
);



BOOL
FindRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PIF_REFERENCE_ENTRY *       ppire
);



VOID
DeleteOutInterfaceRefs(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie,
    BOOL                        bIGMP
);


VOID
DeleteInInterfaceRefs(
    PLIST_ENTRY                 pleRefList
);


DWORD
TransferInterfaceOwnershipToIGMP(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
);


DWORD
TransferInterfaceOwnershipToProtocol(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
);


#endif // _IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\group.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: group.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Data structures for and declarations for routines that manipulate 
// group and sources entries
//============================================================================


#ifndef _GROUP_H_
#define _GROUP_H_


//----------------------------------------------------------------------------
// OUT_IF_ENTRY
//
// Each OUT_IF_ENTRY stores information about an outgoing interface in an
// MFE.  The fields in the structure are :
//
//  leIfList        -           link to next entry in the outgoing interface
//                              list.
//  dwIfIndex       -           Index of interface 
//
//  dwNextHopIfAddr -           For interfaces with same index the next hop
//                              address is used to distinguish them
//
//  dwProtocolId    -           Protocol id of the routing protocol component
//                              that owns dwIfIndex
//
//  dwComponentId   -           Component id of the routing protocol component
//                              that owns dwIfIndex
//
//  wCreatedForFlag -           Indicates if the interface entry was created
//                              explicitly by a protocol or implicitly by
//                              MGM (as a consequence of the interface being
//                              being present in the Outgoing Interface list
//                              of the corresponding (*, G) or (*, *) entry.
//
//  dwAddedByFlag   -           if the interface entry is created by a 
//                              routing protocol then it could have been 
//                              created by both IGMP or by a full fledged 
//                              routing protocol (or both).  This flag is 
//                              used to distinguish both.
//
//  wNumAddsByIGMP  -           Count of number of times this interface has 
//                              been added to the OIL by IGMP.  Can be at most
//                              2, once for a (*, G) addition and once for an
//                              (S, G) addition.
//
//  wNumAddsByRP    -           Count of number of times this interface has 
//                              been added to the OIL by the RP on this 
//                              interface.  Can be at most
//                              3, once for a (*, *) addition, once for a 
//                              (*, G) addition and once for an (S, G) 
//                              addition.
//
//  misIfStats      -           Statistics for this outgoing interface.
//
//----------------------------------------------------------------------------

typedef struct _OUT_IF_ENTRY
{
    LIST_ENTRY                  leIfList;

    DWORD                       dwIfIndex;

    DWORD                       dwIfNextHopAddr;

    DWORD                       dwProtocolId;

    DWORD                       dwComponentId;

    WORD                        wForward;
    
    WORD                        wAddedByFlag;

    WORD                        wNumAddsByIGMP;

    WORD                        wNumAddsByRP;

    IPMCAST_OIF_STATS           imosIfStats;

} OUT_IF_ENTRY, *POUT_IF_ENTRY;


//
// Macros to manipulate bit flags in OUT_IF_ENTRY
// 

#define     ADDED_BY_IGMP                   (DWORD) 0x8000
#define     ADDED_BY_ROUTING_PROTOCOL       (DWORD) 0x4000


#define     SET_ADDED_BY_IGMP( p ) \
            (p)-> wAddedByFlag |= ADDED_BY_IGMP

#define     CLEAR_ADDED_BY_IGMP( p ) \
            (p)-> wAddedByFlag &= ~ADDED_BY_IGMP

#define     IS_ADDED_BY_IGMP( p ) \
            ( (p)-> wAddedByFlag & ADDED_BY_IGMP )


#define     SET_ADDED_BY_PROTOCOL( p ) \
            (p)-> wAddedByFlag |= ADDED_BY_ROUTING_PROTOCOL

#define     CLEAR_ADDED_BY_PROTOCOL( p ) \
            (p)-> wAddedByFlag &= ~ADDED_BY_ROUTING_PROTOCOL

#define     IS_ADDED_BY_PROTOCOL( p ) \
            ( (p)-> wAddedByFlag & ADDED_BY_ROUTING_PROTOCOL )


//----------------------------------------------------------------------------
// SOURCE_ENTRY
//
// Each SOURCE_ENTRY represents information about a specific source for a
// specific group.  The source can also be the wildcard source created by a
// (*, G) join for a group.  A source entry is either explicitly created by 
// a source specific (S, G) join or implicitly by MGM when creating an MFE
// in response to packet arrival.
//
// leSrcList        -           Links along the lexicographically ordered
//                              source list
//
// leSrcHashList    -           Links along the source hash table.
//
// leScopedIfList   -           List of interfaces that have been joined
//                              but administratively scoped out.
//
// leOutIfList      -           Outgoing interface list.  Entries in this
//                              list are created as a result of explicit
//                              (S, G) joins by a protocol
//
// leMfeIfList      -           Outgoing interface list created when an MFE
//                              for this source, for this group is created
//                              by MGM.  This list is created by MGM
//                              when a new packet for this (source, group)
//                              and respresents the merge of the outgoing
//                              interface lists of the (*, *) entry, (*, G)
//                              entry and the (S,G) entry.
//
// dwOutIfCount     -           Count of number of entries in leOutIfList.
//                              Used to determine callback order.
//
// dwOutIfCompCount -           Count of number of protocol components that 
//                              have added interfaces to the outgoing list.
//                              Used to determine the order of callbacks to
//                              routing protocols
//
// dwSourceAddr     -           IP Address of source.
//
// dwSourceMask     -           IP mask corresponding to dwSourceAddr
//
// dwInIfIndex      -           Interface index of the incmoing interface.
//                              A source entry is considered to be an MFE
//                              if it has a valid incoming interface.
//
// dwInIfNextHopAddr    -       next hop address for dwInIfIndex
//
// dwInProtocolId   -           Protocol Id of the protocol owning dwInIfIndex
//
// dwInComponentId  -           Component Id of the protocol component owning
//                              dwIfInIndex
//
// bInForwarder     -           Flag indicating if the MFE is present in the
//                              kernel mode forwarder.
//
// liExpiryTime     -           Expiration time of the source entry.
//
// mgmGrpStatistics -           Statistics associated with this (S, G) entry
//
//----------------------------------------------------------------------------

typedef struct _SOURCE_ENTRY
{
    LIST_ENTRY                  leSrcList;
    
    LIST_ENTRY                  leSrcHashList;

    DWORD                       dwInUse;
    
    DWORD                       dwOutIfCount;
    
    DWORD                       dwOutCompCount;
    
    LIST_ENTRY                  leOutIfList;

    LIST_ENTRY                  leScopedIfList;

    DWORD                       dwMfeIfCount;
    
    LIST_ENTRY                  leMfeIfList;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    DWORD                       dwInIfIndex;

    DWORD                       dwInIfNextHopAddr;

    DWORD                       dwUpstreamNeighbor;

    DWORD                       dwRouteProtocol;

    DWORD                       dwRouteNetwork;

    DWORD                       dwRouteMask;
    
    DWORD                       dwInProtocolId;

    DWORD                       dwInComponentId;

    BOOL                        bInForwarder;

    HANDLE                      hTimer;

    DWORD                       dwTimeOut;
    
    LARGE_INTEGER               liCreationTime;

    IPMCAST_MFE_STATS           imsStatistics;

} SOURCE_ENTRY, *PSOURCE_ENTRY;


#define MGM_SOURCE_ENUM_SIGNATURE   'sMGM'


//----------------------------------------------------------------------------
// GROUP_ENTRY
//
// Each group entry contains information for a specific group that has been
// explicitly added by a protocol (or implicitly by MGM).  The group can 
// a wildcard group created by a (*, *) join.
//
// leGrpList        -           Links along the lexicographically ordered 
//                              group list.
//
// leGrpHashList    -           Links along the group hash bucket.
//
// dwGroupAddr      -           Group address of entry.
//
// dwGroupMask      -           Mask corresponding to the group address
//
// leSourceList     -           Head of lexicographically ordered source list
//
// pleSrcHashTable  -           hash table of source entries for this group
//
//----------------------------------------------------------------------------

typedef struct _GROUP_ENTRY
{
    LIST_ENTRY                  leGrpList;
    
    LIST_ENTRY                  leGrpHashList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    PMGM_READ_WRITE_LOCK        pmrwlLock;


    DWORD                       dwSourceCount;


    DWORD                       dwNumTempEntries;

    LIST_ENTRY                  leTempSrcList;
    
    LIST_ENTRY                  leSourceList;
    
    LIST_ENTRY                  pleSrcHashTable[1];
    
} GROUP_ENTRY, *PGROUP_ENTRY;


#define MGM_GROUP_ENUM_SIGNATURE    'gMGM'



DWORD
CreateGroupEntry(
    PLIST_ENTRY                 pleHashList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge
);


PGROUP_ENTRY
GetGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask
);


VOID
DeleteGroupEntry(
    PGROUP_ENTRY                pge
);


BOOL
FindGroupEntry(
    PLIST_ENTRY                 pleGroupList,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PGROUP_ENTRY *              ppge,
    BOOL                        bHashList
);


DWORD
CreateSourceEntry(
    PGROUP_ENTRY                pge,
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse
);


PSOURCE_ENTRY
GetSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask
);


VOID
DeleteSourceEntry(
    PSOURCE_ENTRY               pse
);


BOOL
FindSourceEntry(
    PLIST_ENTRY                 pleSrcList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    PSOURCE_ENTRY *             ppse,
    BOOL                        bHashList
);


DWORD
CreateOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
);


POUT_IF_ENTRY
GetOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
);


VOID
DeleteOutInterfaceEntry(
    POUT_IF_ENTRY               poie
);


BOOL
FindOutInterfaceEntry(
    PLIST_ENTRY                 pleOutIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PBOOL                       pbNewComponent,   
    POUT_IF_ENTRY *             ppoie
);


DWORD
AddInterfaceToSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP,
    PBOOL                       pbUpdateMfe,
    PLIST_ENTRY                 pleSourceList
);


VOID
AddInterfaceToAllMfeInGroupBucket(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    DWORD                       dwInd,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                 pleSourceList
);


VOID
AddInterfaceToGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bAdd,
    PLIST_ENTRY                    pleSourceList
);


VOID
AddInterfaceToSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    POUT_IF_ENTRY *             ppoie
);


VOID
DeleteInterfaceFromSourceEntry(
    PPROTOCOL_ENTRY             ppe,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    BOOL                        bIGMP
);


VOID
DeleteInterfaceFromAllMfe(
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
);


VOID
DeleteInterfaceFromGroupMfe(
    PGROUP_ENTRY                pge,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP
    
);


VOID
DeleteInterfaceFromSourceMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    BOOL                        bIGMP,
    BOOL                        bDel
);


VOID
LookupAndDeleteYourMfe(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bDeleteTimer,
    PDWORD                      pdwInIfIndex            OPTIONAL,
    PDWORD                      pdwInIfNextHopAddr      OPTIONAL
    
);


VOID
DeleteMfe(
    PGROUP_ENTRY                pge,
    PSOURCE_ENTRY               pse
);



VOID
MergeTempAndMasterGroupLists(
    PLIST_ENTRY                 pleTempList
);


VOID
MergeTempAndMasterSourceLists(
    PGROUP_ENTRY                pge
);

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\ipmgm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: ipmgm.h
//
// History:
//      V Raman Aug-6-1997  Created.
//
// Contains type definitions and declarations for IP MGM.
//============================================================================

#ifndef _IPMGM_H_
#define _IPMGM_H_



//
// various codes describing states of IPMGM.
//

typedef enum _IPMGM_STATUS_CODE {
    IPMGM_STATUS_STARTING   = 100,
    IPMGM_STATUS_RUNNING    = 101,
    IPMGM_STATUS_STOPPING   = 102,
    IPMGM_STATUS_STOPPED    = 103
} IPMGM_STATUS_CODE, *PIPMGM_STATUS_CODE;


//
// Structure of global information maintained by MGM.
//
//

typedef struct _IPMGM_GLOBALS
{
    //------------------------------------------------------------------------
    // global stuff.
    //------------------------------------------------------------------------
    
    CRITICAL_SECTION            csGlobal;

    IPMGM_STATUS_CODE           imscStatus;

    HANDLE                      hIpMgmGlobalHeap;

    LONG                        lActivityCount;

    HANDLE                      hActivitySemaphore;

    ROUTER_MANAGER_CONFIG       rmcRmConfig;
    

    //------------------------------------------------------------------------
    // hash table sizes
    //------------------------------------------------------------------------

    DWORD                       dwRouteTableSize;

    DWORD                       dwTimerQTableSize;
    

    //------------------------------------------------------------------------
    // Timer handles
    //------------------------------------------------------------------------

    HANDLE                      hRouteCheckTimer;

    
    //------------------------------------------------------------------------
    // lists and tables
    //------------------------------------------------------------------------

    LOCK_LIST                   llStackOfLocks;
    
    DWORD                       dwNumProtocols;
    
    MGM_LOCKED_LIST             mllProtocolList;
    
    MGM_LOCKED_LIST             mllOutstandingJoinList;
    
    PMGM_LOCKED_LIST            pmllIfHashTable;

    PMGM_LOCKED_LIST            pmllRouteHashTable;
    

    DWORD                       dwNumTempEntries;

    MGM_LOCKED_LIST             mllTempGrpList;
    
    MGM_LOCKED_LIST             mllGrpList;

    PMGM_LOCKED_LIST            pmllGrpHashTable;

    PHANDLE                     phTimerQHandleTable;


    //------------------------------------------------------------------------
    // trace stuff.
    //------------------------------------------------------------------------

    DWORD                       dwTraceID;

    DWORD                       dwLogLevel;
    
    HANDLE                      hLogHandle;
    
} IPMGM_GLOBALS, *PIPMGM_GLOBALS;




//============================================================================
// external declaration of the global IPMGM struct
//============================================================================

extern IPMGM_GLOBALS ig;


//============================================================================
// Macros to access hash functions and hash table sizes
//============================================================================

#define IF_TABLE_SIZE           ig.rmcRmConfig.dwIfTableSize

#define IF_TABLE_HASH( Index )     \
        ( ( Index ) % IF_TABLE_SIZE )


#define ROUTE_TABLE_SIZE           ig.dwRouteTableSize

#define ROUTE_TABLE_HASH( p )     \
        ( ( (p)-> RR_Network.N_NetNumber ) % ROUTE_TABLE_SIZE )


#define GROUP_TABLE_SIZE        ig.rmcRmConfig.dwGrpTableSize

#define GROUP_TABLE_HASH( Group, Mask )     \
        ( Group ? ( Group % ( GROUP_TABLE_SIZE - 1 ) + 1 ) : 0 ) 


#define SOURCE_TABLE_SIZE       ig.rmcRmConfig.dwSrcTableSize

#define SOURCE_TABLE_HASH( Source, Mask )   \
        ( Source ? ( Source % ( SOURCE_TABLE_SIZE - 1 ) + 1 ) : 0 ) 


#define TIMER_TABLE_SIZE        ig.dwTimerQTableSize

#define TIMER_TABLE_HASH( Group )           \
        ( ( Group ) % TIMER_TABLE_SIZE )


//============================================================================
// Max number of entries in the temp group list.
// if more entries are added to the temp group list then
// the temp group list is merged with the master group list
//============================================================================

#define TEMP_GROUP_LIST_MAXSIZE     16

#define TEMP_SOURCE_LIST_MAXSIZE    16


//============================================================================
// macros to access list heads
//============================================================================

#define PROTOCOL_LIST_HEAD()        &ig.mllProtocolList.leHead

#define JOIN_LIST_HEAD()            &ig.mllOutstandingJoinList.leHead

#define IF_BUCKET_HEAD( i )         &ig.pmllIfHashTable[ (i) ].leHead

#define ROUTE_BUCKET_HEAD( i )      &ig.pmllRouteHashTable[ (i) ].leHead


#define GROUP_BUCKET_HEAD( i )      &ig.pmllGrpHashTable[ (i) ].leHead

#define TEMP_GROUP_LIST_HEAD()      &ig.mllTempGrpList.leHead

#define MASTER_GROUP_LIST_HEAD()    &ig.mllGrpList.leHead


#define SOURCE_BUCKET_HEAD( a, b )  &(a)-> pleSrcHashTable[ (b) ]

#define MASTER_SOURCE_LIST_HEAD(a)  &(a)-> leSourceList

#define TEMP_SOURCE_LIST_HEAD( a )  &(a)-> leTempSrcList

#define TIMER_QUEUE_HANDLE( i )     ig.phTimerQHandleTable[ i ]


//============================================================================
// Macros to access router manager callback for kernel mode forwarder
//============================================================================

#define IS_ADD_MFE_CALLBACK()   \
        ig.rmcRmConfig.pfnAddMfeCallback != NULL

#define ADD_MFE_CALLBACK()      \
        ( *(ig.rmcRmConfig.pfnAddMfeCallback) )

#define IS_DELETE_MFE_CALLBACK()\
        ig.rmcRmConfig.pfnDeleteMfeCallback != NULL

#define DELETE_MFE_CALLBACK()   \
        ( *(ig.rmcRmConfig.pfnDeleteMfeCallback) )

#define IS_GET_MFE_CALLBACK()      \
        ig.rmcRmConfig.pfnGetMfeCallback != NULL

#define GET_MFE_CALLBACK()      \
        ( *(ig.rmcRmConfig.pfnGetMfeCallback) )

#define IS_HAS_BOUNDARY_CALLBACK()      \
        ig.rmcRmConfig.pfnHasBoundaryCallback != NULL

#define HAS_BOUNDARY_CALLBACK() \
        ( *(ig.rmcRmConfig.pfnHasBoundaryCallback) )


//============================================================================
// memory-allocation constants and macros
//============================================================================

#define GLOBAL_HEAP     ig.hIpMgmGlobalHeap
#define MGM_ALLOC(size) HeapAlloc(GLOBAL_HEAP, 0, size)
#define MGM_FREE(ptr)   HeapFree(GLOBAL_HEAP, 0, ptr)



//============================================================================
// macros invoked when entering API or worker functions
//============================================================================

#define ENTER_MGM_API()         EnterMgmAPI()
#define ENTER_MGM_WORKER()      EnterMgmWorker()


//----------------------------------------------------------------------------
// macro invoked when leaving API or worker functions
//----------------------------------------------------------------------------

#define LEAVE_MGM_API()         LeaveMgmWorker()
#define LEAVE_MGM_WORKER()      LeaveMgmWorker()


//============================================================================
// constants used for tracing 
//============================================================================

#define IPMGM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPMGM_TRACE_TIMER           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPMGM_TRACE_IF              ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPMGM_TRACE_GROUP           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPMGM_TRACE_PROTOCOL        ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LOCK            ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPMGM_TRACE_LOCK_COUNT      ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPMGM_TRACE_START           ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_STOP            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_PACKET          ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_FORWARD         ((DWORD)0x08000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_CALLBACK        ((DWORD)0x10000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ENUM            ((DWORD)0x20000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_ROUTE           ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IPMGM_TRACE_SCOPE           ((DWORD)0x80000000 | TRACE_USE_MASK)


//============================================================================
//
// macros used for locking and unlocking protected structures
//
//============================================================================

#ifdef LOCK_DEBUG


//
// Sync functions/lock creation-deletion tracing
//

#define TRACELOCK0(a)           \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a)

#define TRACELOCK1(a, b)        \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b)

#define TRACELOCK2(a, b, c)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b, c)

#define TRACELOCK3(a, b, c, d)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK, a, b, c, d)


#define TRACECOUNT0(a)          \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a)

#define TRACECOUNT1(a, b)       \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a, b)

#define TRACECOUNT2(a, b, c)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_LOCK_COUNT, a, b, c)

#else

#define TRACELOCK0(a)

#define TRACELOCK1(a, b)

#define TRACELOCK2(a, b, c)

#define TRACELOCK3(a, b, c, d)

#define TRACECOUNT0(a)

#define TRACECOUNT1(a, b)

#define TRACECOUNT2(a, b, c)

#endif


//
// Protocol locks
//

#define ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring protocol lock exclusive" );                  \
        AcquireWriteLock(&ig.mllProtocolList.pmrwlLock);                    \
        TRACELOCK0( "Acquired protocol lock exclusive" );                   \
}

#define RELEASE_PROTOCOL_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing protocol lock exclusive" );                  \
        ReleaseWriteLock(&ig.mllProtocolList.pmrwlLock);                    \
        TRACELOCK0( "Released protocol lock exclusive" );                   \
}

#define ACQUIRE_PROTOCOL_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring protocol lock shared" );                     \
        AcquireReadLock(&ig.mllProtocolList.pmrwlLock);                     \
        TRACELOCK0( "Acquired protocol lock shared" );                      \
}

#define RELEASE_PROTOCOL_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing protocol lock shared" );                     \
        ReleaseReadLock(&ig.mllProtocolList.pmrwlLock);                     \
        TRACELOCK0( "Released protocol lock shared" );                      \
}


//
// scope boundaries lock
//

#define ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring Join list lock exclusive" );                 \
        AcquireWriteLock(&ig.mllOutstandingJoinList.pmrwlLock);             \
        TRACELOCK0( "Acquired Join list lock exclusive" );                  \
}

#define RELEASE_JOIN_LIST_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing join list lock exclusive" );                 \
        ReleaseWriteLock(&ig.mllOutstandingJoinList.pmrwlLock);             \
        TRACELOCK0( "Released join list lock exclusive" );                  \
}

#define ACQUIRE_JOIN_LIST_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring join list lock shared" );                    \
        AcquireReadLock(&ig.mllOutstandingJoinList.pmrwlLock);              \
        TRACELOCK0( "Acquired join list lock shared" );                     \
}

#define RELEASE_JOIN_LIST_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing join list lock shared" );                    \
        ReleaseReadLock(&ig.mllOutstandingJoinList.pmrwlLock);              \
        TRACELOCK0( "Released join list lock shared" );                     \
}


//
// Interfaces locking
//

#define ACQUIRE_IF_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring interface lock exclusive : %d", i );         \
        AcquireWriteLock(&ig.pmllIfHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Acquired interface lock exclusive : %d", i );          \
}

#define RELEASE_IF_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Releasing interface lock exclusive : %d", i );         \
        ReleaseWriteLock(&ig.pmllIfHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Released interface lock exclusive : %d", i );          \
}

#define ACQUIRE_IF_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring interface lock shared : %d", i );            \
        AcquireReadLock(&ig.pmllIfHashTable[ i ].pmrwlLock);                \
        TRACELOCK1( "Acquired interface lock shared : %d", i );             \
}

#define RELEASE_IF_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Releasing interface lock shared : %d", i );            \
        ReleaseReadLock(&ig.pmllIfHashTable[ i ].pmrwlLock);                \
        TRACELOCK1( "Released interface lock shared : %d", i );             \
}


//
// Route references lock
//

#define ACQUIRE_ROUTE_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK0( "Acquiring route lock exclusive" );                     \
        AcquireWriteLock(&(p)->pmrwlLock);                                  \
        TRACELOCK0( "Acquired route lock exclusive");                       \
}

#define RELEASE_ROUTE_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK0( "Releasing route lock exclusive");                      \
        ReleaseWriteLock(&(p)->pmrwlLock);                                  \
        TRACELOCK0( "Released route lock exclusive" );                      \
}

#define ACQUIRE_ROUTE_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK0( "Acquiring route lock shared : %x");                    \
        AcquireReadLock(&(p)->pmrwlLock);                                   \
        TRACELOCK0( "Acquired route lock shared : %x");                     \
}

#define RELEASE_ROUTE_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK0( "Releasing route lock shared : %x");                    \
        ReleaseReadLock(&(p)->pmrwlLock);                                   \
        TRACELOCK0( "Released route lock shared : %x");                     \
}


//
// Group table locks
//

#define ACQUIRE_GROUP_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring group lock exclusive : %d", i );             \
        AcquireWriteLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);              \
        TRACELOCK1( "Acquired group lock exclusive : %d", i );              \
}

#define RELEASE_GROUP_LOCK_EXCLUSIVE( i ) \
{                                                                           \
        TRACELOCK1( "Releasing group lock exclusive : %d", i );             \
        ReleaseWriteLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);              \
        TRACELOCK1( "Released group lock exclusive : %d", i );              \
}

#define ACQUIRE_GROUP_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Acquiring group lock shared : %d", i );                \
        AcquireReadLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Acquired group lock shared : %d", i );                 \
}

#define RELEASE_GROUP_LOCK_SHARED( i ) \
{                                                                           \
        TRACELOCK1( "Releasing group lock shared : %d", i );                \
        ReleaseReadLock(&ig.pmllGrpHashTable[ i ].pmrwlLock);               \
        TRACELOCK1( "Released group lock shared : %d", i );                 \
}


//
// Master group list locks
//

#define ACQUIRE_MASTER_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring master group lock exclusive" );              \
        AcquireWriteLock(&ig.mllGrpList.pmrwlLock);                         \
        TRACELOCK0( "Acquired master group lock exclusive" );               \
}

#define RELEASE_MASTER_GROUP_LOCK_EXCLUSIVE()   \
{                                                                           \
        TRACELOCK0( "Releasing master group lock exclusive" );              \
        ReleaseWriteLock(&ig.mllGrpList.pmrwlLock);                         \
        TRACELOCK0( "Released  master group lock exclusive" );              \
}

#define ACQUIRE_MASTER_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring master group lock shared" );                 \
        AcquireReadLock(&ig.mllGrpList.pmrwlLock);                          \
        TRACELOCK0( "Acquired master group lock shared" );                  \
}

#define RELEASE_MASTER_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing master group lock shared" );                 \
        ReleaseReadLock(&ig.mllGrpList.pmrwlLock);                          \
        TRACELOCK0( "Released master group lock shared" );                  \
}


//
// Temp group list locks
//

#define ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Acquiring temp group lock exclusive" );                \
        AcquireWriteLock(&ig.mllTempGrpList.pmrwlLock);                     \
        TRACELOCK0( "Acquired temp group lock exclusive" );                 \
}

#define RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE() \
{                                                                           \
        TRACELOCK0( "Releasing temp group lock exclusive" );                \
        ReleaseWriteLock(&ig.mllTempGrpList.pmrwlLock);                     \
        TRACELOCK0( "Released temp group lock exclusive" );                 \
}

#define ACQUIRE_TEMP_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Acquiring temp group lock shared" );                   \
        AcquireReadLock(&ig.mllTempGrpList.pmrwlLock);                      \
        TRACELOCK0( "Acquired temp group lock shared" );                    \
}

#define RELEASE_TEMP_GROUP_LOCK_SHARED() \
{                                                                           \
        TRACELOCK0( "Releasing temp group lock shared" );                   \
        ReleaseReadLock(&ig.mllTempGrpList.pmrwlLock);                      \
        TRACELOCK0( "Released temp group lock shared" );                    \
}


//
// Group entry locks
//

#define ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK3( "Acquiring group entry lock exclusive : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__ );   \
        AcquireWriteLock(&(p)->pmrwlLock);                                 \
        TRACELOCK1( "Acquired group entry lock exclusive : %x", (p)-> dwGroupAddr );    \
}

#define RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( p ) \
{                                                                           \
        TRACELOCK3( "Releasing group entry lock exclusive : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__ );   \
        ReleaseWriteLock(&(p)->pmrwlLock);                                 \
        TRACELOCK1( "Released group entry lock exclusive : %x", (p)-> dwGroupAddr );    \
}

#define ACQUIRE_GROUP_ENTRY_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK3( "Acquiring group entry lock shared : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__  );      \
        AcquireReadLock(&(p)->pmrwlLock);                                  \
        TRACELOCK1( "Acquired group entry lock shared : %x", (p)-> dwGroupAddr );       \
}

#define RELEASE_GROUP_ENTRY_LOCK_SHARED( p ) \
{                                                                           \
        TRACELOCK3( "Releasing group entry lock shared : %x, %d, %s", (p)-> dwGroupAddr, __LINE__, __FILE__  );      \
        ReleaseReadLock(&(p)->pmrwlLock);                                  \
        TRACELOCK1( "Released group entry lock shared : %x", (p)-> dwGroupAddr );       \
}


#define ENTER_GLOBAL_SECTION() \
        EnterCriticalSection(&ig.csGlobal)

#define LEAVE_GLOBAL_SECTION() \
        LeaveCriticalSection(&ig.csGlobal)


#define ENTER_GLOBAL_LOCK_LIST_SECTION() \
        EnterCriticalSection(&ig.llStackOfLocks.csListLock)

#define LEAVE_GLOBAL_LOCK_LIST_SECTION() \
        LeaveCriticalSection(&ig.llStackOfLocks.csListLock)



//============================================================================
// macros used for tracing 
//============================================================================

#define TRACEID                     ig.dwTraceID


#define TRACESTART()            \
            TRACEID = TraceRegister("IPMGM")
#define TRACESTOP()             \
            TraceDeregister(TRACEID)
#define TRACE0(l,a)             \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e, f)
#define TRACE6(l,a,b,c,d,e,f,g)   \
            TracePrintfEx(TRACEID, IPMGM_TRACE_ ## l, a, b, c, d, e, f, g)

#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)


//============================================================================
// macros for debug trace only
//============================================================================

//
// enum trace
//

#if ENUM_DBG

#define TRACEENUM0      TRACE0

#define TRACEENUM1      TRACE1

#define TRACEENUM2      TRACE2

#define TRACEENUM3      TRACE3

#define TRACEENUM4      TRACE4

#else

#define TRACEENUM0(l,a)

#define TRACEENUM1(l,a,b)

#define TRACEENUM2(l,a,b,c)

#define TRACEENUM3(l,a,b,c,d)

#define TRACEENUM4(l,a,b,c,d,e)

#endif


//
// forward trace
//

#if FORWARD_DBG

#define TRACEFORWARD0   TRACE0

#define TRACEFORWARD1   TRACE1

#define TRACEFORWARD2   TRACE2

#define TRACEFORWARD3   TRACE3

#define TRACEFORWARD4   TRACE4

#define TRACEFORWARD5   TRACE5

#define TRACEFORWARD6   TRACE6


#else

#define TRACEFORWARD0(l,a)

#define TRACEFORWARD1(l,a,b)

#define TRACEFORWARD2(l,a,b,c)

#define TRACEFORWARD3(l,a,b,c,d)

#define TRACEFORWARD4(l,a,b,c,d,e)

#define TRACEFORWARD5(l,a,b,c,d,e,f)

#define TRACEFORWARD6(l,a,b,c,d,e,f,g)

#endif


//
// group trace
//

#if GROUP_DBG

#define TRACEGROUP0     TRACE0

#define TRACEGROUP1     TRACE1

#define TRACEGROUP2     TRACE2

#define TRACEGROUP3     TRACE3

#define TRACEGROUP4     TRACE4

#define TRACEGROUP5     TRACE5

#define TRACEGROUP6     TRACE6


#else

#define TRACEGROUP0(l,a)

#define TRACEGROUP1(l,a,b)

#define TRACEGROUP2(l,a,b,c)

#define TRACEGROUP3(l,a,b,c,d)

#define TRACEGROUP4(l,a,b,c,d,e)

#define TRACEGROUP5(l,a,b,c,d,e,f)

#define TRACEGROUP6(l,a,b,c,d,e,f,g)

#endif


//
// Interface trace
//

#if IF_DBG

#define TRACEIF0        TRACE0

#define TRACEIF1        TRACE1

#define TRACEIF2        TRACE2

#define TRACEIF3        TRACE3

#define TRACEIF4        TRACE4

#define TRACEIF5        TRACE5

#define TRACEIF6        TRACE6


#else

#define TRACEIF0(l,a)

#define TRACEIF1(l,a,b)

#define TRACEIF2(l,a,b,c)

#define TRACEIF3(l,a,b,c,d)

#define TRACEIF4(l,a,b,c,d,e)

#define TRACEIF5(l,a,b,c,d,e,f)

#define TRACEIF6(l,a,b,c,d,e,f,g)

#endif


//
// packet trace
//

#if PACKET_DBG

#define TRACEPACKET0    TRACE0

#define TRACEPACKET1    TRACE1

#define TRACEPACKET2    TRACE2

#define TRACEPACKET3    TRACE3

#define TRACEPACKET4    TRACE4

#define TRACEPACKET5    TRACE5

#define TRACEPACKET6    TRACE6


#else

#define TRACEPACKET0(l,a)

#define TRACEPACKET1(l,a,b)

#define TRACEPACKET2(l,a,b,c)

#define TRACEPACKET3(l,a,b,c,d)

#define TRACEPACKET4(l,a,b,c,d,e)

#define TRACEPACKET5(l,a,b,c,d,e,f)

#define TRACEPACKET6(l,a,b,c,d,e,f,g)

#endif


//
// route trace
//

#if ROUTE_DBG

#define TRACEROUTE0     TRACE0

#define TRACEROUTE1     TRACE1

#define TRACEROUTE2     TRACE2

#define TRACEROUTE3     TRACE3

#define TRACEROUTE4     TRACE4

#define TRACEROUTE5     TRACE5

#define TRACEROUTE6     TRACE6


#else

#define TRACEROUTE0(l,a)

#define TRACEROUTE1(l,a,b)

#define TRACEROUTE2(l,a,b,c)

#define TRACEROUTE3(l,a,b,c,d)

#define TRACEROUTE4(l,a,b,c,d,e)

#define TRACEROUTE5(l,a,b,c,d,e,f)

#define TRACEROUTE6(l,a,b,c,d,e,f,g)

#endif


//
// scope trace
//

#if SCOPE_DBG

#define TRACESCOPE0     TRACE0

#define TRACESCOPE1     TRACE1

#define TRACESCOPE2     TRACE2

#define TRACESCOPE3     TRACE3

#define TRACESCOPE4     TRACE4

#define TRACESCOPE5     TRACE5

#define TRACESCOPE6     TRACE6


#else

#define TRACESCOPE0(l,a)

#define TRACESCOPE1(l,a,b)

#define TRACESCOPE2(l,a,b,c)

#define TRACESCOPE3(l,a,b,c,d)

#define TRACESCOPE4(l,a,b,c,d,e)

#define TRACESCOPE5(l,a,b,c,d,e,f)

#define TRACESCOPE6(l,a,b,c,d,e,f,g)

#endif


//============================================================================
// Event logging macros
//============================================================================

#define LOGLEVEL        ig.dwLogLevel
#define LOGHANDLE       ig.hLogHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


//
// Error logging
//

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPMGM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPMGM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,IPMGMLOG_ ## msg,4,_asz,(err)); \
        }


//============================================================================
// Macros to access routing protocol callbacks
//============================================================================

#define IS_JOIN_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnJoinAlertCallback != NULL

#define IS_PRUNE_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnPruneAlertCallback != NULL

#define IS_LOCAL_JOIN_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnLocalJoinCallback != NULL

#define IS_LOCAL_LEAVE_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnLocalLeaveCallback != NULL

#define IS_RPF_CALLBACK( p ) \
        (p)-> rpcProtocolConfig.pfnRpfCallback != NULL

#define IS_CREATION_ALERT( p ) \
        (p)-> rpcProtocolConfig.pfnCreationAlertCallback != NULL


#define RPF_CALLBACK( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnRpfCallback ) )


#if CALLBACK_DEBUG

#define JOIN_ALERT( p )   \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Join Alert for protocol %x, %x",             \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnJoinAlertCallback ) )


#define PRUNE_ALERT( p ) \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Prune Alert for protocol %x, %x",            \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnPruneAlertCallback ) )


#define LOCAL_JOIN_ALERT( p )   \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Local Join Alert for protocol %x, %x",        \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnLocalJoinCallback ) )


#define LOCAL_LEAVE_ALERT( p )  \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Local Leave Alert for protocol %x, %x",       \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnLocalLeaveCallback ) )



#define CREATION_ALERT( p )     \
    {                                                                       \
        TRACE2(                                                             \
            CALLBACK, "Invoked Creation Alert for protocol %x, %x",         \
            (p)-> dwProtocolId, (p)-> dwComponentId                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnCreationAlertCallback ) )


#define IGMP_DISABLE_CALLBACK( p ) \
    {                                                                       \
        TRACE0(                                                             \
            CALLBACK, "Invoked Disable IGMP Alert "                         \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnDisableIgmpCallback ) )

#define IGMP_ENABLE_CALLBACK( p ) \
    {                                                                       \
        TRACE0(                                                             \
            CALLBACK, "Invoked Enable IGMP Alert "                          \
            );                                                              \
    }                                                                       \
    ( *( (p)-> rpcProtocolConfig.pfnEnableIgmpCallback ) )


#else

#define JOIN_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnJoinAlertCallback ) )

#define PRUNE_ALERT( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnPruneAlertCallback ) )

#define LOCAL_JOIN_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnLocalJoinCallback ) )

#define LOCAL_LEAVE_ALERT( p ) \
    ( *( (p)-> rpcProtocolConfig.pfnLocalLeaveCallback ) )

#define CREATION_ALERT( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnCreationAlertCallback ) )

#define IGMP_DISABLE_CALLBACK( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnDisableIgmpCallback ) )

#define IGMP_ENABLE_CALLBACK( p ) \
        ( *( (p)-> rpcProtocolConfig.pfnEnableIgmpCallback ) )

#endif



//============================================================================
// Client count and worker thread related stuff.
//============================================================================

DWORD
QueueMgmWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    );

BOOL
EnterMgmAPI(
    );

BOOL
EnterMgmWorker(
    );

VOID
LeaveMgmWorker(
    );

VOID
DisplayGroupTable(
);



extern RTM_ENTITY_INFO         g_reiRtmEntity;

extern RTM_REGN_PROFILE        g_rrpRtmProfile;

extern RTM_ENTITY_HANDLE       g_hRtmHandle;

extern RTM_NOTIFY_HANDLE       g_hNotificationHandle;

extern RTM_REGN_PROFILE        g_rrpRtmProfile;

#endif // _IPMGM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\if.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: if.c
//
// History:
//      V Raman    June-25-1997  Created.
//
// routines that manipulate interface entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// CreateIfEntry
//
// This function creates a new interface entry. Duh
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

DWORD
CreateIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId
)
{

    DWORD                       dwErr = NO_ERROR;

    PIF_ENTRY                   pie = NULL, pieEntry = NULL;


    TRACEIF4( 
        IF, 
        "ENTERED CreateIfEntry : Interface %x, %x : Protocol %x, %x",
        dwIfIndex, dwIfNextHopAddr, dwProtocolId, dwComponentId
        );

        
    do
    {
        //
        // allocate an interface entry.
        //

        pie = MGM_ALLOC( sizeof( IF_ENTRY ) );

        if ( pie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CreateIfEntry : Failed to allocate entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( pie, sizeof( IF_ENTRY ) );

        
        //
        // init. i/f structure
        //
        
        pie-> dwIfIndex             = dwIfIndex;

        pie-> dwIfNextHopAddr       = dwIfNextHopAddr;

        pie-> dwOwningProtocol      = dwProtocolId;

        pie-> dwOwningComponent     = dwComponentId;

        pie-> wAddedByFlag          = 0;

        
        if ( IS_PROTOCOL_ID_IGMP( dwProtocolId ) )
        {
            SET_ADDED_BY_IGMP( pie );
        }

        else
        {
            SET_ADDED_BY_PROTOCOL( pie );
        }


        InitializeListHead( &pie-> leInIfList );

        InitializeListHead( &pie-> leOutIfList );

        
        //
        // insert in protocol list
        //

        InitializeListHead( &pie-> leIfHashList );
        
        InsertTailList( pleIfList, &pie-> leIfHashList );

        
    } while ( FALSE );


    TRACEIF1( IF, "LEAVING CreateIfEntry : %x", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// DeleteIfEntry
//
// This function deletes an interface entry. Duh
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

VOID
DeleteIfEntry(
    PIF_ENTRY                   pieEntry
)
{
    TRACEIF0( IF, "ENTERED DeleteIfEntry" );
    
    RemoveEntryList( &pieEntry-> leIfHashList );

    MGM_FREE( pieEntry );

    TRACEIF0( IF, "LEAVING DeleteIfEntry" );
}



//----------------------------------------------------------------------------
// GetIfEntry
//
// This function retrieves an interface entry. Duh
//
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

PIF_ENTRY
GetIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr
)
{
    PIF_ENTRY                   pie;

    if ( FindIfEntry( pleIfList, dwIfIndex, dwIfNextHopAddr, &pie ) )
    {
        return pie;
    }

    return NULL;
}

//----------------------------------------------------------------------------
// FindIfEntry
//
// This function retrieves an interface entry. Duh
//
// Assumes that the interface list is locked.
//----------------------------------------------------------------------------

BOOL
FindIfEntry(
    PLIST_ENTRY                 pleIfList,
    DWORD                       dwIfIndex,
    DWORD                       dwIfNextHopAddr,
    PIF_ENTRY *                 ppie
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;
    
    PIF_ENTRY                   pie = NULL;

    PLIST_ENTRY                 ple = NULL;


    TRACEIF2( IF, "ENTERED FindIfEntry : %x, %x", dwIfIndex, dwIfNextHopAddr );

    //
    // Scan interface list.  Interface list is ordered by 
    // interface index, next hop address
    //

    *ppie = NULL;

    
    for ( ple = pleIfList-> Flink; ple != pleIfList; ple = ple-> Flink )
    {
        pie = CONTAINING_RECORD( ple, IF_ENTRY, leIfHashList );

        if ( pie-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( pie-> dwIfIndex > dwIfIndex )
        {
            //
            // Entry not present
            //

            *ppie = pie;

            break;
        }

        
        if ( INET_CMP( pie-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            *ppie = pie;
            
            break;
        }

        *ppie = pie;

        bFound = TRUE;

        break;
    }

    TRACEIF1( IF, "LEAVING FindIfEntry : %x", bFound );
    
    return bFound;
}


//----------------------------------------------------------------------------
// AddSourceToOutList
//
// Each interface entry maintains a list of (source, group) entries that
// reference this interface in their outgoing interface list.  Each time
// membership entry is added the (source, group) to the reference list.
// When this interface is eventually deleted these (source, group) entries
// need to be updated to reflect the deletion of this interface.
//
// Assumes that the interface entry is locked.
//----------------------------------------------------------------------------

VOID
AddSourceToRefList(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
)
{
    BOOL                        bFound = FALSE; 

    DWORD                       dwErr = NO_ERROR;
    
    PIF_REFERENCE_ENTRY         pire = NULL, pireNew = NULL;


    TRACEIF5( 
        IF, 
        "ENTERED AddSourceToIfEntry : Source %x, %x : Group %x, %x"
        " : IGMP %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, bIGMP
        );

    do
    {
        //
        // Check if reference already present
        //


        bFound = FindRefEntry( 
                    pleRefList, dwSourceAddr, dwSourceMask, 
                    dwGroupAddr, dwGroupMask, &pire
                    );
                    

        if ( !bFound )
        {
            //
            // no previous reference for this (source, group) was found
            // create a new one.
            //

            pireNew = MGM_ALLOC( sizeof( IF_REFERENCE_ENTRY ) );

            if ( pireNew == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1( 
                    ANY, 
                    "AddSourceToOutList : Failed to allocate reference entry %x",
                    dwErr
                    );

                LOGERR0( HEAP_ALLOC_FAILED, dwErr );

                break;
            }

            ZeroMemory( pireNew, sizeof( IF_REFERENCE_ENTRY ) );
            

            pireNew-> dwSourceAddr  = dwSourceAddr;

            pireNew-> dwSourceMask  = dwSourceMask;

            pireNew-> dwGroupAddr   = dwGroupAddr;

            pireNew-> dwGroupMask   = dwGroupMask;

            pireNew-> wAddedByFlag  = 0;

            
            //
            // set the appropriate bit for the protocol
            //
            
            if ( bIGMP )
            {
                SET_ADDED_BY_IGMP( pireNew );
            }
            
            else
            {
                SET_ADDED_BY_PROTOCOL( pireNew );
            }


            //
            // insert into ref list
            //
            
            if ( pire == NULL )
            {
                InsertTailList( pleRefList, &pireNew-> leRefList );
            }

            else
            {
                InsertTailList( &pire-> leRefList, &pireNew-> leRefList );
            }
        }

        else
        {
            //
            // set the appropriate bit for the protocol
            //
            
            if ( bIGMP )
            {
                SET_ADDED_BY_IGMP( pire );
            }
            
            else
            {
                SET_ADDED_BY_PROTOCOL( pire );
            }
        }
                
    } while ( FALSE );


    TRACEIF1( IF, "LEAVING AddSourceToRefList : %x", bFound );
    
    return;
}



//----------------------------------------------------------------------------
// DeleeSourceFomrRefList
//
// Delete a reference to a (source, group).
//----------------------------------------------------------------------------

VOID
DeleteSourceFromRefList(
    PLIST_ENTRY                 pleIfRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bIGMP
)
{
    BOOL                    bFound = FALSE; 

    PIF_REFERENCE_ENTRY     pire = NULL, pireEntry = NULL;


    TRACEIF5( 
        IF, 
        "ENTERED DeleteSourceFromIfEntry : Source %x %x, Group : %x, %x"
        " : IGMP %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, bIGMP
        );
    

    //
    // find the entry is already present.
    // list is arranged in descending order in terms of
    // Group address, source address
    //

    bFound = FindRefEntry( 
                pleIfRefList, dwSourceAddr, dwSourceMask, 
                dwGroupAddr, dwGroupMask, &pire
                );
                    
    //
    // if entry was not found
    //

    if ( !bFound )
    {
        TRACE1( IF, "LEAVING DeleteSourceFromRefList : %x", FALSE );

        return;
    }


    //
    // reset the appropriate bit for the protocol
    //
            
    if ( bIGMP )
    {
        CLEAR_ADDED_BY_IGMP( pire );
    }
            
    else
    {
        CLEAR_ADDED_BY_PROTOCOL( pire );
    }


    //
    // if no more references left, remove this entry
    //

    if ( !IS_ADDED_BY_IGMP( pire ) &&
         !IS_ADDED_BY_PROTOCOL( pire ) )
    {
        RemoveEntryList( &pire-> leRefList );

        MGM_FREE( pire );
    }

    TRACEIF1( IF, "LEAVING DeleteSourceFromRefList : %x", TRUE );

    return;
}



//----------------------------------------------------------------------------
// FindRefEntry
//
// Locate a reference entry.  If not found return the expected location in 
// the list.
//----------------------------------------------------------------------------

BOOL
FindRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PIF_REFERENCE_ENTRY *       ppire
)
{
    INT                         iCmp;
    
    PLIST_ENTRY                 ple = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;

    BOOL                        bFound = FALSE;
    

    TRACEIF4( 
        IF, 
        "ENTERED FindRefEntry : Source %x, %x : Group %x, %x",
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );
    

    *ppire = NULL;
    

    for ( ple = pleRefList-> Flink; ple != pleRefList; ple = ple-> Flink )
    {
        pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );

        if ( INET_CMP( pire-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppire = pire;

            break;
        }
        
        if ( INET_CMP( pire-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppire = pire;

            break;
        }
        
        //
        // entry found
        //

        *ppire = pire;

        bFound = TRUE;
        
        break;
    }

    TRACEIF1( IF, "LEAVING FindRefEntry : %x", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// DeleteOutInterfaceRefs
//
// When a interface is deleted by a protocol (or IGMP) all (source, group)
// entries that use this interface in their outgoing interface lists have to
// be updated to reflect ththe deletion.  
//
//----------------------------------------------------------------------------

VOID
DeleteOutInterfaceRefs(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie,
    BOOL                        bIGMP
)
{
    PLIST_ENTRY                 ple = NULL, pleRefList = NULL, pleNext = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;



    TRACEIF1( IF, "ENTERED DeleteOutInterfaceRefs: IGMP %x", bIGMP );
    
    do
    {
        //
        // No references for this interface in any outgoing 
        // interface lists of source entries
        //

        pleRefList = &pie-> leOutIfList;
        
        if ( IsListEmpty( pleRefList ) )
        {
            break;
        }


        //
        // walk the reference list and remove the (source, group) entries
        // for each reference
        //

        for ( ple = pleRefList-> Flink; ple != pleRefList; )
        {
            pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );

            
            //
            // was this reference added by this protocol
            //

            if ( ( bIGMP && !IS_ADDED_BY_IGMP( pire ) ) ||
                 ( !bIGMP && !IS_ADDED_BY_PROTOCOL( pire ) ) )
            {
                //
                // no, skip it
                //

                ple = ple-> Flink;
                
                continue;
            }

            
            //
            // Delete this interface from the (source, group) entry. 
            //

            DeleteInterfaceFromSourceEntry(
                ppe,
                pire-> dwGroupAddr, pire-> dwGroupMask,
                pire-> dwSourceAddr, pire-> dwSourceMask,
                pie-> dwIfIndex, pie-> dwIfNextHopAddr,
                bIGMP
                );


            if ( bIGMP )
            {
                CLEAR_ADDED_BY_IGMP( pire );
            }

            else
            {
                CLEAR_ADDED_BY_PROTOCOL( pire );
            }


            //
            // remove reference entry.
            //
            
            if ( !IS_ADDED_BY_IGMP( pire ) &&
                 !IS_ADDED_BY_PROTOCOL( pire ) )
            {
                //
                // no more references to interface for IGMP
                // or for routing protocol.
                // remove this reference entry altogether.
                //

                pleNext = ple-> Flink;
                
                RemoveEntryList( ple );

                MGM_FREE ( pire );

                ple = pleNext;
            }

            else
            {
                ple = ple-> Flink;
            }
        }
        
    } while ( FALSE );

    TRACEIF0( IF, "LEAVING DeleteOutInterfaceRefs:" );

    return;
}



//----------------------------------------------------------------------------
// DeleteInInterfaceRefs
//
// When a interface is deleted by a protocol (or IGMP) all (source, group)
// entries that use this interface as their incoming interface have to
// be updated to reflect the deletion.   
//----------------------------------------------------------------------------

VOID
DeleteInInterfaceRefs(
    PLIST_ENTRY                 pleRefList
)
{
    PLIST_ENTRY                 ple = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;


    TRACEIF0( IF, "Entering DeleteInInterfaceRefs" );

    
    while ( !IsListEmpty( pleRefList ) )
    {
        ple = RemoveHeadList( pleRefList );
        
        pire = CONTAINING_RECORD( ple, IF_REFERENCE_ENTRY, leRefList );


        //
        // A Zappaesque function call here
        //
        
        LookupAndDeleteYourMfe( 
            pire-> dwSourceAddr, pire-> dwSourceMask,
            pire-> dwGroupAddr, pire-> dwGroupMask,
            TRUE, NULL, NULL
            );

        MGM_FREE( pire );
    }

    TRACEIF0( IF, "LEAVING DeleteInInterfaceRefs" );
}


//----------------------------------------------------------------------------
// TransferInterfaceOwnershipToProtocol
//
//
//----------------------------------------------------------------------------

DWORD
TransferInterfaceOwnershipToProtocol(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
)
{
    
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeIgmp;

    
    do
    {
        //
        // get protocol entry for IGMP
        //

        ppeIgmp = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), pie-> dwOwningProtocol,
                    pie-> dwOwningComponent
                    );

        if ( ppeIgmp == NULL )
        {
            //
            // interface is owned by IGMP, but protocol entry is not
            // present for IGMP.  MGM data is in an inconsistent state
            //

            dwErr = ERROR_UNKNOWN;

            TRACE2( 
                ANY, "TransferInterfaceOwnershipToProtocol : Could not find"
                " IGMP protocol entry", pie-> dwIfIndex,
                pie-> dwIfNextHopAddr
                );

            break;
        }

        
        //
        // indicate to IGMP that interface has been disabled.  This should
        // stop IGMP from adding state to this interface while it is being
        // transferred to the protocol
        //

        IGMP_DISABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );

        
        //
        // delete all IGMP references in and out
        //

        DeleteInInterfaceRefs( &pie-> leInIfList );

        DeleteOutInterfaceRefs( ppeIgmp, pie, TRUE );

        
        //
        // mark interface as added by Routing protocol
        //

        SET_ADDED_BY_PROTOCOL( pie );

        pie-> dwOwningProtocol   = ppe-> dwProtocolId;
        
        pie-> dwOwningComponent  = ppe-> dwComponentId;


        //
        // indicate to IGMP that interface has been enabled.
        //
        
        IGMP_ENABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );


    } while ( FALSE );

    return dwErr;
}



//----------------------------------------------------------------------------
// TransferInterfaceOwnershipToIGMP
//
//
//----------------------------------------------------------------------------

DWORD
TransferInterfaceOwnershipToIGMP(
    PPROTOCOL_ENTRY             ppe,
    PIF_ENTRY                   pie
)
{
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeIgmp;


    do
    {
        //
        // get IGMP protocol entry
        //

        ppeIgmp = GetIgmpProtocolEntry( PROTOCOL_LIST_HEAD() );

        if ( ppeIgmp == NULL )
        {
            //
            // interface is has IGMP enabled on it, but a protocol entry is not
            // present for IGMP.  MGM data is in an inconsistent state
            //

            dwErr = ERROR_UNKNOWN;

            TRACE2( 
                ANY, "TransferInterfaceOwnershipToProtocol : Could not find"
                " IGMP protocol entry", pie-> dwIfIndex,
                pie-> dwIfNextHopAddr
                );

            break;
        }


        //
        // indicate to IGMP that interface has been disabled.  This should
        // stop IGMP from adding state to this interface while it is being
        // transferred to IGMP
        //

        IGMP_DISABLE_CALLBACK( ppeIgmp ) (
                pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );

        
        //
        // delete all protocol references (in and out)
        //

        DeleteInInterfaceRefs( &pie-> leInIfList );

        DeleteOutInterfaceRefs( ppe, pie, FALSE );

        CLEAR_ADDED_BY_PROTOCOL( pie );

        
        //
        // delete all IGMP references, these will get added back by
        // IGMP when is enabled on this interface.  This is done
        // below.
        //

        DeleteOutInterfaceRefs( ppe, pie, TRUE );
        

        //
        // Mark interface as being owned by IGMP
        //

        pie-> dwOwningProtocol  = ppeIgmp-> dwProtocolId;

        pie-> dwOwningComponent = ppeIgmp-> dwComponentId;

        
        //
        // enable IGMP on the interface
        //

        IGMP_ENABLE_CALLBACK( ppeIgmp ) (
            pie-> dwIfIndex, pie-> dwIfNextHopAddr
            );


    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\mgm.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: Mgm.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Entry points into MGM.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop



IPMGM_GLOBALS           ig;

RTM_ENTITY_INFO         g_reiRtmEntity = { 0, AF_INET, MS_IP_MGM, 0 };

RTM_REGN_PROFILE        g_rrpRtmProfile;

RTM_ENTITY_HANDLE       g_hRtmHandle;

RTM_NOTIFY_HANDLE       g_hNotificationHandle;

RTM_REGN_PROFILE        g_rrpRtmProfile;


DWORD
StopMgm(
);




//----------------------------------------------------------------------------
// MgmDllStartup
//
// Invoked from DllMain, to initialize global critical section, set status and
// register for tracing.
//----------------------------------------------------------------------------

BOOL
MgmDllStartup(
)
{
    do
    {
        ZeroMemory( &ig, sizeof( IPMGM_GLOBALS ) );


        ig.dwLogLevel = IPMGM_LOGGING_ERROR;
        
        //
        // Create private heap
        //

        ig.hIpMgmGlobalHeap = HeapCreate( 0, 0, 0 );

        if ( ig.hIpMgmGlobalHeap == NULL )
        {
            break;
        }

        //
        // initialize the lock list
        //

        ig.llStackOfLocks.sleHead.Next = NULL;

        try
        {
            InitializeCriticalSection( &ig.llStackOfLocks.csListLock );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            break;
        }

        ig.llStackOfLocks.bInit = TRUE;

        
        //
        // Initialize global critical section and set MGM status
        //

        try
        {
            InitializeCriticalSection( &ig.csGlobal );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            break;
        }

        ig.imscStatus = IPMGM_STATUS_STOPPED;

        return TRUE;

    } while ( FALSE );

    //
    // error occurred - clean up and return FALSE
    //

    //
    // destroy the lock list
    //

    if ( ig.llStackOfLocks.bInit )
    {
        DeleteCriticalSection( &ig.llStackOfLocks.csListLock );
    }

    //
    // delete private heap
    //

    if ( ig.hIpMgmGlobalHeap != NULL )
    {
        HeapDestroy( ig.hIpMgmGlobalHeap );
    }

    return FALSE;
}


//----------------------------------------------------------------------------
// MgmDllCleanup
//
// Invoked from DllMain, to delete global critical section and
// deregister for tracing.
//----------------------------------------------------------------------------

VOID
MgmDllCleanup(
)
{
    DeleteCriticalSection( &ig.csGlobal );

    //
    // delete lock list
    //

    DeleteLockList();
        
    if ( ig.llStackOfLocks.bInit )
    {
        DeleteCriticalSection( &ig.llStackOfLocks.csListLock );
    }
        
    //
    // delete private heap
    //

    if ( ig.hIpMgmGlobalHeap != NULL )
    {
        HeapDestroy( ig.hIpMgmGlobalHeap );
    }

    return;
}


//----------------------------------------------------------------------------
// MgmInitialize
//
// This function is performs Mgm Initialization that includes allocating
// a private heap, creating a activity count semaphores and the list 
// structures for protocol and interface entries.
//----------------------------------------------------------------------------

DWORD
MgmInitialize(
    IN          PROUTER_MANAGER_CONFIG      prmcRmConfig,
    IN OUT      PMGM_CALLBACKS              pmcCallbacks
)
{

    DWORD                       dwErr = NO_ERROR, dwIndex;

    LARGE_INTEGER               li;

    NTSTATUS                    nsStatus = STATUS_SUCCESS;
    


    ENTER_GLOBAL_SECTION();


    //
    // verify MGM has not already been started.
    //
    
    if ( ig.imscStatus != IPMGM_STATUS_STOPPED )
    {
        TRACE0( START, "MgmInitialize : MGM already running" );

        LOGWARN0( IPMGM_ALREADY_STARTED, NO_ERROR );

        LEAVE_GLOBAL_SECTION();

        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // register for tracing
    //

    TRACESTART();

    ig.hLogHandle = RouterLogRegister( "IPMGM" );



    
    TRACE0( ENTER, "ENTERED MgmInitialize" );

    do
    {
        //
        // Copy the Router manager callbacks.
        //

        ig.rmcRmConfig.pfnAddMfeCallback        =
            prmcRmConfig-> pfnAddMfeCallback;
        
        ig.rmcRmConfig.pfnDeleteMfeCallback     = 
            prmcRmConfig-> pfnDeleteMfeCallback;
            
        ig.rmcRmConfig.pfnGetMfeCallback        =
            prmcRmConfig-> pfnGetMfeCallback;

        ig.rmcRmConfig.pfnHasBoundaryCallback   =
            prmcRmConfig-> pfnHasBoundaryCallback;


        //
        // Hash table sizes
        //
        
        ig.rmcRmConfig.dwIfTableSize        = prmcRmConfig-> dwIfTableSize;
        ig.rmcRmConfig.dwGrpTableSize       = prmcRmConfig-> dwGrpTableSize + 1;
        ig.rmcRmConfig.dwSrcTableSize       = prmcRmConfig-> dwSrcTableSize + 1;
        ig.dwRouteTableSize                 = prmcRmConfig-> dwIfTableSize;
        ig.dwTimerQTableSize                = 
            min( prmcRmConfig-> dwGrpTableSize / 10 + 1, TIMER_TABLE_MAX_SIZE );



        if ( prmcRmConfig-> dwLogLevel <= IPMGM_LOGGING_INFO )
        {
            ig.dwLogLevel = prmcRmConfig-> dwLogLevel;
        }

        //
        // initialize the protocol list
        //

        ig.dwNumProtocols = 0;
        
        CREATE_LOCKED_LIST( &ig.mllProtocolList );


        //
        // initialize the outstanding join list

        CREATE_LOCKED_LIST( &ig.mllOutstandingJoinList );

        
        //
        // create and initialize the interface hash table 
        //

        ig.pmllIfHashTable = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) * IF_TABLE_SIZE );

        if ( ig.pmllIfHashTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate interface table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory( 
            ig.pmllIfHashTable, sizeof( MGM_LOCKED_LIST ) * IF_TABLE_SIZE
            );
            

        for ( dwIndex = 0; dwIndex < IF_TABLE_SIZE; dwIndex++ )
        {
            CREATE_LOCKED_LIST( &ig.pmllIfHashTable[ dwIndex ] );
        }

        
        //
        // initialize the master group list and temp group list.
        //

        CREATE_LOCKED_LIST( &ig.mllGrpList );
        CREATE_LOCKED_LIST( &ig.mllTempGrpList );

        ig.dwNumTempEntries = 0;
        

        //
        // Create and Initialize group Hash table
        //

        ig.pmllGrpHashTable = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) * GROUP_TABLE_SIZE );

        if ( ig.pmllGrpHashTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate group table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory(
            ig.pmllGrpHashTable, sizeof( MGM_LOCKED_LIST ) * GROUP_TABLE_SIZE
            );
            
        
        for ( dwIndex = 0; dwIndex < GROUP_TABLE_SIZE; dwIndex++ )
        {
            CREATE_LOCKED_LIST( &ig.pmllGrpHashTable[ dwIndex ] );
        }


        //
        // Set up the table of timer queues
        //

        ig.phTimerQHandleTable = 
            MGM_ALLOC( TIMER_TABLE_SIZE * sizeof( HANDLE ) );

        if ( ig.phTimerQHandleTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "MgmInitialize : Failed to allocate timer table : %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ZeroMemory(
            ig.phTimerQHandleTable, TIMER_TABLE_SIZE * sizeof( HANDLE )
            );


        for ( dwIndex = 0; dwIndex < TIMER_TABLE_SIZE; dwIndex++ )
        {
            nsStatus = RtlCreateTimerQueue( &ig.phTimerQHandleTable[ dwIndex ] );

            if ( !NT_SUCCESS( nsStatus ) )
            {
                dwErr = ERROR_NO_SYSTEM_RESOURCES;

                break;
            }
        }

        if ( !NT_SUCCESS( nsStatus ) )
        {
            break;
        }
        

        //
        // create activity count semaphore
        //

        ig.lActivityCount = 0;

        ig.hActivitySemaphore = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL );

        if ( ig.hActivitySemaphore == NULL )
        {
            dwErr = GetLastError();

            TRACE1(
                ANY, 
                "MgmInitialize : Failed to create activity count semaphore : %x",
                dwErr
                );

            LOGERR0( CREATE_SEMAPHORE_FAILED, dwErr );

            break;
        }


        //
        // Register with RTMv2 as a client
        //

        dwErr = RtmRegisterEntity(
                    &g_reiRtmEntity, NULL, RtmChangeNotificationCallback,
                    TRUE, &g_rrpRtmProfile, &g_hRtmHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "MgmInitialize : Failed to register with Rtm : %x",
                dwErr
                );

            LOGERR0( RTM_REGISTER_FAILED, dwErr );

            break;
        }

        
        //
        // Register for marked change notification only
        //

        dwErr = RtmRegisterForChangeNotification(
                    g_hRtmHandle, RTM_VIEW_MASK_MCAST,
                    RTM_CHANGE_TYPE_BEST | RTM_NOTIFY_ONLY_MARKED_DESTS, 
                    NULL, &g_hNotificationHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "MgmInitialize : Failed to register with Rtm for change"
                "notification : %x", dwErr
                );

            LOGERR0( RTM_REGISTER_FAILED, dwErr );

            break;
        }

        //
        // set up callbacks into MGM for the router manager.
        //
        
        pmcCallbacks-> pfnMfeDeleteIndication   = DeleteFromForwarder;

        pmcCallbacks-> pfnNewPacketIndication   = MgmNewPacketReceived;

        pmcCallbacks-> pfnWrongIfIndication     = WrongIfFromForwarder;
        
        pmcCallbacks-> pfnBlockGroups           = MgmBlockGroups;

        pmcCallbacks-> pfnUnBlockGroups         = MgmUnBlockGroups;



        //
        // set the status to running.  All future API calls depend on this
        //
        
        ig.imscStatus = IPMGM_STATUS_RUNNING;


        
        
    } while ( FALSE );    


    LEAVE_GLOBAL_SECTION();


    //
    // in case of error, cleanup all resources allocated
    //
    
    TRACE1( ENTER, "LEAVING MgmInitialize : %x\n", dwErr );

    if ( dwErr != NO_ERROR )
    {
        MgmDeInitialize();
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmDeInitialize
//
//
//----------------------------------------------------------------------------

DWORD
MgmDeInitialize(
)
{
    DWORD                       dwErr, dwInd;
    

    TRACE0( ENTER, "ENTERED MgmDeInitialize" );


    do
    {
        //--------------------------------------------------------------------
        // Terminate all activity
        //--------------------------------------------------------------------

        dwErr = StopMgm();

        if ( dwErr != NO_ERROR )
        {
            break;
        }

    
        //--------------------------------------------------------------------
        // Free all resources
        //--------------------------------------------------------------------
    

        //
        // de-register from RTM
        //

        dwErr = RtmDeregisterFromChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( 
                ANY, "Failed to de-register change notification : %x", 
                dwErr
                );
        }
        
        dwErr = RtmDeregisterEntity( g_hRtmHandle );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to de-register from RTM: %x", dwErr );
        }

        
        //
        // delete activity semaphore
        //

        if ( ig.hActivitySemaphore != NULL )
        {
            CloseHandle( ig.hActivitySemaphore );
            ig.hActivitySemaphore  = NULL;
        }

        
        //
        // delete group lists
        //

        for ( dwInd = 0; dwInd < GROUP_TABLE_SIZE; dwInd++ )
        {
            DELETE_LOCKED_LIST( &ig.pmllGrpHashTable[ dwInd ] );
        }

        MGM_FREE( ig.pmllGrpHashTable );

        DELETE_LOCKED_LIST( &ig.mllGrpList );
        
        
        //
        // delete interface lists
        //

        for ( dwInd = 0; dwInd < IF_TABLE_SIZE; dwInd++ )
        {
            DELETE_LOCKED_LIST( &ig.pmllIfHashTable[ dwInd ] );
        }

        MGM_FREE( ig.pmllIfHashTable );


        //
        // delete protocol list
        //

        DELETE_LOCKED_LIST( &ig.mllProtocolList );
        
        //
        // free timer resources
        //

        NtClose( ig.hRouteCheckTimer );

        for ( dwInd = 0; dwInd < TIMER_TABLE_SIZE; dwInd++ )
        {
            RtlDeleteTimerQueue( ig.phTimerQHandleTable[ dwInd ] );
        }


        TRACE1( ENTER, "LEAVING MgmDeInitialize %x\n", dwErr );

        //
        // trace deregister
        //
                
        RouterLogDeregister( ig.hLogHandle );

        TRACESTOP();

        ig.imscStatus = IPMGM_STATUS_STOPPED;
        
    } while ( FALSE );
    

    return dwErr;
}



//----------------------------------------------------------------------------
// StopMgm
//
// This function waits for all the therads that are currently executing in
// MGM to finish.  In addition the status of MGM is marked as stopping which
// prevents the further threads from executing MGM API.
//----------------------------------------------------------------------------

DWORD
StopMgm(
)
{
    LONG    lThreadCount = 0;

    
    TRACE0( STOP, "ENTERED StopMgm" );
    

    //
    // Set status of MGM to be stopping
    //
    
    ENTER_GLOBAL_SECTION();

    if ( ig.imscStatus != IPMGM_STATUS_RUNNING )
    {
        LEAVE_GLOBAL_SECTION();

        TRACE0( ANY, "Mgm is not running" );
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    ig.imscStatus = IPMGM_STATUS_STOPPING;
    
    lThreadCount = ig.lActivityCount;

    LEAVE_GLOBAL_SECTION();



    TRACE1( STOP, "Number of threads in MGM : %x", lThreadCount );
    

    //
    // Wait for all the threads in MGM to terminate.
    //
        
    while ( lThreadCount-- > 0 )
    {
        WaitForSingleObject( ig.hActivitySemaphore, INFINITE );
    }

    
    //
    // Acquire and release global critical section to ensure all
    // threads have finished LEAVE_MGM_API()
    //

    ENTER_GLOBAL_SECTION();
    LEAVE_GLOBAL_SECTION();

    TRACE0( STOP, "LEAVING StopMgm" );

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// MgmRegisterMProtocol
//
// This function is invoked by a routing protocol to obtain a handle.  This
// handle must be supplied to all subsequent MGM operations.  When invoked 
// this function creates an entry in the list of clients.
//----------------------------------------------------------------------------

DWORD
MgmRegisterMProtocol( 
    IN          PROUTING_PROTOCOL_CONFIG    prpcInfo, 
    IN          DWORD                       dwProtocolId,
    IN          DWORD                       dwComponentId,
    OUT         HANDLE *                    phProtocol
)
{

    DWORD                       dwErr = NO_ERROR;

    PPROTOCOL_ENTRY             ppeEntry = NULL;

    
    //
    // increment count of clients executing MGM apis
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmRegisterMProtocol %x, %x", 
        dwProtocolId, dwComponentId 
        );


    //
    // Lock Protocol list
    //
    
    ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE();
        

    do
    {
        //
        // check if the protocol already exists.
        //

        ppeEntry = GetProtocolEntry( 
                    &ig.mllProtocolList.leHead, dwProtocolId, dwComponentId 
                    );

        if ( ppeEntry != NULL )
        {
            //
            // valid entry is present. quit with error
            //

            TRACE2( 
                ANY, "Entry already present for protocol : %x, %x", 
                dwProtocolId, dwComponentId
                );

            LOGERR0( PROTOCOL_ALREADY_PRESENT, dwProtocolId );

            dwErr = ERROR_ALREADY_EXISTS;
                
            break;
        }


        //
        // create new protocol entry
        //

        dwErr = CreateProtocolEntry( 
                    &ig.mllProtocolList.leHead, 
                    dwProtocolId, dwComponentId, prpcInfo, &ppeEntry 
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1(
                ANY, "Failed to create protocol entry %x", dwErr
                );

            LOGERR0( CREATE_PROTOCOL_FAILED, dwErr );

            break;
        }

        ig.dwNumProtocols++;
        

        //
        // return handle to client
        //
        
        *phProtocol = (HANDLE) ( ( (ULONG_PTR) ppeEntry ) 
                                        ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    RELEASE_PROTOCOL_LOCK_EXCLUSIVE();

    LEAVE_MGM_API();

    TRACE1( ENTER, "LEAVING MgmRegisterMProtocol : %x\n", dwErr );
    

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmRegisterMProtocol
//
// This function is invoked by a routing protocol to obtain a handle.  This
// handle must be supplied to all subsequent MGM operations.  When invoked 
// this function creates an entry in the list of clients.
//----------------------------------------------------------------------------

DWORD
MgmDeRegisterMProtocol( 
    IN          HANDLE                      hProtocol
)
{
    DWORD                       dwErr = NO_ERROR;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    
    //
    // increment count of clients executing MGM apis
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmDeRegisterMProtocol" );


    //
    // Acquire write lock
    //

    ACQUIRE_PROTOCOL_LOCK_EXCLUSIVE();

    
    do
    {
        //
        // retrieve entry from handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

        
        //
        // Verify that the protocol entry does not own any interfaces 
        //
        
        if ( ppeEntry-> dwIfCount != 0 )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "%x interfaces present for this protocol", dwErr );

            LOGERR0( INTERFACES_PRESENT, dwErr );

            break;
        }

        
        //
        // No interfaces for this protocol
        //

        DeleteProtocolEntry( ppeEntry );

        ig.dwNumProtocols--;
        
        dwErr = NO_ERROR;
        

    } while ( FALSE );
    

    RELEASE_PROTOCOL_LOCK_EXCLUSIVE();

    TRACE1( ENTER, "LEAVING MgmDeRegisterMProtocol %x\n", dwErr );

    LEAVE_MGM_API();
    
    return dwErr;
}



//============================================================================
// Interface ownership API
//
//============================================================================

//----------------------------------------------------------------------------
// MgmTakeInterfaceOwnership
//
// This function is invoked by a routing protocol when it is enabled on an 
// interface.  This function creates an entry for the specified interface
// and inserts it into the appropriate interface hash bucket.
//
// Only one protocol can take ownership of an interface at a time.  The 
// only exception to this rule is IGMP.  IGMP can co-exist with another
// routing protocol on an interface.  In this case, the routing protocol
// should take ownership of the interface first.   
//----------------------------------------------------------------------------

DWORD
MgmTakeInterfaceOwnership(
    IN          HANDLE                      hProtocol,
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr
)
{
    BOOL                        bFound = FALSE, bIfLock = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwBucket;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;

    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmTakeInterfaceOwnership : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );
    

    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR)MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        
        TRACEIF2(
            IF, "Protocol id: 0x%x 0x%x",
            ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
            );

        //
        // Retrieve interface entry 
        //

        dwBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwBucket );
        bIfLock = TRUE;
        
        bFound = FindIfEntry( 
                    IF_BUCKET_HEAD( dwBucket ), dwIfIndex, dwIfNextHopAddr, 
                    &pieEntry
                    );

        if ( bFound )
        {
            //
            // interface entry exists 
            //

            if ( IS_PROTOCOL_IGMP( ppeEntry ) )
            {
                //
                // IGMP is being enabled to this interface.
                // Set IGMP present flag on this interface entry.
                //

                SET_ADDED_BY_IGMP( pieEntry );
            }


            //
            // A routing protocol is being enabled to this interface entry.
            //

            //
            // Check if interface is currently owned by IGMP.  In this case
            // alone the routing protocol may be added to an existing (from
            // the MGM point of view) interface.
            //
            // If another routing protocol owns the interface that is
            // an error as per the interop rules for multicast protocols
            // on a border router.  report the error.
            //

            else if ( IS_PROTOCOL_ID_IGMP( pieEntry-> dwOwningProtocol ) )
            {
                //
                // Interface currently owned by IGMP
                //

                dwErr = TransferInterfaceOwnershipToProtocol( 
                            ppeEntry, pieEntry 
                            );
            }
            
            
            else
            {
                //
                // Interface currently owned by another routing protocol.
                // This is an error.
                //
                
                dwErr = ERROR_ALREADY_EXISTS;

                TRACE2( 
                    ANY, 
                    "MgmTakeInterfaceOwnership : Already owned by routing protocol"
                    " : %d, %d", pieEntry-> dwOwningProtocol, 
                    pieEntry-> dwOwningComponent
                    );

                LOGWARN0( IF_ALREADY_PRESENT, dwErr );
            }
            
            break;
        }


        //
        // No interface entry found.  Create a new one.
        //

        if ( pieEntry == NULL )
        {
            //
            // First interface in the hash bucket
            //
            
            dwErr = CreateIfEntry( 
                        &ig.pmllIfHashTable[ dwBucket ].leHead,
                        dwIfIndex, dwIfNextHopAddr,
                        ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
                        );
        }

        else
        {
            dwErr = CreateIfEntry( 
                        &pieEntry-> leIfHashList,
                        dwIfIndex, dwIfNextHopAddr,
                        ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
                        );
        }


    } while ( FALSE );


    //
    // Increment interface count for the specified protocol
    //

    if ( dwErr == NO_ERROR )
    {
        InterlockedIncrement( &ppeEntry-> dwIfCount );
    }

    
    //
    // Release held locks.
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwBucket );
    }

    RELEASE_PROTOCOL_LOCK_SHARED();
    

    TRACE1( ENTER, "LEAVING MgmTakeInterfaceOwnership %x\n", dwErr );

    LEAVE_MGM_API();
    
    return dwErr;
}


//----------------------------------------------------------------------------
// MgmReleaseInterfaceOwnership
//
// This function is invoked by a routing protocol when it is disabled 
// on an interface.  This functions deletes the entry for the specified 
// interface.  Before deleting the interface entry all the 
// fowarding entries created by the protocol that use this interface as
// the incoming interface.  Also remove all group memberships on this 
// interface.
// 
// If IGMP and routing protocol are both enabled on this interface
// IGMP should release this interface first followed by the routing
// protocol.
//
//----------------------------------------------------------------------------

DWORD
MgmReleaseInterfaceOwnership(
    IN          HANDLE                      hProtocol,
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr
)
{
    BOOL                        bFound = FALSE, bIGMP, bIfLock = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwBucket;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL, ppe;

    PIF_ENTRY                   pieEntry = NULL;



    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2( 
        ENTER, "ENTERED MgmReleaseInterfaceOwnership : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    do
    {
        //
        // 1. parameter validation
        //
        
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        TRACEIF2(
            IF, "Protocol id: 0x%x 0x%x",
            ppeEntry-> dwProtocolId, ppeEntry-> dwComponentId
            );
            
        //
        // Retrieve interface entry 
        //

        dwBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            //
            // no interface entry
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
            
            TRACE2( 
                ANY, "Interface entry %d, %x not found ", 
                dwIfIndex, dwIfNextHopAddr 
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );
            
            break;
        }


        //
        // Interface entry present.  Make sure it is owned by the protocol 
        // that is releasing it.
        //

        if ( IS_PROTOCOL_IGMP( ppeEntry ) && !IS_ADDED_BY_IGMP( pieEntry ) )
        {
            //
            // trying to delete IGMP on an interface that 
            // it is not present on.
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
        
            TRACE2( 
                ANY, "IGMP not running on interface %x, %x", 
                pieEntry-> dwIfIndex, pieEntry-> dwIfNextHopAddr
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );
        
            break;
        }


        if ( IS_ROUTING_PROTOCOL( ppeEntry ) &&
             ( ( ppeEntry-> dwProtocolId != pieEntry-> dwOwningProtocol ) ||
               ( ppeEntry-> dwComponentId != pieEntry-> dwOwningComponent ) ) )
        {
            //
            // interface entry not owned by routing protocol 
            //
            
            dwErr = ERROR_INVALID_PARAMETER;
        
            TRACE2( 
                ANY, "Routing protcol not running on interface %x, %x",
                pieEntry-> dwIfIndex, pieEntry-> dwIfNextHopAddr
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );
        
            break;
        }    


        //
        // 2. Remove protocol state for the interface
        //

        ppe = ppeEntry;
        
        if ( IS_PROTOCOL_IGMP( ppeEntry ) )
        {
            //
            // IGMP is releasing this interface
            //

            CLEAR_ADDED_BY_IGMP( pieEntry );
            
            bIGMP = TRUE;

            if ( !IS_ADDED_BY_PROTOCOL( pieEntry ) )
            {
                //
                // if IGMP is the only protocol on this interface, then delete 
                // any MFEs that use this interface as the incoming interface.
                // (otherwise these MFEs were created by the routing protocol,
                // that co-exists with IGMP on this interface, leave them 
                // alone)
                //

                DeleteInInterfaceRefs( &pieEntry-> leInIfList );
            }

            else
            {
                //
                // Interface is shared by IGMP and Routing Protocol.
                //
                // Group memberships added on an interface shared by IGMP
                // and a routing protocol are owned by the routing protocol (
                // with a bit field indicating whether they have been added by
                // IGMP )
                // 
                // To delete a group membership added by IGMP on a shared
                // interface, lookup the protocol on that interface and use that
                // as the protocol that added the group membership.
                //

                ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );
            }
        }

        else
        {
            //
            // Interface is being deleted by a routing protocol
            //

            if ( IS_ADDED_BY_IGMP( pieEntry ) )
            {
                //
                // IGMP still exists on this interface
                //
                
                dwErr = TransferInterfaceOwnershipToIGMP( ppeEntry, pieEntry );

                break;
            }


            //
            // only routing protocol existed on this interface.
            //
            
            CLEAR_ADDED_BY_PROTOCOL( pieEntry );

            bIGMP = FALSE;

            //
            // delete all mfes that use this interface as the incoming interface
            //
            
            DeleteInInterfaceRefs( &pieEntry-> leInIfList );
        }


        //
        // Walk the list of group/source entries that contain this
        // interface (for this protocol) and delete the references
        // to this interface.  References in this case are nothing but
        // group memberships added on this interface.
        //

        
        DeleteOutInterfaceRefs( ppeEntry, pieEntry, bIGMP );


        //
        // if neither IGMP nor a routing protocol remain on this interface
        // remove this interface entry.
        //

        if ( !IS_ADDED_BY_IGMP( pieEntry ) &&
             !IS_ADDED_BY_PROTOCOL( pieEntry ) )
        {
            if ( !IsListEmpty( &pieEntry-> leOutIfList ) ||
                 !IsListEmpty( &pieEntry-> leInIfList ) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                
                TRACE0( ANY, "References remain for interface" );

                break;
            }
            
            DeleteIfEntry( pieEntry );
        }


    } while ( FALSE );


    //
    // release locks
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwBucket );
    }
    
    //
    // Ensure any callbacks for source specific leaves
    // (caused by the interface being deleted from MGM)
    // are issued.
    // 
    // Bug : 154227
    //
    
    InvokeOutstandingCallbacks();

    
    //
    // decrement count of interfaces owned by protocol
    //

    if ( dwErr == NO_ERROR )
    {
        InterlockedDecrement( &ppe-> dwIfCount );
    }
    

    RELEASE_PROTOCOL_LOCK_SHARED();
    
    TRACE1( ENTER, "LEAVING MgmReleaseInterfaceOwnership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// MgmAddGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmGetProtocolOnInterface(
    IN          DWORD                       dwIfIndex,
    IN          DWORD                       dwIfNextHopAddr,
    IN  OUT     PDWORD                      pdwIfProtocolId,
    IN  OUT     PDWORD                      pdwIfComponentId
)
{

    DWORD       dwErr = NO_ERROR, dwIfBucket;

    PLIST_ENTRY pleIfHead;

    PIF_ENTRY   pie;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE2(
        ENTER, "ENTERED MgmGetProtocolOnInterface : Interface %x, %x",
        dwIfIndex, dwIfNextHopAddr
        );

    
    dwIfBucket  = IF_TABLE_HASH( dwIfIndex );

    pleIfHead   = IF_BUCKET_HEAD( dwIfBucket );

    ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

    
    do
    {
        pie = GetIfEntry( pleIfHead, dwIfIndex, dwIfNextHopAddr );

        if ( pie == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE2( 
                ANY, "No interface entry present for interface %x, %x",
                dwIfIndex, dwIfNextHopAddr
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );

            break;
        }
                

        *pdwIfProtocolId    = pie-> dwOwningProtocol;

        *pdwIfComponentId   = pie-> dwOwningComponent;
        
    } while ( FALSE );


    RELEASE_IF_LOCK_SHARED( dwIfBucket );

    TRACE1(
        ENTER, "LEAVING MgmGetProtocolOnInterface : %x\n", dwErr
        );

    LEAVE_MGM_API();

    return dwErr;
}



//============================================================================
// Group membership manipulation API. (addition / deletion / retreival)
//============================================================================

//----------------------------------------------------------------------------
// MgmAddGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmAddGroupMembershipEntry(
    IN              HANDLE                  hProtocol,
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwSourceMask,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwGroupMask,
    IN              DWORD                   dwIfIndex,
    IN              DWORD                   dwIfNextHopAddr,
    IN              DWORD                   dwFlags
)
{
    BOOL                        bIfLock = FALSE, bgeLock = FALSE,
                                bIGMP = FALSE, bUpdateMfe, bWCFound,
                                bNewComp = FALSE;
    
    DWORD                       dwErr = NO_ERROR, dwIfBucket, 
                                dwGrpBucket, dwSrcBucket, dwInd,
                                dwWCGrpBucket;
    
    WORD                        wSourceAddedBy = 0,
                                wNumAddsByIGMP = 0, wNumAddsByRP = 0;
                                
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;

    PGROUP_ENTRY                pge = NULL, pgeWC = NULL;

    PSOURCE_ENTRY               pse = NULL;

    POUT_IF_ENTRY               poie = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;
    
    LIST_ENTRY                  leSourceList;

    PCREATION_ALERT_CONTEXT     pcac;


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmAddGroupMembershipEntry : Interface %x, %x : "
        "Source : %x, %x : Group : %x, %x", dwIfIndex, dwIfNextHopAddr,
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    //
    // I. Verify input parameters
    //
    
    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Retrieve interface entry 
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE2( 
                ANY, "Specified interface was not found : %d, %d", dwIfIndex,
                dwIfNextHopAddr
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );

            break;
        }

        //
        // Verify interface is owned by protocol making this call,
        // or 
        // if this operation is being perfomed by IGMP, verify IGMP is
        // enabled on this interface (in this case the interface may
        // be owned by another routing protocol)
        //

        if ( ( pieEntry-> dwOwningProtocol != ppeEntry-> dwProtocolId   ||
               pieEntry-> dwOwningComponent != ppeEntry-> dwComponentId )   &&
             ( !IS_PROTOCOL_IGMP( ppeEntry )                            || 
               !IS_ADDED_BY_IGMP( pieEntry ) ) )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE4(
                ANY, "Interface %d, %d is not owned by protocol %d, %d",
                dwIfIndex, dwIfNextHopAddr, ppeEntry-> dwProtocolId,
                ppeEntry-> dwComponentId
                );
                
            LOGERR0( IF_DIFFERENT_OWNER, dwErr );

            break;
        }


        bIGMP = IS_PROTOCOL_IGMP( ppeEntry );

        if ( bIGMP )
        {
            //
            // if this operation has been invoked by IGMP,
            // retrieve the entry for the routing protocol component
            // that owns this interface.
            //
            
            ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );

            if ( ppeEntry == NULL )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;

                TRACE2(
                    ANY, "IGMP join failed because owning protocol entry"
                    " (%x, %x) not found", pieEntry-> dwOwningProtocol,
                    pieEntry-> dwOwningComponent
                    );

                break;
            }
        }

    } while ( FALSE );


    //
    // return, if parameter validation fails
    //
    
    if ( dwErr != NO_ERROR )
    {
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        }

        RELEASE_PROTOCOL_LOCK_SHARED();
        
        TRACE1( ENTER, "LEAVING MgmAddGroupMembership %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }
    

    //
    // for JOIN STATE changes, i.e for group membership additions
    //
    
    if ( dwFlags & MGM_JOIN_STATE_FLAG )
    {
        //
        // Add membership entry
        //

        InitializeListHead( &leSourceList );
        
        dwErr = AddInterfaceToSourceEntry(
                    ppeEntry, dwGroupAddr, dwGroupMask,
                    dwSourceAddr, dwSourceMask, dwIfIndex, 
                    dwIfNextHopAddr, bIGMP, &bUpdateMfe,
                    &leSourceList
                    );

        if ( dwErr == NO_ERROR )
        {
            //
            // Add to an outgoing interface reference for this group
            //

            AddSourceToRefList(
                &pieEntry-> leOutIfList, dwSourceAddr, dwSourceMask, 
                dwGroupAddr, dwGroupMask, bIGMP
                );
        }


        //
        // release locks in prepapation for updating MFEs
        // (invoking creation alerts when updating MFEs requires
        //  all locks to be released)
        //
        //  When locks are re-acquired you need to verify that 
        //  the interface (dwIfIndex, dwIfNextHopAddr) and the
        //  group membership being added is still present.
        //  Any one of those could be deleted in another thread
        //  when the locks are released.
        //
        
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
            bIfLock = FALSE;
        }
        
        //
        // Invoke pended Join/Prune alerts
        //

        InvokeOutstandingCallbacks();
        

        //
        // Update MFEs if required
        //
        
        if ( ( dwErr == NO_ERROR ) && bUpdateMfe )
        {
            //
            // Queue a work item to update the MFEs
            //  Creation alerts have to be invoked from a separate 
            //  thread.  This is done to avoid calling back into the
            //  protocol (from MGM) in the context of an add membership
            //  call from the the protocol (into MGM).  Doing so results
            //  in deadlocks (bug #323388)
            //
            
            pcac = MGM_ALLOC( sizeof( CREATION_ALERT_CONTEXT ) );

            if ( pcac != NULL )
            {
                pcac-> dwSourceAddr = dwSourceAddr;
                pcac-> dwSourceMask = dwSourceMask;

                pcac-> dwGroupAddr  = dwGroupAddr;
                pcac-> dwGroupMask  = dwGroupMask;

                pcac-> dwIfIndex    = dwIfIndex;
                pcac-> dwIfNextHopAddr = dwIfNextHopAddr;

                pcac-> dwProtocolId = ppeEntry-> dwProtocolId;
                pcac-> dwComponentId = ppeEntry-> dwComponentId;

                pcac-> bIGMP        = bIGMP;

                pcac-> leSourceList = leSourceList;

                leSourceList.Flink-> Blink = &(pcac-> leSourceList);
                leSourceList.Blink-> Flink = &(pcac-> leSourceList);

                dwErr = QueueMgmWorker(
                            WorkerFunctionInvokeCreationAlert,
                            (PVOID)pcac
                            );

                if ( dwErr != NO_ERROR )
                {
                    TRACE1(
                        ANY, "Failed to queue "
                        "WorkerFunctionInvokeCreationAlert",
                        dwErr
                        );

                    MGM_FREE( pcac );

                    dwErr = NO_ERROR;
                }
            }

            else
            {
                TRACE1(
                    ANY, "Failed to allocate %d bytes for work item "
                    "context", sizeof( CREATION_ALERT_CONTEXT )
                    );
            }
        }
    }

    //
    // For FORWARD state changes only.
    //
    
    else if ( ( dwFlags & MGM_FORWARD_STATE_FLAG ) &&
              !IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) &&
              !IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // Forward state changes are for MFEs only.
        // No (*, G) or (*, *) entries are updated
        //
        
        do
        {
            //
            // Check for boundaries
            //

            if ( IS_HAS_BOUNDARY_CALLBACK() &&
                 HAS_BOUNDARY_CALLBACK()( dwIfIndex, dwGroupAddr ) )
            {
                TRACE0( ANY, "Boundary present of group on interface" );

                break;
            }
            

            //
            // Check for (*, *) membership 
            //

            bWCFound = FindRefEntry(
                        &pieEntry-> leOutIfList, 
                        WILDCARD_SOURCE, WILDCARD_SOURCE_MASK,
                        WILDCARD_GROUP, WILDCARD_GROUP_MASK,
                        &pire
                        );

            if ( bWCFound )
            {
                //
                // (*, *) entry present,
                // get counts for (*, *) membership on interface
                //

                dwWCGrpBucket = GROUP_TABLE_HASH( 
                                    WILDCARD_GROUP, WILDCARD_GROUP_MASK
                                    );
                                    
                ACQUIRE_GROUP_LOCK_SHARED( dwWCGrpBucket );

                pgeWC = GetGroupEntry(
                            GROUP_BUCKET_HEAD( dwWCGrpBucket ),
                            WILDCARD_GROUP, WILDCARD_GROUP_MASK
                            );

                if ( pgeWC != NULL )
                {
                    ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    
                    dwSrcBucket = SOURCE_TABLE_HASH(
                                    WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                                    );

                    pse = GetSourceEntry(
                            SOURCE_BUCKET_HEAD( pgeWC, dwSrcBucket ),
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

                    if ( pse != NULL )
                    {
                        poie = GetOutInterfaceEntry(
                                    &pse-> leOutIfList,
                                    dwIfIndex, dwIfNextHopAddr,
                                    ppeEntry-> dwProtocolId,
                                    ppeEntry-> dwComponentId
                                    );

                        if ( poie != NULL )
                        {
                            wSourceAddedBy |= poie-> wAddedByFlag;
                            wNumAddsByRP = poie-> wNumAddsByRP;
                        }
                    }
                }
            }
            
            //
            // Check for (*, G) membership 
            //

            dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                                
            ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

            pge = GetGroupEntry(
                        GROUP_BUCKET_HEAD( dwGrpBucket), 
                        dwGroupAddr, dwGroupMask
                        );

            if ( pge != NULL )
            {
                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                
                dwSrcBucket = SOURCE_TABLE_HASH(
                                WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                                );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                        );

                if ( pse != NULL )
                {
                    //
                    // get counts for interface
                    // if (*, G) is present on the interface
                    //
                    
                    poie = GetOutInterfaceEntry(
                                &pse-> leOutIfList,
                                dwIfIndex, dwIfNextHopAddr,
                                ppeEntry-> dwProtocolId,
                                ppeEntry-> dwComponentId
                                );

                    if ( poie != NULL )
                    {
                        wSourceAddedBy |= poie-> wAddedByFlag;
                        wNumAddsByIGMP = poie-> wNumAddsByIGMP;
                        wNumAddsByRP += poie-> wNumAddsByRP;
                    }
                }


                //
                // Get (S, G) entry
                //
                
                dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        dwSourceAddr, dwSourceMask
                        );

                if ( pse != NULL )
                {
                    poie = GetOutInterfaceEntry(
                                &pse-> leOutIfList,
                                dwIfIndex, dwIfNextHopAddr,
                                ppeEntry-> dwProtocolId,
                                ppeEntry-> dwComponentId
                                );

                    if ( poie != NULL )
                    {
                        //
                        // Get counts for (S, G) membership if
                        // present on interface
                        //
                        
                        wSourceAddedBy |= poie-> wAddedByFlag;
                        wNumAddsByIGMP += poie-> wNumAddsByIGMP;
                        wNumAddsByRP += poie-> wNumAddsByRP;
                    }

                    //
                    // Add interface to MFE OIF list if any
                    // membership
                    //
                    
                    if ( wSourceAddedBy )
                    {
                        AddInterfaceToSourceMfe(
                            pge, pse, dwIfIndex, dwIfNextHopAddr,
                            ppeEntry-> dwProtocolId,
                            ppeEntry-> dwComponentId,
                            IS_PROTOCOL_IGMP( ppeEntry ),
                            &poie
                            );
                    
                        poie-> wAddedByFlag |= wSourceAddedBy;
                        poie-> wNumAddsByIGMP = wNumAddsByIGMP;
                        poie-> wNumAddsByRP = wNumAddsByRP;

                    }

                    else
                    {
                        TRACE0(
                            ANY, "Forward state not updated as no"
                            " memberships present on interface"
                            );
                    }
                }
                
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            }

            RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );

            if ( bWCFound )
            {
                if ( pgeWC )
                {
                    RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                }

                RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
            }

        } while ( FALSE );
    }

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    TRACE1( ENTER, "LEAVING MgmAddGroupMembership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;

}



//----------------------------------------------------------------------------
// MgmDeleteGroupMembershipEntry
//
// 
//----------------------------------------------------------------------------

DWORD
MgmDeleteGroupMembershipEntry(
    IN              HANDLE                  hProtocol,
    IN              DWORD                   dwSourceAddr,
    IN              DWORD                   dwSourceMask,
    IN              DWORD                   dwGroupAddr,
    IN              DWORD                   dwGroupMask,
    IN              DWORD                   dwIfIndex,
    IN              DWORD                   dwIfNextHopAddr,
    IN              DWORD                   dwFlags
)
{
    BOOL                        bIfLock = FALSE, bIGMP;
    
    DWORD                       dwErr = NO_ERROR, dwIfBucket,
                                dwGrpBucket, dwSrcBucket;
    
    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;
    
    PPROTOCOL_ENTRY             ppeEntry = NULL;

    PIF_ENTRY                   pieEntry = NULL;



    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmDeleteGroupMembership : Interface %x, %x : "
        "Source : %x, %x : Group : %x, %x", dwIfIndex, dwIfNextHopAddr,
        dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask
        );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    //
    // Verify input parameters.
    //
    
    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Retrieve interface entry 
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, dwIfNextHopAddr
                        );

        if ( pieEntry == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE0( ANY, "Specified interface was not found" );

            break;
        }

        //
        // Verify interface is owned by protocol making this call.
        // or
        // if IGMP has invoked this api, verify that IGMP is present
        // on this interface.
        //

        if ( ( pieEntry-> dwOwningProtocol != ppeEntry-> dwProtocolId   ||
               pieEntry-> dwOwningComponent != ppeEntry-> dwComponentId )   &&
             ( !IS_PROTOCOL_IGMP( ppeEntry )                            || 
               !IS_ADDED_BY_IGMP( pieEntry ) ) )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE4(
                ANY, "Interface %x, %x is not owned by %x, %x",
                dwIfIndex, dwIfNextHopAddr, ppeEntry-> dwProtocolId,
                ppeEntry-> dwComponentId
                );
                
            LOGERR0( IF_DIFFERENT_OWNER, dwErr );

            break;
        }


        //
        // in case this operation is being performed by IGMP
        // get the routing protocol that co-exists with IGMP
        // on this interface
        //
        
        bIGMP = IS_PROTOCOL_IGMP( ppeEntry );

        if ( bIGMP )
        {
            //
            // if this operation has been invoked by IGMP,
            // retrieve the entry for the routing protocol component
            // that owns this interface.
            //
            
            ppeEntry = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pieEntry-> dwOwningProtocol,
                            pieEntry-> dwOwningComponent
                            );

            if ( ppeEntry == NULL )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;

                TRACE2(
                    ANY, "IGMP join failed because owning protocol entry"
                    " (%x, %x) not found", pieEntry-> dwOwningProtocol,
                    pieEntry-> dwOwningComponent
                    );

                break;
            }
        }
        
    } while ( FALSE );


    //
    // in case of error, release locks and return
    //
    
    if ( dwErr != NO_ERROR )
    {
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
        }
        
        RELEASE_PROTOCOL_LOCK_SHARED();
        
        TRACE1( ENTER, "LEAVING MgmDeleteGroupMembership %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }


    //
    // For JOIN state change
    //
    
    if ( dwFlags & MGM_JOIN_STATE_FLAG )
    {
        //
        // delete interface from source entry
        //

        DeleteInterfaceFromSourceEntry(
            ppeEntry, dwGroupAddr, dwGroupMask, 
            dwSourceAddr, dwSourceMask,
            dwIfIndex, dwIfNextHopAddr, bIGMP
            );


        //
        // delete reference entry
        //

        DeleteSourceFromRefList(
            &pieEntry-> leOutIfList, dwSourceAddr, dwSourceMask,
            dwGroupAddr, dwGroupMask, bIGMP
            );

        //
        // release locks
        //
        
        if ( bIfLock )
        {
            RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
            bIfLock = FALSE;
        }
        
        //
        // Invoke pended Join/Prune alerts
        //

        InvokeOutstandingCallbacks();

    }


    //
    // For FORWARD state changes
    //
    
    else if ( ( dwFlags & MGM_FORWARD_STATE_FLAG ) &&
              !IS_WILDCARD_GROUP( dwGroupAddr, dwGroupMask ) &&
              !IS_WILDCARD_SOURCE( dwSourceAddr, dwSourceMask ) )
    {
        //
        // FORWARD state changes are for MFEs only.
        // No (*, *) or (*, G) entries are updated
        //
        
        //
        // Find the (S, G) entry and delete the group membership
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                            
        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pge = GetGroupEntry(
                    GROUP_BUCKET_HEAD( dwGrpBucket ), 
                    dwGroupAddr, dwGroupMask
                    );

        if ( pge != NULL )
        {
            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

            pse = GetSourceEntry(
                    SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                    dwSourceAddr, dwSourceMask
                    );

            if ( pse != NULL )
            {
                DeleteInterfaceFromSourceMfe(
                    pge, pse, dwIfIndex, dwIfNextHopAddr,
                    ppeEntry-> dwProtocolId,
                    ppeEntry-> dwComponentId, bIGMP, TRUE
                    );
            }

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }
    

    //
    // release locks
    //
    
    if ( bIfLock )
    {
        RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();
    
    TRACE1( ENTER, "LEAVING MgmDeleteGroupMembership %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Update API.
//
//----------------------------------------------------------------------------

DWORD
MgmSetMfe(
    IN              HANDLE                  hProtocol,
    IN              PMIB_IPMCAST_MFE        pmimm
)
{
    BOOL                bGrpLock = FALSE, bgeLock = FALSE;
    
    DWORD               dwErr = NO_ERROR, dwGrpBucket, dwSrcBucket;
    
    PPROTOCOL_ENTRY     ppeEntry;

    PGROUP_ENTRY        pge;

    PSOURCE_ENTRY       pse;

    
    //
    // Check if MGM is still running and increment counts
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    
    TRACE2( 
        ENTER, "ENTERED MgmSetMfe : (%lx, %lx)", pmimm-> dwSource,
        pmimm-> dwGroup
        );

        
    ACQUIRE_PROTOCOL_LOCK_SHARED();

 
    do
    {
        //
        // Verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                        ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // Get group bucket and find group entry
        //

        dwGrpBucket = GROUP_TABLE_HASH( pmimm-> dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpLock = TRUE;
        
        pge = GetGroupEntry( 
                GROUP_BUCKET_HEAD( dwGrpBucket ), pmimm-> dwGroup, 0
                );

        if ( pge == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE1( ANY, "Group %lx not found", pmimm-> dwGroup );

            break;
        }


        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        bgeLock = TRUE;

        
        //
        // Find source with group entry
        //

        dwSrcBucket = SOURCE_TABLE_HASH( 
                        pmimm-> dwSource, pmimm-> dwSrcMask 
                        );

        pse = GetSourceEntry( 
                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ), pmimm-> dwSource,
                pmimm-> dwSrcMask
                );

        if ( pse == NULL )
        {
            dwErr = ERROR_NOT_FOUND;

            TRACE1( ANY, "Source %lx not found", pmimm-> dwSource );

            break;
        }

                    
        //
        // Update the source entry
        //

        pse-> dwUpstreamNeighbor = pmimm-> dwUpStrmNgbr;

    } while ( FALSE );


    if ( bgeLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    
    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    LEAVE_MGM_API();
    
    return dwErr;    
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetMfe(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer
)
{
    DWORD           dwErr;
    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetMfe", *pdwBufferSize );


    dwErr = GetMfe( pmimm, pdwBufferSize, pbBuffer, 0 );

    
    TRACE1( ENTER, "LEAVING MgmGetMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------


DWORD
MgmGetFirstMfe(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{
    DWORD           dwErr;
    
    MIB_IPMCAST_MFE mimm;
    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetFirstMfe", *pdwBufferSize );


    mimm.dwGroup     = 0;
    mimm.dwSource    = 0;
    mimm.dwSrcMask   = 0;

    dwErr = GetNextMfe( 
                &mimm, pdwBufferSize, pbBuffer, pdwNumEntries, 
                TRUE, 0
                );


    TRACE1( ENTER, "LEAVING MgmGetFirstMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetNextMfe(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{

    DWORD           dwErr;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetNextMfe", *pdwBufferSize );


    dwErr = GetNextMfe( 
                pmimmStart, pdwBufferSize, pbBuffer, pdwNumEntries, 
                FALSE, 0
                );


    TRACE1( ENTER, "LEAVING MgmGetNextMfe %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetMfeStats(
    IN              PMIB_IPMCAST_MFE        pmimm,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN              DWORD                   dwFlags
)
{
    DWORD           dwErr;
    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetMfeStats", *pdwBufferSize );


    dwErr = GetMfe( pmimm, pdwBufferSize, pbBuffer, dwFlags );

    
    TRACE1( ENTER, "LEAVING MgmGetMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------


DWORD
MgmGetFirstMfeStats(
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              DWORD                   dwFlags
)
{
    DWORD           dwErr;
    
    MIB_IPMCAST_MFE mimm;
    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetFirstMfeStats", *pdwBufferSize );


    mimm.dwGroup     = 0;
    mimm.dwSource    = 0;
    mimm.dwSrcMask   = 0;

    dwErr = GetNextMfe( 
                &mimm, pdwBufferSize, pbBuffer, pdwNumEntries, 
                TRUE, dwFlags
                );


    TRACE1( ENTER, "LEAVING MgmGetFirstMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}


//----------------------------------------------------------------------------
// Mgm MFE Statistics enumeration API.
//
//----------------------------------------------------------------------------

DWORD
MgmGetNextMfeStats(
    IN              PMIB_IPMCAST_MFE        pmimmStart,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries,
    IN              DWORD                   dwFlags
)
{

    DWORD           dwErr;


    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE1( ENTER, "ENTERED MgmGetNextMfeStats", *pdwBufferSize );


    dwErr = GetNextMfe( 
                pmimmStart, pdwBufferSize, pbBuffer, pdwNumEntries, 
                FALSE, dwFlags
                );


    TRACE1( ENTER, "LEAVING MgmGetNextMfeStats %x\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Group menbership entry enumeration API
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// MgmGroupEnumerationStart
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationStart(
    IN              HANDLE                  hProtocol,
    IN              MGM_ENUM_TYPES          metEnumType,
    OUT             HANDLE *                phEnumHandle
)
{
    DWORD               dwErr = NO_ERROR;

    PPROTOCOL_ENTRY     ppeEntry;

    PGROUP_ENUMERATOR   pgeEnum;

    


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationStart" );

    ACQUIRE_PROTOCOL_LOCK_SHARED();


    do
    {
        //
        // verify protocol handle
        //

        ppeEntry = (PPROTOCOL_ENTRY) 
                        ( ( (ULONG_PTR) hProtocol ) 
                                    ^ (ULONG_PTR) MGM_CLIENT_HANDLE_TAG );

        dwErr = VerifyProtocolHandle( ppeEntry );

        if ( dwErr != NO_ERROR )
        {
            break;
        }
        

        //
        // create an enumerator.
        //

        pgeEnum = MGM_ALLOC( sizeof( GROUP_ENUMERATOR ) );

        if ( pgeEnum == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "Failed to allocate group enumerator of size : %d", 
                sizeof( GROUP_ENUMERATOR )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        
        ZeroMemory( pgeEnum, sizeof( GROUP_ENUMERATOR ) );

        pgeEnum-> dwSignature = MGM_ENUM_SIGNATURE;

        
        //
        // return handle to the enumerator.
        //

        *phEnumHandle = (HANDLE) ( ( (ULONG_PTR) pgeEnum ) 
                                        ^ (ULONG_PTR) MGM_ENUM_HANDLE_TAG );

    } while ( FALSE );


    RELEASE_PROTOCOL_LOCK_SHARED();

    TRACE1( ENTER, "LEAVING MgmGroupEnumerationStart\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// MgmGroupEnumerationGetNext
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationGetNext(
    IN              HANDLE                  hEnum,
    IN  OUT         PDWORD                  pdwBufferSize,
    IN  OUT         PBYTE                   pbBuffer,
    IN  OUT         PDWORD                  pdwNumEntries
)
{

    DWORD               dwErr;

    PGROUP_ENUMERATOR   pgeEnum;

    

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationGetNext" );


    do
    {
        //
        // verify enumeration handle
        //

        pgeEnum = VerifyEnumeratorHandle( hEnum );

        if ( pgeEnum == NULL )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }


        //
        // verify buffer has space for atleast one entry.
        // Otherwise return error and note size required for
        // atleast one entry.
        //

        if ( *pdwBufferSize < sizeof( SOURCE_GROUP_ENTRY ) )
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;

            TRACE1( ANY, "Insufficient buffer size", dwErr );

            *pdwBufferSize = sizeof( SOURCE_GROUP_ENTRY );

            break;
        }


        *pdwNumEntries = 0;
        
        dwErr = GetNextGroupMemberships( 
                    pgeEnum, pdwBufferSize, pbBuffer, pdwNumEntries
                    );
        
        //
        // This comment is to be moved, ignore it.
        //
        
        // If this is the first enumeration call (i.e this is
        // the beginning of the enumeration) then include the 
        // (S, G) == (0, 0) entry if present.  
        //
        // Usually this call would start with the (source, group)
        // entry following the one mentioned in dwLastSource and 
        // dwLastGroup.  This would result in the skipping of the
        // entry at (0, 0) since the (dwLastSource, dwLastGroup) are
        // initialized to (0, 0).  To overcome this a special flag
        // field is used to note the beginning of the enumeration.
        //
        
        //
        // Check if this is the first enumeration call.
        // If so include the (S, G) == (0, 0) entry.
        //
    } while ( FALSE );
    
    TRACE0( ENTER, "LEAVING MgmGroupEnumerationGetNext\n" );

    LEAVE_MGM_API();
    
    return dwErr;
}



//----------------------------------------------------------------------------
// MgmGroupEnumerationEnd
//
//
//----------------------------------------------------------------------------

DWORD
MgmGroupEnumerationEnd(
    IN              HANDLE                  hEnum
)
{
    DWORD               dwErr = ERROR_INVALID_PARAMETER;

    PGROUP_ENUMERATOR   pgeEnum;

    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE0( ENTER, "ENTERED MgmGroupEnumerationEnd" );

    pgeEnum = VerifyEnumeratorHandle( hEnum );

    if ( pgeEnum != NULL )
    {
        MGM_FREE( pgeEnum );

        dwErr = NO_ERROR;
    }

    TRACE1( ENTER, "LEAVING MgmGroupEnumerationEnd\n", dwErr );

    LEAVE_MGM_API();

    return dwErr;
}



VOID
DisplayGroupTable(
)
{

#if UNIT_DBG

    DWORD                   dwErr, dwBufSize, dwNumEntries;

    PLIST_ENTRY             pleGrp, pleGrpHead, pleSrc, pleSrcHead,
                            pleIf, pleIfHead;

    PGROUP_ENTRY            pge;

    PSOURCE_ENTRY           pse;

    POUT_IF_ENTRY           poie;

    PBYTE                   pbBuffer = NULL;

    MIB_IPMCAST_MFE         imm;

    PMIB_IPMCAST_MFE_STATS  pimms;
    

    
    //
    // Enumerate the MFEs
    // Since the forwarder is not present, stats are junk.
    // so all mfe enum does is exercise the API and merge
    // the master and temp lists so that the subsequent
    // walks of this list can be done.
    //

    dwBufSize = 1024;
    
    pbBuffer = HeapAlloc( GetProcessHeap(), 0, dwBufSize );
    RtlZeroMemory( pbBuffer, dwBufSize );
    
    dwErr = MgmGetFirstMfe( &dwBufSize, pbBuffer, &dwNumEntries );

    if ( dwErr != NO_ERROR )
    {
        printf( "MgmGetFirstMfe returned error : %d\n", dwErr );
    }


    imm.dwSource = 0;
    imm.dwSrcMask = 0xffffffff;
    imm.dwGroup = 0;
    RtlZeroMemory( pbBuffer, dwBufSize );
    dwNumEntries = 0;
    
    while ( MgmGetNextMfe( &imm, &dwBufSize, pbBuffer, &dwNumEntries )
            == NO_ERROR )
    {
        if ( dwNumEntries == 0 )
        {
            break;
        }
        
        pimms = (PMIB_IPMCAST_MFE_STATS) pbBuffer;

        imm.dwSource    = pimms-> dwSource;
        imm.dwSrcMask   = pimms-> dwSrcMask;
        imm.dwGroup     = pimms-> dwGroup;

        pimms = (PMIB_IPMCAST_MFE_STATS) ( (PBYTE) pimms + 
                    SIZEOF_MIB_MFE_STATS( pimms-> ulNumOutIf ) );
    }

    if ( dwErr != NO_ERROR )
    {
        printf( "MgmGetNextMfe returned error : %d\n", dwErr );
    }


    //
    // since there is no kernel mode forwarder, just walk the master
    // list of group entries and display all the group entries
    //
    
    pleGrpHead = MASTER_GROUP_LIST_HEAD();

    pleGrp = pleGrpHead-> Flink;

    while ( pleGrp != pleGrpHead )
    {
        //
        // display the group entry
        //

        pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );
        
        printf( "\n\n====================================================\n" );
        printf( "Group Addr\t: %x, %x\n", pge-> dwGroupAddr, pge-> dwGroupMask );
        printf( "Num Sources\t: %d\n", pge-> dwSourceCount );
        printf( "====================================================\n\n" );
        

        pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

        pleSrc = pleSrcHead-> Flink;

        while ( pleSrc != pleSrcHead )
        {
            pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );

            printf( "\n-----------------------Source----------------------------------" );
            printf( "\nSource Addr\t: %x, %x\n", pse-> dwSourceAddr, pse-> dwSourceMask );
            
            printf(
                "Route Addr\t: %x, %x\n", pse-> dwRouteNetwork, pse-> dwRouteMask
                );
                
            printf( 
                "Out if component: %d\nOut if count\t: %d\n\n", pse-> dwOutCompCount,
                pse-> dwOutIfCount
                );

            printf( 
                "In coming interface : %d, %x\n", pse-> dwInIfIndex, 
                pse-> dwInIfNextHopAddr
                );
                
            printf( 
                "In Protocol id : %x, %x\n\n", pse-> dwInProtocolId, 
                pse-> dwInComponentId
                );

            //
            // list all outgoing interfaces
            //

            pleIfHead = &pse-> leOutIfList;

            pleIf = pleIfHead-> Flink;

            printf( "\n----------------------Out Interfaces-----------------\n" );
            
            while ( pleIf != pleIfHead )
            {
                poie = CONTAINING_RECORD( pleIf, OUT_IF_ENTRY, leIfList );
                
                printf( 
                    "Out interface\t: %d, %x\n", poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr
                    );
                    
                printf( 
                    "Out Protocol id\t: %x, %x\n", poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

                printf(
                    "Added by\t: %x\n", poie-> wAddedByFlag
                    );

                printf(
                    "Num adds (IGMP, RP)\t: (%d, %d)\n\n", poie-> wNumAddsByIGMP,
                    poie-> wNumAddsByRP
                    );

                pleIf = pleIf-> Flink;

            }
            
            
            //
            // list mfe oil
            //

            pleIfHead = &pse-> leMfeIfList;

            pleIf = pleIfHead-> Flink;

            printf( "\n------------------Mfe Out Interfaces-----------------\n" );
            
            while ( pleIf != pleIfHead )
            {
                poie = CONTAINING_RECORD( pleIf, OUT_IF_ENTRY, leIfList );
                
                printf( 
                    "Out interface\t: %d, %x\n", poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr
                    );
                    
                printf( 
                    "Out Protocol id\t: %x, %x\n", poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

                printf(
                    "Added by\t:%x\n", poie-> wAddedByFlag
                    );

                printf(
                    "Num adds (IGMP, RP)\t: (%d, %d)\n\n", poie-> wNumAddsByIGMP,
                    poie-> wNumAddsByRP
                    );

                pleIf = pleIf-> Flink;
            }

            pleSrc = pleSrc-> Flink;
        }

        pleGrp = pleGrp-> Flink;
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\log.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    log.h
//
// History:
//  V Raman Aug-18-1997     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in IPMGM's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define IPMGMLOG_BASE                           50000

#define IPMGMLOG_INIT_CRITSEC_FAILED            (IPMGMLOG_BASE + 1)
/*
 * IPMGM was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPMGMLOG_HEAP_CREATE_FAILED             (IPMGMLOG_BASE + 2)
/*
 * IPMGM was unable to create a heap.
 * The data is the error code.
 */

#define IPMGMLOG_HEAP_ALLOC_FAILED              (IPMGMLOG_BASE + 3)
/*
 * IPMGM was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPMGMLOG_IPMGM_ALREADY_STARTED          (IPMGMLOG_BASE + 4)
/*
 * IPMGM received a start request when it was already running.
 */

#define IPMGMLOG_CREATE_RWL_FAILED              (IPMGMLOG_BASE + 5)
/*
 * IPMGM was unable to create a synchronization object.
 * The data is the error code.
 */

#define IPMGMLOG_CREATE_EVENT_FAILED            (IPMGMLOG_BASE + 6)
/*
 * IPMGM was unable to create an event.
 * The data is the error code.
 */

#define IPMGMLOG_CREATE_SEMAPHORE_FAILED        (IPMGMLOG_BASE + 7)
/*
 * IPMGM was unable to create a semaphore.
 * The data is the error code.
 */

#define IPMGMLOG_IPMGM_STARTED                  (IPMGMLOG_BASE + 8)
/*
 * IPMGM has started successfully.
 */

#define IPMGMLOG_QUEUE_WORKER_FAILED            (IPMGMLOG_BASE + 9)
/*
 * IPMGM could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPMGMLOG_PROTOCOL_NOT_FOUND             (IPMGMLOG_BASE + 10)
/*
 * IPMGM could not find the protocol component (%1, %2)
 */

#define IPMGMLOG_PROTOCOL_ALREADY_PRESENT       (IPMGMLOG_BASE + 11)
/*
 * Protocol component has already registered with IPMGM 
 */

#define IPMGMLOG_CREATE_PROTOCOL_FAILED         (IPMGMLOG_BASE + 12)
/*
 * IPMGM failed to register the protocol component.
 * The data is in the error code.
 */

#define IPMGMLOG_INTERFACES_PRESENT             (IPMGMLOG_BASE + 13)
/*
 * The protocol component that is attempting to deregister is currently
 * enabled on one or more interfaces.   
 */

#define IPMGMLOG_IF_ALREADY_PRESENT             (IPMGMLOG_BASE + 14)
/*
 * This protocol component has already been enabled on this interface 
 */

#define IPMGMLOG_IF_NOT_FOUND                   (IPMGMLOG_BASE + 15)
/*
 * Specified interface was not present in MGM. 
 */

#define IPMGMLOG_IF_DIFFERENT_OWNER             (IPMGMLOG_BASE + 16)
/*
 * Another routing protocol component has already been enabled on
 * this interface.  Only one routing protocol component may be 
 * enabled on an interface at any time.
 */

#define IPMGMLOG_IF_IGMP_NOT_PRESENT            (IPMGMLOG_BASE + 17)
/*
 * IGMP is not enabled on this interface 
 */

#define IPMGMLOG_IF_PROTOCOL_NOT_PRESENT        (IPMGMLOG_BASE + 18)
/*
 * No routing protocol has been enabled on this interface 
 */

#define IPMGMLOG_INVALID_PROTOCOL_HANDLE        (IPMGMLOG_BASE + 19)
/*
 * The handle specified by the protocol component is not valid. This
 * maybe because the protocol component is not registered with IPMGM
 */

#define IPMGMLOG_IF_IGMP_PRESENT                (IPMGMLOG_BASE + 20)
/*
 * Interface cannot be deleted because IGMP is still active on 
 * this interface. 
 */

#define IPMGMLOG_INVALID_TIMER_HANDLE           (IPMGMLOG_BASE + 21)
/*
 * Failed to set timer for forwarding entry.  
 * The error code is in the data.
 */

#define IPMGMLOG_RTM_REGISTER_FAILED            (IPMGMLOG_BASE + 22)
/*
 * Failed to register with RTM.
 * The error code is in the data.
 */

#define IPMGMLOG_IPMGM_STOPPED                  (IPMGMLOG_BASE + 99)
/*
 * IPMGM has stopped.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\packet.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: packet.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// New packet processing.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
);

DWORD
InvokeRPFCallbacks(
    PPROTOCOL_ENTRY *           pppe,
    PIF_ENTRY *                 ppieInIf,
    PDWORD                      pdwIfBucket,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PDWORD                      pdwInIfIndex,
    PDWORD                      pdwInIfNextHopAddr,
    PDWORD                      pdwUpstreamNbr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr,
    PHANDLE                     phNextHop,
    PBYTE                       pbBuffer
);


VOID
CopyAndMergeIfLists(
    PLIST_ENTRY                 pleMfeOutIfList,
    PLIST_ENTRY                 pleOutIfList
);


VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
);


VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
);

VOID
InvokeCreationAlert(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    PLIST_ENTRY                 pleMfeOutIfList,
    PDWORD                      pdwMfeOutIfCount
);

BOOL
IsListSame(
    IN          PLIST_ENTRY             pleHead1,
    IN          PLIST_ENTRY             pleHead2
);

VOID
FreeList (
    IN          PLIST_ENTRY             pleHead
);


//----------------------------------------------------------------------------
// MgmNewPacketReceived
//
//----------------------------------------------------------------------------

DWORD
MgmNewPacketReceived(
    DWORD                       dwSourceAddr,
    DWORD                       dwGroupAddr,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr
)
{

    BOOL                        bGrpEntryLock = FALSE,
                                bGrpLock = FALSE,
                                bWCGrpEntryLock = FALSE,
                                bWCGrpLock = FALSE,

                                bGrpFound = FALSE,
                                bSrcFound = FALSE,

                                bIfLock = FALSE;

                                
    DWORD                       dwErr = NO_ERROR,
                                dwIfBucket, 
                                dwUpStreamNbr = 0,
                                dwGroupMask = 0, dwGrpBucket, dwWCGrpBucket,
                                dwSrcBucket, dwWCSrcBucket, 
                                dwSourceMask = 0xFFFFFFFF,
                                dwTimeOut = EXPIRY_INTERVAL, dwTimerQ, 
                                dwOutIfCount = 0;
    

    PPROTOCOL_ENTRY             ppe = NULL;
    

    PIF_ENTRY                   pieInIf = NULL;


    PGROUP_ENTRY                pge = NULL, pgeWC = NULL, pgeNew = NULL;


    PSOURCE_ENTRY               pse = NULL, pseWC = NULL, pseNew = NULL;

    POUT_IF_ENTRY               poie;
    
    PLIST_ENTRY                 pleGrpList = NULL, pleSrcList = NULL,
                                pleWCGrpList = NULL, pleWCSrcList = NULL,
                                ple, pleTemp;


    PTIMER_CONTEXT              ptwc = NULL;
    
    LIST_ENTRY                  leMfeOutIfList, lePrevMfeOutIfList;

    NTSTATUS                    ntStatus;

    RTM_ENTITY_INFO             reiEntityInfo;
    RTM_DEST_INFO               rdiDestInfo;
    HANDLE                      hNextHop;
    BOOL                        bRelDest = FALSE;


    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE6( 
        ENTER, "ENTERED MgmNewPacketReceived : Source %x, %x : "
        "Group %x, %x : In Interface : %x, %x", dwSourceAddr, dwSourceMask,
        dwGroupAddr, dwGroupMask, dwInIfIndex, dwInIfNextHopAddr
        );
    

    //--------------------------------------------------------------------
    // Check if Mfe is already present for this ( source, group ).
    // If so add it to the Kernel mode forwarder.
    //--------------------------------------------------------------------


    if ( IsMFEPresent( 
            dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, TRUE ) )
    {
        TRACE1( ENTER, "LEAVING MgmNewPacketReceived %x\n", dwErr );

        LEAVE_MGM_API();

        return dwErr;
    }


    //--------------------------------------------------------------------
    // No Mfe is present for this ( source, group )
    //--------------------------------------------------------------------


    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        //
        // Perform RPF check on the incoming interface.
        //

        RtlZeroMemory( &rdiDestInfo, sizeof( RTM_DEST_INFO ) );
        
        dwErr = InvokeRPFCallbacks( 
                    &ppe, &pieInIf, &dwIfBucket,
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    &dwInIfIndex, &dwInIfNextHopAddr, &dwUpStreamNbr,
                    dwHdrSize, pbPacketHdr,  &hNextHop, (PBYTE) &rdiDestInfo
                    );

        //
        // Something is hosed here.
        //
        
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        bRelDest = TRUE;
        bIfLock = TRUE;


        //--------------------------------------------------------------------
        // In one of the most dramatic events in the multicast world
        // scattered membership entries now morph into an MFE, capable of 
        // sustaining traffic and bringing multicast applications to life.
        // 
        // Gag-gag-gag-uggggghh.  Ok enough bad poetic license.  
        // Just create the MFE asap. (and get a life please)
        //--------------------------------------------------------------------

        InitializeListHead( &leMfeOutIfList );
        InitializeListHead( &lePrevMfeOutIfList );


        //
        // Check if there is administrative-scoped boundary for this
        // group on the incoming interface
        //

        if ( IS_HAS_BOUNDARY_CALLBACK() &&
             HAS_BOUNDARY_CALLBACK()( dwInIfIndex, dwGroupAddr ) )
        {
            //
            // Admin-scoped bounday exists on incoming interface.
            // Create a negative MFE to prevent forwarding of
            // traffic for this (S, G)
            //
            
            TRACEPACKET2( 
                GROUP, "Admin-scope on for group %lx, incoming interface",
                dwInIfIndex, dwGroupAddr
                );

            //
            // find the group entry
            //

            dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
            
            ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
            bGrpLock = TRUE;
            

            //
            // acquire group lock and find group entry in the hash bucket again
            //

            pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
            
            bGrpFound = FindGroupEntry( 
                            pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                            );

            if ( bGrpFound )
            {
                //
                // Found group, look up source entry
                //

                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bGrpEntryLock = TRUE;


                dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );


                bSrcFound = FindSourceEntry( 
                                pleSrcList, dwSourceAddr, dwSourceMask, 
                                &pse, TRUE 
                                );
            }
        }

        else
        {
            do
            {
                //
                // No admin-scope on incoming interface.  Proceed to create 
                // the OIF list for this MFE.
                //
                
                //
                // 1. check if (*, *) entry is present
                //

                dwWCGrpBucket = GROUP_TABLE_HASH( 0, 0 );

                ACQUIRE_GROUP_LOCK_SHARED( dwWCGrpBucket );
                bWCGrpLock = TRUE;

                pleWCGrpList = GROUP_BUCKET_HEAD( dwWCGrpBucket );


                if ( FindGroupEntry( pleWCGrpList, 0, 0, &pgeWC, TRUE ) )
                {
                    //
                    // ok wildcard group entry exists.
                    // find the wildcard source entry.
                    //

                    ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    bWCGrpEntryLock = TRUE;
                    
                    dwWCSrcBucket = SOURCE_TABLE_HASH( 0, 0 );

                    pleWCSrcList = SOURCE_BUCKET_HEAD( pgeWC, dwWCSrcBucket );
                    

                    if ( FindSourceEntry( pleWCSrcList, 0, 0, &pseWC, TRUE ) )
                    {
                        //
                        // Copy the outgoing interface list for the (*, *) entry
                        //

                        InterlockedExchange( &pseWC-> dwInUse, 1 );
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pseWC-> leOutIfList );
                    }
                }


                //
                // 2. check if a (*, G) entry is present.
                //

                dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );
                
                ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bGrpLock = TRUE;
                

                //
                // acquire group lock and find group entry in the hash bucket again
                //

                pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
                
                bGrpFound = FindGroupEntry( 
                                pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE
                                );
                
                if ( bGrpFound )
                {
                    pseWC = NULL;
                    
                    //
                    // group entry present, check if wildcard source is present
                    //

                    ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                    bGrpEntryLock = TRUE;
                    

                    dwWCSrcBucket = SOURCE_TABLE_HASH( 0, 0 );

                    pleWCSrcList = SOURCE_BUCKET_HEAD( pge, dwWCSrcBucket );


                    if ( FindSourceEntry( pleWCSrcList, 0, 0, &pseWC, TRUE ) )
                    {
                        //
                        // Merge the OIL of the (*, G) entry with the OIL of
                        // the (*, *) entry
                        //

                        pseWC-> dwInUse = 1;
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pseWC-> leOutIfList );
                    }


                    //
                    // 3. Check if (S, G) entry is present 
                    //

                    dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

                    pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

                    bSrcFound = FindSourceEntry( 
                                    pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE 
                                    );

                    if ( bSrcFound )
                    {
                        //
                        // Source Entry present.  Merge with source OIL
                        //

                        pse-> dwInUse = 1;
                        
                        CopyAndMergeIfLists( &leMfeOutIfList, &pse-> leOutIfList );
                    }
                }
                
            
                //
                // If OIF list is empty, no CREATION_ALERTs required.
                //

                if ( IsListEmpty( &leMfeOutIfList ) )
                {
                    FreeList( &lePrevMfeOutIfList );
                    InitializeListHead( &lePrevMfeOutIfList );
                    break;
                }

                //
                // Check if OIF list is the same as previous iteration
                //

                if ( IsListSame( &lePrevMfeOutIfList, &leMfeOutIfList ) )
                {
                    FreeList( &leMfeOutIfList );
                    break;
                }

                
                //--------------------------------------------------------------------
                // It's callback time
                //--------------------------------------------------------------------

                //
                // release all locks before invoking the CREATION_ALERT callback
                //

                if ( bGrpEntryLock )
                {
                    RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                    bGrpEntryLock = FALSE;
                }

                if ( bGrpLock )
                {
                    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                    bGrpLock = FALSE;
                }

                if ( bWCGrpEntryLock  )
                {
                    RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
                    bWCGrpEntryLock = FALSE;
                }
                
                if ( bWCGrpLock )
                {
                    RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
                    bWCGrpLock = FALSE;
                }

                RELEASE_IF_LOCK_SHARED( dwIfBucket );

                bGrpFound = FALSE;
                bSrcFound = FALSE;
                
                //
                // invoked creation alert for each protocol component that
                // has an interface in the OIL.
                //

                InvokeCreationAlert(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwInIfIndex, dwInIfNextHopAddr, &leMfeOutIfList, &dwOutIfCount
                    );


                //
                // Save list from previous iteration
                //

                FreeList( &lePrevMfeOutIfList );

                lePrevMfeOutIfList = leMfeOutIfList;

                leMfeOutIfList.Flink-> Blink = &lePrevMfeOutIfList;

                leMfeOutIfList.Blink-> Flink = &lePrevMfeOutIfList;

                InitializeListHead( &leMfeOutIfList );

                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

            } while (TRUE);
        }
        
        //
        // if OIL is empty, invoke deletion alert for the protocol component
        // on the incoming interface interface
        //

        if ( IsListEmpty( &lePrevMfeOutIfList ) )
        {
            //
            // Outgoing interface list is empty for this MFE
            // Invoke deleteion alert on the protocol component on the 
            // incoming interface
            //

            if ( IS_PRUNE_ALERT( ppe ) )
            {
                PRUNE_ALERT( ppe ) (
                    dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                    dwInIfIndex, dwInIfNextHopAddr, FALSE, &dwTimeOut
                    );
            }
        }


        //
        // if there was no group entry, create one
        //
        
        if ( !bGrpFound )
        {
            if ( pge != NULL )
            {
                dwErr = CreateGroupEntry(
                            &pge-> leGrpHashList, dwGroupAddr, dwGroupMask, 
                            &pgeNew
                            );
            }

            else
            {
                dwErr = CreateGroupEntry(
                            pleGrpList, dwGroupAddr, dwGroupMask, &pgeNew
                            );
            }
            
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pge = pgeNew;

            
            //
            // find source hash bucket
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            bGrpEntryLock = TRUE;
            
            dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

            pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );
        }


        //
        // if there was no source entry
        //

        if ( !bSrcFound )
        {
            if ( pse != NULL )
            {
                dwErr = CreateSourceEntry(
                            pge, &pse-> leSrcHashList, dwSourceAddr, dwSourceMask,
                            &pseNew
                            );
            }

            else
            {
                dwErr = CreateSourceEntry(
                            pge, pleSrcList, dwSourceAddr, dwSourceMask,
                            &pseNew
                            );
            }

            if ( dwErr != NO_ERROR )
            {
                break;
            }

            pse = pseNew;

            pge-> dwSourceCount++;
        }


        //
        // Set incoming interface
        //

        pse-> dwInIfIndex           = dwInIfIndex;

        pse-> dwInIfNextHopAddr     = dwInIfNextHopAddr;

        pse-> dwUpstreamNeighbor    = dwUpStreamNbr;

        pse-> dwInProtocolId        = ppe-> dwProtocolId;

        pse-> dwInComponentId       = ppe-> dwComponentId;
        

        //
        // Set route information
        //

        dwErr = RtmGetEntityInfo(
                    g_hRtmHandle, rdiDestInfo.ViewInfo[ 0 ].Owner,
                    &reiEntityInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACEPACKET1( ANY, "failed to get entity info : %x", dwErr );

            pse-> dwRouteProtocol   = 0;
        }
        else
        {
            pse-> dwRouteProtocol   = reiEntityInfo.EntityId.EntityProtocolId;
        }

        pse-> dwRouteNetwork        = 
            *( (PDWORD) rdiDestInfo.DestAddress.AddrBits );
            
        pse-> dwRouteMask =
            RTM_IPV4_MASK_FROM_LEN( rdiDestInfo.DestAddress.NumBits );
        
        pse-> bInForwarder          = TRUE;
        
        //
        // save timeout in seconds and creation time
        //
        
        pse-> dwTimeOut             = dwTimeOut / 1000;
        
        NtQuerySystemTime( &pse-> liCreationTime );


        //
        // save the MFE OIL
        //

        if ( !IsListEmpty( &lePrevMfeOutIfList ) )
        {
            pse-> dwMfeIfCount           = dwOutIfCount;

            pse-> leMfeIfList            = lePrevMfeOutIfList;

            lePrevMfeOutIfList.Flink-> Blink = &pse-> leMfeIfList;

            lePrevMfeOutIfList.Blink-> Flink = &pse-> leMfeIfList;

            //
            // Free OIF entries on which forwarding is disabled
            //

            ple = pse-> leMfeIfList.Flink;

            while ( ple != &pse-> leMfeIfList )
            {
                poie = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

                pleTemp = ple-> Flink;
                
                if ( !poie-> wForward )
                {
                    RemoveEntryList( ple );

                    MGM_FREE( poie );
                }

                ple = pleTemp;
            }
        }


        //
        // add a reference for the incoming interface
        //

        AddSourceToRefList( 
            &pieInIf-> leInIfList, dwSourceAddr, dwSourceMask, 
            dwGroupAddr, dwGroupMask, IS_PROTOCOL_IGMP( ppe )
            );
        
        //
        // Set the MFE in the forwarder.
        //

        AddMfeToForwarder( pge, pse, dwTimeOut );


        //
        // create timer entry and store timer object
        //
        
        //
        // allocate a timer context structure
        //

        ptwc = MGM_ALLOC( sizeof( TIMER_CONTEXT ) );

        if ( ptwc == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "Failed to allocate timer context of size : %d", 
                sizeof( TIMER_CONTEXT )
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        ptwc-> dwSourceAddr     = pse-> dwSourceAddr;
        ptwc-> dwSourceMask     = pse-> dwSourceMask;

        ptwc-> dwGroupAddr      = pge-> dwGroupAddr;
        ptwc-> dwGroupMask      = pge-> dwGroupMask;

        ptwc-> dwIfIndex        = pse-> dwInIfIndex;

        ptwc-> dwIfNextHopAddr  = pse-> dwInIfNextHopAddr;
        

        //
        // Add timer to appropriate timer Q
        //
        
        dwTimerQ = TIMER_TABLE_HASH( pge-> dwGroupAddr );
        
        ntStatus = RtlCreateTimer(
                        TIMER_QUEUE_HANDLE( dwTimerQ ), &pse-> hTimer,
                        MFETimerProc, ptwc, dwTimeOut, 0, 0
                        );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            TRACE1( ANY, "Timer set failed with status %lx", ntStatus );

            LOGERR0( INVALID_TIMER_HANDLE, ntStatus );
        }

    } while ( FALSE );



    //
    // Release locks and quit 
    //
    
    if ( bGrpEntryLock ) 
    {
        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    if ( bGrpLock )
    {
        RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    }
    
    if ( bWCGrpEntryLock )
    {
        RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
    }
        
    if ( bWCGrpLock )
    {
        RELEASE_GROUP_LOCK_SHARED( dwWCGrpBucket );
    }

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_SHARED( dwIfBucket );
    }


    //
    // Add route retuned by RPF check to route table.
    //

    if ( dwErr == NO_ERROR )
    {
        AddSourceGroupToRouteRefList( 
            dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask, hNextHop,
            (PBYTE) &rdiDestInfo
            );
    }
    

    if ( bRelDest )
    {
        RtmReleaseDestInfo( g_hRtmHandle, &rdiDestInfo );
    }

    RELEASE_PROTOCOL_LOCK_SHARED();
    

    TRACE1( ENTER, "LEAVING MgmNewPacketReceived %x\n", dwErr );

    LEAVE_MGM_API();

    
    return dwErr;
    
}


//----------------------------------------------------------------------------
// IsMFEPresent
//
// Check if MFE is present for a given (source, group).  If it is add it to
// to the kernel mode forwarder.
//----------------------------------------------------------------------------

BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
)
{

    BOOL                        bMfeFound = FALSE;

    DWORD                       dwGrpBucket, dwSrcBucket;

    PLIST_ENTRY                 pleGrpList, pleSrcList;

    PGROUP_ENTRY                pge = NULL;

    PSOURCE_ENTRY               pse = NULL;

    

    //
    // check MFE is present for the specified (source, group)
    //

    dwGrpBucket = GROUP_TABLE_HASH( dwGroupAddr, dwGroupMask );

    ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
    

    pleGrpList = GROUP_BUCKET_HEAD( dwGrpBucket );
    
    if ( FindGroupEntry( 
            pleGrpList, dwGroupAddr, dwGroupMask, &pge, TRUE 
            ) )
    {
        //
        // group entry exists, find source entry
        //

        ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        

        dwSrcBucket = SOURCE_TABLE_HASH( dwSourceAddr, dwSourceMask );

        pleSrcList = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

        if ( FindSourceEntry( 
                pleSrcList, dwSourceAddr, dwSourceMask, &pse, TRUE
                ) )
        {
            //
            // Source entry exists, Is this source entry an MFE ?
            //

            if ( IS_VALID_INTERFACE( pse-> dwInIfIndex, 
                                     pse-> dwInIfNextHopAddr ) )
            {
                if ( bAddToForwarder )
                {

                    //
                    // MFE exists, set it to the forwarder
                    //
                    
                    AddMfeToForwarder( pge, pse, 0 );

                    pse-> bInForwarder = TRUE;
                }
                
                bMfeFound = TRUE;

            }                
        }

        RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
    }

    RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );


    return bMfeFound;
}


//----------------------------------------------------------------------------
// InvokeRPFCallbacks
//
// Assumes that the protocol list and the interface bucket are read locked 
//----------------------------------------------------------------------------

DWORD
InvokeRPFCallbacks(
    PPROTOCOL_ENTRY *           pppe,
    PIF_ENTRY *                 ppieInIf,
    PDWORD                      pdwIfBucket,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PDWORD                      pdwInIfIndex,
    PDWORD                      pdwInIfNextHopAddr,
    PDWORD                      pdwUpStreamNbr,
    DWORD                       dwHdrSize,
    PBYTE                       pbPacketHdr,
    PHANDLE                     phNextHop,
    PBYTE                       pbBuffer
)
{
    BOOL                        bFound = FALSE, bIfLock = FALSE;
    
    DWORD                       dwErr, dwCount = 0,
                                dwNewIfBucket;
    
    PPROTOCOL_ENTRY             ppe = NULL;

    PLIST_ENTRY                 pleIfList;
    
    BOOL                        bRelNextHop = FALSE;
    
    RTM_NET_ADDRESS             rnaSource;

    PRTM_DEST_INFO              prdiDestInfo = (PRTM_DEST_INFO) pbBuffer;

    RTM_NEXTHOP_INFO            rniNextHopInfo;



    TRACEPACKET2(
        PACKET, "ENTERED InvokeRPFCallbacks : In interface : %x, %x",
        *pdwInIfIndex, *pdwInIfNextHopAddr
        );
        
    *pppe = NULL;
    
    do
    {
        //
        // format the address
        //
        
        RTM_IPV4_MAKE_NET_ADDRESS( 
            &rnaSource, dwSourceAddr, IPv4_ADDR_LEN
            );


        //
        // lookup route
        //

        dwErr = RtmGetMostSpecificDestination(
                    g_hRtmHandle, &rnaSource, RTM_BEST_PROTOCOL,
                    RTM_VIEW_MASK_MCAST, prdiDestInfo
                    );
                    
        if ( dwErr != NO_ERROR )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No Route to source %x", dwSourceAddr );

            break;
        }

        
        //
        // Pick NHOP
        //

        *phNextHop = SelectNextHop( prdiDestInfo );

        if ( *phNextHop == NULL )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No NextHop to source %x", dwSourceAddr );

            break;
        }
        

        //
        // Get NHOP info
        //
        
        dwErr = RtmGetNextHopInfo( g_hRtmHandle, *phNextHop, &rniNextHopInfo );

        if ( ( dwErr != NO_ERROR ) || 
             ( rniNextHopInfo.State != RTM_NEXTHOP_STATE_CREATED ) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE1( ANY, "No Nexthop info to source %x", dwSourceAddr );

            break;
        }

        bRelNextHop = TRUE;


        //
        // Set the incoming interface as per the route table
        //
        
        *pdwInIfIndex = rniNextHopInfo.InterfaceIndex;

        //
        // The next hop is set to zero by default.  This is fine for
        // Ethernet and P2P interfaces where this value is 0 for the
        // the corresponding IF entries in the IF table.
        // But for Point to Multi Point interfaces such
        // as the RAS server (internal) interface or NBMA interfaces,
        // the NHOP field is used to distinguish interfaces that 
        // share an IF index.  e.g. RAS clients all connect on the 
        // same interface and are distinguished by different NHOP
        // values.  Consequently to find an entry in the IF hash 
        // table we need the (IF index, NHOP) pair.
        //
        // Here we run into a special case.  The new interface as
        // determined by the route lookup above gives just an IF 
        // index.  So we have an IF index.  
        // How do we get a NHOP on this interface ?
        //
        // (The reason for looking up an interface here is that we
        // would like to determine the protocol component that owns
        // it and then invoke the RPF callback of that protocol
        // component).
        //
        // The solution to this is based on two assumptions.  
        // One is
        // that only one protocol runs on an interface (single IF 
        // index).  This is true for P2MP interfaces too.  So to 
        // determine the protocol on an interface all one needs to 
        // do is to find any IF entry that has the same IF index 
        // (immaterial of the NEXT HOP).
        //
        // Second is that, all interfaces with the same IF index
        // hash to the same bucket in the IF table.  
        // So all the NHOP on a P2MP will be present in the same
        // hash bucket.  Also if the route lookup yields say 
        // IF index X, then looking up (X, (NHOP) 0) in the IF hash 
        // table will result in finding either IF entry (X, 0) for 
        // ethernet or P2P interfaces OR IF entry (X, Y) for P2MP
        // interfaces where Y is the first among the multiple NHOPs
        // that share the same IF index.  If neither exists then
        // we assume that no entry exits for an interface with 
        // IF index X and we report an error and quit.
        //
        // On success we can determine the protocol on IF index X.
        //
        // All this since we have a hash table index of (IF index,
        // NHOP) and we need to look having only a partial key.
        //
        
        *pdwInIfNextHopAddr = 0;

        TRACEPACKET2(
            PACKET, "New incoming interface : %d, %d", *pdwInIfIndex,
            *pdwInIfNextHopAddr
            );
            
        //
        // get the new incoming interface entry
        //
        
        dwNewIfBucket = IF_TABLE_HASH( *pdwInIfIndex );

        ACQUIRE_IF_LOCK_SHARED( dwNewIfBucket );
        bIfLock = TRUE;

        *pdwIfBucket = dwNewIfBucket;

        bFound = FindIfEntry( 
                    IF_BUCKET_HEAD( dwNewIfBucket), *pdwInIfIndex, 
                    *pdwInIfNextHopAddr, ppieInIf
                    );

        //
        // Check if the interface index of this interface is the same
        // as that of the incoming interface.  Since we are looking 
        // up the interface purely on IF index and not on 
        // IF index/NEXTHOP,
        // there is a chance for point to multipoint interface e.g.
        // RAS server interface, that we could have found a different
        // interface
        //

        if ( ( *ppieInIf == NULL )    ||
             ( (*ppieInIf)-> dwIfIndex != *pdwInIfIndex ) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
    
            TRACE3( 
                ANY, "InvokeRPFCallbacks : New incoming Interface not"
                " found : %x, %x, %x", *pdwInIfIndex, 
                *pdwInIfNextHopAddr, *ppieInIf
                );

            LOGWARN0( IF_NOT_FOUND, dwErr );

            break;
        }

        //
        // The incoming interface is now correct as per the route table
        // Look up the protocol on this interface.
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), (*ppieInIf)-> dwOwningProtocol,
                (*ppieInIf)-> dwOwningComponent
                );

        if ( ppe == NULL )
        {
            //
            // Internal MGM inconsistency.  Interface exists
            // but the protocol on it does not.  Should not
            // happen.
            //
            
            dwErr = ERROR_CAN_NOT_COMPLETE;

            TRACE2( 
                ANY, "InvokeRPFCallbacks : No protocol entry for"
                "incoming interface : %x, %x",
                (*ppieInIf)-> dwOwningProtocol, 
                (*ppieInIf)-> dwOwningComponent
                );

            break;
        }


        TRACEPACKET2(
            PACKET, "ProtocolEntry for packet %x, %x", 
            ppe-> dwProtocolId, ppe-> dwComponentId
            );
            
        //
        // Protocol entry found.  Invoke its RPF callback
        //

        if ( !( IS_RPF_CALLBACK( ppe ) ) )
        {
            //
            // No RPF callback provided by the protocol on the 
            // incoming interface.
            //
            
            dwErr = NO_ERROR;

            TRACEPACKET4( 
                ANY, "InvokeRPFCallbacks : No RPF callback for "
                "protocol %x, %x on incoming interface %x, %x",
                (*ppieInIf)-> dwOwningProtocol, 
                (*ppieInIf)-> dwOwningComponent,
                (*ppieInIf)-> dwIfIndex,
                (*ppieInIf)-> dwIfNextHopAddr
                );

            break;
        }

        dwErr = RPF_CALLBACK( ppe )(
                    dwSourceAddr, dwSourceMask, dwGroupAddr, 
                    dwGroupMask, pdwInIfIndex, pdwInIfNextHopAddr,
                    pdwUpStreamNbr, dwHdrSize, pbPacketHdr, pbBuffer 
                    );

        if ( dwErr == ERROR_INVALID_PARAMETER )
        {
            //
            // In the RPF callback the protocol component has
            // changed the incoming interface again.  Make sure
            // to set the IF bucket value correctly
            //

            dwNewIfBucket = IF_TABLE_HASH( *pdwInIfIndex );

            //
            // if this interface is in another hash bucket
            //

            if ( *pdwIfBucket != dwNewIfBucket )
            {
                RELEASE_IF_LOCK_SHARED( *pdwIfBucket );
                
                ACQUIRE_IF_LOCK_SHARED( dwNewIfBucket );

                *pdwIfBucket = dwNewIfBucket;
            }

            //
            // Find the interface entry corresp. to the
            // IF/NHOP as per the protocol
            //
            
            TRACEPACKET2(
                PACKET, "RPF check returned interface : %x, %x", *pdwInIfIndex,
                *pdwInIfNextHopAddr
                );
            
            if ( FindIfEntry( 
                    IF_BUCKET_HEAD( dwNewIfBucket ), *pdwInIfIndex,
                    *pdwInIfNextHopAddr, ppieInIf ) )
            {                        
                dwErr = NO_ERROR;
            }
            else
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
            }
        }
        
    } while ( FALSE );


    //
    // Clean up
    //
    
    if ( bRelNextHop )
    {
        if ( RtmReleaseNextHopInfo( g_hRtmHandle, &rniNextHopInfo ) != 
             NO_ERROR )
        {
            TRACE1( ANY, "Failed to release next hop : %x", dwErr );
        }
    }


    if ( ( dwErr != NO_ERROR ) && ( bIfLock ) )
    {
        RELEASE_IF_LOCK_SHARED( dwNewIfBucket );
    }
    

    //
    // set up the return parameters
    //

    //
    // TDB : in that we need to set a negative MFE if the RPF callback fails
    // without generating a route
    
    *pppe = ppe;

    TRACE1( PACKET, "LEAVING RPF Callback : %d", dwErr );
    
    return dwErr;
}



//----------------------------------------------------------------------------
// CopyAndMergeIfLists
//
//----------------------------------------------------------------------------

VOID
CopyAndMergeIfLists(
    PLIST_ENTRY                 pleMfeOutIfList,
    PLIST_ENTRY                 pleOutIfList
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp = 0;
    
    DWORD                       dwErr = NO_ERROR;
    
    POUT_IF_ENTRY               poieOut = NULL, poieMfe = NULL, poie = NULL;
    
    PLIST_ENTRY                 pleMfe = NULL, pleOut = NULL;

    

    do
    {
        if ( IsListEmpty( pleOutIfList ) )
        {
            break;
        }

        if ( IsListEmpty( pleMfeOutIfList ) )
        {
            CopyAndAppendIfList( 
                pleMfeOutIfList, pleOutIfList->Flink, pleOutIfList 
                );

            break;
        }


        pleMfe = pleMfeOutIfList-> Flink;

        pleOut = pleOutIfList-> Flink;

        while ( pleMfe != pleMfeOutIfList && 
                pleOut != pleOutIfList    && 
                dwErr == NO_ERROR )
        {
            poieOut  = CONTAINING_RECORD( pleOut, OUT_IF_ENTRY, leIfList );


            //
            // find location to insert new entry
            //

            bFound = FALSE;
            
            for ( ; pleMfe != pleMfeOutIfList; pleMfe = pleMfe-> Flink )
            {
                
                poieMfe = CONTAINING_RECORD( pleMfe, OUT_IF_ENTRY, leIfList );
                
                if ( poieMfe-> dwProtocolId < poieOut-> dwProtocolId )
                {
                    continue;
                }

                else if ( poieMfe-> dwProtocolId > poieOut-> dwProtocolId )
                {
                    //
                    // Interface entry not found
                    //

                    break;
                }


                //
                // same protocol
                //
            
                //
                // is same component
                //

                if ( poieMfe-> dwComponentId < poieOut-> dwComponentId ) 
                {
                    continue;
                }

                else if ( poieMfe-> dwComponentId > poieOut-> dwComponentId )
                {
                    //
                    // Interface entry not found
                    //

                    break;
                }


                //
                // same component
                //

                //
                // is same interface
                //

                if ( poieMfe-> dwIfIndex < poieOut-> dwIfIndex )
                {
                    continue;
                }

                else if ( poieMfe-> dwIfIndex > poieOut-> dwIfIndex )
                {
                    //
                    // interface not found
                    //

                    break;
                }


                //
                // is same next hop addr
                // to do IP address comparison function.
                //

                if ( INET_CMP( 
                        poieMfe-> dwIfNextHopAddr, poieOut-> dwIfNextHopAddr, iCmp 
                        ) < 0 )
                {
                    continue;
                }

                else if ( iCmp > 0 )
                {
                    //
                    // interface not found
                    //
                
                    break;
                }

                //
                // Interface found
                //

                bFound = TRUE;
                break;
            }


            if ( bFound )
            {
                //
                // Update entry in the Mfe out list
                //

                if ( IS_ADDED_BY_IGMP( poieOut ) )
                {
                    SET_ADDED_BY_IGMP( poieMfe );

                    poieMfe-> wNumAddsByIGMP += poieOut-> wNumAddsByIGMP;
                }

                if ( IS_ADDED_BY_PROTOCOL( poieOut ) )
                {
                    SET_ADDED_BY_PROTOCOL( poieMfe );

                    poieMfe-> wNumAddsByRP += poieOut-> wNumAddsByRP;
                }

                pleMfe = pleMfe-> Flink;
            }

            else
            {
                //
                // no matching entry in the mfe list
                //

                poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

                if ( poie == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                    TRACE1( 
                        ANY, "CreateOutInterfaceEntry : Could not allocate"
                        "out interface entry %x", dwErr 
                        );

                    LOGERR0( HEAP_ALLOC_FAILED, dwErr );

                    break;
                }

                CopyMemory( poie, poieOut, sizeof( OUT_IF_ENTRY ) );

                InsertTailList( pleMfe, &poie-> leIfList );
            }

            pleOut = pleOut-> Flink;
        }

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        //
        // if entries remain in the out list
        //

        if ( pleOut != pleOutIfList )
        {
            CopyAndAppendIfList( pleMfeOutIfList, pleOut, pleOutIfList );
        }
        
    } while ( FALSE );

    return;
}


//----------------------------------------------------------------------------
// CopyAndAppendIfList
//
//----------------------------------------------------------------------------

VOID
CopyAndAppendIfList(
    PLIST_ENTRY                 pleMfeIfList,
    PLIST_ENTRY                 pleOutIfList,
    PLIST_ENTRY                 pleOutIfHead
)
{
    DWORD                       dwErr = NO_ERROR;
    
    POUT_IF_ENTRY               poieOut = NULL, poie = NULL;

    
        
    for ( ;pleOutIfList != pleOutIfHead; pleOutIfList = pleOutIfList-> Flink )
    {
        poieOut = CONTAINING_RECORD( pleOutIfList, OUT_IF_ENTRY, leIfList );

        poie = MGM_ALLOC( sizeof( OUT_IF_ENTRY ) );

        if ( poie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CopyAndAppendIfList : Could not allocate"
                "out interface entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }

        CopyMemory( poie, poieOut, sizeof( OUT_IF_ENTRY ) );

        InsertTailList( pleMfeIfList, &poie-> leIfList );
    }
}



//----------------------------------------------------------------------------
// InvokeCreationAlert
//
//----------------------------------------------------------------------------

VOID
InvokeCreationAlert(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    DWORD                       dwInIfIndex,
    DWORD                       dwInIfNextHopAddr,
    PLIST_ENTRY                 pleMfeOutIfList,
    PDWORD                      pdwMfeOutIfCount
)
{
    DWORD                       dwCount = 0, dwErr = NO_ERROR, dwInd;

    PPROTOCOL_ENTRY             ppe = NULL;
    
    POUT_IF_ENTRY               poieFirst, poieNext, poieTemp;

    PMGM_IF_ENTRY               pmie = NULL;
    
    PLIST_ENTRY                 ple = NULL, pleFirst = NULL, pleTemp = NULL;

    
    

    TRACEPACKET6(
        PACKET, "ENTERED InvokeCreationAlert : Source %x, %x : Group : %x, %x"
        " : Interface %x, %x", dwSourceAddr, dwSourceMask, dwGroupAddr, 
        dwGroupMask, dwInIfIndex, dwInIfNextHopAddr
        );


    //
    // remove the incoming interface from the list of outgoing interfaces.
    // remove all interfaces that have have an scope-boundary for this group.
    //
    
    ple = pleMfeOutIfList-> Flink;

    while ( ple != pleMfeOutIfList )
    {
        poieTemp = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

        ple = ple-> Flink;
            
        //
        // Check if this is the incoming interface or
        // if this interface has a scope-boundary for this group
        //
        
        if ( ( ( poieTemp-> dwIfIndex       == dwInIfIndex ) &&
               ( poieTemp-> dwIfNextHopAddr == dwInIfNextHopAddr ) ) ||
             ( IS_HAS_BOUNDARY_CALLBACK() &&
               HAS_BOUNDARY_CALLBACK()( poieTemp-> dwIfIndex, dwGroupAddr ) ) )
        {
#if 1
            poieTemp-> wForward = 0;
#else
            RemoveEntryList( &poieTemp-> leIfList );

            MGM_FREE( poieTemp );
#endif
        }
    }
    

    //
    // invoke creation alerts for all components with interfaces in the OIL
    //

    ple = pleMfeOutIfList-> Flink;
    
    while ( ple != pleMfeOutIfList )
    {
        //
        // The OIL is sorted by components i.e. all interfaces for
        // a component are bunched together.
        //
        // Save the start of the interfaces for current component
        //
        
        pleFirst = ple;

        poieFirst = CONTAINING_RECORD( pleFirst, OUT_IF_ENTRY, leIfList );


        //
        // Count all interfaces for same component
        //

        dwCount = 0;

        while ( ple != pleMfeOutIfList )
        {
            poieNext = CONTAINING_RECORD( ple, OUT_IF_ENTRY, leIfList );

#if 1
            if ( !poieNext-> wForward )
            {
                ple = ple-> Flink;
                
                continue;
            }
#endif
            if ( poieNext-> dwProtocolId != poieFirst-> dwProtocolId    ||
                 poieNext-> dwComponentId != poieFirst-> dwComponentId )
            {
                break;
            }


            //
            // another outgoing interface for the same protocol
            //

            dwCount++;

            ple = ple-> Flink;
        }


        //
        // check if we have atleast one out interface entry
        // If not move to next protocol component in the OIL
        //
        
        if ( dwCount == 0 )
        {
            continue;
        }


        TRACEPACKET3( 
            PACKET, "Out If count %d for component %x %x", dwCount,
            poieFirst-> dwProtocolId, poieFirst-> dwComponentId
            );
        

        pmie = MGM_ALLOC( sizeof( MGM_IF_ENTRY ) * dwCount );

        if ( pmie == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( 
                ANY, "CopyAndAppendIfList : Could not allocate"
                "out interface entry %x", dwErr 
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // fill up buffer with list of interfaces for the 
        // the protocol component and invoke its creation alert.
        //
        
        pleTemp = pleFirst;
        
        for ( dwInd = 0; dwInd < dwCount; dwInd++ )
        {
            poieTemp = CONTAINING_RECORD( pleTemp, OUT_IF_ENTRY, leIfList );

#if 1
            if ( !poieTemp-> wForward )
            {
                pleTemp = pleTemp-> Flink;
                continue;
            }
#endif
            pmie[ dwInd ].dwIfIndex         = poieTemp-> dwIfIndex;
            
            pmie[ dwInd ].dwIfNextHopAddr   = poieTemp-> dwIfNextHopAddr;

            pmie[ dwInd ].bIsEnabled        = TRUE;

            pmie[ dwInd ].bIGMP             = IS_ADDED_BY_IGMP( poieTemp );

            pleTemp = pleTemp-> Flink;
            
        } 
        

        ppe = GetProtocolEntry(
                PROTOCOL_LIST_HEAD(), poieFirst-> dwProtocolId, 
                poieFirst-> dwComponentId
                );
                
        if ( IS_CREATION_ALERT( ppe ) )
        {
            CREATION_ALERT( ppe )(
                dwSourceAddr, dwSourceMask, dwGroupAddr, dwGroupMask,
                dwInIfIndex, dwInIfNextHopAddr, dwCount, pmie
                );
        }


        //
        // Accumulate the count of OIF
        //
        
        *pdwMfeOutIfCount += dwCount;


        //
        // remove the interface the are flaged as disabled
        //

        pleTemp = pleFirst;
        
        for ( dwInd = 0; dwInd < dwCount; dwInd++ )
        {
            poieTemp = CONTAINING_RECORD( pleTemp, OUT_IF_ENTRY, leIfList );
        
            ple = pleTemp-> Flink;
            
            if ( !pmie[ dwInd ].bIsEnabled )
            {
                //
                // Forwarding for this (S, G) for this interface has been 
                // disabled by the protocol
                //

#if 1
                poieTemp-> wForward = 0;
#else
                RemoveEntryList( pleTemp );

                MGM_FREE( poieTemp );
#endif
                (*pdwMfeOutIfCount)--;
            }

            pleTemp = ple;
        }

        MGM_FREE( pmie );
    }


    TRACEPACKET2(
        PACKET, "LEAVING InvokeCreationAlert : count %x, error : %x", 
        *pdwMfeOutIfCount, dwErr
        );
}



//----------------------------------------------------------------------------
// WrongIfFromForwarder
//
//----------------------------------------------------------------------------

DWORD 
WrongIfFromForwarder(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
)
{
    DWORD           dwErr = NO_ERROR;
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE3( 
        PACKET, "ENTERED WrongIfFromForwarder for (%lx, %lx) on interface "
        " %lx", dwSourceAddr, dwGroupAddr, dwInIfIndex
        );

    TRACE1( PACKET, "LEAVING WrongIfFromForwarder : %lx\n", dwErr );


    LEAVE_MGM_API();
    
    return dwErr;
}



//----------------------------------------------------------------------------
// FreeList
//
//----------------------------------------------------------------------------

VOID
FreeList (
    IN          PLIST_ENTRY             pleHead
)
{
    PLIST_ENTRY     ple, pleTemp;

    
    if ( IsListEmpty( pleHead ) )
    {
        return;
    }
    
    ple = pleHead-> Flink;

    while ( ple != pleHead )
    {
        pleTemp = ple-> Flink;

        RemoveEntryList( ple );

        MGM_FREE( ple );

        ple = pleTemp;
    }
}


//----------------------------------------------------------------------------
// IsListSame
//
//----------------------------------------------------------------------------

BOOL
IsListSame(
    IN          PLIST_ENTRY             pleHead1,
    IN          PLIST_ENTRY             pleHead2
)
{
    PLIST_ENTRY        ple1, ple2;

    POUT_IF_ENTRY    poif1, poif2;

    
    //
    // Check for empty lists
    //
    
    if ( ( IsListEmpty( pleHead1 ) && !IsListEmpty( pleHead2 ) ) ||
         ( !IsListEmpty( pleHead1 ) && IsListEmpty( pleHead2 ) ) )
    {
        return FALSE;
    }


    if ( IsListEmpty( pleHead1 ) && IsListEmpty( pleHead2 ) )
    {
        return TRUE;
    }


    //
    // walk lists in tandem and verify equality
    //

    ple1 = pleHead1-> Flink;
    ple2 = pleHead2-> Flink;

    do
    {
        poif1 = CONTAINING_RECORD( ple1, OUT_IF_ENTRY, leIfList );
        poif2 = CONTAINING_RECORD( ple2, OUT_IF_ENTRY, leIfList );

        if ( ( poif1-> dwIfIndex != poif2-> dwIfIndex ) ||
             ( poif1-> dwIfNextHopAddr != poif2-> dwIfNextHopAddr ) )
        {
            return FALSE;
        }

        ple1 = ple1-> Flink;
        ple2 = ple2-> Flink;
        
    } while ( ( ple1 != pleHead1 ) && ( ple2 != pleHead2 ) );


    //
    // If both lists have reached their ends, they match else they don't
    //
    
    if ( ( ( ple1 != pleHead1 ) && ( ple2 == pleHead2 ) ) ||
         ( ( ple1 == pleHead1 ) && ( ple2 != pleHead2 ) ) )
    {
        return FALSE;
    }

    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\mgmrtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.c
//
// History:
//      V Raman	July-11-1997  Created.
//
// Private interface between MGM and RTM
//============================================================================


#ifndef _ROUTING_MGMRTM_
#define _ROUTING_MGMRTM_

BOOL
MgmDllStartup(
);


VOID
MgmDllCleanup(
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\pchmgm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchmgm.h
//
// History:
//      V Raman	Oct-14-1997  Created.
//
// Pre compiled header for MGM
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <winsock.h>
#include <rtmv2.h>
#include <routprot.h>
#include <raserror.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ddipmcst.h>
#include <iprtrmib.h>
#include "rmrtm.h"
#include "mgmrtm.h"
#include "rmmgm.h"
#include "mgm.h"
#include "defs.h"
#include "sync.h"
#include "ipmgm.h"
#include "protocol.h"
#include "group.h"
#include "if.h"
#include "forward.h"
#include "timer.h"
#include "enum.h"
#include "log.h"
#include "route.h"
#include "scope.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\protocol.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: MgmIpRm.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Declarations for routines that manipulate protocol entries
//============================================================================


#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#include <mgm.h>

//----------------------------------------------------------------------------
// Each PROTOCOL_ENTRY structure stores the information for a routing
// protocol that is registered with MGM.
//
//
// dwProtocolId     -   unique protocol identifier.
//
// dwComponentId    -   unique component id, used to differentiate
//                      multiple components within a protocol.
//
// dwIfCount        -   count of interfaces owned by this protocol
//
// rpcProtocolConfig-   protocol config supplied by routing protocol
//                      on registration
// 
// dwSignature      -   Signature used to verify entry.
//----------------------------------------------------------------------------


typedef struct _PROTOCOL_ENTRY 
{
    LIST_ENTRY                  leProtocolList;

    DWORD                       dwProtocolId;

    DWORD                       dwComponentId;

    DWORD                       dwIfCount;
    
    ROUTING_PROTOCOL_CONFIG     rpcProtocolConfig;

    DWORD                       dwSignature;

} PROTOCOL_ENTRY, *PPROTOCOL_ENTRY;


#define MGM_PROTOCOL_SIGNATURE  'MGMp'



//
// Protocol table manipulation routines
//

DWORD
CreateProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId,
    PROUTING_PROTOCOL_CONFIG    prpcConfig,
    PPROTOCOL_ENTRY  *          pppeEntry
);


VOID
DeleteProtocolEntry(
    PPROTOCOL_ENTRY             ppeEntry
);


PPROTOCOL_ENTRY
GetProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId 
);


VOID
DeleteProtocolList(
    PLIST_ENTRY                 pleProtocolList
);


DWORD
VerifyProtocolHandle(
    PPROTOCOL_ENTRY             ppeEntry
);


PPROTOCOL_ENTRY
GetIgmpProtocolEntry(
    PLIST_ENTRY                 pleProtocolList
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\protocol.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: protocol.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Routines that manipulate protocol entries
//============================================================================

#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// CreateProtocolEntry
//
// This function creates, initializes and inserts a new protocol entry in the
// the list of protocols registered with MGM.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

DWORD
CreateProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId, 
    PROUTING_PROTOCOL_CONFIG    prpcConfig,
    PPROTOCOL_ENTRY  *          pppeEntry
)
{

    DWORD               dwErr = NO_ERROR;
    
    PPROTOCOL_ENTRY     ppe = NULL;



    do
    {
        //
        // Allocate new protocol entry.
        //

        ppe = MGM_ALLOC( sizeof( PROTOCOL_ENTRY ) );

        if ( ppe == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            
            TRACE1( 
                ANY, 
                "CreateProtocolEntry : Could not allocate protocol entry %x",
                dwErr
                );

            LOGERR0( HEAP_ALLOC_FAILED, dwErr );

            break;
        }


        //
        // Initialize protocol entry
        //

        InitializeListHead( &ppe-> leProtocolList );
        

        ppe-> dwProtocolId      = dwProtocolId;
        ppe-> dwComponentId     = dwComponentId;
        ppe-> dwIfCount         = 0;

        CopyMemory( 
            &ppe-> rpcProtocolConfig, prpcConfig, 
            sizeof( ROUTING_PROTOCOL_CONFIG )
            );

        ppe-> dwSignature       = MGM_PROTOCOL_SIGNATURE;


        //
        // Insert into protocol list
        //

        InsertTailList( pleProtocolList, &ppe-> leProtocolList );

        *pppeEntry = ppe;
        
        dwErr = NO_ERROR;
        
    } while ( FALSE );


    return dwErr;
}


//----------------------------------------------------------------------------
// GetProtocolEntry
//
// This function retrieves an entry from the list of protocols registered 
// with MGM.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------


PPROTOCOL_ENTRY
GetProtocolEntry(
    PLIST_ENTRY                 pleProtocolList,
    DWORD                       dwProtocolId,
    DWORD                       dwComponentId 
)
{

    BOOL                bFound = FALSE;
    PLIST_ENTRY         ple = NULL;
    PPROTOCOL_ENTRY     ppe = NULL;

    
    //
    // Scan protocol list and find entry
    //
    
    for ( ple = pleProtocolList-> Flink; 
          ple != pleProtocolList; 
          ple = ple-> Flink )
    {
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        if ( ppe-> dwProtocolId == dwProtocolId &&
             ppe-> dwComponentId == dwComponentId )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound ? ppe : NULL;
}


//----------------------------------------------------------------------------
// DeleteProtocolEntry
//
// This function deletes a protocol entry from the list of registered 
// protocols.  All the interface owned by this protocol should have been
// released before this funtion is called.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------


VOID
DeleteProtocolEntry(
    PPROTOCOL_ENTRY             ppeEntry
)
{
    //
    // remove protocol entry from list
    //

    RemoveEntryList( &ppeEntry-> leProtocolList );

    MGM_FREE( ppeEntry );
}



//----------------------------------------------------------------------------
// DeleteProtocolList
//
// This function deletes a protocol entry from the list of registered 
// protocols.  All the interface owned by this protocol should have been
// released before this funtion is called.
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

VOID
DeleteProtocolList(
    PLIST_ENTRY                 pleProtocolList
)
{

    PLIST_ENTRY         ple = NULL;
    
    PPROTOCOL_ENTRY     ppe = NULL;

    
    while ( !IsListEmpty( pleProtocolList ) )
    {
        ple = pleProtocolList-> Flink;
        
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        DeleteProtocolEntry( ppe );
    }
}



//----------------------------------------------------------------------------
// VerifyProtocolHandle
//
// This function verifies that the specified pointer points to a valid
// protocol entry 
//
// Assumes that the protocol list is already locked.
//----------------------------------------------------------------------------

DWORD
VerifyProtocolHandle(
    PPROTOCOL_ENTRY             ppeEntry
)
{

    DWORD dwErr = NO_ERROR;
    
    try
    {
        if ( ppeEntry-> dwSignature != MGM_PROTOCOL_SIGNATURE )
        {
            dwErr = ERROR_INVALID_PARAMETER;

            TRACE0( ANY, "Invalid protocol handle" );

            LOGERR0( INVALID_PROTOCOL_HANDLE, dwErr );

        }
    }
    
    except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? 
                                   EXCEPTION_EXECUTE_HANDLER :
                                   EXCEPTION_CONTINUE_SEARCH )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        TRACE0( ANY, "Invalid protocol handle" );

        LOGERR0( INVALID_PROTOCOL_HANDLE, dwErr );

    }

    return dwErr;
}




//----------------------------------------------------------------------------
// FindIgmpProtocolEntry
//
//  Find the protocol entry for IGMP
//----------------------------------------------------------------------------


PPROTOCOL_ENTRY
GetIgmpProtocolEntry(
    PLIST_ENTRY                 pleProtocolList
)
{
    BOOL                bFound = FALSE;

    PLIST_ENTRY         ple = NULL;

    PPROTOCOL_ENTRY     ppe = NULL;


    
    //
    // Scan protocol list and find entry
    //
    
    for ( ple = pleProtocolList-> Flink; 
          ple != pleProtocolList; 
          ple = ple-> Flink )
    {
        ppe = CONTAINING_RECORD( ple, PROTOCOL_ENTRY, leProtocolList );

        if ( IS_PROTOCOL_IGMP( ppe ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound ? ppe : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\route.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: route.c
//
// History:
//      V Raman	Feb-5-1998  Created.
//
// Routines that manipulate routes entries
//============================================================================


#include "pchmgm.h"
#pragma hdrstop



//----------------------------------------------------------------------------
//
// Route reference operations
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// AddSourceGroupToRouteRefList
//
//  This function inserts a reference for each MFE that uses this route
//  for it RPF check.  It is invoked by the new packet function on creation
//  of an MFE.
//----------------------------------------------------------------------------

VOID
AddSourceGroupToRouteRefList(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    HANDLE                      hNextHop,
    PBYTE                       pbBuffer
)
{
    BOOL                        bUnLock = FALSE, bMark = FALSE;

    DWORD                       dwErr;

    PMGM_LOCKED_LIST            pmllMfeList;

    PBYTE                       pbOpaqueInfo = NULL;

    PRTM_DEST_INFO              prdi = (PRTM_DEST_INFO) pbBuffer;

    PROUTE_REFERENCE_ENTRY      prre = NULL, prreNew = NULL;



    TRACEROUTE0( ROUTE, "ENTERED AddSourceGroupToRouteRefList" );

    do
    {
        //
        // Create a route reference entry
        //

        prre = MGM_ALLOC( sizeof( ROUTE_REFERENCE_ENTRY ) );

        if ( prre == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1(
                ANY, "Failed to allocate %d bytes",
                sizeof( ROUTE_REFERENCE_ENTRY )
                );

            break;
        }


        prre-> dwSourceAddr = dwSourceAddr;
        prre-> dwSourceMask = dwSourceMask;

        prre-> dwGroupAddr  = dwGroupAddr;
        prre-> dwGroupMask  = dwGroupMask;

        prre-> hNextHop     = hNextHop;

        InitializeListHead ( &prre-> leRefList );


        //
        // Lock the dest
        //

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest %x", dwErr );

            break;
        }

        bUnLock = TRUE;


        //
        // Get the opaque pointer
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to retrieve opaque pointer %x", dwErr );

            break;
        }


        if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
        {
            //
            // NULL opaque pointer implies this is the first MFe that
            // depends on this route
            //

            //
            // create a locked list
            //

            pmllMfeList = MGM_ALLOC( sizeof( MGM_LOCKED_LIST ) );

            if ( pmllMfeList == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1(
                    ANY, "AddSourceGroupToRouteRefList : "
                    "Failed to allocate route ref list %x", dwErr
                    );

                break;
            }

            CREATE_LOCKED_LIST( pmllMfeList );

            //
            // insert the element into the list
            //

            InsertTailList(
                &( pmllMfeList-> leHead ), &( prre-> leRefList )
                );


            //
            // set the opaque pointer
            //

            *( ( PBYTE *) pbOpaqueInfo ) = (PBYTE) pmllMfeList;


            //
            // Mark the destination
            //

            bMark = TRUE;
        }

        else
        {
            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE *) pbOpaqueInfo );

            //
            // Acquire the list lock
            //

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // release the dest lock
            //

            bUnLock = FALSE;

            dwErr = RtmLockDestination(
                        g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest %x", dwErr );
            }


            //
            // Insert the rre into the list (in its appropriate place)
            //

            if ( !FindRouteRefEntry(
                    &pmllMfeList-> leHead, dwSourceAddr, dwSourceMask,
                    dwGroupAddr, dwGroupMask, &prreNew
                    ) )
            {
                InsertTailList(
                    ( prreNew ) ? &prreNew-> leRefList :
                                  &pmllMfeList-> leHead,
                    &prre-> leRefList
                    );
            }

            else
            {
                TRACE1(
                    ANY, "Reference already exists for source %x", dwSourceAddr
                    );

                MGM_FREE( prre );
            }


            //
            // release the list lock
            //

            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

            dwErr = NO_ERROR;
        }

    } while ( FALSE );


    //
    // In case of error , free the allocation for route reference
    //

    if ( ( dwErr != NO_ERROR ) && ( prre != NULL ) )
    {
        MGM_FREE( prre );
    }


    //
    // release the dest lock
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to release dest %x", dwErr );
        }
    }


    //
    // mark dest if required
    //

    if ( bMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to mark destination %x:", dwErr );
        }
    }

    TRACEROUTE0( ROUTE, "LEAVING AddSourceGroupToRouteRefList" );
}



//----------------------------------------------------------------------------
// FindRouteRefEntry
//
//  Finds a specified (source, group ) entry in the MFE reference list
//  for a route.
//
//  If the entry is found a pointer to the entry is returned in the parameter
//  pprre.
//  If the entry is not found a pointer to the "next" entry is returned.
//----------------------------------------------------------------------------

BOOL
FindRouteRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PROUTE_REFERENCE_ENTRY *    pprre
)
{
    BOOL                        bFound = FALSE;

    INT                         iCmp;

    PLIST_ENTRY                 pleRef;

    PROUTE_REFERENCE_ENTRY      prre;


    TRACEROUTE0( ROUTE, "ENTERED RouteRefEntry" );

    do
    {
        *pprre = NULL;

        pleRef = pleRefList-> Flink;

        while ( pleRef != pleRefList )
        {
            prre = CONTAINING_RECORD(
                        pleRef, ROUTE_REFERENCE_ENTRY, leRefList
                        );

            //
            // is same group
            //

            if ( INET_CMP( prre-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
            {
                pleRef = pleRef-> Flink;

                continue;
            }

            else if ( iCmp > 0 )
            {
                //
                // past possible group entry
                //

                *pprre = prre;

                break;
            }


            //
            // same group, now look for source
            //

            if ( INET_CMP( prre-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
            {
                pleRef = pleRef-> Flink;

                continue;
            }

            else if ( iCmp > 0 )
            {
                //
                // past possible source entry
                //

                *pprre = prre;

                break;
            }

            //
            // found entry
            //

            *pprre = prre;

            bFound = TRUE;

            break;
        }

    } while ( FALSE );

    TRACEROUTE1( ROUTE, "LEAVING RouteRefEntry : %d", bFound );

    return bFound;
}



//----------------------------------------------------------------------------
// DeletRouteRef
//
//----------------------------------------------------------------------------

VOID
DeleteRouteRef(
    PROUTE_REFERENCE_ENTRY                prre
)
{
    TRACEROUTE0( ROUTE, "ENTERED DeleteRefEntry" );

    RemoveEntryList( &prre-> leRefList );

    MGM_FREE( prre );

    TRACEROUTE0( ROUTE, "LEAVING DeleteRefEntry" );
}



DWORD
WINAPI
RtmChangeNotificationCallback(
    RTM_ENTITY_HANDLE           hRtmHandle,
    RTM_EVENT_TYPE              retEventType,
    PVOID                       pvContext1,
    PVOID                       pvContext2
)
{
    DWORD dwErr = NO_ERROR;


    if ( !ENTER_MGM_API() )
    {
        TRACE0( ANY, "RtmChangeNotificationCallback : Failed to enter" );

        return ERROR_CAN_NOT_COMPLETE;
    }


    TRACE0( ROUTE, "ENTERED RtmChangeNotificationCallback" );


    do
    {
        //
        // Ignore all notifications except change notifications
        //

        if ( retEventType != RTM_CHANGE_NOTIFICATION )
        {
            break;
        }


        //
        // Queue work function to process changed destinations
        //

        dwErr = QueueMgmWorker(
                    WorkerFunctionProcessRtmChangeNotification, NULL
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to queue work item", dwErr );
        }

    } while ( FALSE );


    LEAVE_MGM_API();


    TRACE1( ROUTE, "LEAVING RtmChangeNotificationCallback : %d", dwErr );

    return dwErr;
}



VOID
WorkerFunctionProcessRtmChangeNotification(
    PVOID                       pvContext
)
{
    BOOL bMarked = FALSE, bDone = FALSE;

    DWORD dwErr, dwNumDests;

    RTM_DEST_INFO rdi;



    if ( !ENTER_MGM_WORKER() )
    {
        TRACE0(
            ANY, "WorkerFunctionProcessRtmChangeNotification : Failed to enter"
            );

        return;
    }


    TRACE0( ROUTE, "ENTERED WorkerFunctionRtmChangeNotification" );

    do
    {
        //
        // Get route changes one at a time
        //

        dwNumDests = 1;

        dwErr = RtmGetChangedDests(
                    g_hRtmHandle, g_hNotificationHandle, &dwNumDests, &rdi
                    );

        if ( ( dwErr != NO_ERROR ) && ( dwErr != ERROR_NO_MORE_ITEMS ) )
        {
            TRACE1(
                ANY, "RtmGetChangedDests failed with error : %x",
                dwErr
                );

            break;
        }


        //
        // if there are no changed dests, quit.
        //

        if ( dwNumDests == 0 )
        {
            TRACE0( ANY, "RtmGetChangedDests returns 0 dests" );

            break;
        }


        //
        // There are dests.  Check if there are no more dests.
        // If so set a flag to quit processing after this one
        //

        if ( dwErr == ERROR_NO_MORE_ITEMS )
        {
            bDone = TRUE;
        }


        //
        // Check if there any routes for this destination
        //

        if ( rdi.ViewInfo[ 0 ].Route == NULL )
        {
            //
            // No routes, assume this to be a delete
            //

            dwErr = ProcessRouteDelete( &rdi );
        }

        else
        {
            //
            // Check if dest is marked for change notification
            //

            dwErr = RtmIsMarkedForChangeNotification(
                        g_hRtmHandle, g_hNotificationHandle, rdi.DestHandle,
                        &bMarked
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "RtmIsMarkedForChangeNotification failed with error : %x",
                    dwErr
                    );

                break;
            }


            //
            // Process this destination
            //

            ( bMarked ) ? ProcessRouteUpdate( &rdi ) :
                          ProcessUnMarkedDestination( &rdi );

        } while ( FALSE );


        //
        // Release changed destinations
        //

        dwErr = RtmReleaseChangedDests(
                    g_hRtmHandle, g_hNotificationHandle, 1, &rdi
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to released destination", dwErr );
        }

    } while ( !bDone );


    LEAVE_MGM_WORKER();

    TRACE0( ROUTE, "LEAVING WorkerFunctionRtmChangeNotification" );
}



DWORD
ProcessUnMarkedDestination(
    PRTM_DEST_INFO          prdi
)
{
    BOOL bRelDest = FALSE, bMarked = FALSE, bUnLock = FALSE,
         bRelRouteRef = FALSE, bUnMark = FALSE;

    DWORD dwErr, dwDestMask;

    PBYTE pbOpaqueInfo = NULL;

    PLIST_ENTRY ple, pleTemp;

    PROUTE_REFERENCE_ENTRY prre;

    PMGM_LOCKED_LIST pmllMfeList = NULL;

    RTM_DEST_INFO rdiLessSpecificDest;



    do
    {
        //
        // Get next less specific destination
        //

        dwErr = RtmGetLessSpecificDestination(
                    g_hRtmHandle, prdi-> DestHandle, RTM_BEST_PROTOCOL,
                    RTM_VIEW_MASK_MCAST, &rdiLessSpecificDest
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to get less specific destination", dwErr );

            break;
        }

        bRelDest = TRUE;


        //
        // Check if it is marked
        //

        dwErr = RtmIsMarkedForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    rdiLessSpecificDest.DestHandle, &bMarked
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to check if dest is marked", dwErr );

            break;
        }


        //
        // if marked
        //

        if ( bMarked )
        {
            //
            // it is marked.  Lock it
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle,
                        rdiLessSpecificDest.DestHandle,
                        TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock less specific dest : %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get its opaque pointer
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, rdiLessSpecificDest.DestHandle,
                        &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1(
                    ANY, "Failed to opaque ptr for less specific dest : %x",
                    dwErr
                    );

                break;
            }


            //
            // Check if it is NULL
            //

            if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
            {
                bUnMark = TRUE;

                break;
            }


            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE * ) pbOpaqueInfo );


            //
            // lock the route reference list
            //

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
            bRelRouteRef = TRUE;


            //
            // Unlock the dest
            //

            bUnLock = FALSE;

            dwErr = RtmLockDestination(
                        g_hRtmHandle,
                        rdiLessSpecificDest.DestHandle,
                        TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unlock less specific dest : %x", dwErr );

                break;
            }


            //
            // Create MASK for new dest. from len
            //

            dwDestMask = RTM_IPV4_MASK_FROM_LEN(
                            prdi-> DestAddress.NumBits
                            );

            //
            // For each reference
            //

            for ( ple = pmllMfeList-> leHead.Flink;
                  ple != &pmllMfeList-> leHead; )
            {
                prre = CONTAINING_RECORD(
                        ple, ROUTE_REFERENCE_ENTRY, leRefList
                        );

                //
                // Check if this MFE would fall under the
                // more specific route
                //

                if ( ( prre-> dwSourceAddr & dwDestMask ) ==
                     ((  * ( PDWORD ) prdi-> DestAddress.AddrBits ) & dwDestMask) )
                {
                    //
                    // if it does, delete the MFE.  This will force its
                    // recreation, at which time it will be made dependent
                    // on the more specific route
                    //

                    pleTemp = ple-> Flink;

                    RemoveEntryList( ple );

                    DeleteMfeAndRefs( ple );

                    ple = pleTemp;
                }
                else
                {
                    ple = ple-> Flink;
                }
            }


            //
            // if Ref list is empty, it needs to be deleted too.
            //

            if ( IsListEmpty( &pmllMfeList-> leHead ) )
            {
                //
                // to delete the opaque pointer, the dest needs to be locked
                // (via RtmLockDestination)
                //
                // the dest lock is held before locking the route reference
                // list ( via ACQUIRE_ROUTE_LOCK_EXCLUSIVE )
                //
                // At this point in the code, the route reference is locked
                // but the dest is not locked.
                //
                // To lock it, the route reference lock is first released
                // (via RELEASE_ROUTE_LOCK_EXCLUSIVE).
                //
                // The opaque pointer is then acquired, route ref list locked,
                // and double checked for emptiness.  This round-about ensures
                // that the route ref is not deleted while there are threads
                // waiting on its lock.  This can happen since the dest lock
                // is not held for most of the operations here
                //

                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = FALSE;

                //
                // Lock dest
                //

                dwErr = RtmLockDestination(
                            g_hRtmHandle,
                            rdiLessSpecificDest.DestHandle,
                            TRUE, TRUE
                            );

                if ( dwErr != NO_ERROR )
                {
                    TRACE1( ANY, "Failed to lock dest : %x", dwErr );

                    break;
                }

                bUnLock = TRUE;


                //
                // Get Opaque pointer again
                //

                dwErr = RtmGetOpaqueInformationPointer(
                            g_hRtmHandle, rdiLessSpecificDest.DestHandle,
                            &pbOpaqueInfo
                            );

                if ( dwErr != NO_ERROR || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
                {
                    TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

                    break;
                }


                //
                // Get ref. list and lock it.
                //

                pmllMfeList = ( PMGM_LOCKED_LIST ) * ( ( PBYTE * ) pbOpaqueInfo );

                ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = TRUE;


                //
                // If list is still empty
                //

                if ( IsListEmpty( &pmllMfeList-> leHead ) )
                {
                    //
                    // Clear opaque pointer info
                    //

                    * ( PBYTE * )pbOpaqueInfo = NULL;

                    //
                    // release list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                    bRelRouteRef = FALSE;

                    MGM_FREE( pmllMfeList );


                    //
                    // unmark the dest.  Change notifications for this
                    // dest are no longer required.
                    //

                    bUnMark = TRUE;
                }
            }

            else
            {
                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                bRelRouteRef = FALSE;
            }
        }

    } while ( FALSE );


    //
    // release route ref list lock
    //

    if ( bRelRouteRef )
    {
        RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
    }


    //
    // Unlock dest
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle,
                    rdiLessSpecificDest.DestHandle,
                    TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );
        }
    }


    //
    // Unmark dest
    //

    if ( bUnMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    rdiLessSpecificDest.DestHandle, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
        }
    }

    return dwErr;
}



DWORD
ProcessRouteDelete(
    PRTM_DEST_INFO          prdi
)
{
    BOOL                    bMark = FALSE;

    DWORD                   dwErr;

    PMGM_LOCKED_LIST        pmllMfeList;

    PBYTE                   pbOpaqueInfo = NULL;

    PLIST_ENTRY             ple;


    do
    {
        //
        // Cannot lock dest.  Is that OK ?
        //

        //
        // Check if this is a marked destination
        // Only marked destinations are processed
        //

        dwErr = RtmIsMarkedForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, &bMark
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to check if dest marked", dwErr );

            break;
        }

        if ( !bMark )
        {
            TRACE0( 
                ANY, "Ignoring change notification for unmarked destination"
                );
                
            break;
        }


        //
        // Get Opaque pointer & the list of MFEs dependent
        // on this dest
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( (dwErr != NO_ERROR) || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
        {
            TRACE1( ANY, "Failed to get opaque ptr", dwErr );

            break;
        }


        //
        // Clear out the opaque pointer
        //

        pmllMfeList = (PMGM_LOCKED_LIST) *( ( PBYTE * ) pbOpaqueInfo );

        *( ( PBYTE * ) pbOpaqueInfo ) = NULL;


        //
        // Cannot unlock dest.  Is that ok ?
        //

        //
        // Check if the opaque pointer is NULL
        //

        if ( pmllMfeList == NULL )
        {
            TRACE0( ANY, "Opaque pointer is NULL" );

            break;
        }


        //
        // Delete all the MFEs
        //

        ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

        while ( !IsListEmpty( &pmllMfeList-> leHead ) )
        {
            ple = RemoveHeadList( &pmllMfeList-> leHead );

            DeleteMfeAndRefs( ple );
        }


        RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

        MGM_FREE( pmllMfeList );

        dwErr = NO_ERROR;

    } while ( FALSE );


    return dwErr;
}


DWORD
ProcessRouteUpdate(
    PRTM_DEST_INFO          prdi
)
{
    BOOL                    bUnLock = FALSE, bUnMark = FALSE,
                            bFound = FALSE;

    DWORD                   dwSize, dwErr, dwInd;

    PBYTE                   pbOpaqueInfo = NULL;

    PMGM_LOCKED_LIST        pmllMfeList;

    PLIST_ENTRY             ple, pleTemp;

    PROUTE_REFERENCE_ENTRY  prre;

    PRTM_ROUTE_INFO         prri;


    //
    // the processing goes as follows :
    //

    do
    {
        //
        // Allocate route info structure
        //

        dwSize = sizeof ( RTM_ROUTE_INFO ) +
                 ( g_rrpRtmProfile.MaxNextHopsInRoute - 1 ) *
                 sizeof( RTM_NEXTHOP_HANDLE );

        prri = MGM_ALLOC( dwSize );

        if ( prri == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            TRACE1( ANY, "Failed to allocate route info, size : %x", dwSize );

            break;
        }

        //
        // Lock destination
        //

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );

            break;
        }

        bUnLock = TRUE;


        //
        // Get Opaque pointer
        //

        dwErr = RtmGetOpaqueInformationPointer(
                    g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

            break;
        }


        //
        // Unmark dest if there are no MFEs that depend on it.
        //

        if ( *( ( PBYTE * ) pbOpaqueInfo ) == NULL )
        {
            bUnMark = TRUE;

            break;
        }

        pmllMfeList = (PMGM_LOCKED_LIST) *( ( PBYTE * ) pbOpaqueInfo );


        //
        // get route ref list lock
        //

        ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


        //
        // Unlock dest
        //

        bUnLock = FALSE;

        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle, TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );

            break;
        }

        //
        // Get the route info for the best UNICAST route on dest
        //

        dwErr = RtmGetRouteInfo(
                    g_hRtmHandle, prdi ->ViewInfo[ 0 ].Route, prri, NULL);

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed route info : %x", dwErr);

            break;
        }

        //
        // For each Reference, check if NEXTHOP is still present
        //

        for ( ple = pmllMfeList-> leHead.Flink;
              ple != &pmllMfeList-> leHead; )
        {
            prre = CONTAINING_RECORD( ple, ROUTE_REFERENCE_ENTRY, leRefList );

            for ( dwInd = 0; dwInd < prri-> NextHopsList.NumNextHops; dwInd++ )
            {
                bFound = FALSE;

                if ( prre-> hNextHop == prri-> NextHopsList.NextHops[ dwInd ] )
                {
                    //
                    // OK next hop still present, nothing further needs
                    // to be done
                    //

                    bFound = TRUE;
                    break;
                }
            }


            //
            // if NEXTHOP is not present
            //

            if ( !bFound )
            {
                pleTemp = ple-> Flink;

                //
                // Delete the reference and the corresponding MFE
                //

                RemoveEntryList( ple );

                DeleteMfeAndRefs( ple );

                ple = pleTemp;
            }

            else
            {
                ple = ple-> Flink;
            }

        }

        //
        // Release the route info
        //

        dwErr = RtmReleaseRouteInfo( g_hRtmHandle, prri );
        
        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to release route info : %x", dwErr );
        }

        //
        // if Ref list is empty, it needs to be deleted too.
        //

        if ( IsListEmpty( &pmllMfeList-> leHead ) )
        {
            //
            // to delete the opaque pointer, the dest needs to be locked
            // (via RtmLockDestination)
            //
            // the dest lock is held before locking the route reference
            // list ( via ACQUIRE_ROUTE_LOCK_EXCLUSIVE )
            //
            // At this point in the code, the route reference is locked
            // but the dest is not locked.
            //
            // To lock it, the route reference lock is first released
            // (via RELEASE_ROUTE_LOCK_EXCLUSIVE).
            //
            // The opaque pointer is then acquired, route ref list locked,
            // and double checked for emptiness.  This round-about ensures
            // that the route ref is not deleted while there are threads
            // waiting on its lock.  This can happen since the dest lock
            // is not held for most of the operations here
            //

            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // Lock dest
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle, prdi-> DestHandle, TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock dest : %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get Opaque pointer again
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, prdi-> DestHandle, &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR || ((* ((PBYTE *)pbOpaqueInfo) == NULL)) )
            {
                TRACE1( ANY, "Failed to get opaque ptr : %x", dwErr );

                break;
            }


            //
            // Get ref. list and lock it.
            //

            pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE * ) pbOpaqueInfo );

            //
            // Ensure that the list still exists.  it is possible (though
            // the chances are small) that this list may have been freed
            //

            if ( pmllMfeList == NULL )
            {
                TRACE0(
                    ANY, "ProcessRouteUpdate : Route ref list already freed"
                    );

                break;
            }

            ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );


            //
            // If list is still empty
            //

            if ( IsListEmpty( &pmllMfeList-> leHead ) )
            {
                //
                // Clear opaque pointer info
                //

                *( ( PBYTE * ) pbOpaqueInfo ) = NULL;

                //
                // release list lock
                //

                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                MGM_FREE( pmllMfeList );


                //
                // unmark the dest.  Change notifications for this
                // dest are no longer required.
                //

                bUnMark = TRUE;
            }

            else
            {
                RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
            }
        }

        else
        {
            RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
        }

    } while ( FALSE );


    //
    // Unlock dest
    //

    if ( bUnLock )
    {
        dwErr = RtmLockDestination(
                    g_hRtmHandle, prdi-> DestHandle,
                    TRUE, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to lock dest : %x", dwErr );
        }
    }


    //
    // Unmark dest
    //

    if ( bUnMark )
    {
        dwErr = RtmMarkDestForChangeNotification(
                    g_hRtmHandle, g_hNotificationHandle,
                    prdi-> DestHandle, FALSE
                    );

        if ( dwErr != NO_ERROR )
        {
            TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
        }
    }

    //
    // Free allocations
    //

    if ( prri )
    {
        MGM_FREE( prri );
    }

    return dwErr;
}



VOID
DeleteMfeAndRefs(
    PLIST_ENTRY     ple
    )
{
    DWORD                   dwInIfIndex = 0, dwInIfNextHopAddr = 0, dwIfBucket;

    PROUTE_REFERENCE_ENTRY  prre;

    PIF_ENTRY               pie = NULL;

    PIF_REFERENCE_ENTRY     pire = NULL;


    //
    // Get the reference entry
    //

    prre = CONTAINING_RECORD(
                ple, ROUTE_REFERENCE_ENTRY, leRefList
                );

    //
    // Look up and delete the MFE
    //

    LookupAndDeleteYourMfe(
        prre-> dwSourceAddr, prre-> dwSourceMask,
        prre-> dwGroupAddr, prre-> dwGroupMask,
        TRUE, &dwInIfIndex, &dwInIfNextHopAddr
        );


    //
    // Find incoming interface and delete ref from there too.
    //

	if ( dwInIfIndex != 0 )
	{
	    dwIfBucket = IF_TABLE_HASH( dwInIfIndex );

	    ACQUIRE_IF_LOCK_E