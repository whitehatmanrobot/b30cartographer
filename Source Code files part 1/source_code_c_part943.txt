// parse out the EventIdentifier phrase
		if( CWbemClassObject::GetPropertyValueFromString(sQuery,IDS_STRING_MOF_EVENTID,m_sEventID) )
		{
			m_bEventID = TRUE;
		}

		// parse out the SourceName
		if( CWbemClassObject::GetPropertyValueFromString(sQuery,IDS_STRING_MOF_SOURCENAME,m_sSource) )
		{
			m_bSource = TRUE;
		}

		// parse out the CategoryString
		if( CWbemClassObject::GetPropertyValueFromString(sQuery,IDS_STRING_MOF_CATEGORYSTRING,m_sCategory) )
		{
			m_bCategory = TRUE;
		}

		// parse out the User
		if( CWbemClassObject::GetPropertyValueFromString(sQuery,IDS_STRING_MOF_USER,m_sUser) )
		{
			m_bUser = TRUE;
		}
	}

	// Get require reset
	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	UpdateData(FALSE);

	delete pClassObject;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPNtEventPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPNtEventPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPNtEventPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPNtEventPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPNtEventPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       

                /*
	            m_bCategory = FALSE;
	            m_bError = FALSE;
	            m_bEventID = FALSE;
	            m_bFailure = FALSE;
	            m_bInformation = FALSE;
	            m_bRequireReset = TRUE;
	            m_bSource = FALSE;
	            m_bSuccess = FALSE;
	            m_bUser = FALSE;
	            m_bWarning = FALSE;
	            m_sCategory = _T("");
	            m_sEventID = _T("");
	            m_sSource = _T("");
	            m_sUser = _T("");
	            m_sLogFile = _T("");
                */

                CString sType;
                CString sNewName;

                // Format the name
                //------------------------

                if ((m_bError) &&
                   ((!m_bWarning) && (!m_bInformation) && (!m_bSuccess) && (!m_bFailure)))
                {
                    sType.LoadString(IDS_NTEVENT_TYPE_ERRORS);
                }
                else if (((m_bError) && (m_bWarning)) &&
                        ((!m_bInformation) && (!m_bSuccess) && (!m_bFailure)))
                {
                    sType.LoadString(IDS_NTEVENT_TYPE_ERRORS_AND_WARNINGS);
                }
                else
                {
                    sType.LoadString(IDS_NTEVENT_TYPE_EVENTS);
                }


                if ((!m_bError) && (!m_bWarning) && (!m_bInformation) && (!m_bSuccess) && (!m_bFailure))
                {
                    sNewName.Format(IDS_NTEVENT_NEWNAME_EVENTLOG,m_sLogFile);
                }
                else if ((!m_sSource.IsEmpty()) && (m_sEventID.IsEmpty()))
                {
                    sNewName.Format(IDS_NTEVENT_NEWNAME,m_sSource,sType,m_sLogFile);
                }
                else if (!m_sEventID.IsEmpty())
                {
                    sNewName.Format(IDS_NTEVENT_NEWNAME_EVENTID,m_sEventID,m_sLogFile);
                }
                else
                {
                    sNewName.Format(IDS_NTEVENT_NEWNAME_LOGNAME,m_sLogFile,sType);
                }


                if (!sNewName.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sNewName);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CDPNtEventPage::OnButtonTest() 
{
	// TODO: Add your control notification handler code here
	
}

void CDPNtEventPage::OnCheckCategory() 
{
	UpdateData();
	SetModified();	
}

void CDPNtEventPage::OnCheckEventid() 
{
	UpdateData();
	SetModified();		
}

void CDPNtEventPage::OnCheckSource() 
{
	UpdateData();
	SetModified();	
}

void CDPNtEventPage::OnCheckUser() 
{
	UpdateData();
	SetModified();	
}

BOOL CDPNtEventPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CString sQuery = IDS_STRING_MOF_EVENT_LOG_QUERY;

	CString sTemp;

	// parse out the LogFile
	sTemp.Format(_T(" AND TargetInstance.Logfile=\"%s\""), m_sLogFile);
	sQuery += sTemp;


	// parse out the Type phrases
	bool bAppendOr = false;
	if( m_bError )
	{
		sTemp = _T(" AND (TargetInstance.Type=\"error\"");
		bAppendOr = true;
		sQuery += sTemp;
	}

	if( m_bWarning )
	{
		sTemp = bAppendOr ? _T(" OR TargetInstance.Type=\"warning\"") : _T(" AND (TargetInstance.Type=\"warning\"");
		bAppendOr = true;
		sQuery += sTemp;
	}

	if( m_bInformation )
	{
		sTemp = bAppendOr ? _T(" OR TargetInstance.Type=\"information\"") : _T(" AND (TargetInstance.Type=\"information\"");
		bAppendOr = true;
		sQuery += sTemp;
	}

	if( m_bSuccess )
	{
		sTemp = bAppendOr ? _T(" OR TargetInstance.Type=\"audit success\"") : _T(" AND (TargetInstance.Type=\"audit success\"");
		bAppendOr = true;
		sQuery += sTemp;
	}

	if( m_bFailure )
	{
		sTemp = bAppendOr ? _T(" OR TargetInstance.Type=\"audit failure\"") : _T(" AND (TargetInstance.Type=\"audit failure\"");
		bAppendOr = true;
		sQuery += sTemp;
	}

	if (bAppendOr)
		sQuery += _T(")");

	// parse out the EventIdentifier phrase
	if( m_bEventID )
	{
		sTemp.Format(_T(" AND TargetInstance.EventIdentifier=%s"), m_sEventID);
		sQuery += sTemp;
	}

	// parse out the SourceName
	if( m_bSource )
	{
		sTemp.Format(_T(" AND TargetInstance.SourceName=\"%s\""), m_sSource);
		sQuery += sTemp;
	}

	// parse out the CategoryString
	if( m_bCategory )
	{
		sTemp.Format(_T(" AND TargetInstance.CategoryString=\"%s\""), m_sCategory);
		sQuery += sTemp;
	}

	// parse out the User
	if( m_bUser )
	{
		sTemp.Format(_T(" AND TargetInstance.User=\"%s\""), m_sUser);
		sQuery += sTemp;
	}

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	pClassObject->SetProperty(IDS_STRING_MOF_QUERY,sQuery);

    /* 63128
	CStringArray saPropertyNames;
	saPropertyNames.Add(_T("EventIdentifier"));
	saPropertyNames.Add(_T("SourceName"));
	saPropertyNames.Add(_T("Type"));
	saPropertyNames.Add(_T("CategoryString"));
	saPropertyNames.Add(_T("User"));
	saPropertyNames.Add(_T("LogFile"));
	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saPropertyNames);*/

	CString sNamespace = _T("root\\cimv2");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPNtEventPage::OnCheckError() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnCheckFailure() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnCheckInformation() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnCheckRequireReset() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnCheckSuccess() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnCheckWarning() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnEditchangeComboLogFile() 
{
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnChangeEditCategory() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnChangeEditEventid() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnChangeEditSource() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}

void CDPNtEventPage::OnChangeEditUser() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpnteventpage.h ===
#if !defined(AFX_DPNTEVENTPAGE_H__0708329E_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPNTEVENTPAGE_H__0708329E_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPNtEventPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPNtEventPage dialog

class CDPNtEventPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPNtEventPage)

// Construction
public:
	CDPNtEventPage();
	~CDPNtEventPage();

// Dialog Data
	//{{AFX_DATA(CDPNtEventPage)
	enum { IDD = IDD_DATAPOINT_WINDOWSNTEVENT };
	CComboBox	m_LogFile;
	BOOL	m_bCategory;
	BOOL	m_bError;
	BOOL	m_bEventID;
	BOOL	m_bFailure;
	BOOL	m_bInformation;
	BOOL	m_bRequireReset;
	BOOL	m_bSource;
	BOOL	m_bSuccess;
	BOOL	m_bUser;
	BOOL	m_bWarning;
	CString	m_sCategory;
	CString	m_sEventID;
	CString	m_sSource;
	CString	m_sUser;
	CString	m_sLogFile;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPNtEventPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPNtEventPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonTest();
	afx_msg void OnCheckCategory();
	afx_msg void OnCheckEventid();
	afx_msg void OnCheckSource();
	afx_msg void OnCheckUser();
	afx_msg void OnCheckError();
	afx_msg void OnCheckFailure();
	afx_msg void OnCheckInformation();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnCheckSuccess();
	afx_msg void OnCheckWarning();
	afx_msg void OnEditchangeComboLogFile();
	afx_msg void OnChangeEditCategory();
	afx_msg void OnChangeEditEventid();
	afx_msg void OnChangeEditSource();
	afx_msg void OnChangeEditUser();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPNTEVENTPAGE_H__0708329E_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dphttppage.cpp ===
// DPHttpPage.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// History
//
// 03/03/00 v-marfin Added code to handle the selection of AuthType from
//                   the combobox.
//                   Changed handler for combobox  from ON_CBN_EDITCHANGE
//                   to ON_CBN_SELCHANGE since combobox is not type to
//                   respond to ON_CBN_EDITCHANGE and the Apply button was
//                   not being set.
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/16/00 v-marfin bug 60233 : Added EscapeSpecialChars() and UnEscapeSpecialChars() 
//                   functions and used to double any backslashes contained in strings 
//                   being passed to WMI in the Path. See OnApply(). And to remove those
//                   double backslashes upon reading back from WMI (see OnInitDialog())
// 03/22/00 v-marfin bug 60632 : converted timeout to a float value and displayed as
//                   seconds, storing and retrieving as milliseconds.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.
// 04/08/00 v-marfin bug 63116 : Convert and unconvert CRLF from post data and extra headers.
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "DPHttpPage.h"
#include "HMObject.h"
#include "HttpAdvancedDlg.h"
#include <math.h>
#include "SnapinDefines.h"  // v-marfin Bug 61451 
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#include "HealthmonResultsPane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPHttpPage property page

IMPLEMENT_DYNCREATE(CDPHttpPage, CHMPropertyPage)

CDPHttpPage::CDPHttpPage() : CHMPropertyPage(CDPHttpPage::IDD)
{
	//{{AFX_DATA_INIT(CDPHttpPage)
	m_bRequireReset = FALSE;
	m_bUseProxy = FALSE;
	m_sAuthentication = _T("");
	m_sPassword = _T("");
	m_sProxyAddress = _T("");
	m_sProxyPort = _T("");
	m_fTimeout = 30.0;
	m_sURL = _T("");
	m_sUserName = _T("");
	//}}AFX_DATA_INIT

	m_bFollowRedirects = TRUE;
	m_sMethod = _T("GET");
	m_sHelpTopic = _T("HMon21.chm::/dDEhttp.htm");

	m_iAuthType = 0;  // v-marfin Bug 61451 

}

CDPHttpPage::~CDPHttpPage()
{
}

void CDPHttpPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPHttpPage)
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Check(pDX, IDC_CHECK_USE_PROXY, m_bUseProxy);
	DDX_CBString(pDX, IDC_COMBO_AUTHENTICATION, m_sAuthentication);
	DDV_MaxChars(pDX, m_sAuthentication, 255);
	DDX_Text(pDX, IDC_EDIT_PASSWORD, m_sPassword);
	DDV_MaxChars(pDX, m_sPassword, 255);
	DDX_Text(pDX, IDC_EDIT_PROXY_ADDRESS, m_sProxyAddress);
	DDV_MaxChars(pDX, m_sProxyAddress, 255);
	DDX_Text(pDX, IDC_EDIT_PROXY_PORT, m_sProxyPort);
	DDV_MaxChars(pDX, m_sProxyPort, 255);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_fTimeout);
	DDX_Text(pDX, IDC_EDIT_URL, m_sURL);
	DDV_MaxChars(pDX, m_sURL, 512);
	DDX_Text(pDX, IDC_EDIT_USER_NAME, m_sUserName);
	DDV_MaxChars(pDX, m_sUserName, 255);
	//}}AFX_DATA_MAP

	if( m_bUseProxy )
	{
		GetDlgItem(IDC_EDIT_PROXY_ADDRESS)->EnableWindow();
		GetDlgItem(IDC_EDIT_PROXY_PORT)->EnableWindow();
	}
	else
	{
		GetDlgItem(IDC_EDIT_PROXY_ADDRESS)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_PROXY_PORT)->EnableWindow(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CDPHttpPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPHttpPage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
	ON_BN_CLICKED(IDC_CHECK_USE_PROXY, OnCheckUseProxy)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_CBN_SELCHANGE(IDC_COMBO_AUTHENTICATION, OnEditchangeComboAuthentication)
	ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnChangeEditPassword)
	ON_EN_CHANGE(IDC_EDIT_PROXY_ADDRESS, OnChangeEditProxyAddress)
	ON_EN_CHANGE(IDC_EDIT_PROXY_PORT, OnChangeEditProxyPort)
	ON_EN_CHANGE(IDC_EDIT_TIMEOUT, OnChangeEditTimeout)
	ON_EN_CHANGE(IDC_EDIT_URL, OnChangeEditUrl)
	ON_EN_CHANGE(IDC_EDIT_USER_NAME, OnChangeEditUserName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPHttpPage message handlers

BOOL CDPHttpPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();



	CHMPropertyPage::OnInitDialog();
	

	// v-marfin Bug 61451 
	// Load combobox
	LoadAuthTypeCombo();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
	
    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	CString sPath;
	pClassObject->GetProperty(IDS_STRING_MOF_PATH,sPath);

	if( ! sPath.IsEmpty() )
	{
		// parse out the Method property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("Method"),m_sMethod);

		// v-marfin Bug 61451 
		// parse out the AuthType property value and set appropriate value
		// in the dropdown combo
		CString sAuthType;
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("AuthType"),sAuthType);
		if( ! sAuthType.IsEmpty() )
		{
			m_iAuthType = _ttoi(sAuthType);
			SetAuthTypeCombo();
		}

		// parse out the Url property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("Url"),m_sURL);

        CSnapInApp* pApp = (CSnapInApp*) AfxGetApp();
		m_sURL = pApp->UnEscapeSpecialChars(m_sURL);  // v-marfin bug 60233

		// parse out the TimeoutSecs property value
		CString sTimeout;
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("TimeoutMSecs"),sTimeout);
		if( ! sTimeout.IsEmpty() )
		{
            // v-marfin: 60632
            // timeout is stored in milliseconds but we display in seconds so
            // adjust accordingly. 
			m_fTimeout = (float) _ttol(sTimeout);
            m_fTimeout /= 1000;
		}

		// parse out the AuthUser property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("AuthUser"),m_sUserName);

		m_sUserName = pApp->UnEscapeSpecialChars(m_sUserName);  // v-marfin bug 60233


		// parse out the AuthPassword property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("AuthPassword"),m_sPassword);
		m_sPassword = pApp->UnEscapeSpecialChars(m_sPassword);  // v-marfin bug 60233


		// parse out the ProxyServer property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("ProxyServer"),m_sProxyAddress);
		m_sProxyAddress = pApp->UnEscapeSpecialChars(m_sProxyAddress);  // v-marfin bug 60233

		if( ! m_sProxyAddress.IsEmpty() )
		{
			int iIndex = -1;
			m_bUseProxy =  m_sProxyAddress.IsEmpty() ? FALSE : TRUE;
			if( (iIndex = m_sProxyAddress.Find(_T(":"))) != -1 )
			{				
				m_sProxyPort = m_sProxyAddress.Right(m_sProxyAddress.GetLength()-iIndex-1);
				m_sProxyAddress = m_sProxyAddress.Left(iIndex);
			}
		}
	
		// parse out the ExtraHeaders property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("ExtraHeaders"),m_sExtraHeaders);
        m_sExtraHeaders = UnconvertSpecialChars(m_sExtraHeaders); // 63116

		// parse out the PostData property value
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("PostData"),m_sPostData);
        m_sPostData = UnconvertSpecialChars(m_sPostData); // 63116

		// parse out the FollowRedirects property value
		CString sFollowRedirects;
		CWbemClassObject::GetPropertyValueFromString(sPath,_T("FollowRedirects"),sFollowRedirects);		
		if( ! sFollowRedirects.IsEmpty() )
		{
			m_bFollowRedirects = _ttoi(sFollowRedirects);
		}

	}
	
	// set require reset
	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	delete pClassObject;

    // v-marfin 59579
    if (m_iAuthType == 0)
    {
        m_sUserName.Empty();
        m_sPassword.Empty();
        GetDlgItem(IDC_EDIT_USER_NAME)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_PASSWORD)->EnableWindow(FALSE);
    }

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPHttpPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPHttpPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPHttpPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPHttpPage::OnOK - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sURL.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sURL);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } 
        // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();

	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
}

void CDPHttpPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPHttpPage::OnButtonAdvanced() 
{
	CHttpAdvancedDlg dlg;

	dlg.m_bFollowRedirects = m_bFollowRedirects;
	dlg.m_sExtraHeaders = m_sExtraHeaders;
	dlg.m_sHTTPMethod = m_sMethod;
	dlg.m_sPostData = m_sPostData;

	if( dlg.DoModal() == IDOK )
	{
		m_bFollowRedirects = dlg.m_bFollowRedirects;
		m_sExtraHeaders = dlg.m_sExtraHeaders;
		m_sMethod = dlg.m_sHTTPMethod;
		m_sPostData = dlg.m_sPostData;
		SetModified();
	}
	
}

void CDPHttpPage::OnCheckUseProxy() 
{
	UpdateData();
	SetModified();
}

BOOL CDPHttpPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	CString sPath = _T("HTTPProvider.");

	// parse out the Method property value
	if( ! m_sMethod.IsEmpty() )
	{
		sPath += _T("Method=\"");
		sPath += m_sMethod;
		sPath += _T("\",");
	}

    CSnapInApp* pApp = (CSnapInApp*) AfxGetApp();

	// parse out the Url property value
	if( ! m_sURL.IsEmpty() )
	{
		sPath += _T("Url=\"");
		sPath += pApp->EscapeSpecialChars(m_sURL);  // v-marfin bug 60233
		sPath += _T("\",");
	}

	// parse out the TimeoutSecs property value

    // v-marfin: 60632
    // Since timeout is displayed seconds but stored in milliseconds, 
    // we need to multiply it by 1000.
    m_fTimeout = (float) fabs((double)(m_fTimeout * 1000));
	CString sTimeout;
	sTimeout.Format(_T("%d"),(int)m_fTimeout);
	sPath += _T("TimeoutMSecs=");
	sPath += sTimeout;
	sPath += _T(",");

    // v-marfin : 60632 
    // Now put m_fTimeout back to its original
    m_fTimeout /= 1000;

	// v-marfin Bug 61451 
	// parse out the AuthType property value 
	if (GetAuthTypeFromCombo())
	{
		CString sAuthType;
		sAuthType.Format(_T("%d"),m_iAuthType);
		sPath += _T("AuthType=");
		sPath += sAuthType;  
		sPath += _T(",");
	}


	// parse out the AuthUser property value
	if( ! m_sUserName.IsEmpty() )
	{
		sPath += _T("AuthUser=\"");
		sPath += pApp->EscapeSpecialChars(m_sUserName);  // v-marfin bug 60233
		sPath += _T("\",");
	}

	// parse out the AuthPassword property value
	if( ! m_sPassword.IsEmpty() )
	{
		sPath += _T("AuthPassword=\"");
		sPath += pApp->EscapeSpecialChars(m_sPassword);  // v-marfin bug 60233
		sPath += _T("\",");
	}

	// parse out the ProxyServer property value
	if( ! m_sProxyAddress.IsEmpty() && m_bUseProxy )
	{
		sPath += _T("ProxyServer=\"");
		sPath += pApp->EscapeSpecialChars(m_sProxyAddress) + _T(":") + m_sProxyPort;  // v-marfin bug 60233
		sPath += _T("\",");
	}

	// parse out the ExtraHeaders property value
	if( ! m_sExtraHeaders.IsEmpty() )
	{
		sPath += _T("ExtraHeaders=\"");
		sPath += ConvertSpecialChars(m_sExtraHeaders); // 63116
		sPath += _T("\",");
	}

	// parse out the PostData property value
	if( ! m_sPostData.IsEmpty() )
	{
		sPath += _T("PostData=\"");
		sPath += ConvertSpecialChars(m_sPostData); // 63116
		sPath += _T("\",");
	}

	// parse out the FollowRedirects property value
	CString sFollowRedirects;
	sFollowRedirects.Format(_T("%d"),m_bFollowRedirects);
	sPath += _T("FollowRedirects=");
	sPath += sFollowRedirects;

	pClassObject->SetProperty(IDS_STRING_MOF_PATH,sPath);

	// set target namespace
	CString sNamespace = _T("root\\cimv2\\MicrosoftHealthmonitor");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	// set statistics properties
	/* 63128 
    CStringArray saNames;
	saNames.Add(_T("StatusCode"));
	saNames.Add(_T("StatusText"));
	saNames.Add(_T("ContentLength"));
	saNames.Add(_T("TextResponse"));
	saNames.Add(_T("RawHeaders"));
	saNames.Add(_T("ContentType"));
	saNames.Add(_T("Cookie"));
	saNames.Add(_T("LastModified"));
	saNames.Add(_T("ResponseTime"));
	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saNames);*/	

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

	delete pClassObject;

    SetModified(FALSE);

	return TRUE;
}

void CDPHttpPage::OnCheckRequireReset() 
{
	SetModified();
}

void CDPHttpPage::OnEditchangeComboAuthentication() 
{
    // v-marfin 59579 : If "None" selected as authentication, disable the
    //                  Username and Password.
    UpdateData();

    GetAuthTypeFromCombo();
    BOOL bNoneSelected = (m_iAuthType == 0);
    
    if (bNoneSelected)
    {
        m_sUserName.Empty();
        m_sPassword.Empty();
    }

    UpdateData(FALSE);

    GetDlgItem(IDC_EDIT_USER_NAME)->EnableWindow(!bNoneSelected);
    GetDlgItem(IDC_EDIT_PASSWORD)->EnableWindow(!bNoneSelected);

	SetModified();
}

void CDPHttpPage::OnChangeEditPassword() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
}

void CDPHttpPage::OnChangeEditProxyAddress() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	

	SetModified();
	
}

void CDPHttpPage::OnChangeEditProxyPort() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	

	SetModified();

	
}

void CDPHttpPage::OnChangeEditTimeout() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();

	
}

void CDPHttpPage::OnChangeEditUrl() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
}

void CDPHttpPage::OnChangeEditUserName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
}


// v-marfin Bug 61451 
//*********************************************************
// SetAuthTypeCombo
//
// Set the combo box entry to the value corresponding with the
// member variable
//
// Parms: None
// Returns: TRUE - success
//          FALSE - failed
//*********************************************************
BOOL CDPHttpPage::SetAuthTypeCombo()
{
	int x=0;
	int nAuthType=0;
	int nCount=0;

	// Get a ptr to the combobox
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_AUTHENTICATION);
	if (!pBox)
	{
		_ASSERTE(FALSE);
		return FALSE;
	}

	// get the number of entries in the combo
	nCount = pBox->GetCount();

	// Search through each entry
	for (x=0; x<nCount; x++)
	{
		// Get the type of this entry
		nAuthType = (int)pBox->GetItemData(x);
		_ASSERTE(nAuthType != CB_ERR);

		// Is this entry type the one we want?
		if (nAuthType == m_iAuthType)
		{
			// yes. Set this as the selected item and get out
			pBox->SetCurSel(x);
			return TRUE;
		}
	}

	_ASSERTE(FALSE); // should never get here
	return FALSE;
}


// v-marfin Bug 61451 
//*********************************************************
// LoadAuthTypeCombo
//
// Loads the combo box from predefined values and sets the
// data item associated with each item to its associated value.
//
// Since the combo is NOT sorted, set the 1st entry to "selected"
// upon loading it. Later in the initialization, if the user
// had saved a previous value it will be set to that.
//
// Parms: None
// Returns: None
//*********************************************************
void CDPHttpPage::LoadAuthTypeCombo()
{
	int nRet=0;

	// Load the combo in the following order:
	/*
#define AUTHTYPE_VALUE_NONE_STRING			_T("None")
#define AUTHTYPE_VALUE_BASIC_STRING			_T("Clear Text (Basic)")
#define AUTHTYPE_VALUE_NEGOTIATE_STRING		_T("Windows Default (Negotiate)")	
#define AUTHTYPE_VALUE_NTLM_STRING			_T("NTLM")
#define AUTHTYPE_VALUE_DIGEST_STRING		_T("Digest")	
#define AUTHTYPE_VALUE_KERBEROS_STRING		_T("Kerberos")
	*/


	// Get a ptr to the combobox
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_AUTHENTICATION);
	if (!pBox)
	{
		_ASSERTE(FALSE);
		return;
	}

	// Empty it
	pBox->ResetContent();

	// Load it

	// AuthType None
	nRet = pBox->AddString(AUTHTYPE_VALUE_NONE_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_NONE);
	}

	// AuthType Basic
	nRet = pBox->AddString(AUTHTYPE_VALUE_BASIC_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_BASIC);
	}

	// AuthType Negotiate
	nRet = pBox->AddString(AUTHTYPE_VALUE_NEGOTIATE_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_NEGOTIATE);
	}

	// AuthType NTLM
	nRet = pBox->AddString(AUTHTYPE_VALUE_NTLM_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_NTLM);
	}


	// AuthType Digest
	nRet = pBox->AddString(AUTHTYPE_VALUE_DIGEST_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_DIGEST);
	}
	
	
	// AuthType Kerberos
	nRet = pBox->AddString(AUTHTYPE_VALUE_KERBEROS_STRING);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return;
	}
	else
	{
		pBox->SetItemData(nRet,AUTHTYPE_VALUE_KERBEROS);
	}



	// Set the 1st entry as selected by default ("None")
	pBox->SetCurSel(0);
}

// v-marfin Bug 61451 
//*********************************************************
// GetAuthTypeFromCombo
//
// Gets the numeric value of the currently selected AuthType
// from the combobox
//
// Parms: None
// Returns: TRUE - success
//          FALSE - failed
//*********************************************************
BOOL CDPHttpPage::GetAuthTypeFromCombo()
{
	// Get a ptr to the combobox
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_AUTHENTICATION);
	if (!pBox)
	{
		_ASSERTE(FALSE);
		return FALSE;
	}

	// Get the current selection. 
	int nRet = pBox->GetCurSel();
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return FALSE;
	}

	// Get the authtype of the selected item
	nRet = (int)pBox->GetItemData(nRet);
	if (nRet == CB_ERR)
	{
		_ASSERTE(FALSE);
		return FALSE;
	}

	// OK. Set our local member to it.
	m_iAuthType = nRet;

	return TRUE;
}

//***************************************************************
// ConvertSpecialChars  63116  Converts \r\n to "%0D%0A" and adds trailing "%0D%0A"
//***************************************************************
CString CDPHttpPage::ConvertSpecialChars(const CString &sString)
{
    CString sRet;
    int nPos=0;
    CString sCRLF = _T("\r\n");
    CString sFormattedCRLF = _T("%0D%0A");

    if (sString.IsEmpty())
        return sRet;

    CString sWrk = sString;

    // remove any leading / trailing crlf
    while (sWrk.Right(sCRLF.GetLength()).CompareNoCase(sCRLF)==0)
    {
        sWrk = sWrk.Left(sWrk.GetLength()-sCRLF.GetLength());
    }
    while (sWrk.Left(sCRLF.GetLength()).CompareNoCase(sCRLF)==0)
    {
        sWrk = sWrk.Mid(sCRLF.GetLength());
    }

    while (sWrk.GetLength())
    {
        nPos = sWrk.Find(sCRLF);
        if (nPos == -1)
            break;

        sRet += sWrk.Mid(0,nPos); // take chars before CRLF
        sRet += sFormattedCRLF;   // add "%0D%0A"

        sWrk = sWrk.Mid(nPos+sCRLF.GetLength());
    }

    // Add final 
    sRet += sWrk;
    sRet += sFormattedCRLF;

    return sRet;
}

//***************************************************************
// UnconvertSpecialChars  63116 converts "%0D%0A" to \r\n and removes trailing "%0D%0A"
//***************************************************************
CString CDPHttpPage::UnconvertSpecialChars(const CString &sString)
{
    CString sRet;
    int nPos=0;
    CString sCRLF = _T("\r\n");
    CString sFormattedCRLF = _T("%0D%0A");

    if (sString.IsEmpty())
        return sRet;

    CString sWrk = sString;

    // remove any leading / trailing "%0D%0A"
    while (sWrk.Right(sFormattedCRLF.GetLength()).CompareNoCase(sFormattedCRLF)==0)
    {
        sWrk = sWrk.Left(sWrk.GetLength()-sFormattedCRLF.GetLength());
    }
    while (sWrk.Left(sFormattedCRLF.GetLength()).CompareNoCase(sFormattedCRLF)==0)
    {
        sWrk = sWrk.Mid(sFormattedCRLF.GetLength());
    }

    while (sWrk.GetLength())
    {
        nPos = sWrk.Find(sFormattedCRLF);
        if (nPos == -1)
            break;

        sRet += sWrk.Mid(0,nPos);   // take chars before "%0D%0A"
        sRet += sCRLF;              // add "\r\n"

        sWrk = sWrk.Mid(nPos+sFormattedCRLF.GetLength());
    }

    // Add final 
    sRet += sWrk;

    // Remove trailing
    while (sRet.Right(sCRLF.GetLength()).CompareNoCase(sCRLF)==0)
    {
        sRet = sRet.Left(sRet.GetLength()-sCRLF.GetLength());
    }

    return sRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpicmppage.h ===
#if !defined(AFX_DPICMPPAGE_H__342597AF_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
#define AFX_DPICMPPAGE_H__342597AF_96F7_11D3_BE93_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPIcmpPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPIcmpPage dialog

class CDPIcmpPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPIcmpPage)

// Construction
public:
	CDPIcmpPage();
	~CDPIcmpPage();

// Dialog Data
	//{{AFX_DATA(CDPIcmpPage)
	enum { IDD = IDD_DATAPOINT_ICMP };
	BOOL	m_bRequireReset;
	CString	m_sRetryCount;
	CString	m_sServer;
	CString	m_sTimeout;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPIcmpPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPIcmpPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnChangeEditServer();
	afx_msg void OnButtonBrowseSystem();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPICMPPAGE_H__342597AF_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpperfmonpage.cpp ===
// DPPerfMonPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/20/00 v-marfin bug 61372 : Display error message if user attempts to close
//                               dialog with no counters present in the list.
// 03/22/00 v-marfin bug 62317 : Display error message if user attempts to close
//                               dialog with no counters selected in the list.
// 03/22/00 v-marfin bug 60766 : Set proper dlg title for object being browsed.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.

#include "stdafx.h"
#include "snapin.h"
#include "DPPerfMonPage.h"
#include "HMObject.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPPerfMonPage property page

IMPLEMENT_DYNCREATE(CDPPerfMonPage, CHMPropertyPage)

CDPPerfMonPage::CDPPerfMonPage() : CHMPropertyPage(CDPPerfMonPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CDPPerfMonPage)
	m_bRequireReset = FALSE;
	m_sInstance = _T("");
	m_sObject = _T("");
	//}}AFX_DATA_INIT
	m_bNT5Perfdata = false;

	m_sHelpTopic = _T("HMon21.chm::/dDEperf.htm");
}

CDPPerfMonPage::~CDPPerfMonPage()
{
}

void CDPPerfMonPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CDPPerfMonPage::UpdateProperties()
{
	m_Properties.DeleteAllItems();

	if( m_sObject.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + m_sNamespace);

	HRESULT hr = classobject.GetObject(m_sObject);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		m_Properties.InsertItem(0,saNames[i]);
	}

	m_Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

void CDPPerfMonPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPPerfMonPage)
	DDX_Control(pDX, IDC_LIST_PROPERTIES, m_Properties);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_INSTANCE, m_sInstance);
	DDX_Text(pDX, IDC_EDIT_OBJECT, m_sObject);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPPerfMonPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPPerfMonPage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_INSTANCE, OnButtonBrowseInstance)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_OBJECT, OnButtonBrowseObject)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_EN_CHANGE(IDC_EDIT_INSTANCE, OnChangeEditInstance)
	ON_EN_CHANGE(IDC_EDIT_OBJECT, OnChangeEditObject)
	ON_NOTIFY(NM_CLICK, IDC_LIST_PROPERTIES, OnClickListProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDPPerfMonPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CDPPerfMonPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDPPerfMonPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {52566158-C9D1-11D2-BD8D-0000F87A3912}
static const IID IID_IDPPerfMonPage =
{ 0x52566158, 0xc9d1, 0x11d2, { 0xbd, 0x8d, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CDPPerfMonPage, CHMPropertyPage)
	INTERFACE_PART(CDPPerfMonPage, IID_IDPPerfMonPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPPerfMonPage message handlers

BOOL CDPPerfMonPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_Properties.SetExtendedStyle(LVS_EX_CHECKBOXES);

	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_Properties.InsertColumn(0,sColumnTitle);


	m_sNamespace = _T("root\\cimv2\\MicrosoftHealthmonitor");

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
	

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	pClassObject->GetProperty(IDS_STRING_MOF_PATH,m_sObject);

	int iIndex = -1;
	if( (iIndex = m_sObject.Find(_T("."))) != -1 )
	{
		m_sInstance = m_sObject;
		m_sObject = m_sObject.Left(iIndex);
	}

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	UpdateProperties();

	CStringArray saCounters;
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saCounters);
	for( int i=0; i < saCounters.GetSize(); i++ )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = saCounters[i];
		int iListIndex = m_Properties.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
			m_Properties.SetCheck(iListIndex);
		}
	}

	delete pClassObject;

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPPerfMonPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPPerfMonPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPPerfMonPage::OnOK - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPPerfMonPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------



            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CDPPerfMonPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPPerfMonPage::OnButtonBrowseInstance() 
{
	CWmiInstanceBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_INSTANCES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the instance enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);

	BSTR bsTemp = m_sObject.AllocSysString();
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sInstance = dlg.m_sSelectedItem;
		UpdateData(FALSE);		
		SetModified();
	}	
}

void CDPPerfMonPage::OnButtonBrowseObject() 
{
	CWmiClassBrowseDlg dlg;	

    // v-marfin 60766 : Set proper dlg title for object being browsed
	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_OBJECTS);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the class enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);
	
	sTemp = _T("Win32_PerfFormattedData");
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateClassEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sObject = dlg.m_sSelectedItem;
		m_sInstance.Empty();
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
	}	
}

BOOL CDPPerfMonPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	if( m_Properties.GetItemCount() <= 0 )
	{
		// v-marfin 61372 : Add err msg so user knows what is going on.
		AfxMessageBox(IDS_ERR_MUST_CREATE_ATLEAST_ONE_COUNTER);
		return FALSE;
	}

	CStringArray saCounters;

	for( int i = 0; i < m_Properties.GetItemCount(); i++ )
	{
		if( m_Properties.GetCheck(i) )
		{			
			saCounters.Add(m_Properties.GetItemText(i,0));
		}
	}

	if( ! saCounters.GetSize() )
    {
		// v-marfin 62317 : Add err msg so user knows what is going on.
		AfxMessageBox(IDS_ERR_MUST_SELECT_ATLEAST_ONE_COUNTER);
		return FALSE;
    }

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sNamespace);

	if( m_sInstance.IsEmpty() )
	{
		pClassObject->SetProperty(IDS_STRING_MOF_PATH,m_sObject);
	}
	else
	{
		pClassObject->SetProperty(IDS_STRING_MOF_PATH,m_sInstance);
	}

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saCounters);


	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

  delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPPerfMonPage::OnCheckRequireReset() 
{
	UpdateData();
	SetModified();
	
}

void CDPPerfMonPage::OnChangeEditInstance() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();

	
}

void CDPPerfMonPage::OnChangeEditObject() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	UpdateProperties();
	
}

void CDPPerfMonPage::OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpschedulepage.h ===
#if !defined(AFX_DPSCHEDULEPAGE_H__E7CF55CD_E208_11D2_BDAD_0000F87A3912__INCLUDED_)
#define AFX_DPSCHEDULEPAGE_H__E7CF55CD_E208_11D2_BDAD_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPSchedulePage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPSchedulePage dialog

class CDPSchedulePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPSchedulePage)

// Construction
public:
	CDPSchedulePage();
	~CDPSchedulePage();

// Dialog Data
	//{{AFX_DATA(CDPSchedulePage)
	enum { IDD = IDD_DATAPOINT_SCHEDULE };
	CDateTimeCtrl	m_StartTimeCtrl2;
	CDateTimeCtrl	m_StartTimeCtrl1;
	CDateTimeCtrl	m_EndTimeCtrl2;
	CDateTimeCtrl	m_EndTimeCtrl1;
	CSpinButtonCtrl	m_Spin2;
	CSpinButtonCtrl	m_Spin1;
	CComboBox	m_Units;
	BOOL	m_bFriday;
	BOOL	m_bMonday;
	BOOL	m_bSaturday;
	BOOL	m_bSunday;
	BOOL	m_bThursday;
	BOOL	m_bTuesday;
	BOOL	m_bWednesday;
	CTime	m_EndTime_1;
	CTime	m_EndTime_2;
	CTime	m_StartTime_1;
	CTime	m_StartTime_2;	
	int		m_iTotalSamples;
	int		m_iDataCollection;
	int		m_iCollectionIntervalTime;
	//}}AFX_DATA

	int m_iActiveDays;
	int	m_iCollectionInterval;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPSchedulePage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPSchedulePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioAllDay();
	afx_msg void OnRadioAllDayExcept();
	afx_msg void OnRadioOnceDaily();
	afx_msg void OnRadioOnlyFrom();
	afx_msg void OnCheckFriday();
	afx_msg void OnCheckMonday();
	afx_msg void OnCheckSaturday();
	afx_msg void OnCheckSunday();
	afx_msg void OnCheckThursday();
	afx_msg void OnCheckTuesday();
	afx_msg void OnCheckWednesday();
	afx_msg void OnDatetimechangeDatetimepickerEnd1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerEnd2(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerOnce(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerStart1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerStart2(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditTotalSamples();
	afx_msg void OnChangeEditDataCollectInterval();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPSCHEDULEPAGE_H__E7CF55CD_E208_11D2_BDAD_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpschedulepage.cpp ===
// DPSchedulePage.cpp : implementation file
//
// Copyright (c) Microsoft Corporation
//
// 03/24/00 v-marfin 62368 : fix for hours to seconds conversion.
//
//
#include "stdafx.h"
#include "snapin.h"
#include "DPSchedulePage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPSchedulePage property page

IMPLEMENT_DYNCREATE(CDPSchedulePage, CHMPropertyPage)

CDPSchedulePage::CDPSchedulePage() : CHMPropertyPage(CDPSchedulePage::IDD)
{
	//{{AFX_DATA_INIT(CDPSchedulePage)
	m_bFriday = FALSE;
	m_bMonday = FALSE;
	m_bSaturday = FALSE;
	m_bSunday = FALSE;
	m_bThursday = FALSE;
	m_bTuesday = FALSE;
	m_bWednesday = FALSE;
	m_EndTime_1 = CTime::GetCurrentTime();
	m_EndTime_2 = CTime::GetCurrentTime();
	m_StartTime_1 = CTime::GetCurrentTime();
	m_StartTime_2 = CTime::GetCurrentTime();
	m_iTotalSamples = 0;
	m_iDataCollection = -1;
	m_iCollectionIntervalTime = 0;
	//}}AFX_DATA_INIT
	
	m_sHelpTopic = _T("HMon21.chm::dDEsched.htm");
}

CDPSchedulePage::~CDPSchedulePage()
{
}

void CDPSchedulePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CDPSchedulePage)
	DDX_Control(pDX, IDC_DATETIMEPICKER_START_2, m_StartTimeCtrl2);
	DDX_Control(pDX, IDC_DATETIMEPICKER_START_1, m_StartTimeCtrl1);
	DDX_Control(pDX, IDC_DATETIMEPICKER_END_2, m_EndTimeCtrl2);
	DDX_Control(pDX, IDC_DATETIMEPICKER_END_1, m_EndTimeCtrl1);
	DDX_Control(pDX, IDC_SPIN2, m_Spin2);
	DDX_Control(pDX, IDC_SPIN1, m_Spin1);
	DDX_Control(pDX, IDC_COMBO_UNITS, m_Units);
	DDX_Check(pDX, IDC_CHECK_FRIDAY, m_bFriday);
	DDX_Check(pDX, IDC_CHECK_MONDAY, m_bMonday);
	DDX_Check(pDX, IDC_CHECK_SATURDAY, m_bSaturday);
	DDX_Check(pDX, IDC_CHECK_SUNDAY, m_bSunday);
	DDX_Check(pDX, IDC_CHECK_THURSDAY, m_bThursday);
	DDX_Check(pDX, IDC_CHECK_TUESDAY, m_bTuesday);
	DDX_Check(pDX, IDC_CHECK_WEDNESDAY, m_bWednesday);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_1, m_EndTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_2, m_EndTime_2);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_1, m_StartTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_2, m_StartTime_2);
	DDX_Text(pDX, IDC_EDIT_TOTAL_SAMPLES, m_iTotalSamples);
	DDX_Radio(pDX, IDC_RADIO_ALL_DAY, m_iDataCollection);
	DDX_Text(pDX, IDC_EDIT_DATA_COLLECT_INTERVAL, m_iCollectionIntervalTime);
	//}}AFX_DATA_MAP

	if( pDX->m_bSaveAndValidate )
	{
		m_iActiveDays = 0;

		if( m_bSunday )
		{
			m_iActiveDays |= 0x00000001;
		}

		if( m_bMonday )
		{
			m_iActiveDays |= 0x00000002;
		}

		if( m_bTuesday )
		{
			m_iActiveDays |= 0x00000004;
		}

		if( m_bWednesday )
		{
			m_iActiveDays |= 0x00000008;
		}

		if( m_bThursday )
		{
			m_iActiveDays |= 0x00000010;
		}

		if( m_bFriday )
		{
			m_iActiveDays |= 0x00000020;
		}

		if( m_bSaturday )
		{
			m_iActiveDays |= 0x00000040;
		}
	}


	switch( m_iDataCollection )
	{
		case 0:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

		case 1:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(TRUE);
		}
		break;

		case 2:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

	}

}

BEGIN_MESSAGE_MAP(CDPSchedulePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPSchedulePage)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY, OnRadioAllDay)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY_EXCEPT, OnRadioAllDayExcept)
	ON_BN_CLICKED(IDC_RADIO_ONCE_DAILY, OnRadioOnceDaily)
	ON_BN_CLICKED(IDC_RADIO_ONLY_FROM, OnRadioOnlyFrom)
	ON_BN_CLICKED(IDC_CHECK_FRIDAY, OnCheckFriday)
	ON_BN_CLICKED(IDC_CHECK_MONDAY, OnCheckMonday)
	ON_BN_CLICKED(IDC_CHECK_SATURDAY, OnCheckSaturday)
	ON_BN_CLICKED(IDC_CHECK_SUNDAY, OnCheckSunday)
	ON_BN_CLICKED(IDC_CHECK_THURSDAY, OnCheckThursday)
	ON_BN_CLICKED(IDC_CHECK_TUESDAY, OnCheckTuesday)
	ON_BN_CLICKED(IDC_CHECK_WEDNESDAY, OnCheckWednesday)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_END_1, OnDatetimechangeDatetimepickerEnd1)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_END_2, OnDatetimechangeDatetimepickerEnd2)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_ONCE, OnDatetimechangeDatetimepickerOnce)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_START_1, OnDatetimechangeDatetimepickerStart1)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_START_2, OnDatetimechangeDatetimepickerStart2)
	ON_EN_CHANGE(IDC_EDIT_TOTAL_SAMPLES, OnChangeEditTotalSamples)
	ON_EN_CHANGE(IDC_EDIT_DATA_COLLECT_INTERVAL, OnChangeEditDataCollectInterval)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPSchedulePage message handlers

BOOL CDPSchedulePage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();
	
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// get the active days
	pClassObject->GetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// get the begin time
	int iBeginHour;
	int iBeginMinute;
	CString sBeginTime;

	pClassObject->GetProperty(IDS_STRING_MOF_BEGINTIME,sBeginTime);

	if( sBeginTime.IsEmpty() )
	{
		iBeginHour = 0;
		iBeginMinute = 0;
	}
	else
	{
		sBeginTime = sBeginTime.Right(17);
		sBeginTime = sBeginTime.Left(4);
		_stscanf(sBeginTime,_T("%02d%02d"), &iBeginHour, &iBeginMinute);
	}	

	// get the end time
	int iEndHour;
	int iEndMinute;
	CString sEndTime;

	pClassObject->GetProperty(IDS_STRING_MOF_ENDTIME,sEndTime);

	if( sEndTime.IsEmpty() )
	{
		iEndHour = 23;
		iEndMinute = 59;
	}
	else
	{
		sEndTime = sEndTime.Right(17);
		sEndTime = sEndTime.Left(4);

		_stscanf(sEndTime,_T("%02d%02d"), &iEndHour, &iEndMinute);
	}

	pClassObject->GetProperty(IDS_STRING_MOF_COLLECTIONINTERVAL,m_iCollectionInterval);

	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSWINDOW,m_iTotalSamples);

	delete pClassObject;
	pClassObject = NULL;

	m_iCollectionIntervalTime = m_iCollectionInterval;

	if( iBeginHour == 0 && iBeginMinute == 0 && iEndHour == 23 && iEndMinute == 59 )
	{
		m_iDataCollection = 0;
	}
	else if( iBeginHour > iEndHour )
	{
		m_iDataCollection = 2;
		m_EndTime_2 = CTime(1999,12,31,iBeginHour,iBeginMinute,0);
		m_StartTime_2 = CTime(1999,12,31,iEndHour,iEndMinute,0);
	}
	else
	{
		m_iDataCollection = 1;
		m_StartTime_1 = CTime(1999,12,31,iBeginHour,iBeginMinute,0);
		m_EndTime_1 = CTime(1999,12,31,iEndHour,iEndMinute,0);
	}

	if( m_iActiveDays & 0x00000001 )
	{
		m_bSunday = TRUE;
	}

	if( m_iActiveDays & 0x00000002 )
	{
		m_bMonday = TRUE;
	}

	if( m_iActiveDays & 0x00000004 )
	{
		m_bTuesday = TRUE;
	}

	if( m_iActiveDays & 0x00000008 )
	{
		m_bWednesday = TRUE;
	}

	if( m_iActiveDays & 0x00000010 )
	{
		m_bThursday = TRUE;
	}

	if( m_iActiveDays & 0x00000020 )
	{
		m_bFriday = TRUE;
	}

	if( m_iActiveDays & 0x00000040 )
	{
		m_bSaturday = TRUE;
	}

	m_Units.SetCurSel(0);

	m_Spin1.SetRange32(0,INT_MAX-1);
	m_Spin2.SetRange32(0,INT_MAX-1);

	CString sTimeFormat;
	int iLen = GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STIMEFORMAT,NULL,0);
	GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STIMEFORMAT,sTimeFormat.GetBuffer(iLen+1),iLen);
	sTimeFormat.ReleaseBuffer();

	int iIndex = sTimeFormat.Find(_T(":ss"));
	if( iIndex != -1 )
	{
		sTimeFormat.Delete(iIndex,3);
	}

	iIndex = sTimeFormat.Find(_T(":s"));
	if( iIndex != -1 )
	{
		sTimeFormat.Delete(iIndex,2);
	}

	m_StartTimeCtrl2.SetFormat(sTimeFormat);
	m_StartTimeCtrl1.SetFormat(sTimeFormat);
	m_EndTimeCtrl2.SetFormat(sTimeFormat);
	m_EndTimeCtrl1.SetFormat(sTimeFormat);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPSchedulePage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPSchedulePage::OnRadioAllDay() 
{
	UpdateData();	
	SetModified();
}

void CDPSchedulePage::OnRadioAllDayExcept() 
{
	UpdateData();	
	SetModified();
}

void CDPSchedulePage::OnRadioOnceDaily() 
{
	UpdateData();	
	SetModified();
}

void CDPSchedulePage::OnRadioOnlyFrom() 
{
	UpdateData();
	SetModified();
}

BOOL CDPSchedulePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	switch( m_Units.GetCurSel() )
	{
		case 0: // seconds
		{
			if( m_iCollectionIntervalTime == 0 )
			{
				AfxMessageBox(IDS_STRING_WRONG_COLLECTION_VALUE);
				return FALSE;
			}
			else
			{
				m_iCollectionInterval = m_iCollectionIntervalTime;
			}
		}
		break;

		case 1: // minutes
		{
			m_iCollectionInterval = (m_iCollectionIntervalTime*60);
		}
		break;

		case 2: // hours
		{
			// v-marfin 62368 : fix for hours to seconds conversion.
			m_iCollectionInterval = (m_iCollectionIntervalTime*(60*60));  
		}
		break;
	}

	int iBeginHour=0;
	int iBeginMinute=0;
	int iEndHour=0;
	int iEndMinute=0;

	switch( m_iDataCollection )
	{
		case 0: // all day
		{
			iBeginHour = iBeginMinute = 0;
			iEndHour = 23;
			iEndMinute = 59;
		}
		break;

		case 1:	// only from x to y
		{
			iBeginHour = m_StartTime_1.GetHour();
			iBeginMinute = m_StartTime_1.GetMinute();
			iEndHour = m_EndTime_1.GetHour();
			iEndMinute = m_EndTime_1.GetMinute();
		}
		break;

		case 2: // all day except x to y
		{
			iBeginHour = m_EndTime_2.GetHour();
			iBeginMinute = m_EndTime_2.GetMinute();
			iEndHour = m_StartTime_2.GetHour();
			iEndMinute = m_StartTime_2.GetMinute();
		}
		break;

	}

	// update the agent object
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// set the active days
	pClassObject->SetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// set the begin time
	CString sTime;
	sTime.Format(_T("********%02d%02d**.******+***"),iBeginHour,iBeginMinute);

	pClassObject->SetProperty(IDS_STRING_MOF_BEGINTIME,sTime);

	// set the end time	
	sTime.Format(_T("********%02d%02d**.******+***"),iEndHour,iEndMinute);

	pClassObject->SetProperty(IDS_STRING_MOF_ENDTIME,sTime);

	pClassObject->SetProperty(IDS_STRING_MOF_COLLECTIONINTERVAL,m_iCollectionInterval);

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSWINDOW,m_iTotalSamples);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPSchedulePage::OnCheckFriday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckMonday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckSaturday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckSunday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckThursday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckTuesday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnCheckWednesday() 
{
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnDatetimechangeDatetimepickerEnd1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	
	*pResult = 0;
}

void CDPSchedulePage::OnDatetimechangeDatetimepickerEnd2(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	
	*pResult = 0;
}

void CDPSchedulePage::OnDatetimechangeDatetimepickerOnce(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	
	*pResult = 0;
}

void CDPSchedulePage::OnDatetimechangeDatetimepickerStart1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	
	*pResult = 0;
}

void CDPSchedulePage::OnDatetimechangeDatetimepickerStart2(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	
	*pResult = 0;
}

void CDPSchedulePage::OnChangeEditTotalSamples() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	if( ! m_Units.GetSafeHwnd() )
		return;
	
	UpdateData();
	SetModified();
	
}

void CDPSchedulePage::OnChangeEditDataCollectInterval() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	if( ! m_Units.GetSafeHwnd() )
		return;
	
	UpdateData();
	SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpservicepage.cpp ===
// DPServicePage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/22/00  v-marfin 60766 : Set proper dlg title for object being browsed.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.

#include "stdafx.h"
#include "snapin.h"
#include "DPServicePage.h"
#include "HMObject.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPServicePage property page

IMPLEMENT_DYNCREATE(CDPServicePage, CHMPropertyPage)

CDPServicePage::CDPServicePage() : CHMPropertyPage(CDPServicePage::IDD)
{
	//{{AFX_DATA_INIT(CDPServicePage)
	m_iType = 0;
	m_bRequireReset = FALSE;
	m_sService = _T("");
	m_sProcess = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEserv.htm");
}

CDPServicePage::~CDPServicePage()
{
}

void CDPServicePage::UpdateProperties(CListCtrl& Properties, const CString& sNamespace, const CString& sClass)
{
	Properties.DeleteAllItems();

	if( sClass.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + sNamespace);

	HRESULT hr = classobject.GetObject(sClass);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		Properties.InsertItem(0,saNames[i]);
	}

	Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

void CDPServicePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPServicePage)
	DDX_Control(pDX, IDC_LIST_PROCESS_PROPERTIES, m_ProcessProperties);
	DDX_Control(pDX, IDC_LIST_SERVICE_PROPERTIES, m_ServiceProperties);
	DDX_Radio(pDX, IDC_RADIO1, m_iType);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_SERVICE, m_sService);
	DDX_Text(pDX, IDC_EDIT_PROCESS, m_sProcess);
	//}}AFX_DATA_MAP

	if( m_iType == 0 )
	{
		GetDlgItem(IDC_EDIT_SERVICE)->EnableWindow();
		GetDlgItem(IDC_BUTTON_BROWSE_SERVICE)->EnableWindow();
		GetDlgItem(IDC_LIST_SERVICE_PROPERTIES)->EnableWindow();
		GetDlgItem(IDC_BUTTON_BROWSE_PROCESS)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_PROCESS)->EnableWindow(FALSE);
		GetDlgItem(IDC_LIST_PROCESS_PROPERTIES)->EnableWindow(FALSE);
	}
	else if( m_iType == 1 )
	{
		GetDlgItem(IDC_EDIT_SERVICE)->EnableWindow(FALSE);
		GetDlgItem(IDC_BUTTON_BROWSE_SERVICE)->EnableWindow(FALSE);
		GetDlgItem(IDC_LIST_SERVICE_PROPERTIES)->EnableWindow(FALSE);
		GetDlgItem(IDC_BUTTON_BROWSE_PROCESS)->EnableWindow();
		GetDlgItem(IDC_EDIT_PROCESS)->EnableWindow();
		GetDlgItem(IDC_LIST_PROCESS_PROPERTIES)->EnableWindow();
	}
}

BEGIN_MESSAGE_MAP(CDPServicePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPServicePage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_PROCESS, OnButtonBrowseProcess)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_SERVICE, OnButtonBrowseService)
	ON_EN_CHANGE(IDC_EDIT_PROCESS, OnChangeEditProcess)
	ON_BN_CLICKED(IDC_RADIO1, OnRadio1)
	ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
	ON_EN_CHANGE(IDC_EDIT_SERVICE, OnChangeEditService)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_NOTIFY(NM_CLICK, IDC_LIST_PROCESS_PROPERTIES, OnClickListProcessProperties2)
	ON_NOTIFY(NM_CLICK, IDC_LIST_SERVICE_PROPERTIES, OnClickListServiceProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPServicePage message handlers

BOOL CDPServicePage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();
	
	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_ServiceProperties.SetExtendedStyle(LVS_EX_CHECKBOXES);
	m_ProcessProperties.SetExtendedStyle(LVS_EX_CHECKBOXES);


	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_ServiceProperties.InsertColumn(0,sColumnTitle);
	m_ProcessProperties.InsertColumn(0,sColumnTitle);

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

	UpdateProperties(m_ServiceProperties,_T("root\\cimv2"),_T("Win32_Service"));
	UpdateProperties(m_ProcessProperties,_T("root\\cimv2"),_T("Win32_Process"));
	
    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------

	CString sQuery;
	pClassObject->GetProperty(IDS_STRING_MOF_QUERY,sQuery);

	int iIndex = -1;
	
	if( (iIndex = sQuery.Find(_T("Win32_Service"))) != -1 )
	{
		CWbemClassObject::GetPropertyValueFromString(sQuery,_T("Name"),m_sService);
		m_iType = 0;
	}
	else if( (iIndex = sQuery.Find(_T("Win32_Process"))) != -1 )
	{
		CWbemClassObject::GetPropertyValueFromString(sQuery,_T("Name"),m_sProcess);
		m_iType = 1;		
	}

	CStringArray saProperties;
	CString sProperties;

	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	if( m_iType == 0 )
	{
		for( int i=0; i < saProperties.GetSize(); i++ )
		{
			LVFINDINFO lvfi;
			ZeroMemory(&lvfi,sizeof(LVFINDINFO));
			lvfi.flags = LVFI_WRAP|LVFI_STRING;
			lvfi.psz = saProperties[i];
			int iListIndex = m_ServiceProperties.FindItem(&lvfi);
			if( iListIndex >= 0 )
			{
				m_ServiceProperties.SetCheck(iListIndex);
			}
		}
	}
	else if( m_iType == 1 )
	{
		for( int i=0; i < saProperties.GetSize(); i++ )
		{
			LVFINDINFO lvfi;
			ZeroMemory(&lvfi,sizeof(LVFINDINFO));
			lvfi.flags = LVFI_WRAP|LVFI_STRING;
			lvfi.psz = saProperties[i];
			int iListIndex = m_ProcessProperties.FindItem(&lvfi);
			if( iListIndex >= 0 )
			{
				m_ProcessProperties.SetCheck(iListIndex);
			}
		}
	}

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	delete pClassObject;

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPServicePage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPServicePage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPServicePage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPServicePage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                CString sObject = m_sService.IsEmpty() ? m_sProcess : m_sService;

                // No, so set the new name 
                if (!sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------

            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)


	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CDPServicePage::OnOK() 
{
	CHMPropertyPage::OnOK();
}


void CDPServicePage::OnButtonBrowseProcess() 
{
	CWmiInstanceBrowseDlg dlg;	

    // v-marfin 60766 : Set proper dlg title for object being browsed
	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_PROCESSES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the instance enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),_T("root\\cimv2"));

	dlg.m_ClassObject.SetNamespace(sTemp);

	// set the listbox title
	dlg.m_sTitle = sTemp;

	sTemp = _T("Win32_Process");
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		CString sProcess = dlg.m_sSelectedItem;
		CWbemClassObject ClassObject;
		sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),_T("root\\cimv2"));
		ClassObject.SetNamespace(sTemp);
		if( ! CHECKHRESULT(ClassObject.GetObject(sProcess)) )
		{
			return;
		}
		ClassObject.GetProperty(IDS_STRING_MOF_NAME,m_sProcess);
		m_sProcess.TrimLeft(_T("\""));
		m_sProcess.TrimRight(_T("\""));
		UpdateData(FALSE);
	}	
}

void CDPServicePage::OnButtonBrowseService() 
{
	CWmiInstanceBrowseDlg dlg;	

    // v-marfin 60766 : Set proper dlg title for object being browsed
	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_SERVICES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the instance enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),_T("root\\cimv2"));

	dlg.m_ClassObject.SetNamespace(sTemp);

	// set the listbox title
	dlg.m_sTitle = sTemp;

	sTemp = _T("Win32_Service");
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sService = dlg.m_sSelectedItem;
		int iIndex = m_sService.Find(_T("Name="));
		m_sService = m_sService.Right(m_sService.GetLength()-iIndex-5);
		m_sService.TrimLeft(_T("\""));
		m_sService.TrimRight(_T("\""));
		m_iType = 0;
		UpdateData(FALSE);		
	}	
}

void CDPServicePage::OnChangeEditProcess() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
}

void CDPServicePage::OnRadio1() 
{
	UpdateData();	
	SetModified();
}

void CDPServicePage::OnRadio2() 
{
	UpdateData();	
	SetModified();
}

void CDPServicePage::OnChangeEditService() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}

BOOL CDPServicePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CStringArray saCounters;

	if( m_iType == 0 )
	{
		if( m_ServiceProperties.GetItemCount() <= 0 )
		{
			return FALSE;
		}

		for( int i = 0; i < m_ServiceProperties.GetItemCount(); i++ )
		{
			if( m_ServiceProperties.GetCheck(i) )
			{			
				saCounters.Add(m_ServiceProperties.GetItemText(i,0));
			}
		}
	}
	else if( m_iType == 1 )
	{
		if( m_ProcessProperties.GetItemCount() <= 0 )
		{
			return FALSE;
		}

		for( int i = 0; i < m_ProcessProperties.GetItemCount(); i++ )
		{
			if( m_ProcessProperties.GetCheck(i) )
			{			
				saCounters.Add(m_ProcessProperties.GetItemText(i,0));
			}
		}
	}

//	if( ! saCounters.GetSize() )
//	{
//		return FALSE;
//	}

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	CString sNamespace = _T("root\\cimv2");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	CString sQuery;

	if( m_iType == 0 )
	{
		sQuery.Format(_T("select * from Win32_Service where Name=\"%s\""),m_sService);
		pClassObject->SetProperty(IDS_STRING_MOF_QUERY,sQuery);
	}
	else if( m_iType == 1 )
	{
		sQuery.Format(_T("select * from Win32_Process where Name=\"%s\""),m_sProcess);
		pClassObject->SetProperty(IDS_STRING_MOF_QUERY,sQuery);
	}

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saCounters);

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPServicePage::OnCheckRequireReset() 
{
	UpdateData();
	SetModified();	
}

void CDPServicePage::OnClickListProcessProperties2(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();
	
	*pResult = 0;
}

void CDPServicePage::OnClickListServiceProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpsmtppage.h ===
#if !defined(AFX_DPSMTPPAGE_H__D64271A5_4121_11D3_BE26_0000F87A3912__INCLUDED_)
#define AFX_DPSMTPPAGE_H__D64271A5_4121_11D3_BE26_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPSmtpPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPSmtpPage dialog

class CDPSmtpPage : public CHMPropertyPage
{
// Construction
public:
	CDPSmtpPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDPSmtpPage)
	enum { IDD = IDD_DATAPOINT_SMTP };
	CSpinButtonCtrl	m_SpinCtrl;
	BOOL	m_bRequireReset;
	CString	m_sData;
	CString	m_sFrom;
	CString	m_sServer;
	CString	m_sTo;
	CString	m_sTimeout;
	CString	m_sSubject;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDPSmtpPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDPSmtpPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnChangeEditData();
	afx_msg void OnChangeEditFrom();
	afx_msg void OnChangeEditServer();
	afx_msg void OnChangeEditTimeout();
	afx_msg void OnChangeEditTo();
	afx_msg void OnChangeEditSubject();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPSMTPPAGE_H__D64271A5_4121_11D3_BE26_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpsmtppage.cpp ===
// DPSmtpPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/24/00 v-marfin bug 61372 : show user err msgbox for any required field in OnApply().
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.

#include "stdafx.h"
#include "snapin.h"
#include "DPSmtpPage.h"
#include "HMDataElementConfiguration.h"
#include "HMObject.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPSmtpPage dialog


CDPSmtpPage::CDPSmtpPage()
	: CHMPropertyPage(CDPSmtpPage::IDD)
{
	//{{AFX_DATA_INIT(CDPSmtpPage)
	m_bRequireReset = FALSE;
	m_sData = _T("");
	m_sFrom = _T("");
	m_sServer = _T("");
	m_sTo = _T("");
	m_sTimeout = _T("");
	m_sSubject = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEsmpt.htm");
}


void CDPSmtpPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPSmtpPage)
	DDX_Control(pDX, IDC_SPIN9, m_SpinCtrl);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_DATA, m_sData);
	DDX_Text(pDX, IDC_EDIT_FROM, m_sFrom);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_sServer);
	DDX_Text(pDX, IDC_EDIT_TO, m_sTo);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_sTimeout);
	DDX_Text(pDX, IDC_EDIT_SUBJECT, m_sSubject);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDPSmtpPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPSmtpPage)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_EN_CHANGE(IDC_EDIT_DATA, OnChangeEditData)
	ON_EN_CHANGE(IDC_EDIT_FROM, OnChangeEditFrom)
	ON_EN_CHANGE(IDC_EDIT_SERVER, OnChangeEditServer)
	ON_EN_CHANGE(IDC_EDIT_TIMEOUT, OnChangeEditTimeout)
	ON_EN_CHANGE(IDC_EDIT_TO, OnChangeEditTo)
	ON_EN_CHANGE(IDC_EDIT_SUBJECT, OnChangeEditSubject)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPSmtpPage message handlers

BOOL CDPSmtpPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	COleSafeArray arguments;
	HMContextArray Arguments;
	HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	if( hr != S_FALSE )
	{
		CHMPolledMethodDataElementConfiguration::CopyArgsFromSafeArray(arguments,Arguments);
	}

	if( Arguments.GetSize() == 6 )
	{
		m_sServer = Arguments[0]->m_sValue;
		m_sFrom = Arguments[1]->m_sValue;
		m_sTo = Arguments[2]->m_sValue;
		m_sSubject = Arguments[3]->m_sValue;
    m_sData = Arguments[4]->m_sValue;
		m_sTimeout = Arguments[5]->m_sValue;
	}

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	delete pClassObject;

	UpdateData(FALSE);

	SendDlgItemMessage(IDC_SPIN9,UDM_SETRANGE32,0,INT_MAX-1);	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPSmtpPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

BOOL CDPSmtpPage::OnApply()
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}
	
    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	//---------------------------------------------------------------------
	// v-marfin : 61372 : show user err msgbox for any required field.
	/*if(	m_sServer.IsEmpty() || m_sFrom.IsEmpty() || m_sTo.IsEmpty() ||
			m_sData.IsEmpty() || m_sTimeout.IsEmpty() )
	{
		return FALSE;
	}*/

	m_sServer.TrimRight(); 
	m_sServer.TrimLeft();
	if (m_sServer.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_SMTP_REQ_SERVER);
		UpdateData(FALSE);
		GetDlgItem(IDC_EDIT_SERVER)->SetFocus();
		return FALSE;
	}

	m_sFrom.TrimRight(); 
	m_sFrom.TrimLeft();
	if (m_sFrom.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_SMTP_REQ_FROM);
		UpdateData(FALSE);
		GetDlgItem(IDC_EDIT_FROM)->SetFocus();
		return FALSE;
	}

	m_sTo.TrimRight(); 
	m_sTo.TrimLeft();
	if (m_sTo.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_SMTP_REQ_TO);
		UpdateData(FALSE);
		GetDlgItem(IDC_EDIT_TO)->SetFocus();
		return FALSE;
	}

	m_sData.TrimRight(); 
	m_sData.TrimLeft();
	if (m_sData.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_SMTP_REQ_MESSAGE);
		UpdateData(FALSE);
		GetDlgItem(IDC_EDIT_DATA)->SetFocus();
		return FALSE;
	}

	m_sTimeout.TrimRight(); 
	m_sTimeout.TrimLeft();
	if (m_sTimeout.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_SMTP_REQ_TIMEOUT);
		UpdateData(FALSE);
		GetDlgItem(IDC_EDIT_TIMEOUT)->SetFocus();
		return FALSE;
	}

	//---------------------------------------------------------------------

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	HMContextArray Arguments;


	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Server"),CIM_STRING,m_sServer);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("From"),CIM_STRING,m_sFrom);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("To"),CIM_STRING,m_sTo);
  
  CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Subject"),CIM_STRING,m_sSubject);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Data"),CIM_STRING,m_sData);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Timeout"),CIM_UINT32,m_sTimeout);

	COleSafeArray arguments;
	CHMPolledMethodDataElementConfiguration::CopyArgsToSafeArray(Arguments,arguments);

	hr = pClassObject->SetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	CString sNamespace = _T("root\\cimv2\\MicrosoftHealthmonitor");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	pClassObject->SetProperty(IDS_STRING_MOF_PATH,CString(_T("Microsoft_IPPExecution")));

	pClassObject->SetProperty(IDS_STRING_MOF_METHODNAME,CString(_T("ExecuteSMTP")));

	/* 63128 
    CStringArray saProperties;	
	saProperties.Add(_T("ResponseTime"));
	saProperties.Add(_T("OverallResultCode"));
	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);*/

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();
	
	delete pClassObject;	

  SetModified(FALSE);

	return TRUE;
}

void CDPSmtpPage::OnCheckRequireReset() 
{
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditData() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditFrom() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditServer() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditTimeout() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditTo() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnChangeEditSubject() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPSmtpPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPSmtpPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPSmtpPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPPerfMonPage::OnOK - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                CString sObject;
                sObject.Format(IDS_STRING_FORMAT_SMTPNAME,m_sServer);

                // No, so set the new name 
                if (!sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------

            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)



	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpperfmonpage.h ===
#if !defined(AFX_DPPERFMONPAGE_H__52566159_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_DPPERFMONPAGE_H__52566159_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPPerfMonPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPPerfMonPage dialog

class CDPPerfMonPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPPerfMonPage)

// Construction
public:
	CDPPerfMonPage();
	~CDPPerfMonPage();

// Dialog Data
	//{{AFX_DATA(CDPPerfMonPage)
	enum { IDD = IDD_DATAPOINT_PERFMON };
	CListCtrl	m_Properties;
	BOOL	m_bRequireReset;
	CString	m_sInstance;
	CString	m_sObject;
	//}}AFX_DATA
	bool m_bNT5Perfdata;
	CString m_sNamespace;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPPerfMonPage)
	public:
	virtual void OnFinalRelease();
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateProperties();
	// Generated message map functions
	//{{AFX_MSG(CDPPerfMonPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonBrowseInstance();
	afx_msg void OnButtonBrowseObject();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnChangeEditInstance();
	afx_msg void OnChangeEditObject();
	afx_msg void OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CDPPerfMonPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPPERFMONPAGE_H__52566159_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpservicepage.h ===
#if !defined(AFX_DPSERVICEPAGE_H__0708329D_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPSERVICEPAGE_H__0708329D_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPServicePage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPServicePage dialog

class CDPServicePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPServicePage)

// Construction
public:
	CDPServicePage();
	~CDPServicePage();

// Dialog Data
	//{{AFX_DATA(CDPServicePage)
	enum { IDD = IDD_DATAPOINT_SERVICEPROCESS };
	CListCtrl	m_ProcessProperties;
	CListCtrl	m_ServiceProperties;
	int		m_iType;
	BOOL	m_bRequireReset;
	CString	m_sService;
	CString	m_sProcess;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPServicePage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateProperties(CListCtrl& Properties, const CString& sNamespace, const CString& sClass);
	// Generated message map functions
	//{{AFX_MSG(CDPServicePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonBrowseProcess();
	afx_msg void OnButtonBrowseService();
	afx_msg void OnChangeEditProcess();
	afx_msg void OnRadio1();
	afx_msg void OnRadio2();
	afx_msg void OnChangeEditService();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnClickListProcessProperties2(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickListServiceProperties(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPSERVICEPAGE_H__0708329D_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpsnmpdatapage.h ===
#if !defined(AFX_DPSNMPDATAPAGE_H__0B575649_E243_11D2_BDAD_0000F87A3912__INCLUDED_)
#define AFX_DPSNMPDATAPAGE_H__0B575649_E243_11D2_BDAD_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPSNMPDataPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPSNMPDataPage dialog

class CDPSNMPDataPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPSNMPDataPage)

// Construction
public:
	CDPSNMPDataPage();
	~CDPSNMPDataPage();

// Dialog Data
	//{{AFX_DATA(CDPSNMPDataPage)
	enum { IDD = IDD_DATAPOINT_SNMPDATA };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPSNMPDataPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPSNMPDataPage)
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPSNMPDATAPAGE_H__0B575649_E243_11D2_BDAD_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpwmipolledquerypage.cpp ===
// DPWmiPolledQueryPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.


#include "stdafx.h"
#include "snapin.h"
#include "DPWmiPolledQueryPage.h"
#include "HMObject.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPWmiPolledQueryPage property page

IMPLEMENT_DYNCREATE(CDPWmiPolledQueryPage, CHMPropertyPage)

CDPWmiPolledQueryPage::CDPWmiPolledQueryPage() : CHMPropertyPage(CDPWmiPolledQueryPage::IDD)
{
	//{{AFX_DATA_INIT(CDPWmiPolledQueryPage)
	m_sClass = _T("");
	m_sNamespace = _T("");
	m_sQuery = _T("");
	m_bRequireReset = FALSE;
	//}}AFX_DATA_INIT
	
	m_sHelpTopic = _T("HMon21.chm::/dDEquery.htm");
}

CDPWmiPolledQueryPage::~CDPWmiPolledQueryPage()
{
}

inline void CDPWmiPolledQueryPage::ConstructQuery()
{
	m_sQuery.Format(_T("SELECT * FROM %s"), m_sClass.IsEmpty() ? _T("<<your_class_name_here>>") : m_sClass);

	GetDlgItem(IDC_EDIT_QUERY)->SetWindowText(m_sQuery);
}

void CDPWmiPolledQueryPage::UpdateProperties()
{
	m_Properties.DeleteAllItems();

	if( m_sClass.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + m_sNamespace);

	HRESULT hr = classobject.GetObject(m_sClass);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		m_Properties.InsertItem(0,saNames[i]);
	}

	m_Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

void CDPWmiPolledQueryPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPWmiPolledQueryPage)
	DDX_Control(pDX, IDC_LIST_PROPERTIES, m_Properties);
	DDX_Text(pDX, IDC_EDIT_CLASS, m_sClass);
	DDX_Text(pDX, IDC_EDIT_NAMESPACE, m_sNamespace);
	DDX_Text(pDX, IDC_EDIT_QUERY, m_sQuery);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDPWmiPolledQueryPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPWmiPolledQueryPage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_NAMESPACE, OnButtonBrowseNamespace)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_CLASS, OnButtonBrowseClass)
	ON_EN_CHANGE(IDC_EDIT_CLASS, OnChangeEditClass)
	ON_EN_CHANGE(IDC_EDIT_NAMESPACE, OnChangeEditNamespace)
	ON_EN_CHANGE(IDC_EDIT_QUERY, OnChangeEditQuery)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_NOTIFY(NM_CLICK, IDC_LIST_PROPERTIES, OnClickListProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPWmiPolledQueryPage message handlers

BOOL CDPWmiPolledQueryPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_Properties.SetExtendedStyle(LVS_EX_CHECKBOXES);


	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_Properties.InsertColumn(0,sColumnTitle);
	
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();	
	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------

	pClassObject->GetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sNamespace);

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	pClassObject->GetProperty(IDS_STRING_MOF_QUERY,m_sQuery);
	m_sQuery.MakeUpper();

	int iIndex = m_sQuery.Find(_T("SELECT * FROM "));
	if( iIndex != -1 )
	{
		m_sClass = m_sQuery.Right(m_sQuery.GetLength()-iIndex-14);
		iIndex = m_sClass.Find(_T(" "));
		if( iIndex != -1 )
		{
			m_sClass = m_sClass.Left(iIndex);
		}
	}

	UpdateProperties();

	CStringArray saProperties;
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	for( int i=0; i < saProperties.GetSize(); i++ )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = saProperties[i];
		int iListIndex = m_Properties.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
			m_Properties.SetCheck(iListIndex);
		}
	}

	delete pClassObject;

	UpdateData(FALSE);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPWmiPolledQueryPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPWmiPolledQueryPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPWmiPolledQueryPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPWmiPolledQueryPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sQuery.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sQuery);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)


	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CDPWmiPolledQueryPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPWmiPolledQueryPage::OnButtonBrowseNamespace() 
{
	CWmiNamespaceBrowseDlg dlg;

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_NAMESPACES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the namespace enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	if( m_sNamespace.IsEmpty() )
	{
		m_sNamespace.Format(IDS_STRING_MOF_NAMESPACE_FORMAT,GetObjectPtr()->GetSystemName());
	}

	dlg.m_sTitle.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);
	dlg.m_ClassObject.SetNamespace(dlg.m_sTitle);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display dialog
	if( dlg.DoModal() == IDOK )
	{
		m_sNamespace = dlg.m_sSelectedItem;
		m_sClass.Empty();
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
		ConstructQuery();
	}
}

void CDPWmiPolledQueryPage::OnButtonBrowseClass() 
{
	CWmiClassBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_CLASSES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the class enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);

	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateClassEnumerator(NULL)) )
	{
		return;
	}

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sClass = dlg.m_sSelectedItem;		
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
		ConstructQuery();
	}
}

void CDPWmiPolledQueryPage::OnChangeEditClass() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	UpdateProperties();
	SetModified();
	ConstructQuery();
}

void CDPWmiPolledQueryPage::OnChangeEditNamespace() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_sNamespace.Find(_T("\\\\")) != -1 )
  {
    AfxMessageBox(IDS_STRING_NO_REMOTE_NAMESPACES);
    GetDlgItem(IDC_EDIT_NAMESPACE)->SetWindowText(_T(""));
  }
	
	GetDlgItem(IDC_EDIT_CLASS)->SetWindowText(_T(""));	
	
	UpdateData();
	UpdateProperties();
	SetModified();
	ConstructQuery();
}

void CDPWmiPolledQueryPage::OnChangeEditQuery() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();	
	SetModified();
}

BOOL CDPWmiPolledQueryPage::OnApply() 
{
    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CStringArray saProperties;

	for( int i = 0; i < m_Properties.GetItemCount(); i++ )
	{
		if( m_Properties.GetCheck(i) )
		{			
			saProperties.Add(m_Properties.GetItemText(i,0));
		}
	}

//	if( ! saProperties.GetSize() )
//	{
//		return FALSE;
//	}

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();	
	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sNamespace);	

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	
	pClassObject->SetProperty(IDS_STRING_MOF_QUERY,m_sQuery);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPWmiPolledQueryPage::OnCheckRequireReset() 
{
	UpdateData();
	SetModified();	
}

void CDPWmiPolledQueryPage::OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpsnmpdatapage.cpp ===
// DPSNMPDataPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
//
#include "stdafx.h"
#include "snapin.h"
#include "DPSNMPDataPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPSNMPDataPage property page

IMPLEMENT_DYNCREATE(CDPSNMPDataPage, CHMPropertyPage)

CDPSNMPDataPage::CDPSNMPDataPage() : CHMPropertyPage(CDPSNMPDataPage::IDD)
{
	//{{AFX_DATA_INIT(CDPSNMPDataPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}

CDPSNMPDataPage::~CDPSNMPDataPage()
{
}

void CDPSNMPDataPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPSNMPDataPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPSNMPDataPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPSNMPDataPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPSNMPDataPage message handlers

void CDPSNMPDataPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

BOOL CDPSNMPDataPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\enablethresholddlg.cpp ===
// EnableThresholdDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "EnableThresholdDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnableThresholdDlg dialog


CEnableThresholdDlg::CEnableThresholdDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnableThresholdDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEnableThresholdDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CEnableThresholdDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnableThresholdDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEnableThresholdDlg, CDialog)
	//{{AFX_MSG_MAP(CEnableThresholdDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnableThresholdDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpwmiquerypage.cpp ===
// DPWmiQueryPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.


#include "stdafx.h"
#include "snapin.h"
#include "DPWmiQueryPage.h"
#include "HMObject.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPWmiQueryPage property page

IMPLEMENT_DYNCREATE(CDPWmiQueryPage, CHMPropertyPage)

CDPWmiQueryPage::CDPWmiQueryPage() : CHMPropertyPage(CDPWmiQueryPage::IDD)
{
	//{{AFX_DATA_INIT(CDPWmiQueryPage)
	m_bRequireReset = FALSE;
	m_sNamespace = _T("");
	m_sQuery = _T("");
	m_sClass = _T("");
	m_iEventType = -1;
	//}}AFX_DATA_INIT
	
	m_sHelpTopic = _T("HMon21.chm::/dDEevent.htm");
}

CDPWmiQueryPage::~CDPWmiQueryPage()
{
}

void CDPWmiQueryPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPWmiQueryPage)
	DDX_Control(pDX, IDC_LIST_PROPERTIES, m_Properties);
	DDX_Control(pDX, IDC_COMBO_EVENT_TYPE, m_IntrinsicEventTypeBox);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_NAMESPACE, m_sNamespace);
	DDX_Text(pDX, IDC_EDIT_QUERY, m_sQuery);
	DDX_Text(pDX, IDC_EDIT_CLASS, m_sClass);
	DDX_Radio(pDX, IDC_RADIO1, m_iEventType);
	//}}AFX_DATA_MAP

	if( m_iEventType == 0 )
	{
		m_IntrinsicEventTypeBox.EnableWindow();
	}
	else if( m_iEventType == 1 )
	{
		m_IntrinsicEventTypeBox.EnableWindow(FALSE);
	}
}

void CDPWmiQueryPage::UpdateProperties()
{
	m_Properties.DeleteAllItems();

	if( m_sClass.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + m_sNamespace);

	HRESULT hr = classobject.GetObject(m_sClass);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		m_Properties.InsertItem(0,saNames[i]);
	}

	m_Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

inline void CDPWmiQueryPage::ConstructQuery()
{
	if( m_iEventType == 1 )
	{
		m_sQuery.Format(_T("SELECT * FROM %s"), m_sClass.IsEmpty() ? _T("<<your_class_name_here>>") : m_sClass);
	}
	else if( m_iEventType == 0 )
	{
		CString sIntrinsicType;
		switch(m_IntrinsicEventTypeBox.GetCurSel())
		{
			case 0:
			{
				sIntrinsicType = _T("__InstanceCreationEvent");
			}
			break;

			case 1:
			{
				sIntrinsicType = _T("__InstanceDeletionEvent");
			}
			break;

			case 2:
			{
				sIntrinsicType = _T("__InstanceModificationEvent");
			}
			break;

			case 3:
			{
				sIntrinsicType = _T("__ClassCreationEvent");
			}
			break;

			case 4:
			{
				sIntrinsicType = _T("__ClassDeletionEvent");
			}
			break;

			case 5:
			{
				sIntrinsicType = _T("__ClassModificationEvent");
			}
			break;

			case 6:
			{
				sIntrinsicType = _T("__NamespaceCreationEvent");
			}
			break;

			case 7:
			{
				sIntrinsicType = _T("__NamespaceDeletionEvent");
			}
			break;

			case 8:
			{
				sIntrinsicType = _T("__NamespaceModificationEvent");
			}
			break;
		}

		m_sQuery.Format(_T("SELECT * FROM %s where TargetInstance isa \"%s\""), sIntrinsicType, m_sClass.IsEmpty() ? _T("") : m_sClass);
	}

	GetDlgItem(IDC_EDIT_QUERY)->SetWindowText(m_sQuery);
}

BEGIN_MESSAGE_MAP(CDPWmiQueryPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPWmiQueryPage)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_NAMESPACE, OnButtonBrowseNamespace)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_CLASS, OnButtonBrowseClass)
	ON_EN_CHANGE(IDC_EDIT_CLASS, OnChangeEditClass)
	ON_EN_CHANGE(IDC_EDIT_NAMESPACE, OnChangeEditNamespace)
	ON_EN_CHANGE(IDC_EDIT_QUERY, OnChangeEditQuery)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_EN_CHANGE(IDC_EDIT_INSTANCE, OnChangeEditInstance)
	ON_CBN_EDITCHANGE(IDC_COMBO_EVENT_TYPE, OnEditchangeComboEventType)
	ON_CBN_SELENDOK(IDC_COMBO_EVENT_TYPE, OnSelendokComboEventType)
	ON_BN_CLICKED(IDC_RADIO1, OnRadio1)
	ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
	ON_NOTIFY(NM_CLICK, IDC_LIST_PROPERTIES, OnClickListProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPWmiQueryPage message handlers

BOOL CDPWmiQueryPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_Properties.SetExtendedStyle(LVS_EX_CHECKBOXES);

	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_Properties.InsertColumn(0,sColumnTitle);

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();	
	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------

	pClassObject->GetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sNamespace);

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	pClassObject->GetProperty(IDS_STRING_MOF_QUERY,m_sQuery);

	CString sQuery = m_sQuery;
	_tcsupr(sQuery.GetBuffer(sQuery.GetLength()));
	sQuery.ReleaseBuffer();

	int iIndex = -1;
	if( (iIndex = sQuery.Find(_T("ISA"))) != -1 )
	{
		m_sClass = m_sQuery.Right(m_sQuery.GetLength()-iIndex-4);
		iIndex = m_sClass.Find(_T(" "));
		if( iIndex != -1 )
		{
			m_sClass = m_sClass.Left(iIndex);
		}
		m_sClass.TrimLeft(_T("\""));
		m_sClass.TrimRight(_T("\""));

		if( sQuery.Find(_T("__INSTANCECREATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(0);
		}
		else if(sQuery.Find(_T("__INSTANCEDELETIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(1);
		}
		else if(sQuery.Find(_T("__INSTANCEMODIFICATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(2);
		}
		else if(sQuery.Find(_T("__CLASSCREATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(3);
		}
		else if(sQuery.Find(_T("__CLASSDELETIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(4);
		}
		else if(sQuery.Find(_T("__CLASSMODIFICATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(5);
		}
		else if(sQuery.Find(_T("__NAMESPACECREATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(6);
		}
		else if(sQuery.Find(_T("__NAMESPACEDELETIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(7);
		}
		else if(sQuery.Find(_T("__NAMESPACEMODIFICATIONEVENT")) != -1 )
		{
			m_IntrinsicEventTypeBox.SetCurSel(8);
		}

		m_iEventType = 0;
	}
	else
	{
		iIndex = sQuery.Find(_T("SELECT * FROM "));
		if( iIndex != -1 )
		{
			m_sClass = m_sQuery.Right(m_sQuery.GetLength()-iIndex-14);
			iIndex = m_sClass.Find(_T(" "));
			if( iIndex != -1 )
			{
				m_sClass = m_sClass.Left(iIndex);
			}
		}
		
		m_iEventType = 1;
	}

	UpdateProperties();

	CStringArray saProperties;
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	for( int i=0; i < saProperties.GetSize(); i++ )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = saProperties[i];
		int iListIndex = m_Properties.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
			m_Properties.SetCheck(iListIndex);
		}
	}

	delete pClassObject;

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPWmiQueryPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPWmiQueryPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPWmiQueryPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPWmiQueryPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sQuery.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sQuery);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CDPWmiQueryPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPWmiQueryPage::OnButtonBrowseNamespace() 
{
	CWmiNamespaceBrowseDlg dlg;

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_NAMESPACES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the namespace enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	if( m_sNamespace.IsEmpty() )
	{
		m_sNamespace.Format(IDS_STRING_MOF_NAMESPACE_FORMAT,GetObjectPtr()->GetSystemName());
	}

	dlg.m_sTitle.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);
	dlg.m_ClassObject.SetNamespace(dlg.m_sTitle);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display dialog
	if( dlg.DoModal() == IDOK )
	{
		m_sNamespace = dlg.m_sSelectedItem;
		m_sClass.Empty();
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
		ConstructQuery();
	}
}

void CDPWmiQueryPage::OnButtonBrowseClass() 
{
	CWmiClassBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_CLASSES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the class enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);

	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateClassEnumerator(NULL)) )
	{
		return;
	}

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sClass = dlg.m_sSelectedItem;
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
		ConstructQuery();
	}
}


void CDPWmiQueryPage::OnChangeEditClass() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}

	UpdateData();
	SetModified();
	UpdateProperties();
	ConstructQuery();
}


void CDPWmiQueryPage::OnChangeEditNamespace() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}

  if( m_sNamespace.Find(_T("\\\\")) != -1 )
  {
    AfxMessageBox(IDS_STRING_NO_REMOTE_NAMESPACES);
    GetDlgItem(IDC_EDIT_NAMESPACE)->SetWindowText(_T(""));
  }

	GetDlgItem(IDC_EDIT_CLASS)->SetWindowText(_T(""));	
		
	UpdateData();
	UpdateProperties();
	SetModified();
	ConstructQuery();	
}

void CDPWmiQueryPage::OnChangeEditQuery() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}
	
	UpdateData();
	SetModified();	
}

BOOL CDPWmiQueryPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CStringArray saProperties;

	for( int i = 0; i < m_Properties.GetItemCount(); i++ )
	{
		if( m_Properties.GetCheck(i) )
		{			
			saProperties.Add(m_Properties.GetItemText(i,0));
		}
	}

//	if( ! saProperties.GetSize() )
//	{
//		return FALSE;
//	}


	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();	
	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sNamespace);	

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	
	pClassObject->SetProperty(IDS_STRING_MOF_QUERY,m_sQuery);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPWmiQueryPage::OnCheckRequireReset() 
{
	UpdateData();
	SetModified();	
}

void CDPWmiQueryPage::OnChangeEditInstance() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}
	UpdateData();
	SetModified();
	
}

void CDPWmiQueryPage::OnEditchangeComboEventType() 
{
	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}
	UpdateData();
	SetModified();
	ConstructQuery();	
}

void CDPWmiQueryPage::OnSelendokComboEventType() 
{
	UpdateData();
	SetModified();
	ConstructQuery();
}

void CDPWmiQueryPage::OnRadio1() 
{
	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}

	UpdateData();
	SetModified();
	ConstructQuery();
}

void CDPWmiQueryPage::OnRadio2() 
{
	if( ! m_IntrinsicEventTypeBox.GetSafeHwnd() )
	{
		return;
	}
	UpdateData();
	SetModified();
	ConstructQuery();
}

void CDPWmiQueryPage::OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpwmiquerypage.h ===
#if !defined(AFX_DPWMIQUERYPAGE_H__D7EF2BF1_095D_11D3_937D_00A0CC406605__INCLUDED_)
#define AFX_DPWMIQUERYPAGE_H__D7EF2BF1_095D_11D3_937D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPWmiQueryPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPWmiQueryPage dialog

class CDPWmiQueryPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPWmiQueryPage)

// Construction
public:
	CDPWmiQueryPage();
	~CDPWmiQueryPage();

// Dialog Data
	//{{AFX_DATA(CDPWmiQueryPage)
	enum { IDD = IDD_DATAPOINT_WMI_QUERY };
	CListCtrl	m_Properties;
	CComboBox	m_IntrinsicEventTypeBox;
	BOOL	m_bRequireReset;
	CString	m_sNamespace;
	CString	m_sQuery;
	CString	m_sClass;
	int		m_iEventType;
	//}}AFX_DATA

// operations
protected:
	void ConstructQuery();
	void UpdateProperties();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPWmiQueryPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPWmiQueryPage)
	afx_msg void OnButtonBrowseNamespace();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonBrowseClass();
	afx_msg void OnChangeEditClass();
	afx_msg void OnChangeEditNamespace();
	afx_msg void OnChangeEditQuery();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnChangeEditInstance();
	afx_msg void OnEditchangeComboEventType();
	afx_msg void OnSelendokComboEventType();
	afx_msg void OnRadio1();
	afx_msg void OnRadio2();
	afx_msg void OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPWMIQUERYPAGE_H__D7EF2BF1_095D_11D3_937D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\event.cpp ===
// Event.cpp: implementation of the CEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "Event.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CEvent,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEvent::CEvent()
{
	ZeroMemory(&m_st,sizeof(SYSTEMTIME));
	m_iState = -1;
}

CEvent::~CEvent()
{
	ZeroMemory(&m_st,sizeof(SYSTEMTIME));
	m_iState = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpwmipolledquerypage.h ===
#if !defined(AFX_DPWMIPOLLEDQUERYPAGE_H__28F3C7F6_2726_11D3_9390_00A0CC406605__INCLUDED_)
#define AFX_DPWMIPOLLEDQUERYPAGE_H__28F3C7F6_2726_11D3_9390_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPWmiPolledQueryPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPWmiPolledQueryPage dialog

class CDPWmiPolledQueryPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPWmiPolledQueryPage)

// Construction
public:
	CDPWmiPolledQueryPage();
	~CDPWmiPolledQueryPage();

// Dialog Data
	//{{AFX_DATA(CDPWmiPolledQueryPage)
	enum { IDD = IDD_DATAPOINT_WMI_POLLED_QUERY };
	CListCtrl	m_Properties;
	CString	m_sClass;
	CString	m_sNamespace;
	CString	m_sQuery;
	BOOL	m_bRequireReset;
	//}}AFX_DATA

// operations
protected:
	void ConstructQuery();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPWmiPolledQueryPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateProperties();
	// Generated message map functions
	//{{AFX_MSG(CDPWmiPolledQueryPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonBrowseNamespace();
	afx_msg void OnButtonBrowseClass();
	afx_msg void OnChangeEditClass();
	afx_msg void OnChangeEditNamespace();
	afx_msg void OnChangeEditQuery();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPWMIPOLLEDQUERYPAGE_H__28F3C7F6_2726_11D3_9390_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\event.h ===
// Event.h: interface for the CEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENT_H__988BB45A_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
#define AFX_EVENT_H__988BB45A_8C93_11D3_BE83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMEventResultsPaneItem.h"

class CEvent : public CObject  
{

DECLARE_DYNCREATE(CEvent)

// Construction/Destruction
public:
	CEvent();
	virtual ~CEvent();

// Event Time Members
public:
	CString GetEventLocalTime();
	SYSTEMTIME m_st;

// State Members
public:
	static int GetStatus(int iAgentState); // maps from agent state to console state
	static void GetStatus(int iAgentState, CString& sStatus); // maps agent state integer to UI Text
	int m_iState;

// StatusGuid
public:
	CString m_sStatusGuid;

// Name
public:
	CString m_sName;

// System Name
public:
	CString m_sSystemName;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView) { ASSERT(pView); ASSERT(FALSE); return NULL; }
};

typedef CTypedPtrArray<CObArray,CEvent*> EventArray;

#include "Event.inl"

#endif // !defined(AFX_EVENT_H__988BB45A_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\enablethresholddlg.h ===
#if !defined(AFX_ENABLETHRESHOLDDLG_H__3ADB0FD7_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
#define AFX_ENABLETHRESHOLDDLG_H__3ADB0FD7_C4FA_11D2_BD83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EnableThresholdDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEnableThresholdDlg dialog

class CEnableThresholdDlg : public CDialog
{
// Construction
public:
	CEnableThresholdDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEnableThresholdDlg)
	enum { IDD = IDD_DIALOG_ENABLETHRESHOLDING };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnableThresholdDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEnableThresholdDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENABLETHRESHOLDDLG_H__3ADB0FD7_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventcontainer.cpp ===
// EventContainer.cpp: implementation of the CEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "EventContainer.h"
#include "HMObject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CEventContainer,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventContainer::CEventContainer()
{
	m_iState = 0;
	m_pObject = NULL;
	m_iNumberNormals = 0;
	m_iNumberWarnings = 0;
	m_iNumberCriticals = 0;
	m_iNumberUnknowns = 0;
}

CEventContainer::~CEventContainer()
{
	m_pObject = NULL;
	DeleteEvents();
	DeleteStatistics();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventcontainer.h ===
// EventContainer.h: interface for the CEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTCONTAINER_H__988BB453_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
#define AFX_EVENTCONTAINER_H__988BB453_8C93_11D3_BE83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Event.h"
#include "Statistics.h"
#include "HMObject.h"


class CEventContainer : public CObject  
{

DECLARE_DYNCREATE(CEventContainer)

// Construction/Destruction
public:
	CEventContainer();
	virtual ~CEventContainer();

// Event Operations
public:
	void AddEvents(EventArray& Events);
	void AddEvent(CEvent* pEvent);
	CEvent* GetEventByGuid(const CString& sStatusGuid);
	void DeleteEvent(const CString& sStatusGuid);
	virtual void DeleteEvent(int iIndex);
	void DeleteEvents();
	void DeleteSystemEvents(const CString& sSystemName);
	int GetEventCount();
	CEvent* GetEvent(int iIndex);
	CString GetLastEventDTime();

// Statistics Operations
public:
	void AddStatistic(CStatistics* pStatistic);
	void AddStatistics(StatsArray& Statistics);
	void DeleteStatistics();
	int GetStatisticsCount();
	CStatistics* GetStatistic(int iIndex);

// Attributes
public:
	int m_iState;	
	CString m_sConfigurationGuid;
	int m_iNumberNormals;
	int m_iNumberWarnings;
	int m_iNumberCriticals;
	int m_iNumberUnknowns;
protected:
	EventArray m_Events;
	StatsArray m_Statistics;

// Configuration Association Members
public:
	CHMObject* GetObjectPtr();
	void SetObjectPtr(CHMObject* pObject);
protected:
	CHMObject* m_pObject;
};

#include "EventContainer.inl"

#endif // !defined(AFX_EVENTCONTAINER_H__988BB453_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventmanager.cpp ===
// EventManager.cpp: implementation of the CEventManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "EventManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CEventManager theEvtManager;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventManager::CEventManager()
{

}

CEventManager::~CEventManager()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\event.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// State Members
//////////////////////////////////////////////////////////////////////

inline int CEvent::GetStatus(int iAgentState)
{
	switch( iAgentState )
	{
		case 9:
		{
			return HMS_CRITICAL;
		}
		break;

		case 8:
		{
			return HMS_WARNING;
		}
		break;

		case 7:
		{
			return HMS_NODATA;
		}
		break;

		case 6:
		{
			return HMS_UNKNOWN;
		}
		break;

		case 5:
		{
			return HMS_SCHEDULEDOUT;
		}
		break;

		case 4:
		{
			return HMS_DISABLED;
		}
		break;

		case 3:
		{
			return HMS_INFO;
		}
		break;

		case 2:
		{
			return HMS_NORMAL;
		}
		break;

    case 1:
    {
      return HMS_NORMAL;
    }
    break;

		case 0:
		{
			return HMS_NORMAL;
		}
		break;
	}	

	ASSERT(FALSE);

	return -1;
}

inline void CEvent::GetStatus(int iAgentState, CString& sStatus)
{
	switch( iAgentState )
	{
		case 9:
		{
			sStatus.LoadString(IDS_STRING_CRITICAL);			
		}
		break;

		case 8:
		{
			sStatus.LoadString(IDS_STRING_WARNING);
		}
		break;

		case 7:
		{
			sStatus.LoadString(IDS_STRING_NODATA);
		}
		break;

		case 6:
		{
			sStatus.LoadString(IDS_STRING_UNKNOWN);
		}
		break;

		case 5:
		{
			sStatus.LoadString(IDS_STRING_OUTAGE);
		}
		break;

		case 4:
		{
			sStatus.LoadString(IDS_STRING_DISABLED);
		}
		break;

		case 3:
		{
			sStatus.LoadString(IDS_STRING_INFORMATION);
		}
		break;

		case 2:
		{
			sStatus.LoadString(IDS_STRING_RESET);
		}
		break;

		case 1:
		{
			sStatus.LoadString(IDS_STRING_COLLECTING);
		}
		break;

		case 0:
		{
			sStatus.LoadString(IDS_STRING_RESET);
		}
		break;		

		default:
		{
			sStatus.LoadString(IDS_STRING_NONE);
		}
		break;
	}	
}

//////////////////////////////////////////////////////////////////////
// Event Time Members
//////////////////////////////////////////////////////////////////////

inline CString CEvent::GetEventLocalTime()
{
	CString sTime;
	CString sDate;
	CString sDateTime;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	sDateTime = sDate + _T("  ") + sTime;	

	return sDateTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventcontainer.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

inline void CEventContainer::AddEvents(EventArray& Events)
{
	for( int i  = 0; i < Events.GetSize(); i++ )
	{
    CEvent* pEvent = Events[i];
		AddEvent(pEvent);
	}
}

inline void CEventContainer::AddEvent(CEvent* pEvent)
{	
	if( !pEvent || ! GfxCheckObjPtr((CObject*)pEvent,CEvent) )
	{
		ASSERT(FALSE);
		return;
	}


	// by default, add the event to the container's event collection
	// only if another event with the same statusguid is not already there
	if( GetEventByGuid(pEvent->m_sStatusGuid) )
	{
		return;
	}

	m_Events.Add(pEvent);

	// determine if this container has a config object connected to it
	// if a config object is connected then
	//		if the config object is the selected object then
	//			add a results pane item to the results view for this event
	CHMObject* pObject = GetObjectPtr();
	if( pObject )
	{
		CScopePaneItem* pItem = pObject->IsSelected();
		if( pItem && GfxCheckObjPtr(pItem,CScopePaneItem) )
		{
			CResultsPaneView* pView = pItem->GetResultsPaneView();
			pView->AddItem(pEvent->CreateResultsPaneItem(pView));
		}
	}
}

inline CEvent* CEventContainer::GetEventByGuid(const CString& sGuid)
{
	for( int i = 0; i < m_Events.GetSize(); i++  )
	{
		CEvent* pEvent = m_Events[i];
		if( pEvent && GfxCheckObjPtr((CObject*)pEvent,CEvent) )
		{
			if( pEvent->m_sStatusGuid == sGuid )
			{
				return pEvent;
			}
		}
	}

	return NULL;
}

inline void CEventContainer::DeleteEvent(int iIndex)
{
	m_Events.RemoveAt(iIndex);
}

inline void CEventContainer::DeleteEvent(const CString& sStatusGuid)
{
	for( int i = (int)m_Events.GetSize() - 1; i >= 0; i-- )
	{
		CEvent* pEvent = m_Events[i];
		if( pEvent && GfxCheckObjPtr((CObject*)pEvent,CEvent) )
		{
			if( ! pEvent->m_sStatusGuid.IsEmpty() && pEvent->m_sStatusGuid == sStatusGuid )
			{
				DeleteEvent(i);
			}
		}
	}
}

inline void CEventContainer::DeleteEvents()
{
	for( int i = (int)m_Events.GetSize() - 1; i >= 0; i-- )
	{
		DeleteEvent(i);
	}
}

inline void CEventContainer::DeleteSystemEvents(const CString& sSystemName)
{
	for( int i = (int)m_Events.GetSize() - 1; i >= 0; i-- )
	{
		CEvent* pEvent = m_Events[i];
		if( pEvent && GfxCheckObjPtr((CObject*)pEvent,CEvent) )
		{
			if( LPCTSTR(pEvent->m_sSystemName) )
      {
        if( pEvent->m_sSystemName.GetLength() && pEvent->m_sSystemName == sSystemName )
			  {
				  DeleteEvent(i);
			  }
      }
      else
      {
        ASSERT(FALSE);
      }
		}
	}
}

inline int CEventContainer::GetEventCount()
{
	return (int)m_Events.GetSize();
}

inline CEvent* CEventContainer::GetEvent(int iIndex)
{
	if( iIndex < 0 )	
	{
		return NULL;
	}

	if( iIndex > m_Events.GetUpperBound() )
	{
		return NULL;
	}

	return m_Events[iIndex];
}

inline CString CEventContainer::GetLastEventDTime()
{
	CEvent* pEvent = GetEvent(GetEventCount()-1);
	if( ! pEvent )
	{
		return _T("");
	}

	return pEvent->GetEventLocalTime();
}

//////////////////////////////////////////////////////////////////////
// Statistics Members
//////////////////////////////////////////////////////////////////////

inline void CEventContainer::AddStatistic(CStatistics* pStatistic)
{
	if( ! pStatistic || ! GfxCheckObjPtr((CObject*)pStatistic,CStatistics) )
	{
    ASSERT(FALSE);
		return;
	}

	for( int i = 0; i < m_Statistics.GetSize(); i++ )
	{
		if( pStatistic->CompareTo(m_Statistics[i]) )
		{
			delete pStatistic;
			return;
		}
	}

  if( m_Statistics.GetSize() > 50 )
  {
    delete m_Statistics[0];
    m_Statistics.RemoveAt(0);
  }

	m_Statistics.Add(pStatistic);

	// determine if this container has a config object connected to it
	// if a config object is connected then
	//		if the config object is the selected object then
	//			add a results pane item to the results view for this event
	CHMObject* pObject = GetObjectPtr();
	if( pObject )
	{
		CHMScopeItem* pItem = (CHMScopeItem*)pObject->IsSelected();
		if( pItem && GfxCheckObjPtr(pItem,CHMScopeItem) )
		{
			CSplitPaneResultsView* pView = (CSplitPaneResultsView*)pItem->GetResultsPaneView();
			if( ! GfxCheckObjPtr(pView,CSplitPaneResultsView) )
			{
				ASSERT(FALSE);
				return;
			}

			pView->AddStatistic(this,pStatistic);
		}
	}

}

inline void CEventContainer::AddStatistics(StatsArray& Statistics)
{
	for( int i = 0; i < Statistics.GetSize(); i++ )
	{
		AddStatistic(Statistics[i]);
	}
}

inline void CEventContainer::DeleteStatistics()
{
	for( int i = (int)m_Statistics.GetSize()-1; i >= 0; i-- )
	{
		if( m_Statistics[i] && GfxCheckObjPtr((CObject*)m_Statistics[i],CStatistics) )
		{
			delete m_Statistics[i];
			m_Statistics.RemoveAt(i);
		}
	}
}

inline int CEventContainer::GetStatisticsCount()
{
	return (int)m_Statistics.GetSize();
}

inline CStatistics* CEventContainer::GetStatistic(int iIndex)
{
	if( iIndex < 0 )	
	{
		return NULL;
	}

	if( iIndex > m_Statistics.GetUpperBound() )
	{
		return NULL;
	}

	return m_Statistics[iIndex];
}

//////////////////////////////////////////////////////////////////////
// Configuration Association Members
//////////////////////////////////////////////////////////////////////

inline CHMObject* CEventContainer::GetObjectPtr()
{
	if( ! m_pObject )
	{
		return NULL;
	}

	if( ! GfxCheckObjPtr(m_pObject,CHMObject) )
	{
		return NULL;
	}

	return m_pObject;
}

inline void CEventContainer::SetObjectPtr(CHMObject* pObject)
{
	if( ! pObject )
	{
		m_pObject = NULL;
		return;
	}

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		m_pObject = NULL;
		return;
	}

	m_pObject = pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\fileversion.cpp ===
// FileVersion.cpp: implementation of the CFileVersion class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FileVersion.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileVersion::CFileVersion() 
{ 
  m_lpVersionData = NULL;
  m_dwLangCharset = 0;
}

CFileVersion::~CFileVersion() 
{ 
  Close();
} 

void CFileVersion::Close()
{
	delete[] m_lpVersionData; 
	m_lpVersionData = NULL;
	m_dwLangCharset = 0;
}

BOOL CFileVersion::Open(LPCTSTR lpszModuleName)
{
	ASSERT(_tcslen(lpszModuleName) > 0);
	ASSERT(m_lpVersionData == NULL);

	// Get the version information size for allocate the buffer
	DWORD dwHandle;     
	DWORD dwDataSize = ::GetFileVersionInfoSize((LPTSTR)lpszModuleName, &dwHandle); 
	if ( dwDataSize == 0 ) 
		return FALSE;

	// Allocate buffer and retrieve version information
	m_lpVersionData = new BYTE[dwDataSize]; 
	if (!::GetFileVersionInfo((LPTSTR)lpszModuleName, dwHandle, dwDataSize, 
												(void**)m_lpVersionData) )
	{
		Close();
		return FALSE;
	}

	// Retrieve the first language and character-set identifier
	UINT nQuerySize;
	DWORD* pTransTable;
	if (!::VerQueryValue(m_lpVersionData, _T("\\VarFileInfo\\Translation"),
										 (void **)&pTransTable, &nQuerySize) )
	{
		Close();
		return FALSE;
	}

	// Swap the words to have lang-charset in the correct format
	m_dwLangCharset = MAKELONG(HIWORD(pTransTable[0]), LOWORD(pTransTable[0]));

	return TRUE;
}

CString CFileVersion::QueryValue(LPCTSTR lpszValueName, 
                                 DWORD dwLangCharset /* = 0*/)
{
	// Must call Open() first
//  ASSERT(m_lpVersionData != NULL);
	if ( m_lpVersionData == NULL )
		return (CString)_T("");

	// If no lang-charset specified use default
	if ( dwLangCharset == 0 )
		dwLangCharset = m_dwLangCharset;

	// Query version information value
	UINT nQuerySize;
	LPVOID lpData;
	CString strValue, strBlockName;
	strBlockName.Format(_T("\\StringFileInfo\\%08lx\\%s"), 
									 dwLangCharset, lpszValueName);
	if ( ::VerQueryValue((void **)m_lpVersionData, strBlockName.GetBuffer(0), 
									 &lpData, &nQuerySize) )
		strValue = (LPCTSTR)lpData;

	strBlockName.ReleaseBuffer();

	return strValue;
}

BOOL CFileVersion::GetFixedInfo(VS_FIXEDFILEINFO& vsffi)
{
	// Must call Open() first
	ASSERT(m_lpVersionData != NULL);
	if ( m_lpVersionData == NULL )
		return FALSE;

	UINT nQuerySize;
	VS_FIXEDFILEINFO* pVsffi;
	if ( ::VerQueryValue((void **)m_lpVersionData, _T("\\"),
										 (void**)&pVsffi, &nQuerySize) )
	{
		vsffi = *pVsffi;
		return TRUE;
	}

	return FALSE;
}

CString CFileVersion::GetFixedFileVersion()
{
  CString strVersion;
	VS_FIXEDFILEINFO vsffi;

  if ( GetFixedInfo(vsffi) )
  {
      strVersion.Format(_T("%u,%u,%u,%u"),HIWORD(vsffi.dwFileVersionMS),
          LOWORD(vsffi.dwFileVersionMS),
          HIWORD(vsffi.dwFileVersionLS),
          LOWORD(vsffi.dwFileVersionLS));
  }
  return strVersion;
}

CString CFileVersion::GetFixedProductVersion()
{
	CString strVersion;
	VS_FIXEDFILEINFO vsffi;

	if ( GetFixedInfo(vsffi) )
	{
		strVersion.Format(_T("%u,%u,%u,%u"), HIWORD(vsffi.dwProductVersionMS),
				LOWORD(vsffi.dwProductVersionMS),
				HIWORD(vsffi.dwProductVersionLS),
				LOWORD(vsffi.dwProductVersionLS));
	}
	return strVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventmanager.inl ===
// 04/09/00 v-marfin 63119 : converted m_iCurrent to string


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

inline void CEventManager::ProcessEvent(CWbemClassObject* pEventObject)
{
	if( pEventObject == NULL )
	{
		ASSERT(FALSE);
		return;
	}
	
	if( pEventObject->GetMachineName().IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}

  // three possible flavors of events
  //    - threshold
  //    - data collector
  //    - everything else

	EventArray SystemEvents;
  
  CString sClass;
  pEventObject->GetClassName(sClass);

  if( ! sClass.CompareNoCase(_T("Microsoft_HMThresholdStatusInstance")) )
  {
    ProcessRuleStatusInstanceEvent(pEventObject,SystemEvents);
  }
  else if( ! sClass.CompareNoCase(_T("Microsoft_HMThresholdStatus")) )
  {
    ProcessRuleStatusEvent(pEventObject);
  }
  else if( ! sClass.CompareNoCase(_T("Microsoft_HMDataCollectorStatus")) )
  {
    ProcessDataElementStatusEvent(pEventObject,SystemEvents);
  }
  else if( ! sClass.CompareNoCase(_T("Microsoft_HMDataGroupStatus")) )
  {
    ProcessDataGroupStatusEvent(pEventObject);
  }
  else if( ! sClass.CompareNoCase(_T("Microsoft_HMSystemStatus")) )
  {
    ProcessSystemStatusEvent(pEventObject);
  }
  else if( ! sClass.CompareNoCase(_T("Microsoft_HMDataCollectorStatistics")) )
  {
    ProcessStatisticEvent(pEventObject);
  }
  else
  {
    return;
  }

	// propogate these events up to the root system group event container
	CTreeNode<CEventContainer*>* pSystemNode = NULL;
	if( ! m_SystemNameToContainerMap.Lookup(pEventObject->GetMachineName(),pSystemNode) )
	{
		ASSERT(FALSE);
		return;
	}

	CTreeNode<CEventContainer*>* pParentNode = pSystemNode->GetParent();
	while(pParentNode)
	{
		CEventContainer* pContainer = pParentNode->GetObject();
		ASSERT(pContainer);
		if( pContainer )
		{
			pContainer->AddEvents(SystemEvents);
		}
		pParentNode = pParentNode->GetParent();
	}

	// also propogate to associated nodes of the system
	for( int i = 0; i < pSystemNode->GetAssocCount(); i++ )
	{
		CTreeNode<CEventContainer*>* pAssocNode = pSystemNode->GetAssoc(i);
		if( pAssocNode )
		{
			CEventContainer* pContainer = pAssocNode->GetObject();
			if( pContainer )
			{
				pContainer->AddEvents(SystemEvents);
				pParentNode = pAssocNode->GetParent();
				while(pParentNode)
				{
					CEventContainer* pContainer = pParentNode->GetObject();
					ASSERT(pContainer);
					if( pContainer )
					{
						pContainer->AddEvents(SystemEvents);
					}
					pParentNode = pParentNode->GetParent();
				}
			}
		}
	}
}

inline void CEventManager::ProcessUnknownEvent(const CString& sSystemName, CRuleEvent* pUnknownEvent)
{
	if( sSystemName.IsEmpty() )
	{
		return;
	}

	if( ! pUnknownEvent )
	{
		return;
	}

	// add event to the system container
	CTreeNode<CEventContainer*>* pSystemNode = NULL;
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pSystemNode) )
	{
		ASSERT(FALSE);
		return;
	}

	CEventContainer* pContainer = pSystemNode->GetObject();
	if( ! pContainer )
	{
		return;
	}

	pContainer->AddEvent(pUnknownEvent);
	pContainer->m_iState = 6;

	// propogate these events up to the root system group event container
	CTreeNode<CEventContainer*>* pParentNode = pSystemNode->GetParent();
	while(pParentNode)
	{
		CEventContainer* pContainer = pParentNode->GetObject();
		ASSERT(pContainer);
		if( pContainer )
		{
			pContainer->AddEvent(pUnknownEvent);
			pContainer->m_iState = 6;
		}
		pParentNode = pParentNode->GetParent();
	}

	// also propogate to associated nodes of the system
	for( int i = 0; i < pSystemNode->GetAssocCount(); i++ )
	{
		CTreeNode<CEventContainer*>* pAssocNode = pSystemNode->GetAssoc(i);
		if( pAssocNode )
		{
			CEventContainer* pContainer = pAssocNode->GetObject();
			if( pContainer )
			{
				pContainer->AddEvent(pUnknownEvent);
				pParentNode = pAssocNode->GetParent();
				while(pParentNode)
				{
					CEventContainer* pContainer = pParentNode->GetObject();
					ASSERT(pContainer);
					if( pContainer )
					{
						pContainer->AddEvent(pUnknownEvent);
						pContainer->m_iState = 6;
					}
					pParentNode = pParentNode->GetParent();
				}
			}
		}
	}
}

inline void CEventManager::ProcessActionEvent(CWbemClassObject* pActionEventObject)
{
  if( pActionEventObject == NULL )
  {
    ASSERT(FALSE);
    return;
  }

	// Config Guid
  CString sGuid;
	HRESULT hr = pActionEventObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

	// find the action container node by its guid
	CEventContainer* pContainer = NULL;
	GetEventContainer(pActionEventObject->GetMachineName(),sGuid,pContainer);
	if( pContainer == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	CString sClass;
	hr = pActionEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMActionStatus")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	EventArray DataGroupEvents;

  // GUID
  pContainer->m_sConfigurationGuid = sGuid;

	// Name  
	CString sName;
  hr = pActionEventObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sName);
	CHECKHRESULT(hr);
  
	// NumberNormals  
  hr = pActionEventObject->GetProperty(IDS_STRING_MOF_NUMBERNORMALS,pContainer->m_iNumberNormals);
	CHECKHRESULT(hr);

	// NumberWarnings  
  hr = pActionEventObject->GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,pContainer->m_iNumberWarnings);
	CHECKHRESULT(hr);

	// NumberCriticals  
  hr = pActionEventObject->GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,pContainer->m_iNumberCriticals);
	CHECKHRESULT(hr);

	// State  
    hr = pActionEventObject->GetProperty(IDS_STRING_MOF_STATE,pContainer->m_iState);
	CHECKHRESULT(hr);
    
    // v-marfin 59492 ---------------------------------------------------------------------
	CHECKHRESULT(hr);
	if( pContainer->GetObjectPtr() )
	{
		pContainer->GetObjectPtr()->SetState(CEvent::GetStatus(pContainer->m_iState),true);
	}
    //--------------------------------------------------------------------------------------
}

inline void CEventManager::ProcessStatisticEvent(CWbemClassObject* pStatObject)
{
	if( ! pStatObject )
	{
		ASSERT(FALSE);
		return;
	}

	CString sClass;
	HRESULT hr = pStatObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMDataCollectorStatistics")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	CString sGuid;
	hr = pStatObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	if( sGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

	// find the data element container node with the appropriate Guid
	// this must exist to continue processing
	CEventContainer* pContainer = NULL;
	GetEventContainer(pStatObject->GetMachineName(),sGuid,pContainer);
	if( pContainer == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	CDataPointStatistics* pDPStat = new CDataPointStatistics;
  StatsArray Statistics;

	// DTime  
	CTime time;
	hr = pStatObject->GetProperty(IDS_STRING_MOF_LOCALTIME,time);  	
  time.GetAsSystemTime(pDPStat->m_st);

  // PropertyName
  hr = pStatObject->GetProperty(IDS_STRING_MOF_PROPERTYNAME,pDPStat->m_sPropertyName);	
	
	CString sValue;
	
	// InstanceName
	hr = pStatObject->GetProperty(IDS_STRING_MOF_INSTANCENAME,pDPStat->m_sInstanceName);

	// CurrentValue
	// 63119 hr = pStatObject->GetProperty(IDS_STRING_MOF_CURRENTVALUE,sValue);
	// 63119 pDPStat->m_iCurrent =	_ttoi(sValue);
    hr = pStatObject->GetProperty(IDS_STRING_MOF_CURRENTVALUE,pDPStat->m_strCurrent);


	// MinValue
	hr = pStatObject->GetProperty(IDS_STRING_MOF_MINVALUE,sValue);
	pDPStat->m_iMin =	_ttoi(sValue);

	// MaxValue
	hr = pStatObject->GetProperty(IDS_STRING_MOF_MAXVALUE,sValue);
	pDPStat->m_iMax =	_ttoi(sValue);

	// AvgValue
	hr = pStatObject->GetProperty(IDS_STRING_MOF_AVGVALUE,sValue);
	pDPStat->m_iAvg =	_ttoi(sValue);

	Statistics.Add(pDPStat);

	PropogateStatisticsToChildren(pStatObject->GetMachineName(),sGuid,Statistics);

	pContainer->AddStatistics(Statistics);	
}

inline void CEventManager::GetEventContainer(const CString& sSystemName, const CString& sGuid, CEventContainer*& pContainer)
{
	// get a container beneath a system - Guid is filled out and SystemName is filled out

	// get a container above a system - SystemName is blank and Guid is filled out

	// get a container for a system - System Name is filled out and Guid is empty

	CTreeNode<CEventContainer*>* pNode = NULL;

	if( ! sGuid.IsEmpty() && sGuid != _T("@") )
	{
		if( ! m_GuidToContainerMap.Lookup(sGuid,pNode) )
		{
			if( sSystemName.IsEmpty() )
			{
				ASSERT(FALSE);
				pContainer = NULL;
				return;
			}

			if( ! m_GuidToContainerMap.Lookup(GetCompositeGuid(sSystemName,sGuid),pNode) )
			{
				pContainer = NULL;
				return;
			}
		}

		pContainer = pNode->GetObject();
		ASSERT(pContainer);
		if( pContainer->m_sConfigurationGuid != sGuid )
		{
			ASSERT(FALSE);
			pContainer = NULL;
		}
	}
	else if( ! sSystemName.IsEmpty() )
	{
		if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pNode) )
		{
			ASSERT(FALSE);
			return;
		}

		pContainer = pNode->GetObject();
		ASSERT(pContainer);
	}
}  

inline void CEventManager::DeleteEvents(const CString& sSystemName, const CString& sStatusGuid)
{
	ASSERT(!sSystemName.IsEmpty());
	if( sSystemName.IsEmpty() )
	{
		return;
	}

	DeleteEvents(m_EventContainers.GetRootNode(),sSystemName,sStatusGuid);	

	CTreeNode<CEventContainer*>* pSystemNode = NULL;
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pSystemNode) )	
	{
		ASSERT(FALSE);
		return;
	}
	ASSERT(pSystemNode);

	if( ! pSystemNode )
	{
		ASSERT(FALSE);
		return;
	}

	CEventContainer* pContainer = pSystemNode->GetObject();

	if( ! pContainer )
	{
		ASSERT(FALSE);
		return;
	}

	if( sStatusGuid.IsEmpty() )
	{
		pContainer->DeleteSystemEvents(sSystemName);
	}
	else
	{
		pContainer->DeleteEvent(sStatusGuid);
	}
}

inline void CEventManager::DeleteEvents(CTreeNode<CEventContainer*>* pNode,const CString& sSystemName, const CString& sStatusGuid)
{
	ASSERT(pNode);
	if( pNode == NULL )
	{
		return;
	}
	
	CEventContainer* pContainer = pNode->GetObject();
	ASSERT(pContainer);
	if( pContainer == NULL )
	{
		return;
	}

	ASSERT(!sSystemName.IsEmpty());

	// skip over this node if it is the system node
	CTreeNode<CEventContainer*>* pSystemNode = NULL;
	m_SystemNameToContainerMap.Lookup(sSystemName,pSystemNode);
	if( pSystemNode != pNode )
	{
		// if status guid is filled out, then delete only the event which corresponds to it

		// if the system name is filled out and status guid is not, then delete all the events for the system

		if( ! sStatusGuid.IsEmpty() )
		{
			pContainer->DeleteEvent(sStatusGuid);
		}
		else if( ! sSystemName.IsEmpty() )
		{
			pContainer->DeleteSystemEvents(sSystemName);
		}
		else
		{
			ASSERT(FALSE);
		}
	}

	for( int i = 0; i < pNode->GetChildCount(); i++ )
	{
		DeleteEvents(pNode->GetChild(i),sSystemName,sStatusGuid);
	}
}

inline void CEventManager::AddContainer(const CString& sSystemName, const CString& sParentGuid, const CString& sGuid, CHMObject* pObject, CRuntimeClass* pClass)
{
	ASSERT(pClass);
	if( ! pClass )
	{
		return;
	}

	ASSERT(!sGuid.IsEmpty());
	if( sGuid.IsEmpty() )
	{
		return;
	}

	// we could be adding a system group - systemname == NULL, parentguid could be null, sguid valid
	// we could be adding something below a system - systemname valid, parentguid == "@" or is valid, sguid valid
	CString _sGuid = sGuid;
	CString _sParentGuid = sParentGuid;

	if( ! sSystemName.IsEmpty() && ! sParentGuid.IsEmpty() && ! sGuid.IsEmpty() )
	{
		_sGuid = GetCompositeGuid(sSystemName,sGuid);
		_sParentGuid = GetCompositeGuid(sSystemName,sParentGuid);
	}


	// first check if the container already exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;	

	// if it exists, return
	if( m_GuidToContainerMap.Lookup(_sGuid,pExistingNode) )
	{
		ASSERT(pExistingNode);
		ASSERT(pExistingNode->GetObject());
	
		if( pExistingNode->GetObject() && pExistingNode->GetObject()->GetObjectPtr() == NULL )
		{
			pExistingNode->GetObject()->SetObjectPtr(pObject);
		}
		return;
	}
	
	// if the parent guid is filled out, then query for the parent node. It must exist to continue.
	CTreeNode<CEventContainer*>* pParentNode = NULL;
	if( ! sParentGuid.IsEmpty() )
	{
		if( ! m_GuidToContainerMap.Lookup(_sParentGuid,pParentNode) )
		{
			ASSERT(sParentGuid == _T("@"));
			if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pParentNode) )
			{
				ASSERT(FALSE);
				return;
			}
		}

		ASSERT(pParentNode);

		if( pParentNode == NULL )
		{	
			return;
		}
	}

	// if the container with guid does not exist then
	//		create a new Node in the tree, NewNode
	//		create a new event container and associate it with NewNode
	//		if the node to add has a parent (parentguid filled out) then
	//			add NewNode as child of ParentNode
	//		else if the node has no parent then
	//			set the NewNode to be the RootNode of the EventContainer tree
	//		add the GUID,Node key-value pair to the container map
	
	CTreeNode<CEventContainer*>* pNewNode = new CTreeNode<CEventContainer*>;
	CEventContainer* pNewContainer = (CEventContainer*)pClass->CreateObject();
	pNewContainer->m_sConfigurationGuid = sGuid;
	pNewContainer->SetObjectPtr(pObject);
	pNewNode->SetObject(pNewContainer);

	if( pParentNode ) 
	{
		pParentNode->AddChild(pNewNode);
		pNewNode->SetParent(pParentNode);
	}
	else
	{
		ASSERT( m_EventContainers.GetRootNode() == NULL);
		if( m_EventContainers.GetRootNode() != NULL  )
		{
			delete pNewNode;
			delete pNewContainer;
			return;
		}

		pNewNode->SetParent(NULL);
		m_EventContainers.SetRootNode(pNewNode);
	}

	m_GuidToContainerMap.SetAt(_sGuid,pNewNode);
}

inline void CEventManager::RemoveContainer(const CString& sSystemName, const CString& sGuid)
{
	ASSERT(!sGuid.IsEmpty());

	if( sGuid.IsEmpty() )
	{
		return;
	}

	// first check if the container exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it exists, delete it and remove the key from the guid to container map

	// try the normal guid
	if( m_GuidToContainerMap.Lookup(sGuid,pExistingNode) )
	{
		ASSERT(pExistingNode);
		ASSERT(pExistingNode->GetObject());
		if( pExistingNode )
		{
			if( pExistingNode == m_EventContainers.GetRootNode() )
			{
				m_EventContainers.SetRootNode(NULL);
			}
			delete pExistingNode;			
			m_GuidToContainerMap.RemoveKey(sGuid);
		}
		return;
	}

	// try the composite guid
	if( m_GuidToContainerMap.Lookup(GetCompositeGuid(sSystemName,sGuid),pExistingNode) )
	{
		ASSERT(pExistingNode);
		ASSERT(pExistingNode->GetObject());
		if( pExistingNode )
		{
			delete pExistingNode;			
			m_GuidToContainerMap.RemoveKey(sGuid);
		}
		return;
	}

	ASSERT(FALSE); // did not find it
}

inline void CEventManager::AddSystemContainer(const CString& sParentGuid, const CString& sSystemName, CHMObject* pObject)
{
	// parent guid must be filled out to continue
	ASSERT(!sParentGuid.IsEmpty());
	if( sParentGuid.IsEmpty() )
	{
		return;
	}

	// first check if the container already exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it exists, return
	if( m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
		ASSERT(pExistingNode);
		ASSERT(pExistingNode->GetObject());
		if( pExistingNode->GetObject() )
		{
			pExistingNode->GetObject()->SetObjectPtr(pObject);
		}
		return;
	}
	
	// query for the parent node. It must exist to continue.
	CTreeNode<CEventContainer*>* pParentNode = NULL;
	if( ! m_GuidToContainerMap.Lookup(sParentGuid,pParentNode) )
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(pParentNode);

	if( pParentNode == NULL )
	{	
		return;
	}

	// if the container with guid does not exist then
	//		create a new Node in the tree, NewNode
	//		create a new system event container and associate it with NewNode
	//		if the node to add has a parent (parentguid filled out) then
	//			add NewNode as child of ParentNode
	//		else if the node has no parent then
	//			set the NewNode to be the RootNode of the EventContainer tree
	//		add the GUID,Node key-value pair to the container map
	
	CTreeNode<CEventContainer*>* pNewNode = new CTreeNode<CEventContainer*>;
	CSystemEventContainer* pNewContainer = new CSystemEventContainer;
	pNewContainer->m_sConfigurationGuid = _T("@");
	pNewContainer->SetObjectPtr(pObject);
	pNewNode->SetObject(pNewContainer);

	pParentNode->AddChild(pNewNode);
	pNewNode->SetParent(pParentNode);

	m_SystemNameToContainerMap.SetAt(sSystemName,pNewNode);
}

inline void CEventManager::RemoveSystemContainer(const CString& sSystemName)
{
	ASSERT(!sSystemName.IsEmpty());
	if( sSystemName.IsEmpty() )
	{
		return;
	}

	// first check if the container exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it does not exist, return
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
		ASSERT(FALSE);
		return;
	}

	// make certain the node is valid
	ASSERT(pExistingNode);
	if( pExistingNode == NULL )
	{
		return;
	}

	// destroy all the events for this system from the tree
	DeleteEvents(sSystemName,_T(""));

	// destroy the node and all its children and then remove the system name key from the map
	CTreeNode<CEventContainer*>* pParentNode = pExistingNode->GetParent();
	ASSERT(pParentNode);
	if( ! pParentNode )
	{
		return;
	}
	pParentNode->RemoveChild(pExistingNode);
	m_SystemNameToContainerMap.RemoveKey(sSystemName);

	// clean up the GuidToContainer map by deleting any keys left around
	POSITION pos = m_GuidToContainerMap.GetStartPosition();	
	CString sKey;
	CTreeNode<CEventContainer*>* pNode = NULL;
	while(pos != NULL)
	{
		m_GuidToContainerMap.GetNextAssoc(pos,sKey,pNode);
		if( sKey.Find(sSystemName) != -1 )
		{
			m_GuidToContainerMap.RemoveKey(sKey);
		}
	}

}

inline void CEventManager::AddSystemShortcutAssociation(const CString& sParentGuid, const CString& sSystemName)
{
	// parent guid must be filled out to continue
	ASSERT(!sParentGuid.IsEmpty());
	if( sParentGuid.IsEmpty() )
	{
		return;
	}

	// first check if the container already exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it does not exist, return
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
		return;
	}
	
	ASSERT(pExistingNode);
	if( !pExistingNode )
	{
		return;
	}
	
	ASSERT(pExistingNode->GetObject());	
	if(! pExistingNode->GetObject() )
	{
		return;
	}

	// query for the parent node. It must exist to continue.
	CTreeNode<CEventContainer*>* pParentNode = NULL;
	if( ! m_GuidToContainerMap.Lookup(sParentGuid,pParentNode) )
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(pParentNode);

	if( pParentNode == NULL )
	{	
		return;
	}

	pExistingNode->AddAssoc(pParentNode);	

	// pump events up from the associated node to the root
	CEventContainer* pSystemContainer = pExistingNode->GetObject();
	ASSERT(pSystemContainer);
	if( ! pSystemContainer )
	{
		return;
	}

	while(pParentNode)
	{
		CEventContainer* pContainer = pParentNode->GetObject();
		ASSERT(pContainer);
		if( pContainer )
		{
      for( int i = 0; i < pSystemContainer->GetEventCount(); i++ )
      {        
			  pContainer->AddEvent(pSystemContainer->GetEvent(i));
      }
		}
		pParentNode = pParentNode->GetParent();
	}

}

inline void CEventManager::RemoveSystemShortcutAssociation(const CString& sParentGuid, const CString& sSystemName)
{
	// parent guid must be filled out to continue
	ASSERT(!sParentGuid.IsEmpty());
	if( sParentGuid.IsEmpty() )
	{
		return;
	}

	// first check if the container already exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it exists, return
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
    ASSERT(FALSE);
		return;
	}

	ASSERT(pExistingNode);
	ASSERT(pExistingNode->GetObject());
	
	// query for the parent node. It must exist to continue.
	CTreeNode<CEventContainer*>* pParentNode = NULL;
	if( ! m_GuidToContainerMap.Lookup(sParentGuid,pParentNode) )
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(pParentNode);

	if( pParentNode == NULL )
	{	
		return;
	}

	pExistingNode->RemoveAssoc(pParentNode);	
  
  // destroy system events for the parents
  while( pParentNode )
  {
    pParentNode->GetObject()->DeleteSystemEvents(sSystemName);
    if( pParentNode->GetParent() && pParentNode->GetParent()->GetParent() )
    {
      pParentNode = pParentNode->GetParent();      
    }
    else
    {
      pParentNode = NULL;
    }
  }
}

inline int CEventManager::GetStatus(const CString& sSystemName, const CString& sGuid)
{
	ASSERT(!sGuid.IsEmpty());
	if( sGuid.IsEmpty() )
	{
		return -1;
	}

	// first check if the container exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it does not exist, return
	if( ! m_GuidToContainerMap.Lookup(sGuid,pExistingNode) )
	{		
		if( ! m_GuidToContainerMap.Lookup(GetCompositeGuid(sSystemName,sGuid),pExistingNode) )
		{
			ASSERT(FALSE);
			return -1;
		}
	}

	ASSERT(pExistingNode);
	if( ! pExistingNode )
	{
		return -1;
	}

	ASSERT(pExistingNode->GetObject());
	if( ! pExistingNode->GetObject() )
	{
		return -1;
	}
	
	return CEvent::GetStatus(pExistingNode->GetObject()->m_iState);
}

inline int CEventManager::GetSystemStatus(const CString& sSystemName)
{
	ASSERT(!sSystemName.IsEmpty());
	if( sSystemName.IsEmpty() )
	{
		return -1;
	}

	// first check if the system container exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it does not exist, return
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
		ASSERT(FALSE);
		return -1;
	}

	ASSERT(pExistingNode);
	if( ! pExistingNode )
	{
		return -1;
	}

	ASSERT(pExistingNode->GetObject());
	if( ! pExistingNode->GetObject() )
	{
		return -1;
	}
	
	return CEvent::GetStatus(pExistingNode->GetObject()->m_iState);
}

inline void CEventManager::ActivateStatisticsEvents(const CString& sSystemName, const CString& sGuid)
{
	CEventContainer* pContainer = NULL;
	GetEventContainer(sSystemName,sGuid,pContainer);
	if( ! pContainer && ! pContainer->IsKindOf(RUNTIME_CLASS(CDataPointEventContainer)) )
	{
		ASSERT(FALSE);
		return;
	}

	CDataPointEventContainer* pDPContainer = (CDataPointEventContainer*)pContainer;
	
	ASSERT(pDPContainer->m_pDEStatsListener == NULL);
	if( pDPContainer->m_pDEStatsListener )
	{
		return;
	}

	pDPContainer->m_pDEStatsListener = new CDataElementStatsListener;
	CString sQuery;
	sQuery.Format(IDS_STRING_STATISTICS_EVENTQUERY,sGuid);
	pDPContainer->m_pDEStatsListener->SetEventQuery(sQuery);
	pDPContainer->m_pDEStatsListener->SetObjectPtr(pContainer->GetObjectPtr());
	pDPContainer->m_pDEStatsListener->Create();
}

inline void CEventManager::DeactivateStatisticsEvents(const CString& sSystemName, const CString& sGuid)
{
	CDataPointEventContainer* pContainer = NULL;
	GetEventContainer(sSystemName,sGuid,(CEventContainer*&)pContainer);
	if( ! pContainer && ! pContainer->IsKindOf(RUNTIME_CLASS(CDataPointEventContainer)) )
	{
		ASSERT(FALSE);
		return;
	}

	CDataPointEventContainer* pDPContainer = (CDataPointEventContainer*)pContainer;

	ASSERT(pDPContainer->m_pDEStatsListener);
	if( pDPContainer->m_pDEStatsListener )
	{
		delete pDPContainer->m_pDEStatsListener;
		pDPContainer->m_pDEStatsListener = NULL;
	}
}

inline void CEventManager::ActivateSystemEventListener(const CString& sSystemName)
{
	ASSERT(!sSystemName.IsEmpty());
	if( sSystemName.IsEmpty() )
	{
		return;
	}

	// first check if the system container exists
	CTreeNode<CEventContainer*>* pExistingNode = NULL;

	// if it does not exist, return
	if( ! m_SystemNameToContainerMap.Lookup(sSystemName,pExistingNode) )
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(pExistingNode);
	if( ! pExistingNode )
	{
		return;
	}

  CSystemEventContainer* pSystemContainer = (CSystemEventContainer*)pExistingNode->GetObject();
  
  ASSERT(pSystemContainer);
  if( ! pSystemContainer )
  {
    return;
  }
  
	// create the system status listener
  ASSERT(pSystemContainer->m_pSystemStatusListener == NULL);
  if( pSystemContainer->m_pSystemStatusListener == NULL )
  {
	  pSystemContainer->m_pSystemStatusListener = new CSystemStatusListener;
	  pSystemContainer->m_pSystemStatusListener->SetObjectPtr(pSystemContainer->GetObjectPtr());
	  pSystemContainer->m_pSystemStatusListener->Create();

	  HRESULT hr = S_OK;
	  IWbemObjectSink* pSink = pSystemContainer->m_pSystemStatusListener->GetSink();
	  
    if( !CHECKHRESULT(hr = CnxExecQueryAsync(sSystemName,IDS_STRING_STATUS_QUERY,pSink)) )
    {
      TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
    }

  }
}

inline void CEventManager::ProcessSystemStatusEvent(CWbemClassObject* pEventObject)
{
	// find the system container node named sSystemName
	CEventContainer* pContainer = NULL;
	GetEventContainer(pEventObject->GetMachineName(),_T(""),pContainer);
	if( pContainer == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	CString sClass;
	HRESULT hr = pEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMSystemStatus")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	hr = pEventObject->GetProperty(IDS_STRING_MOF_GUID,pContainer->m_sConfigurationGuid);
	CHECKHRESULT(hr);
	pContainer->m_sConfigurationGuid.TrimLeft(_T("{"));
	pContainer->m_sConfigurationGuid.TrimRight(_T("}"));

	// Name  
	CString sName;
  hr = pEventObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sName);
	CHECKHRESULT(hr);
  
	// NumberNormals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERNORMALS,pContainer->m_iNumberNormals);
	CHECKHRESULT(hr);

	// NumberWarnings  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,pContainer->m_iNumberWarnings);
	CHECKHRESULT(hr);

	// NumberCriticals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,pContainer->m_iNumberCriticals);
	CHECKHRESULT(hr);

	// State  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_STATE,pContainer->m_iState);
	CHECKHRESULT(hr);	

	// add statistics
	CTime time = CTime::GetCurrentTime();
	CHMStatistics* pStat = new CHMStatistics;
	pStat->m_sName = sName;
	pStat->m_iNumberCriticals = pContainer->m_iNumberCriticals;
	pStat->m_iNumberNormals = pContainer->m_iNumberNormals;
	pStat->m_iNumberUnknowns = pContainer->m_iNumberUnknowns;
	pStat->m_iNumberWarnings = pContainer->m_iNumberWarnings;
	time.GetAsSystemTime(pStat->m_st);
	pContainer->AddStatistic(pStat);

	CHMObject* pObject = pContainer->GetObjectPtr();
	if( pObject && GfxCheckObjPtr(pObject,CHMObject) )
	{
		pObject->UpdateStatus();
	}
}

inline void CEventManager::ProcessDataGroupStatusEvent(CWbemClassObject* pEventObject)
{
	CString sClass;
	HRESULT hr = pEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMDataGroupStatus")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	CString sGuid;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	if( sGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

  // Parent Guid
  CString sParentGuid;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_PARENT_GUID,sParentGuid);
	CHECKHRESULT(hr);
	if( sParentGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sParentGuid.TrimLeft(_T("{"));
	sParentGuid.TrimRight(_T("}"));

	// find the data group container node with the appropriate Guid
	CEventContainer* pContainer = NULL;
	GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
	if( pContainer == NULL )
	{
		AddContainer(pEventObject->GetMachineName(),sParentGuid,sGuid,NULL);
		GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
		if( pContainer == NULL )
		{
			ASSERT(FALSE);
			return;
		}		
	}

	// Name  
	CString sName;
  hr = pEventObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sName);
	CHECKHRESULT(hr);

	// NumberNormals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERNORMALS,pContainer->m_iNumberNormals);
	CHECKHRESULT(hr);

	// NumberWarnings  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,pContainer->m_iNumberWarnings);
	CHECKHRESULT(hr);

	// NumberCriticals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,pContainer->m_iNumberCriticals);
	CHECKHRESULT(hr);

	// State  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_STATE,pContainer->m_iState);
	CHECKHRESULT(hr);
	if( pContainer->GetObjectPtr() )
	{
		pContainer->GetObjectPtr()->SetState(CEvent::GetStatus(pContainer->m_iState),true);
	}

	// add statistics
	CTime time = CTime::GetCurrentTime();
	CHMStatistics* pStat = new CHMStatistics;
	pStat->m_sName = sName;
	pStat->m_iNumberCriticals = pContainer->m_iNumberCriticals;
	pStat->m_iNumberNormals = pContainer->m_iNumberNormals;
	pStat->m_iNumberUnknowns = pContainer->m_iNumberUnknowns;
	pStat->m_iNumberWarnings = pContainer->m_iNumberWarnings;
	time.GetAsSystemTime(pStat->m_st);
	pContainer->AddStatistic(pStat);


	CHMObject* pObject = pContainer->GetObjectPtr();
	if( pObject && GfxCheckObjPtr(pObject,CHMObject) )
	{
		pObject->UpdateStatus();
	}
}

inline void CEventManager::ProcessDataElementStatusEvent(CWbemClassObject* pEventObject, EventArray& NewEvents)
{
	CString sClass;
	HRESULT hr = pEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMDataCollectorStatus")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	CString sGuid;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	if( sGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

  // Parent Guid
  CString sParentGuid;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_PARENT_GUID,sParentGuid);
	CHECKHRESULT(hr);
	if( sParentGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sParentGuid.TrimLeft(_T("{"));
	sParentGuid.TrimRight(_T("}"));

	// find the data element container node with the appropriate Guid
	CEventContainer* pContainer = NULL;
	GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
	if( pContainer == NULL )
	{
		AddContainer(pEventObject->GetMachineName(),sParentGuid,sGuid,NULL,RUNTIME_CLASS(CDataPointEventContainer));
		GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
		if( pContainer == NULL )
		{
			ASSERT(FALSE);
			return;
		}
	}

	// Name  
	CString sName;
  hr = pEventObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sName);
	CHECKHRESULT(hr);

	// NumberNormals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERNORMALS,pContainer->m_iNumberNormals);
	CHECKHRESULT(hr);

	// NumberWarnings  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,pContainer->m_iNumberWarnings);
	CHECKHRESULT(hr);

	// NumberCriticals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,pContainer->m_iNumberCriticals);
	CHECKHRESULT(hr);

	// State  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_STATE,pContainer->m_iState);
	CHECKHRESULT(hr);
	if( pContainer->GetObjectPtr() )
	{
		pContainer->GetObjectPtr()->SetState(CEvent::GetStatus(pContainer->m_iState),true);
	}

	// create a DataElement event if the message is not null
	
	// ConfigurationMessage
	CString sMessage;
	hr = pEventObject->GetLocaleStringProperty(IDS_STRING_MOF_CONFIG_MESSAGE,sMessage);

	if( ! sMessage.IsEmpty() )
	{
		CDataElementEvent* pDEEvent = new CDataElementEvent;
		
		pDEEvent->m_sMessage = sMessage;
		pDEEvent->m_iState = pContainer->m_iState;		
		pDEEvent->m_sName = sName;
		pDEEvent->m_sSystemName = pEventObject->GetMachineName();

		// StatusGUID
		hr = pEventObject->GetProperty(IDS_STRING_MOF_STATUSGUID,pDEEvent->m_sStatusGuid);
		pDEEvent->m_sStatusGuid.TrimLeft(_T("{"));
		pDEEvent->m_sStatusGuid.TrimRight(_T("}"));

		// DTime  
		CTime time;
		hr = pEventObject->GetProperty(IDS_STRING_MOF_LOCALTIME,time);  
		time.GetAsSystemTime(pDEEvent->m_st);

		// add the event to the container
		pContainer->AddEvent(pDEEvent);
		// add the event to the collection of new events
		NewEvents.Add(pDEEvent);

    // roll this event up to the system level

    CTreeNode<CEventContainer*>* pNode = NULL;
	  if( ! m_GuidToContainerMap.Lookup(GetCompositeGuid(pEventObject->GetMachineName(),sGuid),pNode) )
	  {
		  return;
	  }

	  CTreeNode<CEventContainer*>* pParentNode = pNode;
    CEventContainer* pContainer = NULL;
	  while(pParentNode)
	  {
		  pContainer = pParentNode->GetObject();
		  ASSERT(pContainer);
		  if( pContainer )
		  {
			  pContainer->AddEvents(NewEvents);
		  }
    
      // base case
      if( pContainer->IsKindOf(RUNTIME_CLASS(CSystemEventContainer)) )
      {
        return;
      }

		  pParentNode = pParentNode->GetParent();
	  }
		
	}
}

inline void CEventManager::ProcessRuleStatusEvent(CWbemClassObject* pEventObject)
{
	CString sClass;
	HRESULT hr = pEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMThresholdStatus")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	CString sGuid;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	if( sGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

  // Parent Guid
  CString sParentGuid;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_PARENT_GUID,sParentGuid);
	CHECKHRESULT(hr);
	if( sParentGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sParentGuid.TrimLeft(_T("{"));
	sParentGuid.TrimRight(_T("}"));

	// find the rule container node with the appropriate Guid
	CEventContainer* pContainer = NULL;
	GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
	if( pContainer == NULL )
	{
		AddContainer(pEventObject->GetMachineName(),sParentGuid,sGuid,NULL);
		GetEventContainer(pEventObject->GetMachineName(),sGuid,pContainer);
		if( pContainer == NULL )
		{
			ASSERT(FALSE);
			return;
		}
	}

	// NumberNormals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERNORMALS,pContainer->m_iNumberNormals);
	CHECKHRESULT(hr);

	// NumberWarnings  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,pContainer->m_iNumberWarnings);
	CHECKHRESULT(hr);

	// NumberCriticals  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,pContainer->m_iNumberCriticals);
	CHECKHRESULT(hr);

	// State  
  hr = pEventObject->GetProperty(IDS_STRING_MOF_STATE,pContainer->m_iState);
	CHECKHRESULT(hr);
	if( pContainer->GetObjectPtr() )
	{
		pContainer->GetObjectPtr()->SetState(CEvent::GetStatus(pContainer->m_iState),true);
	}

	CHMObject* pObject = pContainer->GetObjectPtr();
	if( pObject && GfxCheckObjPtr(pObject,CHMObject) )
	{
		pObject->UpdateStatus();
	}
}

inline void CEventManager::ProcessRuleStatusInstanceEvent(CWbemClassObject* pEventObject, EventArray& NewEvents)
{
	CString sClass;
	HRESULT hr = pEventObject->GetClassName(sClass);	

	if( !CHECKHRESULT(hr) || sClass.CompareNoCase(_T("Microsoft_HMThresholdStatusInstance")) != 0 )
	{
		ASSERT(FALSE);
		return;
	}

	// Config Guid
	CString sGuid;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_GUID,sGuid);
	CHECKHRESULT(hr);
	if( sGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}
	sGuid.TrimLeft(_T("{"));
	sGuid.TrimRight(_T("}"));

	// State
	int iState = -1;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_STATE,iState);
	CHECKHRESULT(hr);

	// Message
	CString sMessage;
	hr = pEventObject->GetLocaleStringProperty(IDS_STRING_MOF_MESSAGE,sMessage);

	// StatusGUID
	CString sStatusGuid;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_STATUSGUID,sStatusGuid);
	sStatusGuid.TrimLeft(_T("{"));
	sStatusGuid.TrimRight(_T("}"));

	// DTime  
	CTime time;
	hr = pEventObject->GetProperty(IDS_STRING_MOF_LOCALTIME,time);  	

	// ID  
	int iID = -1;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_ID,iID);

  // DataCollector Name
  CString sDEName;
  hr = pEventObject->GetProperty(IDS_STRING_MOF_DCNAME,sDEName);

	CRuleEvent* pRuleEvent = new CRuleEvent;
	
	pRuleEvent->m_iID = iID;
	pRuleEvent->m_sMessage = sMessage;
	pRuleEvent->m_iState = iState;		
	pRuleEvent->m_sSystemName = pEventObject->GetMachineName();
	pRuleEvent->m_sStatusGuid = sStatusGuid;
	pRuleEvent->m_sName = sDEName;
	time.GetAsSystemTime(pRuleEvent->m_st);

	// add the event to the collection of new events
	NewEvents.Add(pRuleEvent);

  // roll this event up to the system level

  CTreeNode<CEventContainer*>* pNode = NULL;
	if( ! m_GuidToContainerMap.Lookup(GetCompositeGuid(pEventObject->GetMachineName(),sGuid),pNode) )
	{
		return;
	}

	CTreeNode<CEventContainer*>* pParentNode = pNode;
  CEventContainer* pContainer = NULL;
	while(pParentNode)
	{
		pContainer = pParentNode->GetObject();
		ASSERT(pContainer);
		if( pContainer )
		{
			pContainer->AddEvents(NewEvents);
		}
    
    // base case
    if( pContainer && pContainer->IsKindOf(RUNTIME_CLASS(CSystemEventContainer)) )
    {
      return;
    }

		pParentNode = pParentNode->GetParent();
	}

}

inline CString CEventManager::GetCompositeGuid(const CString& sSystemName, const CString& sGuid)
{
	if( sSystemName.IsEmpty() )
	{
		return sGuid;
	}

	return sSystemName + _T("-") + sGuid;
}

inline void CEventManager::PropogateStatisticsToChildren(const CString& sSystemName, const CString& sParentGuid, StatsArray& Statistics)
{
	if( sSystemName.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}

	if( sParentGuid.IsEmpty() )
	{
		ASSERT(FALSE);
		return;
	}

	CTreeNode<CEventContainer*>* pParentNode = NULL;
	if( ! m_GuidToContainerMap.Lookup(GetCompositeGuid(sSystemName,sParentGuid),pParentNode) )
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(pParentNode);
	if( ! pParentNode )
	{
		return;
	}

	// for each child do
	//		for each stat do
	//			create copy of stat
	//			add to child.Statistics
	for( int i = 0; i < pParentNode->GetChildCount(); i++ )
	{
		CTreeNode<CEventContainer*>* pChildNode = pParentNode->GetChild(i);
		ASSERT(pChildNode);
		if( pChildNode )
		{
			CEventContainer* pContainer = pChildNode->GetObject();
			ASSERT(pContainer);
			if( pContainer )
			{
				for( int j = 0; j < Statistics.GetSize(); j++ )
				{
					CStatistics* pStat = Statistics[j];
					if( pStat )
					{
						pContainer->AddStatistic(pStat->Copy());
					}
				}
			}
		}
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\eventmanager.h ===
// EventManager.h: interface for the CEventManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTMANAGER_H__988BB45B_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
#define AFX_EVENTMANAGER_H__988BB45B_8C93_11D3_BE83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SystemEventContainer.h"
#include "WbemClassObject.h"
#include "Tree.h"
#include "DataElementEvent.h"
#include "RuleEvent.h"
#include "HMStatistics.h"
#include "DataPointStatistics.h"
#include "DataPointEventContainer.h"

//////////////////////////////////////////////////////////////////////
// CEventManager - manages events, status and statistics for console

class CEventManager : public CObject  
{

// Construction/Destruction
public:
	CEventManager();
	virtual ~CEventManager();

// Operations
public:
	void ProcessEvent(CWbemClassObject* pEventObject);
	void ProcessUnknownEvent(const CString& sSystemName, CRuleEvent* pEvent);
  void ProcessActionEvent(CWbemClassObject* pActionEventObject);
	void ProcessStatisticEvent(CWbemClassObject* pStatObject);
	void GetEventContainer(const CString& sSystemName, const CString& sGuid, CEventContainer*& pContainer);	
	void DeleteEvents(const CString& sSystemName, const CString& sStatusGuid);
	void AddContainer(const CString& sSystemName, const CString& sParentGuid, const CString& sGuid, CHMObject* pObject, CRuntimeClass* pClass = RUNTIME_CLASS(CEventContainer));
	void RemoveContainer(const CString& sSystemName, const CString& sGuid);
	void AddSystemContainer(const CString& sParentGuid, const CString& sSystemName, CHMObject* pObject);
	void RemoveSystemContainer(const CString& sSystemName);
	void AddSystemShortcutAssociation(const CString& sParentGuid, const CString& sSystemName);
	void RemoveSystemShortcutAssociation(const CString& sParentGuid, const CString& sSystemName);
	int GetStatus(const CString& sSystemName, const CString& sGuid);
	int GetSystemStatus(const CString& sSystemName);
	void ActivateStatisticsEvents(const CString& sSystemName, const CString& sGuid);
	void DeactivateStatisticsEvents(const CString& sSystemName, const CString& sGuid);
  void ActivateSystemEventListener(const CString& sSystemName);
protected:
	void ProcessSystemStatusEvent(CWbemClassObject* pEventObject);
	void ProcessDataGroupStatusEvent(CWbemClassObject* pEventObject);
	void ProcessDataElementStatusEvent(CWbemClassObject* pEventObject, EventArray& NewEvents);
	void ProcessRuleStatusEvent(CWbemClassObject* pEventObject);
	void ProcessRuleStatusInstanceEvent(CWbemClassObject* pEventObject, EventArray& NewEvents);
	void DeleteEvents(CTreeNode<CEventContainer*>* pNode,const CString& sSystemName, const CString& sStatusGuid);
	CString GetCompositeGuid(const CString& sSystemName, const CString& sGuid);
	void PropogateStatisticsToChildren(const CString& sSystemName, const CString& sParentGuid, StatsArray& Statistics);
	
// Attributes
protected:
	CTree<CEventContainer*> m_EventContainers; // tree of event containers
	CTypedPtrMap<CMapStringToPtr,CString,CTreeNode<CEventContainer*>*> m_GuidToContainerMap; // maps Guid of a config object to a event container
	CTypedPtrMap<CMapStringToPtr,CString,CTreeNode<CEventContainer*>*> m_SystemNameToContainerMap; // maps the system name to a system event container
};

#include "EventManager.inl"

extern CEventManager theEvtManager;

inline CEventManager* EvtGetEventManager()
{
	return &theEvtManager;
}

#endif // !defined(AFX_EVENTMANAGER_H__988BB45B_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\fileversion.h ===
// FileVersion.h: interface for the CFileVersion class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEVERSION_H__9D1C1050_06E0_11D2_8362_0000F87A3912__INCLUDED_)
#define AFX_FILEVERSION_H__9D1C1050_06E0_11D2_8362_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CFileVersion  
{
// Construction
public:
	CFileVersion();

// Operations
public: 
  BOOL    Open(LPCTSTR lpszModuleName);
	void    Close();
  CString QueryValue(LPCTSTR lpszValueName, DWORD dwLangCharset = 0);
  CString GetFileDescription()  {return QueryValue(_T("FileDescription")); };
  CString GetFileVersion()      {return QueryValue(_T("FileVersion"));     };
  CString GetInternalName()     {return QueryValue(_T("InternalName"));    };
  CString GetCompanyName()      {return QueryValue(_T("CompanyName"));     }; 
  CString GetLegalCopyright()   {return QueryValue(_T("LegalCopyright"));  };
  CString GetOriginalFilename() {return QueryValue(_T("OriginalFilename"));};
  CString GetProductName()      {return QueryValue(_T("ProductName"));     };
  CString GetProductVersion()   {return QueryValue(_T("ProductVersion"));  };
  BOOL    GetFixedInfo(VS_FIXEDFILEINFO& vsffi);
  CString GetFixedFileVersion();
	CString GetFixedProductVersion();

// Attributes
protected:
	LPBYTE  m_lpVersionData; 
  DWORD   m_dwLangCharset;

// Implementation
public:
	~CFileVersion(); 
};

#endif // !defined(AFX_FILEVERSION_H__9D1C1050_06E0_11D2_8362_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\groupgeneralpage.h ===
#if !defined(AFX_GROUPGENERALPAGE_H__C3F44E7B_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_GROUPGENERALPAGE_H__C3F44E7B_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GroupGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage dialog

class CGroupGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CGroupGeneralPage)

// Construction
public:
	CGroupGeneralPage();
	~CGroupGeneralPage();


// Dialog Data
public:
	//{{AFX_DATA(CGroupGeneralPage)
	enum { IDD = IDD_GROUP_GENERAL };
	CString	m_sComment;
	CString	m_sName;
	CString	m_sCreationDate;
	CString	m_sLastModifiedDate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupGeneralPage)
	public:
	virtual void OnFinalRelease();
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditComment();
	afx_msg void OnDestroy();
	afx_msg void OnChangeEditName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CGroupGeneralPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPGENERALPAGE_H__C3F44E7B_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonresultspane.h ===
// HealthmonResultsPane.h: interface for the CHealthmonResultsPane class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HEALTHMONRESULTSPANE_H__307235A8_AA50_11D2_BD61_0000F87A3912__INCLUDED_)
#define AFX_HEALTHMONRESULTSPANE_H__307235A8_AA50_11D2_BD61_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ResultsPane.h"
#include "constants.h"
#include "hmlistview.h" // OLE dispatch driver class
#include "hmlistvieweventsink.h" // OLE Event Sink class
#include "hmgraphview.h" // OLE dispatch driver class
#include "hmgraphvieweventsink.h" // OLE Event Sink class

class CHealthmonResultsPane : public CResultsPane  
{

DECLARE_DYNCREATE(CHealthmonResultsPane)

// Construction/Destruction
public:
	CHealthmonResultsPane();
	virtual ~CHealthmonResultsPane();

// Creation/Destruction overrideable members
protected:
	virtual bool OnCreateOcx(LPUNKNOWN pIUnknown);
  virtual bool OnDestroy();

// Split Pane Control Result Item Icon Management
public:
	int AddIcon(UINT nIconResID, SplitResultsPane pane);
	int GetIconIndex(UINT nIconResID, SplitResultsPane pane);
	int GetIconCount(SplitResultsPane pane);
	void RemoveAllIcons(SplitResultsPane pane);
protected:
	CMap<UINT,UINT,int,int> m_UpperIconMap;
	CMap<UINT,UINT,int,int> m_LowerIconMap;

// Control bar Members
protected:
	virtual HRESULT OnSetControlbar(LPCONTROLBAR pIControlbar);
	virtual HRESULT OnControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	HBITMAP m_hbmpNewSystem;
  HBITMAP m_hbmpClearEvents;
  HBITMAP m_hbmpResetStatus;
  HBITMAP m_hbmpDisable;

// Splitter Control Members
public:
	_DHMListView* GetUpperListCtrl();
	CHMListViewEventSink* GetUpperListSink();
	_DHMListView* GetLowerListCtrl();
	CHMListViewEventSink* GetLowerListSink();
	_DHMListView* GetStatsListCtrl();
	CHMListViewEventSink* GetStatsListSink();
	_DHMGraphView* GetGraphViewCtrl();
	CHMGraphViewEventSink* GetGraphViewSink();
protected:
	bool LoadListControls(LPUNKNOWN pIUnknown);	
	_DHMListView m_DispUpperList;
	_DHMListView m_DispLowerList;
	_DHMListView m_DispStatsList;
	_DHMGraphView m_DispGraph;
	CHMListViewEventSink m_UpperListSink;
	CHMListViewEventSink m_LowerListSink;
	CHMListViewEventSink m_StatsListSink;
	CHMGraphViewEventSink m_GraphSink;

// MFC Implementation
protected:
	DECLARE_OLECREATE_EX(CHealthmonResultsPane)
};

#endif // !defined(AFX_HEALTHMONRESULTSPANE_H__307235A8_AA50_11D2_BD61_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\groupgeneralpage.cpp ===
// GroupGeneralPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "GroupGeneralPage.h"
#include "HMObject.h"
#include "SystemGroup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage property page

IMPLEMENT_DYNCREATE(CGroupGeneralPage, CHMPropertyPage)

CGroupGeneralPage::CGroupGeneralPage() : CHMPropertyPage(CGroupGeneralPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CGroupGeneralPage)
	m_sComment = _T("");
	m_sName = _T("");
	m_sCreationDate = _T("");
	m_sLastModifiedDate = _T("");
	//}}AFX_DATA_INIT

	CnxPropertyPageInit();	
}

CGroupGeneralPage::~CGroupGeneralPage()
{
}

void CGroupGeneralPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CGroupGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupGeneralPage)
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_sComment);
	DDX_Text(pDX, IDC_EDIT_NAME, m_sName);
	DDX_Text(pDX, IDC_STATIC_DATE_CREATED, m_sCreationDate);
	DDX_Text(pDX, IDC_STATIC_DATE_LAST_MODIFIED, m_sLastModifiedDate);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGroupGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CGroupGeneralPage)
	ON_EN_CHANGE(IDC_EDIT_COMMENT, OnChangeEditComment)
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CGroupGeneralPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CGroupGeneralPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IGroupGeneralPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {C3F44E7A-BA00-11D2-BD76-0000F87A3912}
static const IID IID_IGroupGeneralPage =
{ 0xc3f44e7a, 0xba00, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CGroupGeneralPage, CHMPropertyPage)
	INTERFACE_PART(CGroupGeneralPage, IID_IGroupGeneralPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage message handlers

BOOL CGroupGeneralPage::OnInitDialog() 
{
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

  if( GetObjectPtr()->IsKindOf(RUNTIME_CLASS(CSystemGroup)) )
  {
    m_sHelpTopic = _T("HMon21.chm::/dSGgen.htm");
  }
  else
  {
    m_sHelpTopic = _T("HMon21.chm::/dDGgen.htm");
  }

	m_sName = GetObjectPtr()->GetName();
	m_sComment = GetObjectPtr()->GetComment();
	GetObjectPtr()->GetCreateDateTime(m_sCreationDate);
	GetObjectPtr()->GetModifiedDateTime(m_sLastModifiedDate);

  if( GetObjectPtr()->IsKindOf(RUNTIME_CLASS(CSystemGroup)) )
  {
    CStatic* pStatic = (CStatic*)GetDlgItem(IDC_ICON_STATIC);    
    pStatic->SetIcon(AfxGetApp()->LoadIcon(IDI_ICON_SYSTEMS));
  }
	
	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGroupGeneralPage::OnChangeEditComment() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified(TRUE);
}

void CGroupGeneralPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CGroupGeneralPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	CnxPropertyPageDestroy();		
}

BOOL CGroupGeneralPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	GetObjectPtr()->Rename(m_sName);
	GetObjectPtr()->UpdateComment(m_sComment);

  SetModified(FALSE);
	
	return TRUE;
}

void CGroupGeneralPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonsnapinabout.cpp ===
// HealthmonSnapinAbout.cpp: implementation of the CHealthmonSnapinAbout class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "HealthmonSnapinAbout.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHealthmonSnapinAbout::CHealthmonSnapinAbout()
{

}

CHealthmonSnapinAbout::~CHealthmonSnapinAbout()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonscopepane.h ===
// HealthmonScopePane.h: interface for the CHealthmonScopePane class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HEALTHMONSCOPEPANE_H__307235A7_AA50_11D2_BD61_0000F87A3912__INCLUDED_)
#define AFX_HEALTHMONSCOPEPANE_H__307235A7_AA50_11D2_BD61_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ScopePane.h"

class CAllSystemsScopeItem;
class CSystemGroup;
class CSystem;

class CHealthmonScopePane : public CScopePane  
{

DECLARE_DYNCREATE(CHealthmonScopePane)

// Construction/Destruction
public:
	CHealthmonScopePane();
	virtual ~CHealthmonScopePane();

// Creation/Destruction Overrideable Members
protected:
	virtual bool OnCreate();
	virtual LPCOMPONENT OnCreateComponent();
	virtual bool OnDestroy();

// Root Scope Pane Item Members
public:
	virtual CScopePaneItem* CreateRootScopeItem();

// Root Group Members
public:
	CSystemGroup* GetRootGroup() { return m_pRootGroup; }
protected:
	CSystemGroup* m_pRootGroup;

// Healthmon Scope Helper Members
public:
	CAllSystemsScopeItem* GetAllSystemsScopeItem();
	CSystemGroup* GetAllSystemsGroup();
	CSystem* GetSystem(const CString& sName);

// Serialization
public:
	virtual bool OnLoad(CArchive& ar);
	virtual bool OnSave(CArchive& ar);

// Parse Command Line
public:
	bool ParseCommandLine(CStringArray& saSystems);

// MFC Implementation
protected:
	DECLARE_OLECREATE_EX(CHealthmonScopePane)

};

#endif // !defined(AFX_HEALTHMONSCOPEPANE_H__307235A7_AA50_11D2_BD61_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonscopepane.cpp ===
// HealthmonScopePane.cpp: implementation of the CHealthmonScopePane class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "AllSystemsScopeItem.h"
#include "HealthmonScopePane.h"
#include "HealthmonResultsPane.h"
#include "SystemsScopeItem.h"
#include "RootScopeItem.h"
#include "SystemGroup.h"
#include "System.h"
#include "EventManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CHealthmonScopePane,CScopePane)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHealthmonScopePane::CHealthmonScopePane()
{
	EnableAutomation();

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	// create the root scope item
	SetRootScopeItem(CreateRootScopeItem());

	m_pRootGroup = NULL;
}

CHealthmonScopePane::~CHealthmonScopePane()
{
	if( m_pRootItem )
	{
		if( GfxCheckObjPtr(m_pRootItem,CScopePaneItem) )
		{
			delete m_pRootItem;
		}
		m_pRootItem = NULL;
	}

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

}

/////////////////////////////////////////////////////////////////////////////
// Creation/Destruction Overrideable Members
/////////////////////////////////////////////////////////////////////////////

bool CHealthmonScopePane::OnCreate()
{
	TRACEX(_T("CHealthmonScopePane::OnCreate\n"));

	// create connection manager
	if( ! CnxCreate() ) 
	{
		TRACE(_T("FAILED : CnxCreate returns false.\n"));
		return false;
	}

	// call base class to create root scope item
	if( ! CScopePane::OnCreate() )
	{
		TRACE(_T("FAILED : CScopePane::OnCreate failed.\n"));
		return false;
	}

	// create the Root Group
	m_pRootGroup = new CSystemGroup;

	m_pRootGroup->SetScopePane(this);

	CScopePaneItem* pRootItem = GetRootScopeItem();

	m_pRootGroup->SetName(pRootItem->GetDisplayName());
	m_pRootGroup->AddScopeItem(pRootItem);
	((CHMScopeItem*)pRootItem)->SetObjectPtr(m_pRootGroup);

	EvtGetEventManager()->AddContainer(_T(""),_T(""),m_pRootGroup->GetGuid(),m_pRootGroup);

	// create the All Systems Group and add it to the root group
	CAllSystemsGroup* pAllSystemsGroup = new CAllSystemsGroup;
	CString sName;
	sName.LoadString(IDS_STRING_ALL_SYSTEMS_NODE);
	pAllSystemsGroup->SetName(sName);

	m_pRootGroup->AddChild(pAllSystemsGroup);

	return true;
}

LPCOMPONENT CHealthmonScopePane::OnCreateComponent()
{
	TRACEX(_T("CHealthmonScopePane::OnCreateComponent\n"));

	CHealthmonResultsPane* pNewPane = new CHealthmonResultsPane;
	
	if( ! GfxCheckObjPtr(pNewPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		return NULL;
	}

	pNewPane->SetOwnerScopePane(this);

	int iIndex = AddResultsPane(pNewPane);
	
	ASSERT(iIndex != -1);

	LPCOMPONENT pComponent = (LPCOMPONENT)pNewPane->GetInterface(&IID_IComponent);

	if( ! CHECKPTR(pComponent,sizeof(IComponent)) )
	{
		return NULL;
	}

	return pComponent;
}

bool CHealthmonScopePane::OnDestroy()
{
	TRACEX(_T("CHealthmonScopePane::OnDestroy\n"));

	// unhook the window first
	UnhookWindow();

	if( m_pMsgHook )
	{
		delete m_pMsgHook;
		m_pMsgHook = NULL;
	}		

	// destroy the root item and all its child scope items
	if( m_pRootItem )
	{
		if( GfxCheckObjPtr(m_pRootItem,CScopePaneItem) )
		{
			delete m_pRootItem;
		}
		m_pRootItem = NULL;
	}

	m_pSelectedScopeItem = NULL;

	// destroy the HMObjects we allocated during the console session
	if( m_pRootGroup )
	{
		m_pRootGroup->Destroy();
		EvtGetEventManager()->RemoveContainer(_T(""),m_pRootGroup->GetGuid());
		delete m_pRootGroup;
		m_pRootGroup = NULL;
	}

	// Release all the interfaces queried for
	if( m_pIConsole )
	{
		m_pIConsole->Release();
		m_pIConsole = NULL;
	}

	if( m_pIConsoleNamespace )
	{
		m_pIConsoleNamespace->Release();
		m_pIConsoleNamespace = NULL;
	}

	if( m_pIImageList )
	{
		m_pIImageList->Release();
		m_pIImageList = NULL;
	}

	// empty Result Panes array

	for( int i = GetResultsPaneCount()-1; i >= 0; i-- )
	{
		RemoveResultsPane(i);
	}

	CnxDestroy();

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Root Scope Pane Item Members
/////////////////////////////////////////////////////////////////////////////

CScopePaneItem* CHealthmonScopePane::CreateRootScopeItem()
{
	TRACEX(_T("CHealthmonScopePane::CreateRootScopeItem\n"));

	return new CRootScopeItem;
}

/////////////////////////////////////////////////////////////////////////////
// Healthmon Scope Helper Members
/////////////////////////////////////////////////////////////////////////////

CAllSystemsScopeItem* CHealthmonScopePane::GetAllSystemsScopeItem()
{
	TRACEX(_T("CHealthmonScopePane::GetAllSystemsScopeItem\n"));

	CScopePaneItem* pRootItem = GetRootScopeItem();

	if( ! pRootItem )
	{
		TRACE(_T("FAILED : CScopePane::GetRootScopeItem returns NULL.\n"));
		return NULL;
	}


	for( int i = 0; i < pRootItem->GetChildCount(); i++ )
	{
		CScopePaneItem* pTempItem = pRootItem->GetChild(i);
		if( pTempItem && pTempItem->IsKindOf(RUNTIME_CLASS(CAllSystemsScopeItem)) )
		{
			return (CAllSystemsScopeItem*)pTempItem;
		}
	}

	TRACE(_T("FAILED : A node of type CAllSystemsScopeItem was not found.\n"));
	ASSERT(FALSE);
	return NULL;
}

CSystemGroup* CHealthmonScopePane::GetAllSystemsGroup()
{
	TRACEX(_T("CHealthmonScopePane::GetAllSystemsGroup\n"));	

	CSystemGroup* pRG = GetRootGroup();

	CSystemGroup* pASG = (CSystemGroup*)pRG->GetChild(0);

	if( ! GfxCheckObjPtr(pASG,CSystemGroup) )
	{
		return NULL;
	}

	return pASG;
}

CSystem* CHealthmonScopePane::GetSystem(const CString& sName)
{
	TRACEX(_T("CHealthmonScopePane::GetSystem\n"));

	CSystemGroup* pGroup = GetAllSystemsGroup();

	CSystem* pSystem = (CSystem*)pGroup->GetChild(sName);
	if( ! GfxCheckObjPtr(pSystem,CSystem) )
	{
		return NULL;
	}

	return pSystem;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization
/////////////////////////////////////////////////////////////////////////////

bool CHealthmonScopePane::OnLoad(CArchive& ar)
{
	TRACEX(_T("CHealthmonScopePane::OnLoad\n"));
	if( ! CScopePane::OnLoad(ar) )
	{
		return false;
	}

	CSystemGroup* pASG = GetAllSystemsGroup();
	ASSERT(pASG);
	pASG->Serialize(ar);

	CStringArray saSystems;
	if( ParseCommandLine(saSystems) )
	{
		for( int z = 0; z < saSystems.GetSize(); z++ )
		{
			IWbemServices* pServices = NULL;
			BOOL bAvail = FALSE;

			if( CnxGetConnection(saSystems[z],pServices,bAvail) == E_FAIL )
			{
				MessageBeep(MB_ICONEXCLAMATION);
			}

			if( pServices )
			{
				pServices->Release();
			}

			CSystem* pNewSystem = new CSystem;
			pNewSystem->SetName(saSystems[z]);
			pNewSystem->SetSystemName(saSystems[z]);
			pNewSystem->SetScopePane(this);

			pASG->AddChild(pNewSystem);
			pNewSystem->Connect();

			CActionPolicy* pPolicy = new CActionPolicy;
			pPolicy->SetSystemName(pNewSystem->GetName());
			pNewSystem->AddChild(pPolicy);

/*		causes AV in MMCNDMGR
			if( z == 0 )
			{
				for( int x = 0; x < pNewSystem->GetScopeItemCount(); x++ )
				{
					CScopePaneItem* pItem = pNewSystem->GetScopeItem(x);
					if( pItem )
					{
						pItem->SelectItem();
					}
				}
			}
*/
		}
	}

	CSystemGroup* pMSG = GetRootGroup();

	int iSystemGroupCount;

	ar >> iSystemGroupCount;

	for( int i = 0; i < iSystemGroupCount; i++ )
	{
		CSystemGroup* pNewGroup = new CSystemGroup;		
		pNewGroup->SetScopePane(this);				
		pNewGroup->SetName(pMSG->GetUniqueChildName());
		pMSG->AddChild(pNewGroup);
		pNewGroup->Serialize(ar);		
	}

	return true;
}

bool CHealthmonScopePane::OnSave(CArchive& ar)
{
	TRACEX(_T("CHealthmonScopePane::OnSave\n"));
	if( ! CScopePane::OnSave(ar) )
	{
		return false;
	}

	CSystemGroup* pASG = GetAllSystemsGroup();
	ASSERT(pASG);
	pASG->Serialize(ar);

	CSystemGroup* pMSG = GetRootGroup();

	int iSystemGroupCount = pMSG->GetChildCount(RUNTIME_CLASS(CSystemGroup))-1;

	ar << iSystemGroupCount;

	for( int i = 1; i <= iSystemGroupCount; i++ )
	{
		pMSG->GetChild(i)->Serialize(ar);
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Parse Command Line
/////////////////////////////////////////////////////////////////////////////

bool CHealthmonScopePane::ParseCommandLine(CStringArray& saSystems)
{
	TRACEX(_T("CHealthmonScopePane::ParseCommandLine\n"));

	saSystems.RemoveAll();

	CString sCmdLine = GetCommandLine();

	sCmdLine.MakeUpper();

	int iIndex = sCmdLine.Find(_T("/HEALTHMON_SYSTEMS:"));

	if( iIndex == -1 )
	{
		return false;
	}

	sCmdLine = sCmdLine.Right(sCmdLine.GetLength()-iIndex-19);

	iIndex = sCmdLine.Find(_T(" "));

	if( iIndex != -1 )
	{
		sCmdLine = sCmdLine.Left(iIndex);
	}

	LPTSTR lpszCmdLine = new TCHAR[sCmdLine.GetLength()+1];
	_tcscpy(lpszCmdLine,sCmdLine);

	LPTSTR lpszToken = _tcstok(lpszCmdLine,_T(","));

	while(lpszToken)
	{
		saSystems.Add(lpszToken);
		lpszToken = _tcstok(NULL,_T(","));
	}

	delete[] lpszCmdLine;

	return true;
}

// {FBBB8DAE-AB34-11d2-BD62-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CHealthmonScopePane, "SnapIn.ScopePane", 0xfbbb8dae, 0xab34, 0x11d2, 0xbd, 0x62, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12);

BOOL CHealthmonScopePane::CHealthmonScopePaneFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonresultspane.cpp ===
// HealthmonResultsPane.cpp: implementation of the CHealthmonResultsPane class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "HealthmonResultsPane.h"
#include "splitter1.h"
#include "hmtabview.h"
#include "SystemGroup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const IID BASED_CODE IID_DHMListView =
		{ 0x5116a804, 0xdafc, 0x11d2, { 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };

const IID BASED_CODE IID_DHMTabView =
		{ 0x4fffc38a, 0x2f1e, 0x11d3, { 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };

const IID BASED_CODE IID_DHMGraphView =
		{ 0x9acb0cf6, 0x2ff0, 0x11d3, { 0xbe, 0x15, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CHealthmonResultsPane,CResultsPane)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHealthmonResultsPane::CHealthmonResultsPane()
{
	EnableAutomation();

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_hbmpNewSystem = NULL;
  m_hbmpClearEvents = NULL;
  m_hbmpResetStatus = NULL;
  m_hbmpDisable = NULL;

}

CHealthmonResultsPane::~CHealthmonResultsPane()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

  // free the bitmaps
  if( m_hbmpNewSystem )
  {
    DeleteObject(m_hbmpNewSystem);
    m_hbmpNewSystem = NULL;
  }

  if( m_hbmpClearEvents )
  {
    DeleteObject(m_hbmpClearEvents);
    m_hbmpClearEvents = NULL;
  }

  if( m_hbmpResetStatus )
  {
    DeleteObject(m_hbmpResetStatus);
    m_hbmpResetStatus = NULL;
  }

  if( m_hbmpDisable )
  {
    DeleteObject(m_hbmpDisable);
    m_hbmpDisable = NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////
// Creation/Destruction Overrideable Members
/////////////////////////////////////////////////////////////////////////////

bool CHealthmonResultsPane::OnCreateOcx(LPUNKNOWN pIUnknown)
{
	TRACEX(_T("CHealthmonResultsPane::OnCreateOcx\n"));
	TRACEARGn(pIUnknown);

	if( ! CResultsPane::OnCreateOcx(pIUnknown) )
	{
		TRACE(_T("FAILED : CResultsPane::OnCreateOcx failed.\n"));
		return false;
	}

	if( ! LoadListControls(pIUnknown) )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::LoadListControls failed.\n"));
		return false;
	}

	return true;
}

bool CHealthmonResultsPane::OnDestroy()
{
	TRACEX(_T("CHealthmonResultsPane::OnDestroy\n"));

	m_DispUpperList.ReleaseDispatch();
	m_DispLowerList.ReleaseDispatch();
	m_DispStatsList.ReleaseDispatch();
	m_DispGraph.ReleaseDispatch();

  return CResultsPane::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
// Results Item Icon Management
/////////////////////////////////////////////////////////////////////////////

int CHealthmonResultsPane::AddIcon(UINT nIconResID, SplitResultsPane pane)
{
	TRACEX(_T("CHealthmonResultsPane::AddIcon\n"));
	TRACEARGn(nIconResID);
	TRACEARGn(pane);

	_DHMListView* pList = NULL;
	if( pane == Upper )
	{
		pList = GetUpperListCtrl();
	}
	else if( pane == Lower )
	{
		pList = GetLowerListCtrl();
	}
	else
	{
		TRACE(_T("FAILED : The pane to add an icon to has not been specified.\n"));
		ASSERT(FALSE);
		return -1;
	}

	if( !pList )
	{
		TRACE(_T("FAILED : list control has not been initialized.\n"));
		return -1;
	}

	HIMAGELIST hImageList = (HIMAGELIST)pList->GetImageList(LVSIL_SMALL);

	CImageList smallimages;

	if( hImageList == NULL || hImageList == (HIMAGELIST)-1 )
	{
		if( ! smallimages.Create(16,16,ILC_COLOR4,1,4) )
		{
			TRACE(_T("FAILED : CImageList::Create returned false.\n"));
			return NULL;
		}
#ifndef IA64
		pList->SetImageList((long)smallimages.GetSafeHandle(),LVSIL_SMALL);
#endif // IA64
	}
	else
	{
		smallimages.Attach(hImageList);
	}

	// load icon
	HICON hIcon = AfxGetApp()->LoadIcon(nIconResID);
	if( hIcon == NULL )
	{
		TRACE(_T("FAILED : Icon with resid=%d not found"),nIconResID);
		smallimages.Detach();
		return -1;
	}

	// insert icon into image list
	int nIconIndex = smallimages.Add(hIcon);
	ASSERT(nIconIndex != -1);

	// add resid and index to map
	if( pane == Upper )
	{
		m_UpperIconMap.SetAt(nIconResID,nIconIndex);
	}
	else if( pane == Lower )
	{
		m_LowerIconMap.SetAt(nIconResID,nIconIndex);
	}
	else
	{
		ASSERT(FALSE);
	}

	smallimages.Detach();

	// return index of newly inserted image
	return nIconIndex;
}

int CHealthmonResultsPane::GetIconIndex(UINT nIconResID, SplitResultsPane pane)
{
	TRACEX(_T("CHealthmonResultsPane::GetIconIndex\n"));
	TRACEARGn(nIconResID);
	TRACEARGn(pane);

	// check map for an existing id
	int nIconIndex = -1;

	if( pane == Upper )
	{
		if( m_UpperIconMap.Lookup(nIconResID,nIconIndex) )
		{
			// if exists, return index
			return nIconIndex;
		}
	}
	else if( pane == Lower )
	{	
		if( m_LowerIconMap.Lookup(nIconResID,nIconIndex) )
		{
			// if exists, return index
			return nIconIndex;
		}
	}
	else
	{
		ASSERT(FALSE);
	}

	// does not exist so add icon
	nIconIndex = AddIcon(nIconResID,pane);

	// if it still does not exist, icon is not in resources
	if( nIconIndex != -1 )
		return nIconIndex;

	TRACE(_T("FAILED : Icon with Resource id=%d could not be loaded.\n"),nIconResID);

	return -1;
}

int CHealthmonResultsPane::GetIconCount(SplitResultsPane pane)
{
	TRACEX(_T("CHealthmonResultsPane::GetIconCount\n"));
	TRACEARGn(pane);

	int iCount = 0;

	if( pane == Upper )
	{
		iCount = (int)m_UpperIconMap.GetCount();
	}
	else if( pane == Lower )
	{
		iCount = (int)m_LowerIconMap.GetCount();
	}
	else
	{
		ASSERT(FALSE);
	}

	return iCount;
}

void CHealthmonResultsPane::RemoveAllIcons(SplitResultsPane pane)
{
	TRACEX(_T("CHealthmonResultsPane::RemoveAllIcons\n"));
	TRACEARGn(pane);

	_DHMListView* pList = NULL;
	if( pane == Upper )
	{
		pList = GetUpperListCtrl();
	}
	else if( pane == Lower )
	{
		pList = GetLowerListCtrl();
	}
	else
	{
		TRACE(_T("FAILED : The pane to add an icon to has not been specified.\n"));
		ASSERT(FALSE);
		return;
	}

	if( !pList )
	{
		TRACE(_T("FAILED : list control has not been initialized.\n"));
		return;
	}

	HIMAGELIST hImageList = (HIMAGELIST)pList->GetImageList(LVSIL_SMALL);

	CImageList smallimages;

	if( hImageList == NULL )
	{
		TRACE(_T("FAILED : CHMListCtrl::GetImageList returns NULL.\n"));
		return;
	}

	smallimages.Attach(hImageList);

	int iImageCount = smallimages.GetImageCount();
	for( int i = 0; i < iImageCount; i++ )
	{
		smallimages.Remove(0);
	}

	if( pane == Upper )
	{
		m_UpperIconMap.RemoveAll();
	}
	else if( pane == Lower )
	{
		m_LowerIconMap.RemoveAll();
	}

	smallimages.Detach();
}

/////////////////////////////////////////////////////////////////////////////
// Control bar Members
/////////////////////////////////////////////////////////////////////////////

HRESULT CHealthmonResultsPane::OnSetControlbar(LPCONTROLBAR pIControlbar)
{
	TRACEX(_T("CHealthmonResultsPane::OnSetControlbar\n"));
	TRACEARGn(pIControlbar);

	HRESULT hr = S_OK;

	// default behavior simply creates an empty toolbar
	
	// override to add buttons or to disallow creation of a new toolbar

	if( pIControlbar )
	{
		if( ! GfxCheckPtr(pIControlbar,IControlbar) )
		{
			return E_FAIL;
		}
		
		// hold on to that controlbar pointer
		pIControlbar->AddRef();
		m_pIControlbar = pIControlbar;

		// create a new toolbar
		LPEXTENDCONTROLBAR lpExtendControlBar = (LPEXTENDCONTROLBAR)GetInterface(&IID_IExtendControlbar);
    hr = m_pIControlbar->Create(TOOLBAR,lpExtendControlBar,(LPUNKNOWN*)(&m_pIToolbar));

		CString sButtonText;
		CString sTooltipText;

    // New System Button
		sButtonText.LoadString(IDS_STRING_NEW_COMPUTER);
		sTooltipText.LoadString(IDS_STRING_NEW_COMPUTER);

		MMCBUTTON mb;
		mb.nBitmap = 0;
		mb.idCommand = IDM_NEW_SYSTEM;
		mb.fsState = TBSTATE_ENABLED;
		mb.fsType = TBSTYLE_BUTTON;
		mb.lpButtonText = (LPTSTR)(LPCTSTR)sButtonText;
		mb.lpTooltipText = (LPTSTR)(LPCTSTR)sTooltipText;

    m_pIToolbar->AddRef();
    
		// Add the toolbar bitmap
		CBitmap NewBitmap;
		NewBitmap.LoadBitmap(IDB_BITMAP_NEW_SYSTEM);

    m_hbmpNewSystem = (HBITMAP)NewBitmap.Detach();
    hr = m_pIToolbar->AddBitmap( 1, m_hbmpNewSystem, 16, 16, RGB(255,0,255) );
    ASSERT( SUCCEEDED(hr) );

    // Add a button
    hr = m_pIToolbar->AddButtons(1, &mb);
    ASSERT( SUCCEEDED(hr) );

    // Clear Alerts Button
		sButtonText.LoadString(IDS_STRING_CLEAR_EVENTS);
		sTooltipText.LoadString(IDS_STRING_CLEAR_EVENTS);

		mb.nBitmap = 1;
		mb.idCommand = IDM_CLEAR_EVENTS;
		mb.fsState = TBSTATE_ENABLED;
		mb.fsType = TBSTYLE_BUTTON;
		mb.lpButtonText = (LPTSTR)(LPCTSTR)sButtonText;
		mb.lpTooltipText = (LPTSTR)(LPCTSTR)sTooltipText;

    m_pIToolbar->AddRef();
    
		// Add the toolbar bitmap
		NewBitmap.LoadBitmap(IDB_BITMAP_CLEAR_EVENTS);

    m_hbmpClearEvents = (HBITMAP)NewBitmap.Detach();
    hr = m_pIToolbar->AddBitmap( 1, m_hbmpClearEvents, 16, 16, RGB(255,0,255) );
    ASSERT( SUCCEEDED(hr) );

    // Add a button
    hr = m_pIToolbar->AddButtons(1, &mb);
    ASSERT( SUCCEEDED(hr) );


    // Reset Status Button
		sButtonText.LoadString(IDS_STRING_RESET_STATUS);
		sTooltipText.LoadString(IDS_STRING_RESET_STATUS);

		mb.nBitmap = 2;
		mb.idCommand = IDM_RESET_STATUS;
		mb.fsState = TBSTATE_ENABLED;
		mb.fsType = TBSTYLE_BUTTON;
		mb.lpButtonText = (LPTSTR)(LPCTSTR)sButtonText;
		mb.lpTooltipText = (LPTSTR)(LPCTSTR)sTooltipText;

    m_pIToolbar->AddRef();
    
		// Add the toolbar bitmap
		NewBitmap.LoadBitmap(IDB_BITMAP_RESET_STATUS);

    m_hbmpResetStatus = (HBITMAP)NewBitmap.Detach();
    hr = m_pIToolbar->AddBitmap( 1, m_hbmpResetStatus, 16, 16, RGB(255,0,255) );
    ASSERT( SUCCEEDED(hr) );

    // Add a button
    hr = m_pIToolbar->AddButtons(1, &mb);
    ASSERT( SUCCEEDED(hr) );


    // Disable Button
		sButtonText.LoadString(IDS_STRING_DISABLE);
		sTooltipText.LoadString(IDS_STRING_DISABLE);

		mb.nBitmap = 3;
		mb.idCommand = IDM_DISABLE_MONITORING;
		mb.fsState = TBSTATE_ENABLED;
		mb.fsType = TBSTYLE_BUTTON;
		mb.lpButtonText = (LPTSTR)(LPCTSTR)sButtonText;
		mb.lpTooltipText = (LPTSTR)(LPCTSTR)sTooltipText;

    m_pIToolbar->AddRef();
    
		// Add the toolbar bitmap
		NewBitmap.LoadBitmap(IDB_BITMAP_DISABLE);

    m_hbmpDisable = (HBITMAP)NewBitmap.Detach();
    hr = m_pIToolbar->AddBitmap( 1, m_hbmpDisable, 16, 16, RGB(255,0,255) );
    ASSERT( SUCCEEDED(hr) );

    // Add a button
    hr = m_pIToolbar->AddButtons(1, &mb);
    ASSERT( SUCCEEDED(hr) );
	}
	else
	{
		// free the toolbar
		if( m_pIToolbar )
		{
			m_pIToolbar->Release();
			m_pIToolbar = NULL;
		}

		// free the controlbar
		if( m_pIControlbar )
		{
			m_pIControlbar->Release();
			m_pIControlbar = NULL;
		}

    // free the bitmaps
    if( m_hbmpNewSystem )
    {
      DeleteObject(m_hbmpNewSystem);
      m_hbmpNewSystem = NULL;
    }

    if( m_hbmpClearEvents )
    {
      DeleteObject(m_hbmpClearEvents);
      m_hbmpClearEvents = NULL;
    }

    if( m_hbmpResetStatus )
    {
      DeleteObject(m_hbmpResetStatus);
      m_hbmpResetStatus = NULL;
    }

    if( m_hbmpDisable )
    {
      DeleteObject(m_hbmpDisable);
      m_hbmpDisable = NULL;
    }
	}

	return hr;
}

HRESULT CHealthmonResultsPane::OnControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	TRACEX(_T("CHealthmonResultsPane::OnControlbarNotify\n"));
	TRACEARGn(event);
	TRACEARGn(arg);
	TRACEARGn(param);

	HRESULT hr = S_OK;

  switch( event )
  {
    case MMCN_BTN_CLICK:               // For a Controlbar click, the
      switch( param )                  // param is the MenuItemID
      {
        case IDM_NEW_SYSTEM:
				{
					CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetOwnerScopePane();
					CSystemGroup* pASG = pPane->GetAllSystemsGroup();
					hr = pASG->GetScopeItem(0)->OnCommand(IDM_NEW_SYSTEM);
				}
        break;

        case IDM_CLEAR_EVENTS:
        case IDM_RESET_STATUS:
        case IDM_DISABLE_MONITORING:
        {
          CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetOwnerScopePane();
          CScopePaneItem* pSPI = pPane->GetSelectedScopeItem();
          if( pSPI )
          {
            hr = (HRESULT)pSPI->OnCommand((long)param);
          }
        }
        break;
      }
      break;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Splitter Control Members
//////////////////////////////////////////////////////////////////////

_DHMListView* CHealthmonResultsPane::GetUpperListCtrl()
{
	TRACEX(_T("CHealthmonResultsPane::GetUpperListCtrl\n"));

	if( ! GfxCheckPtr(&m_DispUpperList,_DHMListView) )
	{
		TRACE(_T("FAILED : The upper list control object is not valid.\n"));
		return NULL;
	}

	if( ! (LPDISPATCH)m_DispUpperList )
	{
		return NULL;
	}

	return &m_DispUpperList;
}

CHMListViewEventSink* CHealthmonResultsPane::GetUpperListSink()
{
	TRACEX(_T("CHealthmonResultsPane::GetUpperListSink\n"));

	if( ! GfxCheckPtr(&m_UpperListSink,CHMListViewEventSink) )
	{
		TRACE(_T("FAILED : The upper list sink object is not valid.\n"));
		return NULL;
	}

	return &m_UpperListSink;
}

_DHMListView* CHealthmonResultsPane::GetLowerListCtrl()
{
	TRACEX(_T("CHealthmonResultsPane::GetLowerListCtrl\n"));

	if( ! GfxCheckPtr(&m_DispLowerList,_DHMListView) )
	{
		TRACE(_T("FAILED : The upper list control object is not valid.\n"));
		return NULL;
	}

	if( ! (LPDISPATCH)m_DispLowerList )
	{
		return NULL;
	}

	return &m_DispLowerList;
}

CHMListViewEventSink* CHealthmonResultsPane::GetLowerListSink()
{
	TRACEX(_T("CHealthmonResultsPane::GetLowerListSink\n"));

	if( ! GfxCheckPtr(&m_LowerListSink,CHMListViewEventSink) )
	{
		TRACE(_T("FAILED : The lower list sink object is not valid.\n"));
		return NULL;
	}

	return &m_LowerListSink;
}

_DHMListView* CHealthmonResultsPane::GetStatsListCtrl()
{
	TRACEX(_T("CHealthmonResultsPane::GetStatsListCtrl\n"));

	if( ! GfxCheckPtr(&m_DispStatsList,_DHMListView) )
	{
		TRACE(_T("FAILED : The upper list control object is not valid.\n"));
		return NULL;
	}

	if( ! (LPDISPATCH)m_DispStatsList )
	{
		return NULL;
	}

	return &m_DispStatsList;
}

CHMListViewEventSink* CHealthmonResultsPane::GetStatsListSink()
{
	TRACEX(_T("CHealthmonResultsPane::GetStatsListSink\n"));

	if( ! GfxCheckPtr(&m_StatsListSink,CHMListViewEventSink) )
	{
		TRACE(_T("FAILED : The Stats list sink object is not valid.\n"));
		return NULL;
	}

	return &m_StatsListSink;
}

_DHMGraphView* CHealthmonResultsPane::GetGraphViewCtrl()
{
	TRACEX(_T("CHealthmonResultsPane::GetGraphViewCtrl\n"));

	if( ! GfxCheckPtr(&m_DispGraph,_DHMGraphView) )
	{
		TRACE(_T("FAILED : The graph control object is not valid.\n"));
		return NULL;
	}

	if( ! m_DispGraph.m_lpDispatch )
	{
		return NULL;
	}

	return &m_DispGraph;
}

CHMGraphViewEventSink* CHealthmonResultsPane::GetGraphViewSink()
{
	TRACEX(_T("CHealthmonResultsPane::GetGraphViewSink\n"));

	if( ! GfxCheckObjPtr(&m_GraphSink,CHMGraphViewEventSink) )
	{
		TRACE(_T("FAILED : The graph control sink is not valid.\n"));
		return NULL;
	}

	return &m_GraphSink;
}


inline bool CHealthmonResultsPane::LoadListControls(LPUNKNOWN pIUnknown)
{
	TRACEX(_T("CHealthmonResultsPane::LoadListControls\n"));
	TRACEARGn(pIUnknown);

	ASSERT(pIUnknown);

	if( pIUnknown == NULL )
	{
		TRACE(_T("FAILED : pIUnknown is NULL.\n"));
		return false;
	}

	// if the controls are already set up then do not create them again
	if( m_DispUpperList && m_DispLowerList && m_DispStatsList )
	{
		return true;
	}

	// query for the dispatch interface on the splitter control
	LPDISPATCH pIDispatch = NULL;
	HRESULT hr = pIUnknown->QueryInterface(IID_IDispatch,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));
		pIUnknown->Release();
		return false;
	}

	// attach a COleDispatchDriver class to it
	_DSplitter DSplitter(pIDispatch);
	

	// create the lower list control
	CString sControlID = _T("{5116A806-DAFC-11D2-BDA4-0000F87A3912}");	
	DSplitter.CreateControl(1,0,(LPCTSTR)sControlID);	

	LPUNKNOWN lpControlUnknown = DSplitter.GetControlIUnknown(1,0);
	if( lpControlUnknown == NULL )
	{
		return false;
	}

	// attach event sink to the list
	hr = m_LowerListSink.HookUpEventSink(lpControlUnknown);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : Unable to hook up event sink to lower list control.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	// get main dispatch interface to drive the list
	hr = lpControlUnknown->QueryInterface(IID_DHMListView,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	lpControlUnknown->Release();

	// attach the OLE dispatch driver class to IDispatch pointer
	m_DispLowerList.AttachDispatch(pIDispatch);

	m_LowerListSink.m_pDHMListView = &m_DispLowerList;
  m_LowerListSink.m_pHMRP = this;
  m_LowerListSink.m_Pane = Lower;

	// Make certain that label editing is turned off for the lower list
	m_DispLowerList.ModifyListStyle(LVS_EDITLABELS,0,0);

	// create the tab view control and add the tabs/controls to it
	sControlID = _T("HMTabView.HMTabviewctrl.1");
	DSplitter.CreateControl(0,0,(LPCTSTR)sControlID);

	lpControlUnknown = DSplitter.GetControlIUnknown(0,0);
	if( lpControlUnknown == NULL )
	{		
		return false;
	}

	hr = lpControlUnknown->QueryInterface(IID_DHMTabView,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	lpControlUnknown->Release();

	_DHMTabView DHMTabview(pIDispatch);

	CString sTabTitle;

	// Details Listview
	sTabTitle.LoadString(IDS_STRING_SUMMARY);	
	DHMTabview.InsertItem(TCIF_TEXT,0,sTabTitle,-1L,0L);

	sControlID = _T("{5116A806-DAFC-11D2-BDA4-0000F87A3912}");	
	DHMTabview.CreateControl(0,sControlID);

	// Statistics ListView
	sTabTitle.LoadString(IDS_STRING_STATISTICS);	
	DHMTabview.InsertItem(TCIF_TEXT,1,sTabTitle,-1L,0L);

	sControlID = _T("{5116A806-DAFC-11D2-BDA4-0000F87A3912}");	
	DHMTabview.CreateControl(1,sControlID);

	// GraphView
	sTabTitle.LoadString(IDS_STRING_GRAPH);	
	DHMTabview.InsertItem(TCIF_TEXT,2,sTabTitle,-1L,0L);

	sControlID = _T("HMGraphView.HMGraphViewCtrl.1");	
	DHMTabview.CreateControl(2,sControlID);

	// attach dispatch drivers for the newly created tabview controls

	lpControlUnknown = DHMTabview.GetControl(0);
	if( lpControlUnknown == NULL )
	{		
		return false;
	}

	// attach event sink to the upper list
	hr = m_UpperListSink.HookUpEventSink(lpControlUnknown);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : Unable to hook up event sink to upper list control.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	hr = lpControlUnknown->QueryInterface(IID_DHMListView,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	lpControlUnknown->Release();

	// attach the OLE dispatch driver class to IDispatch pointer
	m_DispUpperList.AttachDispatch(pIDispatch);

	m_UpperListSink.m_pDHMListView = &m_DispUpperList;
  m_UpperListSink.m_pHMRP = this;
  m_UpperListSink.m_Pane = Upper;

	// get the stats listview control
	lpControlUnknown = DHMTabview.GetControl(1);
	if( lpControlUnknown == NULL )
	{		
		return false;
	}

	// attach event sink to the stats list
	hr = m_StatsListSink.HookUpEventSink(lpControlUnknown);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : Unable to hook up event sink to stats list control.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	hr = lpControlUnknown->QueryInterface(IID_DHMListView,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));		
		lpControlUnknown->Release();
		return false;
	}

	lpControlUnknown->Release();

	// attach the OLE dispatch driver class to IDispatch pointer
	m_DispStatsList.AttachDispatch(pIDispatch);

	m_StatsListSink.m_pDHMListView = &m_DispStatsList;
  m_StatsListSink.m_pHMRP = this;
  m_StatsListSink.m_Pane = Stats;

	// Make certain that label editing is turned off for the stats list
	m_DispStatsList.ModifyListStyle(LVS_EDITLABELS,0,0);

	// get the GraphView Control
	lpControlUnknown = DHMTabview.GetControl(2);
	if( lpControlUnknown == NULL )
	{
		DHMTabview.DeleteItem(2);
		return false;
	}

	// attach event sink to the graph
	hr = m_GraphSink.HookUpEventSink(lpControlUnknown);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : Unable to hook up event sink to graph control.\n"));		
		DHMTabview.DeleteItem(2);
		lpControlUnknown->Release();
		return false;
	}

	hr = lpControlUnknown->QueryInterface(IID_DHMGraphView,(LPVOID*)&pIDispatch);
	if( ! CHECKHRESULT(hr) || ! pIDispatch )
	{
		TRACE(_T("FAILED : IUnknown::QI(IID_IDispatch) failed.\n"));		
		DHMTabview.DeleteItem(2);
		lpControlUnknown->Release();
		return false;
	}

	lpControlUnknown->Release();

	// attach the OLE dispatch driver class to IDispatch pointer for the GraphView
	m_DispGraph.AttachDispatch(pIDispatch);

	m_GraphSink.SetGraphViewCtrl(&m_DispGraph);

	return true;
}

// {FBBB8DB3-AB34-11d2-BD62-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CHealthmonResultsPane, "SnapIn.ResultsPane", 
0xfbbb8db3, 0xab34, 0x11d2, 0xbd, 0x62, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12);

BOOL CHealthmonResultsPane::CHealthmonResultsPaneFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\healthmonsnapinabout.h ===
// HealthmonSnapinAbout.h: interface for the CHealthmonSnapinAbout class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HEALTHMONSNAPINABOUT_H__FD7193F9_AB16_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_HEALTHMONSNAPINABOUT_H__FD7193F9_AB16_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SnapinAbout.h"

class CHealthmonSnapinAbout : public CSnapinAbout  
{
public:
	CHealthmonSnapinAbout();
	virtual ~CHealthmonSnapinAbout();

};

#endif // !defined(AFX_HEALTHMONSNAPINABOUT_H__FD7193F9_AB16_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmcontext.h ===
// HMContext.h: interface for the CHMContext class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMCONTEXT_H__22706B1F_412F_11D3_BE26_0000F87A3912__INCLUDED_)
#define AFX_HMCONTEXT_H__22706B1F_412F_11D3_BE26_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMContext : public CWbemClassObject  
{
DECLARE_DYNCREATE(CHMContext)

// Construction/Destruction
public:
	CHMContext();
	virtual ~CHMContext();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();
	virtual HRESULT SaveAllProperties();

// Microsoft_HMContext properties
public:
	CString m_sName;
	int			m_iType;
	CString m_sValue;
	
};

typedef CTypedPtrArray<CObArray,CHMContext*> HMContextArray;

#endif // !defined(AFX_HMCONTEXT_H__22706B1F_412F_11D3_BE26_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementconfiguration.h ===
// HMDataElementConfiguration.h: interface for the HMDataElementConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMDATAELEMENTCONFIGURATION_H__B0D24257_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
#define AFX_HMDATAELEMENTCONFIGURATION_H__B0D24257_F80C_11D2_BDC8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"
#include "HMContext.h"

class CHMDataElementConfiguration : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMDataElementConfiguration)

// Construction/Destruction
public:
	CHMDataElementConfiguration();
	virtual ~CHMDataElementConfiguration();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  HRESULT GetAllProperties();
  HRESULT SaveEnabledProperty();
	HRESULT SaveAllProperties();

// HMDataElementConfiguration Properties
public:
	CString m_sGUID;		// Unique identifier

	CString m_sName;		// Display name

	CString m_sDescription;	// Description

	CString m_sTargetNamespace;	// What Namespace we are to look in. Can contain path to a remote machine.

	int m_iCollectionIntervalMultiple; // How often to sample. 

	int m_iStatisticsWindowSize; // Number of collection intervals to calculate the statistics across.
															 // And also determining number of event rule cases.

	int m_iActiveDays;	// Days of the week it is active. One bit per day.

	CTime m_BeginTime;
			
	CTime m_EndTime;
	
	CString m_sTypeGUID;	// For use by the console to aid in the display

	bool m_bRequireManualReset; // 

	bool m_bEnable;		// If this is to be active

	CStringArray m_saStatisticsPropertyNames; // What properties to collect statistics on

};

typedef CTypedPtrArray<CObArray,CHMDataElementConfiguration*> DataElementArray;

//////////////////////////////////////////////////////////////////////
// CHMPolledGetObjectDataElementConfiguration 

class CHMPolledGetObjectDataElementConfiguration : public CHMDataElementConfiguration
{
// Property Retreival Operations
public:
  HRESULT GetAllProperties();
	HRESULT SaveAllProperties();

// HMPolledGetObjectDataElementConfiguration Properties
public:
	CString m_sObjectPath;	// Specifies what data to get .e.g. "Win32_SystemDriver.Name="DiskPerf""

};
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// CHMPolledMethodDataElementConfiguration 

class CHMPolledMethodDataElementConfiguration : public CHMPolledGetObjectDataElementConfiguration
{
// Construction/Destruction
public:
	~CHMPolledMethodDataElementConfiguration();

// static Operations
public:
	static void AddArgument(HMContextArray& Arguments, const CString& sMachineName, const CString& sName, int iType, const CString& sValue);
	static void DestroyArguments(HMContextArray& Arguments);
	static void CopyArgsToSafeArray(HMContextArray& Arguments, COleSafeArray& Target);
	static void CopyArgsFromSafeArray(COleSafeArray& Arguments, HMContextArray& Target);

// Property Retreival Operations
public:
  HRESULT GetAllProperties();
	HRESULT SaveAllProperties();

// HMPolledMethodDataElementConfiguration Properties
public:
	CString m_sMethodName;

	COleSafeArray m_arguments;
	HMContextArray m_Arguments;	// Arguments to the method
};
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// CHMPolledQueryDataElementConfiguration

class CHMQueryDataElementConfiguration : public CHMDataElementConfiguration
{
// Property Retreival Operations
public:
  HRESULT GetAllProperties();
	HRESULT SaveAllProperties();

// HMQueryDataElementConfiguration Properties
public:
	CString m_sQuery;
};
//////////////////////////////////////////////////////////////////////


#endif // !defined(AFX_HMDATAELEMENTCONFIGURATION_H__B0D24257_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementstatistics.h ===
// HMDataElementStatistics.h: interface for the CHMDataElementStatistics class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMDATAELEMENTSTATISTICS_H__A28C24E2_348F_11D3_BE18_0000F87A3912__INCLUDED_)
#define AFX_HMDATAELEMENTSTATISTICS_H__A28C24E2_348F_11D3_BE18_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"
#include "HMPropertyStatus.h"
#include "HMRuleStatus.h"

class CHMDataElementStatistics : public CHMEvent  
{

DECLARE_DYNCREATE(CHMDataElementStatistics)

// Construction/Destruction
public:
	CHMDataElementStatistics();
	virtual ~CHMDataElementStatistics();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Property Retreival Operations
public:
  HRESULT GetAllProperties();

// HMDataElementStatistics Properties
public:
	CString m_sGUID;
	CString m_sDTime;
	COleSafeArray m_Statistics;

	PropertyStatusArray m_PropStats;

	CString		m_sDateTime;
	SYSTEMTIME m_st;

};

#endif // !defined(AFX_HMDATAELEMENTSTATISTICS_H__A28C24E2_348F_11D3_BE18_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmcontext.cpp ===
// HMContext.cpp: implementation of the CHMContext class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMContext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMContext,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMContext::CHMContext()
{
	m_iType = CIM_ILLEGAL;
}

CHMContext::~CHMContext()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMContext::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMContext object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMContext"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMContext::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMContext::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMContext::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Name
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// Type

	hr = GetProperty(IDS_STRING_MOF_TYPE,m_iType);


	// Values
	
	hr = GetProperty(IDS_STRING_MOF_VALUES,m_sValue);


  return hr;
}

HRESULT CHMContext::SaveAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Name
  
  hr = SetProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// Type

	hr = SetProperty(IDS_STRING_MOF_TYPE,m_iType);


	// Values	
	
	hr = SetProperty(IDS_STRING_MOF_VALUES,m_sValue);


  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementstatistics.cpp ===
// HMDataElementStatistics.cpp: implementation of the CHMDataElementStatistics class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMDataElementStatistics.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMDataElementStatistics,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMDataElementStatistics::CHMDataElementStatistics()
{
}

CHMDataElementStatistics::~CHMDataElementStatistics()
{
	for( int i = 0; i < m_PropStats.GetSize(); i++ )
	{
		delete m_PropStats[i];
	}
	m_PropStats.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementStatistics::Create(const CString& sMachineName)
{
  HRESULT hr = CHMEvent::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMDataElementStatistics::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CHMEvent::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementStatistics::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;
	
	// Unique identifier
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGUID);
	m_sGUID.TrimLeft(_T("{"));
	m_sGUID.TrimRight(_T("}"));

	// DTime
  
	CTime time;  
  hr = GetProperty(IDS_STRING_MOF_DTIME,time);
  
	time.GetAsSystemTime(m_st);

	CString sTime;
	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	m_sDateTime = sTime;


	// Statistics
	
	
	hr = GetProperty(IDS_STRING_MOF_STATISTICS,m_Statistics);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_Statistics.GetLBound(1L,&lLower);
		m_Statistics.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_Statistics.GetElement(&i,&pIWBCO);
		CHMPropertyStatus* pPS = new CHMPropertyStatus;
		pPS->Create(pIWBCO);
		pPS->GetAllProperties();
		m_PropStats.Add(pPS);
		pPS->Destroy();
	}

	m_Statistics.Destroy();
	m_Statistics.Detach();


  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementstatus.cpp ===
// HMDataElementStatus.cpp: implementation of the CHMDataElementStatus class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMDataElementStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMDataElementStatus,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMDataElementStatus::CHMDataElementStatus()
{
	m_iNumberWarnings = 0; // Number of Rules currently in critical state
	m_iNumberCriticals = 0;// Number of Rules currently in warning state
	m_iState = HMS_UNKNOWN;	// The state we are in - rollup from all Microsoft_HMDataGroups.
	ZeroMemory(&m_st,sizeof(SYSTEMTIME));
}

CHMDataElementStatus::~CHMDataElementStatus()
{
	for( int i = 0; i < m_RuleStatus.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_RuleStatus[i],CHMRuleStatus) )
		{
			delete m_RuleStatus[i];
		}
	}
	m_RuleStatus.RemoveAll();

	for( i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_RolledUpRuleStatus[i],CHMEvent) )
		{
			delete m_RolledUpRuleStatus[i];
		}
	}
	m_RolledUpRuleStatus.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementStatus::Create(const CString& sMachineName)
{
  HRESULT hr = CHMEvent::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMDataElementStatus object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMDataCollectorStatus"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMDataElementStatus::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CHMEvent::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementStatus::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementStatus::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Name
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// GUID
  
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGuid);
	m_sGuid.TrimLeft(_T("{"));
	m_sGuid.TrimRight(_T("}"));
  

	// NumberNormals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERNORMALS,m_iNumberNormals);

	// NumberWarnings
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,m_iNumberWarnings);
  

	// NumberCriticals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,m_iNumberCriticals);
  

	// State
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);

	switch( m_iState )
	{
		case 0:
		{
			m_sState.LoadString(IDS_STRING_CRITICAL);			
		}
		break;

		case 1:
		{
			m_sState.LoadString(IDS_STRING_WARNING);
		}
		break;

		case 2:
		{
			m_sState.LoadString(IDS_STRING_NODATA);
		}
		break;

		case 3:
		{
			m_sState.LoadString(IDS_STRING_UNKNOWN);
		}
		break;

		case 4:
		{
			m_sState.LoadString(IDS_STRING_OUTAGE);
		}
		break;

		case 5:
		{
			m_sState.LoadString(IDS_STRING_DISABLED);
		}
		break;

		case 6:
		{
			m_sState.LoadString(IDS_STRING_INFORMATION);
		}
		break;

		case 7:
		{
			m_sState.LoadString(IDS_STRING_RESET);
		}
		break;

		case 8:
		{
			m_sState.LoadString(IDS_STRING_NORMAL);
		}
		break;
		
	}

	// StatusGUID

	hr = GetProperty(IDS_STRING_MOF_STATUSGUID,m_sStatusGuid);
	m_sStatusGuid.TrimLeft(_T("{"));
	m_sStatusGuid.TrimRight(_T("}"));


	// DTime
  
	CTime time;  
  hr = GetProperty(IDS_STRING_MOF_LOCALTIME,time);
  
	time.GetAsSystemTime(m_st);

	CString sTime;
	CString sDate;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	m_sDateTime = sDate + _T("  ") + sTime;


	// Message


	hr = GetLocaleStringProperty(IDS_STRING_MOF_MESSAGE,m_sMessage);
  

	if( ! m_sMessage.IsEmpty() )
	{
		CHMRuleStatusInstance* pRSI = new CHMRuleStatusInstance;
		pRSI->SetParent(this);
		pRSI->m_sDataElementName = m_sName;
		pRSI->m_sSystemName = m_sSystemName;
		pRSI->m_sMessage = m_sMessage;
		pRSI->m_iState = m_iState;
		pRSI->m_sState = m_sState;
		pRSI->m_sStatusGuid = m_sStatusGuid;
		pRSI->m_sDateTime = m_sDateTime;
		pRSI->m_sDTime = m_sDTime;
		pRSI->m_st = m_st;

		m_RolledUpRuleStatus.Add(pRSI);

		// propogate the status back up to the HMSystemStatus instance
		// this gives us a roll up of status at each node in the tree
		CHMEvent* pParent = GetParent();
		CHMRuleStatusInstance* pStatus = NULL;
		while(pParent)
		{
			pStatus = new CHMRuleStatusInstance(*pRSI);
			pStatus->SetParent(this);
			pParent->m_RolledUpRuleStatus.Add(pStatus);
			pParent = pParent->GetParent();
		}

	}


	// Rules
	
	
	hr = GetProperty(IDS_STRING_MOF_RULES,m_Rules);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_Rules.GetLBound(1L,&lLower);
		m_Rules.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_Rules.GetElement(&i,&pIWBCO);
		if( pIWBCO )
		{
			CHMRuleStatus* pRS = new CHMRuleStatus;
			pRS->SetParent(this);
			pRS->m_sDataElementName = m_sName;
			pRS->m_sSystemName = m_sSystemName;
			pRS->Create(pIWBCO);
			pRS->GetAllProperties();
			m_RuleStatus.Add(pRS);
		}
	}

  return hr;
}

void CHMDataElementStatus::RemoveStatusEvent(CHMEvent* pEvent)
{
	for( int i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( pEvent == m_RolledUpRuleStatus[i] )
		{
			m_RolledUpRuleStatus.RemoveAt(i);
			break;
		}
	}

	for( i = 0; i < m_RuleStatus.GetSize(); i++ )
	{
		m_RuleStatus[i]->RemoveStatusEvent(pEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementstatus.h ===
// HMDataElementStatus.h: interface for the CHMDataElementStatus class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMDATAELEMENTSTATUS_H__2C8B4D54_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
#define AFX_HMDATAELEMENTSTATUS_H__2C8B4D54_02FB_11D3_BDD8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMRuleStatus.h"

class CHMDataElementStatus : public CHMEvent
{
DECLARE_DYNCREATE(CHMDataElementStatus)

// Construction/Destruction
public:
	CHMDataElementStatus();
	virtual ~CHMDataElementStatus();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();

// Microsoft_HMDataElementStatus properties
public:
	CString		m_sName;	// Name of the system
	CString		m_sGuid;
	int				m_iState;	// The state we are in - rollup from all Microsoft_HMConfigs.
	CString		m_sDTime;	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. GMT minute
	CString		m_sMessage;
	CString		m_sStatusGuid;

	CString		m_sState;
	CString		m_sDateTime;
	SYSTEMTIME m_st;

	COleSafeArray m_Rules;

	RuleStatusArray m_RuleStatus;

// Status Rollup Operations
public:
	void RemoveStatusEvent(CHMEvent* pEvent);
};

typedef CTypedPtrArray<CObArray,CHMDataElementStatus*> DataElementStatusArray;

#endif // !defined(AFX_HMDATAELEMENTSTATUS_H__2C8B4D54_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdataelementconfiguration.cpp ===
// HMDataElementConfiguration.cpp: implementation of the HMDataElementConfiguration class.
//
// Copyright (c) 2000 Microsoft Corporation 
//
// 03/21/00 v-marfin  bug 62315 : Moved from below GetAllProperties() to here to ensure
//                    this property was fetched.


#include "stdafx.h"
#include "snapin.h"
#include "HMDataElementConfiguration.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMDataElementConfiguration,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMDataElementConfiguration::CHMDataElementConfiguration()
{
	m_sName.LoadString(IDS_STRING_UNKNOWN);
	m_sDescription.LoadString(IDS_STRING_UNKNOWN);
	m_iCollectionIntervalMultiple = 0;
	m_iStatisticsWindowSize = 0;
	m_iActiveDays = 0;
	m_bRequireManualReset = false;
	m_bEnable = true;
}

CHMDataElementConfiguration::~CHMDataElementConfiguration()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementConfiguration::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMDataElementConfiguration::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementConfiguration::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataElementConfiguration::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;
	
	// Unique identifier


  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGUID);
	m_sGUID.TrimLeft(_T("{"));
	m_sGUID.TrimRight(_T("}"));

	// Display name

  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);


	// Description

  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,m_sDescription);


	// What Namespace we are to look in. Can contain path to a remote machine.

  
  hr = GetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sTargetNamespace);


	// How often to sample.

  
  hr = GetProperty(IDS_STRING_MOF_COLLECTIONINTERVAL,m_iCollectionIntervalMultiple);


	// Number of collection intervals to calculate the statistics across.
	// And also determining number of event rule cases.

  
  hr = GetProperty(IDS_STRING_MOF_STATISTICSWINDOW,m_iStatisticsWindowSize);


	// Days of the week it is active. One bit per day.	

  
  hr = GetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);


	// Hour (24hr) to activate (if day is active). e.g. 9 for 9AM
	
  
  hr = GetProperty(IDS_STRING_MOF_BEGINTIME,m_BeginTime,false);
	if( hr == S_FALSE )
	{
		m_BeginTime = CTime(1999,12,31,0,0,0);
	}

	
	
	// Hour (24hr) to inactivate. e.g. 1350
	
  
  hr = GetProperty(IDS_STRING_MOF_ENDTIME,m_EndTime,false);
	if( hr == S_FALSE )
	{
		m_EndTime = CTime(1999,12,31,23,59,59);
	}


	// For use by the console to aid in the display
	
  
  hr = GetProperty(IDS_STRING_MOF_TYPEGUID,m_sTypeGUID);
	m_sTypeGUID.TrimLeft(_T("{"));
	m_sTypeGUID.TrimRight(_T("}"));
	
  
  hr = GetProperty(IDS_STRING_MOF_REQUIRERESET,m_bRequireManualReset);


  // Enable

  
  hr = GetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);

	// Statistics Property Names

	hr = GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,m_saStatisticsPropertyNames);


  return hr;
}

HRESULT CHMDataElementConfiguration::SaveEnabledProperty()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

  // Enable
  


  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);

  ASSERT(SUCCEEDED(hr));

  hr = SaveAllProperties();
  ASSERT(SUCCEEDED(hr));

  return hr;
}

HRESULT CHMDataElementConfiguration::SaveAllProperties()
{
	HRESULT hr = S_OK;

	// Display name


  hr = SetProperty(IDS_STRING_MOF_NAME,m_sName);


	// Description

  
  hr = SetProperty(IDS_STRING_MOF_DESCRIPTION,m_sDescription);


	// What Namespace we are to look in. Can contain path to a remote machine.

  
  hr = SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,m_sTargetNamespace);


	// How often to sample.

  
  hr = SetProperty(IDS_STRING_MOF_COLLECTIONINTERVAL,m_iCollectionIntervalMultiple);


	// Number of collection intervals to calculate the statistics across.
	// And also determining number of event rule cases.

  
  hr = SetProperty(IDS_STRING_MOF_STATISTICSWINDOW,m_iStatisticsWindowSize);


	// Days of the week it is active. One bit per day.	

  
  hr = SetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);


	// Hour (24hr) to activate (if day is active). e.g. 9 for 9AM
	
  
  hr = SetProperty(IDS_STRING_MOF_BEGINTIME,m_BeginTime,false);

  

	// Hour (24hr) to inactivate. e.g. 1350
	
  
  hr = SetProperty(IDS_STRING_MOF_ENDTIME,m_EndTime,false);



	// For use by the console to aid in the display

  
  hr = SetProperty(IDS_STRING_MOF_TYPEGUID,m_sTypeGUID);


	
  
  hr = SetProperty(IDS_STRING_MOF_REQUIRERESET,m_bRequireManualReset);



  // Enable

  
  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);

	// Statistics Property Names

	hr = SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,m_saStatisticsPropertyNames);


	if( ! CHECKHRESULT( hr = CWbemClassObject::SaveAllProperties() ) )
	{
		TRACE(_T("FAILED : Call to CWbemClassObject::SaveAllProperties failed.\n"));
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// implementation of the CHMPolledGetObjectDataElementConfiguration class

//////////////////////////////////////////////////////////////////////
// Property Retreival Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMPolledGetObjectDataElementConfiguration::GetAllProperties()
{
	HRESULT hr = S_OK;

	// Unique identifier
    // v-marfin 62315 : Moved from below GetAllProperties() to here to ensure
    //                  this property was fetched.
    hr = GetProperty(IDS_STRING_MOF_PATH,m_sObjectPath);
    if (!CHECKHRESULT(hr))
    {
        return hr;
    }

	if( ! CHECKHRESULT(hr = CHMDataElementConfiguration::GetAllProperties()) )
	{
        return hr;
	}

	return hr;
}

HRESULT CHMPolledGetObjectDataElementConfiguration::SaveAllProperties()
{
	HRESULT hr = S_OK;

	// ObjectPath


  hr = SetProperty(IDS_STRING_MOF_PATH,m_sObjectPath);


	if( ! CHECKHRESULT(hr = CHMDataElementConfiguration::SaveAllProperties()) )
	{
		return hr;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// implementation of the CHMPolledMethodDataElementConfiguration class

CHMPolledMethodDataElementConfiguration::~CHMPolledMethodDataElementConfiguration()
{
	DestroyArguments(m_Arguments);
}

void CHMPolledMethodDataElementConfiguration::AddArgument(HMContextArray& Arguments, const CString& sMachineName, const CString& sName, int iType, const CString& sValue)
{
	CHMContext* pContext = new CHMContext;
	pContext->SetMachineName(sMachineName);
	CString sClassName = _T("Microsoft_HMContext");
	BSTR bsClassName = sClassName.AllocSysString();
	if( ! CHECKHRESULT(pContext->CreateInstance(bsClassName)) )
	{
		return;
	}

	pContext->m_iType = iType;
	pContext->m_sValue = sValue;
	pContext->m_sName = sName;
	pContext->SaveAllProperties();

	Arguments.Add(pContext);

	::SysFreeString(bsClassName);
}

void CHMPolledMethodDataElementConfiguration::DestroyArguments(HMContextArray& Arguments)
{
	for( int i = 0; i < Arguments.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(Arguments[i],CHMContext) )
		{
			delete Arguments[i];
		}
	}
	Arguments.RemoveAll();
}

void CHMPolledMethodDataElementConfiguration::CopyArgsToSafeArray(HMContextArray& Arguments, COleSafeArray& Target)
{
	Target.CreateOneDim(VT_UNKNOWN,(int)Arguments.GetSize());

	for( long i = 0; i < Arguments.GetSize(); i++ )
	{
		IWbemClassObject* pIWCO = Arguments[i]->GetClassObject();
		if( pIWCO )
		{
			Target.PutElement(&i,pIWCO);
			pIWCO->Release();			
		}
	}
}

void CHMPolledMethodDataElementConfiguration::CopyArgsFromSafeArray(COleSafeArray& Arguments, HMContextArray& Target)
{
	long lLower = 0L;
	long lUpper = -1L;

	Arguments.GetLBound(1L,&lLower);
	Arguments.GetUBound(1L,&lUpper);

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		Arguments.GetElement(&i,&pIWBCO);
		if( pIWBCO )
		{
			CHMContext* pHMC = new CHMContext;
			pHMC->Create(pIWBCO);
			pHMC->GetAllProperties();
			Target.Add(pHMC);
		}
	}

}


//////////////////////////////////////////////////////////////////////
// Property Retreival Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMPolledMethodDataElementConfiguration::GetAllProperties()
{
	HRESULT hr = S_OK;
	if( ! CHECKHRESULT(hr = CHMPolledGetObjectDataElementConfiguration::GetAllProperties()) )
	{
		return hr;
	}

	// MethodName

  hr = GetProperty(IDS_STRING_MOF_METHODNAME,m_sMethodName);

	// Arguments

	hr = GetProperty(IDS_STRING_MOF_ARGUMENTS,m_arguments);


	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_arguments.GetLBound(1L,&lLower);
		m_arguments.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_arguments.GetElement(&i,&pIWBCO);
		if( pIWBCO )
		{
			CHMContext* pHMC = new CHMContext;
			pHMC->Create(pIWBCO);
			pHMC->GetAllProperties();
			m_Arguments.Add(pHMC);
		}
	}

	return hr;
}

HRESULT CHMPolledMethodDataElementConfiguration::SaveAllProperties()
{
	HRESULT hr = S_OK;

	// MethodName

  hr = SetProperty(IDS_STRING_MOF_METHODNAME,m_sMethodName);

	// Arguments

	m_arguments.Destroy();
	m_arguments.CreateOneDim(VT_UNKNOWN,(int)m_Arguments.GetSize());

	for( long i = 0; i < m_Arguments.GetSize(); i++ )
	{
		IWbemClassObject* pIWCO = m_Arguments[i]->GetClassObject();
		if( pIWCO )
		{
			m_arguments.PutElement(&i,pIWCO);
			pIWCO->Release();			
		}
	}

	hr = SetProperty(IDS_STRING_MOF_ARGUMENTS,m_arguments);

	if( ! CHECKHRESULT(hr = CHMPolledGetObjectDataElementConfiguration::SaveAllProperties()) )
	{
		return hr;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// implementation of the CHMQueryDataElementConfiguration class

//////////////////////////////////////////////////////////////////////
// Property Retreival Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMQueryDataElementConfiguration::GetAllProperties()
{
	HRESULT hr = S_OK;
	if( ! CHECKHRESULT(hr = CHMDataElementConfiguration::GetAllProperties()) )
	{
		return hr;
	}



  hr = GetProperty(IDS_STRING_MOF_QUERY,m_sQuery);


	return hr;
}

HRESULT CHMQueryDataElementConfiguration::SaveAllProperties()
{
	HRESULT hr = S_OK;



  hr = SetProperty(IDS_STRING_MOF_QUERY,m_sQuery);


	if( ! CHECKHRESULT(hr = CHMDataElementConfiguration::SaveAllProperties()) )
	{
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmeventresultspaneitem.h ===
// HMEventResultsPaneItem.h: interface for the CHMEventResultsPaneItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMEVENTRESULTSPANEITEM_H__E86D3B5F_2E46_11D3_BE0F_0000F87A3912__INCLUDED_)
#define AFX_HMEVENTRESULTSPANEITEM_H__E86D3B5F_2E46_11D3_BE0F_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMResultsPaneItem.h"

class CHMEventResultsPaneItem : public CHMResultsPaneItem  
{

DECLARE_DYNCREATE(CHMEventResultsPaneItem)

// Construction/Destruction
public:
	CHMEventResultsPaneItem();
	virtual ~CHMEventResultsPaneItem();

// Event Data Members
public:
	SYSTEMTIME m_st;
	int m_iState;
	CString m_sGuid;

// Display Names Members
public:
	virtual CString GetDisplayName(int nIndex = 0);
	int GetDateTimeColumn() { return m_iDateTimeColumn; }
	void SetDateTimeColumn(int iIndex) { m_iDateTimeColumn = iIndex; }
protected:
	int m_iDateTimeColumn;

// MMC-Related Members
public:
	virtual int CompareItem(CResultsPaneItem* pItem, int iColumn = 0);
	virtual HRESULT WriteExtensionData(LPSTREAM pStream);

// MMC Notify Handlers
public:
	virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
	virtual HRESULT OnCommand(CResultsPane* pPane, long lCommandID);
	

};

#endif // !defined(AFX_HMEVENTRESULTSPANEITEM_H__E86D3B5F_2E46_11D3_BE0F_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdatagroupstatus.cpp ===
// HMDataGroupStatus.cpp: implementation of the CHMDataGroupStatus class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMDataGroupStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMDataGroupStatus,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMDataGroupStatus::CHMDataGroupStatus()
{
	m_iNumberWarnings = 0; // Number of Rules currently in critical state
	m_iNumberCriticals = 0;// Number of Rules currently in warning state
	m_iState = HMS_UNKNOWN;	// The state we are in - rollup from all Microsoft_HMDataGroups.
}

CHMDataGroupStatus::~CHMDataGroupStatus()
{
	for( int i = 0; i < m_DGStatus.GetSize(); i++ )
	{
		delete m_DGStatus[i];
	}
	m_DGStatus.RemoveAll();

	for( i = 0; i < m_DEStatus.GetSize(); i++ )
	{
		delete m_DEStatus[i];
	}
	m_DEStatus.RemoveAll();

	for( i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_RolledUpRuleStatus[i],CHMEvent) )
		{
			delete m_RolledUpRuleStatus[i];
		}
	}
	m_RolledUpRuleStatus.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupStatus::Create(const CString& sMachineName)
{
  HRESULT hr = CHMEvent::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMDataGroupStatus object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMDataGroupStatus"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMDataGroupStatus::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CHMEvent::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupStatus::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupStatus::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Name
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// GUID
  
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGuid);
	m_sGuid.TrimLeft(_T("{"));
	m_sGuid.TrimRight(_T("}"));

	// NumberNormals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERNORMALS,m_iNumberNormals);
  

	// NumberWarnings
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,m_iNumberWarnings);
  

	// NumberCriticals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,m_iNumberCriticals);
  

	// State
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	// DataGroups
	
	
	hr = GetProperty(IDS_STRING_MOF_DATAGROUPS,m_DataGroups);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_DataGroups.GetLBound(1L,&lLower);
		m_DataGroups.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_DataGroups.GetElement(&i,&pIWBCO);
		CHMDataGroupStatus* pDGS = new CHMDataGroupStatus;
		pDGS->SetParent(this);
		pDGS->m_sSystemName = m_sSystemName;
		pDGS->Create(pIWBCO);
		pDGS->GetAllProperties();
		m_DGStatus.Add(pDGS);
	}

	// DataElements
	
	
	hr = GetProperty(IDS_STRING_MOF_DATAELEMENTS,m_DataElements);
	

	lLower = 0L;
	lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_DataElements.GetLBound(1L,&lLower);
		m_DataElements.GetUBound(1L,&lUpper);
	}

	for( i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_DataElements.GetElement(&i,&pIWBCO);
		CHMDataElementStatus* pDES = new CHMDataElementStatus;
		pDES->SetParent(this);
		pDES->m_sSystemName = m_sSystemName;
		pDES->Create(pIWBCO);
		pDES->GetAllProperties();
		m_DEStatus.Add(pDES);
	}


  return hr;
}

void CHMDataGroupStatus::RemoveStatusEvent(CHMEvent* pEvent)
{
	for( int i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( pEvent == m_RolledUpRuleStatus[i] )
		{
			m_RolledUpRuleStatus.RemoveAt(i);
			break;
		}
	}

	for( i = 0; i < m_DGStatus.GetSize(); i++ )
	{
		m_DGStatus[i]->RemoveStatusEvent(pEvent);
	}

	for( i = 0; i < m_DEStatus.GetSize(); i++ )
	{
		m_DEStatus[i]->RemoveStatusEvent(pEvent);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdatagroupstatus.h ===
// HMDataGroupStatus.h: interface for the CHMDataGroupStatus class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMDATAGROUPSTATUS_H__2C8B4D53_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
#define AFX_HMDATAGROUPSTATUS_H__2C8B4D53_02FB_11D3_BDD8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMDataElementStatus.h"

class CHMDataGroupStatus : public CHMEvent  
{

DECLARE_DYNCREATE(CHMDataGroupStatus)

// Construction/Destruction
public:
	CHMDataGroupStatus();
	virtual ~CHMDataGroupStatus();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();

// Microsoft_HMDataGroupStatus properties
public:
	CString		m_sName;	// Name of the system
	CString		m_sGuid;
	int				m_iState;	// The state we are in - rollup from all Microsoft_HMDataGroups.
	COleSafeArray m_DataGroups;
	COleSafeArray m_DataElements;

	CTypedPtrArray<CObArray,CHMDataGroupStatus*> m_DGStatus;
	DataElementStatusArray m_DEStatus;

// Status Rollup Operations
public:
	void RemoveStatusEvent(CHMEvent* pEvent);
};

typedef CTypedPtrArray<CObArray,CHMDataGroupStatus*> DataGroupStatusArray;

#endif // !defined(AFX_HMDATAGROUPSTATUS_H__2C8B4D53_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdatagroupconfiguration.cpp ===
// HMDataGroupConfiguration.cpp: implementation of the CHMDataGroupConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMDataGroupConfiguration.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMDataGroupConfiguration,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMDataGroupConfiguration::CHMDataGroupConfiguration()
{
	m_sName.LoadString(IDS_STRING_UNKNOWN);
	m_sDescription.LoadString(IDS_STRING_UNKNOWN);;
	m_bEnable = true;
}

CHMDataGroupConfiguration::~CHMDataGroupConfiguration()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupConfiguration::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMDataGroupConfiguration::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupConfiguration::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMDataGroupConfiguration::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;
	
	// Unique identifier
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGUID);
	m_sGUID.TrimLeft(_T("{"));
	m_sGUID.TrimRight(_T("}"));
  

	// Display name
  
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// Description
  
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,m_sDescription);
  

  // Enable
  
  
  hr = GetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  

  return hr;
}

HRESULT CHMDataGroupConfiguration::SaveEnabledProperty()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

  // Enable
  
  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  
  ASSERT(SUCCEEDED(hr));

  hr = SaveAllProperties();
  ASSERT(SUCCEEDED(hr));

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmdatagroupconfiguration.h ===
// HMDataGroupConfiguration.h: interface for the CHMDataGroupConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMDATAGROUPCONFIGURATION_H__B0D24256_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
#define AFX_HMDATAGROUPCONFIGURATION_H__B0D24256_F80C_11D2_BDC8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMDataGroupConfiguration : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMDataGroupConfiguration)

// Construction/Destruction
public:
	CHMDataGroupConfiguration();
	virtual ~CHMDataGroupConfiguration();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();
  HRESULT SaveEnabledProperty();

// HMDataGroupConfiguration Properties
public:
	CString m_sGUID;		// Unique identifier
	CString m_sName;		// Display name
	CString	m_sDescription;// Description
	bool m_bEnable;		//  True = enabled; False = disabled
};

typedef CTypedPtrArray<CObArray,CHMDataGroupConfiguration*> DataGroupArray;

#endif // !defined(AFX_HMDATAGROUPCONFIGURATION_H__B0D24256_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmeventresultspaneitem.cpp ===
// HMEventResultsPaneItem.cpp: implementation of the CHMEventResultsPaneItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMEventResultsPaneItem.h"
#include "HealthmonResultsPane.h"
#include "ScopePaneItem.h"
#include "ResultsPaneView.h"
#include "AlertPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMEventResultsPaneItem,CHMResultsPaneItem)


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMEventResultsPaneItem::CHMEventResultsPaneItem()
{
	ZeroMemory(&m_st,sizeof(SYSTEMTIME));
	m_iState = HMS_UNKNOWN;
	m_iDateTimeColumn = -1;
}

CHMEventResultsPaneItem::~CHMEventResultsPaneItem()
{
	Destroy();
	m_iState = -1;
	m_iDateTimeColumn = -1;
}

/////////////////////////////////////////////////////////////////////////////
// Display Names Members

CString CHMEventResultsPaneItem::GetDisplayName(int nIndex /* = 0*/)
{
	TRACEX(_T("CResultsPaneItem::GetDisplayName\n"));
	TRACEARGn(nIndex);

	if( nIndex >= m_saDisplayNames.GetSize() || nIndex < 0 )
	{
		TRACE(_T("FAILED : nIndex is out of array bounds.\n"));
		return _T("");
	}

	if( nIndex == GetDateTimeColumn() )
	{
		CString sTime;
		CString sDate;

		int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
		iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
		sTime.ReleaseBuffer();

		iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
		iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
		sDate.ReleaseBuffer();

		return sDate + _T("  ") + sTime;		
	}

	return m_saDisplayNames[nIndex];	
}

/////////////////////////////////////////////////////////////////////////////
// MMC-Related Members

int CHMEventResultsPaneItem::CompareItem(CResultsPaneItem* pItem, int iColumn /*= 0*/ )
{
	TRACEX(_T("CResultsPaneItem::CompareItem\n"));
	TRACEARGn(pItem);
	TRACEARGn(iColumn);

	CHMEventResultsPaneItem* pEventItem = (CHMEventResultsPaneItem*)pItem;

	if( ! GfxCheckObjPtr(pEventItem,CHMEventResultsPaneItem) )
	{
		return CResultsPaneItem::CompareItem(pItem,iColumn);
	}

	if( iColumn == GetDateTimeColumn() )
	{
		CTime time1(m_st);
		CTime time2(pEventItem->m_st);
		if( time1 == time2 )
			return 0;
		if( time1 < time2 )
			return 1;
		if( time1 > time2 )
			return -1;
	}

	if( iColumn == 0 && IsLowerPane() )
	{
		if( m_iState == pEventItem->m_iState )
			return 0;
		if( m_iState < pEventItem->m_iState )
			return 1;
		if( m_iState > pEventItem->m_iState )
			return -1;
	}

	return CResultsPaneItem::CompareItem(pItem,iColumn);
}

HRESULT CHMEventResultsPaneItem::WriteExtensionData(LPSTREAM pStream)
{
	TRACEX(_T("CHMEventResultsPaneItem::WriteExtensionData\n"));
	TRACEARGn(pStream);

	HRESULT hr = S_OK;

	ULONG ulSize = GetDisplayName(3).GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(GetDisplayName(3), ulSize, NULL)) )
	{
		return hr;
	}

	CString sType = IDS_STRING_MOF_HMR_STATUS;
	ulSize = sType.GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(sType, ulSize, NULL)) )
	{
		return hr;
	}

	ulSize = m_sGuid.GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(m_sGuid, ulSize, NULL)) )
	{
		return hr;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Notify Handlers
/////////////////////////////////////////////////////////////////////////////

HRESULT CHMEventResultsPaneItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CHMEventResultsPaneItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

	HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
    // TODO: Add any context menu items for the New Menu here
  }

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
	  // TODO: Add any context menu items for the Task Menu here
  }

	  // Add Top Menu Items
  if( CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

		// Copy
    sResString.LoadString(IDS_STRING_COPY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));    
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_COPY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }	  

		if( ! IsStatsPane() )
		{
			// Delete
			sResString.LoadString(IDS_STRING_CLEAR);
			cmi.strName           = LPTSTR(LPCTSTR(sResString));    
			cmi.strStatusBarText  = NULL;
			cmi.lCommandID        = IDM_DELETE;
			cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			cmi.fFlags            = 0;
			cmi.fSpecialFlags     = 0;

			hr = piCallback->AddItem(&cmi);
			if( !SUCCEEDED(hr) )
			{
				TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				return hr;
			}	  

      // Refresh
			sResString.LoadString(IDS_STRING_REFRESH);
			cmi.strName           = LPTSTR(LPCTSTR(sResString));    
			cmi.strStatusBarText  = NULL;
			cmi.lCommandID        = IDM_REFRESH;
			cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			cmi.fFlags            = 0;
			cmi.fSpecialFlags     = 0;

			hr = piCallback->AddItem(&cmi);
			if( !SUCCEEDED(hr) )
			{
				TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				return hr;
			}	  

      if( ! IsUpperPane() )
      {
			  cmi.strName           = NULL;    
			  cmi.strStatusBarText  = NULL;
			  cmi.lCommandID        = 0;
			  cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			  cmi.fFlags            = MF_SEPARATOR;
			  cmi.fSpecialFlags     = 0;

			  hr = piCallback->AddItem(&cmi);
			  if( !SUCCEEDED(hr) )
			  {
				  TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				  return hr;
			  }	  

        // Properties
			  sResString.LoadString(IDS_STRING_ALERT_PROPERTIES);
			  cmi.strName           = LPTSTR(LPCTSTR(sResString));    
			  cmi.strStatusBarText  = NULL;
			  cmi.lCommandID        = IDM_PROPERTIES;
			  cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			  cmi.fFlags            = 0;
			  cmi.fSpecialFlags     = 0;

			  hr = piCallback->AddItem(&cmi);
			  if( !SUCCEEDED(hr) )
			  {
				  TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				  return hr;
			  }	          

			  cmi.strName           = NULL;    
			  cmi.strStatusBarText  = NULL;
			  cmi.lCommandID        = 0;
			  cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			  cmi.fFlags            = MF_SEPARATOR;
			  cmi.fSpecialFlags     = 0;

			  hr = piCallback->AddItem(&cmi);
			  if( !SUCCEEDED(hr) )
			  {
				  TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				  return hr;
			  }	  
      }

      // Help
			sResString.LoadString(IDS_STRING_HELP);
			cmi.strName           = LPTSTR(LPCTSTR(sResString));    
			cmi.strStatusBarText  = NULL;
			cmi.lCommandID        = IDM_HELP;
			cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			cmi.fFlags            = 0;
			cmi.fSpecialFlags     = 0;

			hr = piCallback->AddItem(&cmi);
			if( !SUCCEEDED(hr) )
			{
				TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
				return hr;
			}	  

		}
  }


	return S_OK;
}

HRESULT CHMEventResultsPaneItem::OnCommand(CResultsPane* pPane, long lCommandID)
{
	TRACEX(_T("CHMEventResultsPaneItem::OnCommand\n"));
	TRACEARGn(pPane);
	TRACEARGn(lCommandID);

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;
	if( ! GfxCheckObjPtr(pHMRP,CHealthmonResultsPane) )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	switch( lCommandID )
	{
		case IDM_CUT:
		{
			
		}
		break;

		case IDM_COPY:
		{
			_DHMListView* pListView = IsStatsPane() ? pHMRP->GetStatsListCtrl() : pHMRP->GetLowerListCtrl();

			if( ! pListView )
			{
				return E_FAIL;
			}

			CTypedPtrArray<CObArray,CHMEventResultsPaneItem*> Items;

			int iIndex = pListView->GetNextItem(-1,LVNI_SELECTED);
			while( iIndex != -1 )
			{
				LPARAM lParam = pListView->GetItem(iIndex);

				CHMEventResultsPaneItem* pItem = (CHMEventResultsPaneItem*)lParam;
				if( GfxCheckObjPtr(pItem,CHMEventResultsPaneItem) )
				{
					Items.Add(pItem);
				}

				int iNextIndex = pListView->GetNextItem(iIndex,LVNI_SELECTED|LVNI_BELOW);
				if( iNextIndex == iIndex )
				{
					break;
				}
				else
				{
					iIndex = iNextIndex;
				}
			}


			CString sData;

			for( int i = 0; i < Items.GetSize(); i++ )
			{
				CHMEventResultsPaneItem* pItem = Items[i];

				if( IsStatsPane() )
				{
					for( int l = 0; l < pItem->GetDisplayNameCount(); l++ )
					{
						sData += pItem->m_saDisplayNames[l] + _T("\t");
					}
				}
				else
				{
					for( int l = 0; l < pItem->GetDisplayNameCount(); l++ )
					{
						sData += pItem->GetDisplayName(l) + _T("\t");
					}
				}
				sData.TrimRight(_T("\t"));

				sData += _T("\r\n");
			}			

			COleDataSource* pDataSource = new COleDataSource;

			// Allocate memory for the stream
			HGLOBAL hGlobal = GlobalAlloc( GMEM_SHARE, (sData.GetLength()+1)*sizeof(TCHAR) );

			if( ! hGlobal )
			{
				hr = E_OUTOFMEMORY;
				TRACE(_T("FAILED : Out of Memory.\n"));
				return hr;
			}

			LPVOID lpGlobal = GlobalLock(hGlobal);

			CopyMemory(lpGlobal,(LPCTSTR)sData,(sData.GetLength()+1)*sizeof(TCHAR));

			GlobalUnlock(hGlobal);

			pDataSource->CacheGlobalData(CF_UNICODETEXT,hGlobal);

			pDataSource->SetClipboard();
			
		}
		break;

		case IDM_DELETE:
		{
			CHMListViewEventSink* pSink = pHMRP->GetLowerListSink();
			pSink->OnDelete();
		}
		break;

    case IDM_PROPERTIES:
    {
			_DHMListView* pListView = IsStatsPane() ? pHMRP->GetStatsListCtrl() : pHMRP->GetLowerListCtrl();

      CPropertySheet sheet(IDS_STRING_PROPERTIES_OF_ALERT);
      sheet.m_psh.dwFlags |= PSH_HASHELP;
      sheet.m_psh.dwFlags |= PSH_NOAPPLYNOW;

      CAlertPage page;
      page.m_psp.dwFlags |= PSP_HASHELP;
      sheet.AddPage(&page);

      page.m_sSeverity = GetDisplayName(0);
      page.m_sID = GetDisplayName(1);
      page.m_sDTime = GetDisplayName(2);
      page.m_sDataCollector = GetDisplayName(3);
      page.m_sComputer = GetDisplayName(4);
      page.m_sAlert = GetDisplayName(5);
      page.m_pScopePane = pHMRP->GetOwnerScopePane();
      page.m_pListView = pListView;

#ifndef IA64
      page.m_iIndex = pListView->FindItemByLParam((LPARAM)this);  // Needs ptr fixing
#endif // IA64

      sheet.DoModal();
    }
    break;

    case IDM_REFRESH:
    {
      CResultsPaneView* pView = GetOwnerResultsView();
      if( pView )
      {
        CScopePaneItem* pSPI = pView->GetOwnerScopeItem();
        if( GfxCheckObjPtr(pSPI,CScopePaneItem) )
        {
          pSPI->OnRefresh();
        }
      }
    }
    break;

    case IDM_HELP:
    {
      CResultsPaneView* pView = GetOwnerResultsView();
      if( pView )
      {
        CScopePaneItem* pSPI = pView->GetOwnerScopeItem();
        if( GfxCheckObjPtr(pSPI,CScopePaneItem) )
        {
          pSPI->OnContextHelp();
        }
      }
    }
    break;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmheaderctrl.h ===
#if !defined(AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
#define AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMHeaderCtrl.h : header file
//

#define _MAX_COLUMNS 2

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl window

class CHMHeaderCtrl : public CHeaderCtrl
{
// Construction
public:
	CHMHeaderCtrl();

// Attributes
public:
	int GetLastColumn();
protected:
	HBITMAP GetArrowBitmap(bool bAscending);
	void CreateUpArrowBitmap();
	void CreateDownArrowBitmap();
	CBitmap m_up;
	CBitmap m_down;
	int m_iLastColumn;
	bool m_bSortAscending;

// Operations
public:
	int SetSortImage( int nColumn, bool bAscending );
	void RemoveSortImage(int nColumn);
	void RemoveAllSortImages();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMHeaderCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHMHeaderCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHMHeaderCtrl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgraphview.h ===
#ifndef __HMGRAPHVIEW_H__
#define __HMGRAPHVIEW_H__
// Machine generated IDispatch wrapper class(es) created with ClassWizard
// _DHMGraphView wrapper class

class _DHMGraphView : public COleDispatchDriver
{
public:
	_DHMGraphView() {}		// Calls COleDispatchDriver default constructor
	_DHMGraphView(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DHMGraphView(const _DHMGraphView& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	long GetStyle();
	void InsertHistoricGroupStats(LPCTSTR lpszName, LPCTSTR lpszTime, long lNormal, long lWarning, long lCritical, long lUnknown);
	void InsertCurrentGroupStats(LPCTSTR lpszName, long lNormal, long lWarning, long lCritical, long lUnknown);
	void InsertCurrentElementStats(LPCTSTR lpszName, LPCTSTR lpszInstance, long lCurrent, long lMin, long lMax, long lAverage);
	void InsertHistoricElementStats(LPCTSTR lpszName, LPCTSTR lpszInstance, LPCTSTR lpszTime, long lCurrent);
	void SetStyle(long lNewStyle);
	void SetName(LPCTSTR lpszName);
	void Clear();
	void AboutBox();
};

#endif //__HMGRAPHVIEW_H__/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgeneralpage.cpp ===
// HMGeneralPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HMGeneralPage.h"
#include "FileVersion.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMGeneralPage property page

IMPLEMENT_DYNCREATE(CHMGeneralPage, CHMPropertyPage)

CHMGeneralPage::CHMGeneralPage() : CHMPropertyPage(CHMGeneralPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CHMGeneralPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dhmongen.htm");
}

CHMGeneralPage::~CHMGeneralPage()
{
}

void CHMGeneralPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CHMGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHMGeneralPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CHMGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CHMGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CHMGeneralPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CHMGeneralPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IHMGeneralPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {C3F44E6B-BA00-11D2-BD76-0000F87A3912}
static const IID IID_IHMGeneralPage =
{ 0xc3f44e6b, 0xba00, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CHMGeneralPage, CHMPropertyPage)
	INTERFACE_PART(CHMGeneralPage, IID_IHMGeneralPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMGeneralPage message handlers


BOOL CHMGeneralPage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();
	
	TCHAR szFileName[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),szFileName,_MAX_PATH);

	CFileVersion fv;
	
	fv.Open(szFileName);

	CString sDescription;
	sDescription += _T("\r\n");
	sDescription += fv.GetFileDescription();
  sDescription += _T(" Version ");
  sDescription += fv.GetFileVersion();
	sDescription += _T("\r\n");
	sDescription += fv.GetLegalCopyright();

  GetDlgItem(IDC_STATIC_INFO)->SetWindowText(sDescription);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgraphvieweventsink.h ===
#if !defined(AFX_HMGRAPHVIEWEVENTSINK_H__C54EFB02_3555_11D3_BE19_0000F87A3912__INCLUDED_)
#define AFX_HMGRAPHVIEWEVENTSINK_H__C54EFB02_3555_11D3_BE19_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMGraphViewEventSink.h : header file
//

class CSplitPaneResultsView;
class _DHMGraphView;

/////////////////////////////////////////////////////////////////////////////
// CHMGraphViewEventSink command target

class CHMGraphViewEventSink : public CCmdTarget
{

DECLARE_DYNCREATE(CHMGraphViewEventSink)

// Construction/Destruction
public:
	CHMGraphViewEventSink();           // protected constructor used by dynamic creation
	virtual ~CHMGraphViewEventSink();

// Attributes
public:
	CSplitPaneResultsView* GetResultsViewPtr();
	void SetResultsViewPtr(CSplitPaneResultsView* pView);
	_DHMGraphView* GetGraphViewCtrl() { return m_pGraphView; }
	void SetGraphViewCtrl(_DHMGraphView* pGraphCtrl) { m_pGraphView = pGraphCtrl; }
protected:
	CSplitPaneResultsView* m_pView;
	DWORD m_dwEventCookie;	
	_DHMGraphView* m_pGraphView;

// Operations
public:
	HRESULT HookUpEventSink(LPUNKNOWN lpControlUnknown);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMGraphViewEventSink)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHMGraphViewEventSink)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CHMGraphViewEventSink)
	afx_msg void OnChangeStyle(long lNewStyle);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMGRAPHVIEWEVENTSINK_H__C54EFB02_3555_11D3_BE19_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgraphview.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "hmgraphview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




/////////////////////////////////////////////////////////////////////////////
// _DHMGraphView properties

/////////////////////////////////////////////////////////////////////////////
// _DHMGraphView operations

long _DHMGraphView::GetStyle()
{
	long result;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void _DHMGraphView::InsertHistoricGroupStats(LPCTSTR lpszName, LPCTSTR lpszTime, long lNormal, long lWarning, long lCritical, long lUnknown)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszName, lpszTime, lNormal, lWarning, lCritical, lUnknown);
}

void _DHMGraphView::InsertCurrentGroupStats(LPCTSTR lpszName, long lNormal, long lWarning, long lCritical, long lUnknown)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszName, lNormal, lWarning, lCritical, lUnknown);
}

void _DHMGraphView::InsertCurrentElementStats(LPCTSTR lpszName, LPCTSTR lpszInstance, long lCurrent, long lMin, long lMax, long lAverage)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszName, lpszInstance, lCurrent, lMin, lMax, lAverage);
}

void _DHMGraphView::InsertHistoricElementStats(LPCTSTR lpszName, LPCTSTR lpszInstance, LPCTSTR lpszTime, long lCurrent)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszName, lpszInstance, lpszTime, lCurrent);
}

void _DHMGraphView::SetStyle(long lNewStyle)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lNewStyle);
}

void _DHMGraphView::SetName(LPCTSTR lpszName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszName);
}

void _DHMGraphView::Clear()
{
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void _DHMGraphView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmheaderctrl.cpp ===
// HMHeaderCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "HMHeaderCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl

CHMHeaderCtrl::CHMHeaderCtrl()
{
	m_iLastColumn = -1;
}

CHMHeaderCtrl::~CHMHeaderCtrl()
{
	m_up.DeleteObject();
	m_down.DeleteObject();
}

inline HBITMAP CHMHeaderCtrl::GetArrowBitmap(bool bAscending)
{
	if( bAscending )
	{
		if( ! m_up.GetSafeHandle() )
		{
			CreateUpArrowBitmap();
		}
		return (HBITMAP)m_up.GetSafeHandle();
	}
	else
	{
		if( ! m_down.GetSafeHandle() )
		{
			CreateDownArrowBitmap();
		}
		return (HBITMAP)m_down.GetSafeHandle();
	}

	return NULL;
}

inline void CHMHeaderCtrl::CreateUpArrowBitmap()
{
	CDC MemDC;
	CClientDC dc(this);
	CRect r(0,0,8,8);

	// create offscreen dc and offscreen bitmap
	MemDC.CreateCompatibleDC(&dc);

	m_up.CreateCompatibleBitmap(&dc,r.Width(),r.Height());

	CBitmap* pOldBitmap = MemDC.SelectObject(&m_up);

	// Draw the background
	MemDC.FillSolidRect(r, ::GetSysColor(COLOR_3DFACE));

	// Set up pens to use for drawing the triangle
	CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	CPen *pOldPen = MemDC.SelectObject( &penLight );

	// Draw triangle pointing upwards
	MemDC.MoveTo( r.left,		r.bottom-1 );
	MemDC.LineTo( r.right,	r.bottom-1 );
	MemDC.LineTo( r.right/2,	r.top );

	MemDC.SelectObject( &penShadow );
	MemDC.LineTo( r.left, r.bottom-1 );

	// clean up
	MemDC.SelectObject(pOldPen);
	MemDC.SelectObject(pOldBitmap);
}

inline void CHMHeaderCtrl::CreateDownArrowBitmap()
{
	CDC MemDC;
	CClientDC dc(this);
	CRect r(0,0,8,8);

	// create offscreen dc and offscreen bitmap
	MemDC.CreateCompatibleDC(&dc);

	m_down.CreateCompatibleBitmap(&dc,r.Width(),r.Height());

	CBitmap* pOldBitmap = MemDC.SelectObject(&m_down);

	// Draw the background
	MemDC.FillSolidRect(r, ::GetSysColor(COLOR_3DFACE));

	// Set up pens to use for drawing the triangle
	CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	CPen *pOldPen = MemDC.SelectObject( &penShadow );

	// Draw triangle pointing downwards
	MemDC.MoveTo( r.right,		r.top );
	MemDC.LineTo( r.left,			r.top );
	MemDC.LineTo( r.right/2,	r.bottom );

	MemDC.SelectObject( &penLight );
	MemDC.LineTo( r.right, r.top );

	// clean up
	MemDC.SelectObject(pOldPen);
	MemDC.SelectObject(pOldBitmap);
}

int CHMHeaderCtrl::SetSortImage( int nColumn, bool bAscending )
{
	int nPrevCol = m_iLastColumn;
	m_bSortAscending = bAscending;

	// set the passed column to display the appropriate sort indicator
	HDITEM hditem;
	hditem.mask = HDI_FORMAT;
	GetItem( nColumn, &hditem );
	hditem.mask = HDI_BITMAP | HDI_FORMAT;
	hditem.fmt |= HDF_BITMAP;
	hditem.fmt |= HDF_BITMAP_ON_RIGHT;
	hditem.hbm = (HBITMAP)GetArrowBitmap(bAscending);
	SetItem( nColumn, &hditem );

	// save off the last column the user clikced on
	m_iLastColumn = nColumn;

	return nPrevCol;
}

void CHMHeaderCtrl::RemoveSortImage(int nColumn)
{
	// clear the sort indicator from the previous column
	HDITEM hditem;
	hditem.mask = HDI_FORMAT;
	GetItem( nColumn, &hditem );
	hditem.mask = HDI_FORMAT;
	hditem.fmt &= ~HDF_BITMAP;
	hditem.fmt &= ~HDF_BITMAP_ON_RIGHT;
	SetItem( nColumn, &hditem );
}

void CHMHeaderCtrl::RemoveAllSortImages()
{
	int iCount = GetItemCount();
	for( int i = 0; i < iCount; i++ )
	{
		RemoveSortImage(i);
	}
}


BEGIN_MESSAGE_MAP(CHMHeaderCtrl, CHeaderCtrl)
	//{{AFX_MSG_MAP(CHMHeaderCtrl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgeneralpage.h ===
#if !defined(AFX_HMGENERALPAGE_H__C3F44E6C_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_HMGENERALPAGE_H__C3F44E6C_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CHMGeneralPage dialog

class CHMGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CHMGeneralPage)

// Construction
public:
	CHMGeneralPage();
	~CHMGeneralPage();

// Dialog Data
	//{{AFX_DATA(CHMGeneralPage)
	enum { IDD = IDD_HEALTHMONITOR_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHMGeneralPage)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHMGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CHMGeneralPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMGENERALPAGE_H__C3F44E6C_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmgraphvieweventsink.cpp ===
// HMGraphViewEventSink.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HMGraphViewEventSink.h"
#include "HMGraphView.h"
#include "SplitPaneResultsView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMGraphViewEventSink

IMPLEMENT_DYNCREATE(CHMGraphViewEventSink, CCmdTarget)

CHMGraphViewEventSink::CHMGraphViewEventSink()
{
	EnableAutomation();
	m_dwEventCookie = 0L;
	m_pGraphView = NULL;
	m_pView = NULL;
}

CHMGraphViewEventSink::~CHMGraphViewEventSink()
{
	m_pGraphView = NULL;
	m_pView = NULL;
}


void CHMGraphViewEventSink::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}

CSplitPaneResultsView* CHMGraphViewEventSink::GetResultsViewPtr()
{
	TRACEX(_T("CHMGraphViewEventSink::GetResultsViewPtr\n"));

	if( ! GfxCheckObjPtr(m_pView,CSplitPaneResultsView) )
	{
		return NULL;
	}

	return m_pView;
}

void CHMGraphViewEventSink::SetResultsViewPtr(CSplitPaneResultsView* pView)
{
	TRACEX(_T("CHMGraphViewEventSink::SetObjectPtr\n"));
	TRACEARGn(pView);

	if( ! pView || ! GfxCheckObjPtr(pView,CSplitPaneResultsView) )
	{
		m_pView = NULL;
		return;
	}

	m_pView = pView;
}

HRESULT CHMGraphViewEventSink::HookUpEventSink(LPUNKNOWN lpControlUnknown)
{
	TRACEX(_T("CHMGraphViewEventSink::HookUpEventSink\n"));
	TRACEARGn(lpControlUnknown);

	HRESULT hr = S_OK;
  IConnectionPointContainer* pCPC = 0;
	hr = lpControlUnknown->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if(pCPC)
	{
		IProvideClassInfo2* pPCI = 0;
		lpControlUnknown->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);
		if(pPCI)
		{
			IID iidEventSet;
			hr = pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,&iidEventSet);
			if(SUCCEEDED(hr))
			{
				IConnectionPoint* pCP = 0;
				hr = pCPC->FindConnectionPoint(iidEventSet, &pCP);

				if(pCP)
				{
					pCP->Advise(GetIDispatch(TRUE),&m_dwEventCookie); 
					pCP->Release();
				}
			}
			pPCI->Release();
		}
		pCPC->Release();
	}

	return hr;
}


BEGIN_MESSAGE_MAP(CHMGraphViewEventSink, CCmdTarget)
	//{{AFX_MSG_MAP(CHMGraphViewEventSink)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CHMGraphViewEventSink, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CHMGraphViewEventSink)
	DISP_FUNCTION(CHMGraphViewEventSink, "OnChangeStyle", OnChangeStyle, VT_EMPTY, VTS_I4)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IHMGraphViewEventSink to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {C54EFB01-3555-11D3-BE19-0000F87A3912}
static const IID IID_IHMGraphViewEventSink =
{ 0xc54efb01, 0x3555, 0x11d3, { 0xbe, 0x19, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CHMGraphViewEventSink, CCmdTarget)
	INTERFACE_PART(CHMGraphViewEventSink, IID_IHMGraphViewEventSink, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMGraphViewEventSink message handlers

void CHMGraphViewEventSink::OnChangeStyle(long lNewStyle) 
{
	CSplitPaneResultsView* pView = GetResultsViewPtr();
	if( ! pView )
	{
		return;
	}
	
	pView->OnGraphViewStyleChange(m_pGraphView);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmhistorypage.cpp ===
// HMHistoryPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HMHistoryPage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMHistoryPage property page

IMPLEMENT_DYNCREATE(CHMHistoryPage, CHMPropertyPage)

CHMHistoryPage::CHMHistoryPage() : CHMPropertyPage(CHMHistoryPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CHMHistoryPage)
	m_iRefreshSelection = -1;
	m_iTimePeriod = 0;
	m_iNumberEvents = 0;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dhmonhis.htm");
}

CHMHistoryPage::~CHMHistoryPage()
{
}

void CHMHistoryPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CHMHistoryPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHMHistoryPage)
	DDX_Control(pDX, IDC_SPIN7, m_TimeSpin);
	DDX_Control(pDX, IDC_SPIN1, m_EventSpin);
	DDX_Control(pDX, IDC_COMBO_TIME, m_TimeUnits);
	DDX_Radio(pDX, IDC_RADIO_NONE, m_iRefreshSelection);
	DDX_Text(pDX, IDC_EDIT_TIME_PERIOD, m_iTimePeriod);
	DDX_Text(pDX, IDC_EDIT_NUMBER_EVENTS, m_iNumberEvents);
	//}}AFX_DATA_MAP

	if( pDX->m_bSaveAndValidate )
	{
		m_Units = (TimeUnit)m_TimeUnits.GetCurSel();
	}
	else
	{
		m_TimeUnits.SetCurSel(m_Units);
	}

	switch( m_iRefreshSelection )
	{
		case 0: // None
		{
			GetDlgItem(IDC_EDIT_NUMBER_EVENTS)->EnableWindow(FALSE);
			GetDlgItem(IDC_SPIN7)->EnableWindow(FALSE);
			GetDlgItem(IDC_EDIT_TIME_PERIOD)->EnableWindow(FALSE);
			GetDlgItem(IDC_SPIN1)->EnableWindow(FALSE);
			GetDlgItem(IDC_COMBO_TIME)->EnableWindow(FALSE);
		}
		break;

		case 1: // Refresh by count of events
		{
			GetDlgItem(IDC_EDIT_NUMBER_EVENTS)->EnableWindow(TRUE);
			GetDlgItem(IDC_SPIN7)->EnableWindow(TRUE);
			GetDlgItem(IDC_EDIT_TIME_PERIOD)->EnableWindow(FALSE);
			GetDlgItem(IDC_SPIN1)->EnableWindow(FALSE);
			GetDlgItem(IDC_COMBO_TIME)->EnableWindow(FALSE);
		}
		break;

		case 2: // Refresh by time period
		{
			GetDlgItem(IDC_EDIT_NUMBER_EVENTS)->EnableWindow(FALSE);
			GetDlgItem(IDC_SPIN7)->EnableWindow(FALSE);
			GetDlgItem(IDC_EDIT_TIME_PERIOD)->EnableWindow(TRUE);
			GetDlgItem(IDC_SPIN1)->EnableWindow(TRUE);
			GetDlgItem(IDC_COMBO_TIME)->EnableWindow(TRUE);
		}
		break;
	}
}

BEGIN_MESSAGE_MAP(CHMHistoryPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CHMHistoryPage)
	ON_BN_CLICKED(IDC_RADIO_NONE, OnRadioNone)
	ON_BN_CLICKED(IDC_RADIO_NUMBER_EVENTS, OnRadioNumberEvents)
	ON_BN_CLICKED(IDC_RADIO_TIME_PERIOD, OnRadioTimePeriod)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CHMHistoryPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CHMHistoryPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IHMHistoryPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {C3F44E6E-BA00-11D2-BD76-0000F87A3912}
static const IID IID_IHMHistoryPage =
{ 0xc3f44e6e, 0xba00, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CHMHistoryPage, CHMPropertyPage)
	INTERFACE_PART(CHMHistoryPage, IID_IHMHistoryPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMHistoryPage message handlers


BOOL CHMHistoryPage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();

	CHMObject* pObject = GetObjectPtr();

	if( ! pObject )
	{
		return FALSE;
	}

	m_iRefreshSelection = pObject->GetRefreshType();
	m_iNumberEvents = pObject->GetRefreshEventCount();
	pObject->GetRefreshTimePeriod(m_iTimePeriod,m_Units);

	UpdateData(FALSE);

	m_EventSpin.SetRange32(0,INT_MAX-1);
	m_TimeSpin.SetRange32(0,INT_MAX-1);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CHMHistoryPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CHMHistoryPage::OnRadioNone() 
{
	UpdateData();	
	SetModified();
}

void CHMHistoryPage::OnRadioNumberEvents() 
{
	UpdateData();
	SetModified();
}

void CHMHistoryPage::OnRadioTimePeriod() 
{
	UpdateData();	
	SetModified();
}

BOOL CHMHistoryPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CHMObject* pObject = GetObjectPtr();

	if( ! pObject )
	{
		return FALSE;
	}
	
	pObject->SetRefreshType(m_iRefreshSelection);

	switch( m_iRefreshSelection )
	{
		case 0: // None
		{
		}
		break;

		case 1: // Refresh by count of events
		{
			pObject->SetRefreshEventCount(m_iNumberEvents);
		}
		break;

		case 2: // Refresh by time period
		{
			pObject->SetRefreshTimePeriod(m_iTimePeriod,m_Units);
		}
		break;
	}

  SetModified(FALSE);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmhistorypage.h ===
#if !defined(AFX_HMHISTORYPAGE_H__C3F44E6F_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_HMHISTORYPAGE_H__C3F44E6F_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMHistoryPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CHMHistoryPage dialog

class CHMHistoryPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CHMHistoryPage)

// Construction
public:
	CHMHistoryPage();
	~CHMHistoryPage();

// Dialog Data
	//{{AFX_DATA(CHMHistoryPage)
	enum { IDD = IDD_HEALTHMONITOR_HISTORY };
	CSpinButtonCtrl	m_TimeSpin;
	CSpinButtonCtrl	m_EventSpin;
	CComboBox	m_TimeUnits;
	int		m_iRefreshSelection;
	int		m_iTimePeriod;
	int		m_iNumberEvents;
	//}}AFX_DATA
	TimeUnit m_Units;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHMHistoryPage)
	public:
	virtual void OnFinalRelease();
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHMHistoryPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioNone();
	afx_msg void OnRadioNumberEvents();
	afx_msg void OnRadioTimePeriod();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CHMHistoryPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMHISTORYPAGE_H__C3F44E6F_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlist.cpp ===
// HMList.cpp : implementation file
//

#include "stdafx.h"
#include "Snapin.h"
#include "HMList.h"
#include "SortClass.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const int _IDM_HEADER_CONTEXTMENU_BASE = 1500;

/////////////////////////////////////////////////////////////////////////////
// CHMList

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////////////////////////////

CHMList::CHMList()
{
	m_bSorting = false;
	m_lColumnSortStates = 0;
}

CHMList::~CHMList()
{
}

/////////////////////////////////////////////////////////////////////////////
// Sorting Operations
/////////////////////////////////////////////////////////////////////////////

void CHMList::SortColumn( int iSubItem, bool bSortingMultipleColumns )
{	
	int iNumCombinedSortedCols = GetNumCombinedSortedColumns();
	m_bSorting = true;

	if( bSortingMultipleColumns )
	{
		if( NotInCombinedSortedColumnList( iSubItem ) )
		{
			m_aCombinedSortedColumns[ iNumCombinedSortedCols++ ] = iSubItem;
		}
		else
		{
			MoveItemInCombinedSortedListToEnd( iSubItem );
		}

		for( int i = iNumCombinedSortedCols - 1; i >= 0 ; i-- )
		{
			SORT_STATE ssEachItem = GetItemSortState( m_aCombinedSortedColumns[i] );
			if( iNumCombinedSortedCols - 1 != i )
			{
				ssEachItem = (SORT_STATE)!ssEachItem;
			}
			
			CSortClass csc(this, m_aCombinedSortedColumns[i] );	
			csc.Sort( ssEachItem ? true : false );
			if( i == iNumCombinedSortedCols - 1 )
			{	//Only swap the last column's sort order.
				m_headerctrl.SetSortImage( m_aCombinedSortedColumns[i], ssEachItem ? true : false );
				SetItemSortState( m_aCombinedSortedColumns[i] , (SORT_STATE)!ssEachItem );			
			}
		}
	}
	else
	{
		m_headerctrl.RemoveAllSortImages();
		EmptyArray(m_aCombinedSortedColumns);
		m_aCombinedSortedColumns[ 0 ] = iSubItem;
		SORT_STATE ssEachItem = GetItemSortState( iSubItem );
		
		CSortClass csc(this, iSubItem );	
		csc.Sort( ssEachItem ? true : false );
		m_headerctrl.SetSortImage( iSubItem, ssEachItem ? true : false );
		SetItemSortState( iSubItem , (SORT_STATE)!ssEachItem );
	}
	m_bSorting = false;
}

const int CHMList::GetNumCombinedSortedColumns() const
{
	for( int i = 0; i < MAX_COLUMNS; i++ )
	{
		if( m_aCombinedSortedColumns[i] == -1 )
		{
			return i;
		}
	}
	return MAX_COLUMNS;
}

bool CHMList::NotInCombinedSortedColumnList(int iItem) const
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	for( int i = 0; i < iNumCombinedSortedColumns; i++ )
	{
		if( m_aCombinedSortedColumns[i] == iItem )
		{
			return false;
		}
	}
	return true;
}

void CHMList::MoveItemInCombinedSortedListToEnd(int iItem)
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	int aCombinedSortedColumns[MAX_COLUMNS];
	memset( aCombinedSortedColumns, -1, MAX_COLUMNS );
	int iItemIndex = FindItemInCombedSortedList( iItem );
	if( iItemIndex != -1 )
	{
		if( iItemIndex > 0 )
		{
			memcpy( aCombinedSortedColumns, m_aCombinedSortedColumns, iItemIndex * sizeof( int ) );
			memcpy( &aCombinedSortedColumns[iItemIndex], &m_aCombinedSortedColumns[iItemIndex + 1], (iNumCombinedSortedColumns - iItemIndex - 1) * sizeof(int) );
		}
	}
	aCombinedSortedColumns[ iNumCombinedSortedColumns - 1 ] = iItem;
	memcpy( m_aCombinedSortedColumns, aCombinedSortedColumns, MAX_COLUMNS * sizeof(int) );
	for( int i = 0; i < MAX_COLUMNS ; i++ )
	{
		if( aCombinedSortedColumns[i] == -1 )
			break;
	}
}

const SORT_STATE CHMList::GetItemSortState( int iItem ) const
{
	return (SORT_STATE)((m_lColumnSortStates) & ( 1 << iItem ));
}

void CHMList::SetItemSortState(int iItem, SORT_STATE bSortState)
{
	if( bSortState != GetItemSortState( iItem ) )
	{
		m_lColumnSortStates ^= (1 << iItem);
	}
}

void CHMList::EmptyArray( int *pArray )
{
	memset( pArray, -1, MAX_COLUMNS );
}

const bool CHMList::IsColumnNumeric( int iCol ) const
{
	for( int i = 0; i < m_aNumericColumns.GetSize(); i++ )
	{	
		if( m_aNumericColumns.GetAt( i ) == (UINT)iCol )
		{
			return true;
		}
	}
	return false;
}

int CHMList::FindItemInCombedSortedList( int iItem )
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	for( int i = 0; i < iNumCombinedSortedColumns; i++ )
	{
		if(m_aCombinedSortedColumns[i] == iItem )
		{
			return i;
		}
	}
	return -1;
}

const int CHMList::IsControlPressed() const
{
	return (::GetKeyState( VK_SHIFT ) < 0 );
}

BEGIN_MESSAGE_MAP(CHMList, CListCtrl)
	//{{AFX_MSG_MAP(CHMList)
	ON_WM_CREATE()
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMList message handlers

BOOL CHMList::PreCreateWindow(CREATESTRUCT& cs) 
{
	cs.style = cs.style|LVS_EDITLABELS|LVS_REPORT;
	cs.lpszClass = _T("SysListView32");	
	
	return CListCtrl::PreCreateWindow(cs);
}

int CHMList::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_headerctrl.SubclassWindow( GetHeaderCtrl()->GetSafeHwnd() );
		
	return 0;
}

void CHMList::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	// Handle right click on the header control
	if( pWnd->GetSafeHwnd() == GetHeaderCtrl()->GetSafeHwnd() )
	{

		CMenu listcontextmenu;
		listcontextmenu.CreatePopupMenu();

/*		menu.LoadMenu(IDR_MENU_HEADER_CONTEXT);
		CMenu& listcontextmenu = *menu.GetSubMenu(0);

		CHeaderCtrl* pHdrCtrl = GetHeaderCtrl();
		DWORD dwStyle = GetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE);

		if( dwStyle & HDS_FILTERBAR )
		{
			listcontextmenu.CheckMenuItem(ID_HEADERCONTEXT_FILTERBAR,MF_BYCOMMAND|MF_CHECKED);
		}
*/
		int iCol = 0;
		TCHAR szName[255];
		LVCOLUMN lvc;
		ZeroMemory(&lvc,sizeof(LVCOLUMN));
		lvc.mask = LVCF_TEXT|LVCF_WIDTH;
		lvc.pszText = szName;
		lvc.cchTextMax = 255;

		while( GetColumn(iCol,&lvc) )
		{
			if( lvc.cx > 0 )
			{
				listcontextmenu.AppendMenu(MF_CHECKED|MF_STRING,_IDM_HEADER_CONTEXTMENU_BASE+iCol,lvc.pszText);
			}
			else
			{
				listcontextmenu.AppendMenu(MF_UNCHECKED|MF_STRING,_IDM_HEADER_CONTEXTMENU_BASE+iCol,lvc.pszText);
			}
			iCol++;
		}

		listcontextmenu.TrackPopupMenu(TPM_LEFTALIGN,point.x,point.y,this);

		listcontextmenu.DestroyMenu();
	}	
}

void CHMList::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	if( IsControlPressed() )
	{
		SortColumn( pNMListView->iSubItem, MULTI_COLUMN_SORT );
	}
	else
	{
		SortColumn( pNMListView->iSubItem, SINGLE_COLUMN_SORT );
	}

	*pResult = 0;

}

void CHMList::OnDestroy() 
{
	CListCtrl::OnDestroy();
}

BOOL CHMList::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	WORD wID = LOWORD(wParam);

	if( wID >= _IDM_HEADER_CONTEXTMENU_BASE )
	{
		TCHAR szName[255];
		int iCol = wID - _IDM_HEADER_CONTEXTMENU_BASE;
		LVCOLUMN lvc;
		ZeroMemory(&lvc,sizeof(LVCOLUMN));
		lvc.mask = LVCF_TEXT|LVCF_WIDTH;
		lvc.cx = 0;
		lvc.pszText = szName;
		lvc.cchTextMax = 255;
		GetColumn(iCol,&lvc);
		if( lvc.cx == 0 )
		{
			CDC dc;
			dc.Attach(::GetDC(NULL));
		
			// get the width in pixels of the item
			CSize size  = dc.GetTextExtent(lvc.pszText);
			lvc.cx = size.cx + 50;
			
			HDC hDC = dc.Detach();
			::ReleaseDC(NULL,hDC);
		}
		else
		{
			lvc.cx = 0;
		}
		SetColumn(iCol,&lvc);
	}
		
	return CListCtrl::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistview.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "hmlistview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// _DHMListView properties

CString _DHMListView::GetTitle()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void _DHMListView::SetTitle(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

CString _DHMListView::GetDescription()
{
	CString result;
	GetProperty(0x2, VT_BSTR, (void*)&result);
	return result;
}

void _DHMListView::SetDescription(LPCTSTR propVal)
{
	SetProperty(0x2, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// _DHMListView operations

void _DHMListView::SetProgressRange(long lLowerBound, long lUpperBound)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lLowerBound, lUpperBound);
}

long _DHMListView::GetProgressPos()
{
	long result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void _DHMListView::SetProgressPos(long lPos)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lPos);
}

long _DHMListView::InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lState, long lStateMask, long lImage, long lParam)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lMask, lItem, lpszItem, lState, lStateMask, lImage, lParam);
	return result;
}

long _DHMListView::InsertColumn(long lColumn, LPCTSTR lpszColumnHeading, long lFormat, long lWidth, long lSubItem)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lColumn, lpszColumnHeading, lFormat, lWidth, lSubItem);
	return result;
}

long _DHMListView::SetItem(long lItem, long lSubItem, long lMask, LPCTSTR lpszItem, long lImage, long lState, long lStateMask, long lParam)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lItem, lSubItem, lMask, lpszItem, lImage, lState, lStateMask, lParam);
	return result;
}

long _DHMListView::GetStringWidth(LPCTSTR lpsz)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpsz);
	return result;
}

long _DHMListView::GetColumnWidth(long lCol)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCol);
	return result;
}

BOOL _DHMListView::SetColumnWidth(long lCol, long lcx)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lCol, lcx);
	return result;
}

long _DHMListView::FindItemByLParam(long lParam)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lParam);
	return result;
}

long _DHMListView::GetImageList(long lImageListType)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lImageListType);
	return result;
}

BOOL _DHMListView::DeleteAllItems()
{
	BOOL result;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL _DHMListView::DeleteColumn(long lCol)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lCol);
	return result;
}

long _DHMListView::StepProgressBar()
{
	long result;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long _DHMListView::SetProgressStep(long lStep)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lStep);
	return result;
}

long _DHMListView::SetImageList(long hImageList, long lImageListType)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		hImageList, lImageListType);
	return result;
}

long _DHMListView::GetNextItem(long lItem, long lFlags)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lItem, lFlags);
	return result;
}

long _DHMListView::GetItem(long lItemIndex)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lItemIndex);
	return result;
}

BOOL _DHMListView::DeleteItem(long lIndex)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lIndex);
	return result;
}

long _DHMListView::GetItemCount()
{
	long result;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL _DHMListView::ModifyListStyle(long lRemove, long lAdd, long lFlags)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_I4;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lRemove, lAdd, lFlags);
	return result;
}

long _DHMListView::GetColumnCount()
{
	long result;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long _DHMListView::GetColumnOrderIndex(long lColumn)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lColumn);
	return result;
}

long _DHMListView::SetColumnOrderIndex(long lColumn, long lOrder)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lColumn, lOrder);
	return result;
}

CString _DHMListView::GetColumnOrder()
{
	CString result;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void _DHMListView::SetColumnOrder(LPCTSTR lpszOrder)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszOrder);
}

void _DHMListView::SetColumnFilter(long lColumn, LPCTSTR lpszFilter, long lFilterType)
{
	static BYTE parms[] =
		VTS_I4 VTS_BSTR VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lColumn, lpszFilter, lFilterType);
}

void _DHMListView::GetColumnFilter(long lColumn, BSTR* lplpszFilter, long* lpFilterType)
{
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR VTS_PI4;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lColumn, lplpszFilter, lpFilterType);
}

long _DHMListView::GetSelectedCount()
{
	long result;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void _DHMListView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistviewcolumn.cpp ===
// HMListViewColumn.cpp: implementation of the CHMListViewColumn class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMListViewColumn.h"
#include "HealthmonResultsPane.h"
#include "HMScopeItem.h"
#include "ResultsPaneView.h"
#include "HMObject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMListViewColumn,CListViewColumn)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMListViewColumn::CHMListViewColumn()
{
	m_Pane = Uninitialized;
}

CHMListViewColumn::~CHMListViewColumn()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Column Members
//////////////////////////////////////////////////////////////////////

bool CHMListViewColumn::InsertColumn(CResultsPane* pResultsPane, int iColumnIndex)
{
	TRACEX(_T("CHMListViewColumn::InsertColumn"));
	TRACEARGn(pResultsPane);
	TRACEARGn(iColumnIndex);

	if( ! GfxCheckObjPtr(pResultsPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pResultsPane is not a valid pointer.\n"));
		return false;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pResultsPane;

	_DHMListView* pList = NULL;
	if( IsUpperPane() )
	{
		pList = pHMRP->GetUpperListCtrl();
	}
	else if( IsLowerPane() )
	{
		pList = pHMRP->GetLowerListCtrl();
	}
	else if( IsStatsPane() )
	{
		pList = pHMRP->GetStatsListCtrl();
	}
	else
	{
		TRACE(_T("WARNING : Column has not been assigned to a results pane in the split view.\n"));
		ASSERT(FALSE);
	}

	if( ! pList )
	{
		TRACE(_T("FAILED : Results Pane's list control has not been intialized.\n"));
		return false;		
	}

	CResultsPaneView* pView = GetOwnerResultsView();
	if( pView )
	{
		CHMScopeItem* pItem = (CHMScopeItem*)pView->GetOwnerScopeItem();
		if( GfxCheckObjPtr(pItem,CHMScopeItem) )
		{
			CHMObject* pObject = pItem->GetObjectPtr();
			if( pObject )
			{
				CRuntimeClass* pRTC = pObject->GetRuntimeClass();
				if( pRTC )
				{
					USES_CONVERSION;
					CString sEntry;
					sEntry.Format(_T("ColumnWidth_%d_%d"),m_Pane,pList->GetColumnCount());
					m_iWidth = AfxGetApp()->GetProfileInt(A2T(pRTC->m_lpszClassName),sEntry,m_iWidth);
					if( m_iWidth > 2500 || m_iWidth < 0 )
					{
						m_iWidth = 125;
					}
				}
			}
		}
	}

	int iResult = pList->InsertColumn(pList->GetColumnCount(),(LPCTSTR)GetTitle(),GetFormat(),GetWidth(),-1L);
	if( iResult == -1 )
	{
		TRACE(_T("FAILED : CListCtrl::InsertColumn failed.\n"));
		return false;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Width Members

void CHMListViewColumn::SaveWidth(CResultsPane* pResultsPane, int iColumnIndex)
{
	TRACEX(_T("CListViewColumn::SaveWidth\n"));	
	TRACEARGn(pResultsPane);
	TRACEARGn(iColumnIndex);

	if( ! GfxCheckObjPtr(pResultsPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pResultsPane is not a valid pointer.\n"));
		return;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pResultsPane;

	_DHMListView* pList = NULL;
	if( IsUpperPane() )
	{
		pList = pHMRP->GetUpperListCtrl();
	}
	else if( IsLowerPane() )
	{
		pList = pHMRP->GetLowerListCtrl();
	}
	else if( IsStatsPane() )
	{
		pList = pHMRP->GetStatsListCtrl();
	}
	else
	{
		TRACE(_T("WARNING : Column has not been assigned to a results pane in the split view.\n"));
		ASSERT(FALSE);
	}

	if( ! pList )
	{
		TRACE(_T("FAILED : Results Pane's list control has not been intialized.\n"));
		return;		
	}

	m_iWidth = pList->GetColumnWidth(iColumnIndex);

	CResultsPaneView* pView = GetOwnerResultsView();
	if( ! pView )
	{
		return;
	}

	CHMScopeItem* pItem = (CHMScopeItem*)pView->GetOwnerScopeItem();

	if( ! GfxCheckObjPtr(pItem,CHMScopeItem) )
	{
		return;
	}

	CHMObject* pObject = pItem->GetObjectPtr();
	if( ! pObject )
	{
		return;
	}

	CRuntimeClass* pRTC = pObject->GetRuntimeClass();
	USES_CONVERSION;
	CString sEntry;
	sEntry.Format(_T("ColumnWidth_%d_%d"),m_Pane,iColumnIndex);
	AfxGetApp()->WriteProfileInt(A2T(pRTC->m_lpszClassName),sEntry,m_iWidth);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistviewcolumn.h ===
// HMListViewColumn.h: interface for the CHMListViewColumn class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMLISTVIEWCOLUMN_H__9F7B45B1_B60A_11D2_BD72_0000F87A3912__INCLUDED_)
#define AFX_HMLISTVIEWCOLUMN_H__9F7B45B1_B60A_11D2_BD72_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Constants.h"
#include "ListViewColumn.h"

class CHMListViewColumn : public CListViewColumn  
{

DECLARE_DYNCREATE(CHMListViewColumn)

// Construction/Destruction
public:
	CHMListViewColumn();
	virtual ~CHMListViewColumn();

// Column Members
public:
	virtual bool InsertColumn(CResultsPane* pResultsPane, int iColumnIndex);

// Width Members
public:
	virtual void SaveWidth(CResultsPane* pResultsPane, int iColumnIndex);

// Results Pane Location of Column - for split pane results view
public:
	bool IsUpperPane() const { return m_Pane==Upper; }
	bool IsLowerPane() const { return m_Pane==Lower; }
	bool IsStatsPane() const { return m_Pane==Stats; }
	void SetToUpperPane() { m_Pane = Upper; }
	void SetToLowerPane() { m_Pane = Lower; }
	void SetToStatsPane() { m_Pane = Stats; }
protected:
	SplitResultsPane m_Pane;

};

#endif // !defined(AFX_HMLISTVIEWCOLUMN_H__9F7B45B1_B60A_11D2_BD72_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlist.h ===
#if !defined(AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMList.h : header file
//

#include "HMHeaderCtrl.h"

#define MAX_COLUMNS	       64
#define MULTI_COLUMN_SORT  1
#define SINGLE_COLUMN_SORT 0

enum SORT_STATE{ DESCENDING=0, ASCENDING=1 };

/////////////////////////////////////////////////////////////////////////////
// CHMList window

class CHMList : public CListCtrl
{
// Construction
public:
	CHMList();

// Sorting
public:
	void SortColumn( int, bool = false );
	const int GetNumCombinedSortedColumns() const;
	bool NotInCombinedSortedColumnList( int iItem ) const;
	void MoveItemInCombinedSortedListToEnd( int );
	const SORT_STATE GetItemSortState( int ) const;
	void SetItemSortState(int iItem, SORT_STATE bSortState);
	void EmptyArray( int * );
	const bool IsColumnNumeric( int ) const;
	int FindItemInCombedSortedList( int );	
	const int IsControlPressed() const;

// Attributes
public:
  void SubclassHeaderCtrl() { m_headerctrl.SubclassWindow( GetHeaderCtrl()->GetSafeHwnd() ); }
protected:
	CHMHeaderCtrl m_headerctrl;
	__int64	      m_lColumnSortStates;
	int           m_aCombinedSortedColumns[MAX_COLUMNS];
	CUIntArray    m_aNumericColumns;
	bool					m_bSorting;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMList)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHMList();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHMList)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistview.h ===
#ifndef __HMLISTVIEW_H__
#define __HMLISTVIEW_H__
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// _DHMListView wrapper class

class _DHMListView : public COleDispatchDriver
{
public:
	_DHMListView() {}		// Calls COleDispatchDriver default constructor
	_DHMListView(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DHMListView(const _DHMListView& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetTitle();
	void SetTitle(LPCTSTR);
	CString GetDescription();
	void SetDescription(LPCTSTR);

// Operations
public:
	void SetProgressRange(long lLowerBound, long lUpperBound);
	long GetProgressPos();
	void SetProgressPos(long lPos);
	long InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lState, long lStateMask, long lImage, long lParam);
	long InsertColumn(long lColumn, LPCTSTR lpszColumnHeading, long lFormat, long lWidth, long lSubItem);
	long SetItem(long lItem, long lSubItem, long lMask, LPCTSTR lpszItem, long lImage, long lState, long lStateMask, long lParam);
	long GetStringWidth(LPCTSTR lpsz);
	long GetColumnWidth(long lCol);
	BOOL SetColumnWidth(long lCol, long lcx);
	long FindItemByLParam(long lParam);
	long GetImageList(long lImageListType);
	BOOL DeleteAllItems();
	BOOL DeleteColumn(long lCol);
	long StepProgressBar();
	long SetProgressStep(long lStep);
	long SetImageList(long hImageList, long lImageListType);
	long GetNextItem(long lItem, long lFlags);
	long GetItem(long lItemIndex);
	BOOL DeleteItem(long lIndex);
	long GetItemCount();
	BOOL ModifyListStyle(long lRemove, long lAdd, long lFlags);
	long GetColumnCount();
	long GetColumnOrderIndex(long lColumn);
	long SetColumnOrderIndex(long lColumn, long lOrder);
	CString GetColumnOrder();
	void SetColumnOrder(LPCTSTR lpszOrder);
	void SetColumnFilter(long lColumn, LPCTSTR lpszFilter, long lFilterType);
	void GetColumnFilter(long lColumn, BSTR* lplpszFilter, long* lpFilterType);
	long GetSelectedCount();
	void AboutBox();
};

#endif //__HMLISTVIEW_H__/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistvieweventsink.h ===
#if !defined(AFX_HMLISTVIEWEVENTSINK_H__85B084D1_24C7_11D3_BE04_0000F87A3912__INCLUDED_)
#define AFX_HMLISTVIEWEVENTSINK_H__85B084D1_24C7_11D3_BE04_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMListViewEventSink.h : header file
//

#include "hmlistview.h"

class CHealthmonResultsPane;

/////////////////////////////////////////////////////////////////////////////
// CHMListViewEventSink command target

class CHMListViewEventSink : public CCmdTarget
{
	DECLARE_DYNCREATE(CHMListViewEventSink)

// Construction/Destruction
public:
	CHMListViewEventSink();           // constructor used by dynamic creation
	virtual ~CHMListViewEventSink();

// Attributes
public:
	DWORD m_dwEventCookie;
	_DHMListView* m_pDHMListView;
  CHealthmonResultsPane* m_pHMRP;
  SplitResultsPane m_Pane;

// Operations
public:
	HRESULT HookUpEventSink(LPUNKNOWN lpControlUnknown);
	void OnDelete() { LONG lResult = 0L; ListKeyDown(VK_DELETE,NULL,&lResult); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMListViewEventSink)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHMListViewEventSink)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CHMListViewEventSink)
	afx_msg void ListClick(long lParam);
	afx_msg void ListDblClick(long lParam);
	afx_msg void ListRClick(long lParam);
	afx_msg void CompareItem(long lItem1, long lItem2, long lColumn, long FAR* lpResult);
	afx_msg void ListLabelEdit(LPCTSTR lpszNewName, long lParam, long FAR* plResult);
	afx_msg void ListKeyDown(long lVKCode, long lFlags, long FAR* plResult);
	afx_msg void FilterChange(long lItem, LPCTSTR pszFilter, long lFilterType, long FAR* lpResult);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLISTVIEWEVENTSINK_H__85B084D1_24C7_11D3_BE04_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmobject.cpp ===
// HMObject.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HMObject.h"
#include "EventManager.h"
#include "System.h"

#include "ActionPolicy.h"  // 59492b

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// static members for refreshing the events
int CHMObject::m_iRefreshType = 0;
int CHMObject::m_iEventCount = 50;
int CHMObject::m_iTimeValue = 1;
TimeUnit CHMObject::m_Units = Hours;

/////////////////////////////////////////////////////////////////////////////
// CHMObject

IMPLEMENT_SERIAL(CHMObject, CCmdTarget, 1)

CHMObject::CHMObject()
{
	EnableAutomation();

	m_nState = HMS_NODATA;
	m_lNameSuffix = 0L;

	SYSTEMTIME st;
	GetSystemTime(&st);

	// adjust to the local time zone
 	TIME_ZONE_INFORMATION tzi;
	SYSTEMTIME stLocal;
	GetTimeZoneInformation(&tzi);
	SystemTimeToTzSpecificLocalTime(&tzi,&st,&stLocal);	
	m_CreateDateTime = stLocal;
	m_ModifiedDateTime = stLocal;

	m_lActiveSinkCount = 0L;

	m_lNormalCount = 0;
	m_lUnknownCount = 0;
	m_lWarningCount = 0;
	m_lCriticalCount = 0;
}

CHMObject::~CHMObject()
{	
	
}

/////////////////////////////////////////////////////////////////////////////
// Event Members
/////////////////////////////////////////////////////////////////////////////

void CHMObject::AddContainer(const CString& sParentGuid, const CString& sGuid, CHMObject* pObject)
{
	if( sGuid == _T("@") )
	{
		EvtGetEventManager()->AddSystemContainer(sParentGuid,pObject->GetSystemName(),pObject);
	}
	else
	{
		if( pObject->IsKindOf(RUNTIME_CLASS(CDataElement)) )
		{
			EvtGetEventManager()->AddContainer(GetSystemName(),sParentGuid,sGuid,pObject,RUNTIME_CLASS(CDataPointEventContainer));
		}
		else
		{
			EvtGetEventManager()->AddContainer(GetSystemName(),sParentGuid,sGuid,pObject);
		}
	}	
}

void CHMObject::ClearEvents()
{
	for( int i = 0; i < GetChildCount(); i++ )
	{
		CHMObject* pChild = GetChild(i);
		if( pChild )
		{
			pChild->ClearEvents();
		}		
	}

	if( GetChildCount() == 0 )
	{

		CEventContainer* pContainer = NULL;
		EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
		if( ! pContainer )
		{
			ASSERT(FALSE);
			return;
		}
		
		// delete each event by status guid	
		CStringArray saStatusGuidsToDelete;
		for( i = 0; i < pContainer->GetEventCount(); i++ )
		{
			CEvent* pEvent = pContainer->GetEvent(i);
			saStatusGuidsToDelete.Add(pEvent->m_sStatusGuid);		
		}

		for( i = 0; i < saStatusGuidsToDelete.GetSize(); i++ )
		{
			EvtGetEventManager()->DeleteEvents(GetSystemName(),saStatusGuidsToDelete[i]);
		}
	}
}

void CHMObject::DestroyChild(int iIndex, bool bDeleteClassObject /*= false*/)
{
	TRACEX(_T("CHMObject::DestroyChild\n"));
	TRACEARGn(iIndex);
	TRACEARGn(bDeleteClassObject);
	
	CHMObject* pObject = m_Children[iIndex];

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return;
	}

	// destroy the events for the child
	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
		pContainer->SetObjectPtr(NULL);
	}

	m_Children.RemoveAt(iIndex);
	if( bDeleteClassObject )
	{
		pObject->DeleteClassObject();
	}
	for( int i = pObject->GetScopeItemCount()-1; i >= 0; i-- )
	{
		CScopePaneItem* pChild = pObject->GetScopeItem(i);
		pObject->RemoveScopeItem(i);
		if( pChild )
		{
			CScopePaneItem* pParent = pChild->GetParent();
			if( pParent )
			{
				pParent->DestroyChild(pChild);
			}
		}
		

	}		
	delete pObject;
}

void CHMObject::UpdateStatus()
{
	TRACEX(_T("CHMObject::UpdateStatus\n"));

	// set the state as appropriate
	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
	if( ! pContainer )
	{
		return;
	}

	SetState(CEvent::GetStatus(pContainer->m_iState),true);	

	m_lNormalCount = pContainer->m_iNumberNormals;
	m_lWarningCount = pContainer->m_iNumberWarnings;
	m_lCriticalCount = pContainer->m_iNumberCriticals;
	m_lUnknownCount = pContainer->m_iNumberUnknowns;

}

void CHMObject::IncrementActiveSinkCount()
{
	TRACEX(_T("CHMObject::IncrementActiveSinkCount\n"));

	m_lActiveSinkCount++;

  CHealthmonScopePane* pHMPane = (CHealthmonScopePane*)GetScopePane();
  if( ! pHMPane )
  {
    return;
  }

  CSystem* pSystem = pHMPane->GetSystem(GetSystemName());
  if( ! pSystem )
  {
    return;
  }

  pSystem->m_lTotalActiveSinkCount++;
}

void CHMObject::DecrementActiveSinkCount()
{
	TRACEX(_T("CHMObject::DecrementActiveSinkCount\n"));

	m_lActiveSinkCount--;

	if( m_lActiveSinkCount == 0L )
	{
		UpdateStatus();
	}

  CHealthmonScopePane* pHMPane = (CHealthmonScopePane*)GetScopePane();

  if( ! pHMPane )
  {
    return;
  }

  CSystem* pSystem = pHMPane->GetSystem(GetSystemName());
  if( ! pSystem )
  {
    return;
  }

  pSystem->m_lTotalActiveSinkCount--;

  if( pSystem->m_lTotalActiveSinkCount == 0 )
  {
	  EvtGetEventManager()->ActivateSystemEventListener(GetSystemName());    
  }
}

void CHMObject::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CHMObject, CCmdTarget)
	//{{AFX_MSG_MAP(CHMObject)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CHMObject, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CHMObject)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IHMObject to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4F9A-F673-11D2-BDC4-0000F87A3912}
static const IID IID_IHMObject =
{ 0xd9bf4f9a, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CHMObject, CCmdTarget)
	INTERFACE_PART(CHMObject, IID_IHMObject, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMObject message handlers

// 59492b
// This will determine whether the object is the "Actions" item in the tree control
//*********************************************************************************
// IsActionsItem
//*********************************************************************************
BOOL CHMObject::IsActionsItem()
{
    if (this->IsKindOf(RUNTIME_CLASS(CActionPolicy)))
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmobject.h ===
#if !defined(AFX_HMOBJECT_H__D9BF4F9B_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_HMOBJECT_H__D9BF4F9B_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMObject.h : header file
//

#include "HealthmonScopePane.h"
#include "ScopePaneItem.h"
#include "HMRuleStatus.h"
#include "HMScopeItem.h"
#include "HMEventResultsPaneItem.h"
#include "SplitpaneResultsView.h"
#include "WbemEventListener.h"
#include "HMGraphView.h"
#include "HMListView.h"

/////////////////////////////////////////////////////////////////////////////
// CHMObject command target

class CHMObject : public CCmdTarget
{
	DECLARE_SERIAL(CHMObject)

// Construction/Destruction
public:
	CHMObject();
	virtual ~CHMObject();

// Create/Destroy
public:
	virtual void Destroy(bool bDeleteClassObject = false);

// WMI Operations
public:
	virtual HRESULT EnumerateChildren();
	virtual CString GetObjectPath();
	virtual CString GetStatusObjectPath();
	virtual CWbemClassObject* GetClassObject();
	virtual CWbemClassObject* GetParentClassObject();	
	virtual CHMEvent* GetStatusClassObject();
	virtual void DeleteClassObject();
	void IncrementActiveSinkCount();
	void DecrementActiveSinkCount();
	virtual bool ImportMofFile(CArchive& ar);
	virtual bool ExportMofFile(CArchive& ar);
protected:
	long m_lActiveSinkCount;	

// Clipboard Operations
public:
	virtual bool Copy(CString& sParentGuid, COleSafeArray& Instances);
	virtual bool Paste(CHMObject* pObject, bool bCutOrMove);
	virtual bool QueryPaste(CHMObject* pObject);

// Operations
public:
	CString GetGuid();
	void SetGuid(const CString& sGuid);
	CString GetName();
	void SetName(const CString& sNewName);
	virtual bool Rename(const CString& sNewName);
	CString GetTypeName();
	virtual CString GetUITypeName();
	CString GetSystemName();
	void SetSystemName(const CString& sNewName);
	void ToggleStatusIcon(bool bOn = true);
	virtual bool Refresh();
	static int GetRefreshType() { return m_iRefreshType; }
	static int GetRefreshEventCount() { return m_iEventCount; }
	static void GetRefreshTimePeriod(int& iTimeValue, TimeUnit& Units) { iTimeValue = m_iTimeValue; Units = m_Units; }
	static void SetRefreshType(int iType) { m_iRefreshType = iType; }
	static void SetRefreshEventCount(int iEventCount) { m_iEventCount = iEventCount; }
	static void SetRefreshTimePeriod(int iTimeValue, TimeUnit Units) { m_iTimeValue = iTimeValue; m_Units = Units; }
	virtual bool ResetStatus();
	virtual bool ResetStatistics();
	virtual bool CheckNow();
  bool DeleteActionAssoc(const CString& sActionConfigGuid);
	int IsEnabled();
	void Enable();
	void Disable();
	CTime GetCreateDateTime();
	void GetCreateDateTime(CString& sDateTime);
	void SetCreateDateTime(const CTime& dtime);
	CTime	GetModifiedDateTime();
	void GetModifiedDateTime(CString& sDateTime);
	void SetModifiedDateTime(const CTime& dtime);
	CString GetComment();
	void SetComment(const CString& sComment);
	void UpdateComment(const CString& sComment);
	void Serialize(CArchive& ar);
protected:
	CString m_sGUID;
	CString m_sName;
	CString m_sTypeName;
	CString m_sSystemName;
	bool m_bStatusIconsOn;
	CTime m_CreateDateTime;
	CTime m_ModifiedDateTime;
	CString m_sComment;
	static int m_iRefreshType;
	static int m_iEventCount;
	static int m_iTimeValue;
	static TimeUnit m_Units;
	
// Child Members
public:
	int GetChildCount(CRuntimeClass* pClass = NULL);	
	virtual int AddChild(CHMObject* pObject);
	virtual bool CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName);
	CString GetUniqueChildName(UINT uiFmtID = IDS_STRING_UNTITLED);
	virtual CHMObject* GetChild(const CString& sName);
	CHMObject* GetChildByGuid(const CString& sGUID);
  CHMObject* GetDescendantByGuid(const CString& sGuid);
	CHMObject* GetChild(int iIndex);
	virtual void RemoveChild(CHMObject* pObject);
	void DestroyChild(int iIndex, bool bDeleteClassObject = false);
	virtual void DestroyChild(CHMObject* pObject, bool bDeleteClassObject = false);
	void DestroyAllChildren();
protected:
	CTypedPtrArray<CObArray,CHMObject*> m_Children;
	long m_lNameSuffix;

// Event Members
public:
	virtual void AddContainer(const CString& sParentGuid, const CString& sGuid, CHMObject* pObject);
	void ClearEvents();

// State Members
public:
	virtual void UpdateStatus();
	int GetState() { return m_nState; }
	void SetState(int iState, bool bUpdateScopeItems = false, bool bApplyToChildren = false);
	virtual	void TallyChildStates();
	long GetNormalCount() { return m_lNormalCount; }
	long GetWarningCount() { return m_lWarningCount; }
	long GetCriticalCount() { return m_lCriticalCount; }
	long GetUnknownCount() { return m_lUnknownCount; }
protected:
	int m_nState;
	long m_lNormalCount;
	long m_lWarningCount;
	long m_lCriticalCount;
	long m_lUnknownCount;

// Associated Scope Pane Member
public:
	CScopePane* GetScopePane();
	void SetScopePane(CScopePane* pPane);
protected:
	CScopePane* m_pPane;

// Scope Item Members
public:
	BOOL IsActionsItem();
	int GetScopeItemCount();
	CScopePaneItem* GetScopeItem(int iIndex);
	virtual int AddScopeItem(CScopePaneItem* pItem);
	virtual void RemoveScopeItem(int iIndex);
	void RemoveAllScopeItems();
	void DestroyAllScopeItems();
	virtual CScopePaneItem* CreateScopeItem() { ASSERT(FALSE); return NULL; }
	CScopePaneItem* IsSelected();
protected:
	CTypedPtrArray<CObArray,CScopePaneItem*> m_ScopeItems;
	
// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMObject)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHMObject)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CHMObject)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "HMObject.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMOBJECT_H__D9BF4F9B_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmobject.inl ===
// File : HMObject.inl
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/25/00 v-marfin 60298 Delete source object after a drag and drop MOVE
//                         operation.
// 04/05/00 v-marfin 59492b Also check for object type of CActionPolicy 
//                          in Refresh function so this type is not deleted as
//                          part of the refresh.
//
//
//
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

inline void CHMObject::Destroy(bool bDeleteClassObject /*= false*/)
{
	TRACEX(_T("CHMObject::Destroy\n"));

	if( bDeleteClassObject )
	{
		DeleteClassObject();
	}

	for( int i = 0; i < GetChildCount(); i++ )
	{
		CHMObject* pObject = GetChild(i);
		if( pObject )
		{
			pObject->Destroy(bDeleteClassObject);
			delete pObject;
			m_Children.SetAt(i,NULL);
		}
	}
	m_Children.RemoveAll();

	RemoveAllScopeItems();

	// TODO : Destroy Events
}

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CHMObject::EnumerateChildren()
{
	TRACEX(_T("CHMObject::EnumerateChildren\n"));
	
//	ASSERT(FALSE);

	return E_FAIL;
}

inline CString CHMObject::GetObjectPath()
{
	TRACEX(_T("CHMObject::GetObjectPath\n"));

	return _T("");
}

inline CString CHMObject::GetStatusObjectPath()
{
	TRACEX(_T("CHMObject::GetStatusObjectPath\n"));

	return _T("");
}

inline CWbemClassObject* CHMObject::GetClassObject()
{
	TRACEX(_T("CHMObject::GetClassObject\n"));

	CWbemClassObject* pClassObject = new CWbemClassObject;

	if( ! CHECKHRESULT(pClassObject->Create(GetSystemName())) )
	{
		delete pClassObject;
		return NULL;
	}

	if( ! CHECKHRESULT(pClassObject->GetObject(GetObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	return pClassObject;
}

inline CWbemClassObject* CHMObject::GetParentClassObject()
{
	TRACEX(_T("CHMObject::GetParentClassObject\n"));

	return NULL;
}

inline CHMEvent* CHMObject::GetStatusClassObject()
{
	TRACEX(_T("CHMObject::GetStatusClassObject\n"));

	CHMEvent* pClassObject = new CHMEvent;

	pClassObject->SetMachineName(GetSystemName());

	if( ! CHECKHRESULT(pClassObject->GetObject(GetStatusObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	return pClassObject;
}

inline void CHMObject::DeleteClassObject()
{
	TRACEX(_T("CHMObject::DeleteClassObject\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return;
	}

	CWbemClassObject HMSystemConfig;
	HMSystemConfig.Create(GetSystemName());

	if( ! CHECKHRESULT(HMSystemConfig.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG)) )
	{
		return;
	}

	int iResult = 0;
	CString sArgValue;
	sArgValue.Format(_T("{%s}"),GetGuid());
	if( ! CHECKHRESULT(HMSystemConfig.ExecuteMethod(_T("Delete"),_T("TargetGUID"),sArgValue,iResult)) )
	{
		return;
	}
}

inline bool CHMObject::ImportMofFile(CArchive& ar)
{
	TRACEX(_T("CHMObject::ImportMofFile\n"));

	ASSERT(ar.IsLoading());

	return true;
}

inline bool CHMObject::ExportMofFile(CArchive& ar)
{
	TRACEX(_T("CHMObject::ExportMofFile\n"));

	ASSERT(ar.IsStoring());

	CString sText;

	CWbemClassObject* pClassObject = GetClassObject();

	pClassObject->GetObjectText(sText);

	USES_CONVERSION;
	char* pszAnsiText = T2A(sText);

	ar.Write(pszAnsiText,strlen(pszAnsiText)+sizeof(char));

/*
	for( int i = 0; i < GetChildCount(); i++ )
	{
		CHMObject* pObject = GetChild(i);
		if( pObject )
		{
			pObject->ExportMofFile(ar);
		}
	}
*/
	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CHMObject::Copy(CString& sParentGuid, COleSafeArray& Instances)
{
	TRACEX(_T("CHMObject::Copy\n"));

	CWbemClassObject SystemConfigObject;

	SystemConfigObject.Create(GetSystemName());

	HRESULT hr = SystemConfigObject.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG);
	if( ! CHECKHRESULT(hr) )
	{
		return false;
	}
	
	CWbemClassObject CopyMethodIn;
	CWbemClassObject CopyMethodOut;
	hr = SystemConfigObject.GetMethod(_T("Copy"),CopyMethodIn);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

	CString sGuid = _T("{") + GetGuid() + _T("}");
	CopyMethodIn.SetProperty(_T("TargetGUID"),sGuid);	

	hr = SystemConfigObject.ExecuteMethod(_T("Copy"),CopyMethodIn,CopyMethodOut);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

	CopyMethodOut.GetProperty(_T("OriginalParentGuid"),sParentGuid);
	CopyMethodOut.GetProperty(_T("Instances"),Instances);

	return true;
}

// Move operations result in bIsOperationCopy = 0
// Copy operations result in bIsOperationCopy = 1
inline bool CHMObject::Paste(CHMObject* pObject, bool bIsOperationCopy)  
{
	TRACEX(_T("CHMObject::Paste\n"));
	TRACEARGn(pObject);
	TRACEARGn(bIsOperationCopy);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return false;
	}
	
	COleSafeArray Instances;
	CString sParentGuid;

	if( ! pObject->Copy(sParentGuid,Instances) )
	{
		return false;
	}
	
	CWbemClassObject SystemConfigObject;

	SystemConfigObject.Create(GetSystemName());

	HRESULT hr = SystemConfigObject.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG);
	if( ! CHECKHRESULT(hr) )
	{
		return false;
	}
	
	CWbemClassObject PasteMethodIn;
	CWbemClassObject PasteMethodOut;
	hr = SystemConfigObject.GetMethod(_T("Paste"),PasteMethodIn);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

	CString sGuid;
	if( GetGuid() == _T("@") )
		sGuid = GetGuid();
	else
		sGuid = _T("{") + GetGuid() + _T("}");
	PasteMethodIn.SetProperty(_T("TargetGUID"),sGuid);	
	PasteMethodIn.SetProperty(_T("ForceReplace"),false);
	PasteMethodIn.SetProperty(_T("OriginalSystem"),pObject->GetSystemName());
	PasteMethodIn.SetProperty(_T("OriginalParentGuid"),sParentGuid);
	PasteMethodIn.SetProperty(_T("Instances"),Instances);

	hr = SystemConfigObject.ExecuteMethod(_T("Paste"),PasteMethodIn,PasteMethodOut);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

// v-marfin : 60298 -----------------------------------------
	// If this is a move operation, delete the source object.
	// RemoveScopeItem instead?
	if (!bIsOperationCopy)
	{
		// Call the scope item's OnDelete() function which will do the 
		// necessary cleanup etc.
		CHMScopeItem* pItem = (CHMScopeItem*)pObject->GetScopeItem(0);
		pItem->OnDelete(FALSE); // FALSE = skip the confirmation prompt
	}
//-----------------------------------------------------------

	Refresh();

	return true;
}

inline bool CHMObject::QueryPaste(CHMObject* pObject)
{
	TRACEX(_T("CHMObject::GetGuid\n"));
	TRACEARGn(pObject);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return false;
	}

	CString sTargetClass = GetRuntimeClass()->m_lpszClassName;
	CString sSourceClass = pObject->GetRuntimeClass()->m_lpszClassName;
	if( sTargetClass == _T("CSystemGroup") )
	{
		if( sSourceClass != _T("CSystem") )
		{
			return false;
		}
	}
	else if( sTargetClass == _T("CSystem") )
	{
		if( sSourceClass == _T("CSystem") || sSourceClass == _T("CSystemGroup") )
		{
			return false;
		}
	}
	else if( sTargetClass == _T("CDataGroup") )
	{
		if( sSourceClass == _T("CSystem") || sSourceClass == _T("CSystemGroup") )
		{
			return false;
		}
	}
	else if( sTargetClass == _T("CDataElement") )
	{
		if( sSourceClass != _T("CRule") )
		{
			return false;
		}
	}
	else if( sTargetClass == _T("CRule") )
	{
		return false;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline CString CHMObject::GetGuid()
{
	TRACEX(_T("CHMObject::GetGuid\n"));

	return m_sGUID;
}

inline void CHMObject::SetGuid(const CString& sGuid)
{
	TRACEX(_T("CHMObject::SetGuid\n"));
	TRACEARGs(m_sGUID);

	m_sGUID = sGuid;

	if( m_sGUID[0] == _T('{') )
	{
		m_sGUID.TrimLeft(_T('{'));
		m_sGUID.TrimRight(_T('}'));
	}
}

inline CString CHMObject::GetName()
{
	TRACEX(_T("CHMObject::GetName\n"));

	return m_sName;
}

inline void CHMObject::SetName(const CString& sNewName)
{
	TRACEX(_T("CHMObject::SetName\n"));
	TRACEARGs(sNewName);

	m_sName = sNewName;
}

inline bool CHMObject::Rename(const CString& sNewName)
{
	TRACEX(_T("CHMObject::Rename\n"));
	TRACEARGs(sNewName);

	if( ! GetScopeItemCount() )
	{
		return false;
	}

	// rename the WMI instance...if this object has one
	if( GetObjectPath().IsEmpty() ) // no object path, so just rename the scope items and the object
	{
		CHMScopeItem* pParentItem = (CHMScopeItem*)GetScopeItem(0)->GetParent();

		if( pParentItem )
		{
			CHMObject* pParentObject = pParentItem->GetObjectPtr();
			if( pParentObject )
			{
				if( pParentObject->GetChild(sNewName) )
				{
					return false;
				}
			}
		}

		m_sName = sNewName;

		for(int i = 0; i < m_ScopeItems.GetSize(); i++)
		{
			m_ScopeItems[i]->SetDisplayName(0,m_sName);
			m_ScopeItems[i]->SetItem();
		}
		return true;
	}

	CWbemClassObject WmiInstance;

	if( ! CHECKHRESULT(WmiInstance.Create(GetSystemName())) )
	{
		return false;
	}

	if( ! CHECKHRESULT(WmiInstance.GetObject(GetObjectPath())) )
	{
		return false;
	}

	CHMScopeItem* pParentItem = (CHMScopeItem*)GetScopeItem(0)->GetParent();

	if( pParentItem )
	{
		CHMObject* pParentObject = pParentItem->GetObjectPtr();
		if( pParentObject )
		{
			if( pParentObject->GetChild(sNewName) )
			{
				return false;
			}
		}
	}

	WmiInstance.SetProperty(IDS_STRING_MOF_NAME,sNewName);

	if( ! CHECKHRESULT(WmiInstance.SaveAllProperties()) )
	{
		return false;
	}

	m_sName = sNewName;

	for(int i = 0; i < m_ScopeItems.GetSize(); i++)
	{
		m_ScopeItems[i]->SetDisplayName(0,m_sName);
		m_ScopeItems[i]->SetItem();
	}

	return true;
}

inline CString CHMObject::GetTypeName()
{
	TRACEX(_T("CHMObject::GetTypeName\n"));

	return m_sTypeName;	
}

inline CString CHMObject::GetUITypeName()
{
	TRACEX(_T("CHMObject::GetUITypeName\n"));

	return _T("");
}

inline CString CHMObject::GetSystemName()
{
	TRACEX(_T("CHMObject::GetSystemName\n"));

	return m_sSystemName;
}

inline void CHMObject::SetSystemName(const CString& sNewSystemName)
{
	TRACEX(_T("CHMObject::SetSystemName\n"));
	TRACEARGs(sNewSystemName);

	m_sSystemName = sNewSystemName;
}

inline void CHMObject::ToggleStatusIcon(bool bOn /*= true*/)
{
	TRACEX(_T("CHMObject::ToggleStatusIcon\n"));
	TRACEARGn(m_bStatusIconsOn);

	m_bStatusIconsOn = bOn;

	for(int i = 0; i < m_ScopeItems.GetSize(); i++)
	{
		// turn status icons on/off
	}
}

inline bool CHMObject::Refresh()
{
	TRACEX(_T("CHMObject::Refresh\n"));	

	for( int i = GetChildCount()-1; i >= 0; i-- )
	{
		CHMObject* pChildObject = GetChild(i);

        // v-marfin 59492b : Also check to see if object is a CActionPolicy ("Actions")
        //                   item since we added an object path to it before so that
        //                   handling of individual action states would work.
		if( pChildObject && 
            !pChildObject->GetObjectPath().IsEmpty() &&
            !pChildObject->IsActionsItem())  // 59492b 
		{
			pChildObject->DestroyAllChildren();
			DestroyChild(i);
		}
		else
		{
			pChildObject->Refresh();
		}
	}

	EnumerateChildren();
	UpdateStatus();

	return true;
}

inline bool CHMObject::ResetStatus()
{
	TRACEX(_T("CHMObject::ResetStatus\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return false;
	}

	CWbemClassObject HMSystemConfig;
	HMSystemConfig.Create(GetSystemName());

	if( ! CHECKHRESULT(HMSystemConfig.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG)) )
	{
		return false;
	}

	int iResult = 0;
	CString sArgValue;
	if( GetGuid() == _T("@") )
		sArgValue.Format(_T("%s"),GetGuid());
	else
		sArgValue.Format(_T("{%s}"),GetGuid());
	if( ! CHECKHRESULT(HMSystemConfig.ExecuteMethod(_T("ResetDataCollectorState"),_T("TargetGUID"),sArgValue,iResult)) )
	{
		return false;
	}

	return true;
}

inline bool CHMObject::ResetStatistics()
{
	TRACEX(_T("CHMObject::ResetStatistics\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return false;
	}

	CWbemClassObject HMSystemConfig;
	HMSystemConfig.Create(GetSystemName());

	if( ! CHECKHRESULT(HMSystemConfig.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG)) )
	{
		return false;
	}

	int iResult = 0;
	CString sArgValue;
	if( GetGuid() == _T("@") )
		sArgValue.Format(_T("%s"),GetGuid());
	else
		sArgValue.Format(_T("{%s}"),GetGuid());
	if( ! CHECKHRESULT(HMSystemConfig.ExecuteMethod(_T("ResetDataCollectorStatistics"),_T("TargetGUID"),sArgValue,iResult)) )
	{
		return false;
	}

	return true;
}

inline bool CHMObject::CheckNow()
{
	TRACEX(_T("CHMObject::ResetStatistics\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return false;
	}

	CWbemClassObject HMSystemConfig;
	HMSystemConfig.Create(GetSystemName());

	if( ! CHECKHRESULT(HMSystemConfig.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG)) )
	{
		return false;
	}

	int iResult = 0;
	CString sArgValue;
	if( GetGuid() == _T("@") )
		sArgValue.Format(_T("%s"),GetGuid());
	else
		sArgValue.Format(_T("{%s}"),GetGuid());
	if( ! CHECKHRESULT(HMSystemConfig.ExecuteMethod(_T("EvaluateDataCollectorNow"),_T("TargetGUID"),sArgValue,iResult)) )
	{
		return false;
	}

	return true;
}

inline bool CHMObject::DeleteActionAssoc(const CString& sActionConfigGuid)
{
	CWbemClassObject SystemConfigObject;

	SystemConfigObject.Create(GetSystemName());

	HRESULT hr = SystemConfigObject.GetObject(IDS_STRING_MOF_SYSTEM_CONFIG);
	if( ! CHECKHRESULT(hr) )
	{
		return false;
	}

	CWbemClassObject MethodIn;
	CWbemClassObject MethodOut;
	hr = SystemConfigObject.GetMethod(_T("DeleteConfigurationActionAssociation"),MethodIn);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

	CString sGuid = _T("{") + GetGuid() + _T("}");
  MethodIn.SetProperty(_T("TargetGUID"),sGuid);	
	MethodIn.SetProperty(_T("ActionGUID"),sActionConfigGuid);	
  

	hr = SystemConfigObject.ExecuteMethod(_T("DeleteConfigurationActionAssociation"),MethodIn,MethodOut);
	if( ! CHECKHRESULT(hr) )
	{
		CnxDisplayErrorMsgBox(hr,GetSystemName());
		return false;
	}

  return true;
}

inline int CHMObject::IsEnabled()
{
	TRACEX(_T("CHMObject::IsEnabled\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return false;
	}

	return( GetState() != HMS_DISABLED );
}

inline void CHMObject::Enable()
{
	TRACEX(_T("CHMObject::Enable\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return;
	}

	CWbemClassObject* pClassObject = GetClassObject();
	if( ! pClassObject )
	{
		return;
	}

	bool bEnabled = true;
	HRESULT hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	pClassObject->SaveAllProperties();
	delete pClassObject;

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : CWbemClassObject::SetProperty failed.\n"));
	}
}

inline void CHMObject::Disable()
{
	TRACEX(_T("CHMObject::Disable\n"));

	if( GetObjectPath().IsEmpty() ) // check if there is a WMI class associated to this object
	{
		return;
	}

	CWbemClassObject* pClassObject = GetClassObject();
	if( ! pClassObject )
	{
		return;
	}

	bool bEnabled = false;
	HRESULT hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	pClassObject->SaveAllProperties();
	delete pClassObject;

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : CWbemClassObject::SetProperty failed.\n"));
	}
}

inline CTime CHMObject::GetCreateDateTime()
{
	TRACEX(_T("CHMObject::GetCreateDateTime\n"));

	return m_CreateDateTime;
}

inline void CHMObject::GetCreateDateTime(CString& sDateTime)
{
	TRACEX(_T("CHMObject::GetCreateDateTime\n"));
	TRACEARGs(sDateTime);

	SYSTEMTIME st;

	m_CreateDateTime.GetAsSystemTime(st);

	CString sTime;
	CString sDate;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	sDateTime = sDate + _T("  ") + sTime;
}

inline void CHMObject::SetCreateDateTime(const CTime& dtime)
{
	TRACEX(_T("CHMObject::SetCreateDateTime\n"));
	
	m_CreateDateTime = dtime;
}

inline CTime CHMObject::GetModifiedDateTime()
{
	TRACEX(_T("CHMObject::GetModifiedDateTime\n"));

	return m_ModifiedDateTime;
}

inline void CHMObject::GetModifiedDateTime(CString& sDateTime)
{
	TRACEX(_T("CHMObject::GetModifiedDateTime\n"));
	TRACEARGs(sDateTime);

	SYSTEMTIME st;

	m_ModifiedDateTime.GetAsSystemTime(st);

	CString sTime;
	CString sDate;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	sDateTime = sDate + _T("  ") + sTime;
}

inline void CHMObject::SetModifiedDateTime(const CTime& dtime)
{
	TRACEX(_T("CHMObject::SetModifiedDateTime\n"));

	m_ModifiedDateTime = dtime;
}

inline CString CHMObject::GetComment()
{
	TRACEX(_T("CHMObject::GetComment\n"));

	return m_sComment;
}

inline void CHMObject::SetComment(const CString& sComment)
{
	TRACEX(_T("CHMObject::SetComment\n"));

	m_sComment = sComment;
}

inline void CHMObject::UpdateComment(const CString& sComment)
{
	TRACEX(_T("CHMObject::UpdateComment\n"));

	SetComment(sComment);

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CStringArray& saNames = GetScopeItem(i)->GetDisplayNames();
		if( saNames.GetSize() > 1 )
		{
			GetScopeItem(i)->SetDisplayName((int)saNames.GetUpperBound(),sComment);
			GetScopeItem(i)->SetItem();
		}
	}

	// update the comment for the WMI instance...if this object has one
	if( GetObjectPath().IsEmpty() ) // no object path, so just return
	{
		return;
	}


	CWbemClassObject* pClassObject = GetClassObject();
	if( pClassObject )
	{
		pClassObject->SetProperty(IDS_STRING_MOF_DESCRIPTION,m_sComment);
		pClassObject->SaveAllProperties();
		delete pClassObject;
	}
}

inline void CHMObject::Serialize(CArchive& ar)
{
	TRACEX(_T("CHMObject::Serialize\n"));
	
	CCmdTarget::Serialize(ar);

	if( ar.IsStoring() )
	{
		ar << GetName();
	}
	else
	{
		CString sName;
		ar >> sName;
		SetName(sName);
	}
}
	
/////////////////////////////////////////////////////////////////////////////
// Child Members
/////////////////////////////////////////////////////////////////////////////

inline int CHMObject::GetChildCount(CRuntimeClass* pClass /*=NULL*/)
{
	TRACEX(_T("CHMObject::GetChildCount\n"));
	TRACEARGn(pClass);

	if( ! pClass )
	{
		return (int)m_Children.GetSize();
	}

	int iCount = 0;
	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i]->IsKindOf(pClass) )
		{
			iCount++;
		}
	}

	return iCount;
}

inline int CHMObject::AddChild(CHMObject* pObject)
{
	TRACEX(_T("CHMObject::AddChild\n"));
	TRACEARGn(pObject);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		TRACE(_T("FAILED : pObject is not a valid pointer.\n"));
		return -1;
	}

	int iIndex = (int)m_Children.Add(pObject);

	pObject->SetScopePane(GetScopePane());

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CScopePaneItem* pItem = pObject->CreateScopeItem();

		if( ! pItem->Create(m_pPane,GetScopeItem(i)) )
		{
			ASSERT(FALSE);
			delete pItem;
			return -1;
		}

		pItem->SetIconIndex(pObject->GetState());
		pItem->SetOpenIconIndex(pObject->GetState());
		
		pItem->SetDisplayName(0,pObject->GetName());

		if( GfxCheckObjPtr(pItem,CHMScopeItem) )
		{
			((CHMScopeItem*)pItem)->SetObjectPtr(pObject);
		}
	
		int iIndex = GetScopeItem(i)->AddChild(pItem);		
		pItem->InsertItem(iIndex);
		pObject->AddScopeItem(pItem);

	}

	AddContainer(GetGuid(),pObject->GetGuid(),pObject);
	pObject->UpdateStatus();

	return iIndex;
}

inline bool CHMObject::CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName)
{
	TRACEX(_T("CHMObject::CreateChild\n"));
	TRACEARGn(pObject);
	TRACEARGs(sWMIClassName);
	TRACEARGs(sWMIAssociatorClassName);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return false;
	}

	pObject->SetSystemName(GetSystemName());

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	pObject->SetGuid(sGuid);

  // Add the child
	AddChild(pObject);

	// create child instance
	CWbemClassObject ChildClassObject;
	if( ! CHECKHRESULT(ChildClassObject.Create(GetSystemName())) )
	{
		return false;
	}

	BSTR bsTemp = sWMIClassName.AllocSysString();
	if( ! CHECKHRESULT(ChildClassObject.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);

	// Save the child instance properties for name and guid
	ChildClassObject.SetProperty(IDS_STRING_MOF_NAME,pObject->GetName());

	ChildClassObject.SetProperty(IDS_STRING_MOF_GUID,sGuid);

	// create the association class instance
	CWbemClassObject Associator;
	if( ! CHECKHRESULT(Associator.Create(GetSystemName())) )
	{
		return false;
	}

	bsTemp = sWMIAssociatorClassName.AllocSysString();
	if( ! CHECKHRESULT(Associator.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);

	// set path properties for the association class instance
	Associator.SetProperty(IDS_STRING_MOF_PARENT_ASSOC,GetObjectPath());

	Associator.SetProperty(IDS_STRING_MOF_CHILD_ASSOC,pObject->GetObjectPath());

	// commit the changes to WMI
	ChildClassObject.SaveAllProperties();
	Associator.SaveAllProperties();

	// Add the child
	return true;
}

inline CString CHMObject::GetUniqueChildName(UINT uiFmtID /*= IDS_STRING_UNITITLED */)
{
	TRACEX(_T("CHMObject::GetUniqueChildName\n"));

	CString sName;
	sName.LoadString(uiFmtID);
	sName = sName.Left(sName.GetLength()-3);
	
	while( GetChild(sName) != NULL )
	{
		sName.Format(uiFmtID,m_lNameSuffix++);
	}	

	return sName;
}

inline CHMObject* CHMObject::GetChild(const CString& sName)
{
	TRACEX(_T("CHMObject::GetChild\n"));

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i]->GetName().CompareNoCase(sName) == 0 )
		{
			return GetChild(i);
		}
	}

	return NULL;
}

inline CHMObject* CHMObject::GetChildByGuid(const CString& sGuid)
{
	TRACEX(_T("CHMObject::GetChildByGUID\n"));
	TRACEARGs(sGuid);

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i]->GetGuid() == sGuid )
		{
			return GetChild(i);
		}
	}

	return NULL;
}

inline CHMObject* CHMObject::GetDescendantByGuid(const CString& sGuid)
{
	TRACEX(_T("CHMObject::GetDescendantByGuid\n"));
	TRACEARGs(sGuid);

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i]->GetGuid() == sGuid )
		{
			return GetChild(i);
		}

    CHMObject* pDescendantObject = m_Children[i]->GetDescendantByGuid(sGuid);
    if( pDescendantObject )
    {
      return pDescendantObject;
    }
	}

	return NULL;
}

inline CHMObject* CHMObject::GetChild(int iIndex)
{
	TRACEX(_T("CHMObject::GetChild\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_Children.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return NULL;
	}

	return m_Children[iIndex];
}

inline void CHMObject::RemoveChild(CHMObject* pObject)
{
	TRACEX(_T("CHMObject::RemoveChild\n"));
	TRACEARGn(pObject);

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i] == pObject )
		{
			m_Children.RemoveAt(i);
			return;
		}
	}
}


inline void CHMObject::DestroyChild(CHMObject* pChildObject, bool bDeleteClassObject /*= false*/)
{
	TRACEX(_T("CHMObject::DestroyChild\n"));
	TRACEARGn(pChildObject);
	TRACEARGn(bDeleteClassObject);

	for( int i = 0; i < m_Children.GetSize(); i++ )	
	{
		if( GetChild(i) == pChildObject )
		{
			DestroyChild(i,bDeleteClassObject);
			break;
		}
	}
}

inline void CHMObject::DestroyAllChildren()
{
	TRACEX(_T("CHMObject::DestroyAllChildren\n"));

	for( int i = (int)m_Children.GetSize() - 1; i >= 0; i-- )
	{
		m_Children[i]->DestroyAllChildren();
		DestroyChild(i);
	}
}

/////////////////////////////////////////////////////////////////////////////
// State Members
/////////////////////////////////////////////////////////////////////////////

inline void CHMObject::SetState(int iState, bool bUpdateScopeItems /*= false*/, bool bApplyToChildren /*= false*/)
{
	TRACEX(_T("CHMObject::SetState\n"));
	TRACEARGn(iState);
	
	m_nState = iState;

	if( bUpdateScopeItems )
	{
		for( int i = 0; i < GetScopeItemCount(); i++ )
		{
			CScopePaneItem* pItem = GetScopeItem(i);
			if( pItem )
			{
				pItem->SetIconIndex(GetState());
				pItem->SetOpenIconIndex(GetState());
				pItem->SetItem();
			}
		}
	}

	if( bApplyToChildren )
	{
		for( int i = 0; i < GetChildCount(); i++ )
		{
			CHMObject* pObject = GetChild(i);
			if( pObject )
			{
				pObject->SetState(iState,bUpdateScopeItems,bApplyToChildren);
			}
		}
	}
}

inline void CHMObject::TallyChildStates()
{
	TRACEX(_T("CHMObject::TallyChildStates\n"));

	m_lNormalCount = 0L;
	m_lWarningCount = 0L;
	m_lCriticalCount = 0L;
	m_lUnknownCount = 0L;


	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		switch( m_Children[i]->GetState() )
		{
			case HMS_NORMAL:
			{
				m_lNormalCount++;
			}
			break;

			case HMS_WARNING:
			{
				m_lWarningCount++;
			}
			break;

			case HMS_CRITICAL:
			{
				m_lCriticalCount++;
			}
			break;

			case HMS_UNKNOWN:
			{
				m_lUnknownCount++;
			}
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Associated Scope Pane Member
/////////////////////////////////////////////////////////////////////////////

inline CScopePane* CHMObject::GetScopePane()
{
	TRACEX(_T("CHMObject::GetScopePane\n"));

	if( ! GfxCheckObjPtr(m_pPane,CScopePane) )
	{
		TRACE(_T("FAILED : m_pPane is not a valid pointer.\n"));
		return NULL;
	}

	return m_pPane;
}

inline void CHMObject::SetScopePane(CScopePane* pPane)
{
	TRACEX(_T("CHMObject::SetScopePane\n"));
	TRACEARGn(pPane);
	
	if( ! GfxCheckObjPtr(pPane,CScopePane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return;
	}

	m_pPane = pPane;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline int CHMObject::GetScopeItemCount()
{
	TRACEX(_T("CHMObject::GetScopeItemCount\n"));

	return (int)m_ScopeItems.GetSize();
}

inline CScopePaneItem* CHMObject::GetScopeItem(int iIndex)
{
	TRACEX(_T("CHMObject::GetScopeItem\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ScopeItems.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return NULL;
	}

	if( ! GfxCheckObjPtr(m_ScopeItems[iIndex],CScopePaneItem) )
	{
		TRACE(_T("FAILED : The Scope Pane Item pointer stored at iIndex is invalid.\n"));
		return NULL;
	}

	return m_ScopeItems[iIndex];
}

inline int CHMObject::AddScopeItem(CScopePaneItem* pItem)
{
	TRACEX(_T("CHMObject::AddScopeItem\n"));
	TRACEARGn(pItem);

	if( ! GfxCheckObjPtr(pItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pItem is not a valid pointer.\n"));
		return -1;
	}

	if( pItem->GetChildCount() == 0 && GetChildCount() != 0 )
	{
		for( int i = 0; i < m_Children.GetSize(); i++ )
		{
			CScopePaneItem* pNewItem = m_Children[i]->CreateScopeItem();
			if( ! pNewItem->Create(m_pPane,pItem) )
			{
				ASSERT(FALSE);
				delete pNewItem;
				return -1;
			}

			if( m_Children[i]->GetScopeItemCount() )
			{
				pNewItem->SetDisplayNames(m_Children[i]->GetScopeItem(0)->GetDisplayNames());
			}
			else
			{
				pNewItem->SetDisplayName(0,m_Children[i]->GetName());
			}
			pNewItem->SetIconIndex(m_Children[i]->GetState());
			pNewItem->SetOpenIconIndex(m_Children[i]->GetState());
			int iIndex = pItem->AddChild(pNewItem);
			pNewItem->InsertItem(iIndex);
			m_Children[i]->AddScopeItem(pNewItem);
		}

	}

	// make certain the new scope item has the correct icon
	pItem->SetIconIndex(GetState());
	pItem->SetOpenIconIndex(GetState());

	return (int)m_ScopeItems.Add(pItem);
}

inline void CHMObject::RemoveScopeItem(int iIndex)
{
	TRACEX(_T("CHMObject::RemoveScopeItem\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ScopeItems.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	if( ! GfxCheckObjPtr(m_ScopeItems[iIndex],CScopePaneItem) )
	{
		TRACE(_T("FAILED : The Scope Pane Item pointer stored at iIndex is invalid.\n"));
		return;
	}

	m_ScopeItems.RemoveAt(iIndex);
}

inline void CHMObject::RemoveAllScopeItems()
{
	TRACEX(_T("CHMObject::RemoveAllScopeItems\n"));

	m_ScopeItems.RemoveAll();
}

inline CScopePaneItem* CHMObject::IsSelected()
{
	TRACEX(_T("CHMObject::IsSelected\n"));

	if( ! GetScopePane() )
	{
		return NULL;
	}

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		if( m_pPane->GetSelectedScopeItem() == GetScopeItem(i) )
		{
			return GetScopeItem(i);
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertypage.h ===
#if !defined(AFX_HMPROPERTYPAGE_H__C3B8B693_095A_11D3_937D_00A0CC406605__INCLUDED_)
#define AFX_HMPROPERTYPAGE_H__C3B8B693_095A_11D3_937D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMPropertyPage.h : header file
//

class CHMObject;

/////////////////////////////////////////////////////////////////////////////
// CHMPropertyPage dialog

class CHMPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CHMPropertyPage)

// Construction
public:
	CHMPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	~CHMPropertyPage();
protected:
	CHMPropertyPage();

    // v-marfin 59237
    CString m_sOriginalName;


// HMObject Association
public:
	CHMObject* GetObjectPtr();
	void SetObjectPtr(CHMObject* pObject);
protected:
	CHMObject* m_pHMObject;

    // v-marfin 62585
    BOOL m_bOnApplyUsed;

// Callback Members
protected:
	LPFNPSPCALLBACK m_pfnOriginalCallback;
	static UINT CALLBACK PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );

// Connection Check
protected:
	bool IsConnectionOK();

// Help System
public:
	void ClearStatistics();
	// v-marfin: necessary for overrides.
	CString m_sHelpTopic;
protected:

// Dialog Data
	//{{AFX_DATA(CHMPropertyPage)
	enum { IDD = IDC_STATIC };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHMPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHMPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMPROPERTYPAGE_H__C3B8B693_095A_11D3_937D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmlistvieweventsink.cpp ===
// HMListViewEventSink.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "Healthmonscopepane.h"
#include "HMListViewEventSink.h"
#include "HMEventResultsPaneItem.h"
#include "HMScopeItem.h"
#include "ResultsPaneView.h"
#include "SystemGroup.h"
#include "EventManager.h"
#include "HealthmonResultsPane.h"
#include "..\HMListView\HMList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMListViewEventSink

IMPLEMENT_DYNCREATE(CHMListViewEventSink, CCmdTarget)

CHMListViewEventSink::CHMListViewEventSink()
{
	EnableAutomation();
	m_dwEventCookie = 0L;
	m_pDHMListView = NULL;
  m_pHMRP = NULL;
  m_Pane = Uninitialized;
}

CHMListViewEventSink::~CHMListViewEventSink()
{
	m_dwEventCookie = 0L;
	m_pDHMListView = NULL;
  m_pHMRP = NULL;
  m_Pane = Uninitialized;
}

void CHMListViewEventSink::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}

HRESULT CHMListViewEventSink::HookUpEventSink(LPUNKNOWN lpControlUnknown)
{
	TRACEX(_T("CHMListViewEventSink::HookUpEventSink\n"));
	TRACEARGn(lpControlUnknown);

	HRESULT hr = S_OK;
  IConnectionPointContainer* pCPC = 0;
	hr = lpControlUnknown->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if(pCPC)
	{
		IProvideClassInfo2* pPCI = 0;
		lpControlUnknown->QueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);
		if(pPCI)
		{
			IID iidEventSet;
			hr = pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,&iidEventSet);
			if(SUCCEEDED(hr))
			{
				IConnectionPoint* pCP = 0;
				hr = pCPC->FindConnectionPoint(iidEventSet, &pCP);

				if(pCP)
				{
					pCP->Advise(GetIDispatch(TRUE),&m_dwEventCookie); 
					pCP->Release();
				}
			}
			pPCI->Release();
		}
		pCPC->Release();
	}

	return hr;
}

BEGIN_MESSAGE_MAP(CHMListViewEventSink, CCmdTarget)
	//{{AFX_MSG_MAP(CHMListViewEventSink)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CHMListViewEventSink, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CHMListViewEventSink)
	DISP_FUNCTION(CHMListViewEventSink, "ListClick", ListClick, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CHMListViewEventSink, "ListDblClick", ListDblClick, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CHMListViewEventSink, "ListRClick", ListRClick, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CHMListViewEventSink, "CompareItem", CompareItem, VT_EMPTY, VTS_I4 VTS_I4 VTS_I4 VTS_PI4)
	DISP_FUNCTION(CHMListViewEventSink, "ListLabelEdit", ListLabelEdit, VT_EMPTY, VTS_BSTR VTS_I4 VTS_PI4)
	DISP_FUNCTION(CHMListViewEventSink, "ListKeyDown", ListKeyDown, VT_EMPTY, VTS_I4 VTS_I4 VTS_PI4)
	DISP_FUNCTION(CHMListViewEventSink, "FilterChange", FilterChange, VT_EMPTY, VTS_I4 VTS_BSTR VTS_I4 VTS_PI4)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_DHMListViewEvents to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

const IID BASED_CODE IID_DHMListViewEvents =
		{ 0x5116a805, 0xdafc, 0x11d2, { 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CHMListViewEventSink, CCmdTarget)
	INTERFACE_PART(CHMListViewEventSink, IID_DHMListViewEvents, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMListViewEventSink message handlers

void CHMListViewEventSink::ListClick(long lParam) 
{
	CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
	if( !pItem || ! GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
	{
		return;
	}	
}

void CHMListViewEventSink::ListDblClick(long lParam) 
{
	CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
	if( !pItem || ! GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
	{
		return;
	}

	if( pItem->IsUpperPane() ) // this item is a scope pane item...double click means select it in scope pane
	{
		CResultsPaneView* pView = pItem->GetOwnerResultsView();
		CScopePaneItem* pScopeItem = pView->GetOwnerScopeItem();
		for( int i = 0; i < pScopeItem->GetChildCount(); i++ )
		{
			CScopePaneItem* pChildItem = pScopeItem->GetChild(i);
			if( pChildItem->GetDisplayName() == pItem->GetDisplayName() )
			{
				pChildItem->SelectItem();
				return;
			}
		}
	}
	else if( pItem->IsLowerPane() )
	{
    pItem->OnCommand(m_pHMRP,IDM_PROPERTIES);
	}
}

void CHMListViewEventSink::ListRClick(long lParam) 
{
    int iSelectedCount = 0;
	CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
	if( ! pItem || ! GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
	{
		return;
	}

	if( pItem->IsUpperPane() ) // this item is a scope pane item...double click means select it in scope pane
	{
		CResultsPaneView* pView = pItem->GetOwnerResultsView();
		CScopePaneItem* pScopeItem = pView->GetOwnerScopeItem();
		for( int i = 0; i < pScopeItem->GetChildCount(); i++ )
		{
			CScopePaneItem* pChildItem = pScopeItem->GetChild(i);
			if( pChildItem->GetDisplayName() == pItem->GetDisplayName() )
			{
				CPoint pt;
				GetCursorPos(&pt);

                // v-marfin 59644 : Send count of items selected to context menu since
                //                  3rd party menu item is only allowed if 1 results pane
                //                  item is selected.
                iSelectedCount = pView->GetUpperPaneSelectedCount();

                // v-marfin 59644 : Changed prototype to include count of items
				pChildItem->InvokeContextMenu(pt,iSelectedCount);
				return;
			}
		}
	}
	else if( pItem->IsLowerPane() || pItem->IsStatsPane() )
	{
    if( m_pDHMListView )
    {
      iSelectedCount = m_pDHMListView->GetSelectedCount();
    }

		CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
		if( ! GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
		{
			ASSERT(FALSE);
			return;
		}

		CResultsPaneView* pView = pItem->GetOwnerResultsView();
		if( ! GfxCheckObjPtr(pView,CResultsPaneView) )
		{
			ASSERT(FALSE);
			return;
		}

		CPoint pt;
		GetCursorPos(&pt);

		pView->InvokeContextMenu(pt, pItem, iSelectedCount);
	}
}

void CHMListViewEventSink::CompareItem(long lItem1, long lItem2, long lColumn, long FAR* lpResult) 
{
	CHMResultsPaneItem* pItem1 = (CHMResultsPaneItem*)lItem1;
	if( ! pItem1 || ! GfxCheckObjPtr(pItem1,CHMResultsPaneItem) )
	{
		return;
	}

	CHMResultsPaneItem* pItem2 = (CHMResultsPaneItem*)lItem2;
	if( ! pItem2 || ! GfxCheckObjPtr(pItem2,CHMResultsPaneItem) )
	{
		return;
	}

	*lpResult = pItem1->CompareItem(pItem2,lColumn);
}

void CHMListViewEventSink::ListLabelEdit(LPCTSTR lpszNewName, long lParam, long FAR* plResult) 
{
	CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
	if( ! pItem || ! GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
	{
		return;
	}

	if( pItem->IsUpperPane() ) // this item is a scope pane item...
	{
		CResultsPaneView* pView = pItem->GetOwnerResultsView();
		CScopePaneItem* pScopeItem = pView->GetOwnerScopeItem();
		for( int i = 0; i < pScopeItem->GetChildCount(); i++ )
		{
			CScopePaneItem* pChildItem = pScopeItem->GetChild(i);
			if( pChildItem->GetDisplayName() == pItem->GetDisplayName() )
			{
				*plResult = pChildItem->OnRename(CString(lpszNewName)) == S_OK ? 1 : 0;
				if( *plResult )
				{
					pItem->SetDisplayName(0,lpszNewName);
				}
				return;
			}
		}
	}
}

void CHMListViewEventSink::ListKeyDown(long lVKCode, long lFlags, long FAR* plResult) 
{
	if( ! GfxCheckPtr(m_pDHMListView,_DHMListView) )
	{
		return;
	}

	switch( lVKCode )
	{
		case VK_DELETE:
		{
			CTypedPtrArray<CObArray,CHMResultsPaneItem*> Items;

			int iIndex = m_pDHMListView->GetNextItem(-1,LVNI_SELECTED);
			CDWordArray IndexArray;
			while( iIndex != -1 )
			{
				LPARAM lParam = m_pDHMListView->GetItem(iIndex);

				CHMResultsPaneItem* pItem = (CHMResultsPaneItem*)lParam;
				if( pItem && GfxCheckObjPtr(pItem,CHMResultsPaneItem) )
				{
					Items.Add(pItem);
					IndexArray.Add(iIndex);
				}

				int iNextIndex = m_pDHMListView->GetNextItem(iIndex,LVNI_SELECTED|LVNI_BELOW);
				if( iNextIndex == iIndex )
				{
					break;
				}
				else
				{
					iIndex = iNextIndex;
				}
			}

			for( int i = 0; i < Items.GetSize(); i++ )
			{
				CHMResultsPaneItem* pItem = Items[i];

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( pItem->IsUpperPane() ) // this item is a scope pane item...
				{					
					CScopePaneItem* pScopeItem = pView->GetOwnerScopeItem();

					for( int k = 0; k < pScopeItem->GetChildCount(); k++ )
					{
						CScopePaneItem* pChildItem = pScopeItem->GetChild(k);
						if( pChildItem->GetDisplayName() == pItem->GetDisplayName() )
						{
							pChildItem->OnDelete();								
						}
					}

					if( i == Items.GetSize() - 1 )
					{
						pScopeItem->SelectItem();
					}
				}
				else if( pItem->IsLowerPane() )
				{
					CHMEventResultsPaneItem* pEventItem = (CHMEventResultsPaneItem*)pItem;
					if( ! GfxCheckObjPtr(pEventItem,CHMEventResultsPaneItem) )
					{
						return;
					}
					CHMScopeItem* pScopeItem = (CHMScopeItem*)pView->GetOwnerScopeItem();
					if( ! GfxCheckObjPtr(pScopeItem,CHMScopeItem) )
					{
						return;
					}
					CHealthmonScopePane* pPane = (CHealthmonScopePane*)pScopeItem->GetScopePane();
					if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
					{
						return;
					}

					EvtGetEventManager()->DeleteEvents(pEventItem->GetDisplayName(4),pEventItem->m_sGuid);

					pView->OnDelete(pItem);
				}
				else if( pItem->IsStatsPane() )
				{
					CHMEventResultsPaneItem* pEventItem = (CHMEventResultsPaneItem*)pItem;
					if( ! GfxCheckObjPtr(pEventItem,CHMEventResultsPaneItem) )
					{
						return;
					}
					CScopePaneItem* pScopeItem = pView->GetOwnerScopeItem();
					if( ! GfxCheckObjPtr(pScopeItem,CHMScopeItem) )
					{
						return;
					}
					CHealthmonScopePane* pPane = (CHealthmonScopePane*)pScopeItem->GetScopePane();
					if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
					{
						return;
					}

					// TODO: Destroy statistic
					pView->OnDelete(pItem);
				}
			}

		}
		break;

	}
	
}

void CHMListViewEventSink::FilterChange(long lItem, LPCTSTR pszFilter, long lFilterType, long FAR* lpResult) 
{
	if( ! GfxCheckPtr(m_pDHMListView,_DHMListView) )
	{
		return;
	}

  if( ! m_pHMRP )
  {
    return;
  }

  CScopePane* pHMSP = m_pHMRP->GetOwnerScopePane();
  if( ! pHMSP )
  {
    return;
  }

  CScopePaneItem* pSPI = pHMSP->GetSelectedScopeItem();
  if( ! pSPI )
  {
    return;
  }

  CResultsPaneView* pView = pSPI->GetResultsPaneView();
  if( ! pView )
  {
    return;
  }
  
  // get all the filters on all the columns
  CStringArray saFilters;
  CDWordArray dwaFilterTypes;

  CString sFilter;
  BSTR bsFilter = NULL;
  long lType = -1L;
  long lColumnCount = m_pDHMListView->GetColumnCount();

  for( long l = 0L; l < lColumnCount; l++ )
  {
    m_pDHMListView->GetColumnFilter(l,&bsFilter,&lType);
    sFilter = bsFilter;
    saFilters.Add(sFilter);
    dwaFilterTypes.Add(lType);
    SysFreeString(bsFilter);
  }

  // determine the set of result items that pass through the filter
  ResultsPaneItemArray FilteredResultItems;
  for( int i = 0; i < pView->GetItemCount(); i++ )
  {
    CResultsPaneItem* pRPI = pView->GetItem(i);   
    bool bItemPassed = true;
    for( l = 0L; l < lColumnCount; l++ )
    {
      if( dwaFilterTypes[l] == HDFS_CONTAINS )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l).Find(saFilters[l]) == -1 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_DOES_NOT_CONTAIN )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l).Find(saFilters[l]) != -1 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_STARTS_WITH )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l).Find(saFilters[l]) != 0 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_ENDS_WITH )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l).Find(saFilters[l]) != pRPI->GetDisplayName(l).GetLength() - saFilters[l].GetLength() )
        {
          bItemPassed = false;
          break;
        }
      }      
      else if( dwaFilterTypes[l] == HDFS_IS )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l) != saFilters[l] )
        {
          bItemPassed = false;
          break;
        }
      }      
      else if( dwaFilterTypes[l] == HDFS_IS_NOT )
      {
        if( saFilters[l] != _T("") && pRPI->GetDisplayName(l) == saFilters[l] )
        {
          bItemPassed = false;
          break;
        }
      }      
    }

    if( bItemPassed )
    {
      FilteredResultItems.Add(pRPI);
    }
  }
  
  // delete all the current items from the list control
  m_pDHMListView->DeleteAllItems();

  // insert all the filtered result items
  for( i = 0; i < FilteredResultItems.GetSize(); i++ )
  {
    FilteredResultItems[i]->InsertItem(m_pHMRP,i);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertypage.cpp ===
// HMPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HMPropertyPage.h"
#include "HMObject.h"
#include <mmc.h>

#include "DataElement.h"            // 62548
#include "HealthmonResultsPane.h"   // 62548

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const UINT ID_MMC_HELP = 57670;

/////////////////////////////////////////////////////////////////////////////
// CHMPropertyPage property page

IMPLEMENT_DYNCREATE(CHMPropertyPage, CPropertyPage)

CHMPropertyPage::CHMPropertyPage()
{
	ASSERT(FALSE);
}

CHMPropertyPage::CHMPropertyPage(UINT nIDTemplate, UINT nIDCaption) : CPropertyPage(nIDTemplate,nIDCaption)
{
	//{{AFX_DATA_INIT(CHMPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_bOnApplyUsed=FALSE;  // v-marfin 62585

	m_pHMObject = NULL;

	m_psp.dwFlags |= PSP_HASHELP;
  m_pfnOriginalCallback = m_psp.pfnCallback;
	m_psp.pfnCallback = PropSheetPageProc;
	m_psp.lParam = (LPARAM)this;

	MMCPropPageCallback( &m_psp );
}

CHMPropertyPage::~CHMPropertyPage()
{
}

/////////////////////////////////////////////////////////////////////////////
// HMObject Association
/////////////////////////////////////////////////////////////////////////////

CHMObject* CHMPropertyPage::GetObjectPtr()
{
	TRACEX(_T("CHMPropertyPage::GetObjectPtr\n"));

	if( ! GfxCheckObjPtr(m_pHMObject,CHMObject) )
	{
		return NULL;
	}

	return m_pHMObject;
}

void CHMPropertyPage::SetObjectPtr(CHMObject* pObject)
{
	TRACEX(_T("CHMPropertyPage::GetObjectPtr\n"));
	TRACEARGn(pObject);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )	
	{
		m_pHMObject = NULL;
		return;
	}

	m_pHMObject = pObject;
}

/////////////////////////////////////////////////////////////////////////////
// Callback Members
/////////////////////////////////////////////////////////////////////////////

UINT CALLBACK CHMPropertyPage::PropSheetPageProc(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE pPsp)
{
  CHMPropertyPage* pThis = (CHMPropertyPage*)(pPsp->lParam);
  ASSERT( pThis != NULL );
	if( !pThis || ! GfxCheckObjPtr(pThis,CHMPropertyPage) )
	{
		return 0;
	}

  switch( uMsg )
  {
    case PSPCB_CREATE:                  
      break;

    case PSPCB_RELEASE:  
      delete pThis;      
      return 1;              
  }
  return (pThis->m_pfnOriginalCallback)(hWnd, uMsg, pPsp); 
}

/////////////////////////////////////////////////////////////////////////////
// Connection Check
/////////////////////////////////////////////////////////////////////////////

inline bool CHMPropertyPage::IsConnectionOK()
{
	// check the connection to the remote system before proceeding
	// if the object requires WMI connectivity

	if( GetObjectPtr()->GetObjectPath().IsEmpty() )
	{
		return TRUE;
	}
	
	IWbemServices* pServices = NULL;
	BOOL bAvail = FALSE;
	HRESULT hr = CnxGetConnection(GetObjectPtr()->GetSystemName(),pServices,bAvail);

	if( hr != S_OK )
	{
		MessageBeep(MB_ICONEXCLAMATION);
		CnxDisplayErrorMsgBox(hr,GetObjectPtr()->GetSystemName());
		return FALSE;
	}

	if( pServices )
	{
		pServices->Release();
	}

	return TRUE;
}

void CHMPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHMPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHMPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CHMPropertyPage)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMPropertyPage message handlers

BOOL CHMPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	CWaitCursor wait;

	if( ! GetObjectPtr() )
	{
		GetParent()->PostMessage(WM_COMMAND,MAKELONG(IDCANCEL,BN_CLICKED),(LPARAM)GetDlgItem(IDCANCEL)->GetSafeHwnd());
		return FALSE;
	}

	if( ! IsConnectionOK() )
	{
		GetParent()->PostMessage(WM_COMMAND,MAKELONG(IDCANCEL,BN_CLICKED),(LPARAM)GetDlgItem(IDCANCEL)->GetSafeHwnd());
		return FALSE;
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CHMPropertyPage::OnApply() 
{
	if( ! GetObjectPtr() )
	{
		return FALSE;
	}

	if( ! IsConnectionOK() )
	{
		return FALSE;
	}

	GetObjectPtr()->SetModifiedDateTime(CTime::GetCurrentTime());

	return CPropertyPage::OnApply();
}

BOOL CHMPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if( ! m_sHelpTopic.IsEmpty() )
	{
		MMCPropertyHelp((LPTSTR)(LPCTSTR)m_sHelpTopic);
	}
	
	return CPropertyPage::OnHelpInfo(pHelpInfo);
}

LRESULT CHMPropertyPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	if( message == WM_COMMAND )
	{
		if( wParam == ID_MMC_HELP )
			OnHelpInfo(NULL);
	}
	
	return CPropertyPage::WindowProc(message, wParam, lParam);
}

//*************************************************************************
// ClearStatistics  62548 - clear stats on change of any properties
//*************************************************************************
void CHMPropertyPage::ClearStatistics()
{
    TRACE(_T("CHMPropertyPage::ClearStatistics\n"));

    CDataElement* pElement = (CDataElement*)GetObjectPtr();
    if (pElement)
    {
	    if(pElement->GetScopeItemCount())
	    {
		    CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		    if( pItem )
            {
                CResultsPaneView* pView = pItem->GetResultsPaneView();

                CHealthmonResultsPane* pPane = (CHealthmonResultsPane*)pView->GetResultsPane(0);
                pPane->GetStatsListCtrl()->DeleteAllItems();
            }
        }
    }
    else
    {
        TRACE(_T("ERROR: CHMPropertyPage::ClearStatistics unable to GetObjectPtr().\n"));
        ASSERT(FALSE);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertystatus.cpp ===
// HMPropertyStatus.cpp: implementation of the CHMPropertyStatus class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMPropertyStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMPropertyStatus,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMPropertyStatus::CHMPropertyStatus()
{
}

CHMPropertyStatus::~CHMPropertyStatus()
{
	for( int i = 0; i < m_PropStatusInstances.GetSize(); i++ )
	{
		delete m_PropStatusInstances[i];
	}
	m_PropStatusInstances.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMPropertyStatus::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMPropertyStatus::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMPropertyStatus::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;
	
	// PropertyName
  hr = GetProperty(IDS_STRING_MOF_PROPERTYNAME,m_sPropertyName);

	// Instances	
	hr = GetProperty(IDS_STRING_MOF_INSTANCES,m_Instances);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_Instances.GetLBound(1L,&lLower);
		m_Instances.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_Instances.GetElement(&i,&pIWBCO);
		CHMPropertyStatusInstance* pPSI = new CHMPropertyStatusInstance;
		pPSI->Create(pIWBCO);
		pPSI->GetAllProperties();
		m_PropStatusInstances.Add(pPSI);
		pPSI->Destroy();
	}

	m_Instances.Destroy();
	m_Instances.Detach();


  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertystatusinstance.cpp ===
// HMPropertyStatusInstance.cpp: implementation of the CHMPropertyStatusInstance class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMPropertyStatusInstance.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMPropertyStatusInstance,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMPropertyStatusInstance::CHMPropertyStatusInstance()
{
}

CHMPropertyStatusInstance::~CHMPropertyStatusInstance()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMPropertyStatusInstance::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMPropertyStatusInstance::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMPropertyStatusInstance::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;
	
	// InstanceName
	hr = GetProperty(IDS_STRING_MOF_INSTANCENAME,m_sInstanceName);

	// CurrentValue
	hr = GetProperty(IDS_STRING_MOF_CURRENTVALUE,m_sCurrentValue);
	m_lCurrentValue =	_ttoi(m_sCurrentValue);

	// MinValue
	hr = GetProperty(IDS_STRING_MOF_MINVALUE,m_sMinValue);
	m_lMinValue =	_ttoi(m_sMinValue);

	// MaxValue
	hr = GetProperty(IDS_STRING_MOF_MAXVALUE,m_sMaxValue);
	m_lMaxValue =	_ttoi(m_sMaxValue);

	// AvgValue
	hr = GetProperty(IDS_STRING_MOF_AVGVALUE,m_sAvgValue);
	m_lAvgValue =	_ttoi(m_sAvgValue);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertystatus.h ===
// HMPropertyStatus.h: interface for the CHMPropertyStatus class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMPROPERTYSTATUS_H__A28C24E4_348F_11D3_BE18_0000F87A3912__INCLUDED_)
#define AFX_HMPROPERTYSTATUS_H__A28C24E4_348F_11D3_BE18_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"
#include "HMPropertyStatusInstance.h"

class CHMPropertyStatus : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMPropertyStatus)

// Construction/Destruction
public:
	CHMPropertyStatus();
	virtual ~CHMPropertyStatus();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Property Retreival Operations
public:
  HRESULT GetAllProperties();

// HMDataElementStatistics Properties
public:
	CString m_sPropertyName;
	COleSafeArray m_Instances;

	PropertyStatusInstanceArray m_PropStatusInstances;

};

typedef CTypedPtrArray<CObArray,CHMPropertyStatus*> PropertyStatusArray;

#endif // !defined(AFX_HMPROPERTYSTATUS_H__A28C24E4_348F_11D3_BE18_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmresultspaneitem.h ===
// HMResultsPaneItem.h: interface for the CHMResultsPaneItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMRESULTSPANEITEM_H__988259DA_B71C_11D2_BD74_0000F87A3912__INCLUDED_)
#define AFX_HMRESULTSPANEITEM_H__988259DA_B71C_11D2_BD74_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ResultsPaneItem.h"
#include "Constants.h"

class CHMResultsPaneItem : public CResultsPaneItem  
{

DECLARE_DYNCREATE(CHMResultsPaneItem)

// Construction/Destruction
public:
	CHMResultsPaneItem();
	virtual ~CHMResultsPaneItem();

// MMC-Related Members
public:
	virtual bool InsertItem(CResultsPane* pPane, int iIndex, bool bResizeColumns = false);
	virtual bool SetItem(CResultsPane* pPane);
	virtual bool RemoveItem(CResultsPane* pPane);

// Results Pane Location of Item - for split pane results view
public:
	bool IsUpperPane() const { return m_Pane==Upper; }
	bool IsLowerPane() const { return m_Pane==Lower; }
	bool IsStatsPane() const { return m_Pane==Stats; }
	void SetToUpperPane() { m_Pane = Upper; }
	void SetToLowerPane() { m_Pane = Lower; }
	void SetToStatsPane() { m_Pane = Stats; }
protected:
	SplitResultsPane m_Pane;

// MMC Notify Handlers
public:
	virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
	virtual HRESULT OnCommand(CResultsPane* pPane, long lCommandID);

};

#endif // !defined(AFX_HMRESULTSPANEITEM_H__988259DA_B71C_11D2_BD74_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmresultspaneitem.cpp ===
// HMResultsPaneItem.cpp: implementation of the CHMResultsPaneItem class.
//
//////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000 Microsoft Corporation
//
// 04/06/00 v-marfin 62935 : Show "OK" Instead of "Reset" in the upper pane only
//
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "HMResultsPaneItem.h"
#include "HealthmonResultsPane.h"
#include "..\HMListView\HMList.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMResultsPaneItem,CResultsPaneItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMResultsPaneItem::CHMResultsPaneItem()
{

}

CHMResultsPaneItem::~CHMResultsPaneItem()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// MMC-Related Members

bool CHMResultsPaneItem::InsertItem(CResultsPane* pPane, int nIndex, bool bResizeColumns /*= false*/)
{
	TRACEX(_T("CHMResultsPaneItem::InsertItem\n"));
	TRACEARGn(pPane);
	TRACEARGn(nIndex);
	TRACEARGn(bResizeColumns);

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return false;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;

	_DHMListView* pList = NULL;
	
	if( IsUpperPane() )
	{
		pList = pHMRP->GetUpperListCtrl();
	}
	else if( IsLowerPane() )
	{
		pList = pHMRP->GetLowerListCtrl();
	}
	else if( IsStatsPane() )
	{
		pList = pHMRP->GetStatsListCtrl();
	}
	else
	{
		TRACE(_T("WARNING : Column has not been assigned to a results pane in the split view.\n"));
		ASSERT(FALSE);
	}

	if( ! pList )
	{
		TRACE(_T("FAILED : Results Pane's list control has not been intialized.\n"));
		return false;		
	}

#ifndef IA64
	if( pList->FindItemByLParam((long)this) >= 0 ) // needs ptr fixing
	{
		return true;
	}
#endif // IA64

  if( IsLowerPane() )
  {
    // check filters
    CStringArray saFilters;
    CDWordArray dwaFilterTypes;
    CString sFilter;
    BSTR bsFilter = NULL;
    long lType = -1L;

    long lColumnCount = pList->GetColumnCount();

    for( long l = 0L; l < lColumnCount; l++ )
    {
      pList->GetColumnFilter(l,&bsFilter,&lType);
      sFilter = bsFilter;
      saFilters.Add(sFilter);
      dwaFilterTypes.Add(lType);
      SysFreeString(bsFilter);
    }

    bool bItemPassed = true;

    for( l = 0L; l < lColumnCount; l++ )
    {
      if( dwaFilterTypes[l] == HDFS_CONTAINS )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l).Find(saFilters[l]) == -1 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_DOES_NOT_CONTAIN )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l).Find(saFilters[l]) != -1 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_STARTS_WITH )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l).Find(saFilters[l]) != 0 )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_ENDS_WITH )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l).Find(saFilters[l]) != GetDisplayName(l).GetLength() - saFilters[l].GetLength() )
        {
          bItemPassed = false;
          break;
        }
      }
      else if( dwaFilterTypes[l] == HDFS_IS )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l) != saFilters[l] )
        {
          bItemPassed = false;
          break;
        }
      }      
      else if( dwaFilterTypes[l] == HDFS_IS_NOT )
      {
        if( saFilters[l] != _T("") && GetDisplayName(l) == saFilters[l] )
        {
          bItemPassed = false;
          break;
        }
      }      

    }

    if( ! bItemPassed )
    {
      return true;
    }
  }

	// insert the item	
	DWORD dwlvif = LVIF_TEXT|LVIF_PARAM;
	int iIconIndex = -1;
	if( m_IconResIds.GetSize() > 0 )
	{
		dwlvif |= LVIF_IMAGE;
		iIconIndex = pHMRP->GetIconIndex(GetIconId(),m_Pane);
	}

	int iResult=0;

#ifndef IA64
	iResult = pList->InsertItem(dwlvif,
																	IsUpperPane() ? nIndex : 0,
																	(LPCTSTR)GetDisplayName(),
																	-1L,
																	-1L,
																	iIconIndex,
																	(long)this);
#endif // IA64


	// insert the subitems
	for(int i = 1; i < m_saDisplayNames.GetSize(); i++ )
	{
#ifndef IA64
		iResult = pList->SetItem(IsUpperPane() ? nIndex : 0,
														 i,
														 LVIF_TEXT,
														 (LPCTSTR)GetDisplayName(i),
														 -1L,
														 -1L,
														 -1L,
														 (long)this);
#endif // IA64

		if( iResult == -1 )
		{
			TRACE(_T("FAILED : CHMListCtrl::InsertItem failed.\n"));
		}

		if( GetDisplayName(i).IsEmpty() && bResizeColumns )
		{
			pList->SetColumnWidth(i,LVSCW_AUTOSIZE_USEHEADER);
		}
	}

	if( iResult == -1 )
	{
		TRACE(_T("FAILED : CHMListCtrl::InsertItem failed.\n"));
		return false;
	}

	if( bResizeColumns )
	{
		/*
		int iColWidth = 0;
		int iStrWidth = 0;

		// set the widths of the columns for this item
		for( int  i = 0; i < m_saDisplayNames.GetSize(); i++ )
		{
			// get the width in pixels of the item
			iStrWidth = pList->GetStringWidth((LPCTSTR)m_saDisplayNames[i]) + 16;
			iColWidth = pList->GetColumnWidth(i);
			if( iStrWidth > iColWidth && iStrWidth > 10 )
				pList->SetColumnWidth(i,iStrWidth);
		}
		*/
	}


  return true;
}

bool CHMResultsPaneItem::SetItem(CResultsPane* pPane)
{
	TRACEX(_T("CHMResultsPaneItem::SetItem\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return false;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;

	_DHMListView* pList = NULL;
    BOOL bUpperPane = FALSE;  // 62935 : Show "OK" Instead of "Reset" in the upper pane only

	int iIndex = -1;	
	if( IsUpperPane() )
	{
		pList = pHMRP->GetUpperListCtrl();
        bUpperPane=TRUE; // 62935 : Show "OK" Instead of "Reset" in the upper pane only
	}
	else if( IsLowerPane() )
	{
		pList = pHMRP->GetLowerListCtrl();
	}
	else if( IsStatsPane() )
	{
		pList = pHMRP->GetStatsListCtrl();
	}
	else
	{
		TRACE(_T("WARNING : Column has not been assigned to a results pane in the split view.\n"));
		ASSERT(FALSE);
	}

	if( ! pList )
	{
		TRACE(_T("FAILED : Results Pane's list control has not been intialized.\n"));
		return false;		
	}

#ifndef IA64
	iIndex = pList->FindItemByLParam((long)this);
#endif // IA64


	// set the item

	DWORD dwlvif = LVIF_TEXT;
	int iIconIndex = -1;
	if( m_IconResIds.GetSize() > 0 )
	{
		dwlvif |= LVIF_IMAGE;
		iIconIndex = pHMRP->GetIconIndex(GetIconId(),m_Pane);
	}

	int iResult=0;

#ifndef IA64
	iResult = pList->SetItem(iIndex,
															 0,
															 dwlvif,
															 (LPCTSTR)GetDisplayName(),
															 iIconIndex,
															 -1L,
															 -1L,
															 (long)this);
#endif // IA64
															 																
    // 62935 : Show "OK" Instead of "Reset" in the upper pane only
    CString sOK;
    sOK.LoadString(IDS_STRING_OK);
    CString sReset;
    sReset.LoadString(IDS_STRING_RESET);

	// insert the subitems
	for(int i = 1; i < m_saDisplayNames.GetSize(); i++ )
	{
        CString sTest = GetDisplayName(i);

#ifndef IA64
		iResult = pList->SetItem(iIndex,
														 i,
														 LVIF_TEXT,
					                                     //(LPCTSTR)GetDisplayName(i),  // 62935
             (i==1 && bUpperPane && GetDisplayName(i) == sReset) ? (LPCTSTR)sOK : (LPCTSTR)GetDisplayName(i), // 62935														 -1L,
														 -1L,
														 -1L,
														 -1L,
														 (long)this);
#endif // IA64

		if( iResult == -1 )
		{
			TRACE(_T("FAILED : CHMListCtrl::InsertItem failed.\n"));
		}
	}

	if( iResult == -1 )
	{
		TRACE(_T("FAILED : CHMListCtrl::InsertItem failed.\n"));
		return false;
	}

	return true;
}

bool CHMResultsPaneItem::RemoveItem(CResultsPane* pPane)
{
	TRACEX(_T("CHMResultsPaneItem::RemoveItem\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is an invalid pointer.\n"));
		return false;
	}

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return false;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;

	_DHMListView* pList = NULL;

	int iIndex = -1;	
	if( IsUpperPane() )
	{
		pList = pHMRP->GetUpperListCtrl();
	}
	else if( IsLowerPane() )
	{
		pList = pHMRP->GetLowerListCtrl();
	}
	else if( IsStatsPane() )
	{
		pList = pHMRP->GetStatsListCtrl();
	}
	else
	{
		TRACE(_T("WARNING : Column has not been assigned to a results pane in the split view.\n"));
		ASSERT(FALSE);
	}

	if( ! pList )
	{
		TRACE(_T("FAILED : Results Pane's list control has not been intialized.\n"));
		return false;		
	}

#ifndef IA64
	iIndex = pList->FindItemByLParam((long)this);
#endif // IA64

	if( iIndex == -1 )
	{
		return false;
	}

	return pList->DeleteItem(iIndex) ? TRUE : FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Notify Handlers
/////////////////////////////////////////////////////////////////////////////

HRESULT CHMResultsPaneItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CHMResultsPaneItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

	HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
    // TODO: Add any context menu items for the New Menu here
  }

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
	  // TODO: Add any context menu items for the Task Menu here
  }

	  // Add Top Menu Items
  if( CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

		// Cut
    sResString.LoadString(IDS_STRING_CUT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));    
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_CUT;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }	  

		// Copy
    sResString.LoadString(IDS_STRING_COPY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));    
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_COPY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }	  

  }


	return S_OK;
}

HRESULT CHMResultsPaneItem::OnCommand(CResultsPane* pPane, long lCommandID)
{
	TRACEX(_T("CHMResultsPaneItem::OnCommand\n"));
	TRACEARGn(lCommandID);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmruleconfiguration.h ===
// HMRuleConfiguration.h: interface for the CHMRuleConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMRULECONFIGURATION_H__B0D24258_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
#define AFX_HMRULECONFIGURATION_H__B0D24258_F80C_11D2_BDC8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMRuleConfiguration : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMRuleConfiguration)

// Construction/Destruction
public:
	CHMRuleConfiguration();
	virtual ~CHMRuleConfiguration();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  HRESULT GetAllProperties();
  HRESULT SaveEnabledProperty();
	HRESULT SaveAllProperties();
	HRESULT SaveAllExpressionProperties();

// HMRuleConfiguration Attributes
public:

	CString m_sGUID;	// Unique identifier

	CString m_sName;	// Display name

	CString m_sDescription;	// Description

	int m_iID;		// User viewable ID that shows up in the event so user
					// can query/filter for them instead of by string.
	
	CString m_sPropertyName;// What property to look at from the parent instance
						// It all comes down to this. This is the value we
						// get each sampling interval. It is used to keep
						// the current, min, max and avg values.

	int m_iUseFlag;

	int m_iRuleCondition;	// The condition to use for the Rule.
	
	CString m_sRuleCondition;

	CString m_sRuleValue;	// Value to use for Rule.

	int m_iRuleDuration;// How long the value must remain. In

	int m_iState;// The state we transition to if cross Rule.

	CString m_sState;

	CString m_sCreationDate;	// Time of origional creation

	CString m_sLastUpdate;	// Time of last change

	CString m_sMessage;	// What gets sent to the event. Can contain special

	int m_iActiveDays;	// Days of the week it is active. One bit per day.

	int m_iBeginHourTime;	// Hour (24hr) to activate (if day is active). e.g. 9 for 9AM
			
	int m_iBeginMinuteTime;

	int m_iEndHourTime;		// Hour (24hr) to inactivate. e.g. 1350
	
	int m_iEndMinuteTime;

	bool m_bEnable;

};

typedef CTypedPtrArray<CObArray,CHMRuleConfiguration*> RuleArray;

#endif // !defined(AFX_HMRULECONFIGURATION_H__B0D24258_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmpropertystatusinstance.h ===
// HMPropertyStatusInstance.h: interface for the CHMPropertyStatusInstance class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMPROPERTYSTATUSINSTANCE_H__A28C24E3_348F_11D3_BE18_0000F87A3912__INCLUDED_)
#define AFX_HMPROPERTYSTATUSINSTANCE_H__A28C24E3_348F_11D3_BE18_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMPropertyStatusInstance : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMPropertyStatusInstance)

// Construction/Destruction
public:
	CHMPropertyStatusInstance();
	virtual ~CHMPropertyStatusInstance();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Property Retreival Operations
public:
  HRESULT GetAllProperties();

// HMDataElementStatistics Properties
public:
	CString m_sInstanceName;
	CString m_sCurrentValue;
	CString m_sMinValue;
	CString m_sMaxValue;
	CString m_sAvgValue;
	
	long m_lCurrentValue;
	long m_lMinValue;
	long m_lMaxValue;
	long m_lAvgValue;
};

typedef CTypedPtrArray<CObArray,CHMPropertyStatusInstance*> PropertyStatusInstanceArray;

#endif // !defined(AFX_HMPROPERTYSTATUSINSTANCE_H__A28C24E3_348F_11D3_BE18_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmrulestatus.cpp ===
// HMRuleStatus.cpp: implementation of the CHMRuleStatus class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMRuleStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMEvent,CWbemClassObject)

IMPLEMENT_DYNCREATE(CHMRuleStatus,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMRuleStatus::CHMRuleStatus()
{
	m_iState = 2;
	m_sState.LoadString(IDS_STRING_UNKNOWN);
	m_sDataElementName.LoadString(IDS_STRING_NONE);
	m_ID = -1;
	m_iRuleCondition = -1;
	m_iRuleDuration = -1;
}

CHMRuleStatus::CHMRuleStatus(const CHMRuleStatus& HMRuleStatus)
{
	m_sSystemName = HMRuleStatus.m_sSystemName;
	m_sGuid = HMRuleStatus.m_sGuid;
	m_iState= HMRuleStatus.m_iState;
	m_ID= HMRuleStatus.m_ID;
	m_sDTime= HMRuleStatus.m_sDTime;
	m_iRuleCondition= HMRuleStatus.m_iRuleCondition;
	m_iRuleDuration= HMRuleStatus.m_iRuleDuration;

	m_sState= HMRuleStatus.m_sState;
	m_sDateTime= HMRuleStatus.m_sDateTime;
	m_st = HMRuleStatus.m_st;

	m_sDataElementName = HMRuleStatus.m_sDataElementName;

	for( int i = 0; i < HMRuleStatus.m_Instances.GetSize(); i++ )
	{
		m_Instances.Add( new CHMRuleStatusInstance(*HMRuleStatus.m_Instances[i]));
	}
}

CHMRuleStatus::~CHMRuleStatus()
{
	for( int i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_RolledUpRuleStatus[i],CHMEvent) )
		{
			delete m_RolledUpRuleStatus[i];
		}
	}
	m_RolledUpRuleStatus.RemoveAll();

	for( i = 0; i < m_Instances.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_Instances[i],CHMEvent) )
		{
			delete m_Instances[i];
		}
	}
	m_Instances.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleStatus::Create(const CString& sMachineName)
{
  HRESULT hr = CHMEvent::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMRuleStatus object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMThresholdStatus"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMRuleStatus::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CHMEvent::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleStatus::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleStatus::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;


	// GUID
  
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGuid);
	m_sGuid.TrimLeft(_T("{"));
	m_sGuid.TrimRight(_T("}"));
  

	// State
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	switch( m_iState )
	{
		case 0:
		{
			m_sState.LoadString(IDS_STRING_CRITICAL);			
		}
		break;

		case 1:
		{
			m_sState.LoadString(IDS_STRING_WARNING);
		}
		break;

		case 2:
		{
			m_sState.LoadString(IDS_STRING_NODATA);
		}
		break;

		case 3:
		{
			m_sState.LoadString(IDS_STRING_UNKNOWN);
		}
		break;

		case 4:
		{
			m_sState.LoadString(IDS_STRING_OUTAGE);
		}
		break;

		case 5:
		{
			m_sState.LoadString(IDS_STRING_DISABLED);
		}
		break;

		case 6:
		{
			m_sState.LoadString(IDS_STRING_INFORMATION);
		}
		break;

		case 7:
		{
			m_sState.LoadString(IDS_STRING_RESET);
		}
		break;

		case 8:
		{
			m_sState.LoadString(IDS_STRING_NORMAL);
		}
		break;
		
	}

	// ID
  
  
  hr = GetProperty(IDS_STRING_MOF_ID,m_ID);
  

	// DTime
  
	CTime time;  
  hr = GetProperty(IDS_STRING_MOF_LOCALTIME,time);
  
	time.GetAsSystemTime(m_st);

	CString sTime;
	CString sDate;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	m_sDateTime = sDate + _T("  ") + sTime;


	// Condition
  
  
  hr = GetProperty(IDS_STRING_MOF_CONDITION,m_iRuleCondition);
  

	// Duration
	
  
  hr = GetProperty(IDS_STRING_MOF_DURATION,m_iRuleDuration);


	// CompareValue

	hr = GetProperty(IDS_STRING_MOF_COMPAREVALUE,m_sCompareValue);
	
  
	// Instances
	
	
	hr = GetProperty(IDS_STRING_MOF_INSTANCES,m_instances);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_instances.GetLBound(1L,&lLower);
		m_instances.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_instances.GetElement(&i,&pIWBCO);
		if( pIWBCO )
		{
			CHMRuleStatusInstance* pRSI = new CHMRuleStatusInstance;
			pRSI->SetParent(this);
			pRSI->m_sSystemName = m_sSystemName;
			pRSI->m_sDataElementName = m_sDataElementName;
			pRSI->Create(pIWBCO);
			pRSI->GetAllProperties();
			m_Instances.Add(pRSI);
			pRSI->Destroy();
		}
	}

  return hr;
}


void CHMRuleStatus::RemoveStatusEvent(CHMEvent* pEvent)
{
	for( int i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( pEvent == m_RolledUpRuleStatus[i] )
		{
			m_RolledUpRuleStatus.RemoveAt(i);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmrulestatus.h ===
// HMRuleStatus.h: interface for the CHMRuleStatus class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMRULESTATUS_H__2C8B4D55_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
#define AFX_HMRULESTATUS_H__2C8B4D55_02FB_11D3_BDD8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMEvent : public CWbemClassObject
{
DECLARE_DYNCREATE(CHMEvent)

// Construction/Destruction
public:
	CHMEvent()
	{
		SYSTEMTIME st;
		m_pParent = NULL;
		m_ArrivalTime = CTime::GetCurrentTime();
		m_ArrivalTime.GetAsSystemTime(st);
		int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,NULL,0);
		iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&st,NULL,m_sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
		m_sTime.ReleaseBuffer();
		m_iNumberNormals = 0; // Number of Rules currently in normal state
		m_iNumberWarnings = 0; // Number of Rules currently in warning state
		m_iNumberCriticals = 0;// Number of Rules currently in critical state
	}
	~CHMEvent() { m_pParent = NULL; }

// Parent Members
protected:
	CHMEvent* m_pParent;
public:
	CHMEvent* GetParent() { return m_pParent; }
	void SetParent(CHMEvent* pParent) { m_pParent = pParent; }

// Rolled Up RuleStatus
public:
	virtual void RemoveStatusEvent(CHMEvent* pEvent) { ASSERT(pEvent); }
	CTypedPtrArray<CObArray,CHMEvent*> m_RolledUpRuleStatus;

// Console Timestamp
public:
	CTime m_ArrivalTime;	// arrival time at console
	CString m_sTime;

// Common Members
public:
	int				m_iNumberNormals; // Number of Rules currently in normal state
	int				m_iNumberWarnings; // Number of Rules currently in warning state
	int				m_iNumberCriticals;// Number of Rules currently in critical state
	CString		m_sSystemName;
};



class CHMRuleStatusInstance : public CHMEvent  
{
DECLARE_DYNCREATE(CHMRuleStatusInstance)

// Construction/Destruction
public:
	CHMRuleStatusInstance();
	CHMRuleStatusInstance(const CHMRuleStatusInstance& rsi);
	virtual ~CHMRuleStatusInstance();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();

// Properties of the Microsoft_HMRuleStatusInstance
public:
	CString	m_sGuid;
	CString m_sMessage; // Comes directly from what was in the Microsoft_HMRule property
	CString m_sInstanceName; // Instance name is applicable (e.g. C: drive)
	int m_iState;	// The state we are in.
	CString m_sCurrentValue; // Current value that caused the Rule crossing
	CString		m_sStatusGuid;
	CString		m_sDTime;	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. GMT minute
	int				m_ID;	// User viewable ID that shows up in the event so user can filter.

	// special property to track name of parent DataElement
	CString m_sDataElementName;

	CString		m_sState;
	CString		m_sDateTime;
	SYSTEMTIME m_st;

};

typedef CTypedPtrArray<CObArray,CHMRuleStatusInstance*> RuleStatusInstanceArray;



class CHMRuleStatus : public CHMEvent  
{
DECLARE_DYNCREATE(CHMRuleStatus)

// Construction/Destruction
public:
	CHMRuleStatus();
	CHMRuleStatus(const CHMRuleStatus& HMRuleStatus);
	virtual ~CHMRuleStatus();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();

// Microsoft_HMRuleStatus properties
public:
	CString		m_sRuleName;	// Name of the system
	CString		m_sGuid;
	int				m_iState;	// The state we are in - rollup from all Microsoft_HMDataGroups.
	int				m_ID;	// User viewable ID that shows up in the event so user can filter.
	CString		m_sDTime;	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. GMT minute
	int				m_iRuleCondition; // Condition that was used if the Rule crossing
	int				m_iRuleDuration; // How long the value must have remained
	CString		m_sCompareValue;

	COleSafeArray m_instances;
	RuleStatusInstanceArray m_Instances;

	// special property to track name of parent DataElement
	CString m_sDataElementName;


	CString		m_sState;
	CString		m_sDateTime;
	SYSTEMTIME m_st;

// Status Rollup Operations
public:
	void RemoveStatusEvent(CHMEvent* pEvent);
};

typedef CTypedPtrArray<CObArray,CHMRuleStatus*> RuleStatusArray;

#endif // !defined(AFX_HMRULESTATUS_H__2C8B4D55_02FB_11D3_BDD8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmrulestatusinstance.cpp ===
// HMRuleStatusInstance.cpp: implementation of the CHMRuleStatusInstance class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMRuleStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMRuleStatusInstance,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMRuleStatusInstance::CHMRuleStatusInstance()
{
	m_iState = 2;
	m_sState.LoadString(IDS_STRING_UNKNOWN);
	m_sMessage.LoadString(IDS_STRING_CONNECTED);
	m_sCurrentValue.LoadString(IDS_STRING_UNKNOWN);
}

CHMRuleStatusInstance::CHMRuleStatusInstance(const CHMRuleStatusInstance& rsi)
{
	m_sSystemName = rsi.m_sSystemName;
	m_sGuid = rsi.m_sGuid;
	m_ID= rsi.m_ID;
	m_sMessage = rsi.m_sMessage;
	m_sInstanceName = rsi.m_sInstanceName;
	m_iState = rsi.m_iState;
	m_sState = rsi.m_sState;
	m_sStatusGuid = rsi.m_sStatusGuid;
	m_sCurrentValue = rsi.m_sCurrentValue;
	m_sDateTime= rsi.m_sDateTime;
	m_st = rsi.m_st;

	m_sDataElementName = rsi.m_sDataElementName;
}

CHMRuleStatusInstance::~CHMRuleStatusInstance()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleStatusInstance::Create(const CString& sMachineName)
{
  HRESULT hr = CHMEvent::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMRuleStatus object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMThresholdStatusInstance"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMRuleStatusInstance::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CHMEvent::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleStatusInstance::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;


	// GUID
  
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGuid);
	m_sGuid.TrimLeft(_T("{"));
	m_sGuid.TrimRight(_T("}"));


	// StatusGUID

	hr = GetProperty(IDS_STRING_MOF_STATUSGUID,m_sStatusGuid);
	m_sStatusGuid.TrimLeft(_T("{"));
	m_sStatusGuid.TrimRight(_T("}"));


	// State
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	switch( m_iState )
	{
		case 0:
		{
			m_sState.LoadString(IDS_STRING_CRITICAL);			
		}
		break;

		case 1:
		{
			m_sState.LoadString(IDS_STRING_WARNING);
		}
		break;

		case 2:
		{
			m_sState.LoadString(IDS_STRING_NODATA);
		}
		break;

		case 3:
		{
			m_sState.LoadString(IDS_STRING_UNKNOWN);
		}
		break;

		case 4:
		{
			m_sState.LoadString(IDS_STRING_OUTAGE);
		}
		break;

		case 5:
		{
			m_sState.LoadString(IDS_STRING_DISABLED);
		}
		break;

		case 6:
		{
			m_sState.LoadString(IDS_STRING_INFORMATION);
		}
		break;

		case 7:
		{
			m_sState.LoadString(IDS_STRING_RESET);
		}
		break;

		case 8:
		{
			m_sState.LoadString(IDS_STRING_NORMAL);
		}
		break;
		
	}

	// Message
  
  
  hr = GetProperty(IDS_STRING_MOF_MESSAGE,m_sMessage);
  


	// CurrentValue
  
  
  hr = GetProperty(IDS_STRING_MOF_CURRENTVALUE,m_sCurrentValue);
  


	// InstanceName
	
  
  hr = GetProperty(IDS_STRING_MOF_INSTANCENAME,m_sInstanceName);


	// ID
  
  
  hr = GetProperty(IDS_STRING_MOF_ID,m_ID);
  

	// DTime
  
	CTime time;  
  hr = GetProperty(IDS_STRING_MOF_LOCALTIME,time);
  
	time.GetAsSystemTime(m_st);

	CString sTime;
	CString sDate;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	m_sDateTime = sDate + _T("  ") + sTime;
  

	// propogate the status back up to the HMSystemStatus instance
	// this gives us a roll up of status at each node in the tree
	CHMEvent* pParent = GetParent();
	CHMRuleStatusInstance* pStatus = NULL;
	while(pParent)
	{
		pStatus = new CHMRuleStatusInstance(*this);
		pStatus->SetParent(this);
		pParent->m_RolledUpRuleStatus.Add(pStatus);
		pParent = pParent->GetParent();
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmruleconfiguration.cpp ===
// HMRuleConfiguration.cpp: implementation of the CHMRuleConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMRuleConfiguration.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMRuleConfiguration,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMRuleConfiguration::CHMRuleConfiguration()
{
	m_iID = 0;
	m_iUseFlag = 0;
	m_iRuleCondition = 0;
	m_iRuleDuration = 0;
	m_iState = 0;
	m_bEnable = true;
}

CHMRuleConfiguration::~CHMRuleConfiguration()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleConfiguration::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMRuleConfiguration::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleConfiguration::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMRuleConfiguration::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Unique identifier
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGUID);
	m_sGUID.TrimLeft(_T("{"));
	m_sGUID.TrimRight(_T("}"));
  

	// Display name
  
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// Description
  
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,m_sDescription);
  

  hr = GetProperty(IDS_STRING_MOF_ID,m_iID);
  
	
	// What property to look at from the parent instance
  
  
  hr = GetProperty(IDS_STRING_MOF_PROPERTYNAME,m_sPropertyName);
  

	// Rules against the average value, not the current value.
  
  
  hr = GetProperty(IDS_STRING_MOF_USEFLAG,m_iUseFlag);
  


	// The condition to use for the Rule.
  
  
  hr = GetProperty(IDS_STRING_MOF_RULECONDITION,m_iRuleCondition);
  

	switch( m_iRuleCondition )
	{
		case 0:
		{
			m_sRuleCondition.LoadString(IDS_STRING_LESS_THAN);
		}
		break;

		case 1:
		{
			m_sRuleCondition.LoadString(IDS_STRING_GREATER_THAN);
		}
		break;

		case 2:
		{
			m_sRuleCondition.LoadString(IDS_STRING_EQUALS);
		}
		break;

		case 3:
		{
			m_sRuleCondition.LoadString(IDS_STRING_DOES_NOT_EQUAL);
		}
		break;

		case 4:
		{
			m_sRuleCondition.LoadString(IDS_STRING_GREATER_THAN_EQUAL_TO);
		}
		break;

		case 5:
		{
			m_sRuleCondition.LoadString(IDS_STRING_LESS_THAN_EQUAL_TO);
		}
		break;

		case 6:
		{
			m_sRuleCondition.LoadString(IDS_STRING_CONTAINS);
		}
		break;

		case 7:
		{
			m_sRuleCondition.LoadString(IDS_STRING_DOES_NOT_CONTAIN);
		}
		break;
	}

	// Value to use for Rule.
  
  
  hr = GetProperty(IDS_STRING_MOF_RULEVALUE,m_sRuleValue);
  

	// How long the value must remain. In
  
  
  hr = GetProperty(IDS_STRING_MOF_RULEDURATION,m_iRuleDuration);
  

	// The state we transition to if cross Rule.
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	switch( m_iState )
	{
		case 0:
		{
			m_sState.LoadString(IDS_STRING_CRITICAL);
		}
		break;

		case 1:
		{
			m_sState.LoadString(IDS_STRING_WARNING);
		}
		break;

		case 2:
		{
			m_sState.LoadString(IDS_STRING_INFORMATION);
		}
		break;

		case 3:
		{
			m_sState.LoadString(IDS_STRING_RESET);
		}
		break;
	}

	// Time of origional creation
  
  
  hr = GetProperty(IDS_STRING_MOF_CREATIONDATE,m_sCreationDate);
  

	// Time of last change
  
  
  hr = GetProperty(IDS_STRING_MOF_LASTUPDATE,m_sLastUpdate);
  

	// What gets sent to the event. Can contain special
  
  
  hr = GetProperty(IDS_STRING_MOF_MESSAGE,m_sMessage);
  

  // Enable
  
  
  hr = GetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  

  return hr;
}

HRESULT CHMRuleConfiguration::SaveEnabledProperty()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

  // Enable
  CString sProperty;
  
  
  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  
  ASSERT(SUCCEEDED(hr));

  hr = SaveAllProperties();
  ASSERT(SUCCEEDED(hr));

  return hr;
}

HRESULT CHMRuleConfiguration::SaveAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Unique identifier
  
  
//  hr = SetProperty(IDS_STRING_MOF_GUID,m_sGUID);
  

	// Display name
  
  
  hr = SetProperty(IDS_STRING_MOF_NAME,m_sName);
  

	// Description
  
  
  hr = SetProperty(IDS_STRING_MOF_DESCRIPTION,m_sDescription);
  

  
  hr = SetProperty(IDS_STRING_MOF_ID,m_iID);
  
	
	// What property to look at from the parent instance
  
  
  hr = SetProperty(IDS_STRING_MOF_PROPERTYNAME,m_sPropertyName);
  

	// Rule against the change, not the current
  
  
  hr = SetProperty(IDS_STRING_MOF_USEFLAG,m_iUseFlag);
  


	// The condition to use for the Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_RULECONDITION,m_iRuleCondition);
  

	// Value to use for Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_RULEVALUE,m_sRuleValue);
  

	// How long the value must remain. In
  
  
  hr = SetProperty(IDS_STRING_MOF_RULEDURATION,m_iRuleDuration);
  

	// The state we transition to if cross Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	// Time of origional creation
  
  
  hr = SetProperty(IDS_STRING_MOF_CREATIONDATE,m_sCreationDate);
  

	// Time of last change
  
  
  hr = SetProperty(IDS_STRING_MOF_LASTUPDATE,m_sLastUpdate);
  

	// What gets sent to the event. Can contain special
  
  
  hr = SetProperty(IDS_STRING_MOF_MESSAGE,m_sMessage);
  


  // Enable
  
  
  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  

	hr = CWbemClassObject::SaveAllProperties();

	CHECKHRESULT(hr);

  return hr;
}

HRESULT CHMRuleConfiguration::SaveAllExpressionProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Value to use for Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_RULEVALUE,m_sRuleValue);
  

	// The state we transition to if cross Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	// The condition to use for the Rule.
  
  
  hr = SetProperty(IDS_STRING_MOF_RULECONDITION,m_iRuleCondition);
  

	// What property to look at from the parent instance
  
  
  hr = SetProperty(IDS_STRING_MOF_PROPERTYNAME,m_sPropertyName);
  

	// Rules against the average value, not the current value.
  
  
  hr = SetProperty(IDS_STRING_MOF_USEFLAG,m_iUseFlag);
  


 	hr = CWbemClassObject::SaveAllProperties();

	CHECKHRESULT(hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmscopeitem.h ===
// HMScopeItem.h: interface for the CHMScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMSCOPEITEM_H__7265EAF9_CCCB_11D2_BD91_0000F87A3912__INCLUDED_)
#define AFX_HMSCOPEITEM_H__7265EAF9_CCCB_11D2_BD91_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ScopePaneItem.h"

class CHMObject;

class CHMScopeItem : public CScopePaneItem  
{

DECLARE_DYNCREATE(CHMScopeItem)

// Construction/Destruction
public:
	CHMScopeItem();
	virtual ~CHMScopeItem();

// State Management
public:
	virtual int OnChangeChildState(int iNewState);

// MMC-Related Item Members
public:
	bool InsertItem(int iIndex);
	bool DeleteItem();
	bool SetItem();
	virtual HRESULT WriteExtensionData(LPSTREAM pStream);

// Back Pointer to HMObject
public:
	CHMObject* GetObjectPtr();
	void SetObjectPtr(CHMObject* pObject);
protected:
	CHMObject* m_pObject;

// MMC Notify Handlers
public:
	virtual HRESULT OnCutOrMove();
	virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnDelete(BOOL bConfirm=TRUE); // v-marfin 60298	
	virtual HRESULT OnExpand(BOOL bExpand);
	virtual HRESULT OnPaste(LPDATAOBJECT pSelectedItems, LPDATAOBJECT* ppCopiedItems);
	virtual HRESULT OnQueryPaste(LPDATAOBJECT pDataObject);
	virtual HRESULT OnRefresh();
	virtual HRESULT OnRename(const CString& sNewName);
};

#include "HMScopeItem.inl"

#endif // !defined(AFX_HMSCOPEITEM_H__7265EAF9_CCCB_11D2_BD91_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmscopeitem.inl ===
// HMScopeItem.inl: inlines for the CHMScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Back Pointer to HMObject
//////////////////////////////////////////////////////////////////////

inline CHMObject* CHMScopeItem::GetObjectPtr()
{
	TRACEX(_T("CHMScopeItem::GetObjectPtr\n"));

	return m_pObject;
}

inline void CHMScopeItem::SetObjectPtr(CHMObject* pObject)
{
	TRACEX(_T("CHMScopeItem::SetObjectPtr\n"));
	TRACEARGn(pObject);

	m_pObject = pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmscopeitem.cpp ===
// HMScopeItem.cpp: implementation of the CHMScopeItem class.
//
//////////////////////////////////////////////////////////////////////
//
// 04/07/00 v-marfin 62985 : do not allow paste into yourself
//
//
//
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "HMScopeItem.h"
#include "HMObject.h"
#include "ScopePane.h"
#include "SplitPaneResultsView.h"
#include "HMResultsPaneItem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMScopeItem,CScopePaneItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMScopeItem::CHMScopeItem()
{
	m_pObject = NULL;
  m_sHelpTopic = _T("HMon21.chm::/ostart.htm");
}

CHMScopeItem::~CHMScopeItem()
{
	CHMObject* pObject = GetObjectPtr();
	if( pObject )
	{
		for( int i = 0; i < pObject->GetScopeItemCount(); i++ )
		{
			if( pObject->GetScopeItem(i) == this )
			{
				pObject->RemoveScopeItem(i);
				break;
			}
		}
	}
	Destroy();

}

/////////////////////////////////////////////////////////////////////////////
// State Management
/////////////////////////////////////////////////////////////////////////////

int CHMScopeItem::OnChangeChildState(int iNewState)
{
	TRACEX(_T("CHMScopeItem::OnChangeChildState\n"));
	TRACEARGn(iNewState);

	// walk the list of children and determine the final state we should assume
	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		CHMScopeItem* pItem = (CHMScopeItem*)(m_Children[i]);
		int iItemState = pItem->GetIconIndex();
		if( iItemState > iNewState )
		{
			if( iItemState == GetIconIndex() )
			{
				return iItemState;
			}
			else
			{
				iNewState = iItemState;
			}
		}
	}

	SetIconIndex(iNewState);
	SetOpenIconIndex(iNewState);
	SetItem();

	// if the parent is an HMScopeItem, inform it of the state change
	CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();
	if( pParentItem && GfxCheckObjPtr(pParentItem,CHMScopeItem) )
	{
		pParentItem->OnChangeChildState(iNewState);
	}

	return iNewState;
}

/////////////////////////////////////////////////////////////////////////////
// MMC-Related Item Members
/////////////////////////////////////////////////////////////////////////////

bool CHMScopeItem::InsertItem( int iIndex )
{
	TRACEX(_T("CHMScopeItem::InsertItem\n"));
	
	bool bResult = CScopePaneItem::InsertItem(iIndex);

	// if the parent is the current selected scope item
	// and the parent's results view is of type CSplitPaneResultsView
	// and there is no results item for this scope item in the split pane
	// then add a new CHMResultsPaneItem to the results view for this scope item

	CScopePane* pPane = GetScopePane();

	if( pPane == NULL )
	{
		ASSERT(FALSE);
		return bResult;
	}

	if( !pPane->GetSelectedScopeItem() || !GetParent() || pPane->GetSelectedScopeItem() != GetParent() )
	{
		return bResult;
	}

	CResultsPaneView* pView = GetParent()->GetResultsPaneView();
	if( ! pView || ! pView->IsKindOf(RUNTIME_CLASS(CSplitPaneResultsView)) )
	{
		return bResult;
	}

	for( int i = 0; i < pView->GetItemCount(); i++ )
	{
		if( pView->GetItem(i)->GetDisplayName() == GetDisplayName() )
		{
			return bResult;
		}
	}

	CHMResultsPaneItem* pHMRPI = new CHMResultsPaneItem;
	CStringArray saNames;
	saNames.Copy(GetDisplayNames());
	CUIntArray iaIconIds;
	iaIconIds.Copy(GetIconIds());
	pHMRPI->Create(pView,saNames,iaIconIds,GetIconIndex());
	pHMRPI->SetToUpperPane();
	pView->AddItem(pHMRPI);
	return bResult;
}

bool CHMScopeItem::DeleteItem()
{
	TRACEX(_T("CHMScopeItem::DeleteItem\n"));

	bool bResult = CScopePaneItem::DeleteItem();

	return bResult;
}

bool CHMScopeItem::SetItem()
{
	TRACEX(_T("CHMScopeItem::SetItem\n"));

	bool bResult = CScopePaneItem::SetItem();

	CScopePane* pPane = GetScopePane();

	if( pPane == NULL )
	{
		ASSERT(FALSE);
		return bResult;
	}

	if( !pPane->GetSelectedScopeItem() || !GetParent() || pPane->GetSelectedScopeItem() != GetParent() )
	{
		return bResult;
	}

	CResultsPaneView* pView = GetParent()->GetResultsPaneView();
	if( ! pView || ! pView->IsKindOf(RUNTIME_CLASS(CSplitPaneResultsView)) )
	{
		return bResult;
	}

	for( int i = 0; i < pView->GetItemCount(); i++ )
	{
		if( pView->GetItem(i)->GetDisplayName() == GetDisplayName() )
		{
			CStringArray saNames;
			saNames.Copy(GetDisplayNames());
			CUIntArray iaIconIds;
			iaIconIds.Copy(GetIconIds());
			pView->GetItem(i)->SetDisplayNames(saNames);
			pView->GetItem(i)->SetIconIds(iaIconIds);
			pView->GetItem(i)->SetIconIndex(GetIconIndex());
			return pView->UpdateItem(pView->GetItem(i)) && bResult;
		}
	}

	return bResult;
}

HRESULT CHMScopeItem::WriteExtensionData(LPSTREAM pStream)
{
	TRACEX(_T("CHMScopeItem::WriteExtensionData\n"));
	TRACEARGn(pStream);

	HRESULT hr = S_OK;

	ULONG ulSize = GetObjectPtr()->GetSystemName().GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(GetObjectPtr()->GetSystemName(), ulSize, NULL)) )
	{
		return hr;
	}

	ulSize = GetObjectPtr()->GetObjectPath().GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(GetObjectPtr()->GetObjectPath(), ulSize, NULL)) )
	{
		return hr;
	}

	ulSize = GetObjectPtr()->GetGuid().GetLength() + 1;
	ulSize *= sizeof(TCHAR);
	if( ! CHECKHRESULT(hr = pStream->Write(GetObjectPtr()->GetGuid(), ulSize, NULL)) )
	{
		return hr;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////

HRESULT CHMScopeItem::OnCutOrMove()
{
	TRACEX(_T("CHMScopeItem::OnCutOrMove\n"));

	HRESULT hr = S_OK;

	/*if( ! CHECKHRESULT(hr = CHMScopeItem::OnCutOrMove()) )
	{
		return hr;
	}*/

	return hr;
}

HRESULT CHMScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CHMScopeItem::OnCutOrMove\n"));

	HRESULT hr = S_OK;

	CHMObject* pObject = GetObjectPtr();
	if( ! pObject )
	{
		return E_FAIL;
	}

	switch( lCommandID )
	{
		case IDM_CLEAR_EVENTS:
		{
			if( AfxMessageBox(IDS_STRING_WARN_CLEAR_EVENTS,MB_YESNO) == IDYES )
			{
				pObject->ClearEvents();
				SelectItem();
			}
		}
		break;

		case IDM_RESET_STATUS:
		{
			pObject->ResetStatus();
		}
		break;

		case IDM_RESET_STATISTICS:
		{
			pObject->ResetStatistics();
		}
		break;

		case IDM_DISABLE_MONITORING:
		{
			if( pObject->IsEnabled() )
			{
				pObject->Disable();
			}
			else
			{
				pObject->Enable();
			}
		}
		break;

		case IDM_CHECK_NOW:
		{
			pObject->CheckNow();
		}
		break;

    case IDM_ICON_LEGEND:
    {
      CScopePane* pPane = GetScopePane();
      if( pPane )
      {
        hr = pPane->ShowTopic(_T("HMon21.chm::/cicons.htm"));
      }
    }
    break;

		default:
		{
			hr = CScopePaneItem::OnCommand(lCommandID);
		}

	}

	return hr;
}

HRESULT CHMScopeItem::OnDelete(BOOL bConfirm)  // v-marfin 60298
{
	TRACEX(_T("CHMScopeItem::OnDelete\n"));

	HRESULT hr = CScopePaneItem::OnDelete();
	if( ! CHECKHRESULT(hr) )
	{
		return hr;
	}	

	CHMObject* pObject = GetObjectPtr();

	if( ! pObject )
	{
		return E_FAIL;
	}

	CString sMsg;
	sMsg.Format(IDS_STRING_WARN_DELETE,pObject->GetUITypeName(),pObject->GetUITypeName());	

	if ((bConfirm) && ( AfxMessageBox(sMsg,MB_YESNO) != IDYES ))
	{
		return S_FALSE;
	}

	// first query all the scope items and see if any have open property sheets
	for( int i = 0; i < pObject->GetScopeItemCount(); i++ )
	{
		if( pObject->GetScopeItem(i)->IsPropertySheetOpen(true) )
		{
			AfxMessageBox(IDS_STRING_WARN_PROPPAGE_OPEN);
			return S_OK;
		}
	}

	for( i = pObject->GetScopeItemCount()-1; i >= 0 ; i-- )
	{
		CHMScopeItem* pParentItem = (CHMScopeItem*)pObject->GetScopeItem(i)->GetParent();
		if( pParentItem && GfxCheckObjPtr(pParentItem,CHMScopeItem) )
		{
			pParentItem->DestroyChild(pObject->GetScopeItem(i));
			pParentItem->OnChangeChildState(HMS_NORMAL);

			if( i == 0 )
			{			
				CHMObject* pParentObject = pParentItem->GetObjectPtr();
				pParentObject->RemoveChild(pObject);
			}
		}
	}

	pObject->Destroy(true);

	delete pObject;

	return S_OK;
}

HRESULT CHMScopeItem::OnExpand(BOOL bExpand)
{
	TRACEX(_T("CHMScopeItem::OnExpand\n"));
	TRACEARGn(bExpand);

	if( ! GetObjectPtr() )
	{
		return E_FAIL;
	}

	if( GetChildCount() == 0 )
	{
		m_pObject->EnumerateChildren();
	}

	return CScopePaneItem::OnExpand(bExpand);;
}

HRESULT CHMScopeItem::OnPaste(LPDATAOBJECT pSelectedItems, LPDATAOBJECT* ppCopiedItems)
{
	TRACEX(_T("CHMScopeItem::OnPaste\n"));
	TRACEARGn(pSelectedItems);
	TRACEARGn(ppCopiedItems);

	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = CScopePaneItem::OnPaste(pSelectedItems, ppCopiedItems)) )
	{
		return hr;
	}

	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(pSelectedItems);
	
	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	if( psdo->GetItemType() != CCT_SCOPE )
	{
		return E_FAIL;
	}

	CScopePaneItem* pItem = NULL;
	if( ! psdo->GetItem(pItem) )
	{
		return E_FAIL;
	}

	ASSERT(pItem);

	if( ! GetObjectPtr()->Paste(((CHMScopeItem*)pItem)->GetObjectPtr(),ppCopiedItems == NULL) )
	{
		return E_FAIL;
	}


	return hr;
}

HRESULT CHMScopeItem::OnQueryPaste(LPDATAOBJECT pDataObject)
{
	TRACEX(_T("CHMScopeItem::OnQueryPaste\n"));
	TRACEARGn(pDataObject);

	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = CScopePaneItem::OnQueryPaste(pDataObject)) )
	{
		return hr;
	}

	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(pDataObject);
	
	if( psdo == NULL || ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	if( psdo->GetItemType() != CCT_SCOPE )
	{
		return E_FAIL;
	}

	CScopePaneItem* pItem = NULL;
	if( ! psdo->GetItem(pItem) )
	{
		return E_FAIL;
	}

	ASSERT(pItem);

    // 62985 : do not allow paste into yourself
    if (this == pItem)
    {
        return E_FAIL;
    }

	if( ! GetObjectPtr()->QueryPaste(((CHMScopeItem*)pItem)->GetObjectPtr()) )
	{
		return S_FALSE;
	}

	return hr;
}

HRESULT CHMScopeItem::OnRefresh()
{
	TRACEX(_T("CHMScopeItem::OnRefresh\n"));

	CHMObject* pObject = GetObjectPtr();

	if( ! pObject )
	{
		return E_FAIL;
	}

	if( IsPropertySheetOpen(true) )
	{
		AfxMessageBox(IDS_STRING_WARN_PROPPAGE_OPEN);
		return S_FALSE;
	}

	if( ! pObject->Refresh() )
	{
		return E_FAIL;
	}

	SelectItem();

	return S_OK;
}

HRESULT CHMScopeItem::OnRename(const CString& sNewName)
{
	TRACEX(_T("CHMScopeItem::OnRename\n"));

	if( ! m_pObject->Rename(sNewName) )
	{
		return S_FALSE;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsnapinabout.cpp ===
// HMSnapinAbout.cpp: implementation of the CHMSnapinAbout class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMSnapinAbout.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMSnapinAbout,CSnapinAbout)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMSnapinAbout::CHMSnapinAbout()
{

}

CHMSnapinAbout::~CHMSnapinAbout()
{

}

//////////////////////////////////////////////////////////////////////
// Overrideable Members
//////////////////////////////////////////////////////////////////////

HRESULT CHMSnapinAbout::OnGetStaticFolderImage(HBITMAP __RPC_FAR * hSmallImage,HBITMAP __RPC_FAR * hSmallImageOpen,HBITMAP __RPC_FAR * hLargeImage,COLORREF __RPC_FAR * cMask)
{
	TRACEX(_T("CHMSnapinAbout::OnGetStaticFolderImage\n"));
  TRACEARGn(hSmallImage);
  TRACEARGn(hSmallImageOpen);
  TRACEARGn(hLargeImage);
  TRACEARGn(cMask);

	CBitmap bitmap;
	
	bitmap.LoadBitmap(IDB_BITMAP_HEALTHMON_SMALL);
	*hSmallImage = bitmap;
	bitmap.Detach();
	
	bitmap.LoadBitmap(IDB_BITMAP_HEALTHMON_SMALL);
	*hSmallImageOpen = bitmap;
	bitmap.Detach();

	bitmap.LoadBitmap(IDB_BITMAP_HEALTHMON_LARGE);
	*hLargeImage = bitmap;	
	bitmap.Detach();

	*cMask = RGB(255,0,255);

	return S_OK;
}

void CHMSnapinAbout::OnGetSnapinDescription(CString& sDescription)
{
	TRACEX(_T("CHMSnapinAbout::OnGetSnapinDescription\n"));
	TRACEARGs(sDescription);
}

HRESULT CHMSnapinAbout::OnGetSnapinImage(HICON __RPC_FAR *hAppIcon)
{
	TRACEX(_T("CHMSnapinAbout::OnGetSnapinImage\n"));
	TRACEARGn(hAppIcon);

	*hAppIcon = AfxGetApp()->LoadIcon(IDI_ICON_HEALTHMON);

	return S_OK;
}

// {80F85332-AB10-11D2-BD62-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CHMSnapinAbout, "SnapIn.SnapinAbout", 0x80f85332, 0xab10, 0x11d2, 0xbd, 0x62, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CHMSnapinAbout::CHMSnapinAboutFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmstatistics.h ===
// HMStatistics.h: interface for the CHMStatistics class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMSTATISTICS_H__8F327D2B_909C_11D3_BE87_0000F87A3912__INCLUDED_)
#define AFX_HMSTATISTICS_H__8F327D2B_909C_11D3_BE87_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Statistics.h"

class CHMStatistics : public CStatistics  
{

DECLARE_DYNCREATE(CHMStatistics)

// Construction/Destruction
public:
	CHMStatistics();
	virtual ~CHMStatistics();

// Counts of State for immediate children
public:
	int m_iNumberNormals;
	int m_iNumberWarnings;
	int m_iNumberCriticals;
	int m_iNumberUnknowns;

// Name
public:
	CString m_sName;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView);

// Graph Members
public:
	virtual void UpdateGraph(_DHMGraphView* pGraphView);

// Equivalence operator
public:
	virtual int CompareTo(CStatistics* pStat);

};

#include "HMStatistics.inl"

#endif // !defined(AFX_HMSTATISTICS_H__8F327D2B_909C_11D3_BE87_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmstatistics.cpp ===
// HMStatistics.cpp: implementation of the CHMStatistics class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMStatistics.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMStatistics,CStatistics)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMStatistics::CHMStatistics()
{
	m_iNumberNormals = 0;
	m_iNumberWarnings = 0;
	m_iNumberCriticals = 0;
	m_iNumberUnknowns = 0;
}

CHMStatistics::~CHMStatistics()
{
	m_iNumberNormals = 0;
	m_iNumberWarnings = 0;
	m_iNumberCriticals = 0;
	m_iNumberUnknowns = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmstatistics.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CompareTo
//////////////////////////////////////////////////////////////////////

inline int CHMStatistics::CompareTo(CStatistics* pStat)
{
	CHMStatistics* pHMStat = (CHMStatistics*)pStat;

	CTime time1 = m_st;
	CTime time2 = pHMStat->m_st;

	return	time1 == time2 && 
					m_iNumberNormals == pHMStat->m_iNumberNormals &&
					m_iNumberWarnings == pHMStat->m_iNumberWarnings &&
					m_iNumberCriticals == pHMStat->m_iNumberCriticals &&
					m_iNumberUnknowns == pHMStat->m_iNumberUnknowns;
}

//////////////////////////////////////////////////////////////////////
// Result Pane Item Members
//////////////////////////////////////////////////////////////////////

inline CHMEventResultsPaneItem* CHMStatistics::CreateResultsPaneItem(CResultsPaneView* pView)
{
	ASSERT(pView);
	if( ! pView )
	{
		return NULL;
	}

	CHMEventResultsPaneItem* pItem = new CHMEventResultsPaneItem;
	pItem->SetDateTimeColumn(HMLV_STATS_DTIME_INDEX);

	CStringArray saNames;
	CUIntArray uiaIconResIds;
	CString sValue;

	saNames.Add(GetStatLocalTime());

	sValue.Format(_T("%d"),m_iNumberNormals);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iNumberWarnings);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iNumberCriticals);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iNumberUnknowns);
	saNames.Add(sValue);

	pItem->m_st = m_st;
			
	pItem->SetDisplayNames(saNames);
	pItem->SetToStatsPane();

	pItem->Create(pView);

	return pItem;
}

//////////////////////////////////////////////////////////////////////
// Graph Members
//////////////////////////////////////////////////////////////////////

inline void CHMStatistics::UpdateGraph(_DHMGraphView* pGraphView)
{
	// v-marfin : As long as there is no graph view remove the assert
    //            since it is getting in the way of debugging.
    //ASSERT(pGraphView);

	if( ! pGraphView )
	{
		return;
	}

	long lStyle = pGraphView->GetStyle();
	if( lStyle & HMGVS_CURRENT )
	{
		pGraphView->InsertCurrentGroupStats(m_sName,m_iNumberNormals,m_iNumberWarnings,m_iNumberCriticals,m_iNumberUnknowns);
	}

	if( lStyle & HMGVS_HISTORIC )
	{
		CString sLocalTime = GetStatLocalTime();
		int iIndex = sLocalTime.Find(_T(" "));
		if( iIndex != -1 )
		{
			sLocalTime = sLocalTime.Right(sLocalTime.GetLength()-iIndex-1);
		}
		pGraphView->InsertHistoricGroupStats(m_sName,sLocalTime,m_iNumberNormals,m_iNumberWarnings,m_iNumberCriticals,m_iNumberUnknowns);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsnapinabout.h ===
// HMSnapinAbout.h: interface for the CHMSnapinAbout class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMSNAPINABOUT_H__6F1C1CC3_C1EE_11D2_BD81_0000F87A3912__INCLUDED_)
#define AFX_HMSNAPINABOUT_H__6F1C1CC3_C1EE_11D2_BD81_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SnapinAbout.h"

class CHMSnapinAbout : public CSnapinAbout  
{

DECLARE_DYNCREATE(CHMSnapinAbout)

// Construction/Destruction
public:
	CHMSnapinAbout();
	virtual ~CHMSnapinAbout();

// Overrideable Members
protected:
	virtual HRESULT OnGetStaticFolderImage(HBITMAP __RPC_FAR * hSmallImage,HBITMAP __RPC_FAR * hSmallImageOpen,HBITMAP __RPC_FAR * hLargeImage,COLORREF __RPC_FAR * cMask);
	virtual void OnGetSnapinDescription(CString& sDescription);
	virtual HRESULT OnGetSnapinImage(HICON __RPC_FAR *hAppIcon);

// MFC Implementation
protected:
	DECLARE_OLECREATE_EX(CHMSnapinAbout)
};

#endif // !defined(AFX_HMSNAPINABOUT_H__6F1C1CC3_C1EE_11D2_BD81_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsystem.h ===
// HMSystem.h: interface for the CHMSystem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMSYSTEM_H__B0D24253_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
#define AFX_HMSYSTEM_H__B0D24253_F80C_11D2_BDC8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemClassObject.h"

class CHMSystemConfiguration : public CWbemClassObject  
{

DECLARE_DYNCREATE(CHMSystemConfiguration)

// Construction/Destruction
public:
	CHMSystemConfiguration();
	virtual ~CHMSystemConfiguration();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();
  HRESULT SaveEnabledProperty();

// HMSystemConfiguration Attributes
public:
	bool m_bEnable;
	CString m_sGuid;
};


#endif // !defined(AFX_HMSYSTEM_H__B0D24253_F80C_11D2_BDC8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsystem.cpp ===
// HMSystem.cpp: implementation of the CHMSystemConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMSystem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMSystemConfiguration,CWbemClassObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMSystemConfiguration::CHMSystemConfiguration()
{
	m_bEnable = 1;
}

CHMSystemConfiguration::~CHMSystemConfiguration()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemConfiguration::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMSystemConfiguration object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMSystemConfiguration"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMSystemConfiguration::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemConfiguration::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemConfiguration::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

  // Enable
  
  hr = GetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  
	// GUID
  
  hr = GetProperty(IDS_STRING_MOF_GUID,m_sGuid);
	m_sGuid.TrimLeft(_T("{"));
	m_sGuid.TrimRight(_T("}"));

  return hr;
}

HRESULT CHMSystemConfiguration::SaveEnabledProperty()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

  // Enable
  
  hr = SetProperty(IDS_STRING_MOF_ENABLE,m_bEnable);
  
  ASSERT(SUCCEEDED(hr));

  hr = SaveAllProperties();
  ASSERT(SUCCEEDED(hr));

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsystemstatus.cpp ===
// HMSystemStatus.cpp: implementation of the CHMSystemStatus class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "HMSystemStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CHMSystemStatus,CHMEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHMSystemStatus::CHMSystemStatus()
{
	m_iNumberWarnings = 0; // Number of Rules currently in critical state
	m_iNumberCriticals = 0;// Number of Rules currently in warning state
	m_iState = 2;	// The state we are in - rollup from all Microsoft_HMDataGroups.
}

CHMSystemStatus::~CHMSystemStatus()
{
	for( int i = 0; i < m_DGStatus.GetSize(); i++ )
	{
		delete m_DGStatus[i];
	}
	m_DGStatus.RemoveAll();

	for( i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_RolledUpRuleStatus[i],CHMEvent) )
		{
			delete m_RolledUpRuleStatus[i];
		}
	}
	m_RolledUpRuleStatus.RemoveAll();

	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemStatus::Create(const CString& sMachineName)
{
  HRESULT hr = CWbemClassObject::Create(sMachineName);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  // create the enumerator for Microsoft_HMSystemStatus object instances
  BSTR bsClass = SysAllocString(_T("Microsoft_HMSystemStatus"));
  hr = CreateEnumerator(bsClass);
  SysFreeString(bsClass);

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CHMSystemStatus::Create(IWbemClassObject* pObject)
{
  HRESULT hr = CWbemClassObject::Create(pObject);
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Enumeration Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemStatus::EnumerateObjects(ULONG& uReturned)
{
  // call GetNextObject to proceed to the next object instance
  HRESULT hr = GetNextObject(uReturned);
  if( FAILED(hr) || uReturned != 1 )
  {
    // no more instances
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(0);
    return S_FALSE;
  }

  // process the properties of this object
  hr = GetAllProperties();

  return hr;
}

//////////////////////////////////////////////////////////////////////
// Property Retrieval Operations
//////////////////////////////////////////////////////////////////////

HRESULT CHMSystemStatus::GetAllProperties()
{
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  HRESULT hr = S_OK;

	// Name
  
  hr = GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sName);
  

  
	// NumberNormals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERNORMALS,m_iNumberNormals);

	// NumberWarnings
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERWARNINGS,m_iNumberWarnings);
  

	// NumberCriticals
  
  
  hr = GetProperty(IDS_STRING_MOF_NUMBERCRITICALS,m_iNumberCriticals);
  

	// State
  
  
  hr = GetProperty(IDS_STRING_MOF_STATE,m_iState);
  

	// DataGroups
	
	
	hr = GetProperty(IDS_STRING_MOF_DATAGROUPS,m_DataGroups);
	

	long lLower = 0L;
	long lUpper = -1L;

	if( hr != S_FALSE )
	{
		m_DataGroups.GetLBound(1L,&lLower);
		m_DataGroups.GetUBound(1L,&lUpper);
	}

	for( long i = lLower; i <= lUpper; i++ )
	{
		IWbemClassObject* pIWBCO = NULL;
		m_DataGroups.GetElement(&i,&pIWBCO);
		CHMDataGroupStatus* pDGS = new CHMDataGroupStatus;
		pDGS->SetParent(this);
		pDGS->m_sSystemName = m_sSystemName;
		pDGS->Create(pIWBCO);
		pDGS->GetAllProperties();
		m_DGStatus.Add(pDGS);
	}

  return hr;
}

void CHMSystemStatus::RemoveStatusEvent(CHMEvent* pEvent)
{
	for( int i = 0; i < m_RolledUpRuleStatus.GetSize(); i++ )
	{
		if( pEvent == m_RolledUpRuleStatus[i] )
		{
			m_RolledUpRuleStatus.RemoveAt(i);
			break;
		}
	}

	for( i = 0; i < m_DGStatus.GetSize(); i++ )
	{
		m_DGStatus[i]->RemoveStatusEvent(pEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmsystemstatus.h ===
// HMSystemStatus.h: interface for the CHMSystemStatus class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HMSYSTEMSTATUS_H__3779B729_FD95_11D2_BDCF_0000F87A3912__INCLUDED_)
#define AFX_HMSYSTEMSTATUS_H__3779B729_FD95_11D2_BDCF_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMDataGroupStatus.h"

class CHMSystemStatus : public CHMEvent  
{

DECLARE_DYNCREATE(CHMSystemStatus)

// Construction/Destruction
public:
	CHMSystemStatus();
	virtual ~CHMSystemStatus();

// Create
public:
  HRESULT Create(const CString& sMachineName);
  HRESULT Create(IWbemClassObject* pObject);

// Enumeration Operations
public:
  HRESULT EnumerateObjects(ULONG& uReturned); // rentrant...continue to call until uReturned == 0

// Property Retreival Operations
public:
  virtual HRESULT GetAllProperties();

// Microsoft_HMSystemStatus properties
public:
	CString		m_sName;	// Name of the system
	int				m_iState;	// The state we are in - rollup from all Microsoft_HMDataGroups.
	COleSafeArray m_DataGroups;

	DataGroupStatusArray m_DGStatus;	

// Status Rollup Operations
public:
	void RemoveStatusEvent(CHMEvent* pEvent);
};

#endif // !defined(AFX_HMSYSTEMSTATUS_H__3779B729_FD95_11D2_BDCF_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmtabview.h ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// _DHMTabView wrapper class

class _DHMTabView : public COleDispatchDriver
{
public:
	_DHMTabView() {}		// Calls COleDispatchDriver default constructor
	_DHMTabView(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DHMTabView(const _DHMTabView& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	BOOL InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lImage, long lParam);
	BOOL DeleteItem(long lItem);
	BOOL DeleteAllItems();
	BOOL CreateControl(long lItem, LPCTSTR lpszControlID);
	LPUNKNOWN GetControl(long lItem);
	void AboutBox();
};
/////////////////////////////////////////////////////////////////////////////
// _DHMTabViewEvents wrapper class

class _DHMTabViewEvents : public COleDispatchDriver
{
public:
	_DHMTabViewEvents() {}		// Calls COleDispatchDriver default constructor
	_DHMTabViewEvents(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DHMTabViewEvents(const _DHMTabViewEvents& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\hmtabview.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "hmtabview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// _DHMTabView properties

/////////////////////////////////////////////////////////////////////////////
// _DHMTabView operations

BOOL _DHMTabView::InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lImage, long lParam)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lMask, lItem, lpszItem, lImage, lParam);
	return result;
}

BOOL _DHMTabView::DeleteItem(long lItem)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lItem);
	return result;
}

BOOL _DHMTabView::DeleteAllItems()
{
	BOOL result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_BOOL, (void*)&result, NULL);
	return result;
}

BOOL _DHMTabView::CreateControl(long lItem, LPCTSTR lpszControlID)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_BSTR;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lItem, lpszControlID);
	return result;
}

LPUNKNOWN _DHMTabView::GetControl(long lItem)
{
	LPUNKNOWN result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_UNKNOWN, (void*)&result, parms,
		lItem);
	return result;
}

void _DHMTabView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// _DHMTabViewEvents properties

/////////////////////////////////////////////////////////////////////////////
// _DHMTabViewEvents operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\insertionstringmenu.h ===
// InsertionStringMenu.h: interface for the CInsertionStringMenu class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_INSERTIONSTRINGMENU_H__12A665E5_9783_11D3_BE94_0000F87A3912__INCLUDED_)
#define AFX_INSERTIONSTRINGMENU_H__12A665E5_9783_11D3_BE94_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CInsertionStringMenu;
class CHMObject;

class CHiddenWnd : public CWnd
{
// BackPointer
public:
	CInsertionStringMenu* m_pMenu;

// Construction/Destruction
public:
	CHiddenWnd()
	{
		m_pMenu = NULL;
	}

// Command Handler
protected:
	virtual BOOL OnCommand( WPARAM wParam, LPARAM lParam );
};

class CInsertionStringMenu : public CMenu  
{

// Construction/Destruction
public:
	CInsertionStringMenu();
	virtual ~CInsertionStringMenu();

// Create
public:
	bool Create(CWnd* pEditControl, CHMObject* pObject, bool bRuleMenu=true);

// Menu Members
public:
	void DisplayMenu(CPoint& pt);
	BOOL OnCommand( WPARAM wParam, LPARAM lParam );

// Attributes
protected:
	CWnd* m_pEditCtl;
	CStringArray m_saInsertionStrings;
	CHiddenWnd m_HiddenWnd;
};

#endif // !defined(AFX_INSERTIONSTRINGMENU_H__12A665E5_9783_11D3_BE94_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\httpadvanceddlg.cpp ===
// HttpAdvancedDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "HttpAdvancedDlg.h"
#include <mmc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHttpAdvancedDlg dialog


CHttpAdvancedDlg::CHttpAdvancedDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHttpAdvancedDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHttpAdvancedDlg)
	m_bFollowRedirects = TRUE;
	m_sHTTPMethod = _T("GET");
	m_sExtraHeaders = _T("");
	m_sPostData = _T("");
	//}}AFX_DATA_INIT
}


void CHttpAdvancedDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHttpAdvancedDlg)
	DDX_Check(pDX, IDC_CHECK_FOLLOW_REDIRECTS, m_bFollowRedirects);
	DDX_CBString(pDX, IDC_COMBO_HTTP_METHOD, m_sHTTPMethod);
	DDX_Text(pDX, IDC_EDIT_EXTRA_HEADERS, m_sExtraHeaders);
	DDX_Text(pDX, IDC_EDIT_POST_DATA, m_sPostData);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHttpAdvancedDlg, CDialog)
	//{{AFX_MSG_MAP(CHttpAdvancedDlg)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHttpAdvancedDlg message handlers

void CHttpAdvancedDlg::OnButtonHelp() 
{
	CString sHelpTopic = _T("HMon21.chm::/dDEadv.htm");
	MMCPropertyHelp((LPTSTR)(LPCTSTR)sHelpTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\insertionstringmenu.cpp ===
// InsertionStringMenu.cpp: implementation of the CInsertionStringMenu class.
//
//////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03-15-00 v-marfin : bug 60935 - Set focus back to edit control
//                     after inserting a string and set 
//                     cursor in proper location a
//
#include "stdafx.h"
#include "snapin.h"
#include "InsertionStringMenu.h"
#include "WbemClassObject.h"
#include "HMObject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

BOOL CHiddenWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if( ! m_pMenu )
	{
		return CWnd::OnCommand(wParam,lParam);
	}
	return m_pMenu->OnCommand(wParam,lParam);
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CInsertionStringMenu::CInsertionStringMenu()
{
	m_pEditCtl = NULL;
}

CInsertionStringMenu::~CInsertionStringMenu()
{
}

//////////////////////////////////////////////////////////////////////
// Create
//////////////////////////////////////////////////////////////////////

bool CInsertionStringMenu::Create(CWnd* pEditControl, CHMObject* pObject, bool bRuleMenu /*=true*/)
{
	ASSERT(pEditControl);
	if( pEditControl == NULL )
	{
		return false;
	}

	ASSERT(pEditControl->GetSafeHwnd());
	if( pEditControl->GetSafeHwnd() == NULL )
	{
		return false;
	}
	
	ASSERT(pObject);
	if( pObject == NULL )
	{
		return false;
	}

	m_pEditCtl = pEditControl;
  
  CString sPrefix;
  if( ! bRuleMenu )
  {
    sPrefix = _T("TargetInstance.EmbeddedStatus.");
  }

	// get the insertion strings
	CWbemClassObject ClassObject;
	ClassObject.Create(pObject->GetSystemName());

	HRESULT hr = ClassObject.GetObject(_T("Microsoft_HMThresholdStatusInstance"));
	if( ! CHECKHRESULT(hr) )
	{
		return false;
	}

	ClassObject.GetPropertyNames(m_saInsertionStrings);

	ClassObject.Destroy();

  CWbemClassObject* pParentObject = pObject->GetParentClassObject();
  CString sObjectPath;
  CString sNamespace;
  CStringArray saEmbeddedInstNames;
  if( pParentObject )
  {
    pParentObject->GetProperty(IDS_STRING_MOF_PATH,sObjectPath);
    pParentObject->GetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);
    delete pParentObject;
    pParentObject = NULL;
  }

  if( ! sObjectPath.IsEmpty() )
  {
	  int iIndex = -1;
	  if( (iIndex = sObjectPath.Find(_T("."))) != -1 )
	  {
		  sObjectPath = sObjectPath.Left(iIndex);
	  }
    CWbemClassObject WmiObject;
    WmiObject.SetNamespace(_T("\\\\") + pObject->GetSystemName() + _T("\\") + sNamespace);
    WmiObject.GetObject(sObjectPath);
    WmiObject.GetPropertyNames(saEmbeddedInstNames);
    for( int i = 0; i < saEmbeddedInstNames.GetSize(); i++ )
	  {
		  saEmbeddedInstNames.SetAt(i,_T("%") + sPrefix + _T("EmbeddedInstance.") + saEmbeddedInstNames[i]+ _T("%"));
	  }  
  }

	ASSERT(m_saInsertionStrings.GetSize());
	if( m_saInsertionStrings.GetSize() == 0 )
	{
		return false;
	}

	for( int i = 0; i < m_saInsertionStrings.GetSize(); i++ )
	{
		m_saInsertionStrings.SetAt(i,_T("%") + sPrefix + m_saInsertionStrings[i] + _T("%"));
	}

  m_saInsertionStrings.Append(saEmbeddedInstNames);

	m_pEditCtl->SetCaretPos(CPoint(0,0));

	if( ! m_HiddenWnd.Create(NULL,NULL,WS_CHILD,CRect(0,0,10,10),m_pEditCtl,2411) )
	{
		m_saInsertionStrings.RemoveAll();
		return false;
	}

	m_HiddenWnd.m_pMenu = this;

	m_HiddenWnd.ShowWindow(SW_HIDE);

	return true;
}

//////////////////////////////////////////////////////////////////////
// DisplayMenu
//////////////////////////////////////////////////////////////////////

void CInsertionStringMenu::DisplayMenu(CPoint& pt)
{
	ASSERT(m_saInsertionStrings.GetSize());
	if( m_saInsertionStrings.GetSize() == 0)
	{		
		return;
	}

	ASSERT(m_pEditCtl);
	if( m_pEditCtl == NULL )
	{
		return;
	}

	ASSERT(m_pEditCtl->GetSafeHwnd());
	if( m_pEditCtl->GetSafeHwnd() == NULL )
	{
		return;
	}

	if( ! CreatePopupMenu() )
	{
		ASSERT(FALSE);
		return;
	}

	// add each insertion string to the menu
	for( int i = 0; i < m_saInsertionStrings.GetSize(); i++ )
	{
		InsertMenu(i,MF_BYPOSITION,i,m_saInsertionStrings[i]);
	}

	TrackPopupMenu(TPM_LEFTALIGN,pt.x,pt.y,&m_HiddenWnd);

	DestroyMenu();
}

BOOL CInsertionStringMenu::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT(m_saInsertionStrings.GetSize());
	if( m_saInsertionStrings.GetSize() == 0)
	{		
		return FALSE;
	}

	ASSERT(m_pEditCtl);
	if( m_pEditCtl == NULL )
	{
		return FALSE;
	}

	ASSERT(m_pEditCtl->GetSafeHwnd());
	if( m_pEditCtl->GetSafeHwnd() == NULL )
	{
		return FALSE;
	}

	int id = LOWORD(wParam);

	if( id < m_saInsertionStrings.GetSize() && id >= 0 )
	{
		CPoint point = m_pEditCtl->GetCaretPos();
		int iCharIndex = LOWORD(((CEdit*)m_pEditCtl)->CharFromPos(point));
		CString sWindowText;
		m_pEditCtl->GetWindowText(sWindowText);
		sWindowText.Insert(iCharIndex,m_saInsertionStrings[id]);
		m_pEditCtl->SetWindowText(sWindowText);

		//--------------------------------------------------------
		// v-marfin : bug 60935 - Set focus back to edit control
		//                        after inserting a string and set 
		//                        cursor in proper location a
		m_pEditCtl->SetFocus();
		CEdit* pEdit = (CEdit*)m_pEditCtl;

		CString sInsertion = m_saInsertionStrings[id];
		int nLen = sInsertion.GetLength() + iCharIndex;
		pEdit->SetSel(nLen,nLen,TRUE);
		//--------------------------------------------------------

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\listviewcolumn.cpp ===
// ListViewColumn.cpp : implementation file
//

#include "stdafx.h"
#include "ResultsPaneView.h"
#include "ResultsPane.h"
#include "ListViewColumn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListViewColumn

IMPLEMENT_DYNCREATE(CListViewColumn, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CListViewColumn::CListViewColumn()
{
	EnableAutomation();

	m_pOwnerResultsView = NULL;
	m_iWidth = -1;
	m_dwFormat = 0L;

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CListViewColumn::~CListViewColumn()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy

bool CListViewColumn::Create(CResultsPaneView* pOwnerView, const CString& sTitle, int nWidth /*= 100*/, DWORD dwFormat /*= LVCFMT_LEFT*/)
{
	TRACEX(_T("CListViewColumn::Create\n"));
	TRACEARGn(pOwnerView);

	SetOwnerResultsView(pOwnerView);
	SetTitle(sTitle);
	SetWidth(nWidth);
	SetFormat(dwFormat);

	return true;
}

void CListViewColumn::Destroy()
{
	TRACEX(_T("CListViewColumn::Destroy\n"));
}

/////////////////////////////////////////////////////////////////////////////
// Owner ResultsView Members

CResultsPaneView* CListViewColumn::GetOwnerResultsView()
{
	TRACEX(_T("CListViewColumn::GetOwnerResultsView\n"));

	if( GfxCheckObjPtr(m_pOwnerResultsView,CResultsPaneView)  )
		return m_pOwnerResultsView;

	TRACE(_T("WARNING : m_pOwnerResultsView pointer was not valid.\n"));

	return NULL;
}

void CListViewColumn::SetOwnerResultsView(CResultsPaneView* pView)
{
	TRACEX(_T("CListViewColumn::SetOwnerResultsView\n"));
	TRACEARGn(pView);

	if( ! GfxCheckObjPtr(pView, CResultsPaneView) )
	{
		m_pOwnerResultsView = NULL;
		TRACE(_T("WARNING : pView argument is an invalid pointer.\n"));
		return;
	}

	m_pOwnerResultsView = pView;
}

/////////////////////////////////////////////////////////////////////////////
// Title Members

CString CListViewColumn::GetTitle()
{
	TRACEX(_T("CListViewColumn::GetTitle\n"));

	return m_sTitle;
}

void CListViewColumn::SetTitle(const CString& sTitle)
{
	TRACEX(_T("CListViewColumn::SetTitle\n"));
	TRACEARGs(sTitle);

	m_sTitle = sTitle;
}

/////////////////////////////////////////////////////////////////////////////
// Width Members

int CListViewColumn::GetWidth()
{
	TRACEX(_T("CListViewColumn::GetWidth\n"));

	return m_iWidth;
}

void CListViewColumn::SetWidth(int iWidth)
{
	TRACEX(_T("CListViewColumn::SetWidth\n"));
	TRACEARGn(iWidth);

	if( iWidth < 0 )
	{
		TRACE(_T("WARNING : Attempt to set column width to negative value.\n"));
		return;
	}

	if( iWidth > 2000 )
	{
		TRACE(_T("WARNING : Attempt to set column width to a value greater than 2000 pixels.\n"));
		return;
	}

	m_iWidth = iWidth;
}

void CListViewColumn::SaveWidth(CResultsPane* pResultsPane, int iColumnIndex)
{
	TRACEX(_T("CListViewColumn::SaveWidth\n"));	
	TRACEARGn(pResultsPane);
	TRACEARGn(iColumnIndex);

	if( ! GfxCheckObjPtr(pResultsPane,CResultsPane) )
	{
		TRACE(_T("FAILED : Invalid pointer passed.\n"));
		return;
	}

	LPHEADERCTRL2 pIHeaderCtrl = pResultsPane->GetHeaderCtrlPtr();

	if( ! GfxCheckPtr(pIHeaderCtrl,IHeaderCtrl2) )
	{
		TRACE(_T("FAILED : HeaderCtrl pointer is invalid.\n"));
		return;
	}

	HRESULT hr = pIHeaderCtrl->GetColumnWidth(iColumnIndex,&m_iWidth);

	pIHeaderCtrl->Release();

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IHeaderCtrl2::GetColumnWidth failed.\n"));
	}

	return;
}

/////////////////////////////////////////////////////////////////////////////
// Format Members

DWORD CListViewColumn::GetFormat()
{
	TRACEX(_T("CListViewColumn::GetFormat\n"));

	return m_dwFormat;
}

void CListViewColumn::SetFormat(DWORD dwFormat)
{
	TRACEX(_T("CListViewColumn::SetFormat\n"));
	TRACEARGn(dwFormat);

	m_dwFormat = dwFormat;
}

/////////////////////////////////////////////////////////////////////////////
// Column Members

bool CListViewColumn::InsertColumn(CResultsPane* pResultsPane, int iColumnIndex)
{
	TRACEX(_T("CListViewColumn::InsertColumn"));
	TRACEARGn(pResultsPane);
	TRACEARGn(iColumnIndex);

	if( ! GfxCheckObjPtr(pResultsPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pResultsPane is not a valid pointer.\n"));
		return false;
	}

	LPHEADERCTRL2 lpHeaderCtrl = pResultsPane->GetHeaderCtrlPtr();

	if( ! GfxCheckPtr(lpHeaderCtrl,IHeaderCtrl2) )
	{
		TRACE(_T("FAILED : lpHeaderCtrl is not a valid pointer.\n"));
		return false;
	}

	HRESULT hr = lpHeaderCtrl->InsertColumn(iColumnIndex,GetTitle(),GetFormat(),GetWidth());

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IHeaderCtrl::InsertColumn failed.\n "));
		return false;
	}

	lpHeaderCtrl->Release();

	return true;
}


void CListViewColumn::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CListViewColumn, CCmdTarget)
	//{{AFX_MSG_MAP(CListViewColumn)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CListViewColumn, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CListViewColumn)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IListViewColumn to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {BA13F0BF-9446-11D2-BD49-0000F87A3912}
static const IID IID_IListViewColumn =
{ 0xba13f0bf, 0x9446, 0x11d2, { 0xbd, 0x49, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CListViewColumn, CCmdTarget)
	INTERFACE_PART(CListViewColumn, IID_IListViewColumn, Dispatch)
END_INTERFACE_MAP()

// {BA13F0C0-9446-11D2-BD49-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CListViewColumn, "SnapIn.ListViewColumn", 0xba13f0c0, 0x9446, 0x11d2, 0xbd, 0x49, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CListViewColumn::CListViewColumnFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CListViewColumn message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\mmcmsghook.cpp ===
// MmcMsgHook.cpp: implementation of the CMmcMsgHook class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MmcMsgHook.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMmcMsgHook,CMsgHook)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMmcMsgHook::CMmcMsgHook()
{
	m_pScopeItem = NULL;
}

CMmcMsgHook::~CMmcMsgHook()
{
	m_pScopeItem = NULL;
}

//////////////////////////////////////////////////////////////////////
// Hook Operations
//////////////////////////////////////////////////////////////////////

BOOL CMmcMsgHook::Init(CScopePaneItem* pItem, HWND hMainMMCWnd)
{
	m_pScopeItem = pItem;
	CWnd* pWnd = CWnd::FromHandle(hMainMMCWnd);	
	return HookWindow(pWnd);
}

//////////////////////////////////////////////////////////////////////
// Implementation Attributes
//////////////////////////////////////////////////////////////////////

LRESULT CMmcMsgHook::WindowProc(UINT msg, WPARAM wp, LPARAM lp)
{
	if( GfxCheckObjPtr(m_pScopeItem,CScopePaneItem) )
	{
		if( msg == WM_SETTINGCHANGE )
		{
			m_pScopeItem->MsgProc(msg,wp,lp);
		}
	}

	return CMsgHook::WindowProc(msg, wp, lp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\listviewcolumn.h ===
#if !defined(AFX_LISTVIEWCOLUMN_H__BA13F0C1_9446_11D2_BD49_0000F87A3912__INCLUDED_)
#define AFX_LISTVIEWCOLUMN_H__BA13F0C1_9446_11D2_BD49_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ListViewColumn.h : header file
//

#include <mmc.h>

class CResultsPaneView;
class CResultsPane;

/////////////////////////////////////////////////////////////////////////////
// CListViewColumn command target

class CListViewColumn : public CCmdTarget
{

DECLARE_DYNCREATE(CListViewColumn)

// Construction/Destruction
public:
	CListViewColumn();
	virtual ~CListViewColumn();

// Create/Destroy
public:
	virtual bool Create(CResultsPaneView* pOwnerView, const CString& sTitle, int nWidth = 100, DWORD dwFormat = LVCFMT_LEFT);
	virtual void Destroy();

// Owner ResultsView Members
public:
	CResultsPaneView* GetOwnerResultsView();
	void SetOwnerResultsView(CResultsPaneView* pView);
protected:
	CResultsPaneView* m_pOwnerResultsView;
	
// Title Members
public:
	CString GetTitle();
	void SetTitle(const CString& sTitle);
protected:
	CString m_sTitle;

// Width Members
public:
	int GetWidth();
	void SetWidth(int iWidth);
	virtual void SaveWidth(CResultsPane* pResultsPane, int iColumnIndex);
protected:
	int m_iWidth;

// Format Members
public:
	DWORD GetFormat();
	void SetFormat(DWORD dwFormat);
protected:
	DWORD m_dwFormat;

// Column Members
public:
	virtual bool InsertColumn(CResultsPane* pResultsPane, int iColumnIndex);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListViewColumn)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListViewColumn)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CListViewColumn)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CListViewColumn)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

typedef CTypedPtrArray<CObArray,CListViewColumn*> ListViewColumnArray;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTVIEWCOLUMN_H__BA13F0C1_9446_11D2_BD49_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\httpadvanceddlg.h ===
#if !defined(AFX_HTTPADVANCEDDLG_H__2AAE3E53_2CBA_11D3_9391_00A0CC406605__INCLUDED_)
#define AFX_HTTPADVANCEDDLG_H__2AAE3E53_2CBA_11D3_9391_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HttpAdvancedDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHttpAdvancedDlg dialog

class CHttpAdvancedDlg : public CDialog
{
// Construction
public:
	CHttpAdvancedDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CHttpAdvancedDlg)
	enum { IDD = IDD_DATAPOINT_HTTP_ADVANCED };
	BOOL	m_bFollowRedirects;
	CString	m_sHTTPMethod;
	CString	m_sExtraHeaders;
	CString	m_sPostData;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHttpAdvancedDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHttpAdvancedDlg)
	afx_msg void OnButtonHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HTTPADVANCEDDLG_H__2AAE3E53_2CBA_11D3_9391_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\mmcmsghook.h ===
// MmcMsgHook.h: interface for the CMmcMsgHook class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MMCMSGHOOK_H__4A1FD82C_36DE_11D2_8A48_0000F87A3912__INCLUDED_)
#define AFX_MMCMSGHOOK_H__4A1FD82C_36DE_11D2_8A48_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "MsgHook.h"
#include "ScopePaneItem.h"

class CMmcMsgHook : public CMsgHook  
{

DECLARE_DYNCREATE(CMmcMsgHook)

// Construction/Destruction
public:
	CMmcMsgHook();
	virtual ~CMmcMsgHook();

// Operations
public:
	BOOL Init(CScopePaneItem* pItem, HWND hMainMMCWnd);

// Implementation Operations
protected:
	virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp);	

// Implementation Attributes
protected:
	CScopePaneItem* m_pScopeItem;
};

#endif // !defined(AFX_MMCMSGHOOK_H__4A1FD82C_36DE_11D2_8A48_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\msghook.h ===
// MsgHook.h: interface for the CMsgHook class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MSGHOOK_H__DED2E338_D3D5_11D1_82F1_0000F87A3912__INCLUDED_)
#define AFX_MSGHOOK_H__DED2E338_D3D5_11D1_82F1_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMsgHook; // forward declaration

//////////////////
// The message hook map is derived from CMapPtrToPtr, which associates
// a pointer with another pointer. It maps an HWND to a CMsgHook, like
// the way MFC's internal maps map HWND's to CWnd's. The first hook
// attached to a window is stored in the map; all other hooks for that
// window are then chained via CMsgHook::m_pNext.
//
class CMsgHookMap : private CMapPtrToPtr
{
// Construction/Destruction
public:
	CMsgHookMap();
	~CMsgHookMap();

// Operations
public:
	static CMsgHookMap& GetHookMap();
	void Add(HWND hwnd, CMsgHook* pMsgHook);
	void Remove(CMsgHook* pMsgHook);
	void RemoveAll(HWND hwnd);
	CMsgHook* Lookup(HWND hwnd);
};

class CMsgHook : public CObject  
{
DECLARE_DYNAMIC(CMsgHook)

// Construction/Destruction
public:
	CMsgHook();
	virtual ~CMsgHook();

// Message Hook Operations
public:
	// Hook a window. Hook(NULL) to unhook (automatic on WM_NCDESTROY)
	BOOL	HookWindow(CWnd* pRealWnd);
	BOOL	IsHooked()			{ return m_pWndHooked!=NULL; }

	friend LRESULT CALLBACK HookWndProc(HWND, UINT, WPARAM, LPARAM);
	friend class CMsgHookMap;

// Utility and Helper Functions
public:
	HWND GetSafeHwnd() { return (m_pWndHooked?m_pWndHooked->GetSafeHwnd():NULL); }

// Implementation Operations
protected:
	// Override this to handle messages in specific handlers
	virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp);
	LRESULT Default();				// call this at the end of handler fns

// Implementation Data Members
protected:	
	CWnd*			m_pWndHooked;		// the window hooked
	WNDPROC		m_pOldWndProc;	// ..and original window proc
	CMsgHook*	m_pNext;				// next in chain of hooks for this window
};

#endif // !defined(AFX_MSGHOOK_H__DED2E338_D3D5_11D1_82F1_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newactionassociationdlg.cpp ===
// NewActionAssociationDlg.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/26/00 v-marfin 62211 : At least 1 state must be checked in order to close dlg

#include "stdafx.h"
#include "snapin.h"
#include "NewActionAssociationDlg.h"
#include <mmc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewActionAssociationDlg dialog


CNewActionAssociationDlg::CNewActionAssociationDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewActionAssociationDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewActionAssociationDlg)
	m_bCritical = FALSE;
	m_bDisabled = FALSE;
	m_bNoData = FALSE;
	m_bNormal = FALSE;
	m_bWarning = FALSE;
	m_iReminderTime = 0;
	m_iThrottleTime = 0;
	m_iThrottleUnits = 0;
	m_iReminderUnits = 0;
	//}}AFX_DATA_INIT
	
	m_iSelectedAction = 0;
	m_bEnableActionsComboBox = TRUE;
}


void CNewActionAssociationDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewActionAssociationDlg)
	DDX_Control(pDX, IDC_COMBO_ACTIONS, m_Actions);
	DDX_Check(pDX, IDC_CHECK_CRITICAL, m_bCritical);
	DDX_Check(pDX, IDC_CHECK_DISABLED, m_bDisabled);
	DDX_Check(pDX, IDC_CHECK_NO_DATA, m_bNoData);
	DDX_Check(pDX, IDC_CHECK_NORMAL, m_bNormal);
	DDX_Check(pDX, IDC_CHECK_WARNING, m_bWarning);
	DDX_Text(pDX, IDC_EDIT_REMINDER_TIME, m_iReminderTime);
	DDX_Text(pDX, IDC_EDIT_THROTTLE_TIME, m_iThrottleTime);
	DDX_CBIndex(pDX, IDC_COMBO_THROTTLE_UNITS, m_iThrottleUnits);
	DDX_CBIndex(pDX, IDC_COMBO_REMINDER_UNITS, m_iReminderUnits);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewActionAssociationDlg, CDialog)
	//{{AFX_MSG_MAP(CNewActionAssociationDlg)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewActionAssociationDlg message handlers

BOOL CNewActionAssociationDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	for( int i = 0; i < m_saActions.GetSize(); i++ )
	{
		m_Actions.AddString(m_saActions[i]);
	}

	m_Actions.SetCurSel(m_iSelectedAction);

	m_Actions.EnableWindow(m_bEnableActionsComboBox);


  SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,9999);
	SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,9999);	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewActionAssociationDlg::OnOK() 
{
	// v-marfin 62211 : At least 1 state must be checked in order to close dlg
	UpdateData();
	if	((!m_bCritical) &&
		(!m_bDisabled) &&
		(!m_bNormal)   &&
		(!m_bNoData)   &&
		(!m_bWarning))
	{
		AfxMessageBox(IDS_ERR_SELECT_STATE);
		return;
	}


	CDialog::OnOK();

	switch( m_iThrottleUnits )
	{
		case 1: // minutes
		{
			m_iThrottleTime *= 60;
		}
		break;

		case 2: // hours
		{
			m_iThrottleTime *= 360;
		}
		break;
	}

	switch( m_iReminderUnits )
	{
		case 1: // minutes
		{
			m_iReminderTime *= 60;
		}
		break;

		case 2: // hours
		{
			m_iReminderTime *= 360;
		}
		break;
	}

	CString sSelectedAction;

	int iCurSel = m_Actions.GetCurSel();

	m_Actions.GetLBText(iCurSel,sSelectedAction);

	for( int i = 0; i < m_saActions.GetSize(); i++ )
	{
		if( m_saActions[i] == sSelectedAction )
		{
			m_iSelectedAction = i;
			return;
		}
	}
}

void CNewActionAssociationDlg::OnButtonHelp() 
{
	MMCPropertyHelp(_T("HMon21.chm::/dassoci8.htm"));  // 62212	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newactionassociationdlg.h ===
#if !defined(AFX_NEWACTIONASSOCIATIONDLG_H__9136B32D_5C9B_11D3_BE49_0000F87A3912__INCLUDED_)
#define AFX_NEWACTIONASSOCIATIONDLG_H__9136B32D_5C9B_11D3_BE49_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewActionAssociationDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewActionAssociationDlg dialog

class CNewActionAssociationDlg : public CDialog
{
// Construction
public:
	CNewActionAssociationDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewActionAssociationDlg)
	enum { IDD = IDD_DIALOG_NEW_ACTION_ASSOC };
	CComboBox	m_Actions;
	BOOL	m_bCritical;
	BOOL	m_bDisabled;
	BOOL	m_bNoData;
	BOOL	m_bNormal;
	BOOL	m_bWarning;
	int		m_iReminderTime;
	int		m_iThrottleTime;
	int		m_iThrottleUnits;
	int		m_iReminderUnits;
	//}}AFX_DATA

	CStringArray m_saActions;
	int m_iSelectedAction;
	BOOL m_bEnableActionsComboBox;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewActionAssociationDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewActionAssociationDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWACTIONASSOCIATIONDLG_H__9136B32D_5C9B_11D3_BE49_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\msghook.cpp ===
// MsgHook.cpp: implementation of the CMsgHook class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MsgHook.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CMsgHook, CObject)

// This trick is used so the hook map isn't
// instantiated until someone actually requests it.
//
#define	theHookMap	(CMsgHookMap::GetHookMap())

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMsgHook::CMsgHook()
{
	m_pNext = NULL;
	m_pOldWndProc = NULL;	
	m_pWndHooked  = NULL;
}

CMsgHook::~CMsgHook()
{
	ASSERT(m_pWndHooked == NULL);		// can't destroy while still hooked!
	ASSERT(m_pOldWndProc == NULL);
}

//////////////////
// Hook a window.
// This installs a new window proc that directs messages to the CMsgHook.
// pWnd=NULL to remove.
//
BOOL CMsgHook::HookWindow(CWnd* pWnd)
{
	if (pWnd)
	{
		// Hook the window
		ASSERT(m_pWndHooked == NULL);
		HWND hwnd = pWnd->m_hWnd;
		ASSERT(hwnd && ::IsWindow(hwnd));
		theHookMap.Add(hwnd, this);			// Add to map of hooks
	}
	else
	{
		// Unhook the window
		ASSERT(m_pWndHooked!=NULL);
		theHookMap.Remove(this);				// Remove from map
		m_pOldWndProc = NULL;
	}
	m_pWndHooked = pWnd;
	return TRUE;
}

//////////////////
// Window proc-like virtual function which specific CMsgHooks will
// override to do stuff. Default passes the message to the next hook; 
// the last hook passes the message to the original window.
// You MUST call this at the end of your WindowProc if you want the real
// window to get the message. This is just like CWnd::WindowProc, except that
// a CMsgHook is not a window.
//
LRESULT CMsgHook::WindowProc(UINT msg, WPARAM wp, LPARAM lp)
{
	ASSERT(m_pOldWndProc);
	return m_pNext ? m_pNext->WindowProc(msg, wp, lp) :	
		::CallWindowProc(m_pOldWndProc, m_pWndHooked->m_hWnd, msg, wp, lp);
}

//////////////////
// Like calling base class WindowProc, but with no args, so individual
// message handlers can do the default thing. Like CWnd::Default
//
LRESULT CMsgHook::Default()
{
	// MFC stores current MSG in thread state
	MSG& curMsg = AfxGetThreadState()->m_lastSentMsg;
	// Note: must explicitly call CMsgHook::WindowProc to avoid infinte
	// recursion on virtual function
	return CMsgHook::WindowProc(curMsg.message, curMsg.wParam, curMsg.lParam);
}

//////////////////
// Subclassed window proc for message hooks. Replaces AfxWndProc (or whatever
// else was there before.)
//
LRESULT CALLBACK HookWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
#ifdef _USRDLL
	// If this is a DLL, need to set up MFC state
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

	// Set up MFC message state just in case anyone wants it
	// This is just like AfxCallWindowProc, but we can't use that because
	// a CMsgHook is not a CWnd.
	//
	MSG& curMsg = AfxGetThreadState()->m_lastSentMsg;
	MSG  oldMsg = curMsg;   // save for nesting
	curMsg.hwnd		= hwnd;
	curMsg.message = msg;
	curMsg.wParam  = wp;
	curMsg.lParam  = lp;

	// Get hook object for this window. Get from hook map
	CMsgHook* pMsgHook = theHookMap.Lookup(hwnd);
	ASSERT(pMsgHook);

	LRESULT lr;
	if (msg==WM_NCDESTROY)
	{
		// Window is being destroyed: unhook all hooks (for this window)
		// and pass msg to orginal window proc
		//
		WNDPROC wndproc = pMsgHook->m_pOldWndProc;
		theHookMap.RemoveAll(hwnd);
		lr = ::CallWindowProc(wndproc, hwnd, msg, wp, lp);

	}
	else
	{
		// pass to msg hook
		lr = pMsgHook->WindowProc(msg, wp, lp);
	}
	curMsg = oldMsg;			// pop state
	return lr;
}

////////////////////////////////////////////////////////////////
// CMsgHookMap implementation

CMsgHookMap::CMsgHookMap()
{
}

CMsgHookMap::~CMsgHookMap()
{
	ASSERT(IsEmpty());	// all hooks should be removed!	
}

//////////////////
// Get the one and only global hook map
// 
CMsgHookMap& CMsgHookMap::GetHookMap()
{
	// By creating theMap here, C++ doesn't instantiate it until/unless
	// it's ever used! This is a good trick to use in C++, to
	// instantiate/initialize a static object the first time it's used.
	//
	static CMsgHookMap theMap;
	return theMap;
}

/////////////////
// Add hook to map; i.e., associate hook with window
//
void CMsgHookMap::Add(HWND hwnd, CMsgHook* pMsgHook)
{
	ASSERT(hwnd && ::IsWindow(hwnd));

	// Add to front of list
	pMsgHook->m_pNext = Lookup(hwnd);
	SetAt(hwnd, pMsgHook);
	
	if( pMsgHook->m_pNext == NULL )
	{
		// If this is the first hook added, subclass the window
		pMsgHook->m_pOldWndProc = 
			(WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)HookWndProc);

	}
	else
	{
		// just copy wndproc from next hook
		pMsgHook->m_pOldWndProc = pMsgHook->m_pNext->m_pOldWndProc;
	}
	ASSERT(pMsgHook->m_pOldWndProc);
}

//////////////////
// Remove hook from map
//
void CMsgHookMap::Remove(CMsgHook* pUnHook)
{
	HWND hwnd = pUnHook->m_pWndHooked->GetSafeHwnd();
	ASSERT(hwnd && ::IsWindow(hwnd));

	CMsgHook* pHook = Lookup(hwnd);
	ASSERT(pHook);
	if( pHook == pUnHook )
	{
		// hook to remove is the one in the hash table: replace w/next
		if( pHook->m_pNext )
		{
			SetAt(hwnd, pHook->m_pNext);
		}
		else
		{
			// This is the last hook for this window: restore wnd proc
			RemoveKey(hwnd);
			SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pHook->m_pOldWndProc);
		}
	}
	else	
	{
		// Hook to remove is in the middle: just remove from linked list
		while (pHook->m_pNext!=pUnHook)
			pHook = pHook->m_pNext;
		ASSERT(pHook && pHook->m_pNext==pUnHook);
		pHook->m_pNext = pUnHook->m_pNext;
	}
}

//////////////////
// Remove all the hooks for a window
//
void CMsgHookMap::RemoveAll(HWND hwnd)
{
	CMsgHook* pMsgHook;
	while ((pMsgHook = Lookup(hwnd))!=NULL)
		pMsgHook->HookWindow(NULL);	// (unhook)
}

/////////////////
// Find first hook associate with window
//
CMsgHook* CMsgHookMap::Lookup(HWND hwnd)
{
	CMsgHook* pFound = NULL;
	if( ! CMapPtrToPtr::Lookup(hwnd,(void*&)pFound) )
		return NULL;
	ASSERT_KINDOF(CMsgHook, pFound);
	return pFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newsystemdlg.cpp ===
// NewSystemDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "NewSystemDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewSystemDlg dialog


CNewSystemDlg::CNewSystemDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewSystemDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewSystemDlg)
	m_sName = _T("");
	//}}AFX_DATA_INIT

}


void CNewSystemDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewSystemDlg)
	DDX_Text(pDX, IDC_EDIT_MACHINE_NAME, m_sName);
	DDV_MaxChars(pDX, m_sName, 255);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewSystemDlg, CDialog)
	//{{AFX_MSG_MAP(CNewSystemDlg)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewSystemDlg message handlers

void CNewSystemDlg::OnBrowse() 
{
	LPMALLOC pMalloc;
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		BROWSEINFO bi;
		TCHAR szBuffer[MAX_PATH];
		LPITEMIDLIST pidlNet;
		LPITEMIDLIST pidl;
		
		if( ::SHGetSpecialFolderLocation(GetSafeHwnd(),CSIDL_NETWORK,&pidlNet) != NOERROR )
			return;

    CString sResString;
    sResString.LoadString(IDS_STRING_BROWSE_SYSTEM);

		bi.hwndOwner = GetSafeHwnd();
		bi.pidlRoot = pidlNet;
		bi.pszDisplayName = szBuffer;
		bi.lpszTitle = LPCTSTR(sResString);
		bi.ulFlags = BIF_BROWSEFORCOMPUTER;
		bi.lpfn = NULL;
		bi.lParam = 0;

		if( (pidl = ::SHBrowseForFolder(&bi)) != NULL )
		{			
			m_sName = szBuffer;
			UpdateData(FALSE);			
			pMalloc->Free(pidl);
		}
		pMalloc->Free(pidlNet);
		pMalloc->Release();
	}
}

void CNewSystemDlg::OnOK() 
{
	UpdateData();
	
	if( m_sName.IsEmpty() )	
	{
		MessageBeep(MB_ICONEXCLAMATION);
		return;
	}

	IWbemServices* pServices = NULL;
	BOOL bAvail = FALSE;

	if( CnxGetConnection(m_sName,pServices,bAvail) == E_FAIL )
	{
		MessageBeep(MB_ICONEXCLAMATION);
		return;
	}

	if( pServices )
	{
		pServices->Release();
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newsystemshortcutdlg.cpp ===
// NewSystemShortcutDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "NewSystemShortcutDlg.h"
#include <mmc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewSystemShortcutDlg dialog


CNewSystemShortcutDlg::CNewSystemShortcutDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewSystemShortcutDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewSystemShortcutDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CNewSystemShortcutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewSystemShortcutDlg)
	DDX_Control(pDX, IDC_BUTTON_DESELECT_ALL, m_DeselectAllButton);
	DDX_Control(pDX, IDC_BUTTON_SELECT_ALL, m_SelectAllButton);
	DDX_Control(pDX, IDC_LIST_SYSTEMS, m_Systems);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewSystemShortcutDlg, CDialog)
	//{{AFX_MSG_MAP(CNewSystemShortcutDlg)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
	ON_BN_CLICKED(IDC_BUTTON_DESELECT_ALL, OnButtonDeselectAll)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewSystemShortcutDlg message handlers

BOOL CNewSystemShortcutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	CString sTitleFmt;

	GetDlgItem(IDC_STATIC_TITLE)->GetWindowText(sTitleFmt);

	CString sTitle;
	sTitle.Format(sTitleFmt,m_sGroupName);

	GetDlgItem(IDC_STATIC_TITLE)->SetWindowText(sTitle);

	// create the tooltip
	EnableToolTips();
	m_ToolTip.Create(this,TTS_ALWAYSTIP);
	m_ToolTip.AddTool(&m_SelectAllButton,IDS_STRING_TOOLTIP_SELECT_ALL);
	m_ToolTip.AddTool(&m_DeselectAllButton,IDS_STRING_TOOLTIP_DESELECT_ALL);
	m_ToolTip.Activate(TRUE);

	// create bitmaps and init each bitmap button	
	CBitmap bitmap;
	bitmap.LoadBitmap(IDB_BITMAP_SELECT_ALL);
	m_hSelectAllBitmap = (HBITMAP)bitmap.Detach();

	bitmap.LoadBitmap(IDB_BITMAP_DESELECT_ALL);
	m_hDeselectAllBitmap = (HBITMAP)bitmap.Detach();

	SendDlgItemMessage(IDC_BUTTON_SELECT_ALL,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)m_hSelectAllBitmap);
	SendDlgItemMessage(IDC_BUTTON_DESELECT_ALL,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)m_hDeselectAllBitmap);


	// initialize the list view
	m_Systems.SetExtendedStyle(LVS_EX_CHECKBOXES);

	for( int i = 0; i < m_saSystems.GetSize(); i++ )
	{
		int iIndex = m_Systems.InsertItem(0,m_saSystems[i]);
		m_Systems.SetCheck(iIndex,m_uaIncludeFlags[i]);
	}


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewSystemShortcutDlg::OnOK() 
{
	for( int i = 0; i < m_Systems.GetItemCount(); i++ )
	{
		m_saSystems.SetAt(i,m_Systems.GetItemText(i,0));

		if( m_Systems.GetCheck(i) )
		{
			m_uaIncludeFlags.SetAt(i,1);
		}
		else
		{
			m_uaIncludeFlags.SetAt(i,0);
		}
	}
	
	CDialog::OnOK();
}

void CNewSystemShortcutDlg::OnButtonHelp() 
{
	MMCPropertyHelp(_T("HMon21.chm::/daddsh.htm"));	// 62212
}

void CNewSystemShortcutDlg::OnButtonSelectAll() 
{
	for( int i = 0; i < m_Systems.GetItemCount(); i++ )
	{
		m_Systems.SetCheck(i,TRUE);
	}
}

void CNewSystemShortcutDlg::OnButtonDeselectAll() 
{
	for( int i = 0; i < m_Systems.GetItemCount(); i++ )
	{
		m_Systems.SetCheck(i,FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newsystemshortcutdlg.h ===
#if !defined(AFX_NEWSYSTEMSHORTCUTDLG_H__5DB2CB69_DE15_11D2_BDA8_0000F87A3912__INCLUDED_)
#define AFX_NEWSYSTEMSHORTCUTDLG_H__5DB2CB69_DE15_11D2_BDA8_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewSystemShortcutDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewSystemShortcutDlg dialog

class CNewSystemShortcutDlg : public CDialog
{
// Construction
public:
	CNewSystemShortcutDlg(CWnd* pParent = NULL);   // standard constructor

// Systems
public:
	CStringArray m_saSystems;
	CUIntArray m_uaIncludeFlags;
	CString m_sGroupName;

// User Interface Attributes
protected:
	HBITMAP m_hSelectAllBitmap;
	HBITMAP m_hDeselectAllBitmap;
	CToolTipCtrl m_ToolTip;

// Dialog Data
	//{{AFX_DATA(CNewSystemShortcutDlg)
	enum { IDD = IDD_GROUP_NEW_SYSTEMS };
	CButton	m_DeselectAllButton;
	CButton	m_SelectAllButton;
	CListCtrl	m_Systems;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewSystemShortcutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewSystemShortcutDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonHelp();
	afx_msg void OnButtonSelectAll();
	afx_msg void OnButtonDeselectAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWSYSTEMSHORTCUTDLG_H__5DB2CB69_DE15_11D2_BDA8_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\newsystemdlg.h ===
#if !defined(AFX_NEWSYSTEMDLG_H__52566151_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_NEWSYSTEMDLG_H__52566151_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewSystemDlg.h : header file
//

#include "HealthmonScopePane.h"

/////////////////////////////////////////////////////////////////////////////
// CNewSystemDlg dialog

class CNewSystemDlg : public CDialog
{
// Construction
public:
	CNewSystemDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewSystemDlg)
	enum { IDD = IDD_NEW_SYSTEM };
	CString	m_sName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewSystemDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewSystemDlg)
	afx_msg void OnBrowse();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWSYSTEMDLG_H__52566151_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\removegroupdlg.cpp ===
// RemoveGroupDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "RemoveGroupDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemoveGroupDlg dialog


CRemoveGroupDlg::CRemoveGroupDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRemoveGroupDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRemoveGroupDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CRemoveGroupDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemoveGroupDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoveGroupDlg, CDialog)
	//{{AFX_MSG_MAP(CRemoveGroupDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoveGroupDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\proxydialog.cpp ===
// ProxyDialog.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/24/00 v-marfin : 63447 : Fox for proxy property.
//
#include "stdafx.h"
#include "snapin.h"
#include "ProxyDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProxyDialog dialog


CProxyDialog::CProxyDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CProxyDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProxyDialog)
	m_bUseProxy = FALSE;
	m_sPort = _T("");
	m_sAddress = _T("");
	//}}AFX_DATA_INIT
}


void CProxyDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProxyDialog)
	DDX_Check(pDX, IDC_CHECK_USE, m_bUseProxy);
	DDX_Text(pDX, IDC_EDIT_PORT, m_sPort);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_sAddress);
	//}}AFX_DATA_MAP

	GetDlgItem(IDC_EDIT_SERVER)->EnableWindow(m_bUseProxy==TRUE);
	GetDlgItem(IDC_EDIT_PORT)->EnableWindow(m_bUseProxy==TRUE);
}


BEGIN_MESSAGE_MAP(CProxyDialog, CDialog)
	//{{AFX_MSG_MAP(CProxyDialog)
	ON_BN_CLICKED(IDC_CHECK_USE, OnCheckUse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProxyDialog message handlers

void CProxyDialog::OnCheckUse() 
{
	UpdateData();
	
}

BOOL CProxyDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CProxyDialog::OnOK() 
{
	UpdateData();

	if (m_bUseProxy)
	{
		m_sPort.TrimRight();
		m_sPort.TrimLeft();
		m_sAddress.TrimRight();
		m_sAddress.TrimLeft();
		if (m_sPort.IsEmpty())
		{
			AfxMessageBox(IDS_ERR_PROXY_REQ);
			UpdateData(FALSE);
			GetDlgItem(IDC_EDIT_PORT)->SetFocus();
			return;
		}
		if (m_sAddress.IsEmpty())
		{
			AfxMessageBox(IDS_ERR_PROXY_REQ);
			UpdateData(FALSE);
			GetDlgItem(IDC_EDIT_SERVER)->SetFocus();
			return;
		}

	}
	else
	{
		m_sPort.Empty();
		m_sAddress.Empty();
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\proxydialog.h ===
#if !defined(AFX_PROXYDIALOG_H__342597AE_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
#define AFX_PROXYDIALOG_H__342597AE_96F7_11D3_BE93_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProxyDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProxyDialog dialog

class CProxyDialog : public CDialog
{
// Construction
public:
	CProxyDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CProxyDialog)
	enum { IDD = IDD_DIALOG_PROXY };
	BOOL	m_bUseProxy;
	CString	m_sPort;
	CString	m_sAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProxyDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CProxyDialog)
	afx_msg void OnCheckUse();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROXYDIALOG_H__342597AE_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\removegroupdlg.h ===
#if !defined(AFX_REMOVEGROUPDLG_H__3ADB0FD9_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
#define AFX_REMOVEGROUPDLG_H__3ADB0FD9_C4FA_11D2_BD83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemoveGroupDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemoveGroupDlg dialog

class CRemoveGroupDlg : public CDialog
{
// Construction
public:
	CRemoveGroupDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRemoveGroupDlg)
	enum { IDD = IDD_DIALOG_SEPARATEGROUP };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoveGroupDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoveGroupDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVEGROUPDLG_H__3ADB0FD9_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\removesystemdlg.cpp ===
// RemoveSystemDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "RemoveSystemDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemoveSystemDlg dialog


CRemoveSystemDlg::CRemoveSystemDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRemoveSystemDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRemoveSystemDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CRemoveSystemDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemoveSystemDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoveSystemDlg, CDialog)
	//{{AFX_MSG_MAP(CRemoveSystemDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoveSystemDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SnapIn.rc
//
#define IDR_REGISTRY                    1000
#define IDR_REGISTRY_UNREG              1003
#define IDS_STRING_RESOURCE_DLL_MISSING 2000
#define IDS_STRING_HELP_FORMAT          2002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1004
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           1000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\removesystemdlg.h ===
#if !defined(AFX_REMOVESYSTEMDLG_H__3ADB0FD8_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
#define AFX_REMOVESYSTEMDLG_H__3ADB0FD8_C4FA_11D2_BD83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemoveSystemDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemoveSystemDlg dialog

class CRemoveSystemDlg : public CDialog
{
// Construction
public:
	CRemoveSystemDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRemoveSystemDlg)
	enum { IDD = IDD_DIALOG_REMOVESYSTEM };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoveSystemDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoveSystemDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVESYSTEMDLG_H__3ADB0FD8_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resizeabledialog.h ===
#if !defined(AFX_RESIZEABLEDIALOG_H__19874DCF_3F9A_11D3_BE24_0000F87A3912__INCLUDED_)
#define AFX_RESIZEABLEDIALOG_H__19874DCF_3F9A_11D3_BE24_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ResizeableDialog.h : header file
//

#define ANCHOR_LEFT	0x0000
#define ANCHOR_TOP		0x0000
#define ANCHOR_RIGHT	0x0001
#define ANCHOR_BOTTOM	0x0002
#define	RESIZE_HOR		0x0004
#define	RESIZE_VER		0x0008
#define	RESIZE_BOTH		(RESIZE_HOR | RESIZE_VER)

/////////////////////////////////////////////////////////////////////////////
// CResizeableDialog dialog

class CResizeableDialog : public CDialog
{
// Construction
public:
	CResizeableDialog( UINT nIDTemplate, CWnd* pParentWnd = NULL );

// Operations
public:
	void SetControlInfo(WORD CtrlId,WORD Anchor);
	BOOL GetRememberSize() { return  m_bRememberSize;}
	void SetRememberSize(BOOL bRemember) { m_bRememberSize = bRemember;}
	virtual void GetDialogProfileEntry(CString &sEntry);
// Dialog Data
protected:
	BOOL	m_bRememberSize;
	BOOL	m_bDrawGripper;
	int		m_minWidth,m_minHeight;
	int		m_old_cx,m_old_cy;
	BOOL	m_bSizeChanged;
	CDWordArray	m_control_info;
	UINT	m_nIDTemplate;
	CRect	m_GripperRect;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResizeableDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResizeableDialog)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESIZEABLEDIALOG_H__19874DCF_3F9A_11D3_BE24_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resizeabledialog.cpp ===
// ResizeableDialog.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "ResizeableDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResizeableDialog dialog


CResizeableDialog::CResizeableDialog(UINT nIDTemplate, CWnd* pParentWnd) : 
				CDialog(nIDTemplate,pParentWnd)
{
	//{{AFX_DATA_INIT(CResizeableDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_minWidth = m_minHeight = 0;	// flag that GetMinMax wasn't called yet
	m_old_cx = m_old_cy = 0;
	m_bSizeChanged = FALSE;
	m_nIDTemplate = nIDTemplate;

	m_bRememberSize = FALSE;
	m_bDrawGripper = TRUE;
}

void CResizeableDialog::SetControlInfo(WORD CtrlId,WORD Anchor)			
{
	if(Anchor == ANCHOR_LEFT)
		return;

	// Add resizing behaviour for the control
	DWORD c_info = CtrlId | (Anchor << 16);
	m_control_info.Add(c_info);
}

void CResizeableDialog::GetDialogProfileEntry(CString &sEntry)
{
	// By default store the size under the Dialog ID value (Hex)
	sEntry.Format(_T("%x"),m_nIDTemplate);
}

void CResizeableDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CResizeableDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CResizeableDialog, CDialog)
	//{{AFX_MSG_MAP(CResizeableDialog)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_NCHITTEST()
	ON_WM_GETMINMAXINFO()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResizeableDialog message handlers

BOOL CResizeableDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	if(m_bRememberSize)
	{
		// Load the previous size of the dialog box from the INI/Registry
		CString dialog_name;
		GetDialogProfileEntry(dialog_name);

		int cx = AfxGetApp()->GetProfileInt(dialog_name,_T("CX"),0);
		int cy = AfxGetApp()->GetProfileInt(dialog_name,_T("CY"),0);
		
		if(cx && cy)
		{
			SetWindowPos( NULL, 0, 0, cx, cy, SWP_NOMOVE );
		}
	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CResizeableDialog::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// Remember the original size so later we can calculate
	// how to place the controls on dialog Resize
	m_minWidth  = lpCreateStruct->cx;
	m_minHeight = lpCreateStruct->cy;

	
	return 0;
}

void CResizeableDialog::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// Save the size of the dialog box, so next time
	// we'll start with this size
	if(m_bRememberSize && m_bSizeChanged && m_old_cx && m_old_cy)
	{
		CRect rc;
		GetWindowRect(&rc);
		CString dialog_name;
		GetDialogProfileEntry(dialog_name);

		AfxGetApp()->WriteProfileInt(dialog_name,_T("CX"),rc.Width());
		AfxGetApp()->WriteProfileInt(dialog_name,_T("CY"),rc.Height());
	}

	// Important: Reset the internal values in case of reuse of the dialog
	// with out deleting.
	m_minWidth = m_minHeight = m_old_cx = m_old_cy = 0;
	m_bSizeChanged = FALSE;	
}

void CResizeableDialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// Draw a resizing gripper at the lower left corner
	//
	// Note: Make sure you leave enough space in your dialog template
	// for the gripper to be drawn.
	// Don't put any controls on the lower left corner.
	if(m_bDrawGripper)
	{
		CRect rc;
		GetClientRect(rc);

		rc.left = rc.right-GetSystemMetrics(SM_CXHSCROLL);
		rc.top = rc.bottom-GetSystemMetrics(SM_CYVSCROLL);
		m_GripperRect = rc;
		CClientDC dc(this);
		dc.DrawFrameControl(rc,DFC_SCROLL,DFCS_SCROLLSIZEGRIP);
	}
	
	// Do not call CDialog::OnPaint() for painting messages
}

UINT CResizeableDialog::OnNcHitTest(CPoint point) 
{
	UINT ht = CDialog::OnNcHitTest(point);

	if(ht==HTCLIENT && m_bDrawGripper)
	{
		CRect rc;
		GetWindowRect( rc );
		rc.left = rc.right-GetSystemMetrics(SM_CXHSCROLL);
		rc.top = rc.bottom-GetSystemMetrics(SM_CYVSCROLL);
		if(rc.PtInRect(point))
		{
			ht = HTBOTTOMRIGHT;
		}
	}
	return ht;
}

void CResizeableDialog::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) 
{
  if (!m_minWidth) // first time
	{
		CDialog::OnGetMinMaxInfo(lpMMI);
		return;
	}
  lpMMI->ptMinTrackSize.x = m_minWidth;
  lpMMI->ptMinTrackSize.y = m_minHeight;
}

void CResizeableDialog::OnSize(UINT nType, int cx, int cy) 
{
	CDialog::OnSize(nType, cx, cy);
	
	if(nType == SIZE_MINIMIZED)
		return;

	int dx = cx - m_old_cx;
	int dy = cy - m_old_cy;

	if(m_old_cx)
	{
		// Move and Size the controls using the information
		// we got in SetControlInfo()
		//
		m_bSizeChanged = TRUE;
		CRect WndRect;
		CWnd *pWnd;
		DWORD c_info;
		short Anchor;
		for(int i = 0; i < m_control_info.GetSize(); i++)
		{
			c_info = m_control_info[i];
			pWnd = GetDlgItem(LOWORD(c_info));
			if(!pWnd)
			{
				TRACE(_T("Control ID - %d NOT FOUND!!\n"),LOWORD(c_info));
				continue;
			}

			if(!HIWORD(c_info))
				continue; // do nothing if anchored to top and or left

			Anchor = HIWORD(c_info);
			pWnd->GetWindowRect(&WndRect);  ScreenToClient(&WndRect);
			
			if(Anchor & RESIZE_HOR)
				WndRect.right += dx;
			else if(Anchor & ANCHOR_RIGHT)
				WndRect.OffsetRect(dx,0);

			if(Anchor & RESIZE_VER)
				WndRect.bottom += dy;
			else if(Anchor & ANCHOR_BOTTOM)
				WndRect.OffsetRect(0,dy);

			pWnd->MoveWindow(&WndRect);
		}

	}
	m_old_cx = cx;
	m_old_cy = cy;

	// When enlarging a dialog box we need to erase the old gripper 
	if(m_bDrawGripper)
		InvalidateRect(m_GripperRect);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspane.cpp ===
// ResultsPane.cpp : implementation file
//

#include "stdafx.h"
#include "SnapIn.h"
#include "ScopePane.h"
#include "ResultsPane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResultsPane

IMPLEMENT_DYNCREATE(CResultsPane, CCmdTarget)


/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CResultsPane::CResultsPane()
{
	EnableAutomation();
	m_pIResultData = NULL;
	m_pIHeaderCtrl = NULL;
	m_pIControlbar = NULL;
	m_pIToolbar = NULL;
	m_pIConsoleVerb = NULL;
	m_pOwnerScopePane = NULL;
}

CResultsPane::~CResultsPane()
{
}

/////////////////////////////////////////////////////////////////////////////
// Creation/Destruction overrideable members

bool CResultsPane::OnCreate(LPCONSOLE lpConsole)
{
	TRACEX(_T("CResultsPane::OnCreate\n"));
	TRACEARGn(lpConsole);

	if( ! CHECKPTR(lpConsole,sizeof(IConsole)) )
	{
		TRACE(_T("lpConsole is an invalid pointer.\n"));
		return false;
	}

	HRESULT hr = lpConsole->QueryInterface(IID_IConsole2,(LPVOID*)&m_pIConsole);
  if( ! CHECKHRESULT(hr) ) 
	{
		TRACE(_T("FAILED : lpConsole->QueryInterface for IID_IConsole2 failed.\n"));
    return false;
	}

	lpConsole->Release();


  hr = m_pIConsole->QueryInterface(IID_IResultData, (LPVOID*)&m_pIResultData);
  if( ! CHECKHRESULT(hr) ) 
	{
		TRACE(_T("FAILED : m_pIConsole->QueryInterface for IID_IResultData failed.\n"));
    return false;
	}

  hr = m_pIConsole->QueryInterface(IID_IHeaderCtrl2, (LPVOID*)&m_pIHeaderCtrl);
  if( ! CHECKHRESULT(hr) ) 
	{
		TRACE(_T("FAILED : m_pIConsole->QueryInterface for IID_IHeaderCtrl2 failed.\n"));
    return false;
	}

	hr = m_pIConsole->SetHeader( m_pIHeaderCtrl );
  if( ! CHECKHRESULT(hr) ) 
	{
		TRACE(_T("FAILED : m_pIConsole->SetHeader failed.\n"));
    return false;
	}


  hr = m_pIConsole->QueryConsoleVerb( &m_pIConsoleVerb );
  if( ! CHECKHRESULT(hr) ) 
	{
		TRACE(_T("FAILED : m_pIConsole->QueryConsoleVerb failed.\n"));
    return false;
	}

	return true;
}

bool CResultsPane::OnCreateOcx(LPUNKNOWN pIUnknown)
{
	TRACEX(_T("CResultsPane::OnCreateOcx\n"));
	TRACEARGn(pIUnknown);

	if( ! CHECKPTR(pIUnknown,sizeof(IUnknown)) )
	{
		return false;
	}

	return true;
}

bool CResultsPane::OnDestroy()
{
	TRACEX(_T("CResultsPane::OnDestroy\n"));

	CScopePane* pPane = GetOwnerScopePane();
	if( CHECKOBJPTR(pPane,RUNTIME_CLASS(CScopePane),sizeof(CScopePane)) )
	{
		// for some goofy reason, you have to
		// explicitly set the header control
		// to NULL so MMC releases it.
		LPCONSOLE2 lpConsole = pPane->GetConsolePtr();
		lpConsole->SetHeader(NULL);
		lpConsole->Release();
		lpConsole = NULL;
	}

	if( m_pIResultData )
	{
		m_pIResultData->Release();
		m_pIResultData = NULL;
	}

	if( m_pIHeaderCtrl )
	{
		m_pIHeaderCtrl->Release();
		m_pIHeaderCtrl = NULL;
	}

	if( m_pIControlbar )
	{
		m_pIControlbar->Release();
		m_pIControlbar = NULL;
	}

	if( m_pIToolbar )
	{
		m_pIToolbar->Release();
		m_pIToolbar = NULL;
	}

	if( m_pIConsoleVerb )
	{
		m_pIConsoleVerb->Release();
		m_pIConsoleVerb = NULL;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Owner Scope Pane Members

CScopePane* CResultsPane::GetOwnerScopePane() const
{
	TRACEX(_T("CResultsPane::GetOwnerScopePane\n"));

	if( ! CHECKOBJPTR(m_pOwnerScopePane,RUNTIME_CLASS(CScopePane),sizeof(CScopePane)) )
	{
		TRACE(_T("FAILED : m_pOwnerScopePane pointer is invalid.\n"));
		return NULL;
	}

	return m_pOwnerScopePane;
}

void CResultsPane::SetOwnerScopePane(CScopePane* pOwnerPane)
{
	TRACEX(_T("CResultsPane::SetOwnerScopePane\n"));
	TRACEARGn(pOwnerPane);

	if( ! CHECKOBJPTR(pOwnerPane,RUNTIME_CLASS(CScopePane),sizeof(CScopePane)) )
	{
		TRACE(_T("FAILED : Bad Scope Pane pointer passed.\n"));
		return;
	}

	m_pOwnerScopePane = pOwnerPane;

	return;
}


/////////////////////////////////////////////////////////////////////////////
// MMC Interface Members

LPCONSOLE2 CResultsPane::GetConsolePtr() const
{
	TRACEX(_T("CResultsPane::GetConsolePtr\n"));

	if( ! CHECKPTR(m_pIConsole,sizeof(IConsole2)) )
	{
		TRACE(_T("FAILED : m_pIConsole is invalid.\n"));
		return NULL;
	}

	m_pIConsole->AddRef();

	return m_pIConsole;
}

LPRESULTDATA CResultsPane::GetResultDataPtr() const
{
	TRACEX(_T("CResultsPane::GetResultDataPtr\n"));

	if( ! CHECKPTR(m_pIResultData,sizeof(IResultData)) )
	{
		TRACE(_T("FAILED : m_pIResultData is invalid.\n"));
		return NULL;
	}

	m_pIResultData->AddRef();

	return m_pIResultData;
}

LPHEADERCTRL2 CResultsPane::GetHeaderCtrlPtr() const
{
	TRACEX(_T("CResultsPane::GetHeaderCtrlPtr\n"));

	if( ! CHECKPTR(m_pIHeaderCtrl,sizeof(IHeaderCtrl2)) )
	{
		TRACE(_T("FAILED : m_pIHeaderCtrl is invalid.\n"));
		return NULL;
	}

	m_pIHeaderCtrl->AddRef();

	return m_pIHeaderCtrl;
}

LPCONTROLBAR CResultsPane::GetControlbarPtr() const
{
	TRACEX(_T("CResultsPane::GetControlbarPtr\n"));

	if( ! CHECKPTR(m_pIControlbar,sizeof(IControlbar)) )
	{
		TRACE(_T("FAILED : m_pIControlbar is invalid.\n"));
		return NULL;
	}

	m_pIControlbar->AddRef();

	return m_pIControlbar;
}

LPTOOLBAR CResultsPane::GetToolbarPtr() const
{
	TRACEX(_T("CResultsPane::GetToolbarPtr\n"));

	if( ! CHECKPTR(m_pIToolbar,sizeof(IToolbar)) )
	{
		TRACE(_T("FAILED : m_pIToolbar is invalid.\n"));
		return NULL;
	}

	m_pIToolbar->AddRef();

	return m_pIToolbar;
}

LPCONSOLEVERB CResultsPane::GetConsoleVerbPtr() const
{
	TRACEX(_T("CResultsPane::GetConsoleVerbPtr\n"));

	if( ! CHECKPTR(m_pIConsoleVerb,sizeof(IConsoleVerb)) )
	{
		TRACE(_T("FAILED : m_pIConsoleVerb is invalid.\n"));
		return NULL;
	}

	m_pIConsoleVerb->AddRef();

	return m_pIConsoleVerb;
}

LPIMAGELIST CResultsPane::GetImageListPtr() const
{
	TRACEX(_T("CResultsPane::GetImageListPtr\n"));

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		TRACE(_T("FAILED : m_pIImageList is invalid.\n"));
		return NULL;
	}

	m_pIImageList->AddRef();

	return m_pIImageList;
}

/////////////////////////////////////////////////////////////////////////////
// Control bar Members
/////////////////////////////////////////////////////////////////////////////

HRESULT CResultsPane::OnSetControlbar(LPCONTROLBAR pIControlbar)
{
	TRACEX(_T("CResultsPane::OnSetControlbar\n"));
	TRACEARGn(pIControlbar);

	HRESULT hr = S_OK;

	// default behavior simply creates an empty toolbar
	
	// override to add buttons or to disallow creation of a new toolbar

	if( pIControlbar )
	{
		if( ! GfxCheckPtr(pIControlbar,IControlbar) )
		{
			return E_FAIL;
		}
		
		// hold on to that controlbar pointer
		pIControlbar->AddRef();
		m_pIControlbar = pIControlbar;

		// create a new toolbar that is initially empty
		LPEXTENDCONTROLBAR lpExtendControlBar = (LPEXTENDCONTROLBAR)GetInterface(&IID_IExtendControlbar);
    hr = m_pIControlbar->Create(TOOLBAR,lpExtendControlBar,(LPUNKNOWN*)(&m_pIToolbar));    
	}
	else
	{
		// free the toolbar
		if( m_pIToolbar )
		{
			m_pIToolbar->Release();
			m_pIToolbar = NULL;
		}

		// free the controlbar
		if( m_pIControlbar )
		{
			m_pIControlbar->Release();
			m_pIControlbar = NULL;
		}
	}

	return hr;
}

HRESULT CResultsPane::OnControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	TRACEX(_T("CResultsPane::OnControlbarNotify\n"));
	TRACEARGn(event);
	TRACEARGn(arg);
	TRACEARGn(param);

	HRESULT hr = S_OK;

	// override this virtual function to add event handlers for toolbar buttons

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Results Item Icon Management
/////////////////////////////////////////////////////////////////////////////

int CResultsPane::AddIcon(UINT nIconResID)
{
	TRACEX(_T("CResultsPane::AddIcon\n"));
	TRACEARGn(nIconResID);

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		return -1;
	}

	// load icon
	HICON hIcon = AfxGetApp()->LoadIcon(nIconResID);
	if( hIcon == NULL )
	{
		TRACE(_T("FAILED : Icon with resid=%d not found"),nIconResID);
		return -1;
	}

	int nIconIndex = GetIconCount();

	// insert icon into image list
#ifndef IA64
	if( m_pIImageList->ImageListSetIcon((long*)hIcon, nIconIndex) != S_OK )
	{
		return -1;
	}
#endif // IA64

	// add resid and index to map
	m_IconMap.SetAt(nIconResID,nIconIndex);

	// return index of newly inserted image
	return nIconIndex;
}

int CResultsPane::GetIconIndex(UINT nIconResID)
{
	TRACEX(_T("CResultsPane::GetIconIndex\n"));
	TRACEARGn(nIconResID);

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		return -1;
	}
	
	// check map for an existing id
	int nIconIndex = -1;
	
	if( m_IconMap.Lookup(nIconResID,nIconIndex) )
	{
		// if exists, return index
		return nIconIndex;
	}

	// does not exist so add icon
	nIconIndex = AddIcon(nIconResID);

	// if it still does not exist, icon is not in resources
	if( nIconIndex != -1 )
		return nIconIndex;

	TRACE(_T("FAILED : Icon with Resource id=%d could not be loaded.\n"),nIconResID);

	return -1;
}

int CResultsPane::GetIconCount()
{
	TRACEX(_T("CResultsPane::GetIconCount\n"));

	return (int)m_IconMap.GetCount();
}

void CResultsPane::RemoveAllIcons()
{
	TRACEX(_T("CResultsPane::RemoveAllIcons\n"));

	m_IconMap.RemoveAll();
}

void CResultsPane::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CResultsPane, CCmdTarget)
	//{{AFX_MSG_MAP(CResultsPane)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CResultsPane, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CResultsPane)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IResultsPane to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A685B-9056-11D2-BD45-0000F87A3912}
static const IID IID_IResultsPane =
{ 0x7d4a685b, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CResultsPane, CCmdTarget)
	INTERFACE_PART(CResultsPane, IID_IResultsPane, Dispatch)
	INTERFACE_PART(CResultsPane, IID_IComponent, Component)
	INTERFACE_PART(CResultsPane, IID_IResultDataCompare, ResultDataCompare)
	INTERFACE_PART(CResultsPane, IID_IExtendContextMenu, ExtendContextMenu)
	INTERFACE_PART(CResultsPane, IID_IExtendPropertySheet2, ExtendPropertySheet2)
	INTERFACE_PART(CResultsPane, IID_IExtendControlbar, ExtendControlbar)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResultsPane message handlers

/////////////////////////////////////////////////////////////////////////////
// IComponent Interface Part

ULONG FAR EXPORT CResultsPane::XComponent::AddRef()
{
	METHOD_PROLOGUE(CResultsPane, Component)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CResultsPane::XComponent::Release()
{
	METHOD_PROLOGUE(CResultsPane, Component)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CResultsPane::XComponent::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CResultsPane, Component)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CResultsPane::XComponent::Initialize(
/* [in] */ LPCONSOLE lpConsole)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::Initialize\n"));
	TRACEARGn(lpConsole);

	if( ! pThis->OnCreate(lpConsole) )
	{
		return E_FAIL;
	}

  return S_OK;
}

HRESULT FAR EXPORT CResultsPane::XComponent::Notify(
/* [in] */ LPDATAOBJECT lpDataObject,
/* [in] */ MMC_NOTIFY_TYPE event,
/* [in] */ LPARAM arg,
/* [in] */ LPARAM param)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::Notify\n"));
	TRACEARGn(lpDataObject);
	TRACEARGn(event);
	TRACEARGn(arg);
	TRACEARGn(param);

  HRESULT hr = S_OK;

  switch( event )
  {
		case MMCN_ACTIVATE:
		{
			TRACE(_T("MMCN_ACTIVATE received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_ACTIVATE) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnActivate((int)arg);
		}
		break;

		case MMCN_ADD_IMAGES:
		{
			TRACE(_T("MMCN_ADD_IMAGES received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_ACTIVATE) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			pThis->RemoveAllIcons();

			pThis->m_pIImageList = (LPIMAGELIST)arg;

			hr = pItem->OnAddImages(pThis);
		}
		break;

		case MMCN_BTN_CLICK:
		{
			TRACE(_T("MMCN_BTN_CLICK received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnBtnClick((MMC_CONSOLE_VERB)param);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				hr = pView->OnBtnClick(pItem,(MMC_CONSOLE_VERB)param);
			}
		}
		break;

		case MMCN_CONTEXTHELP: // F1, Help Menu Item or Help Button selected
		{
			TRACE(_T("MMCN_CONTEXTHELP received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnContextHelp();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnContextHelp(pItem);
			}

		}
		break;

		case MMCN_CUTORMOVE:
		{
			TRACE(_T("MMCN_CUTORMOVE received.\n"));
			
			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(LPDATAOBJECT(arg));
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnCutOrMove();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				ASSERT(FALSE);
			}

		}
		break;

		case MMCN_DBLCLICK:
		{
			TRACE(_T("MMCN_DBLCLICK received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_RESULT )
			{
				return S_FALSE;
			}

			CResultsPaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			CResultsPaneView* pView = pItem->GetOwnerResultsView();

			if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
			{
				return E_FAIL;
			}

			hr = pView->OnDblClick(pItem);
		}
		break;


		case MMCN_DELETE:
		{
			TRACE(_T("MMCN_DELETE received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnDelete();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				hr = pView->OnDelete(pItem);
			}
		}
		break;

		case MMCN_EXPAND:
		{
			TRACE(_T("MMCN_EXPAND received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_EXPAND) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnExpand((int)arg);
		}
		break;


		case MMCN_INITOCX: // custom ocx in the results pane has been created
		{
			TRACE(_T("MMCN_INITOCX received.\n"));

			LPUNKNOWN pIUnknown = (LPUNKNOWN)param;
			if( ! CHECKPTR(pIUnknown,sizeof(IUnknown)) )
			{
				return E_FAIL;
			}

			if( ! pThis->OnCreateOcx(pIUnknown) )
			{
				TRACE(_T("FAILED : CResultsPane::OnCreateOcx failed.\n"));
				return E_FAIL;
			}

			hr = S_OK;
		}
		break;


		case MMCN_LISTPAD:
		{
			TRACE(_T("MMCN_LISTPAD received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_LISTPAD) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnListpad((int)arg);
		}
		break;

		case MMCN_MINIMIZED:
		{
			TRACE(_T("MMCN_MINIMIZED received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_MINIMIZED) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnMinimized((int)arg);
		}
		break;

		case MMCN_PASTE:
		{
			TRACE(_T("MMCN_PASTE received.\n"));
			
			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				LPDATAOBJECT pSelection = LPDATAOBJECT(arg);
				if( ! GfxCheckPtr(pSelection,IDataObject) )
				{
					return E_FAIL;
				}

				LPDATAOBJECT* ppCopiedItems = (LPDATAOBJECT*)param;

				hr = pItem->OnPaste(pSelection,ppCopiedItems);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				ASSERT(FALSE);
			}
		}
		break;

		case MMCN_PROPERTY_CHANGE:
		{
			TRACE(_T("MMCN_PROPERTY_CHANGE received.\n"));
			TRACE(_T("WARNING : Not implemented.\n"));
		}
		break;

		case MMCN_QUERY_PASTE:
		{
			TRACE(_T("MMCN_QUERY_PASTE received.\n"));			

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				LPDATAOBJECT pSelection = LPDATAOBJECT(arg);
				if( ! GfxCheckPtr(pSelection,IDataObject) )
				{
					return E_FAIL;
				}

				hr = pItem->OnQueryPaste(pSelection);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				ASSERT(FALSE);
			}
		}
		break;

		case MMCN_REFRESH:
		{
			TRACE(_T("MMCN_REFRESH received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnRefresh();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnRefresh();
			}
		}
		break;

		case MMCN_REMOVE_CHILDREN:
		{
			TRACE(_T("MMCN_REMOVE_CHILDREN received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_REMOVE_CHILDREN) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnRemoveChildren();

		}
		break;

		case MMCN_RENAME:
		{
			TRACE(_T("MMCN_RENAME received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( ! CHECKPTR((LPOLESTR)param,sizeof(LPOLESTR)) )
			{
				TRACE(_T("FAILED : Invalid string pointer passed.\n"));
				return E_INVALIDARG;
			}

			CString sNewName = (LPOLESTR)param;

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnRename(sNewName);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				hr = pView->OnRename(pItem, sNewName);
			}
		}
		break;

		case MMCN_RESTORE_VIEW:
		{
			TRACE(_T("MMCN_RESTORE_VIEW received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_RESTORE_VIEW) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			if( ! CHECKPTR((MMC_RESTORE_VIEW*)arg,sizeof(MMC_RESTORE_VIEW)) )
			{
				TRACE(_T("FAILED : Pointer to MMC_RESTORE_VIEW is invalid.\n"));
				return E_INVALIDARG;
			}

			if( ! CHECKPTR((BOOL*)param,sizeof(BOOL)) )
			{
				TRACE(_T("FAILED : Pointer to BOOL is invalid.\n"));
				return E_INVALIDARG;
			}

			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			hr = pItem->OnRestoreView((MMC_RESTORE_VIEW*)arg,(BOOL*)param);
		}
		break;

		case MMCN_SELECT:
		{
			TRACE(_T("MMCN_SELECT received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( !psdo || ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			BOOL bIsScopeItem = LOWORD(arg);
			BOOL bIsSelected = HIWORD(arg);

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				if( ! bIsScopeItem )
				{
					TRACE(_T("FAILED : Data Object is of type scope item where boolean flag indicates result item type.\n"));
					ASSERT(FALSE);
					return E_FAIL;
				}

				CScopePaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnSelect(pThis,bIsSelected);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				if( ! bIsScopeItem )
				{					
					TRACE(_T("FAILED : Data Object is of type result item where boolean flag indicates scope item type.\n"));
					ASSERT(FALSE);
					return E_FAIL;
				}

				CResultsPaneItem* pItem = NULL;

				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				hr = pView->OnSelect(pThis, pItem, bIsSelected);
			}

			if( pThis->m_pIControlbar )
			{
				hr = pThis->m_pIControlbar->Attach(TOOLBAR, (LPUNKNOWN)pThis->m_pIToolbar);
				ASSERT( SUCCEEDED(hr) );
			}

		}
		break;

		case MMCN_SHOW:
		{
			TRACE(_T("MMCN_SHOW received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);

			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() != CCT_SCOPE )
			{
				TRACE(_T("WARNING : IComponent::Notify(MMCN_SHOW) called with a result item instead of a scope item.\n"));
				return S_FALSE;
			}

			BOOL bIsSelected = (BOOL)arg;
			CScopePaneItem* pItem = NULL;

			if( ! psdo->GetItem(pItem) )
			{
				return E_FAIL;
			}

			ASSERT(pItem);

			CResultsPaneView* pView = pItem->GetResultsPaneView();

			if( ! pView )
			{
				TRACE(_T("FAILED : CScopePaneItem::GetResultsPaneView failed.\n"));
				return E_FAIL;
			}

			if( bIsSelected )
			{
				pView->AddResultsPane(pThis);
			}
			else
			{
				pView->RemoveResultsPane(pThis);
			}

			hr = pItem->OnShow(pThis,bIsSelected);

		}
		break;

		case MMCN_VIEW_CHANGE:
		{
			TRACE(_T("MMCN_VIEW_CHANGE received.\n"));
			TRACE(_T("WARNING : Not implmented.\n"));
		}
		break;
		
  }

  return hr;
}

HRESULT FAR EXPORT CResultsPane::XComponent::Destroy( 
/* [in] */ MMC_COOKIE cookie)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::Destroy\n"));
	TRACEARGn(cookie);

	if( ! pThis->OnDestroy() )
	{
		return E_FAIL;
	}

  return S_OK;
}

HRESULT FAR EXPORT CResultsPane::XComponent::QueryDataObject( 
/* [in] */ MMC_COOKIE cookie,
/* [in] */ DATA_OBJECT_TYPES type,
/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::QueryDataObject\n"));
	TRACEARGn(cookie);
	TRACEARGn(type);
	TRACEARGn(ppDataObject);

  HRESULT hr = S_OK;
  CSnapinDataObject* pdoNew = NULL;

	pdoNew = new CSnapinDataObject;
  
	if( ! pdoNew )
  {
    hr = E_OUTOFMEMORY;
		*ppDataObject = NULL;
		TRACE(_T("Out of memory.\n"));
    return hr;
  }

	*ppDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);


	if( ! CHECKOBJPTR(pdoNew,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

  if( cookie )
  {
		if( type == CCT_SCOPE )
		{
			CScopePaneItem* pItem = (CScopePaneItem*)cookie;
			if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
			{
				return E_FAIL;
			}

			pdoNew->SetItem(pItem);

			ASSERT(pdoNew->GetItemType() == CCT_SCOPE);
		}
		else if( type == CCT_RESULT )
		{
			CResultsPaneItem* pItem = (CResultsPaneItem*)cookie;
			if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
			{
				return E_FAIL;
			}

			pdoNew->SetItem(pItem);

			ASSERT(pdoNew->GetItemType() == CCT_RESULT);
		}
  }
  else // In this case the node is our root scope item, and was placed there for us by MMC.
  {
		CScopePane* pPane = pThis->GetOwnerScopePane();
		
		if( ! CHECKOBJPTR(pPane,RUNTIME_CLASS(CScopePane),sizeof(CScopePane)) )
		{
			return E_FAIL;
		}

    pdoNew->SetItem( pPane->GetRootScopeItem() );

		ASSERT(pdoNew->GetItemType() == CCT_SCOPE);
  }

  return hr;
}

HRESULT FAR EXPORT CResultsPane::XComponent::GetResultViewType( 
/* [in] */ MMC_COOKIE cookie,
/* [out] */ LPOLESTR __RPC_FAR *ppViewType,
/* [out] */ long __RPC_FAR *pViewOptions)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::GetResultViewType\n"));
	TRACEARGn(cookie);
	TRACEARGn(ppViewType);
	TRACEARGn(pViewOptions);

	CScopePaneItem* pItem = NULL;

	if( cookie == NULL ) // this is the root item
	{	
		CScopePane* pPane = pThis->GetOwnerScopePane();
		if( ! pPane )
		{
			TRACE(_T("FAIELD : CResultsPane::GetOwnerScopePane returns NULL.\n"));
			return E_FAIL;
		}
		pItem = pPane->GetRootScopeItem();
	}
	else
	{
		pItem = (CScopePaneItem*)cookie;
	}

	if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		TRACE(_T("FAILED : cookie passed to snapin is not a valid scope pane item type.\n"));
		return E_INVALIDARG;
	}

	ASSERT(pItem);
	
	CString sViewType;
	long lViewOptions = 0L;
	
	HRESULT hr = pItem->OnGetResultViewType(sViewType,lViewOptions);

	*pViewOptions = lViewOptions;

	if( ! sViewType.IsEmpty() )
	{
		*ppViewType = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((sViewType.GetLength() + 1)* sizeof(wchar_t)));
		if (*ppViewType == NULL)
			return E_OUTOFMEMORY;

		_tcscpy(*ppViewType, (LPCTSTR)sViewType);
	}
	else
	{
		*ppViewType = NULL;
	}

  return hr;
}

HRESULT FAR EXPORT CResultsPane::XComponent::GetDisplayInfo( 
/* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::GetDisplayInfo\n"));
	TRACEARGn(pResultDataItem);

	if( ! CHECKPTR(pResultDataItem,sizeof(RESULTDATAITEM)) )
	{
		TRACE(_T("FAILED : pResultDataItem is an invalid pointer.\n"));
		return E_INVALIDARG;
	}

  if( pResultDataItem->bScopeItem ) // for the scope pane items
  {
    CScopePaneItem* pItem = (CScopePaneItem*)pResultDataItem->lParam;
    if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
    {
      TRACE(_T("FAILED : Invalid lParam in RESULTDATAITEM struct.\n"));
      return E_FAIL;
    }

    if( pResultDataItem->mask & RDI_STR )
    {
			pResultDataItem->str = (LPTSTR)(LPCTSTR)pItem->GetDisplayName(pResultDataItem->nCol);
    }

    if( pResultDataItem->mask & RDI_IMAGE )  // Looking for image
    {
			UINT nIconId = 0;

			if( pResultDataItem->nState & LVIS_SELECTED ) // Show the open image
			{
				nIconId = pItem->GetOpenIconId();
			}
			else // show the regular image
			{
				nIconId = pItem->GetIconId();
			}

			int iIndex = pThis->GetIconIndex(nIconId);

			ASSERT(iIndex != -1);

			pResultDataItem->nImage = iIndex;

    }
  }
  else // for the results pane items
  {
    CResultsPaneItem* pItem = (CResultsPaneItem*)pResultDataItem->lParam;
    if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
    {
      TRACE(_T("FAILED : Invalid lParam in RESULTDATAITEM struct.\n"));
      return E_FAIL;
    }

    if( pResultDataItem->mask & RDI_STR )
    {
			pResultDataItem->str = (LPTSTR)(LPCTSTR)pItem->GetDisplayName(pResultDataItem->nCol);
    }

    if( pResultDataItem->mask & RDI_IMAGE )  // Looking for image
    {
			UINT nIconId = pItem->GetIconId();
			int iIndex = pThis->GetIconIndex(nIconId);

			ASSERT(iIndex != -1);

			pResultDataItem->nImage = iIndex;
    }
  }

  return S_OK;
}

HRESULT FAR EXPORT CResultsPane::XComponent::CompareObjects( 
/* [in] */ LPDATAOBJECT lpDataObjectA,
/* [in] */ LPDATAOBJECT lpDataObjectB)
{
  METHOD_PROLOGUE(CResultsPane, Component)
	TRACEX(_T("CResultsPane::XComponent::CompareObjects\n"));
	TRACEARGn(lpDataObjectA);
	TRACEARGn(lpDataObjectB);

  CSnapinDataObject* psdo1 = CSnapinDataObject::GetSnapinDataObject(lpDataObjectA);
	if( ! CHECKOBJPTR(psdo1,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	CSnapinDataObject* psdo2 = CSnapinDataObject::GetSnapinDataObject(lpDataObjectB);
	if( ! CHECKOBJPTR(psdo2,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	if( psdo1->GetCookie() != psdo2->GetCookie() )
		return S_FALSE;

	return S_OK;
}

// IComponent Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IResultDataCompare Interface Part

ULONG FAR EXPORT CResultsPane::XResultDataCompare::AddRef()
{
	METHOD_PROLOGUE(CResultsPane, ResultDataCompare)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CResultsPane::XResultDataCompare::Release()
{
	METHOD_PROLOGUE(CResultsPane, ResultDataCompare)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CResultsPane::XResultDataCompare::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CResultsPane, ResultDataCompare)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CResultsPane::XResultDataCompare::Compare( 
/* [in] */ LPARAM lUserParam,
/* [in] */ MMC_COOKIE cookieA,
/* [in] */ MMC_COOKIE cookieB,
/* [out][in] */ int __RPC_FAR *pnResult)
{
  METHOD_PROLOGUE(CResultsPane, ResultDataCompare)
	TRACEX(_T("CResultsPane::XResultDataCompare::Compare\n"));
	TRACEARGn(lUserParam);
	TRACEARGn(cookieA);
	TRACEARGn(cookieB);
	TRACEARGn(pnResult);

	HRESULT hr = S_OK;


	CResultsPaneItem* pItem1 = (CResultsPaneItem*)cookieA;
	if( ! CHECKOBJPTR(pItem1,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
	{
		return E_FAIL;
	}

	CResultsPaneItem* pItem2 = (CResultsPaneItem*)cookieB;
	if( ! CHECKOBJPTR(pItem2,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
	{
		return E_FAIL;
	}

	int iColumn = *pnResult;

	*pnResult = pItem1->CompareItem(pItem2,iColumn);

	return hr;
}

// IResultDataCompare Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Interface Part

ULONG FAR EXPORT CResultsPane::XExtendContextMenu::AddRef()
{
	METHOD_PROLOGUE(CResultsPane, ExtendContextMenu)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CResultsPane::XExtendContextMenu::Release()
{
	METHOD_PROLOGUE(CResultsPane, ExtendContextMenu)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CResultsPane::XExtendContextMenu::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CResultsPane, ExtendContextMenu)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CResultsPane::XExtendContextMenu::AddMenuItems( 
/* [in] */ LPDATAOBJECT piDataObject,
/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
/* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
  METHOD_PROLOGUE(CResultsPane, ExtendContextMenu)
	TRACEX(_T("CResultsPane::XExtendContextMenu::AddMenuItems\n"));
	TRACEARGn(piDataObject);
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(piDataObject);
	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	if( ! CHECKPTR(piCallback,sizeof(IContextMenuCallback)) )
	{
		return E_FAIL;
	}
	
  DATA_OBJECT_TYPES Type =  psdo->GetItemType();
  if( Type == CCT_SCOPE )
  {
		CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

    hr = pItem->OnAddMenuItems(piCallback,pInsertionAllowed);
    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CScopePaneItem::OnAddMenuItem failed.\n"));
    }
  }
  else if( Type == CCT_RESULT )
  {
    CResultsPaneItem* pItem = NULL;

		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

    hr = pView->OnAddMenuItems(pItem,piCallback,pInsertionAllowed);
    
		if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CResultsPaneView::OnAddMenuItem failed!\n"));
    }
  }

	return hr;
}

HRESULT FAR EXPORT CResultsPane::XExtendContextMenu::Command( 
/* [in] */ long lCommandID,
/* [in] */ LPDATAOBJECT piDataObject)
{
  METHOD_PROLOGUE(CResultsPane, ExtendContextMenu)
	TRACEX(_T("CResultsPane::XExtendContextMenu::Command\n"));
	TRACEARGn(lCommandID);
	TRACEARGn(piDataObject);

  HRESULT hr = S_OK;
	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(piDataObject);
	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

  DATA_OBJECT_TYPES Type =  psdo->GetItemType();
  if( Type == CCT_SCOPE )
  {
		CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

    hr = pItem->OnCommand(lCommandID);

    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CScopePaneItem::OnCommand failed.\n"));
    }
  }
  else if( Type == CCT_RESULT )
  {
    CResultsPaneItem* pItem = NULL;

		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

    hr = pView->OnCommand(pThis,pItem,lCommandID);
    
		if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CResultsPaneView::OnCommand failed!\n"));
    }
  }

	return hr;
}

// IExtendContextMenu Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet2 Interface Part

ULONG FAR EXPORT CResultsPane::XExtendPropertySheet2::AddRef()
{
	METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CResultsPane::XExtendPropertySheet2::Release()
{
	METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CResultsPane::XExtendPropertySheet2::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CResultsPane::XExtendPropertySheet2::CreatePropertyPages( 
/* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
/* [in] */ LONG_PTR handle,
/* [in] */ LPDATAOBJECT lpIDataObject)
{
  METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
	TRACEX(_T("CResultsPane::XExtendPropertySheet2::CreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);
	TRACEARGn(lpIDataObject);

  HRESULT hr = S_FALSE;

	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpIDataObject);
	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

	if( ! CHECKPTR(lpProvider,sizeof(IPropertySheetCallback)) )
	{
		return E_FAIL;
	}

  DATA_OBJECT_TYPES Type =  psdo->GetItemType();
  if( Type == CCT_SCOPE )
  {
		CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

    hr = pItem->OnCreatePropertyPages(lpProvider,handle);

    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CScopePaneItem::OnCreatePropertyPages failed.\n"));
    }
  }
  else if( Type == CCT_RESULT )
  {
    CResultsPaneItem* pItem = NULL;

		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

    hr = pView->OnCreatePropertyPages(pItem,lpProvider,handle);
    
		if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CResultsPaneView::OnCreatePropertyPages failed!\n"));
    }
  }
		
	return hr;
}

HRESULT FAR EXPORT CResultsPane::XExtendPropertySheet2::QueryPagesFor( 
/* [in] */ LPDATAOBJECT lpDataObject)
{
  METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
	TRACEX(_T("CResultsPane::XExtendPropertySheet2::QueryPagesFor\n"));
	TRACEARGn(lpDataObject);

  HRESULT hr = S_OK;

	CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

  DATA_OBJECT_TYPES Type =  psdo->GetItemType();
  if( Type == CCT_SCOPE )
  {
		CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

    hr = pItem->OnQueryPagesFor();

    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CScopePaneItem::OnQueryPagesFor failed.\n"));
    }
  }
  else if( Type == CCT_RESULT )
  {
    CResultsPaneItem* pItem = NULL;

		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

    hr = pView->OnQueryPagesFor(pItem);
    
		if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("FAILED : CResultsPaneView::OnQueryPagesFor failed!\n"));
    }
  }
		
	return hr;
}

HRESULT FAR EXPORT CResultsPane::XExtendPropertySheet2::GetWatermarks( 
/* [in] */ LPDATAOBJECT lpIDataObject,
/* [out] */ HBITMAP __RPC_FAR *lphWatermark,
/* [out] */ HBITMAP __RPC_FAR *lphHeader,
/* [out] */ HPALETTE __RPC_FAR *lphPalette,
/* [out] */ BOOL __RPC_FAR *bStretch)
{
  METHOD_PROLOGUE(CResultsPane, ExtendPropertySheet2)
	TRACEX(_T("CResultsPane::XExtendPropertySheet2::GetWatermarks\n"));
	TRACEARGn(lpIDataObject);
	TRACEARGn(lphWatermark);
	TRACEARGn(lphHeader);
	TRACEARGn(lphPalette);
	TRACEARGn(bStretch);

  HRESULT hr = S_OK;

	return hr;
}

// IExtendPropertySheet2 Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IExtendControlbar Interface Part

ULONG FAR EXPORT CResultsPane::XExtendControlbar::AddRef()
{
	METHOD_PROLOGUE(CResultsPane, ExtendControlbar)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CResultsPane::XExtendControlbar::Release()
{
	METHOD_PROLOGUE(CResultsPane, ExtendControlbar)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CResultsPane::XExtendControlbar::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CResultsPane, ExtendControlbar)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CResultsPane::XExtendControlbar::SetControlbar( 
/* [in] */ LPCONTROLBAR pControlbar)
{
  METHOD_PROLOGUE(CResultsPane, ExtendControlbar)
	TRACEX(_T("CResultsPane::XExtendControlbar::SetControlbar\n"));
	TRACEARGn(pControlbar);

	HRESULT hr = pThis->OnSetControlbar(pControlbar);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("WARNING : CResultsPane::OnSetControlbar failed.\n"));
	}

  return hr;
}

HRESULT FAR EXPORT CResultsPane::XExtendControlbar::ControlbarNotify( 
/* [in] */ MMC_NOTIFY_TYPE event,
/* [in] */ LPARAM arg,
/* [in] */ LPARAM param)
{
  METHOD_PROLOGUE(CResultsPane, ExtendControlbar)
	TRACEX(_T("CResultsPane::XExtendControlbar::ControlbarNotify\n"));
	TRACEARGn(event);
	TRACEARGn(arg);
	TRACEARGn(param);

	HRESULT hr = S_OK;

	hr = pThis->OnControlbarNotify(event,arg,param);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("WARNING : CResultsPane::OnControlbarNotify returned error code.\n"));
	}

  return hr;
}

// IExtendControlbar Interface Part
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rootresultsview.cpp ===
// RootResultsView.cpp: implementation of the CRootResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SnapIn.h"
#include "RootResultsView.h"
#include "SplitPaneResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CRootResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRootResultsView::CRootResultsView()
{

}

CRootResultsView::~CRootResultsView()
{

}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CRootResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CRootResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspaneview.cpp ===
// ResultsPaneView.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/30/00 v-marfin 59644 : GetUpperPaneSelectedCount(). Created to get the number of selected items so we can pass it 
//                           to the context menu so it knows whether to add the
//                           third party menu item "TroubleShooting" which it should
//                           only add if there is only 1 item selected.
// 04/02/00 v-marfin 59643b  On creation of new objects, show details page first.
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "ResultsPaneView.h"
#include "ScopePane.h"
#include "ResultsPane.h"

#include "HealthmonResultsPane.h"
#include "HMListView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResultsPaneView

IMPLEMENT_DYNCREATE(CResultsPaneView, CCmdTarget)

CResultsPaneView::CResultsPaneView()
{
	EnableAutomation();

	m_pOwnerScopeItem = NULL;
}

CResultsPaneView::~CResultsPaneView()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy

bool CResultsPaneView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CResultsPaneView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! GfxCheckObjPtr(pOwnerItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pOwnerItem is not a valid pointer.\n"));
		return false;
	}

	SetOwnerScopeItem(pOwnerItem);

	return true;
}

void CResultsPaneView::Destroy()
{
	TRACEX(_T("CResultsPaneView::Destroy\n"));

  RemoveAllItems();

	m_pOwnerScopeItem = NULL;

  for( int i=0; i < m_Columns.GetSize(); i++ )
  {
    delete m_Columns[i];
  }
  m_Columns.RemoveAll();

	m_ResultsPanes.RemoveAll();

}

/////////////////////////////////////////////////////////////////////////////
// Owner ScopeItem Members

CScopePaneItem* CResultsPaneView::GetOwnerScopeItem()
{
	TRACEX(_T("CResultsPaneView::GetOwnerScopeItem\n"));

	if( ! GfxCheckObjPtr(m_pOwnerScopeItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : m_pOwnerScopeItem is not a valid pointer.\n"));
		return NULL;
	}

	return m_pOwnerScopeItem;
}

void CResultsPaneView::SetOwnerScopeItem(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CResultsPaneView::SetOwnerScopeItem\n"));
	TRACEARGn(pOwnerItem);

	if( ! GfxCheckObjPtr(pOwnerItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pOwnerItem is not a valid pointer.\n"));
		return;
	}

	m_pOwnerScopeItem = pOwnerItem;
}


/////////////////////////////////////////////////////////////////////////////
// ListView Column Members

int CResultsPaneView::GetColumnCount() const
{
	TRACEX(_T("CResultsPaneView::GetColumnCount\n"));

	return (int)m_Columns.GetSize();
}

CListViewColumn* CResultsPaneView::GetColumn(int iIndex)
{
	TRACEX(_T("CResultsPaneView::GetColumn\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_Columns.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return NULL;
	}

	return m_Columns[iIndex];
}

void CResultsPaneView::SetColumn(int iIndex, CListViewColumn* pColumn)
{
	TRACEX(_T("CResultsPaneView::SetColumn\n"));
	TRACEARGn(iIndex);
	TRACEARGn(pColumn);

	if( iIndex >= m_Columns.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	if( ! GfxCheckObjPtr(pColumn,CListViewColumn) )
	{
		TRACE(_T("FAILED : pColumn is not a valid pointer.\n"));
		return;
	}

	m_Columns.SetAt(iIndex,pColumn);
}

int CResultsPaneView::AddColumn(CListViewColumn* pColumn)
{
	TRACEX(_T("CResultsPaneView::AddColumn\n"));
	TRACEARGn(pColumn);

	if( ! GfxCheckObjPtr(pColumn,CListViewColumn) )
	{
		TRACE(_T("FAILED : pColumn is not a valid pointer.\n"));
		return -1;
	}

	return (int)m_Columns.Add(pColumn);
}

void CResultsPaneView::RemoveColumn(int iIndex)
{
	TRACEX(_T("CResultsPaneView::RemoveColumn\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_Columns.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}
	
	delete m_Columns[iIndex];
	m_Columns.RemoveAt(iIndex);
}


/////////////////////////////////////////////////////////////////////////////
// Results Pane Item Members

int CResultsPaneView::GetItemCount() const
{
	TRACEX(_T("CResultsPaneView::GetItemCount\n"));

	return (int)m_ResultItems.GetSize();
}

CResultsPaneItem* CResultsPaneView::GetItem(int iIndex)
{
	TRACEX(_T("CResultsPaneView::GetItem\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ResultItems.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return NULL;
	}

	if( ! GfxCheckObjPtr(m_ResultItems[iIndex],CResultsPaneItem) )
	{
		TRACE(_T("FAILED : item pointer at iIndex is invalid.\n"));
		return NULL;
	}
	
	return m_ResultItems[iIndex];
}

int CResultsPaneView::AddItem(CResultsPaneItem* pItem, bool bResizeColumn /*= false*/)
{
	TRACEX(_T("CResultsPaneView::AddItem\n"));
	TRACEARGn(pItem);

	if( ! GfxCheckObjPtr(pItem,CResultsPaneItem) )
	{
		TRACE(_T("FAILED : pItem is not a valid pointer.\n"));
		return -1;
	}

	int iNewItemIndex = (int)m_ResultItems.Add(pItem);

	ASSERT(iNewItemIndex != -1);

	// for all result panes on this view, add the item into each pane
	for( int i = 0; i < m_ResultsPanes.GetSize(); i++ )	
	{
		if( ! pItem->InsertItem(m_ResultsPanes[i],0, bResizeColumn) )
		{
			TRACE(_T("FAILED : CResultsPaneItem::InsertItem failed.\n"));
			ASSERT(FALSE);			
		}
	}

	return iNewItemIndex;
}

void CResultsPaneView::RemoveItem(int iIndex)
{
	TRACEX(_T("CResultsPaneView::RemoveItem\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ResultItems.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	CResultsPaneItem* pItem = m_ResultItems[iIndex];

	if( ! GfxCheckObjPtr(pItem,CResultsPaneItem) )
	{
		TRACE(_T("FAILED : pItem is not a valid results pane item pointer.\n"));
		return;
	}

	// for each pane showing this results view, delete the item from it
	// this gets a little ugly...sorry
	for( int i=0; i < m_ResultsPanes.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_ResultsPanes[i],CResultsPane) )
		{
			LPRESULTDATA lpResultData = m_ResultsPanes[i]->GetResultDataPtr();

			if( lpResultData )
			{
				HRESULTITEM hri = NULL;

				if( lpResultData->FindItemByLParam((LPARAM)pItem,&hri) == S_OK )
				{
					HRESULT hr = lpResultData->DeleteItem(hri,0);
					if( ! CHECKHRESULT(hr) )
					{
						TRACE(_T("FAILED : IResultData::DeleteItem failed.\n"));
					}					
				}

				lpResultData->Release();
			}
		}
	}

	delete pItem;
	m_ResultItems.RemoveAt(iIndex);
}

void CResultsPaneView::RemoveItem(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::RemoveItem\n"));
	TRACEARGn(pItem);

	if( ! GfxCheckObjPtr(pItem,CResultsPaneItem) )
	{
		TRACE(_T("FAILED : pItem is not a valid pointer.\n"));
		return;
	}

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		if( pItem == m_ResultItems[i] )
		{
			RemoveItem(i);
			return;
		}
	}
}

void CResultsPaneView::RemoveItem(const CString& sName)
{
	TRACEX(_T("CResultsPaneView::RemoveItem\n"));

	if( sName.IsEmpty() )
	{
		TRACE(_T("FAILED : sName is empty.\n"));
		return;
	}

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_ResultItems[i],CResultsPaneItem) )
		{
			if( sName == m_ResultItems[i]->GetDisplayName() )
			{
				RemoveItem(i);
				return;
			}
		}
	}
}

int CResultsPaneView::FindItem(RPIFINDPROC pFindProc, LPARAM param)
{
	TRACEX(_T("CResultsPaneView::FindItem\n"));
	TRACEARGn(pFindProc);
	TRACEARGn(param);

	if( ! GfxCheckPtr(pFindProc,RPIFINDPROC) )
	{
		TRACE(_T("FAILED : pFindProc is not a valid function pointer.\n"));
		return -1;
	}

	return pFindProc(m_ResultItems,param);
}

bool CResultsPaneView::UpdateItem(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::UpdateItem\n"));
	TRACEARGn(pItem);
	
  if( ! GfxCheckObjPtr(pItem,CResultsPaneItem) )
  {
    TRACE(_T("FAILED : pItem is not a valid pointer.\n"));
    return false;
  }

  HRESULT hr = S_OK;

	for( int i=0; i < m_ResultsPanes.GetSize(); i++ )
	{
		hr = pItem->SetItem(m_ResultsPanes[i]);
		if( hr == S_FALSE || ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CResultsPaneItem::SetItem failed.\n"));
		}
	}

	return true;
}

void CResultsPaneView::UpdateAllItems()
{
	TRACEX(_T("CResultsPaneView::UpdateAllItems\n"));

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		if( ! UpdateItem(m_ResultItems[i]) )
		{
			TRACE(_T("FAILED : CResultsPaneView::UpdateItem failed.\n"));
		}
	}
}

void CResultsPaneView::RemoveAllItems()
{
	TRACEX(_T("CResultsPaneView::RemoveAllItems\n"));

	for( int i = (int)m_ResultItems.GetSize()-1; i >=0 ; i-- )
	{
		RemoveItem(i);
	}
}

bool CResultsPaneView::GetSelectedItems(ResultsPaneItemArray& rpiaSelectedItems)
{
	TRACEX(_T("CResultsPaneView::GetSelectedItems\n"));
	TRACEARGn(rpiaSelectedItems.GetSize());

	return true;
}

int CResultsPaneView::GetUpperPaneSelectedCount()
{
	TRACEX(_T("CResultsPaneView::GetUpperPaneSelectedCount\n"));

    // v-marfin 59644 : Get the number of selected items so we can pass it 
    //                  to the context menu so it knows whether to add the
    //                  third party menu item "TroubleShooting" which it should
    //                  only add if there is only 1 item selected.
    if (m_ResultsPanes.GetSize() < 1)
    {
        TRACE(_T("ERROR: CResultsPaneView::GetUpperPaneSelectedCount(): no results panes defined.\n"));
        return 0;
    }

    CHealthmonResultsPane* pPane = (CHealthmonResultsPane*)m_ResultsPanes[0];
    if (!pPane)
    {
        TRACE(_T("ERROR: CResultsPaneView::GetUpperPaneSelectedCount() : Could not fetch CHealthmonResultsPane\n"));
        return 0;
    }

    _DHMListView* pList = pPane->GetUpperListCtrl();
    if (!pList)
    {
        TRACE(_T("ERROR: CResultsPaneView::GetUpperPaneSelectedCount() : Could not fetch upper list control\n"));
        return 0;
    }

    int nSelectedCount = pList->GetSelectedCount();

	return nSelectedCount;
}

/////////////////////////////////////////////////////////////////////////////
// Property Page Members

bool CResultsPaneView::IsPropertySheetOpen()
{
	TRACEX(_T("CResultsPaneView::IsPropertySheetOpen\n"));

	// this function attempts to bring up an open property sheet for each result item
	// if it succeeds, then the property sheet is brought to the foreground
	// if it fails, then there are no open property sheets for the results view

	if( ! GetOwnerScopeItem() || ! GetOwnerScopeItem()->GetScopePane() )
	{
		TRACE(_T("FAILED : Owner scope item is not a valid object.\n"));
		return false;
	}

	LPCONSOLE2 lpConsole = GetOwnerScopeItem()->GetScopePane()->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return false;
	}

	// get a reference to the IPropertySheetProvider interface
	LPPROPERTYSHEETPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	bool bIsOpenSheet = false;

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		// create an IDataObject for this result item
		CSnapinDataObject* pdoNew = NULL;
		pdoNew = new CSnapinDataObject;

		if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
		{
			TRACE(_T("FAILED : Out of memory.\n"));
			lpProvider->Release();
			lpConsole->Release();
			return false;
		}

		LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
		ASSERT(lpDataObject);
		pdoNew->SetItem(m_ResultItems[i]);

		for( int i = 0; i < GetOwnerScopeItem()->GetScopePane()->GetResultsPaneCount(); i++ )
		{
			CResultsPane* pResultsPane = GetOwnerScopeItem()->GetScopePane()->GetResultsPane(i);
			if( GfxCheckObjPtr(pResultsPane,CResultsPane) )
			{
				LPCOMPONENT lpComponent = (LPCOMPONENT)pResultsPane->GetInterface(&IID_IComponent);
				hr = lpProvider->FindPropertySheet(MMC_COOKIE(this),lpComponent,lpDataObject);
				if( hr == S_OK )
				{
					bIsOpenSheet = true;
				}
			}
		}

		delete pdoNew;

	}

	lpProvider->Release();
	lpConsole->Release();

	return bIsOpenSheet;
}

bool CResultsPaneView::InvokePropertySheet(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::InvokePropertySheet\n"));
	TRACEARGn(pItem);

	// first see if a property sheet for this item is open already
	if( IsPropertySheetOpen() )
	{
		return true;
	}

	if( ! GetOwnerScopeItem() || ! GetOwnerScopeItem()->GetScopePane() )
	{
		TRACE(_T("FAILED : Owner scope item is not a valid object.\n"));
		return false;
	}

	LPCONSOLE2 lpConsole = GetOwnerScopeItem()->GetScopePane()->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return false;
	}

	// get a reference to the IPropertySheetProvider interface
	LPPROPERTYSHEETPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	// create an IDataObject for this result item
  CSnapinDataObject* pdoNew = NULL;
	pdoNew = new CSnapinDataObject;

	if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		lpProvider->Release();
		lpConsole->Release();
		return false;
	}

	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject);
	pdoNew->SetItem(pItem);

	hr = lpProvider->CreatePropertySheet(pItem->GetDisplayName(),TRUE,MMC_COOKIE(pItem),lpDataObject,MMC_PSO_HASHELP);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IPropertySheetProvider::CreatePropertySheet failed.\n"));
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

	HWND hWndNotification = NULL;
	HWND hWndMain = NULL;

	hr = lpConsole->GetMainWindow(&hWndMain);
	if( ! CHECKHRESULT(hr) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show( -1, 0);
		lpProvider->Release();
		lpConsole->Release();
		
		delete pdoNew;

		return false;
	}

	// Try to get the correct window that notifications should be sent to.
	hWndNotification = FindWindowEx( hWndMain, NULL, _T("MDIClient"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCChildFrm"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCView"), NULL );
	
	if( hWndNotification == NULL )
	{
		// It was a nice try, but it failed, so we should be able to get by by using the main HWND.
		hWndNotification = hWndMain;
	}

	LPCOMPONENTDATA lpComponentData = (LPCOMPONENTDATA)GetOwnerScopeItem()->GetScopePane()->GetInterface(&IID_IComponentData);

	hr = lpProvider->AddPrimaryPages(lpComponentData,TRUE,hWndNotification,TRUE);
	if( ! CHECKHRESULT(hr) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show(-1,0);
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

    hr = lpProvider->AddExtensionPages();  
	if( ! CHECKHRESULT(hr) )
	{
		// ISSUE: Should I care if this fails?

		// Release data allocated in CreatePropertySheet
		lpProvider->Show( -1, 0);
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

    // v-marfin : Show "details" page on creation of a new obejct
#ifndef IA64
    hr = lpProvider->Show( (long) hWndMain, 1);  // 59643b
#endif // IA64

	if( ! CHECKHRESULT( hr ) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show( -1, 0);
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

	lpProvider->Release();
	lpConsole->Release();

	delete pdoNew;

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Context Menu Members

bool CResultsPaneView::InvokeContextMenu(const CPoint& pt, CResultsPaneItem* pItem, int iSelectedCount)
{
	TRACEX(_T("CResultsPaneView::InvokeContextMenu\n"));
	TRACEARGn(pt.x);
	TRACEARGn(pt.y);
	TRACEARGn(pItem);

	ASSERT(m_ResultsPanes.GetSize());

	CResultsPane* pPane = m_ResultsPanes[0];
	if( !pPane || ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		return false;
	}

	LPCONSOLE2 lpConsole = pPane->GetConsolePtr();

	// get a reference to the IContextMenuProvider interface
	LPCONTEXTMENUPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IContextMenuProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	// just as a precaution
	hr = lpProvider->EmptyMenuList();

	// populate the menu
	CONTEXTMENUITEM cmi;
  CString sResString;
  CString sResString2;
	ZeroMemory(&cmi,sizeof(CONTEXTMENUITEM));

	// add the top insertion point
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// add new menu and insertion point

  sResString.LoadString(IDS_STRING_NEW);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
  sResString2.LoadString(IDS_STRING_NEW_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fFlags            = MF_POPUP;
	cmi.fSpecialFlags = CCM_SPECIAL_SUBMENU;

	hr = lpProvider->AddItem(&cmi);

	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// add task menu and insertion point

  sResString.LoadString(IDS_STRING_TASK);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
  sResString2.LoadString(IDS_STRING_TASK_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fFlags            = MF_POPUP;
	cmi.fSpecialFlags = CCM_SPECIAL_SUBMENU;

	hr = lpProvider->AddItem(&cmi);

	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// create an IDataObject for this results item
  CSnapinDataObject* pdoNew = NULL;
	pdoNew = new CSnapinDataObject;

	if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		lpProvider->Release();
		lpConsole->Release();
		return false;
	}

	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject);
	pdoNew->SetItem(pItem);

	LPUNKNOWN lpUnknown = (LPUNKNOWN)pPane->GetInterface(&IID_IExtendContextMenu);
	hr = lpProvider->AddPrimaryExtensionItems(lpUnknown,lpDataObject);

	// add third party insertion points only if there is 1 item selected
  if( iSelectedCount == 1 )
  {
	  cmi.lCommandID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
	  cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	  cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	  hr = lpProvider->AddItem(&cmi);

	  cmi.lCommandID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
	  cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	  cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	  hr = lpProvider->AddItem(&cmi);

	  hr = lpProvider->AddThirdPartyExtensionItems(lpDataObject);
  }

	HWND hWndMain = NULL;
	
	hr = lpConsole->GetMainWindow(&hWndMain);

	// Try to get the correct window that notifications should be sent to.
	HWND hWndNotification = FindWindowEx( hWndMain, NULL, _T("MDIClient"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCChildFrm"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("AfxFrameOrView42u"), NULL );
	if( hWndNotification == NULL )
	{
		// It was a nice try, but it failed, so we should be able to get by by using the main HWND.
		hWndNotification = hWndMain;
	}	

	long lSelected = 0L;
	hr = lpProvider->ShowContextMenu(hWndNotification,pt.x,pt.y,&lSelected);

	lpProvider->Release();
	lpConsole->Release();

	lpDataObject->Release();

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// Results Pane Members - tracks each results pane open on a particular results view

void CResultsPaneView::AddResultsPane(CResultsPane* pPane)
{
	TRACEX(_T("CResultsPaneView::AddResultsPane\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return;
	}

	m_ResultsPanes.Add(pPane);
}

void CResultsPaneView::RemoveResultsPane(CResultsPane* pPane)
{
	TRACEX(_T("CResultsPaneView::RemoveResultsPane\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return;
	}

	for( int i = 0; i < m_ResultsPanes.GetSize(); i++ )
	{
		if( m_ResultsPanes[i] == pPane )
		{
			m_ResultsPanes.RemoveAt(i);
			return;
		}
	} 
}

CResultsPane* CResultsPaneView::GetResultsPane(int iIndex)
{
	TRACEX(_T("CResultsPaneView::GetResultsPane\n"));
	TRACEARGn(iIndex);

	if( iIndex < 0 )
	{
		TRACE(_T("FAILED : index is out of bounds.\n"));
		return NULL;
	}

	if( iIndex > m_ResultsPanes.GetUpperBound() )
	{
		TRACE(_T("FAILED : index is out of bounds.\n"));
		return NULL;
	}
	
	return m_ResultsPanes[iIndex];
}

int CResultsPaneView::GetResultsPanesCount()
{
	TRACEX(_T("CResultsPaneView::GetResultsPanesCount\n"));

	return (int)m_ResultsPanes.GetSize();
}


/////////////////////////////////////////////////////////////////////////////
// MMC Notify Handlers

HRESULT CResultsPaneView::OnActivate(BOOL bActivate)
{
	TRACEX(_T("CResultsPaneView::OnActivate\n"));
	TRACEARGn(bActivate);

	return S_OK;
}

HRESULT CResultsPaneView::OnAddMenuItems(CResultsPaneItem* pItem, LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CResultsPaneView::OnAddMenuItems\n"));
	TRACEARGn(pItem);
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
    // TODO: Add any context menu items for the New Menu here
  }

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
	  // TODO: Add any context menu items for the Task Menu here
  }

	return pItem->OnAddMenuItems(piCallback,pInsertionAllowed);
}

HRESULT CResultsPaneView::OnBtnClick(CResultsPaneItem* pItem, MMC_CONSOLE_VERB mcvVerb)
{
	TRACEX(_T("CResultsPaneView::OnBtnClick\n"));
	TRACEARGn(pItem);
	TRACEARGn(mcvVerb);

	return S_OK;
}

HRESULT CResultsPaneView::OnCommand(CResultsPane* pPane, CResultsPaneItem* pItem, long lCommandID)
{
	TRACEX(_T("CResultsPaneView::OnCommand\n"));
	TRACEARGn(pPane);
	TRACEARGn(pItem);
	TRACEARGn(lCommandID);

	return pItem->OnCommand(pPane,lCommandID);
}

HRESULT CResultsPaneView::OnContextHelp(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::OnContextHelp\n"));
	TRACEARGn(pItem);

	if( ! GetOwnerScopeItem() )
	{
		return E_FAIL;
	}

	return GetOwnerScopeItem()->OnContextHelp();
}

HRESULT CResultsPaneView::OnCreatePropertyPages(CResultsPaneItem* pItem, LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CResultsPaneView::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);
	TRACEARGn(pItem);

	return S_FALSE;
}

HRESULT CResultsPaneView::OnDblClick(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::OnDblClick\n"));
	TRACEARGn(pItem);

	return S_FALSE;
}

HRESULT CResultsPaneView::OnDelete(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::OnDelete\n"));
	TRACEARGn(pItem);

	RemoveItem(pItem);

	return S_OK;
}

HRESULT CResultsPaneView::OnGetResultViewType(CString& sViewType,long& lViewOptions)
{
	TRACEX(_T("CResultsPaneView::OnGetResultViewType\n"));
	TRACEARGs(sViewType);
	TRACEARGn(lViewOptions);

	return S_OK;
}

HRESULT CResultsPaneView::OnMinimized(BOOL bMinimized)
{
	TRACEX(_T("CResultsPaneView::OnMinimized\n"));
	TRACEARGn(bMinimized);

	return S_OK;
}

HRESULT CResultsPaneView::OnPropertyChange(LPARAM lParam)
{
	TRACEX(_T("CResultsPaneView::OnPropertyChange\n"));
	TRACEARGn(lParam);

	return S_OK;
}

HRESULT CResultsPaneView::OnQueryPagesFor(CResultsPaneItem* pItem)
{
	TRACEX(_T("CResultsPaneView::OnQueryPagesFor\n"));
	TRACEARGn(pItem);

	return S_OK;
}

HRESULT CResultsPaneView::OnRefresh()
{
	TRACEX(_T("CResultsPaneView::OnRefresh\n"));

	return S_OK;
}

HRESULT CResultsPaneView::OnRename(CResultsPaneItem* pItem, const CString& sNewName)
{
	TRACEX(_T("CResultsPaneView::OnRename\n"));
	TRACEARGn(pItem);

	return S_OK;
}

HRESULT CResultsPaneView::OnRestoreView(MMC_RESTORE_VIEW* pRestoreView, BOOL* pbHandled)
{
	TRACEX(_T("CResultsPaneView::OnRestoreView\n"));
	TRACEARGn(pRestoreView);
	TRACEARGn(pbHandled);

	return S_OK;
}

HRESULT CResultsPaneView::OnSelect(CResultsPane* pPane, CResultsPaneItem* pItem, BOOL bSelected)
{
	TRACEX(_T("CResultsPaneView::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(pItem);
	TRACEARGn(bSelected);

	return S_OK;
}

HRESULT CResultsPaneView::OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem)
{
	TRACEX(_T("CResultsPaneView::OnShow\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelecting);
	TRACEARGn(hScopeItem);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	HRESULT hr = S_OK;

  if( bSelecting )
  {
    // add all the columns to the header control
    for( int i=0; i < GetColumnCount(); i++ )
    {
      CListViewColumn* pColumn = GetColumn(i);
			if( pColumn )
			{
				if( ! pColumn->InsertColumn(pPane,i) )
				{
					TRACE(_T("FAILED : CListViewColumn::InsertColumn failed.\n"));
				}
			}
    }

    // insert all the results pane items
    for( i=0; i < GetItemCount(); i++ )
    {
			CResultsPaneItem* pItem = GetItem(i);			
			if( pItem )
			{
				if( ! pItem->InsertItem(pPane,i,true) )
				{
					TRACE(_T("FAILED : CResultsPaneItem::InsertItem failed.\n"));
				}
			}
    }
  }
  else
  {
/*    // remember all the column sizes
    for( int i=0; i < GetColumnCount(); i++ )
    {
			CListViewColumn* pColumn = GetColumn(i);
			if( pColumn )
			{
				pColumn->SaveWidth(pPane,i);
			}
    }

		LPRESULTDATA lpResultData = pPane->GetResultDataPtr();
		if( ! GfxCheckPtr(lpResultData,IResultData) )
		{
			return E_FAIL;
		}

		// remember all the positions of the items
		for( i = 0; i < GetItemCount(); i++ )
		{
			CResultsPaneItem* pItem = NULL;
			RESULTDATAITEM rdi;
			ZeroMemory(&rdi,sizeof(rdi));
			rdi.mask = RDI_INDEX | RDI_PARAM;
			rdi.nIndex = i;
			hr = lpResultData->GetItem(&rdi);
			pItem = (CResultsPaneItem*)rdi.lParam;
			m_ResultItems.SetAt(i,pItem);
		}

		lpResultData->Release();
*/  }

  return hr;
}

HRESULT CResultsPaneView::OnViewChange(CResultsPaneItem* pItem, LONG lArg, LONG lHintParam)
{
	TRACEX(_T("CResultsPaneView::OnViewChange\n"));
	TRACEARGn(pItem);
	TRACEARGn(lArg);
	TRACEARGn(lHintParam);

	return S_OK;
}


void CResultsPaneView::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CResultsPaneView, CCmdTarget)
	//{{AFX_MSG_MAP(CResultsPaneView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CResultsPaneView, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CResultsPaneView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IResultsPaneView to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A6864-9056-11D2-BD45-0000F87A3912}
static const IID IID_IResultsPaneView =
{ 0x7d4a6864, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CResultsPaneView, CCmdTarget)
	INTERFACE_PART(CResultsPaneView, IID_IResultsPaneView, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResultsPaneView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rootresultsview.h ===
// RootResultsView.h: interface for the CRootResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ROOTRESULTSVIEW_H__1E782D92_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_ROOTRESULTSVIEW_H__1E782D92_AB0E_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CRootResultsView : public CSplitPaneResultsView  
{

DECLARE_DYNCREATE(CRootResultsView)

// Construction / Destruction
public:
	CRootResultsView();
	virtual ~CRootResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_ROOTRESULTSVIEW_H__1E782D92_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspane.h ===
#if !defined(AFX_RESULTSPANE_H__7D4A685C_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_RESULTSPANE_H__7D4A685C_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ResultsPane.h : header file
//

#include <mmc.h>

class CScopePane;

/////////////////////////////////////////////////////////////////////////////
// CResultsPane command target

class CResultsPane : public CCmdTarget
{

DECLARE_DYNCREATE(CResultsPane)

// Construction/Destruction
public:
	CResultsPane();
	virtual ~CResultsPane();

// Creation/Destruction overrideable members
protected:
	virtual bool OnCreate(LPCONSOLE pIConsole);
	virtual bool OnCreateOcx(LPUNKNOWN pIUnknown);
	virtual bool OnDestroy();

// Owner Scope Pane Members
public:
	CScopePane* GetOwnerScopePane() const;
	void SetOwnerScopePane(CScopePane* pOwnerPane);
protected:
	CScopePane* m_pOwnerScopePane;

// MMC Interface Members
public:
	LPCONSOLE2 GetConsolePtr() const;
	LPRESULTDATA GetResultDataPtr() const;
	LPHEADERCTRL2 GetHeaderCtrlPtr() const;
	LPCONTROLBAR GetControlbarPtr() const;
	LPTOOLBAR GetToolbarPtr() const;
	LPCONSOLEVERB GetConsoleVerbPtr() const;
	LPIMAGELIST GetImageListPtr() const;
protected:
	LPCONSOLE2 m_pIConsole;
	LPRESULTDATA m_pIResultData;
	LPHEADERCTRL2 m_pIHeaderCtrl;
	LPCONTROLBAR m_pIControlbar;
	LPTOOLBAR m_pIToolbar;
	LPCONSOLEVERB m_pIConsoleVerb;
	LPIMAGELIST m_pIImageList;

// Control bar Members
protected:
	virtual HRESULT OnSetControlbar(LPCONTROLBAR pIControlbar);
	virtual HRESULT OnControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// MMC Result Item Icon Management
public:
	int AddIcon(UINT nIconResID);
	int GetIconIndex(UINT nIconResID);
	int GetIconCount();
	void RemoveAllIcons();
protected:
	CMap<UINT,UINT,int,int> m_IconMap;

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResultsPane)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResultsPane)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CResultsPane)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	// IComponent Interface Part
	BEGIN_INTERFACE_PART(Component,IComponent)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
				/* [in] */ LPCONSOLE lpConsole);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
				/* [in] */ LPDATAOBJECT lpDataObject,
				/* [in] */ MMC_NOTIFY_TYPE event,
				/* [in] */ LPARAM arg,
				/* [in] */ LPARAM param);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
				/* [in] */ MMC_COOKIE cookie);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
				/* [in] */ MMC_COOKIE cookie,
				/* [in] */ DATA_OBJECT_TYPES type,
				/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
				/* [in] */ MMC_COOKIE cookie,
				/* [out] */ LPOLESTR __RPC_FAR *ppViewType,
				/* [out] */ long __RPC_FAR *pViewOptions);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
				/* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
				/* [in] */ LPDATAOBJECT lpDataObjectA,
				/* [in] */ LPDATAOBJECT lpDataObjectB);

	END_INTERFACE_PART(Component)

	// IResultDataCompare Interface Part
	BEGIN_INTERFACE_PART(ResultDataCompare,IResultDataCompare)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
				/* [in] */ LPARAM lUserParam,
				/* [in] */ MMC_COOKIE cookieA,
				/* [in] */ MMC_COOKIE cookieB,
				/* [out][in] */ int __RPC_FAR *pnResult);

	END_INTERFACE_PART(ResultDataCompare)

	// IExtendContextMenu Interface Part
	BEGIN_INTERFACE_PART(ExtendContextMenu,IExtendContextMenu)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
				/* [in] */ LPDATAOBJECT piDataObject,
				/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
				/* [out][in] */ long __RPC_FAR *pInsertionAllowed);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
				/* [in] */ long lCommandID,
				/* [in] */ LPDATAOBJECT piDataObject);

	END_INTERFACE_PART(ExtendContextMenu)

  // IExtendPropertySheet2 Interface Part
	BEGIN_INTERFACE_PART(ExtendPropertySheet2,IExtendPropertySheet2)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
				/* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
				/* [in] */ LONG_PTR handle,
				/* [in] */ LPDATAOBJECT lpIDataObject);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
				/* [in] */ LPDATAOBJECT lpDataObject);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);

	END_INTERFACE_PART(ExtendPropertySheet2)

  // IExtendControlbar Interface Part
	BEGIN_INTERFACE_PART(ExtendControlbar,IExtendControlbar)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
				/* [in] */ LPCONTROLBAR pControlbar);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
				/* [in] */ MMC_NOTIFY_TYPE event,
				/* [in] */ LPARAM arg,
				/* [in] */ LPARAM param);

	END_INTERFACE_PART(ExtendControlbar)

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTSPANE_H__7D4A685C_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspaneitem.cpp ===
// ResultsPaneItem.cpp : implementation file
//

#include "stdafx.h"
#include "ResultsPaneView.h"
#include "ResultsPaneItem.h"
#include "ResultsPane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {8A7DC72D-2D81-11d3-BE0E-0000F87A3912}
static GUID GUID_ResultItem = 
{ 0x8a7dc72d, 0x2d81, 0x11d3, { 0xbe, 0xe, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

LPGUID CResultsPaneItem::m_lpguidItemType = &GUID_ResultItem;

/////////////////////////////////////////////////////////////////////////////
// CResultsPaneItem

IMPLEMENT_DYNCREATE(CResultsPaneItem, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CResultsPaneItem::CResultsPaneItem()
{
	EnableAutomation();

	m_pOwnerResultsView = NULL;
	m_hResultItem = NULL;
	m_iCurrentIconIndex = -1;
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CResultsPaneItem::~CResultsPaneItem()
{
	Destroy();

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy

bool CResultsPaneItem::Create(CResultsPaneView* pOwnerView, const CStringArray& saNames, CUIntArray& uiaIconResIds, int iIconIndex)
{
	TRACEX(_T("CResultsPaneItem::Create\n"));
	TRACEARGn(pOwnerView);
	TRACEARGn(saNames.GetSize());
	TRACEARGn(uiaIconResIds.GetSize());
	TRACEARGn(iIconIndex);

	if( ! GfxCheckObjPtr(pOwnerView,CResultsPaneView) )
	{
		TRACE(_T("FAILED : pOwnerView is an invalid pointer.\n"));
		return false;
	}

	SetOwnerResultsView(pOwnerView);

	if( saNames.GetSize() )
	{
		SetDisplayNames(saNames);
	}

	if( uiaIconResIds.GetSize() )
	{
		SetIconIds(uiaIconResIds);
	}

	SetIconIndex(iIconIndex);

	return true;
}

bool CResultsPaneItem::Create(CResultsPaneView* pOwnerView)
{
	TRACEX(_T("CResultsPaneItem::Create\n"));
	TRACEARGn(pOwnerView);

	if( ! GfxCheckObjPtr(pOwnerView,CResultsPaneView) )
	{
		TRACE(_T("FAILED : pOwnerView is an invalid pointer.\n"));
		return false;
	}

	SetOwnerResultsView(pOwnerView);

	return true;
}

void CResultsPaneItem::Destroy()
{
	TRACEX(_T("CResultsPaneItem::Destroy\n"));

	m_IconResIds.RemoveAll();
	m_saDisplayNames.RemoveAll();
	m_iCurrentIconIndex = -1;
	m_hResultItem = NULL;
	m_pOwnerResultsView = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Owner ResultsView Members

CResultsPaneView* CResultsPaneItem::GetOwnerResultsView()
{
	TRACEX(_T("CResultsPaneItem::GetOwnerResultsView\n"));

	if( GfxCheckObjPtr(m_pOwnerResultsView,CResultsPaneView) )
		return m_pOwnerResultsView;

	TRACE(_T("FAILED : m_pOwnerResultsView is not valid.\n"));

	return NULL;
}

void CResultsPaneItem::SetOwnerResultsView(CResultsPaneView* pView)
{
	TRACEX(_T("CResultsPaneItem::SetOwnerResultsView\n"));
	TRACEARGn(pView);

	if( ! GfxCheckObjPtr(pView,CResultsPaneView) )	
	{
		TRACE(_T("FAILED : pView is not a valid pointer.\n"));
		return;
	}

	m_pOwnerResultsView = pView;
}

/////////////////////////////////////////////////////////////////////////////
// Display Names Members

CString CResultsPaneItem::GetDisplayName(int nIndex /* = 0*/)
{
	TRACEX(_T("CResultsPaneItem::GetDisplayName\n"));
	TRACEARGn(nIndex);

	if( nIndex >= m_saDisplayNames.GetSize() || nIndex < 0 )
	{
		TRACE(_T("FAILED : nIndex is out of array bounds.\n"));
		return _T("");
	}

	return m_saDisplayNames[nIndex];	
}

void CResultsPaneItem::SetDisplayName(int nIndex, const CString& sName)
{
	TRACEX(_T("CResultsPaneItem::SetDisplayName\n"));
	TRACEARGn(nIndex);

	if( nIndex >= m_saDisplayNames.GetSize() || nIndex < 0 )
	{
		TRACE(_T("FAILED : nIndex is out of array bounds.\n"));
		return;
	}

	m_saDisplayNames.SetAt(nIndex,sName);
}

void CResultsPaneItem::SetDisplayNames(const CStringArray& saNames)
{
	TRACEX(_T("CResultsPaneItem::SetDisplayNames\n"));	
	TRACEARGn(saNames.GetSize());

	m_saDisplayNames.Copy(saNames);
}

/////////////////////////////////////////////////////////////////////////////
// MMC-Related Members

bool CResultsPaneItem::InsertItem(CResultsPane* pPane, int nIndex, bool bResizeColumns /*= false*/)
{
	TRACEX(_T("CResultsPaneItem::InsertItem\n"));
	TRACEARGn(pPane);
	TRACEARGn(nIndex);
	TRACEARGn(bResizeColumns);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return false;
	}

  HRESULT hr = S_OK;
  RESULTDATAITEM rdi;

  ZeroMemory(&rdi,sizeof(rdi));

	rdi.mask =   RDI_STR     |    // displayname is valid
							 RDI_IMAGE   |    // nImage is valid
							 RDI_INDEX	 |		// nIndex is valid
							 RDI_PARAM;       // lParam is valid
	rdi.nIndex = nIndex;
  rdi.str    = MMC_CALLBACK;
  rdi.nImage = pPane->GetIconIndex(GetIconId());
  rdi.lParam = (LPARAM)this;


	LPRESULTDATA lpResultData = pPane->GetResultDataPtr();
	
	if( ! GfxCheckPtr(lpResultData,IResultData) )
	{
		TRACE(_T("FAILED : CResultsPane::GetResultDataPtr returns an invalid pointer.\n"));
		return false;
	}
	
  hr = lpResultData->InsertItem( &rdi );

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IResultData::InsertItem failed.\n"));
    return false;
	}

  m_hResultItem = rdi.itemID;

	ASSERT(m_hResultItem);

	if( bResizeColumns )
	{
		LPHEADERCTRL2 lpHeaderCtrl = pPane->GetHeaderCtrlPtr();

		if( GfxCheckPtr(lpHeaderCtrl,IHeaderCtrl2) )
		{
			CDC dc;
			dc.Attach(GetDC(NULL));
			int iWidth = 0;
		
			// set the widths of the columns for this item
			for( int  i = 0; i < m_saDisplayNames.GetSize(); i++ )
			{
				// get the width in pixels of the item
				CSize size  = dc.GetTextExtent(m_saDisplayNames[i]);
				lpHeaderCtrl->GetColumnWidth(i,&iWidth);
				if( size.cx > iWidth )
					lpHeaderCtrl->SetColumnWidth(i,size.cx);
			}
			HDC hDC = dc.Detach();
			int iResult = ReleaseDC(NULL,hDC);
			ASSERT(iResult == 1);

			lpHeaderCtrl->Release();
		}
	}

	lpResultData->Release();

  return true;
}

bool CResultsPaneItem::SetItem(CResultsPane* pPane)
{
	TRACEX(_T("CResultsPaneItem::SetItem\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is an invalid pointer.\n"));
		return false;
	}

  HRESULT hr = S_OK;

  RESULTDATAITEM rdi;

  ZeroMemory(&rdi,sizeof(rdi));

  rdi.mask =   RDI_STR     |    // displayname is valid
               RDI_IMAGE;       // nImage is valid
  rdi.str    = MMC_CALLBACK;
  rdi.nImage = pPane->GetIconIndex(GetIconId());

	LPRESULTDATA lpResultData = pPane->GetResultDataPtr();

	if( ! GfxCheckPtr(lpResultData,IResultData) )
	{
		TRACE(_T("FAILED : lpResultData is an invalid pointer.\n"));
		return false;
	}

	hr = lpResultData->FindItemByLParam((LPARAM)this,&rdi.itemID);
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IResultData::FindItemByLParam failed.\n"));
		lpResultData->Release();
		return false;
	}

  hr = lpResultData->SetItem( &rdi );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IResultData::SetItem failed.\n"));
		lpResultData->Release();
		return false;
	}

	lpResultData->Release();

	return true;
}

int CResultsPaneItem::CompareItem(CResultsPaneItem* pItem, int iColumn /*= 0*/ )
{
	TRACEX(_T("CResultsPaneItem::CompareItem\n"));
	TRACEARGn(pItem);
	TRACEARGn(iColumn);


	CString sDisplayName1 = GetDisplayName(iColumn);
	CString sDisplayName2 = pItem->GetDisplayName(iColumn);

    //---------------------------------------------------------
    // v-marfin : 60246 Detect numeric type and compare on that
    long dw1=0,dw2=0;
    dw1 = _ttol((TCHAR*)(const TCHAR*)sDisplayName1);
    dw2 = _ttol((TCHAR*)(const TCHAR*)sDisplayName2);
    if ((dw1==0) && (dw2==0))
    {
        // Could not convert to numeric, so sort as string
        return sDisplayName1.CompareNoCase(sDisplayName2);
    }
    else
    {
        if (dw1 < dw2) return -1; 
        if (dw1 > dw2) return 1;
        return 0;
    }
    //---------------------------------------------------------
	
}

bool CResultsPaneItem::RemoveItem(CResultsPane* pPane)
{
	TRACEX(_T("CResultsPaneItem::RemoveItem\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is an invalid pointer.\n"));
		return false;
	}

	LPRESULTDATA lpResultData = pPane->GetResultDataPtr();

	if( ! lpResultData )
	{
		TRACE(_T("FAILED : CResultsPane::GetResultDataPtr returned NULL.\n"));
		return false;
	}

	HRESULTITEM hri = NULL;

	if( lpResultData->FindItemByLParam((LPARAM)this,&hri) == S_OK )
	{
		HRESULT hr = lpResultData->DeleteItem(hri,0);
		if( ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : IResultData::DeleteItem failed.\n"));
			lpResultData->Release();
			return false;
		}					
	}

	lpResultData->Release();

	return true;
}

HRESULTITEM CResultsPaneItem::GetItemHandle()
{
	TRACEX(_T("CResultsPaneItem::GetItemHandle\n"));

	if( m_hResultItem == NULL )
	{
		TRACE(_T("WARNING : m_hResultItem is NULL.\n"));
	}

	return m_hResultItem;
}

HRESULT CResultsPaneItem::WriteExtensionData(LPSTREAM pStream)
{
	TRACEX(_T("CResultsPaneItem::WriteExtensionData\n"));
	TRACEARGn(pStream);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Icon Members

void CResultsPaneItem::SetIconIndex(int iIndex)
{
	TRACEX(_T("CResultsPaneItem::SetIconIndex\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_IconResIds.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	m_iCurrentIconIndex = iIndex;
}

int CResultsPaneItem::GetIconIndex()
{
	TRACEX(_T("CResultsPaneItem::GetIconIndex\n"));

	if( m_iCurrentIconIndex >= m_IconResIds.GetSize() || m_iCurrentIconIndex < 0 )
	{
		TRACE(_T("WARNING : m_iCurrentIconIndex is out of array bounds.\n"));
		return -1;
	}

	return m_iCurrentIconIndex;
}

UINT CResultsPaneItem::GetIconId()
{
	TRACEX(_T("CResultsPaneItem::GetIconId\n"));

	if( m_iCurrentIconIndex >= m_IconResIds.GetSize() || m_iCurrentIconIndex < 0 )
	{
		TRACE(_T("FAILED : m_iCurrentIconIndex is out of array bounds.\n"));
		return 0;
	}

	return m_IconResIds[m_iCurrentIconIndex];
}

void CResultsPaneItem::SetIconIds(CUIntArray& uiaIconResIds)
{
	TRACEX(_T("CResultsPaneItem::SetIconIds\n"));
	TRACEARGn(uiaIconResIds.GetSize());

	m_IconResIds.Copy(uiaIconResIds);
	m_iCurrentIconIndex = -1;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Notify Handlers

HRESULT CResultsPaneItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CResultsPaneItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
    // TODO: Add any context menu items for the New Menu here
  }

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
	  // TODO: Add any context menu items for the Task Menu here
  }

	  // Add Top Menu Items
  if( CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed )
  {
	  // TODO: Add any context menu items for the Task Menu here
  }


	return S_OK;
}

HRESULT CResultsPaneItem::OnCommand(CResultsPane* pPane, long lCommandID)
{
	TRACEX(_T("CResultsPaneItem::OnCommand\n"));
	TRACEARGn(pPane);
	TRACEARGn(lCommandID);

	return S_OK;
}


void CResultsPaneItem::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CResultsPaneItem, CCmdTarget)
	//{{AFX_MSG_MAP(CResultsPaneItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CResultsPaneItem, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CResultsPaneItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IResultsPaneItem to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A6867-9056-11D2-BD45-0000F87A3912}
static const IID IID_IResultsPaneItem =
{ 0x7d4a6867, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CResultsPaneItem, CCmdTarget)
	INTERFACE_PART(CResultsPaneItem, IID_IResultsPaneItem, Dispatch)
END_INTERFACE_MAP()

// {7D4A6868-9056-11D2-BD45-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CResultsPaneItem, "SnapIn.ResultsPaneItem", 0x7d4a6868, 0x9056, 0x11d2, 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CResultsPaneItem::CResultsPaneItemFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CResultsPaneItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspaneview.h ===
#if !defined(AFX_RESULTSPANEVIEW_H__7D4A6865_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_RESULTSPANEVIEW_H__7D4A6865_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ResultsPaneView.h : header file
//

#include <mmc.h>
#include "ScopePaneItem.h"
#include "ResultsPaneItem.h"
#include "ListViewColumn.h"

typedef int (*RPIFINDPROC) (const ResultsPaneItemArray& ResultsItems, LPARAM param);

/////////////////////////////////////////////////////////////////////////////
// CResultsPaneView command target

class CResultsPaneView : public CCmdTarget
{
	DECLARE_DYNCREATE(CResultsPaneView)

// Construction/Destruction
public:
	CResultsPaneView();
	virtual ~CResultsPaneView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);
	virtual void Destroy();

// Owner ScopeItem Members
public:
	CScopePaneItem* GetOwnerScopeItem();
	void SetOwnerScopeItem(CScopePaneItem* pOwnerItem);
protected:
	CScopePaneItem* m_pOwnerScopeItem;

// ListView Column Members
public:
	int GetColumnCount() const;
	CListViewColumn* GetColumn(int iIndex);
	void SetColumn(int iIndex, CListViewColumn* pColumn);
	int AddColumn(CListViewColumn* pColumn);
	void RemoveColumn(int iIndex);
protected:
	ListViewColumnArray m_Columns;

// Results Pane Item Members
public:
	int GetItemCount() const;
	CResultsPaneItem* GetItem(int iIndex);
	int AddItem(CResultsPaneItem* pItem, bool bResizeColumn = false);
	virtual void RemoveItem(int iIndex);
	void RemoveItem(CResultsPaneItem* pItem);
	void RemoveItem(const CString& sName);
	int FindItem(RPIFINDPROC pFindProc, LPARAM param);
	bool UpdateItem(CResultsPaneItem* pItem);
	void UpdateAllItems();
	void RemoveAllItems();
	bool GetSelectedItems(ResultsPaneItemArray& rpiaSelectedItems);
    int GetUpperPaneSelectedCount();  // v-marfin 59644 : Added this function to fetch the selected
                             //                  count from the upper results pane.
protected:
	ResultsPaneItemArray m_ResultItems;

// Property Sheet Members
public:
	bool IsPropertySheetOpen();
	bool InvokePropertySheet(CResultsPaneItem* pItem);

// Context Menu Members
public:
	bool InvokeContextMenu(const CPoint& pt, CResultsPaneItem* pItem, int iSelectedCount);

// Results Pane Members - tracks each results pane open on a particular results view
public:
	void AddResultsPane(CResultsPane* pPane);
	CResultsPane* GetResultsPane(int iIndex);
	int GetResultsPanesCount();
	void RemoveResultsPane(CResultsPane* pPane);
protected:
	CTypedPtrArray<CObArray,CResultsPane*> m_ResultsPanes;

// MMC Notify Handlers
public:
  virtual HRESULT OnActivate(BOOL bActivate);
  virtual HRESULT OnAddMenuItems(CResultsPaneItem* pItem, LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnBtnClick(CResultsPaneItem* pItem, MMC_CONSOLE_VERB mcvVerb);
  virtual HRESULT OnCommand(CResultsPane* pPane, CResultsPaneItem* pItem, long lCommandID);
	virtual HRESULT OnContextHelp(CResultsPaneItem* pItem);
	virtual HRESULT OnCreatePropertyPages(CResultsPaneItem* pItem, LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnDblClick(CResultsPaneItem* pItem);
  virtual HRESULT OnDelete(CResultsPaneItem* pItem);
	virtual HRESULT OnGetResultViewType(CString& sViewType,long& lViewOptions);
  virtual HRESULT OnMinimized(BOOL bMinimized);
  virtual HRESULT OnPropertyChange(LPARAM lParam);
	virtual HRESULT OnQueryPagesFor(CResultsPaneItem* pItem);
	virtual HRESULT OnRefresh();
	virtual HRESULT OnRename(CResultsPaneItem* pItem, const CString& sNewName);
	virtual HRESULT OnRestoreView(MMC_RESTORE_VIEW* pRestoreView, BOOL* pbHandled);
  virtual HRESULT OnSelect(CResultsPane* pPane, CResultsPaneItem* pItem, BOOL bSelected);
  virtual HRESULT OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem);
  virtual HRESULT OnViewChange(CResultsPaneItem* pItem, LONG lArg, LONG lHintParam);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResultsPaneView)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResultsPaneView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CResultsPaneView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTSPANEVIEW_H__7D4A6865_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\resultspaneitem.h ===
#if !defined(AFX_RESULTSPANEITEM_H__7D4A6869_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_RESULTSPANEITEM_H__7D4A6869_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ResultsPaneItem.h : header file
//

#include <mmc.h>

class CResultsPaneView;
class CResultsPane;

/////////////////////////////////////////////////////////////////////////////
// CResultsPaneItem command target

class CResultsPaneItem : public CCmdTarget
{

DECLARE_DYNCREATE(CResultsPaneItem)

// Construction/Destruction
public:
	CResultsPaneItem();
	virtual ~CResultsPaneItem();

// Create/Destroy
public:
	virtual bool Create(CResultsPaneView* pOwnerView, const CStringArray& saNames, CUIntArray& uiaIconResIds, int iIconIndex);
	virtual bool Create(CResultsPaneView* pOwnerView);
	virtual void Destroy();

// Owner ResultsView Members
public:
	CResultsPaneView* GetOwnerResultsView();
	void SetOwnerResultsView(CResultsPaneView* pView);
protected:
	CResultsPaneView* m_pOwnerResultsView;

// Display Names Members
public:
	virtual CString GetDisplayName(int nIndex = 0);
	int GetDisplayNameCount() { return (int)m_saDisplayNames.GetSize(); }
	void SetDisplayName(int nIndex, const CString& sName);
	void SetDisplayNames(const CStringArray& saNames);
protected:
	CStringArray m_saDisplayNames;

// MMC-Related Members
public:
	virtual bool InsertItem(CResultsPane* pPane, int iIndex, bool bResizeColumns = false);
	virtual bool SetItem(CResultsPane* pPane);
	virtual int CompareItem(CResultsPaneItem* pItem, int iColumn = 0);
	virtual bool RemoveItem(CResultsPane* pPane);
	HRESULTITEM GetItemHandle();		
	virtual LPGUID GetItemType() { return m_lpguidItemType; }
	virtual HRESULT WriteExtensionData(LPSTREAM pStream);
protected:
	static LPGUID m_lpguidItemType;
	HRESULTITEM m_hResultItem;

// Icon Members
public:
	void SetIconIndex(int iIndex);
	int GetIconIndex();
	UINT GetIconId();
	void SetIconIds(CUIntArray& uiaIconResIds);
protected:
	CUIntArray m_IconResIds;
	int m_iCurrentIconIndex;

// MMC Notify Handlers
public:
	virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
	virtual HRESULT OnCommand(CResultsPane* pPane, long lCommandID);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResultsPaneItem)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResultsPaneItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CResultsPaneItem)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CResultsPaneItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

typedef CTypedPtrArray<CObArray,CResultsPaneItem*> ResultsPaneItemArray;

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTSPANEITEM_H__7D4A6869_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rootscopeitem.cpp ===
// RootScopeItem.cpp: implementation of the CRootScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "RootScopeItem.h"
#include "RootResultsView.h"
#include "AllSystemsScopeItem.h"
#include "configScopeItem.h"
#include "ResultsPane.h"
#include "HMGeneralPage.h"
#include "HMHistoryPage.h"
#include "SystemGroup.h"
#include "HealthmonScopePane.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CRootScopeItem,CHMScopeItem)

// {FB1B60EF-AFD4-11d2-BD6B-0000F87A3912}
static GUID GUID_Root = 
{ 0xfb1b60ef, 0xafd4, 0x11d2, { 0xbd, 0x6b, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };


// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
		IDI_ICON_HEALTHMON,
		IDI_ICON_HEALTHMON_DISABLED,
		IDI_ICON_HEALTHMON_OUTAGE,
		IDI_ICON_HEALTHMON_UNKNOWN,
		IDI_ICON_HEALTHMON_NO_CONNECT,
		IDI_ICON_HEALTHMON_WARNING,
		IDI_ICON_HEALTHMON_CRITICAL
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRootScopeItem::CRootScopeItem()
{
	m_lpguidItemType = &GUID_Root;
	CString sName;
	sName.LoadString(IDS_STRING_ROOT_NODE);
	SetDisplayName(0,sName);
}

CRootScopeItem::~CRootScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CRootScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CRootScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	if( ! CHMScopeItem::Create(pScopePane,NULL) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}

	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	return true;
}

//////////////////////////////////////////////////////////////////////
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CRootScopeItem::CreateResultsPaneView()
{
	TRACE(_T("CRootScopeItem::CreateResultsPaneView\n"));
	return new CRootResultsView;
}

/////////////////////////////////////////////////////////////////////////////
// Messaging Members

LRESULT CRootScopeItem::MsgProc(UINT msg, WPARAM wparam, LPARAM lparam)
{
	TRACEX(_T("CRootScopeItem::MsgProc\n"));
	TRACEARGn(msg);
	TRACEARGn(wparam);
	TRACEARGn(lparam);

	if( msg == WM_SETTINGCHANGE )
	{
		CScopePane* pPane = GetScopePane();
		if( pPane && pPane->GetSelectedScopeItem() )
		{
			pPane->GetSelectedScopeItem()->SelectItem();
		}
	}

	return 0L;
}

//////////////////////////////////////////////////////////////////////
// MMC Message Handlers
//////////////////////////////////////////////////////////////////////

HRESULT CRootScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CRootScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_GROUP;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_RESET_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_RESET_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

  }

	return hr;
}

HRESULT CRootScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CRootScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_GROUP:
		{
			CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
			if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
				return E_FAIL;
			}

			CSystemGroup* pMSG = pPane->GetRootGroup();
			pMSG->CreateNewChildSystemGroup();
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CRootScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CRootScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	if( ! GfxCheckObjPtr(m_pScopePane,CHealthmonScopePane) )
	{
		return E_FAIL;
	}

	CHealthmonScopePane* pHMScopePane = (CHealthmonScopePane*)m_pScopePane;

	HRESULT hr = S_OK;

	CHMGeneralPage* pPage1 = new CHMGeneralPage;

	pPage1->SetObjectPtr(pHMScopePane->GetRootGroup());

  HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );

  hr = lpProvider->AddPage(hPage1);
/*
	CHMHistoryPage* pPage2 = new CHMHistoryPage;

	pPage2->SetObjectPtr(pHMScopePane->GetRootGroup());

  HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );

  hr = lpProvider->AddPage(hPage2);
*/
	return hr;
}

HRESULT CRootScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CRootScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rootscopeitem.h ===
// RootScopeItem.h: interface for the CRootScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ROOTSCOPEITEM_H__1E782D91_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_ROOTSCOPEITEM_H__1E782D91_AB0E_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CRootScopeItem : public CHMScopeItem  
{

DECLARE_DYNCREATE(CRootScopeItem)

// Construction/Destruction
public:
	CRootScopeItem();
	virtual ~CRootScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// Messaging Members
public:
	virtual LRESULT MsgProc(UINT msg, WPARAM wparam, LPARAM lparam);

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);
};

#endif // !defined(AFX_ROOTSCOPEITEM_H__1E782D91_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rule.h ===
#if !defined(AFX_RULE_H__D9BF4FAA_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_RULE_H__D9BF4FAA_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Rule.h : header file
//

#include "HMObject.h"
#include "RuleScopeItem.h"
#include "RuleResultsView.h"
#include "HMRuleStatus.h"
#include "RuleStatusListener.h"
#include "DataElementStatsListener.h"
#include "HMDataElementStatistics.h"

/////////////////////////////////////////////////////////////////////////////
// CRule command target

class CRule : public CHMObject
{

DECLARE_DYNCREATE(CRule)

// Construction/Destruction
public:
	CRule();
	virtual ~CRule();

// WMI Operations
public:
	HRESULT EnumerateChildren();
	CString GetObjectPath();
	CString GetStatusObjectPath();
	CWbemClassObject* GetParentClassObject();
	CHMEvent* GetStatusClassObject();
  CString GetThresholdString();
//	void DeleteClassObject();

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
  virtual bool Rename(const CString& sNewName);
	virtual bool Refresh();
	virtual bool ResetStatus();
	virtual CString GetUITypeName();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// State Members
public:
	void UpdateStatus();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRule)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRule)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CRule)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CRule)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "Rule.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RULE_H__D9BF4FAA_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rule.cpp ===
// Rule.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "Rule.h"
#include "EventManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRule

IMPLEMENT_DYNCREATE(CRule, CHMObject)

CRule::CRule()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_sTypeName = IDS_STRING_MOF_RULE;
	m_nState = HMS_NODATA;

}

CRule::~CRule()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.

	// TODO: Destroy all stats

	// TODO: Destroy all events
	
	AfxOleUnlockApp();
}

void CRule::UpdateStatus()
{
	TRACEX(_T("CRule::UpdateStatus\n"));

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
	if( ! pContainer )	
	{
		ASSERT(FALSE);
		return;
	}

	SetState(CEvent::GetStatus(pContainer->m_iState));

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CScopePaneItem* pItem = GetScopeItem(i);
		if( pItem )
		{
			CStringArray saNames;
			CString sValue;

			// Name of Rule
			saNames.Add(GetName());

			// Status
			CString sStatus;
			CEvent::GetStatus(pContainer->m_iState,sStatus);
			saNames.Add(sStatus);

			// Guid
			saNames.Add(GetGuid());

			// Threshold
			sValue = GetThresholdString();
			saNames.Add(sValue);

			// Last Message
			CString sLastMessage = pContainer->GetLastEventDTime();
			if( sLastMessage.IsEmpty() )
			{
				sLastMessage.LoadString(IDS_STRING_NONE);
			}
			saNames.Add(sLastMessage);

			// Comment
			saNames.Add(GetComment());

			pItem->SetDisplayNames(saNames);
			pItem->SetIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetOpenIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetItem();
		}
	}

	m_lNormalCount = pContainer->m_iNumberNormals;
	m_lWarningCount = pContainer->m_iNumberWarnings;
	m_lCriticalCount = pContainer->m_iNumberCriticals;
	m_lUnknownCount = pContainer->m_iNumberUnknowns;
}

void CRule::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMObject::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CRule, CHMObject)
	//{{AFX_MSG_MAP(CRule)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CRule, CHMObject)
	//{{AFX_DISPATCH_MAP(CRule)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IRule to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4FA8-F673-11D2-BDC4-0000F87A3912}
static const IID IID_IRule =
{ 0xd9bf4fa8, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CRule, CHMObject)
	INTERFACE_PART(CRule, IID_IRule, Dispatch)
END_INTERFACE_MAP()

// {D9BF4FA9-F673-11D2-BDC4-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CRule, "SnapIn.Rule", 0xd9bf4fa9, 0xf673, 0x11d2, 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CRule::CRuleFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CRule message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleconfiglistener.cpp ===
// RuleConfigListener.cpp: implementation of the CRuleConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "RuleConfigListener.h"
#include "HMRuleConfiguration.h"
#include "Rule.h"
#include "System.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CRuleConfigListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleConfigListener::CRuleConfigListener()
{
}

CRuleConfigListener::~CRuleConfigListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CRuleConfigListener::Create()
{
	TRACEX(_T("CRuleConfigListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
    IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
    ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CRuleConfigListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE); // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to create Stub Sink!\n")); 
        ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

    ASSERT(m_pStubSink);

	CHMObject* pObject = GetObjectPtr();
	pObject->IncrementActiveSinkCount();
	
	return true;
}

void CRuleConfigListener::Destroy()
{
	TRACEX(_T("CRuleConfigListener::Destroy\n"));

    if( m_pStubSink )			
    {
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CRuleConfigListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMRuleConfiguration rc;

	if( ! CHECKHRESULT(hr = rc.Create(pClassObject)) )
	{
		return hr;
	}

	rc.GetAllProperties();

	if( ! GetObjectPtr()->GetChildByGuid(rc.m_sGUID) )
	{
		CRule* pRule = new CRule;
		pRule->SetName(rc.m_sName);
		pRule->SetGuid(rc.m_sGUID);
		pRule->SetSystemName(GetObjectPtr()->GetSystemName());
		pRule->SetComment(rc.m_sDescription);
		GetObjectPtr()->AddChild(pRule);
	}
				
  return hr;
}

inline HRESULT CRuleConfigListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CRuleConfigListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult == S_OK )
	{
		CHMObject* pObject = GetObjectPtr();
		pObject->DecrementActiveSinkCount();
	}

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rule.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CRule::EnumerateChildren()
{
	TRACEX(_T("CRule::EnumerateChildren\n"));

	return S_OK;
}

inline CString CRule::GetObjectPath()
{
	TRACEX(_T("CRule::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMR_CONFIG,GetGuid());

	return sPath;
}

inline CString CRule::GetStatusObjectPath()
{
	TRACEX(_T("CRule::GetStatusObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMR_STATUS,GetGuid());

	return sPath;
}

inline CWbemClassObject* CRule::GetParentClassObject()
{
	TRACEX(_T("CRule::GetParentClassObject\n"));

	CWbemClassObject* pClassObject = new CWbemClassObject;

	if( ! CHECKHRESULT(pClassObject->Create(GetSystemName())) )
	{
		delete pClassObject;
		return NULL;
	}

	CString sQuery;
	sQuery.Format(IDS_STRING_R2DE_ASSOC_QUERY,GetGuid());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(pClassObject->ExecQuery(bsQuery)) )
	{
		delete pClassObject;
		::SysFreeString(bsQuery);
		return NULL;
	}
	::SysFreeString(bsQuery);

	ULONG ulReturned = 0L;
	if( pClassObject->GetNextObject(ulReturned) != S_OK )
	{
		ASSERT(FALSE);
		delete pClassObject;
		return NULL;
	}

	ASSERT(ulReturned > 0);

	return pClassObject;
}

inline CHMEvent* CRule::GetStatusClassObject()
{
	TRACEX(_T("CRule::GetStatusClassObject\n"));

	CHMEvent* pClassObject = new CHMRuleStatus;

	pClassObject->SetMachineName(GetSystemName());

	if( ! CHECKHRESULT(pClassObject->GetObject(GetStatusObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	pClassObject->GetAllProperties();

	return pClassObject;
}

inline CString CRule::GetThresholdString()
{
	TRACEX(_T("CRule::GetThresholdString\n"));

  CWbemClassObject* pThreshold = GetClassObject();
  if( ! GfxCheckObjPtr(pThreshold,CWbemClassObject) )
  {
    return _T("");
  }
  
  CString sExpression;
  CString sValue;
  int iCondition = -1;
  
  pThreshold->GetProperty(IDS_STRING_MOF_PROPERTYNAME,sValue);
  if( sValue.IsEmpty() )
  {
    delete pThreshold;
    return _T("");
  }

  sExpression += sValue + _T(" ");

  pThreshold->GetProperty(IDS_STRING_MOF_RULECONDITION,iCondition);
	switch( iCondition )
	{
		case 0:
		{
			sValue = _T("<");
		}
		break;

		case 1:
		{
			sValue = _T(">");
		}
		break;

		case 2:
		{
			sValue = _T("=");
		}
		break;

		case 3:
		{
			sValue = _T("!=");
		}
		break;

		case 4:
		{
			sValue = _T(">=");
		}
		break;

		case 5:
		{
			sValue = _T("<=");
		}
		break;

		case 6:
		{
			sValue.LoadString(IDS_STRING_CONTAINS);
		}
		break;

		case 7:
		{
			sValue.LoadString(IDS_STRING_DOES_NOT_CONTAIN);
		}
		break;

    default:
    {
      delete pThreshold;
      return _T("");
    }
    break;
	}
  sExpression += sValue + _T(" ");

  pThreshold->GetProperty(IDS_STRING_MOF_RULEVALUE,sValue);
  if( sValue.IsEmpty() )
  {
    delete pThreshold;
    return _T("");
  }

  sExpression += sValue;

  delete pThreshold;

  return sExpression;
}

/*
inline void CRule::DeleteClassObject()
{
	TRACEX(_T("CRule::DeleteClassObject\n"));

	// get associator path
	CWbemClassObject Associator;

	Associator.SetMachineName(GetSystemName());

	CString sQuery;
	sQuery.Format(IDS_STRING_R2DE_REF_QUERY,GetGuid());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(Associator.ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return;
	}
	::SysFreeString(bsQuery);

	ULONG ulReturned = 0L;
	if( Associator.GetNextObject(ulReturned) != S_OK )
	{
		ASSERT(FALSE);
		return;
	}

	CString sAssociatorPath;
	Associator.GetProperty(_T("__path"),sAssociatorPath);

	Associator.Destroy();

	// delete the instance
	Associator.SetMachineName(GetSystemName());
	
	BSTR bsInstanceName = sAssociatorPath.AllocSysString();
	CHECKHRESULT(Associator.DeleteInstance(bsInstanceName));
	::SysFreeString(bsInstanceName);
	
}
*/

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CRule::Cut()
{
	TRACEX(_T("CRule::Cut\n"));
	return false;
}

inline bool CRule::Copy()
{
	TRACEX(_T("CRule::Copy\n"));
	return false;
}
	
inline bool CRule::Paste()
{
	TRACEX(_T("CRule::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CRule::Rename(const CString& sNewName)
{
	TRACEX(_T("CRule::Rename\n"));
	TRACEARGs(sNewName);

  CString sName = sNewName;
  CString sThreshold;
  sThreshold.LoadString(IDS_STRING_RULE_FMT);
  sThreshold = sThreshold.Left(sThreshold.GetLength()-3);

  // do we need to autoname this ?
  if( sName.Find(sThreshold) == 0 )
  {
    CWbemClassObject* pRuleObject = GetClassObject();
    CString sPropertyName;
    CString sCompareValue;
    CString sOperator;
    int iCondition;
    
    pRuleObject->GetProperty(IDS_STRING_MOF_PROPERTYNAME,sPropertyName);
    pRuleObject->GetProperty(IDS_STRING_MOF_COMPAREVALUE,sCompareValue);
    pRuleObject->GetProperty(IDS_STRING_MOF_RULECONDITION,iCondition);

    delete pRuleObject;
    pRuleObject = NULL;

	  switch( iCondition )
	  {
		  case 0:
		  {
			  sOperator.LoadString(IDS_STRING_LESS_THAN);
		  }
		  break;

		  case 1:
		  {
			  sOperator.LoadString(IDS_STRING_GREATER_THAN);
		  }
		  break;

		  case 2:
		  {
			  sOperator.LoadString(IDS_STRING_EQUALS);
		  }
		  break;

		  case 3:
		  {
			  sOperator.LoadString(IDS_STRING_DOES_NOT_EQUAL);
		  }
		  break;

		  case 4:
		  {
			  sOperator.LoadString(IDS_STRING_GREATER_THAN_EQUAL_TO);
		  }
		  break;

		  case 5:
		  {
			  sOperator.LoadString(IDS_STRING_LESS_THAN_EQUAL_TO);
		  }
		  break;

		  case 6:
		  {
			  sOperator.LoadString(IDS_STRING_CONTAINS);
		  }
		  break;

		  case 7:
		  {
			  sOperator.LoadString(IDS_STRING_DOES_NOT_CONTAIN);
		  }
		  break;

      case 8:
      {
        sOperator.LoadString(IDS_STRING_IS_ALWAYS_TRUE);
      }
      break;
	  }

    if( ! sPropertyName.IsEmpty() && ! sOperator.IsEmpty() && ! sCompareValue.IsEmpty() )
    {
      if( iCondition != 8 ) // Is Always true is a special case
      {
        sName.Format(_T("%s %s %s"),sPropertyName,sOperator,sCompareValue);
      }
    }
    else if( ! sOperator.IsEmpty() && iCondition == 8 )
    {
      sName = sOperator;
    }
  }

  return CHMObject::Rename(sName);
}

inline bool CRule::Refresh()
{
	TRACEX(_T("CRule::Refresh\n"));
	return false;
}

inline bool CRule::ResetStatus()
{
	TRACEX(_T("CRule::ResetStatus\n"));
	return false;
}

inline CString CRule::GetUITypeName()
{
	TRACEX(_T("CRule::GetUITypeName\n"));

	CString sTypeName;
	sTypeName.LoadString(IDS_STRING_RULE);

	return sTypeName;
}


/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CRule::CreateScopeItem()
{
	TRACEX(_T("CRule::CreateScopeItem\n"));

	CRuleScopeItem * pNewItem = new CRuleScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleevent.cpp ===
// RuleEvent.cpp: implementation of the CRuleEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "RuleEvent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CRuleEvent,CEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleEvent::CRuleEvent()
{
  m_iID = 0;
}

CRuleEvent::~CRuleEvent()
{
  m_iID = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleconfiglistener.h ===
// RuleConfigListener.h: interface for the CRuleConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULECONFIGLISTENER_H__6BD5F131_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
#define AFX_RULECONFIGLISTENER_H__6BD5F131_FE50_11D2_BDD4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CRuleConfigListener : public CWbemEventListener  
{
DECLARE_DYNCREATE(CRuleConfigListener)

// Construction/Destruction
public:
	CRuleConfigListener();
	virtual ~CRuleConfigListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);

};

#endif // !defined(AFX_RULECONFIGLISTENER_H__6BD5F131_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleevent.h ===
// RuleEvent.h: interface for the CRuleEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULEEVENT_H__5F72D13F_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
#define AFX_RULEEVENT_H__5F72D13F_8D58_11D3_BE84_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Event.h"

class CRuleEvent : public CEvent  
{

DECLARE_DYNCREATE(CRuleEvent)

// Construction/Destruction
public:
	CRuleEvent();
	virtual ~CRuleEvent();

// Event ID
public:
	int m_iID;

// Message
public:
	CString m_sMessage;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView);
};

#include "RuleEvent.inl"

#endif // !defined(AFX_RULEEVENT_H__5F72D13F_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleinstanceevent.h ===
// RuleInstanceEvent.h: interface for the CRuleInstanceEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULEINSTANCEEVENT_H__5F72D140_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
#define AFX_RULEINSTANCEEVENT_H__5F72D140_8D58_11D3_BE84_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "RuleEvent.h"

class CRuleInstanceEvent : public CRuleEvent  
{
public:
	CRuleInstanceEvent();
	virtual ~CRuleInstanceEvent();

};

#endif // !defined(AFX_RULEINSTANCEEVENT_H__5F72D140_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleresultsview.h ===
// RuleResultsView.h: interface for the CRuleResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULERESULTSVIEW_H__5CFA29C5_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_RULERESULTSVIEW_H__5CFA29C5_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CRuleResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CRuleResultsView)

// Construction/Destruction
public:
	CRuleResultsView();
	virtual ~CRuleResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

// Eventing and Statistics Members
public:
	virtual void AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph=true);
protected:
	virtual HRESULT AddStatistics(CHealthmonResultsPane* pPane);
	virtual HRESULT RemoveStatistics(CHealthmonResultsPane* pPane);
	CString GetRulePropertyName();

// GraphView Events Members
public:
	virtual void OnGraphViewStyleChange(_DHMGraphView* pGraphView);
};

#endif // !defined(AFX_RULERESULTSVIEW_H__5CFA29C5_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleresultsview.cpp ===
// RuleResultsView.cpp: implementation of the CRuleResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "RuleResultsView.h"
#include "HMListViewColumn.h"
#include "EventManager.h"
#include "HealthmonResultsPane.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CRuleResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleResultsView::CRuleResultsView()
{

}

CRuleResultsView::~CRuleResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CRuleResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CRuleResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Action Policy
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ACTION_POLICY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);


	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// property
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_PROPERTY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// instance
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_INSTANCE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// current
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CURRENT);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// min
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MINIMUM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// max
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MAXIMUM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// avg
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_AVERAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// Last Update
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LASTUPDATE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}

//////////////////////////////////////////////////////////////////////
// Eventing and Statistics Members
//////////////////////////////////////////////////////////////////////

void CRuleResultsView::AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph /*=true*/)
{
	TRACEX(_T("CRuleResultsView::AddStatistic\n"));
	TRACEARGn(pContainer);
	TRACEARGn(pStatistic);	

	// get the property name the rule is watching
	CString sPropName = GetRulePropertyName();
	if( sPropName.IsEmpty() )
	{

		return;
	}

  if( bUpdateGraph )
  {
	  CHMScopeItem* pHMItem = (CHMScopeItem*)GetOwnerScopeItem();

	  if( ! GfxCheckObjPtr(pHMItem,CHMScopeItem) )
	  {
		  TRACE(_T("FAILED : pHMItem is not a valid pointer.\n"));
		  return;
	  }

	  CHMObject* pObject = pHMItem->GetObjectPtr();
	  if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	  {
		  return;
	  }

	  for( int j = 0; j < GetResultsPanesCount(); j++ )
	  {
		  CHealthmonResultsPane* pPane = (CHealthmonResultsPane*)GetResultsPane(j);
		  if( pPane )
		  {
			  _DHMGraphView* pGraphView  = pPane->GetGraphViewCtrl();

	      if( pGraphView )
	      {
		      pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		      long lCurrentStyle = pGraphView->GetStyle();

		      pGraphView->Clear();

		      if( lCurrentStyle & HMGVS_CURRENT )
		      {
			      pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_ELEMENT);
		      }

		      if( lCurrentStyle & HMGVS_HISTORIC )
		      {
			      pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_ELEMENT);
		      }

		      pGraphView->SetName(pObject->GetName());
	      }

	      CEventContainer* pContainer = NULL;
	      EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	      if( pContainer )
	      {
          CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		      for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		      {
			      CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);

	          if( pDPStat && pDPStat->m_sPropertyName.CompareNoCase(sPropName) != 0 )
	          {
              continue;
	          }

            CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
            StatsArray* pStats;
            if( ! StatMap.Lookup(sKey,pStats) )
            {
              pStats = new StatsArray;
              StatMap.SetAt(sKey,pStats);
              pStats->Add(pDPStat);
            }
            else
            {
              if( pStats->GetSize() < 6 )
              {
                pStats->Add(pDPStat);
              }
            }
		      }

          POSITION pos = StatMap.GetStartPosition();
          while( pos != NULL )
          {
            CString sKey;
            StatsArray* pStats = NULL;
            StatMap.GetNextAssoc(pos,sKey,pStats);
            for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
            {
              pStats->GetAt(i)->UpdateGraph(pGraphView);
            }

            delete pStats;
          }
	      }
		  }
	  }
  }

	CDataPointStatistics* pDPStat = (CDataPointStatistics*)pStatistic;
	if( pDPStat && pDPStat->m_sPropertyName.CompareNoCase(sPropName) != 0 )
	{
		return;
	}

	// if this statistic exists in the results pane already, just update the displaynames
	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		CHMEventResultsPaneItem* pItem = (CHMEventResultsPaneItem*)m_ResultItems[i];
		if( pItem && pItem->IsStatsPane() )
		{			
			if( pItem->GetDisplayName(0) == pDPStat->m_sPropertyName &&
					pItem->GetDisplayName(1) == pDPStat->m_sInstanceName )
			{
				pDPStat->SetResultsPaneItem(pItem);
				UpdateItem(pItem);
				return;
			}
		}
	}

	AddItem(pStatistic->CreateResultsPaneItem(this));
}

inline HRESULT CRuleResultsView::AddStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CRuleResultsView::AddStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CString sText;
	sText.Format(IDS_STRING_STATISTICS_FOR,pSPI->GetDisplayName());
	pPane->GetStatsListCtrl()->SetTitle(sText);

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	_DHMGraphView* pGraphView = pPane->GetGraphViewCtrl();
	if( pGraphView )
	{
		pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		long lCurrentStyle = pGraphView->GetStyle();

		pGraphView->Clear();

		if( lCurrentStyle & HMGVS_CURRENT )
		{
			pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_ELEMENT);
		}

		if( lCurrentStyle & HMGVS_HISTORIC )
		{
			pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_ELEMENT);
		}

		pGraphView->SetName(pObject->GetName());
	}

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
	  // get the property name the rule is watching
	  CString sPropName = GetRulePropertyName();
	  if( sPropName.IsEmpty() )
	  {
		  return E_FAIL;
	  }

    CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		{
			CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);
      CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
      StatsArray* pStats;
      if( ! StatMap.Lookup(sKey,pStats) )
      {
        pStats = new StatsArray;
        StatMap.SetAt(sKey,pStats);
        pStats->Add(pDPStat);
      }
      else
      {
        if( pStats->GetSize() < 6 )
        {
          pStats->Add(pDPStat);
        }
      }
		}

    POSITION pos = StatMap.GetStartPosition();
    while( pos != NULL )
    {
      CString sKey;
      StatsArray* pStats = NULL;
      StatMap.GetNextAssoc(pos,sKey,pStats);
      for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
      {
        AddStatistic(pContainer,pStats->GetAt(i),i==pStats->GetSize()-1);
      }

      delete pStats;
    }
	}

	sText.Format(IDS_STRING_COUNT_OF_FORMAT,pContainer->GetStatisticsCount());
	pPane->GetStatsListCtrl()->SetDescription(sText);

	CHMScopeItem* pParentItem = (CHMScopeItem*)pHMItem->GetParent();
	ASSERT(pParentItem);
	if( ! pParentItem )
	{		
		return E_FAIL;
	}
	
	CHMObject* pParentObject = pParentItem->GetObjectPtr();
	ASSERT(pParentObject);
	if( ! pParentObject )
	{
		return E_FAIL;
	}

	EvtGetEventManager()->ActivateStatisticsEvents(pObject->GetSystemName(),pParentObject->GetGuid());

	return S_OK;
}

inline HRESULT CRuleResultsView::RemoveStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CRuleResultsView::RemoveStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	CHMScopeItem* pParentItem = (CHMScopeItem*)pHMItem->GetParent();
	ASSERT(pParentItem);
	if( ! pParentItem )
	{		
		return E_FAIL;
	}
	
	CHMObject* pParentObject = pParentItem->GetObjectPtr();
	ASSERT(pParentObject);
	if( ! pParentObject )
	{
		return E_FAIL;
	}

	EvtGetEventManager()->DeactivateStatisticsEvents(pObject->GetSystemName(), pParentObject->GetGuid());

	pPane->GetGraphViewSink()->SetResultsViewPtr(NULL);

	
	if(pPane->GetGraphViewCtrl())
	{
		pPane->GetGraphViewCtrl()->Clear();
	}

	CString sWaiting;
	sWaiting.LoadString(IDS_STRING_WAITING);
	pPane->GetStatsListCtrl()->SetTitle(sWaiting);

	return S_OK;
}

inline CString CRuleResultsView::GetRulePropertyName()
{
	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		ASSERT(FALSE);
		return _T("");
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		ASSERT(FALSE);
		return _T("");
	}

	CWbemClassObject* pClassObject = pObject->GetClassObject();
	if( ! pClassObject )
	{
		ASSERT(FALSE);
		return _T("");
	}

	CString sPropName;
	HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_PROPERTYNAME,sPropName);
	delete pClassObject;
	if( ! CHECKHRESULT(hr) )
	{
		return _T("");
	}

	return sPropName;
}

//////////////////////////////////////////////////////////////////////
// GraphView Events Members
//////////////////////////////////////////////////////////////////////

void CRuleResultsView::OnGraphViewStyleChange(_DHMGraphView* pGraphView)
{
	if( ! pGraphView )
	{
		ASSERT(FALSE);
		return;
	}

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return;
	}

	pGraphView->SetName(pObject->GetName());

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
	  // get the property name the rule is watching
	  CString sPropName = GetRulePropertyName();
	  if( sPropName.IsEmpty() )
	  {
		  return;
	  }

    CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		{
			CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);
      CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
      StatsArray* pStats;
      if( ! StatMap.Lookup(sKey,pStats) )
      {
        pStats = new StatsArray;
        StatMap.SetAt(sKey,pStats);
        pStats->Add(pDPStat);
      }
      else
      {
        if( pStats->GetSize() < 6 )
        {
          pStats->Add(pDPStat);
        }
      }
		}

    POSITION pos = StatMap.GetStartPosition();
    while( pos != NULL )
    {
      CString sKey;
      StatsArray* pStats = NULL;
      StatMap.GetNextAssoc(pos,sKey,pStats);
      for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
      {
        AddStatistic(pContainer,pStats->GetAt(i));
      }

      delete pStats;
    }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rulescopeitem.h ===
// RuleScopeItem.h: interface for the CRuleScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULESCOPEITEM_H__5CFA29C4_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_RULESCOPEITEM_H__5CFA29C4_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CRuleScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CRuleScopeItem)

// Construction/Destruction
public:
	CRuleScopeItem();
	virtual ~CRuleScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);

};

#endif // !defined(AFX_RULESCOPEITEM_H__5CFA29C4_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleinstanceevent.cpp ===
// RuleInstanceEvent.cpp: implementation of the CRuleInstanceEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "RuleInstanceEvent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleInstanceEvent::CRuleInstanceEvent()
{

}

CRuleInstanceEvent::~CRuleInstanceEvent()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rulescopeitem.cpp ===
// RuleScopeItem.cpp: implementation of the CRuleScopeItem class.
//
//////////////////////////////////////////////////////////////////////
//
// History
//
// 03/04/00 v-marfin bug 59643 Make Expression page the 1st page displayed
// 03/31/00 v-marfin bug 62644 Removed "Reset Status" from the Threshold context menu.
// 04/02/00 v-marfin bug 59643b : Make General Page the first page, but set
//                                details page as the focus on a new item.

//
// 
#include "stdafx.h"
#include "snapin.h"
#include "Rule.h"
#include "RuleScopeItem.h"
#include "RuleResultsView.h"
#include "HealthmonScopePane.h"
#include "THGeneralPage.h"
#include "THExpressionPage.h"
#include "THPolicyPage.h"
#include "THSchedulePage.h"
#include "THMessagePage.h"
#include "ActionAssociationPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {DFB09C0F-C9E7-11d2-BD8D-0000F87A3912}
static GUID GUID_Rule = 
{ 0xdfb09c0f, 0xc9e7, 0x11d2, { 0xbd, 0x8d, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CRuleScopeItem,CHMScopeItem)

// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_THRESHOLD,
	IDI_ICON_THRESHOLD_DISABLED,
	IDI_ICON_THRESHOLD_OUTAGE,
	IDI_ICON_THRESHOLD_UNKNOWN,
	IDI_ICON_THRESHOLD_NO_CONNECT,
	IDI_ICON_THRESHOLD_WARNING,
	IDI_ICON_THRESHOLD_CRITICAL
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleScopeItem::CRuleScopeItem()
{
	m_lpguidItemType = &GUID_Rule;
}

CRuleScopeItem::~CRuleScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CRuleScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CRuleScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}

	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	return true;
}

//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CRuleScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CRuleScopeItem::CreateResultsPaneView\n"));

	return new CRuleResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CRuleScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CRuleScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    /* v-marfin 62644 : Remove "Reset Status" from the Threshold context menu
    sResString.LoadString(IDS_STRING_RESET_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_RESET_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }*/

		// Enable All Thresholds
    sResString.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_DISABLE_MONITORING;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		CHMObject* pObject = GetObjectPtr();
    CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();        

    // disable menu item if null object ptr or parent is disabled
		if( ! pObject || (pParentItem && pParentItem->GetObjectPtr()
                      && !pParentItem->GetObjectPtr()->IsEnabled()) )

		{
			cmi.fFlags = MF_DISABLED|MF_GRAYED;
		}
		else
		{
			int iState = pObject->IsEnabled();
			if( iState == -1 )
			{
				cmi.fFlags = MF_DISABLED|MF_GRAYED;
			}
			else if( iState == 0 )
			{
				cmi.fFlags = MF_CHECKED;
			}
			else if( iState == 1 )
			{
				cmi.fFlags = MF_UNCHECKED;
			}
		}
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

/*
		// Export
    sResString.LoadString(IDS_STRING_EXPORT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_EXPORT;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
*/
		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CRuleScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CRuleScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_EXPORT:
		{
			CString sFilter;
			sFilter.LoadString(IDS_STRING_MOF_FILTER);
			CFileDialog fd(FALSE,_T("MOF"),NULL,OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,sFilter);

			if( fd.DoModal() == IDOK )
			{
				CFile file;
				if( ! file.Open(fd.GetPathName(),CFile::modeCreate|CFile::modeWrite|CFile::shareExclusive) )
				{
					return S_OK;
				}

				CArchive ar(&file,CArchive::store);
				CHMObject* pObject = GetObjectPtr();
				if( pObject )
				{
					pObject->ExportMofFile(ar);
				}
			}
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CRuleScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CRuleScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	CRule* pRule = (CRule*)GetObjectPtr();
	if( ! GfxCheckObjPtr(pRule,CRule) )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;

    // v-marfin bug 59643b - Make general page the first page but make the 
    //                       details page the focus on new items.
	CTHGeneralPage* pPage1 = new CTHGeneralPage;
	pPage1->SetObjectPtr(pRule);
    HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );
    hr = lpProvider->AddPage(hPage1);


    CTHExpressionPage* pPage2 = new CTHExpressionPage;
	pPage2->SetObjectPtr(pRule);
    HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
    hr = lpProvider->AddPage(hPage2);


	CTHMessagePage* pPage3 = new CTHMessagePage;
	pPage3->SetObjectPtr(pRule);
  HPROPSHEETPAGE hPage3 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage3->m_psp) );
  hr = lpProvider->AddPage(hPage3);

	CActionAssociationPage* pPage4 = new CActionAssociationPage;
	pPage4->SetObjectPtr(GetObjectPtr());
  HPROPSHEETPAGE hPage4 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage4->m_psp) );
  hr = lpProvider->AddPage(hPage4);

/*
	CTHSchedulePage* pPage5 = new CTHSchedulePage;
	pPage5->SetObjectPtr(pRule);
  HPROPSHEETPAGE hPage5 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage5->m_psp) );
  hr = lpProvider->AddPage(hPage5);
*/
	return hr;
}

HRESULT CRuleScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CRuleScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ruleevent.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Result Pane Item Members
//////////////////////////////////////////////////////////////////////

inline CHMEventResultsPaneItem* CRuleEvent::CreateResultsPaneItem(CResultsPaneView* pView)
{
	if( ! pView )
	{
		ASSERT(FALSE);
		return NULL;
	}

	CHMEventResultsPaneItem* pItem = new CHMEventResultsPaneItem;
	pItem->SetDateTimeColumn(HMLV_LOWER_DTIME_INDEX);
	
	CStringArray saNames;
	CUIntArray uiaIconResIds;

	CString sValue;
	CEvent::GetStatus(m_iState,sValue);

	saNames.Add(sValue);
  sValue.Format(_T("%d"),m_iID);
  saNames.Add(sValue);
	saNames.Add(GetEventLocalTime());
	saNames.Add(m_sName);
	saNames.Add(m_sSystemName);
	saNames.Add(m_sMessage);
	switch( CEvent::GetStatus(m_iState) )
	{
		case HMS_CRITICAL:
		{
			uiaIconResIds.Add(IDI_ICON_CRITICAL);
		}
		break;
		
		case HMS_WARNING:
		{
			uiaIconResIds.Add(IDI_ICON_WARNING);
		}
		break;
		
		case HMS_NODATA:
		{
			uiaIconResIds.Add(IDI_ICON_NO_CONNECT);
		}
		break;

		case HMS_UNKNOWN:
		{
			uiaIconResIds.Add(IDI_ICON_UNKNOWN);
		}
		break;

		case HMS_SCHEDULEDOUT:
		{
			uiaIconResIds.Add(IDI_ICON_OUTAGE);
		}
		break;

		case HMS_DISABLED:
		{
			uiaIconResIds.Add(IDI_ICON_DISABLED);
		}
		break;

		case HMS_NORMAL:
		{
			uiaIconResIds.Add(IDI_ICON_NORMAL);
		}
		break;

		default:
		{
			ASSERT(FALSE);
			uiaIconResIds.Add(IDI_ICON_NORMAL);
		}
	}

	pItem->m_iState = CEvent::GetStatus(m_iState);
	pItem->m_st = m_st;
	pItem->m_sGuid = m_sStatusGuid;
			
	pItem->SetDisplayNames(saNames);
	pItem->SetIconIds(uiaIconResIds);
	pItem->SetIconIndex(0);
	pItem->SetToLowerPane();

	pItem->Create(pView);	

	return pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rulestatuslistener.cpp ===
// RuleStatusListener.cpp: implementation of the CRuleStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "RuleStatusListener.h"
#include "HMRuleStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CRuleStatusListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRuleStatusListener::CRuleStatusListener()
{
}

CRuleStatusListener::~CRuleStatusListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CRuleStatusListener::Create()
{
	TRACEX(_T("CRuleStatusListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CRuleStatusListener::CreateUnSecuredApartment failed.\n"));
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Stub Sink!\n"));    
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));		
    return false;
  }

  ASSERT(m_pStubSink);
	
	// third, call connection manager to execute the query
	CString sQuery;
	sQuery.Format(IDS_STRING_STATUS_QUERY_FMT,IDS_STRING_MOF_HMR_STATUS,GetObjectPtr()->GetGuid());
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(sSystemName,sQuery,m_pStubSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return true;
}

void CRuleStatusListener::Destroy()
{
	TRACEX(_T("CRuleStatusListener::Destroy\n"));

  if( m_pStubSink )			
  {
		CnxRemoveConnection(m_pHMObject->GetName(),m_pStubSink);
		m_pStubSink->Release();
    m_pStubSink = NULL;
  }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
  {
		s_pIUnsecApartment->Release();
    s_pIUnsecApartment = NULL;
  }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CRuleStatusListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMRuleStatus rs;

	if( ! CHECKHRESULT(hr = rs.Create(pClassObject)) )
	{
		return hr;
	}

	rs.m_sSystemName = GetObjectPtr()->GetSystemName();

	rs.GetAllProperties();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\rulestatuslistener.h ===
// RuleStatusListener.h: interface for the CRuleStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RULESTATUSLISTENER_H__25364FEF_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
#define AFX_RULESTATUSLISTENER_H__25364FEF_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CRuleStatusListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CRuleStatusListener)

// Construction/Destruction
public:
	CRuleStatusListener();
	virtual ~CRuleStatusListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);


};

#endif // !defined(AFX_RULESTATUSLISTENER_H__25364FEF_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\scopepane.cpp ===
// ScopePane.cpp : implementation file
//

#include "stdafx.h"
#include "ScopePane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScopePane

IMPLEMENT_DYNCREATE(CScopePane, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////////////////////////////

CScopePane::CScopePane()
{
	EnableAutomation();

	m_pRootItem = NULL;
	m_pMsgHook = NULL;
	m_pIConsoleNamespace = NULL;
	m_pIConsole = NULL;
	m_pIImageList = NULL;
	m_pSelectedScopeItem = NULL;

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

}

CScopePane::~CScopePane()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Creation/Destruction Overrideable Members
/////////////////////////////////////////////////////////////////////////////

bool CScopePane::OnCreate()
{
	TRACEX(_T("CScopePane::OnCreate\n"));

	if( ! GetRootScopeItem() )
	{
		TRACE(_T("FAILED : The pointer to the root item is invalid.\n"));
		return false;
	}

	if( ! m_pRootItem->Create(this,NULL) )
	{
		TRACE(_T("CRootScopeItem::Create failed.\n"));
		return false;
	}

	return true;
}

LPCOMPONENT CScopePane::OnCreateComponent()
{
	TRACEX(_T("CScopePane::OnCreateComponent\n"));

	CResultsPane* pNewPane = new CResultsPane;
	
	if( ! CHECKOBJPTR(pNewPane,RUNTIME_CLASS(CResultsPane),sizeof(CResultsPane)) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		return NULL;
	}

	pNewPane->SetOwnerScopePane(this);

	int iIndex = AddResultsPane(pNewPane);
	
	ASSERT(iIndex != -1);

	LPCOMPONENT pComponent = (LPCOMPONENT)pNewPane->GetInterface(&IID_IComponent);

	if( ! CHECKPTR(pComponent,sizeof(IComponent)) )
	{
		return NULL;
	}

	return pComponent;
}

bool CScopePane::OnDestroy()
{
	TRACEX(_T("CScopePane::OnDestroy\n"));



	// unhook the window first
	UnhookWindow();

	if( m_pMsgHook )
	{
		delete m_pMsgHook;
		m_pMsgHook = NULL;
	}

	// delete the root scope pane item
	CScopePaneItem* pRootItem = GetRootScopeItem();

	if( pRootItem )
	{
		delete pRootItem;
		m_pRootItem = NULL;
	}

	// Release all the interfaces queried for

	if( m_pIConsole )
	{
		m_pIConsole->Release();
		m_pIConsole = NULL;
	}

	if( m_pIConsoleNamespace )
	{
		m_pIConsoleNamespace->Release();
		m_pIConsoleNamespace = NULL;
	}

	if( m_pIImageList )
	{
		m_pIImageList->Release();
		m_pIImageList = NULL;
	}

	// empty Result Panes array

	for( int i = GetResultsPaneCount()-1; i >= 0; i-- )
	{
		RemoveResultsPane(i);
	}

	m_pSelectedScopeItem = NULL;

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Root Scope Pane Item Members
/////////////////////////////////////////////////////////////////////////////

CScopePaneItem* CScopePane::CreateRootScopeItem()
{
	TRACEX(_T("CScopePane::CreateRootScopeItem\n"));

	return NULL;
}

CScopePaneItem* CScopePane::GetRootScopeItem()
{
	TRACEX(_T("CScopePane::GetRootScopeItem\n"));

	if( ! CHECKOBJPTR(m_pRootItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		return NULL;
	}

	return m_pRootItem;
}

void CScopePane::SetRootScopeItem(CScopePaneItem* pRootItem)
{
	TRACEX(_T("CScopePane::GetRootScopeItem\n"));

	if( ! CHECKOBJPTR(pRootItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		return;
	}

	m_pRootItem = pRootItem;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Frame Window Message Hook Members
/////////////////////////////////////////////////////////////////////////////

bool CScopePane::HookWindow()
{
	TRACEX(_T("CScopePane::HookWindow\n"));

	if( m_pMsgHook == NULL )
	{
		m_pMsgHook = new CMmcMsgHook;
	}

	if( ! CHECKOBJPTR(m_pMsgHook,RUNTIME_CLASS(CMmcMsgHook),sizeof(CMmcMsgHook)) )
	{
		return false;
	}

	HWND hMMCMainWnd = NULL;
	LPCONSOLE2 lpConsole = GetConsolePtr();

	if( lpConsole == NULL )
	{
		return false;
	}

	lpConsole->GetMainWindow(&hMMCMainWnd);
	
	m_pMsgHook->Init(GetRootScopeItem(),hMMCMainWnd);
	
	lpConsole->Release();

	return true;
}

void CScopePane::UnhookWindow()
{
	TRACEX(_T("CScopePane::UnhookWindow\n"));

	if( ! CHECKOBJPTR(m_pMsgHook,RUNTIME_CLASS(CMmcMsgHook),sizeof(CMmcMsgHook)) )
	{
		return;
	}

	m_pMsgHook->HookWindow(NULL);	
}

/////////////////////////////////////////////////////////////////////////////
// MMC Interface Members
/////////////////////////////////////////////////////////////////////////////

LPCONSOLENAMESPACE2 CScopePane::GetConsoleNamespacePtr()
{
	TRACEX(_T("CScopePane::GetConsoleNamespacePtr\n"));

	if( ! CHECKPTR(m_pIConsoleNamespace,sizeof(IConsoleNameSpace2)) )
	{
		return NULL;
	}

	m_pIConsoleNamespace->AddRef();

	return m_pIConsoleNamespace;
}

LPCONSOLE2 CScopePane::GetConsolePtr()
{
	TRACEX(_T("CScopePane::GetConsolePtr\n"));

	if( ! CHECKPTR(m_pIConsole,sizeof(IConsole2)) )
	{
		return NULL;
	}

	m_pIConsole->AddRef();

	return m_pIConsole;
}

LPIMAGELIST CScopePane::GetImageListPtr()
{
	TRACEX(_T("CScopePane::GetImageListPtr\n"));

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		return NULL;
	}

	m_pIImageList->AddRef();

	return m_pIImageList;
}

LPUNKNOWN CScopePane::GetCustomOcxPtr()
{
	TRACEX(_T("CScopePane::GetCustomOcxPtr\n"));

	LPCONSOLE2 pIConsole = GetConsolePtr();

	if( ! CHECKPTR(pIConsole,sizeof(IConsole)) )
	{
		return NULL;
	}

	LPUNKNOWN pIUnknown = NULL;
	HRESULT hr = pIConsole->QueryResultView(&pIUnknown);

	if( ! CHECKHRESULT(hr) )
	{
		return NULL;
	}

	pIConsole->Release();

	return pIUnknown;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Scope Pane Helper Members
/////////////////////////////////////////////////////////////////////////////

CScopePaneItem* CScopePane::GetSelectedScopeItem()
{
	TRACEX(_T("CScopePane::GetSelectedScopeItem\n"));

	if( ! m_pSelectedScopeItem )
	{
		TRACE(_T("WARNING : Selected Scope Item is NULL.\n"));
		return NULL;
	}

	if( ! GfxCheckObjPtr(m_pSelectedScopeItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : m_pSelectedScopeItem is not valid.\n"));
		return NULL;
	}

	return m_pSelectedScopeItem;
}

void CScopePane::SetSelectedScopeItem(CScopePaneItem* pItem)
{
	TRACEX(_T("CScopePane::SetSelectedScopeItem\n"));
	TRACEARGn(pItem);

	if( ! pItem )
	{
		m_pSelectedScopeItem = NULL;
		return;
	}

	if( ! GfxCheckObjPtr(pItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pItem pointer is invalid.\n"));
		return;
	}

	m_pSelectedScopeItem = pItem;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Icon Management
/////////////////////////////////////////////////////////////////////////////

int CScopePane::AddIcon(UINT nIconResID)
{
	TRACEX(_T("CScopePane::AddIcon\n"));
	TRACEARGn(nIconResID);

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		return -1;
	}

	int nIconIndex = GetIconIndex(nIconResID);
	
	if( nIconIndex != -1 )
	{
		return nIconIndex;
	}

	// load icon
	HICON hIcon = AfxGetApp()->LoadIcon(nIconResID);
	if( hIcon == NULL )
	{
		TRACE(_T("FAILED : Icon with resid=%d not found"),nIconResID);
		return -1;
	}

	nIconIndex = GetIconCount();

	// insert icon into image list
#ifndef IA64
	if( ! CHECKHRESULT(m_pIImageList->ImageListSetIcon((long*)hIcon, nIconIndex)) )
	{
		return -1;
	}
#endif // IA64

	// add resid and index to map
	m_IconMap.SetAt(nIconResID,nIconIndex);

	// return index of newly inserted image
	return nIconIndex;
}

int CScopePane::GetIconIndex(UINT nIconResID)
{
	TRACEX(_T("CScopePane::GetIconIndex\n"));
	TRACEARGn(nIconResID);

	if( ! CHECKPTR(m_pIImageList,sizeof(IImageList)) )
	{
		return -1;
	}
	
	// check map for an existing id
	int nIconIndex = -1;
	
	if( m_IconMap.Lookup(nIconResID,nIconIndex) )
	{
		// if exists, return index
		return nIconIndex;
	}

	TRACE(_T("FAILED : Icon could not be found with Resource id=%d\n"),nIconResID);

	return -1;
}

int CScopePane::GetIconCount()
{
	TRACEX(_T("CScopePane::GetIconCount\n"));

	return (int)m_IconMap.GetCount();
}

void CScopePane::RemoveAllIcons()
{
	TRACEX(_T("CScopePane::RemoveAllIcons\n"));

	m_IconMap.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Results Pane Members
/////////////////////////////////////////////////////////////////////////////

int CScopePane::GetResultsPaneCount() const
{
	TRACEX(_T("CScopePane::GetResultsPaneCount\n"));

	return (int)m_ResultsPanes.GetSize();
}

CResultsPane* CScopePane::GetResultsPane(int iIndex)
{
	TRACEX(_T("CScopePane::GetResultsPaneCount\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ResultsPanes.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : Requested ResultPane is out of array bounds\n"));
		return NULL;
	}

	CResultsPane* pPane = m_ResultsPanes[iIndex];

	if( ! CHECKOBJPTR(pPane,RUNTIME_CLASS(CResultsPane),sizeof(CResultsPane)) )
	{
		return NULL;
	}

	return pPane;
}

int CScopePane::AddResultsPane(CResultsPane* pPane)
{
	TRACEX(_T("CScopePane::AddResultsPane\n"));
	TRACEARGn(pPane);

	if( ! CHECKOBJPTR(pPane,RUNTIME_CLASS(CResultsPane),sizeof(CResultsPane)) )
	{
		TRACE(_T("FAILED : pPane pointer is invalid.\n"));
		return -1;
	}

	pPane->ExternalAddRef();

	return (int)m_ResultsPanes.Add(pPane);
}

void CScopePane::RemoveResultsPane(int iIndex)
{
	TRACEX(_T("CScopePane::RemoveResultsPane\n"));
	TRACEARGn(iIndex);
	
	if( iIndex >= m_ResultsPanes.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : Requested ResultPane is out of array bounds\n"));
		return;
	}

	CResultsPane* pPane = m_ResultsPanes[iIndex];

	m_ResultsPanes.RemoveAt(iIndex);

	pPane->ExternalRelease();
}

/////////////////////////////////////////////////////////////////////////////
// Serialization
/////////////////////////////////////////////////////////////////////////////

bool CScopePane::OnLoad(CArchive& ar)
{
	TRACEX(_T("CScopePane::OnLoad\n"));
	ASSERT(ar.IsLoading());

	return true;
}

bool CScopePane::OnSave(CArchive& ar)
{
	TRACEX(_T("CScopePane::OnSave\n"));
	ASSERT(ar.IsStoring());
	return true;
}

/////////////////////////////////////////////////////////////////////////////
// MMC Help
/////////////////////////////////////////////////////////////////////////////

bool CScopePane::ShowTopic(const CString& sHelpTopic)
{
  TRACEX(_T("CScopePane::ShowTopic\n"));
  
  if( sHelpTopic.IsEmpty() )
  {
    return false;
  }

  if( ! m_pIConsole )
  {
    return false;
  }

  IDisplayHelp* pIDisplayHelp = NULL;
  HRESULT hr = m_pIConsole->QueryInterface(IID_IDisplayHelp,(LPVOID*)&pIDisplayHelp);
  if( ! CHECKHRESULT(hr) )
  {
    return false;
  }

	CString sHTMLHelpTopic = AfxGetApp()->m_pszHelpFilePath;
  sHTMLHelpTopic = sHTMLHelpTopic + _T("::") + sHelpTopic;
	LPOLESTR lpCompiledHelpTopic = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((sHTMLHelpTopic.GetLength() + 1)* sizeof(wchar_t)));
  if(lpCompiledHelpTopic == NULL)
  {
		return false;
  }

	_tcscpy(lpCompiledHelpTopic, (LPCTSTR)sHTMLHelpTopic);

  hr = pIDisplayHelp->ShowTopic(lpCompiledHelpTopic);
  pIDisplayHelp->Release();
  
  if( ! CHECKHRESULT(hr) )
  {
    return false;
  }  
  
  return true;
}

/////////////////////////////////////////////////////////////////////////////
// MFC Operations
/////////////////////////////////////////////////////////////////////////////

void CScopePane::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CScopePane, CCmdTarget)
	//{{AFX_MSG_MAP(CScopePane)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScopePane, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CScopePane)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScopePane to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A6858-9056-11D2-BD45-0000F87A3912}
static const IID IID_IScopePane =
{ 0x7d4a6858, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CScopePane, CCmdTarget)
	INTERFACE_PART(CScopePane, IID_IScopePane, Dispatch)
	INTERFACE_PART(CScopePane, IID_IComponentData, ComponentData)
	INTERFACE_PART(CScopePane, IID_IPersistStream, PersistStream)
	INTERFACE_PART(CScopePane, IID_IExtendContextMenu, ExtendContextMenu)
	INTERFACE_PART(CScopePane, IID_IExtendPropertySheet2, ExtendPropertySheet2)
	INTERFACE_PART(CScopePane, IID_ISnapinHelp, SnapinHelp)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// IComponentData Interface Part

ULONG FAR EXPORT CScopePane::XComponentData::AddRef()
{
	METHOD_PROLOGUE(CScopePane, ComponentData)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CScopePane::XComponentData::Release()
{
	METHOD_PROLOGUE(CScopePane, ComponentData)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CScopePane::XComponentData::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CScopePane::XComponentData::Initialize( 
/* [in] */ LPUNKNOWN pUnknown)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::Initialize\n"));
	TRACEARGn(pUnknown);

	if( ! CHECKPTR(pUnknown,sizeof(IUnknown)) )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;

	// MMC should only call ::Initialize once! But you know those MMC clowns...
	ASSERT( pThis->m_pIConsoleNamespace == NULL );
	if( pThis->m_pIConsoleNamespace != NULL )
	{
		TRACE(_T("FAILED : IComponentData::Initialize has already been called. Returning with Error.\n"));
		return E_FAIL;
	}

	// Get pointer to name space interface
	hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (LPVOID*)(&pThis->m_pIConsoleNamespace));
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : pUnknown->QueryInterface for IID_IConsoleNameSpace2 failed.\n"));
		return hr;
	}

	// Get pointer to console interface
	hr = pUnknown->QueryInterface(IID_IConsole2, (LPVOID*)(&pThis->m_pIConsole));
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : pUnknown->QueryInterface for IID_IConsole2 failed.\n"));
		return hr;
	}

	// Query for the Scope Pane ImageList Interface
	pThis->m_pIImageList = NULL;
	hr = pThis->m_pIConsole->QueryScopeImageList(&(pThis->m_pIImageList));
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("pUnknown->QueryScopeImageList failed.\n"));
		return hr;
	}	 

	// Call OnCreate for derived classes. Base class implementation creates a new root scope pane item.
	if( ! pThis->OnCreate() )
	{
		TRACE(_T("FAILED : CScopePane::OnCreate failed.\n"));
		return E_FAIL;
	}

	// Hook the MMC top level window to intercept any window messages of interest
	if( ! pThis->HookWindow() )
	{
		TRACE(_T("FAILED : Unable to hook MMC main window\n"));
		return E_FAIL;
	}

	return hr;
}

HRESULT FAR EXPORT CScopePane::XComponentData::CreateComponent( 
/* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::CreateComponent\n"));
	TRACEARGn(ppComponent);

	*ppComponent = pThis->OnCreateComponent();
	
	if( ! CHECKPTR(*ppComponent,sizeof(IComponent)) )
	{
		TRACE(_T("FAILED : OnCreateComponent returns invalid pointer.\n"));
		return E_FAIL;
	}

  return S_OK;
}

HRESULT FAR EXPORT CScopePane::XComponentData::Notify( 
/* [in] */ LPDATAOBJECT lpDataObject,
/* [in] */ MMC_NOTIFY_TYPE event,
/* [in] */ LPARAM arg,
/* [in] */ LPARAM param)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::Notify\n"));
	TRACEARGn(lpDataObject);
	TRACEARGn(event);
	TRACEARGn(arg);
	TRACEARGn(param);

	HRESULT hr = S_OK;

	switch( event )
	{		
		case MMCN_BTN_CLICK: // toolbar button clicked
		{
			TRACE(_T("MMCN_BTN_CLICK received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnBtnClick((MMC_CONSOLE_VERB)arg);
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnBtnClick(pItem,(MMC_CONSOLE_VERB)arg);
			}

		}
		break;
		
		case MMCN_CONTEXTHELP: // F1, Help Menu Item or Help Button selected
		{
			TRACE(_T("MMCN_CONTEXTHELP received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnContextHelp();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnContextHelp(pItem);
			}

		}
		break;

		case MMCN_DELETE: // delete selected
		{
			TRACE(_T("MMCN_DELETE received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnDelete();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnDelete(pItem);
			}
		}
		break;

		case MMCN_EXPAND: // user clicks on a previously unexpanded node
		{
			TRACE(_T("MMCN_EXPAND received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				if( pItem == pThis->GetRootScopeItem() )
				{
					pItem->SetItemHandle((HSCOPEITEM)param);
				}

				hr = pItem->OnExpand((BOOL)arg);
			}
		}
		break;

		case MMCN_PRELOAD:
		{
			TRACE(_T("MMCN_PRELOAD received.\n"));
			TRACE(_T("MMCN_PRELOAD not implemented.\n"));
		}
		break;

		case MMCN_PRINT:
		{
			TRACE(_T("MMCN_PRINT received.\n"));
			TRACE(_T("MMCN_PRINT not implemented.\n"));
		}
		break;

		case MMCN_PROPERTY_CHANGE:
		{
			TRACE(_T("MMCN_PROPERTY_CHANGE received.\n"));
			TRACE(_T("MMCN_PROPERTY_CHANGE not implemented.\n"));
		}
		break;

		case MMCN_REFRESH:
		{
			TRACE(_T("MMCN_REFRESH received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnRefresh();
			}
			else if( psdo->GetItemType() == CCT_RESULT )
			{
				CResultsPaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CResultsPaneView* pView = pItem->GetOwnerResultsView();

				if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
				{
					return E_FAIL;
				}

				ASSERT(pView);

				hr = pView->OnRefresh();
			}
		}
		break;

		case MMCN_REMOVE_CHILDREN:
		{
			TRACE(_T("MMCN_REMOVE_CHILDREN received.\n"));
			
			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				hr = pItem->OnRemoveChildren();
			}			
		}
		break;

		case MMCN_RENAME:
		{
			TRACE(_T("MMCN_RENAME received.\n"));

			CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpDataObject);
			
			if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
			{
				return E_FAIL;
			}

			if( psdo->GetItemType() == CCT_SCOPE )
			{
				CScopePaneItem* pItem = NULL;
				if( ! psdo->GetItem(pItem) )
				{
					return E_FAIL;
				}

				ASSERT(pItem);

				CString sNewName = (LPOLESTR)param;

				hr = pItem->OnRename(sNewName);
			}			
		}
		break;
	}

  return hr;
}

HRESULT FAR EXPORT CScopePane::XComponentData::Destroy(void)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::Destroy\n"));

	if( ! pThis->OnDestroy() )
	{
		return E_FAIL;
	}

  return S_OK;
}

HRESULT FAR EXPORT CScopePane::XComponentData::QueryDataObject( 
/* [in] */ MMC_COOKIE cookie,
/* [in] */ DATA_OBJECT_TYPES type,
/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::QueryDataObject\n"));
	TRACEARGn(cookie);
	TRACEARGn(type);
	TRACEARGn(ppDataObject);

  HRESULT hr = S_OK;
  CSnapinDataObject* pdoNew = NULL;

	pdoNew = new CSnapinDataObject;

  if( ! pdoNew )
  {
    hr = E_OUTOFMEMORY;
		*ppDataObject = NULL;
		TRACE(_T("Out of memory.\n"));
    return hr;
  }

	*ppDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);

	if( ! CHECKOBJPTR(pdoNew,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return E_FAIL;
	}

  if( cookie )
  {
		CScopePaneItem* pItem = (CScopePaneItem*)cookie;
		if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
		{
			return E_FAIL;
		}

		pdoNew->SetItem(pItem);

		ASSERT(pdoNew->GetItemType() == CCT_SCOPE);
  }
  else // In this case the node is our root scope item, and was placed there for us by MMC.
  {    
    pdoNew->SetItem( pThis->GetRootScopeItem() );

		ASSERT(pdoNew->GetItemType() == CCT_SCOPE);
  }

  return hr;
}

HRESULT FAR EXPORT CScopePane::XComponentData::GetDisplayInfo( 
/* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::GetDisplayInfo\n"));
	TRACEARGn(pScopeDataItem);

	if( ! CHECKPTR(pScopeDataItem,sizeof(SCOPEDATAITEM)) )
	{
		return E_FAIL;
	}

	CScopePaneItem* pItem = NULL;

  if( pScopeDataItem->lParam == 0L ) // cookie is NULL for Root Item
  {
		pItem = pThis->GetRootScopeItem();
  }
  else
  {
    pItem = (CScopePaneItem*)pScopeDataItem->lParam;
  }

	if( ! CHECKOBJPTR(pItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		return E_FAIL;
	}

	if( pScopeDataItem->mask & SDI_STR )
	{
		pScopeDataItem->displayname = (LPTSTR)(LPCTSTR)pItem->GetDisplayName();
	}

	if( pScopeDataItem->mask & SDI_IMAGE )
	{
		pScopeDataItem->nImage = pThis->AddIcon(pItem->GetIconId());		
	}

	if( pScopeDataItem->mask & SDI_OPENIMAGE )
	{
		pScopeDataItem->nOpenImage = pThis->AddIcon(pItem->GetOpenIconId());
	}

  return S_OK;
}

HRESULT FAR EXPORT CScopePane::XComponentData::CompareObjects( 
/* [in] */ LPDATAOBJECT lpDataObjectA,
/* [in] */ LPDATAOBJECT lpDataObjectB)
{
  METHOD_PROLOGUE(CScopePane, ComponentData)

	TRACEX(_T("CScopePane::XComponentData::CompareObjects\n"));
	TRACEARGn(lpDataObjectA);
	TRACEARGn(lpDataObjectB);
  
  CSnapinDataObject* psmdo1 = CSnapinDataObject::GetSnapinDataObject(lpDataObjectA);
  if( psmdo1 == NULL )
  {
    return S_FALSE;
  }

	CSnapinDataObject* psmdo2 = CSnapinDataObject::GetSnapinDataObject(lpDataObjectB);
  if( psmdo2 == NULL )
  {
    return S_FALSE;
  }

	if( psmdo1->GetCookie() != psmdo2->GetCookie() )
		return S_FALSE;

	return S_OK;
}

// IComponentData Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IPersistStream Interface Part

ULONG FAR EXPORT CScopePane::XPersistStream::AddRef()
{
	METHOD_PROLOGUE(CScopePane, PersistStream)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CScopePane::XPersistStream::Release()
{
	METHOD_PROLOGUE(CScopePane, PersistStream)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CScopePane::XPersistStream::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CScopePane, PersistStream)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CScopePane::XPersistStream::GetClassID( 
/* [out] */ CLSID __RPC_FAR *pClassID)
{
	METHOD_PROLOGUE(CScopePane, PersistStream)

	TRACEX(_T("CScopePane::XPersistStream::GetClassID\n"));
	TRACEARGn(pClassID);

	return E_NOTIMPL;
}

HRESULT FAR EXPORT CScopePane::XPersistStream::IsDirty( void)
{
	METHOD_PROLOGUE(CScopePane, PersistStream)

	TRACEX(_T("CScopePane::XPersistStream::IsDirty\n"));

	return E_NOTIMPL;
}

HRESULT FAR EXPORT CScopePane::XPersistStream::Load( 
/* [unique][in] */ IStream __RPC_FAR *pStm)
{
	METHOD_PROLOGUE(CScopePane, PersistStream)

	TRACEX(_T("CScopePane::XPersistStream::Load\n"));
	TRACEARGn(pStm);

	COleStreamFile file;
	file.Attach(pStm);
	CArchive ar(&file,CArchive::load);
	bool bResult = pThis->OnLoad(ar);
	
	return bResult ? S_OK : E_FAIL;
}

HRESULT FAR EXPORT CScopePane::XPersistStream::Save( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ BOOL fClearDirty)
{
	METHOD_PROLOGUE(CScopePane, PersistStream)

	TRACEX(_T("CScopePane::XPersistStream::Save\n"));
	TRACEARGn(pStm);
	TRACEARGn(fClearDirty);

	COleStreamFile file;
	file.Attach(pStm);
	CArchive ar(&file,CArchive::store);
	bool bResult = pThis->OnSave(ar);
	
	return bResult ? S_OK : E_FAIL;
}

HRESULT FAR EXPORT CScopePane::XPersistStream::GetSizeMax( 
/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
	METHOD_PROLOGUE(CScopePane, PersistStream)

	TRACEX(_T("CScopePane::XPersistStream::GetSizeMax\n"));
	TRACEARGn(pcbSize);

	return E_NOTIMPL;
}

// IPersistStream Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Interface Part

ULONG FAR EXPORT CScopePane::XExtendContextMenu::AddRef()
{
	METHOD_PROLOGUE(CScopePane, ExtendContextMenu)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CScopePane::XExtendContextMenu::Release()
{
	METHOD_PROLOGUE(CScopePane, ExtendContextMenu)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CScopePane::XExtendContextMenu::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CScopePane, ExtendContextMenu)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CScopePane::XExtendContextMenu::AddMenuItems( 
/* [in] */ LPDATAOBJECT piDataObject,
/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
/* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
	METHOD_PROLOGUE(CScopePane, ExtendContextMenu)

	TRACEX(_T("CScopePane::XExtendContextMenu::AddMenuItems\n"));
	TRACEARGn(piDataObject);
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;
  CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(piDataObject);
  if( ! CHECKOBJPTR(psdo, RUNTIME_CLASS(CSnapinDataObject), sizeof(CSnapinDataObject)) )
  {
    return E_FAIL;
  }

  DATA_OBJECT_TYPES type =  psdo->GetItemType();
  if( type == CCT_SCOPE )
  {
    CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		ASSERT(pItem);

    hr = pItem->OnAddMenuItems(piCallback,pInsertionAllowed);

    if( ! CHECKHRESULT(hr) )
		{
      TRACE(_T("CScopePaneItem::OnAddMenuItems failed!\n"));
    }
  }
  else if( type == CCT_RESULT )
  {
    CResultsPaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		ASSERT(pItem);

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

		if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
		{
			return E_FAIL;
		}

    hr = pView->OnAddMenuItems(pItem,piCallback,pInsertionAllowed);

    if( ! CHECKHRESULT(hr) )
		{
      TRACE(_T("CResultsPaneView::OnAddMenuItems failed!\n"));
    }
  }

	return hr;
}

HRESULT FAR EXPORT CScopePane::XExtendContextMenu::Command( 
/* [in] */ long lCommandID,
/* [in] */ LPDATAOBJECT piDataObject)
{
	METHOD_PROLOGUE(CScopePane, ExtendContextMenu)

	TRACEX(_T("CScopePane::XExtendContextMenu::Command\n"));
	TRACEARGn(lCommandID);
	TRACEARGn(piDataObject);

  HRESULT hr = S_OK;
  CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(piDataObject);
  if( ! CHECKOBJPTR(psdo, RUNTIME_CLASS(CSnapinDataObject), sizeof(CSnapinDataObject)) )
  {
    return E_FAIL;
  }

  DATA_OBJECT_TYPES type =  psdo->GetItemType();
  if( type == CCT_SCOPE )
  {
    CScopePaneItem* pItem = NULL;
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		ASSERT(pItem);

    hr = pItem->OnCommand(lCommandID);

    if( ! CHECKHRESULT(hr) )
		{
      TRACE(_T("CScopePaneItem::OnCommand failed!\n"));
    }
  }

	return hr;
}

// IExtendContextMenu Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet2 Interface Part

ULONG FAR EXPORT CScopePane::XExtendPropertySheet2::AddRef()
{
	METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CScopePane::XExtendPropertySheet2::Release()
{
	METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CScopePane::XExtendPropertySheet2::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CScopePane::XExtendPropertySheet2::CreatePropertyPages( 
/* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
/* [in] */ LONG_PTR handle,
/* [in] */ LPDATAOBJECT lpIDataObject)
{
	METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)

	TRACEX(_T("CScopePane::XExtendPropertySheet2::CreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);
	TRACEARGn(lpIDataObject);

  HRESULT hr = S_FALSE;
  CSnapinDataObject* psdo = CSnapinDataObject::GetSnapinDataObject(lpIDataObject);
  if( ! CHECKOBJPTR(psdo, RUNTIME_CLASS(CSnapinDataObject), sizeof(CSnapinDataObject)) )
  {
    return E_FAIL;
  }

  DATA_OBJECT_TYPES type =  psdo->GetItemType();

  if( type == CCT_SCOPE )
  {
    CScopePaneItem* pItem = NULL;
		
		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		ASSERT(pItem);
		ASSERT_VALID(pItem);

    hr = pItem->OnCreatePropertyPages(lpProvider,handle);

    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("CScopePaneItem::OnCreatePropertyPages failed!\n"));
    }
  }
  else if( type == CCT_RESULT )
  {
		CResultsPaneItem* pItem = NULL;

		if( ! psdo->GetItem(pItem) )
		{
			return E_FAIL;
		}

		ASSERT(pItem);
		ASSERT_VALID(pItem);

		CResultsPaneView* pView = pItem->GetOwnerResultsView();

		if( ! CHECKOBJPTR(pView,RUNTIME_CLASS(CResultsPaneView),sizeof(CResultsPaneView)) )
		{
			return E_FAIL;
		}

		hr = pView->OnCreatePropertyPages(pItem,lpProvider,handle);
    if( ! CHECKHRESULT(hr) )
    {
      TRACE(_T("CResultsPaneView::OnCreatePropertyPages failed!\n"));
    }
  }
	
	return hr;
}

HRESULT FAR EXPORT CScopePane::XExtendPropertySheet2::QueryPagesFor( 
/* [in] */ LPDATAOBJECT lpDataObject)
{
	METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)

	TRACEX(_T("CScopePane::XExtendPropertySheet2::QueryPagesFor\n"));
	TRACEARGn(lpDataObject);

	HRESULT hr = S_OK;


	return hr;
}

HRESULT FAR EXPORT CScopePane::XExtendPropertySheet2::GetWatermarks( 
/* [in] */ LPDATAOBJECT lpIDataObject,
/* [out] */ HBITMAP __RPC_FAR *lphWatermark,
/* [out] */ HBITMAP __RPC_FAR *lphHeader,
/* [out] */ HPALETTE __RPC_FAR *lphPalette,
/* [out] */ BOOL __RPC_FAR *bStretch)
{
	METHOD_PROLOGUE(CScopePane, ExtendPropertySheet2)

	TRACEX(_T("CScopePane::XExtendPropertySheet2::GetWatermarks\n"));
	TRACEARGn(lpIDataObject);
	TRACEARGn(lphWatermark);
	TRACEARGn(lphHeader);
	TRACEARGn(lphPalette);
	TRACEARGn(bStretch);

	return S_OK;
}

// IExtendPropertySheet2 Interface Part
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// ISnapinHelp Interface Part

ULONG FAR EXPORT CScopePane::XSnapinHelp::AddRef()
{
	METHOD_PROLOGUE(CScopePane, SnapinHelp)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CScopePane::XSnapinHelp::Release()
{
	METHOD_PROLOGUE(CScopePane, SnapinHelp)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CScopePane::XSnapinHelp::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CScopePane, SnapinHelp)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CScopePane::XSnapinHelp::GetHelpTopic( 
/* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile)
{
	METHOD_PROLOGUE(CScopePane, SnapinHelp)

	TRACEX(_T("CScopePane::XSnapinHelp::GetHelpTopic\n"));
	TRACEARGn(lpCompiledHelpFile);

	CString sHTMLHelpFilePath = AfxGetApp()->m_pszHelpFilePath;
	*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((sHTMLHelpFilePath.GetLength() + 1)* sizeof(wchar_t)));
  if (*lpCompiledHelpFile == NULL)
		return E_OUTOFMEMORY;

	_tcscpy(*lpCompiledHelpFile, (LPCTSTR)sHTMLHelpFilePath);

	return S_OK;
}

// ISnapinHelp Interface Part
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CScopePane message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\selectsystemsdlg.cpp ===
// SelectSystemsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "SelectSystemsDlg.h"
#include <commctrl.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmwksta.h>
#include <mmc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectSystemsDlg dialog


CSelectSystemsDlg::CSelectSystemsDlg(CWnd* pParent /*=NULL*/)
	: CResizeableDialog(CSelectSystemsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSelectSystemsDlg)
	m_sDomain = _T("");
	m_sSystems = _T("");
	//}}AFX_DATA_INIT
}


void CSelectSystemsDlg::DoDataExchange(CDataExchange* pDX)
{
	CResizeableDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectSystemsDlg)
	DDX_Control(pDX, IDC_EDIT_SYSTEMS, m_SystemsEditBox);
	DDX_Control(pDX, IDC_LIST_SYSTEMS, m_SystemsList);
	DDX_Control(pDX, IDC_COMBO_DOMAIN, m_Domains);
	DDX_CBString(pDX, IDC_COMBO_DOMAIN, m_sDomain);
	DDX_Text(pDX, IDC_EDIT_SYSTEMS, m_sSystems);
	//}}AFX_DATA_MAP

	CWnd* pCheckNamesBtn = NULL;
	if( (pCheckNamesBtn = GetDlgItem(IDC_BUTTON_CHECK_NAMES)) != NULL )
	{
		pCheckNamesBtn->EnableWindow( ! m_sSystems.IsEmpty() );
	}
}


UINT CSelectSystemsDlg::AddDomains(LPVOID pParam)
{
	CWaitCursor wait;

	HWND* pHwnd = (HWND*)pParam;

	if( ! pHwnd )
	{
		return 1L;
	}

	if( ! ::IsWindow(*pHwnd) )
	{
		return 1L;
	}

	HWND hDomainCombobox = ::GetDlgItem(*pHwnd,IDC_COMBO_DOMAIN);
	::EnableWindow(hDomainCombobox,FALSE);

	CString sWindowTitle;
	sWindowTitle.LoadString(IDS_STRING_WORKING);
	::SetWindowText(hDomainCombobox,sWindowTitle);

	// enumerate all domains
	NET_API_STATUS status = NERR_Success;
	LPSERVER_INFO_100 lpserverinfo = NULL;
	DWORD dwTotalEntries = 0L;
	DWORD dwEntriesRead = 0L;
	DWORD dwResumeHandle = 0L;
	DWORD dwSize = MAX_PREFERRED_LENGTH;

	status = NetServerEnum(NULL,100,(LPBYTE*)&lpserverinfo,dwSize,&dwEntriesRead,&dwTotalEntries,
													 SV_TYPE_DOMAIN_ENUM,NULL,&dwResumeHandle);

	if( status != NERR_Success && status == ERROR_MORE_DATA )
	{
		lpserverinfo = NULL;
		dwSize = sizeof(SERVER_INFO_100)*dwTotalEntries*_MAX_PATH;
		dwTotalEntries = 0L;
		dwEntriesRead = 0L;
		dwResumeHandle = 0L;

		status = NetServerEnum(NULL,100,(LPBYTE*)&lpserverinfo,dwSize,&dwEntriesRead,&dwTotalEntries,
														 SV_TYPE_DOMAIN_ENUM,NULL,&dwResumeHandle);
	}

	::SendDlgItemMessage(*pHwnd,IDC_COMBO_DOMAIN,CB_RESETCONTENT,0,0);

	for( DWORD dw = 0L; dw < dwTotalEntries; dw++ )
	{
		CString sDomainName = lpserverinfo[dw].sv100_name;
		// add domains to the combobox
		::SendMessage(hDomainCombobox,CB_ADDSTRING,0,(LPARAM)(LPCTSTR)sDomainName);
	}

	NetApiBufferFree(lpserverinfo);

	::SetWindowText(hDomainCombobox,_T(""));
	::EnableWindow(hDomainCombobox,TRUE);

	delete pHwnd;

	return 0L;

}

UINT CSelectSystemsDlg::AddSystems(LPVOID pParam)
{
	CWaitCursor wait;

	HWND* pHwnd = (HWND*)pParam;

	if( ! pHwnd )
	{
		return 1L;
	}

	if( ! ::IsWindow(*pHwnd) )
	{
		return 1L;
	}

	HWND hSystemListCtrl = ::GetDlgItem(*pHwnd,IDC_LIST_SYSTEMS);
	HWND hDomainCombobox = ::GetDlgItem(*pHwnd,IDC_COMBO_DOMAIN);

	::EnableWindow(hSystemListCtrl,FALSE);
	::EnableWindow(hDomainCombobox,FALSE);

	ListView_DeleteAllItems(hSystemListCtrl);

	// add the "Working..." item

	CString sText;
	sText.LoadString(IDS_STRING_WORKING);
	LVITEM lvi;
	ZeroMemory(&lvi,sizeof(LVITEM));
	lvi.mask = LVIF_TEXT;
	lvi.pszText = (LPTSTR)(LPCTSTR)sText;

	ListView_InsertItem(hSystemListCtrl,&lvi);
	ListView_SetColumnWidth(hSystemListCtrl,0,LVSCW_AUTOSIZE_USEHEADER);
	ListView_SetColumnWidth(hSystemListCtrl,1,LVSCW_AUTOSIZE_USEHEADER);

	// get the domain name from the combobox
	CString sDomainName;
	int iCurSel = (int)::SendDlgItemMessage(*pHwnd,IDC_COMBO_DOMAIN,CB_GETCURSEL,0,0);
	if( iCurSel != -1 )
	{
		int iTextLen = (int)::SendDlgItemMessage(*pHwnd,IDC_COMBO_DOMAIN,CB_GETLBTEXTLEN,iCurSel,0);
		::SendDlgItemMessage(*pHwnd,IDC_COMBO_DOMAIN,CB_GETLBTEXT,iCurSel,(LPARAM)sDomainName.GetBuffer(iTextLen + 1));
		sDomainName.ReleaseBuffer();
	}
	else
	{
		int iTextLen = ::GetWindowTextLength(hDomainCombobox);
		::GetWindowText(hDomainCombobox,sDomainName.GetBuffer(iTextLen+1),iTextLen+1);
		sDomainName.ReleaseBuffer();
	}
	
	// enumerate for all the systems in the domain
	NET_API_STATUS status = NERR_Success;
	LPSERVER_INFO_101 lpserverinfo = NULL;
	DWORD dwTotalEntries = 0L;
	DWORD dwEntriesRead = 0L;
	DWORD dwResumeHandle = 0L;
	DWORD dwSize = MAX_PREFERRED_LENGTH;

	status = NetServerEnum(NULL,101,(LPBYTE*)&lpserverinfo,dwSize,&dwEntriesRead,&dwTotalEntries,
													 SV_TYPE_NT,sDomainName,&dwResumeHandle);

	if( status != NERR_Success && status == ERROR_MORE_DATA )
	{
		lpserverinfo = NULL;
		dwSize = sizeof(SERVER_INFO_101)*dwTotalEntries*_MAX_PATH;
		dwTotalEntries = 0L;
		dwEntriesRead = 0L;
		dwResumeHandle = 0L;

		status = NetServerEnum(NULL,101,(LPBYTE*)&lpserverinfo,dwSize,&dwEntriesRead,&dwTotalEntries,
														 SV_TYPE_NT,sDomainName,&dwResumeHandle);
	}

	ListView_DeleteAllItems(hSystemListCtrl);

	bool bCommentFound = false;

	for( DWORD dw = 0L; dw < dwTotalEntries; dw++ )
	{
		CString sSystemName = lpserverinfo[dw].sv101_name;

		// add system to the list control
		LVITEM lvi;
		ZeroMemory(&lvi,sizeof(LVITEM));
		lvi.mask = LVIF_TEXT;
		lvi.pszText = (LPTSTR)(LPCTSTR)sSystemName;

		int iItemIndex = ListView_InsertItem(hSystemListCtrl,&lvi);
		
		lvi.iItem = iItemIndex;
		lvi.iSubItem = 1;
		lvi.pszText = lpserverinfo[dw].sv101_comment;
		if( _tcslen(lvi.pszText) > 0 )
		{
			bCommentFound = true;
			ListView_SetItem(hSystemListCtrl,&lvi);
		}		
	}

	if( dwTotalEntries <= 0L )
	{
		ListView_SetColumnWidth(hSystemListCtrl,0,LVSCW_AUTOSIZE_USEHEADER);
	}
	else
	{
		ListView_SetColumnWidth(hSystemListCtrl,0,LVSCW_AUTOSIZE);
	}

	if( bCommentFound )
	{
		ListView_SetColumnWidth(hSystemListCtrl,1,LVSCW_AUTOSIZE);
	}
	else
	{
		ListView_SetColumnWidth(hSystemListCtrl,1,LVSCW_AUTOSIZE_USEHEADER);
	}

	NetApiBufferFree(lpserverinfo);

	::EnableWindow(hSystemListCtrl,TRUE);
	::EnableWindow(hDomainCombobox,TRUE);

	delete pHwnd;

	return 0L;
}

void CSelectSystemsDlg::CompileArrayOfSystems()
{
	m_saSystems.RemoveAll();

	LPTSTR lpszSystems = new TCHAR[m_sSystems.GetLength()+1];
	_tcscpy(lpszSystems,m_sSystems);

	LPTSTR lpszToken = _tcstok(lpszSystems,_T(";"));

	while( lpszToken )
	{
		CString sSystem = lpszToken;
		sSystem.TrimLeft(_T(" "));
		sSystem.TrimRight(_T(" "));
		m_saSystems.Add(sSystem);
		lpszToken = _tcstok(NULL,_T(";"));
	}

	delete[] lpszSystems;
}

bool CSelectSystemsDlg::IsInSystemArray(const CString& sSystem)
{
	for( int i = 0; i < m_saSystems.GetSize(); i++ )
	{
		if( m_saSystems[i] == sSystem )
		{
			return true;
		}
	}

	return false;
}

bool CSelectSystemsDlg::CheckSystemNames()
{
	CWaitCursor wait;

	for( int i = (int)m_saSystems.GetSize()-1; i >= 0; i-- )
	{
	  IWbemServices* pServices = NULL;
	  BOOL bAvail = FALSE;

	  if( ! m_saSystems[i].IsEmpty() )
	  {    
      HRESULT hr = CnxGetConnection(m_saSystems[i],pServices,bAvail);
	    if( hr == E_FAIL )
	    {
		    MessageBeep(MB_ICONEXCLAMATION);
			  int iIndex = m_sSystems.Find(m_saSystems[i]);
			  m_SystemsEditBox.SetFocus();
			  m_SystemsEditBox.SetSel(iIndex,iIndex+m_saSystems[i].GetLength(),TRUE);
			  CnxDisplayErrorMsgBox(hr,m_saSystems[i]);
			  return false;
	    }

	    if( pServices )
	    {
		    pServices->Release();
	    }
	  }
    else
    {
      m_saSystems.RemoveAt(i);
    }

	}

	return true;
}


BEGIN_MESSAGE_MAP(CSelectSystemsDlg, CResizeableDialog)
	//{{AFX_MSG_MAP(CSelectSystemsDlg)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_SYSTEMS, OnDblclkListSystems)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	ON_CBN_DROPDOWN(IDC_COMBO_DOMAIN, OnDropdownComboDomain)
	ON_CBN_CLOSEUP(IDC_COMBO_DOMAIN, OnCloseupComboDomain)
	ON_CBN_SELENDOK(IDC_COMBO_DOMAIN, OnSelendokComboDomain)
	ON_EN_CHANGE(IDC_EDIT_SYSTEMS, OnChangeEditSystems)
	ON_BN_CLICKED(IDC_BUTTON_CHECK_NAMES, OnButtonCheckNames)
	ON_NOTIFY(NM_SETFOCUS, IDC_LIST_SYSTEMS, OnSetfocusListSystems)
	ON_NOTIFY(NM_KILLFOCUS, IDC_LIST_SYSTEMS, OnKillfocusListSystems)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_NOTIFY(NM_CLICK, IDC_LIST_SYSTEMS, OnClickListSystems)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectSystemsDlg message handlers

BOOL CSelectSystemsDlg::OnInitDialog() 
{
	CResizeableDialog::OnInitDialog();

	SetControlInfo(IDC_STATIC_TITLE,				ANCHOR_LEFT | ANCHOR_TOP );
	SetControlInfo(IDC_STATIC_BAR,					ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR);
	SetControlInfo(IDC_STATIC_LOOK_IN,			ANCHOR_LEFT | ANCHOR_TOP );
	SetControlInfo(IDC_LIST_SYSTEMS,				ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR | RESIZE_VER);
	SetControlInfo(IDC_COMBO_DOMAIN,				ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR);
	SetControlInfo(IDC_BUTTON_ADD,					ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDC_BUTTON_CHECK_NAMES,	ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDC_EDIT_SYSTEMS,				ANCHOR_BOTTOM | ANCHOR_LEFT | RESIZE_HOR );
	SetControlInfo(IDOK,										ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDCANCEL,								ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDC_BUTTON_HELP,					ANCHOR_BOTTOM | ANCHOR_LEFT );

	
	NET_API_STATUS status = NERR_Success;
	LPWKSTA_INFO_100 pinfo = NULL;

	status = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pinfo);

	if( status == NERR_Success )
	{
		m_Domains.AddString(pinfo->wki100_langroup);
		m_Domains.SetCurSel(0);
		OnSelendokComboDomain();
	}

	NetApiBufferFree(pinfo);

	CString sTitle;
	sTitle.LoadString(IDS_STRING_NAME);
	m_SystemsList.InsertColumn(0,sTitle,LVCFMT_LEFT,LVSCW_AUTOSIZE_USEHEADER);
	sTitle.LoadString(IDS_STRING_COMMENT);
	m_SystemsList.InsertColumn(1,sTitle,LVCFMT_LEFT,LVSCW_AUTOSIZE_USEHEADER);

	m_SystemsList.SetColumnWidth(0,LVSCW_AUTOSIZE_USEHEADER);
	m_SystemsList.SetColumnWidth(1,LVSCW_AUTOSIZE_USEHEADER);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectSystemsDlg::OnButtonAdd() 
{
	CompileArrayOfSystems();
	
	if( ! m_sSystems.IsEmpty() )
	{
		m_sSystems += _T(" ; ");
	}

	POSITION pos = m_SystemsList.GetFirstSelectedItemPosition();
	int iIndex = 0;
	while( pos && iIndex >= 0 )
	{		
		iIndex = m_SystemsList.GetNextSelectedItem(pos);
		CString sSystem = m_SystemsList.GetItemText(iIndex,0);
		if( ! IsInSystemArray(sSystem) )
		{
			m_sSystems += sSystem + _T(" ; ");
		}
	}

	m_sSystems.TrimRight(_T(" ; "));

	UpdateData(FALSE);

	GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(FALSE);
}

void CSelectSystemsDlg::OnButtonCheckNames() 
{
	GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(FALSE);

	CompileArrayOfSystems();

	CheckSystemNames();
}

void CSelectSystemsDlg::OnClickListSystems(NMHDR* pNMHDR, LRESULT* pResult) 
{
	if( m_SystemsList.GetItemCount() )
	{
		GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(TRUE);
	}	

	
	*pResult = 0;
}

void CSelectSystemsDlg::OnDblclkListSystems(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnButtonAdd();
	
	*pResult = 0;
}

void CSelectSystemsDlg::OnOK() 
{
	CWaitCursor wait;

	CompileArrayOfSystems();

	if( m_saSystems.GetSize() == 0 )
	{
		return;
	}

	if( ! CheckSystemNames() )
	{
		return;
	}
	
	CResizeableDialog::OnOK();
}

void CSelectSystemsDlg::OnCancel() 
{
	m_saSystems.RemoveAll();
	
	CResizeableDialog::OnCancel();
}

void CSelectSystemsDlg::OnButtonHelp() 
{
	MMCPropertyHelp(_T("HMon21.chm::/dnewsys.htm"));  // 62212
	
}

void CSelectSystemsDlg::OnDropdownComboDomain() 
{
	if( m_Domains.GetCount() <= 1 )
	{
		AfxBeginThread((AFX_THREADPROC)AddDomains,new HWND(GetSafeHwnd()));
	}	

	GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(FALSE);
}

void CSelectSystemsDlg::OnCloseupComboDomain() 
{
	// TODO: Add your control notification handler code here
	
}

void CSelectSystemsDlg::OnSelendokComboDomain() 
{
	if( m_SystemsList.IsWindowEnabled() )
	{
		AfxBeginThread((AFX_THREADPROC)AddSystems,new HWND(GetSafeHwnd()));	
		GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(FALSE);
	}
}

void CSelectSystemsDlg::OnChangeEditSystems() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CResizeableDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(FALSE);
	UpdateData();	
}


void CSelectSystemsDlg::OnSetfocusListSystems(NMHDR* pNMHDR, LRESULT* pResult) 
{
	if( m_SystemsList.GetItemCount() )
	{
		GetDlgItem(IDC_BUTTON_ADD)->EnableWindow(TRUE);
	}	
	*pResult = 0;
}

void CSelectSystemsDlg::OnKillfocusListSystems(NMHDR* pNMHDR, LRESULT* pResult) 
{
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\scopepaneitem.cpp ===
// ScopePaneItem.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/29/00 v-marfin 62478 : Set help topic based on type of object
// 03/30/00 v-marfin 59644 : Modified prototype of InvokeContextMenu 
//                           to allow passing to selected item count. Only allow
//                           third party menu item (for Troubleshooting) if only 1
//                           item is selected.
// 04/02/00 v-marfin 59643b  On creation of new items, show details page first.
// 04/05/00 v-marfin 62962   Show "details" page on a new creation unless it is
//                           a new data group in which case show General first.
//
#include "stdafx.h"
#include "snapin.h"
#include "ScopePaneItem.h"
#include "ScopePane.h"

#include "RootScopeItem.h"
#include "AllSystemsScopeItem.h"
#include "SystemScopeItem.h"
#include "ActionPolicyScopeItem.h"
#include "DataGroupScopeItem.h"
#include "DataElementScopeItem.h"
#include "RuleScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScopePaneItem

IMPLEMENT_DYNCREATE(CScopePaneItem, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CScopePaneItem::CScopePaneItem()
{
	EnableAutomation();

	m_pScopePane = NULL;
	m_pParent = NULL;
	m_pResultsPaneView = NULL;
	m_hItemHandle = NULL;
	m_lpguidItemType = NULL;
	m_iCurrentIconIndex = -1;
	m_iCurrentOpenIconIndex = -1;	
	m_bVisible = true;

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CScopePaneItem::~CScopePaneItem()
{
	Destroy();

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
bool CScopePaneItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CScopePaneItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	if( ! GfxCheckObjPtr(pScopePane,CScopePane) )
	{
		TRACE(_T("FAILED : pScopePane is not a valid pointer.\n"));
		return false;
	}

	if( pParentItem == NULL )
	{
		TRACE(_T("WARNING : pParentItem is a NULL pointer. This is acceptable for the root node only.\n"));
	}
	else if( ! GfxCheckObjPtr(pParentItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pParentItem is not a valid pointer.\n"));
		return false;
	}

	SetScopePane(pScopePane);

	SetParent(pParentItem);

  // create the results view
  m_pResultsPaneView = CreateResultsPaneView();

  if( ! GfxCheckObjPtr(m_pResultsPaneView,CResultsPaneView) )
	{
		TRACE(_T("FAILED : CResultsPaneView::CreateResultsPane returned an invalid pointer.\n"));
		return false;
	}

	if( ! m_pResultsPaneView->Create(this) )
  {
    TRACE(_T("FAILED : CResultsPaneView::Create failed.\n"));
    return false;
  }

	m_bVisible = true;

	return true;
}

void CScopePaneItem::Destroy()
{
	TRACEX(_T("CScopePaneItem::Destroy\n"));

	if( m_pScopePane == NULL && m_Children.GetSize() == 0 && m_pResultsPaneView == NULL )
	{
		TRACE(_T("INFO : Destroy has already been called for this item.\n"));
		return;
	}

  // remove all children from our data structure
  for( int i=0; i < m_Children.GetSize(); i++ )
  {
		m_Children[i]->Destroy();
    delete m_Children[i];
  }

  m_Children.RemoveAll();

	DeleteItem();

  if( m_pResultsPaneView )
  {
    delete m_pResultsPaneView;
    m_pResultsPaneView = NULL;
  }

	m_pScopePane = NULL;
	m_pParent = NULL;
	m_hItemHandle = NULL;
	m_lpguidItemType = NULL;
	m_iCurrentIconIndex = -1;
	m_iCurrentOpenIconIndex = -1;
	m_saDisplayNames.RemoveAll();
	m_IconResIds.RemoveAll();
	m_OpenIconResIds.RemoveAll();
	m_sHelpTopic.Empty();
	m_bVisible = true;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Pane Members


// v-marfin 59237 : 
//  Within this data elements scope, return a unique name if the current name is already used
CString CScopePaneItem::GetUniqueDisplayName(CString sProposedName)
{
    int nSize = GetChildCount();

    // if no entries, use proposed
    if (nSize < 1)
    {
        return sProposedName;
    }

    CString sName = sProposedName;
    CString sCompare;
    int nSuffix=0;

    BOOL bContinue=TRUE;
    while (bContinue)
    {
        BOOL bNameAlreadyInUse=FALSE;

        // scan existing display names
        for (int x=0; x<nSize; x++)
        {
            // Is name already in use?
            CScopePaneItem* pItem = GetChild(x);
            if (!pItem)
                continue;

            sCompare = pItem->GetDisplayName();
            if (sCompare.CompareNoCase(sName)==0)
            {
                sName.Format(_T("%s %d"),sProposedName,nSuffix++);
                bNameAlreadyInUse=TRUE;
                break;
            }
        }

        if (bNameAlreadyInUse)
            continue;
        else
            break;
    }

    return sName;
}


CScopePane* CScopePaneItem::GetScopePane() const
{
	TRACEX(_T("CScopePaneItem::GetScopePane\n"));

	if( ! GfxCheckObjPtr(m_pScopePane,CScopePane) )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return NULL;
	}

	return m_pScopePane;
}

void CScopePaneItem::SetScopePane(CScopePane* pScopePane)
{
	TRACEX(_T("CScopePaneItem::SetScopePane\n"));
	TRACEARGn(pScopePane);

	if( ! GfxCheckObjPtr(pScopePane,CScopePane) )
	{
		TRACE(_T("FAILED : pScopePane is not a valid pointer.\n"));
		return;
	}

	m_pScopePane = pScopePane;
}


/////////////////////////////////////////////////////////////////////////////
// Parent Scope Item Members

CScopePaneItem* CScopePaneItem::GetParent() const
{
	TRACEX(_T("CScopePaneItem::GetParent\n"));

	if( !m_pParent || ! GfxCheckObjPtr(m_pParent,CScopePaneItem) )
	{
		TRACE(_T("WARNING : m_pParent is not a valid pointer.\n"));
		return NULL;
	}

	return m_pParent;
}

void CScopePaneItem::SetParent(CScopePaneItem* pParentItem)
{
	TRACEX(_T("CScopePaneItem::SetParent\n"));
	TRACEARGn(pParentItem);

	if( pParentItem == NULL )
	{
		TRACE(_T("WARNING : pParentItem is NULL. This should only happen for the root node, which has no parent.\n"));
	}
	else if( ! GfxCheckObjPtr(pParentItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pParentItem is not a valid pointer.\n"));
		m_pParent = NULL;
		return;
	}

	m_pParent = pParentItem;
}


/////////////////////////////////////////////////////////////////////////////
// Child Scope Item Members

int CScopePaneItem::GetChildCount() const
{
	TRACEX(_T("CScopePaneItem::GetChildCount\n"));

	return (int)m_Children.GetSize();
}

CScopePaneItem* CScopePaneItem::GetChild(int iIndex)
{
	TRACEX(_T("CScopePaneItem::GetChild\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_Children.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return NULL;
	}

	return m_Children[iIndex];
}

int CScopePaneItem::AddChild(CScopePaneItem* pChildItem)
{
	TRACEX(_T("CScopePaneItem::AddChild\n"));
	TRACEARGn(pChildItem);

	if( ! GfxCheckObjPtr(pChildItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pChildItem is not a valid pointer.\n"));
		return -1;
	}

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( pChildItem->GetDisplayName().CompareNoCase(m_Children[i]->GetDisplayName()) < 0 )
		{
			m_Children.InsertAt(i,pChildItem);
			return i;
		}
	}

	return (int)m_Children.Add(pChildItem);
}

void CScopePaneItem::RemoveChild(int iIndex)
{
	TRACEX(_T("CScopePaneItem::RemoveChild\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_Children.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	m_Children.RemoveAt(iIndex);
}

void CScopePaneItem::RemoveChild(CScopePaneItem* pChildItem)
{
	TRACEX(_T("CScopePaneItem::RemoveChild\n"));
	TRACEARGn(pChildItem);

	if( ! GfxCheckObjPtr(pChildItem,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pChildItem is not a valid pointer.\n"));
		return;
	}

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i] == pChildItem )
		{
			RemoveChild(i);
			return;
		}
	}
}

void CScopePaneItem::DestroyChild(CScopePaneItem* pChild)
{
	TRACEX(_T("CScopePaneItem::DestroyChild\n"));
	TRACEARGn(pChild);

	if( ! GfxCheckObjPtr(pChild,CScopePaneItem) )
	{
		TRACE(_T("FAILED : pChild is not a valid pointer.\n"));
		return;
	}

	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		if( m_Children[i] == pChild )
		{
			RemoveChild(i);
			delete pChild;
			return;
		}
	}
}

int CScopePaneItem::FindChild(SPIFINDPROC pFindProc, LPARAM param)
{
	TRACEX(_T("CScopePaneItem::FindChild\n"));
	TRACEARGn(pFindProc);

	if( ! GfxCheckPtr(pFindProc,SPIFINPROC) )
	{
		TRACE(_T("FAILED : pFindProc is not a valid function pointer.\n"));
		return -1;
	}

	return pFindProc(m_Children,param);
}


/////////////////////////////////////////////////////////////////////////////
// Results Pane View Members

CResultsPaneView* CScopePaneItem::CreateResultsPaneView()
{
	TRACEX(_T("CScopePaneItem::CreateResultsPaneView\n"));

	return new CResultsPaneView;
}

CResultsPaneView* CScopePaneItem::GetResultsPaneView()const
{
	TRACEX(_T("CScopePaneItem::GetResultsPaneView\n"));

	if( ! GfxCheckObjPtr(m_pResultsPaneView,CResultsPaneView) )
	{
		TRACE(_T("FAILED : m_pResultsPaneView is not a valid pointer.\n"));
		return NULL;
	}

	return m_pResultsPaneView;
}


/////////////////////////////////////////////////////////////////////////////
// MMC-Related Item Members

bool CScopePaneItem::InsertItem( int iIndex )
{
	TRACEX(_T("CScopePaneItem::InsertItem\n"));

	if( ! GetScopePane() )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

  if( ! GetParent() )
  {
    TRACE(_T("WARNING : m_pParent is not a valid pointer. This could be the root item.\n"));
    return false;
  }

  if( m_pParent->GetItemHandle() == NULL )
  {
    TRACE(_T("FAILED : Parent's item handle is NULL!\n"));
    return false;
  }

  if( GetItemHandle() != NULL )
  {
    TRACE(_T("WARNING : Item already inserted.\n"));
    return false;
  }

  SCOPEDATAITEM sdi;

  ZeroMemory(&sdi,sizeof(sdi));

	if( iIndex > 0 )
	{
		CScopePaneItem* pSiblingItem = m_pParent->GetChild(iIndex-1);
		sdi.mask       = SDI_STR       |
										 SDI_PARAM     |
										 SDI_IMAGE     |
										 SDI_OPENIMAGE |
										 SDI_PREVIOUS;
		sdi.relativeID  = pSiblingItem->GetItemHandle();
	}
	else
	{
		sdi.mask       = SDI_STR       |
										 SDI_PARAM     |
										 SDI_IMAGE     |
										 SDI_OPENIMAGE |
										 SDI_PARENT;
		sdi.relativeID  = m_pParent->GetItemHandle();
	}

	sdi.nImage      = m_pScopePane->AddIcon(GetIconId());
	sdi.nOpenImage  = m_pScopePane->AddIcon(GetOpenIconId());
	sdi.displayname = MMC_CALLBACK;
	sdi.lParam      = (LPARAM)this;    // The cookie is the this pointer

	LPCONSOLENAMESPACE2 lpNamespace = m_pScopePane->GetConsoleNamespacePtr();

	if( ! GfxCheckPtr(lpNamespace,IConsoleNameSpace2) )
	{
		TRACE(_T("FAILED : lpNamespace is not a valid pointer.\n"));
		return false;
	}

	HRESULT hr = lpNamespace->InsertItem( &sdi );

	if( hr != S_OK )
	{
		TRACE(_T("FAILED : IConsoleNameSpace2::InsertItem failed.\n"));
		TRACE(_T("FAILED : HRESULT=%X\n"),hr);
	}

	// save off the ID
	m_hItemHandle = sdi.ID;

	lpNamespace->Release();

	return true;
}

bool CScopePaneItem::DeleteItem()
{
	TRACEX(_T("CScopePaneItem::DeleteItem\n"));

	// this function deletes the item and all its children from the mmc namespace ONLY

	// call Destroy to completely remove this item from MMC and the framework

	if( ! GetScopePane() )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

  if( ! GetItemHandle() )
  {
		TRACE(_T("FAILED : GetItemHandle returns NULL.\n"));
		return false;
	}

	if( IsPropertySheetOpen() )
	{
		return false;
	}

	LPCONSOLENAMESPACE2 lpConsoleNamespace = m_pScopePane->GetConsoleNamespacePtr();
  
	if( ! GfxCheckPtr(lpConsoleNamespace,IConsoleNamespace2) )
	{
		TRACE(_T("WARNING : lpConsoleNamespace is not a valid pointer.\n"));
		return false;
	}

	lpConsoleNamespace->DeleteItem(GetItemHandle(),TRUE);
	lpConsoleNamespace->Release();
	m_hItemHandle = NULL;

	return true;
}

bool CScopePaneItem::SetItem()
{
	TRACEX(_T("CScopePaneItem::SetItem\n"));

  if( GetItemHandle() == NULL )
  {
    TRACE(_T("FAILED : Item handle is NULL!\n"));
    return false;
  }

	if( GetScopePane() == NULL )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

	LPCONSOLENAMESPACE2 lpNamespace = m_pScopePane->GetConsoleNamespacePtr();

	if( ! GfxCheckPtr(lpNamespace,IConsoleNameSpace2) )
	{
		TRACE(_T("FAILED : lpNamespace is not a valid pointer.\n"));
		return false;
	}

  SCOPEDATAITEM sdi;
  ZeroMemory(&sdi,sizeof(sdi));

	sdi.mask       = SDI_PARAM     |   // lParam is valid
									 SDI_IMAGE     |   // nImage is valid
									 SDI_OPENIMAGE;    // nOpenImage is valid
	sdi.nImage      = m_pScopePane->GetIconIndex(GetIconId());
	sdi.nOpenImage  = m_pScopePane->GetIconIndex(GetOpenIconId());
	sdi.lParam      = (LPARAM)this;    // The cookie is the this pointer
  sdi.ID          = GetItemHandle();

	HRESULT hr = lpNamespace->SetItem( &sdi );

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleNameSpace2::SetItem failed.\n"));
		lpNamespace->Release();
		return false;
	}

	lpNamespace->Release();

	return true;
}

void CScopePaneItem::SelectItem()
{
	TRACEX(_T("CScopePaneItem::SelectItem\n"));

	CScopePane* pPane = GetScopePane();
	LPCONSOLE2 lpConsole = pPane->GetConsolePtr();
	lpConsole->SelectScopeItem(GetItemHandle());
	lpConsole->Release();
}

void CScopePaneItem::ExpandItem(BOOL bExpand /* = TRUE*/)
{
	TRACEX(_T("CScopePaneItem::ExpandItem\n"));

	CScopePane* pPane = GetScopePane();
  for( int i = 0; i < pPane->GetResultsPaneCount(); i++ )
  {
	  LPCONSOLE2 lpConsole = pPane->GetResultsPane(i)->GetConsolePtr();
	  HRESULT hr = lpConsole->Expand(GetItemHandle(),bExpand);
    CHECKHRESULT(hr);
	  lpConsole->Release();
  }
}

void CScopePaneItem::SortItems()
{
	if( m_Children.GetSize() == 1 )
		return;

	bool bSorted = false;

	bool bDirty = false;
	while( !bSorted )
	{
		bSorted = true;
		for( int i = 0; i < m_Children.GetSize()-1; i++ )
		{
			CScopePaneItem* pItem1 = m_Children[i];
			CScopePaneItem* pItem2 = m_Children[i+1];
			TRACE(_T("%s > %s\n"),pItem1->GetDisplayName(),pItem2->GetDisplayName());
			if( pItem1->GetDisplayName().CompareNoCase(pItem2->GetDisplayName()) > 0 )
			{
				TRACE(_T("Swapping %s with %s.\n"),pItem1->GetDisplayName(),pItem2->GetDisplayName());
				m_Children.SetAt(i,pItem2);
				m_Children.SetAt(i+1,pItem1);
				bSorted = false;
				bDirty = true;
			}
		}
	}
/*
	if( bDirty )
	{
		LPCONSOLENAMESPACE2 lpNamespace = GetScopePane()->GetConsoleNamespacePtr();
		for( int i = 0; i < m_Children.GetSize(); i++ )
		{
			lpNamespace->DeleteItem(m_Children[i]->GetItemHandle(),1L);			
			m_Children[i]->InsertItem(i);
		}
		lpNamespace->Release();
	}
*/
}

void CScopePaneItem::ShowItem()
{
	TRACEX(_T("CScopePaneItem::ShowItem\n"));

	if( m_bVisible )
	{
		TRACE(_T("WARNING : Item is already visible.\n"));
		return;
	}

	if( ! InsertItem(0) )
	{
		TRACE(_T("FAILED : InsertItem failed.\n"));
		return;
	}

	m_bVisible = true;
}

void CScopePaneItem::HideItem()
{
	TRACEX(_T("CScopePaneItem::HideItem\n"));

	if( !m_bVisible )
	{
		TRACE(_T("WARNING : Item is already hidden.\n"));
		return;
	}

	if( ! DeleteItem() )
	{
		TRACE(_T("FAILED : DeleteItem failed.\n"));
	}

	m_bVisible = false;
}

bool CScopePaneItem::IsItemVisible() const
{
	TRACEX(_T("CScopePaneItem::IsItemVisible\n"));

	return m_bVisible;
}

HSCOPEITEM CScopePaneItem::GetItemHandle()
{
	TRACEX(_T("CScopePaneItem::GetItemHandle\n"));

	return m_hItemHandle;
}

void CScopePaneItem::SetItemHandle(HSCOPEITEM hItem)
{
	TRACEX(_T("CScopePaneItem::SetItemHandle\n"));
	TRACEARGn(hItem);

	m_hItemHandle = hItem;
}

LPGUID CScopePaneItem::GetItemType()
{
	TRACEX(_T("CScopePaneItem::GetItemType\n"));

	if( ! GfxCheckPtr(m_lpguidItemType,GUID) )
	{
		TRACE(_T("FAILED : m_lpguidItemType is an invalid pointer.\n"));
		return NULL;
	}

	return m_lpguidItemType;
}

HRESULT CScopePaneItem::WriteExtensionData(LPSTREAM pStream)
{
	TRACEX(_T("CScopePaneItem::WriteExtensionData\n"));
	TRACEARGn(pStream);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Display Name Members

CString CScopePaneItem::GetDisplayName(int nIndex /*= 0*/)
{
	TRACEX(_T("CScopePaneItem::GetDisplayName\n"));
	TRACEARGn(nIndex);

	if( nIndex >= m_saDisplayNames.GetSize() || nIndex < 0 )
	{
		TRACE(_T("FAILED : nIndex is out of array bounds.\n"));
		return _T("");
	}
	
	return m_saDisplayNames[nIndex];
}

CStringArray& CScopePaneItem::GetDisplayNames()
{
	TRACEX(_T("CScopePaneItem::GetDisplayNames\n"));

	return m_saDisplayNames;
}

void CScopePaneItem::SetDisplayName(int nIndex, const CString& sName)
{
	TRACEX(_T("CScopePaneItem::SetDisplayName\n"));
	TRACEARGn(nIndex);

	if( nIndex >= m_saDisplayNames.GetSize() || nIndex < 0 )
	{
		TRACE(_T("WARNING : nIndex is out of array bounds. The string will be added to Display Names.\n"));
		m_saDisplayNames.InsertAt(nIndex,sName);
		return;
	}

	m_saDisplayNames.SetAt(nIndex,sName);

}

void CScopePaneItem::SetDisplayNames(const CStringArray& saNames)
{
	TRACEX(_T("CScopePaneItem::SetDisplayNames\n"));
	TRACEARGn(saNames.GetSize());

	m_saDisplayNames.Copy(saNames);
}


/////////////////////////////////////////////////////////////////////////////
// Icon Members

void CScopePaneItem::SetIconIndex(int iIndex)
{
	TRACEX(_T("CScopePaneItem::SetIconIndex\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_IconResIds.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	m_iCurrentIconIndex = iIndex;
}

int CScopePaneItem::GetIconIndex()
{
	TRACEX(_T("CScopePaneItem::GetIconIndex\n"));

	if( m_iCurrentIconIndex >= m_IconResIds.GetSize() || m_iCurrentIconIndex < 0 )
	{
		TRACE(_T("WARNING : m_iCurrentIconIndex is out of array bounds.\n"));
		return -1;
	}

	return m_iCurrentIconIndex;

}

UINT CScopePaneItem::GetIconId()
{
	TRACEX(_T("CScopePaneItem::GetIconId\n"));

	if( GetIconIndex() == -1 )
	{
		TRACE(_T("FAILED : m_iCurrentIconIndex is out of array bounds.\n"));
		return 0;
	}

	return m_IconResIds[GetIconIndex()];
}

CUIntArray& CScopePaneItem::GetIconIds()
{
	TRACEX(_T("CScopePaneItem::GetIconId\n"));

	return m_IconResIds;
}

void CScopePaneItem::SetOpenIconIndex(int iIndex)
{
	TRACEX(_T("CScopePaneItem::SetOpenIconIndex\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_OpenIconResIds.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	m_iCurrentOpenIconIndex = iIndex;
}

int CScopePaneItem::GetOpenIconIndex()
{
	TRACEX(_T("CScopePaneItem::GetOpenIconIndex\n"));

	if( m_iCurrentOpenIconIndex >= m_OpenIconResIds.GetSize() || m_iCurrentOpenIconIndex < 0 )
	{
		TRACE(_T("WARNING : m_iCurrentOpenIconIndex is out of array bounds.\n"));
		return -1;
	}

	return m_iCurrentOpenIconIndex;
}

UINT CScopePaneItem::GetOpenIconId()
{
	TRACEX(_T("CScopePaneItem::GetOpenIconId\n"));

	if( GetOpenIconIndex() == -1 )
	{
		TRACE(_T("FAILED : m_iCurrentOpenIconIndex is out of array bounds.\n"));
		return 0;
	}

	return m_OpenIconResIds[GetOpenIconIndex()];
}

/////////////////////////////////////////////////////////////////////////////
// Property Sheet Members

bool CScopePaneItem::IsPropertySheetOpen(bool bSearchChildren /*=false*/)
{
	TRACEX(_T("CScopePaneItem::IsPropertySheetOpen\n"));

	// this function attempts to bring up an open property sheet for this scope item
	// if it succeeds, then the property sheet is brought to the foreground
	// if it fails, then there are no open property sheets for the scope item

	if( ! GetScopePane() )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

	LPCONSOLE2 lpConsole = m_pScopePane->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return false;
	}

	// get a reference to the IPropertySheetProvider interface
	LPPROPERTYSHEETPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	// create an IDataObject for this scope item
  CSnapinDataObject* pdoNew = NULL;
	pdoNew = new CSnapinDataObject;

	if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		lpProvider->Release();
		lpConsole->Release();
		return false;
	}

	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject);
	pdoNew->SetItem(this);

	for( int i = 0; i < m_pScopePane->GetResultsPaneCount(); i++ )
	{
		CResultsPane* pResultsPane = m_pScopePane->GetResultsPane(i);
		if( GfxCheckObjPtr(pResultsPane,CResultsPane) )
		{
			LPCOMPONENT pComponent = (LPCOMPONENT)pResultsPane->GetInterface(&IID_IComponent);
			hr = lpProvider->FindPropertySheet(MMC_COOKIE(this),pComponent,lpDataObject);
			if( hr == S_OK )
				break;
		}
	}


	lpProvider->Release();
	lpConsole->Release();

	delete pdoNew;

	if( hr == S_FALSE || ! CHECKHRESULT(hr) )
	{
		TRACE(_T("INFO : No property sheets were open for this node.\n"));
		if( bSearchChildren ) // search children for open sheets if requested
		{
			for( int k = 0; k < GetChildCount(); k++ )
			{
				if( GetChild(k) && GetChild(k)->IsPropertySheetOpen(true) )
				{
					return true;
				}
			}
		}
		return false;
	}
	else
	{
		return true;
	}

	return false;
}

bool CScopePaneItem::InvokePropertySheet()
{
	TRACEX(_T("CScopePaneItem::InvokePropertySheet\n"));

	// this function programmatically invokes a property sheet for a scope pane item
	// see M. Maguire's doc on IAS snapin design for a detailed description on just what
	// is going on here. I cannot claim this as my own. :-)

	// first see if a property sheet for this item is open already
//	if( IsPropertySheetOpen() )
//	{
//		return true;
//	}

	if( ! GetScopePane() )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

	LPCONSOLE2 lpConsole = m_pScopePane->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return false;
	}

	// get a reference to the IPropertySheetProvider interface
	LPPROPERTYSHEETPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	// create an IDataObject for this scope item
  CSnapinDataObject* pdoNew = NULL;
	pdoNew = new CSnapinDataObject;

	if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		lpProvider->Release();
		lpConsole->Release();
		return false;
	}

	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject);
	pdoNew->SetItem(this);

	hr = lpProvider->CreatePropertySheet(GetDisplayName(),TRUE,MMC_COOKIE(this),lpDataObject,MMC_PSO_HASHELP);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IPropertySheetProvider::CreatePropertySheet failed.\n"));
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

	HWND hWndNotification = NULL;
	HWND hWndMain = NULL;

	hr = lpConsole->GetMainWindow(&hWndMain);
	if( ! CHECKHRESULT(hr) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show( -1, 0);
		lpProvider->Release();
		lpConsole->Release();
		
		delete pdoNew;

		return false;
	}

	// Try to get the correct window that notifications should be sent to.
	hWndNotification = FindWindowEx( hWndMain, NULL, _T("MDIClient"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCChildFrm"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCView"), NULL );
	
	if( hWndNotification == NULL )
	{
		// It was a nice try, but it failed, so we should be able to get by by using the main HWND.
		hWndNotification = hWndMain;
	}

	LPCOMPONENTDATA lpComponentData = (LPCOMPONENTDATA)m_pScopePane->GetInterface(&IID_IComponentData);

	hr = lpProvider->AddPrimaryPages(lpComponentData,TRUE,hWndNotification,TRUE);
	if( ! CHECKHRESULT(hr) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show(-1,0);
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

  hr = lpProvider->AddExtensionPages();  
	if( ! CHECKHRESULT(hr) )
	{
		// ISSUE: Should I care if this fails?
		TRACE(_T("WARNING : PROPERTYSHEETPROVIDER::AddExtensionPages failed.\n"));

		// Release data allocated in CreatePropertySheet
//		lpProvider->Show( -1, 0);
//		lpProvider->Release();
//		lpConsole->Release();

//		delete pdoNew;

//		return false;
	}

    // v-marfin : 62962 Show "details" page on a new creation
    BOOL bIsNewDataGroup = this->IsKindOf(RUNTIME_CLASS(CDataGroupScopeItem));
    int nShowPage = bIsNewDataGroup ? 0 : 1;

#ifndef IA64
    hr = lpProvider->Show( (long) hWndMain, nShowPage);  //59643b
#endif // IA64

	if( ! CHECKHRESULT( hr ) )
	{
		// Release data allocated in CreatePropertySheet
		lpProvider->Show( -1, 0);
		lpProvider->Release();
		lpConsole->Release();

		delete pdoNew;

		return false;
	}

	lpProvider->Release();
	lpConsole->Release();
  lpDataObject->Release();

//	delete pdoNew;

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Context Menu Members

// v-marfin 59644 : Modified prototype to allow passing to selected item count. 
//                  Only allow 3rd party menu item if ony 1 item is selected.
bool CScopePaneItem::InvokeContextMenu(const CPoint& pt, int iSelectedCount)
{
	TRACEX(_T("CScopePaneItem::InvokeContextMenu\n"));
	TRACEARGn(pt.x);
	TRACEARGn(pt.y);

	if( ! GetScopePane() )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return false;
	}

	LPCONSOLE2 lpConsole = m_pScopePane->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return false;
	}

	// get a reference to the IContextMenuProvider interface
	LPCONTEXTMENUPROVIDER lpProvider = NULL;

	HRESULT hr = lpConsole->QueryInterface(IID_IContextMenuProvider,(LPVOID*)&lpProvider);

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("IConsole2::QueryInterface failed.\n"));
		lpConsole->Release();
		return FALSE;
	}

	ASSERT(lpProvider);

	// just in case
	hr = lpProvider->EmptyMenuList();

	// populate the menu
	CONTEXTMENUITEM cmi;
  CString sResString;
  CString sResString2;
	ZeroMemory(&cmi,sizeof(CONTEXTMENUITEM));

	// add the top insertion point
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// add new menu and insertion point

  sResString.LoadString(IDS_STRING_NEW);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
  sResString2.LoadString(IDS_STRING_NEW_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fFlags            = MF_POPUP;
	cmi.fSpecialFlags = CCM_SPECIAL_SUBMENU;

	hr = lpProvider->AddItem(&cmi);

	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// add task menu and insertion point

  sResString.LoadString(IDS_STRING_TASK);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
  sResString2.LoadString(IDS_STRING_TASK_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fFlags            = MF_POPUP;
	cmi.fSpecialFlags = CCM_SPECIAL_SUBMENU;

	hr = lpProvider->AddItem(&cmi);

	cmi.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	hr = lpProvider->AddItem(&cmi);

	// create an IDataObject for this scope item
  CSnapinDataObject* pdoNew = NULL;
	pdoNew = new CSnapinDataObject;

	if( ! GfxCheckObjPtr(pdoNew,CSnapinDataObject) )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		lpProvider->Release();
		lpConsole->Release();
		return false;
	}

	LPDATAOBJECT lpDataObject = (LPDATAOBJECT)pdoNew->GetInterface(&IID_IDataObject);
	ASSERT(lpDataObject);
	pdoNew->SetItem(this);

	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetScopePane()->GetInterface(&IID_IExtendContextMenu);
	hr = lpProvider->AddPrimaryExtensionItems(lpUnknown,lpDataObject);

    // v-marfin 59644 : Only allow 3rd party menu items if only 1 item is selected
    //                  in the results pane view.
    if (iSelectedCount == 1)
    {
	    // add third party insertion points
	    cmi.lCommandID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	    cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	    hr = lpProvider->AddItem(&cmi);

	    cmi.lCommandID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

	    hr = lpProvider->AddItem(&cmi);

	    hr = lpProvider->AddThirdPartyExtensionItems(lpDataObject);
    }

	HWND hWndMain = NULL;
	
	hr = lpConsole->GetMainWindow(&hWndMain);

	// Try to get the correct window that notifications should be sent to.
	HWND hWndNotification = FindWindowEx( hWndMain, NULL, _T("MDIClient"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("MMCChildFrm"), NULL );
	hWndNotification = FindWindowEx( hWndNotification, NULL, _T("AfxFrameOrView42u"), NULL );
	if( hWndNotification == NULL )
	{
		// It was a nice try, but it failed, so we should be able to get by by using the main HWND.
		hWndNotification = hWndMain;
	}	

	long lSelected = 0L;
	hr = lpProvider->ShowContextMenu(hWndNotification,pt.x,pt.y,&lSelected);

	lpProvider->Release();
	lpConsole->Release();
	lpDataObject->Release();

	return true;
}

/////////////////////////////////////////////////////////////////////////////
// Help Topic

CString CScopePaneItem::GetHelpTopic() const
{
	TRACEX(_T("CScopePaneItem::GetHelpTopic\n"));

	return m_sHelpTopic;
}

void CScopePaneItem::SetHelpTopic(const CString& sTopic)
{
	TRACEX(_T("CScopePaneItem::SetHelpTopic\n"));
	TRACEARGs(sTopic);

	if( sTopic.IsEmpty() )
	{
		TRACE(_T("WARNING : sTopic is an empty string.\n"));
	}

	m_sHelpTopic = sTopic;
}


/////////////////////////////////////////////////////////////////////////////
// Messaging Members

LRESULT CScopePaneItem::MsgProc(UINT msg, WPARAM wparam, LPARAM lparam)
{
	TRACEX(_T("CScopePaneItem::MsgProc\n"));
	TRACEARGn(msg);
	TRACEARGn(wparam);
	TRACEARGn(lparam);

	// propagate to all children
	for( int i=0; i < m_Children.GetSize(); i++ )
	{
		// stop if a return value of -1 is given
		if( m_Children[i]->MsgProc(msg,wparam,lparam) == -1L )
		{
			return -1L;
		}
	}

	return 0L;
}


/////////////////////////////////////////////////////////////////////////////
// MMC Notify Handlers

HRESULT CScopePaneItem::OnActivate(BOOL bActivated)
{
	TRACEX(_T("CScopePaneItem::OnActivate\n"));
	TRACEARGn(bActivated);

	return S_OK;
}

HRESULT CScopePaneItem::OnAddImages(CResultsPane* pPane)
{
	TRACEX(_T("CScopePaneItem::OnAddImages\n"));
	TRACEARGn(pPane);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer to an object.\n"));
		return E_FAIL;
	}

	pPane->AddIcon(GetIconId());

	return S_OK;
}

HRESULT CScopePaneItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CScopePaneItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

	return S_OK;
}

HRESULT CScopePaneItem::OnBtnClick(MMC_CONSOLE_VERB verb)
{
	TRACEX(_T("CScopePaneItem::OnBtnClick\n"));
	TRACEARGn(verb);

	return S_OK;
}

HRESULT CScopePaneItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CScopePaneItem::OnCommand\n"));
	TRACEARGn(lCommandID);

	return S_OK;
}

HRESULT CScopePaneItem::OnContextHelp()
{
	TRACEX(_T("CScopePaneItem::OnContextHelp\n"));

	if( GetScopePane() == NULL )
	{
		TRACE(_T("FAILED : m_pScopePane is not a valid pointer.\n"));
		return E_FAIL;
	}

    // v-marfin 62478 : Set help topic based on type of object
    //--------------------------------------------------------

    if (GfxCheckObjPtr(this,CRootScopeItem))               // HealthMonitor level, top level
    {
        m_sHelpTopic = _T("HMon21.chm::/oroot.htm");
    }
    else if (GfxCheckObjPtr(this,CAllSystemsScopeItem))    // All Monitored Computers
    {
        m_sHelpTopic = _T("HMon21.chm::/oallmon.htm");
    }
    else if (GfxCheckObjPtr(this,CSystemScopeItem))        // Monitored Computer
    {
        m_sHelpTopic = _T("HMon21.chm::/ocomp.htm");
    }
    else if (GfxCheckObjPtr(this,CActionPolicyScopeItem))  // Actions
    {
        m_sHelpTopic = _T("HMon21.chm::/oact.htm");
    }
    else if (GfxCheckObjPtr(this,CDataGroupScopeItem))     // Data Group
    {
        m_sHelpTopic = _T("HMon21.chm::/odatagrp.htm");
    }
    else if (GfxCheckObjPtr(this,CDataElementScopeItem))   // Data Collector
    {
        m_sHelpTopic = _T("HMon21.chm::/odatacol.htm");
    }
    else if (GfxCheckObjPtr(this,CRuleScopeItem))          // Threshold
    {
        m_sHelpTopic = _T("HMon21.chm::/othreshold.htm");
    }

    //--------------------------------------------------------



	if( m_sHelpTopic.IsEmpty() )
	{
		return S_OK;
	}

	LPCONSOLE2 lpConsole = m_pScopePane->GetConsolePtr();

	if( ! GfxCheckPtr(lpConsole,IConsole2) )
	{
		TRACE(_T("FAILED : lpConsole is not a valid pointer.\n"));
		return E_FAIL;
	}

	IDisplayHelp* pidh = NULL;
	HRESULT hr = lpConsole->QueryInterface(IID_IDisplayHelp,(LPVOID*)&pidh);

	ASSERT(pidh);
	if( pidh == NULL || ! CHECKHRESULT(hr) )
	{
		TRACE(_T("Failed on IConsole2::QI(IID_IDisplayHelp).\n"));
		return hr;
	}
	
	LPOLESTR lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((m_sHelpTopic.GetLength() + 1)* sizeof(TCHAR)));
  if( lpCompiledHelpFile == NULL )
	{
		TRACE(_T("FAILED : Out of memory.\n"));
		return E_OUTOFMEMORY;
	}

	_tcscpy(lpCompiledHelpFile, (LPCTSTR)m_sHelpTopic);
	
	hr = pidh->ShowTopic(lpCompiledHelpFile);

	pidh->Release();
	lpConsole->Release();

	return hr;
}

HRESULT CScopePaneItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CScopePaneItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	// return S_FALSE to indicate that no property pages will be created
	return S_FALSE;
}

HRESULT CScopePaneItem::OnCutOrMove()
{
	TRACEX(_T("CScopePaneItem::OnCutOrMove\n"));

	return S_OK;
}

HRESULT CScopePaneItem::OnDelete(BOOL bConfirm)  // v-marfin 60298	
{
	TRACEX(_T("CScopePaneItem::OnDelete\n"));

	return S_OK;
}

HRESULT CScopePaneItem::OnExpand(BOOL bExpand)
{
	TRACEX(_T("CScopePaneItem::OnExpand\n"));
	TRACEARGn(bExpand);

  if( bExpand )
  {
    // for each child call InsertItem to insert into namespace
    for( int i=0; i < m_Children.GetSize(); i++ )
    {
      if( ! m_Children[i]->InsertItem(i) )
			{
				TRACE(_T("FAILED : CScopePaneItem::InsertItem failed.\n"));
			}
    }
  }

	return S_OK;
}

HRESULT CScopePaneItem::OnGetDisplayInfo(int nColumnIndex, LPTSTR* ppString)
{
	TRACEX(_T("CScopePaneItem::OnGetDisplayInfo\n"));
	TRACEARGn(nColumnIndex);
	TRACEARGn(ppString);

  if( nColumnIndex < 0 || nColumnIndex >= m_saDisplayNames.GetSize() )
  {
    TRACE(_T("FAILED : The column index is out of the display name array bounds"));
    return E_FAIL;
  }

  *ppString = LPTSTR(LPCTSTR(GetDisplayName(nColumnIndex)));

  return S_OK;
}

HRESULT CScopePaneItem::OnGetResultViewType(CString& sViewType,long& lViewOptions)
{
	TRACEX(_T("CScopePaneItem::OnGetResultViewType\n"));
	TRACEARGs(sViewType);
	TRACEARGn(lViewOptions);

	if( ! GetResultsPaneView() )
	{
		return E_FAIL;
	}

	return m_pResultsPaneView->OnGetResultViewType(sViewType,lViewOptions);
}

HRESULT CScopePaneItem::OnListpad(BOOL bAttachingListCtrl)
{
	TRACEX(_T("CScopePaneItem::OnListpad\n"));
	TRACEARGn(bAttachingListCtrl);

	return S_OK;
}

HRESULT CScopePaneItem::OnMinimized(BOOL bMinimized)
{
	TRACEX(_T("CScopePaneItem::OnMinimized\n"));
	TRACEARGn(bMinimized);

	return S_OK;
}

HRESULT CScopePaneItem::OnPaste(LPDATAOBJECT pSelectedItems, LPDATAOBJECT* ppCopiedItems)
{
	TRACEX(_T("CScopePaneItem::OnPaste\n"));
	TRACEARGn(pSelectedItems);
	TRACEARGn(ppCopiedItems);

	return S_OK;
}

HRESULT CScopePaneItem::OnPropertyChange(LPARAM lParam)
{
	TRACEX(_T("CScopePaneItem::OnPropertyChange\n"));
	TRACEARGn(lParam);

	return S_OK;
}

HRESULT CScopePaneItem::OnQueryPagesFor()
{
	TRACEX(_T("CScopePaneItem::OnQueryPagesFor\n"));

	return S_OK;
}

HRESULT CScopePaneItem::OnQueryPaste(LPDATAOBJECT pDataObject)
{
	TRACEX(_T("CScopePaneItem::OnQueryPaste\n"));
	TRACEARGn(pDataObject);

	return S_OK;
}

HRESULT CScopePaneItem::OnRefresh()
{
	TRACEX(_T("CScopePaneItem::OnRefresh\n"));

	return S_OK;
}

HRESULT CScopePaneItem::OnRemoveChildren()
{
	TRACEX(_T("CScopePaneItem::OnRemoveChildren\n"));

	for( int i = 0; i < GetChildCount(); i++ )
	{
		CScopePaneItem* pItem = GetChild(i);
		if( pItem )
		{
			if( ! pItem->DeleteItem() )
			{
				TRACE(_T("WARNING : CScopePaneItem::DeleteItem returns false.\n"));
			}
		}
	}

	return S_OK;
}

HRESULT CScopePaneItem::OnRename(const CString& sNewName)
{
	TRACEX(_T("CScopePaneItem::OnRename\n"));

	SetDisplayName(0,sNewName);

	return S_OK;
}

HRESULT CScopePaneItem::OnRestoreView(MMC_RESTORE_VIEW* pRestoreView, BOOL* pbHandled)
{
	TRACEX(_T("CScopePaneItem::OnRestoreView\n"));
	TRACEARGn(pRestoreView);
	TRACEARGn(pbHandled);

	return S_OK;
}

HRESULT CScopePaneItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CScopePaneItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! GfxCheckObjPtr(pPane,CResultsPane) )
	{
		return E_FAIL;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

	hr = lpConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetDefaultVerb failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}

HRESULT CScopePaneItem::OnShow(CResultsPane* pPane, BOOL bSelecting)
{
	TRACEX(_T("CScopePaneItem::OnShow\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelecting);

	// first we need to track scope item selected since MMC does not do this
	CScopePane* pScopePane = GetScopePane();

	if( ! pScopePane )
	{
		TRACE(_T("FAILED : CScopePaneItem::GetScopePane returns NULL pointer.\n"));
		return E_FAIL;
	}

	if( ! bSelecting ) // we are being de-selected so tell the scope pane !
	{
		pScopePane->SetSelectedScopeItem(NULL);
	}
	else
	{
		pScopePane->SetSelectedScopeItem(this);
	}

	if( ! GetResultsPaneView() )
	{
		TRACE(_T("FAILED : m_pResultsPaneView is not a valid pointer.\n"));
		return E_FAIL;
	}

	return m_pResultsPaneView->OnShow(pPane,bSelecting,GetItemHandle());
}

/////////////////////////////////////////////////////////////////////////////
// MFC Operations

void CScopePaneItem::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CScopePaneItem, CCmdTarget)
	//{{AFX_MSG_MAP(CScopePaneItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScopePaneItem, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CScopePaneItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScopePaneItem to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A6861-9056-11D2-BD45-0000F87A3912}
static const IID IID_IScopePaneItem =
{ 0x7d4a6861, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CScopePaneItem, CCmdTarget)
	INTERFACE_PART(CScopePaneItem, IID_IScopePaneItem, Dispatch)
END_INTERFACE_MAP()

// {7D4A6862-9056-11D2-BD45-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CScopePaneItem, "SnapIn.ScopePaneItem", 0x7d4a6862, 0x9056, 0x11d2, 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CScopePaneItem::CScopePaneItemFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CScopePaneItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\selectsystemsdlg.h ===
#if !defined(AFX_SELECTSYSTEMSDLG_H__B15FC9AA_5A42_11D3_BE46_0000F87A3912__INCLUDED_)
#define AFX_SELECTSYSTEMSDLG_H__B15FC9AA_5A42_11D3_BE46_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectSystemsDlg.h : header file
//

#include "ResizeableDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectSystemsDlg dialog

class CSelectSystemsDlg : public CResizeableDialog
{
// Construction
public:
	CSelectSystemsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectSystemsDlg)
	enum { IDD = IDD_DIALOG_NEW_SYSTEM };
	CEdit	m_SystemsEditBox;
	CListCtrl	m_SystemsList;
	CComboBox	m_Domains;
	CString	m_sDomain;
	CString	m_sSystems;
	//}}AFX_DATA

	CStringArray m_saSystems;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectSystemsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static UINT AddDomains(LPVOID pParam);
	static UINT AddSystems(LPVOID pParam);

	inline void CompileArrayOfSystems();
	inline bool IsInSystemArray(const CString& sSystem);
	inline bool CheckSystemNames();

	// Generated message map functions
	//{{AFX_MSG(CSelectSystemsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkListSystems(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnButtonHelp();
	afx_msg void OnDropdownComboDomain();
	afx_msg void OnCloseupComboDomain();
	afx_msg void OnSelendokComboDomain();
	afx_msg void OnChangeEditSystems();
	afx_msg void OnButtonCheckNames();
	afx_msg void OnSetfocusListSystems(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusListSystems(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonAdd();
	afx_msg void OnClickListSystems(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTSYSTEMSDLG_H__B15FC9AA_5A42_11D3_BE46_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\scopepaneitem.h ===
#if !defined(AFX_SCOPEPANEITEM_H__7D4A6863_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_SCOPEPANEITEM_H__7D4A6863_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ScopePaneItem.h : header file
//

#include <mmc.h>

class CScopePane;
class CResultsPaneView;
class CScopePaneItem;
class CResultsPane;

typedef CTypedPtrArray<CObArray,CScopePaneItem*> ScopePaneItemArray;
typedef int (*SPIFINDPROC) (const ScopePaneItemArray& ScopeItems, LPARAM param);

/////////////////////////////////////////////////////////////////////////////
// CScopePaneItem command target

class CScopePaneItem : public CCmdTarget
{

DECLARE_DYNCREATE(CScopePaneItem)

// Construction/Destruction
public:
	CScopePaneItem();
	virtual ~CScopePaneItem();

// Create/Destroy
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	virtual void Destroy();

// Scope Pane Members
public:
	CScopePane* GetScopePane() const;
	void SetScopePane(CScopePane* pScopePane);
protected:
	CScopePane* m_pScopePane;

// Parent Scope Item Members
public:
	CScopePaneItem* GetParent() const;
	void SetParent(CScopePaneItem* pParentItem);

    // v-marfin 59237 : Display new data collectors with generated unique name
    CString GetUniqueDisplayName(CString sProposedName); 

protected:
	CScopePaneItem* m_pParent;

// Child Scope Item Members
public:
	int GetChildCount() const;
	CScopePaneItem* GetChild(int iIndex);
	int AddChild(CScopePaneItem* pChildItem);
	void RemoveChild(int iIndex);
	void RemoveChild(CScopePaneItem* pChildItem);
	void DestroyChild(CScopePaneItem* pChild);
	int FindChild(SPIFINDPROC pFindProc, LPARAM param);
protected:
	ScopePaneItemArray m_Children;

// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();
	CResultsPaneView* GetResultsPaneView()const;
protected:
	CResultsPaneView* m_pResultsPaneView;

// MMC-Related Item Members
public:
	virtual bool InsertItem(int iIndex);  
	virtual bool DeleteItem();
	virtual bool SetItem();
	void SelectItem();
  void ExpandItem(BOOL bExpand = TRUE);
	void SortItems();
	void ShowItem();	
	void HideItem();	
	bool IsItemVisible() const;
	HSCOPEITEM GetItemHandle();
	void SetItemHandle(HSCOPEITEM hItem);
	LPGUID GetItemType();
	virtual HRESULT WriteExtensionData(LPSTREAM pStream);
protected:
	HSCOPEITEM m_hItemHandle;
	LPGUID m_lpguidItemType;
	bool m_bVisible;

// Display Name Members
public:
	CString GetDisplayName(int nIndex = 0);
	virtual CStringArray& GetDisplayNames();
	void SetDisplayName(int nIndex, const CString& sName);
	void SetDisplayNames(const CStringArray& saNames);
protected:
	CStringArray m_saDisplayNames;

// Icon Members
public:
	void SetIconIndex(int iIndex);
	int GetIconIndex();
	UINT GetIconId();
	CUIntArray& GetIconIds();
	void SetOpenIconIndex(int iIndex);
	int GetOpenIconIndex();
	UINT GetOpenIconId();
protected:
	CUIntArray m_IconResIds;
	int m_iCurrentIconIndex;
	CUIntArray m_OpenIconResIds;
	int m_iCurrentOpenIconIndex;	

// Property Sheet Members
public:
	bool IsPropertySheetOpen(bool bSearchChildren = false);
	bool InvokePropertySheet();

// Context Menu Members
public:

    // v-marfin 59644 : Modified prototype to allow passing to selected item count
	bool InvokeContextMenu(const CPoint& pt, int iSelectedCount= -1);

// Help Topic
public:
	CString GetHelpTopic() const;
	void SetHelpTopic(const CString& sTopic);
protected:
	CString m_sHelpTopic;

// Messaging Members
public:
	virtual LRESULT MsgProc(UINT msg, WPARAM wparam, LPARAM lparam);

// MMC Notify Handlers
public:
	virtual HRESULT OnActivate(BOOL bActivated);
  virtual HRESULT OnAddImages(CResultsPane* pPane);
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
	virtual HRESULT OnBtnClick(MMC_CONSOLE_VERB verb);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnContextHelp();
	virtual HRESULT OnCutOrMove();
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnDelete(BOOL bConfirm=TRUE);  // v-marfin 60298	
	virtual HRESULT OnExpand(BOOL bExpand);
  virtual HRESULT OnGetDisplayInfo(int nColumnIndex, LPTSTR* ppString);
	virtual HRESULT OnGetResultViewType(CString& sViewType,long& lViewOptions);
	virtual HRESULT OnListpad(BOOL bAttachingListCtrl);
	virtual HRESULT OnMinimized(BOOL bMinimized);
	virtual HRESULT OnPaste(LPDATAOBJECT pSelectedItems, LPDATAOBJECT* ppCopiedItems);
  virtual HRESULT OnPropertyChange(LPARAM lParam);
	virtual HRESULT OnQueryPagesFor();
	virtual HRESULT OnQueryPaste(LPDATAOBJECT pDataObject);
	virtual HRESULT OnRefresh();
  virtual HRESULT OnRemoveChildren();
	virtual HRESULT OnRename(const CString& sNewName);
	virtual HRESULT OnRestoreView(MMC_RESTORE_VIEW* pRestoreView, BOOL* pbHandled);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);
	virtual HRESULT OnShow(CResultsPane* pPane, BOOL bSelecting);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScopePaneItem)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CScopePaneItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CScopePaneItem)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CScopePaneItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCOPEPANEITEM_H__7D4A6863_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapin.cpp ===
// SnapIn.cpp : Defines the initialization routines for the DLL.
//
// Copyright (c) 2000 Microsoft Corporation 
//
//
// 03-14-00 v-marfin bug 58675 : Disable the "server busy.. retry, switch, etc" dialog.
// 03-23-00 v-marfin bug 61680 : Added escape and unescape special chars functions.
// 03/31/00 v-marfin no bug    : Call AfxSetResourceHandle on resource dll handle to 
//                               enable early calls to LoadString() etc to work.
//                               Use AfxFreeLibrary instead of FreeLibrary to use thread
//                               protected version of function.

#include "stdafx.h"
#include "SnapIn.h"
#include <atlbase.h>

#include "WbemClassObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//
CStringArray CSnapInApp::m_arrsNamespaces;

/////////////////////////////////////////////////////////////////////////////
// CSnapInApp

BEGIN_MESSAGE_MAP(CSnapInApp, CWinApp)
	//{{AFX_MSG_MAP(CSnapInApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSnapInApp construction

CSnapInApp::CSnapInApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// Resource Dll Members

inline bool CSnapInApp::LoadDefaultResourceDll()
{
	TRACEX(_T("CSnapInApp::LoadDefaultResourceDll\n"));

	// first attempt to load resources for the current locale
	m_hDefaultResourceDll = AfxLoadLibrary(GetDefaultResDllPath());

	// if that fails then load resources for english
	if( m_hDefaultResourceDll == NULL )
	{
		m_hDefaultResourceDll = AfxLoadLibrary(GetEnglishResDllPath());
	}

    // v-marfin
    AfxSetResourceHandle(m_hDefaultResourceDll);

	return m_hDefaultResourceDll != NULL;
}

inline void CSnapInApp::UnloadDefaultResourceDll()
{
	TRACEX(_T("CSnapInApp::UnloadDefaultResourceDll\n"));

	if( m_hDefaultResourceDll )
	{
        // v-marfin (no bug)
		AfxFreeLibrary(m_hDefaultResourceDll);
	}
}

HINSTANCE CSnapInApp::LoadResourceDll(const CString& sFileName)
{
	HINSTANCE hDllInst = NULL;
	if( m_ResourceDllMap.Lookup(sFileName,hDllInst) )
	{
		return hDllInst;
	}

	hDllInst = AfxLoadLibrary(GetDefaultResDllDirectory() + sFileName);
	if( !hDllInst )
	{
		//AfxMessageBox(IDS_STRING_RESOURCE_DLL_MISSING);
		return NULL;
	}

	m_ResourceDllMap.SetAt(sFileName,hDllInst);

	return hDllInst;
}

bool CSnapInApp::LoadString(const CString& sFileName, UINT uiResId, CString& sResString)
{
	HINSTANCE hInst = LoadResourceDll(sFileName);
	if( ! hInst )
	{
		return false;
	}

	int iResult = ::LoadString(hInst,uiResId,sResString.GetBuffer(2048),2048);
	sResString.ReleaseBuffer();

	if( iResult == 0 || sResString.IsEmpty() )
	{
		return false;
	}

	return true;
}

void CSnapInApp::UnloadResourceDlls()
{
	POSITION pos = m_ResourceDllMap.GetStartPosition();
	
	LPCTSTR lpszKey;
	HINSTANCE hInst;

	while (pos != NULL)
	{
		m_ResourceDllMap.GetNextAssoc( pos, lpszKey, hInst );

		AfxFreeLibrary(hInst);
	}		
}


/////////////////////////////////////////////////////////////////////////////
// Help System Members

inline void CSnapInApp::SetHelpFilePath()
{
	TRACEX(_T("CSnapInApp::SetHelpFilePath\n"));

	TCHAR szWinDir[_MAX_PATH];
	GetWindowsDirectory(szWinDir,_MAX_PATH);

	CString sHelpFilePath;
	sHelpFilePath.Format(IDS_STRING_HELP_FORMAT,szWinDir);

	if( m_pszHelpFilePath )
	{
		free((LPVOID)m_pszHelpFilePath);
	}

	m_pszHelpFilePath = _tcsdup(sHelpFilePath);
}

/////////////////////////////////////////////////////////////////////////////
// Directory Assistance Members

CString CSnapInApp::GetSnapinDllDirectory()
{
	TCHAR szModule[_MAX_PATH];
  TCHAR szDrive[_MAX_PATH];
  TCHAR szDir[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
  _tsplitpath(szModule,szDrive,szDir,NULL,NULL);
  CString sPath;
  sPath += szDrive;
  sPath += szDir;
  return sPath;
}

CString CSnapInApp::GetDefaultResDllDirectory()
{
	LCID lcid = GetUserDefaultLCID();	
	CString sLocaleID;
	sLocaleID.Format(_T("%08x\\"),lcid);	
	return GetSnapinDllDirectory() + sLocaleID;
}

CString CSnapInApp::GetDefaultResDllPath()
{
	return GetDefaultResDllDirectory() + _T("HMSnapinRes.dll");
}

CString CSnapInApp::GetEnglishResDllPath()
{
	return GetSnapinDllDirectory() + _T("00000409\\HMSnapinRes.dll");
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSnapInApp object

CSnapInApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSnapInApp initialization

BOOL CSnapInApp::InitInstance()
{
  SetRegistryKey(_T("Microsoft"));

	// Register all OLE server (factories) as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleObjectFactory::RegisterAll();

	// set the help path up
	SetHelpFilePath();




	// load the resource dll
	if( ! LoadDefaultResourceDll() )
	{
		AfxMessageBox(IDS_STRING_RESOURCE_DLL_MISSING);
		return FALSE;
	}

	//-------------------------------------------------------------------------------
	// v-marfin : bug 58675 : Disable the "server busy.. retry, switch, etc" dialog.
	// 
	if (!AfxOleInit())
	{
		AfxMessageBox(IDS_ERR_OLE_INIT_FAILED);
		return FALSE;
	}

	// If an OLE message filter is already in place, remove it
	COleMessageFilter *pOldFilter = AfxOleGetMessageFilter();
	if (pOldFilter)
	{
		pOldFilter->Revoke();
	}

	// Disable the "busy" dialogs
	m_mfMyMessageFilter.EnableNotRespondingDialog(FALSE);
	m_mfMyMessageFilter.EnableBusyDialog(FALSE);

	if (!m_mfMyMessageFilter.Register())
	{
		AfxMessageBox(IDS_ERR_MSGFILTER_REG_FAILED);
	}
	//-------------------------------------------------------------------------------

	return TRUE;
}

int CSnapInApp::ExitInstance() 
{
	UnloadDefaultResourceDll();

	UnloadResourceDlls();
	
	//-------------------------------------------------------------------------------
	// v-marfin : bug 58675 : Disable the "server busy.. retry, switch, etc" dialog.
	m_mfMyMessageFilter.Revoke();

	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Special entry points required for inproc servers

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return AfxDllCanUnloadNow();
}

HRESULT UpdateRegistryFromResource(LPCOLESTR lpszRes,BOOL bRegister)
{
	HRESULT hRes = S_OK;
	IRegistrar* p;

	hRes = CoCreateInstance(CLSID_Registrar, NULL, CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	if( ! CHECKHRESULT(hRes) )
	{
		AfxMessageBox(_T("Could not create CLSID_Registrar ! Updated version of ATL.DLL is needed !"));
		return hRes;
	}
	else
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
		BSTR szTemp = CString(szModule).AllocSysString();
		p->AddReplacement(OLESTR("Module"), szTemp );		

		LPCOLESTR szType = OLESTR("REGISTRY");
		if( HIWORD(lpszRes) == 0 )
		{
#ifndef IA64
			if (bRegister)
				hRes = p->ResourceRegister(szModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
			else
				hRes = p->ResourceRegister(szModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
#endif // IA64
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(szModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(szModule, lpszRes, szType);

		}
		::SysFreeString(szTemp);
		p->Release();
	}
	return hRes;
}

// by exporting DllRegisterServer, you can use regsvr.exe
STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	HRESULT hRes = UpdateRegistryFromResource((LPCOLESTR)MAKEINTRESOURCE(IDR_REGISTRY),TRUE);
	if( hRes != S_OK )
	{
		return hRes;
	}

	return S_OK;
}

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	HRESULT hRes = UpdateRegistryFromResource((LPCOLESTR)MAKEINTRESOURCE(IDR_REGISTRY_UNREG),TRUE);
	if( hRes != S_OK )
	{
		return hRes;
	}

	// delete the HMSnapin.ini file
	CString sPath;
	GetWindowsDirectory(sPath.GetBuffer(_MAX_PATH+1),_MAX_PATH);
	sPath.ReleaseBuffer();

	sPath += _T("\\HMSnapin.ini");

	try
	{
		CFile::Remove(sPath);
	}
	catch(CException* pE)
	{
		pE->Delete();
	}

	return S_OK;
}

//*********************************************************
// EscapeSpecialChars      v-marfin bug 60233
//*********************************************************
CString CSnapInApp::EscapeSpecialChars(CString &refString)
{
	// Convert any single backslashes to double backslashes.

	// Setup our return var.
	CString sRet;

	// get size of string so we don't call GetLength repeatedly
	int nSize=refString.GetLength();
	int x=0;

	// for each char in passed string, inspect and convert into ret val
	for (x=0; x<nSize; x++)
	{
		// Does this position have a backslash?
		if (refString.GetAt(x) == _T('\\'))
		{
			// Yes - Add 1 more backslash to the ret string before copying the
			// original
			sRet += _T('\\');
		}

		sRet += refString.GetAt(x);
	}

	return sRet;
}
//*********************************************************
// UnEscapeSpecialChars      v-marfin bug 60233
//*********************************************************
CString CSnapInApp::UnEscapeSpecialChars(CString &refString)
{
	// Convert any double backslashes read from WMI into single

	// Setup our return var.
	CString sRet;

	// get size of string so we don't call GetLength repeatedly
	int nSize=refString.GetLength();
	int x=0;

	// for each char in passed string, inspect and convert into ret val
	while (x < nSize)
	{
		// Does this position have a double backslash?
		if (refString.Mid(x,2) == _T("\\\\"))
		{
			// Yes - only write 1 to the return string and increment our index by 2
			sRet += _T('\\');
			x += 2;
		}
		else
		{	
			// No, just copy the char to the return string and increment index.
			sRet += refString.GetAt(x++);
		}
	}

	return sRet;
}


//****************************************************
// ValidNamespace
//****************************************************
BOOL CSnapInApp::ValidNamespace(const CString &refNamespace, const CString& sMachine)
{
	// If namespaces are empty, load.
	if (m_arrsNamespaces.GetSize() < 1)
	{
		// loads only once since it is static.
		CWaitCursor w;
		LoadNamespaceArray(_T("ROOT"),sMachine);
	}

	// scan namespace array
	int nSize = (int)m_arrsNamespaces.GetSize();
	for (int x=0; x<nSize; x++)
	{
		if (m_arrsNamespaces.GetAt(x).CompareNoCase(refNamespace)==0)
			return TRUE;
	}

	return FALSE; // not found. invalid.
}


//********************************************************************
// LoadNamespaceArray
//********************************************************************
void CSnapInApp::LoadNamespaceArray(const CString& sNamespace, const CString& sMachine)
{
	ULONG ulReturned = 0L;
	int i = 0;

	CWbemClassObject Namespaces;
  
	Namespaces.Create(sMachine);

	Namespaces.SetNamespace(sNamespace);

	CString sTemp = IDS_STRING_MOF_NAMESPACE;
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(Namespaces.CreateEnumerator(bsTemp)) )
	{		
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// for each namespace
	while( Namespaces.GetNextObject(ulReturned) == S_OK && ulReturned )
	{
		CString sName;		
		Namespaces.GetProperty(IDS_STRING_MOF_NAME,sName);

		CString sTemp2;
		Namespaces.GetProperty(IDS_STRING_MOF_NAMESPACE,sTemp2);

		// build namespace string
		CString sNamespaceFound = sTemp2 + _T("\\") + sName;

		// Add the namespace to the array
		m_arrsNamespaces.Add(sNamespaceFound);
    
		// call ourself recursively
		LoadNamespaceArray(sNamespaceFound,sMachine);    
	}	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\scopepane.h ===
#if !defined(AFX_SCOPEPANE_H__7D4A6859_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_SCOPEPANE_H__7D4A6859_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ScopePane.h : header file
//

#include <mmc.h>
#include "ScopePaneItem.h"
#include "ResultsPaneItem.h"
#include "ResultsPaneView.h"
#include "ResultsPane.h"
#include "SnapinDataObject.h"
#include "MmcMsgHook.h"

typedef CTypedPtrArray<CObArray,CResultsPane*> ResultsPaneArray;

/////////////////////////////////////////////////////////////////////////////
// CScopePane command target

class CScopePane : public CCmdTarget
{

DECLARE_DYNCREATE(CScopePane)

// Construction/Destruction
public:
	CScopePane();
	virtual ~CScopePane();

// Creation/Destruction Overrideable Members
protected:
	virtual bool OnCreate();
	virtual LPCOMPONENT OnCreateComponent();
	virtual bool OnDestroy();

// Root Scope Pane Item Members
public:
	virtual CScopePaneItem* CreateRootScopeItem();
	CScopePaneItem* GetRootScopeItem();
	void SetRootScopeItem(CScopePaneItem* pRootItem);
protected:
	CScopePaneItem* m_pRootItem;

// MMC Frame Window Message Hook Members
public:
	bool HookWindow();
	void UnhookWindow();
protected:
	CMmcMsgHook* m_pMsgHook;

// MMC Interface Members
public:
	LPCONSOLENAMESPACE2 GetConsoleNamespacePtr();
	LPCONSOLE2 GetConsolePtr();
	LPIMAGELIST GetImageListPtr();
	LPUNKNOWN GetCustomOcxPtr();
protected:
	LPCONSOLENAMESPACE2 m_pIConsoleNamespace;
	LPCONSOLE2 m_pIConsole;
	LPIMAGELIST m_pIImageList;

// MMC Scope Pane Helper Members
public:
	CScopePaneItem* GetSelectedScopeItem();
	void SetSelectedScopeItem(CScopePaneItem* pItem);
protected:
	CScopePaneItem* m_pSelectedScopeItem;

// Scope Item Icon Management
public:
	int AddIcon(UINT nIconResID);
	int GetIconIndex(UINT nIconResID);
	int GetIconCount();
	void RemoveAllIcons();
protected:
	CMap<UINT,UINT,int,int> m_IconMap;

// Results Pane Members
public:	
	int GetResultsPaneCount() const;
	CResultsPane* GetResultsPane(int iIndex);
	int AddResultsPane(CResultsPane* pPane);
	void RemoveResultsPane(int iIndex);
protected:
	ResultsPaneArray m_ResultsPanes;

// Serialization
public:
	virtual bool OnLoad(CArchive& ar);
	virtual bool OnSave(CArchive& ar);

// MMC Help
public:
  bool ShowTopic(const CString& sHelpTopic);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScopePane)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CScopePane)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CScopePane)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	////////////////////////////////
	// IComponentData Interface Part
	
	BEGIN_INTERFACE_PART(ComponentData,IComponentData)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
				/* [in] */ LPUNKNOWN pUnknown);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
				/* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
				/* [in] */ LPDATAOBJECT lpDataObject,
				/* [in] */ MMC_NOTIFY_TYPE event,
				/* [in] */ LPARAM arg,
				/* [in] */ LPARAM param);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
				/* [in] */ MMC_COOKIE cookie,
				/* [in] */ DATA_OBJECT_TYPES type,
				/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
				/* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
  
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
				/* [in] */ LPDATAOBJECT lpDataObjectA,
				/* [in] */ LPDATAOBJECT lpDataObjectB);

	END_INTERFACE_PART(ComponentData)


	////////////////////////////////
	// IPersistStream Interface Part

	BEGIN_INTERFACE_PART(PersistStream,IPersistStream)

    HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);

		HRESULT STDMETHODCALLTYPE IsDirty( void);
  
		HRESULT STDMETHODCALLTYPE Load( 
				/* [unique][in] */ IStream __RPC_FAR *pStm);
  
		HRESULT STDMETHODCALLTYPE Save( 
				/* [unique][in] */ IStream __RPC_FAR *pStm,
				/* [in] */ BOOL fClearDirty);
  
		HRESULT STDMETHODCALLTYPE GetSizeMax( 
				/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);

	END_INTERFACE_PART(PersistStream)

	////////////////////////////////
	// IExtendContextMenu Interface Part

	BEGIN_INTERFACE_PART(ExtendContextMenu,IExtendContextMenu)

    /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
    
    /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);

	END_INTERFACE_PART(ExtendContextMenu)

	////////////////////////////////
	// IExtendPropertySheet2 Interface Part

	BEGIN_INTERFACE_PART(ExtendPropertySheet2,IExtendPropertySheet2)

    /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
    
    /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
				/* [in] */ LPDATAOBJECT lpIDataObject,
				/* [out] */ HBITMAP __RPC_FAR *lphWatermark,
				/* [out] */ HBITMAP __RPC_FAR *lphHeader,
				/* [out] */ HPALETTE __RPC_FAR *lphPalette,
				/* [out] */ BOOL __RPC_FAR *bStretch);

	END_INTERFACE_PART(ExtendPropertySheet2)

	////////////////////////////////
	// ISnapinHelp Interface Part

	BEGIN_INTERFACE_PART(SnapinHelp,ISnapinHelp)

    /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);

	END_INTERFACE_PART(SnapinHelp)

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCOPEPANE_H__7D4A6859_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapin.h ===
// SnapIn.h : main header file for the SNAPIN DLL
//

#if !defined(AFX_SNAPIN_H__7D4A6850_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_SNAPIN_H__7D4A6850_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "..\HmSnapinRes\resource.h"
#include "Constants.h"
#include "ConnectionManager.h"

/////////////////////////////////////////////////////////////////////////////
// CSnapInApp
// See SnapIn.cpp for the implementation of this class
//

class CSnapInApp : public CWinApp
{

// Construction
public:
	CSnapInApp();

// Resource Dll Members
public:
	bool LoadString(const CString& sFileName, UINT uiResId, CString& sResString);
protected:
	bool LoadDefaultResourceDll();
	void UnloadDefaultResourceDll();
	HINSTANCE LoadResourceDll(const CString& sFileName);	
	void UnloadResourceDlls();
	HINSTANCE m_hDefaultResourceDll;
	CMap<LPCTSTR,LPCTSTR,HINSTANCE,HINSTANCE> m_ResourceDllMap;
	
// Help System Members
protected:
	void SetHelpFilePath();

// Directory Assistance Members
public:
	CString GetSnapinDllDirectory();
	CString GetDefaultResDllDirectory();
	CString GetDefaultResDllPath();
	CString GetEnglishResDllPath();

    CString EscapeSpecialChars(CString &refString);
    CString UnEscapeSpecialChars(CString &refString);

	COleMessageFilter m_mfMyMessageFilter;
	
// MFC Overrides
public:
	BOOL ValidNamespace(const CString &refNamespace, const CString& sMachine);

private:
	static CStringArray m_arrsNamespaces;
	void LoadNamespaceArray(const CString& sNamespace, const CString& sMachine);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSnapInApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSnapInApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SNAPIN_H__7D4A6850_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapinabout.cpp ===
// SnapinAbout.cpp : implementation file
//

#include "stdafx.h"
#include "SnapinAbout.h"
#include "FileVersion.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSnapinAbout

IMPLEMENT_DYNCREATE(CSnapinAbout, CCmdTarget)

CSnapinAbout::CSnapinAbout()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CSnapinAbout::~CSnapinAbout()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Overrideable Members
/////////////////////////////////////////////////////////////////////////////

HRESULT CSnapinAbout::OnGetStaticFolderImage(HBITMAP __RPC_FAR * hSmallImage,HBITMAP __RPC_FAR * hSmallImageOpen,HBITMAP __RPC_FAR * hLargeImage,COLORREF __RPC_FAR * cMask)
{
	TRACEX(_T("CSnapinAbout::OnGetStaticFolderImage\n"));

	*hSmallImage = NULL;
	*hSmallImageOpen = NULL;
	*hLargeImage = NULL;
	*cMask = NULL;

	return S_FALSE;
}

void CSnapinAbout::OnGetSnapinDescription(CString& sDescription)
{
	TRACEX(_T("CSnapinAbout::OnGetSnapinDescription\n"));

	sDescription = _T("");
}

HRESULT CSnapinAbout::OnGetSnapinImage(HICON __RPC_FAR *hAppIcon)
{
	TRACEX(_T("CSnapinAbout::OnGetSnapinImage\n"));

	*hAppIcon = NULL;

	return S_FALSE;
}

void CSnapinAbout::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CSnapinAbout, CCmdTarget)
	//{{AFX_MSG_MAP(CSnapinAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSnapinAbout, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CSnapinAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISnapinAbout to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {80F85331-AB10-11D2-BD62-0000F87A3912}
static const IID IID_ISnapInAbout =
{ 0x80f85331, 0xab10, 0x11d2, { 0xbd, 0x62, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CSnapinAbout, CCmdTarget)
	INTERFACE_PART(CSnapinAbout, IID_ISnapInAbout, Dispatch)
	INTERFACE_PART(CSnapinAbout, IID_ISnapinAbout, SnapinAbout)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ISnapinAbout Interface Map
/////////////////////////////////////////////////////////////////////////////

ULONG FAR EXPORT CSnapinAbout::XSnapinAbout::AddRef()
{
  METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CSnapinAbout::XSnapinAbout::Release()
{
  METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::QueryInterface(
    REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::GetSnapinDescription(
/* [out] */ LPOLESTR __RPC_FAR *lpDescription)
{
	METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  TRACEX(_T("CSnapinAbout::XSnapinAbout::GetSnapinDescription\n"));
  TRACEARGn(lpDescription);

	TCHAR szFileName[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),szFileName,_MAX_PATH);

	CFileVersion fv;
	
	fv.Open(szFileName);

	CString sSnapInDescription;
	pThis->OnGetSnapinDescription(sSnapInDescription);

	CString sDescription = sSnapInDescription;
	sDescription += _T("\r\n");
	sDescription += fv.GetFileDescription();
	sDescription += _T("\r\n");
	sDescription += fv.GetLegalCopyright();

	if( sDescription.IsEmpty() )
		return S_OK;

	LPVOID lpBuffer = CoTaskMemAlloc((sDescription.GetLength()+1)*sizeof(TCHAR));
	CopyMemory(lpBuffer,sDescription,(sDescription.GetLength()+1)*sizeof(TCHAR));
	*lpDescription = (TCHAR*)lpBuffer;

	return S_OK;
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::GetProvider( 
/* [out] */ LPOLESTR __RPC_FAR *lpName)
{
	METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  TRACEX(_T("CSnapinAbout::XSnapinAbout::GetProvider\n"));
  TRACEARGn(lpName);

	TCHAR szFileName[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),szFileName,_MAX_PATH);

	CFileVersion fv;
	
	fv.Open(szFileName);

	CString sProvider = fv.GetCompanyName();
	if( sProvider.IsEmpty() )
		return S_OK;

	LPVOID lpBuffer = CoTaskMemAlloc((sProvider.GetLength()+1)*sizeof(TCHAR));
	CopyMemory(lpBuffer,sProvider,(sProvider.GetLength()+1)*sizeof(TCHAR));
	*lpName = (TCHAR*)lpBuffer;

	return S_OK;
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::GetSnapinVersion( 
/* [out] */ LPOLESTR __RPC_FAR *lpVersion)
{
	METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  TRACEX(_T("CSnapinAbout::XSnapinAbout::GetSnapinVersion\n"));
  TRACEARGn(lpVersion);

	TCHAR szFileName[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),szFileName,_MAX_PATH);

	CFileVersion fv;
	
	fv.Open(szFileName);

	CString sVersion = fv.GetFileVersion();
	if( sVersion.IsEmpty() )
		return S_OK;

	LPVOID lpBuffer = CoTaskMemAlloc((sVersion.GetLength()+1)*sizeof(TCHAR));
	CopyMemory(lpBuffer,sVersion,(sVersion.GetLength()+1)*sizeof(TCHAR));
	*lpVersion = (TCHAR*)lpBuffer;

	return S_OK;
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::GetSnapinImage( 
/* [out] */ HICON __RPC_FAR *hAppIcon)
{
	METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  TRACEX(_T("CSnapinAbout::XSnapinAbout::GetSnapinImage\n"));
  TRACEARGn(hAppIcon);

	return pThis->OnGetSnapinImage(hAppIcon);
}

HRESULT FAR EXPORT CSnapinAbout::XSnapinAbout::GetStaticFolderImage( 
/* [out] */ HBITMAP __RPC_FAR *hSmallImage,
/* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
/* [out] */ HBITMAP __RPC_FAR *hLargeImage,
/* [out] */ COLORREF __RPC_FAR *cMask)
{
	METHOD_PROLOGUE(CSnapinAbout, SnapinAbout)
  TRACEX(_T("CSnapinAbout::XSnapinAbout::GetStaticFolderImage\n"));
  TRACEARGn(hSmallImage);
  TRACEARGn(hSmallImageOpen);
  TRACEARGn(hLargeImage);
  TRACEARGn(cMask);

	return pThis->OnGetStaticFolderImage(hSmallImage,hSmallImageOpen,hLargeImage,cMask);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapinAbout message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapinabout.h ===
#if !defined(AFX_SNAPINABOUT_H__80F85333_AB10_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_SNAPINABOUT_H__80F85333_AB10_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SnapinAbout.h : header file
//

#include <mmc.h>

/////////////////////////////////////////////////////////////////////////////
// CSnapinAbout command target

class CSnapinAbout : public CCmdTarget
{
	DECLARE_DYNCREATE(CSnapinAbout)

// Construction/Destruction
public:
	CSnapinAbout();
	virtual ~CSnapinAbout();

// Overrideable Members
protected:
	virtual HRESULT OnGetStaticFolderImage(HBITMAP __RPC_FAR * hSmallImage,HBITMAP __RPC_FAR * hSmallImageOpen,HBITMAP __RPC_FAR * hLargeImage,COLORREF __RPC_FAR * cMask);
	virtual void OnGetSnapinDescription(CString& sDescription);
	virtual HRESULT OnGetSnapinImage(HICON __RPC_FAR *hAppIcon);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSnapinAbout)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSnapinAbout)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSnapinAbout)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	// ISnapinAbout Interface Part
	BEGIN_INTERFACE_PART(SnapinAbout,ISnapinAbout)

		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
															/* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
															/* [out] */ LPOLESTR __RPC_FAR *lpName);
        
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
															/* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
															/* [out] */ HICON __RPC_FAR *hAppIcon);
        
		/* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
															/* [out] */ HBITMAP __RPC_FAR *hSmallImage,
															/* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
															/* [out] */ HBITMAP __RPC_FAR *hLargeImage,
															/* [out] */ COLORREF __RPC_FAR *cMask);

	END_INTERFACE_PART(SnapinAbout)

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SNAPINABOUT_H__80F85333_AB10_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapindataobject.h ===
#if !defined(AFX_SNAPINDATAOBJECT_H__7D4A685F_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_SNAPINDATAOBJECT_H__7D4A685F_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SnapinDataObject.h : header file
//

class CScopePaneItem;
class CResultsPaneItem;

/////////////////////////////////////////////////////////////////////////////
// CSnapinDataObject command target

class CSnapinDataObject : public CCmdTarget
{

DECLARE_DYNCREATE(CSnapinDataObject)

// Construction/Destruction
public:
	CSnapinDataObject();
	virtual ~CSnapinDataObject();

// Clipboard Members
protected:
	bool RegisterClipboardFormats();

	static UINT s_cfInternal;
	static UINT s_cfExtension;
	UINT m_cfDisplayName;
	UINT m_cfSPIGuid;
	UINT m_cfSnapinCLSID;

// Item Members
public:
	DATA_OBJECT_TYPES GetItemType();
	ULONG GetCookie();
	bool GetItem(CScopePaneItem*& pSPItem);
	bool GetItem(CResultsPaneItem*& pRPItem);
	void SetItem(CScopePaneItem* pSPItem);
	void SetItem(CResultsPaneItem* pRPItem);
protected:
	ULONG m_ulCookie;
	DATA_OBJECT_TYPES m_ItemType;

// DataObject Members
public:
	static CSnapinDataObject* GetSnapinDataObject(LPDATAOBJECT lpDataObject);
protected:
	static HRESULT GetDataObject(LPDATAOBJECT lpDataObject, UINT cfClipFormat, ULONG nByteCount, HGLOBAL* phGlobal);

// Write Members
protected:
	HRESULT WriteGuid(LPSTREAM pStream);
	HRESULT WriteDisplayName(LPSTREAM pStream);
	HRESULT WriteSnapinCLSID(LPSTREAM pStream);
	HRESULT WriteDataObject(LPSTREAM pStream);
	HRESULT WriteExtensionData(LPSTREAM pStream);

// MFC Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSnapinDataObject)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSnapinDataObject)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CSnapinDataObject)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSnapinDataObject)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()	

	////////////////////////////////
	// IDataObject Interface Part
	
	BEGIN_INTERFACE_PART(DataObject,IDataObject)

		virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
				/* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
				/* [out] */ STGMEDIUM __RPC_FAR *pmedium);
  
		virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDataHere( 
				/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
				/* [out][in] */ STGMEDIUM __RPC_FAR *pmedium);
  
		virtual HRESULT STDMETHODCALLTYPE QueryGetData( 
				/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc);
  
		virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc( 
				/* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
				/* [out] */ FORMATETC __RPC_FAR *pformatetcOut);
  
		virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
				/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
				/* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
				/* [in] */ BOOL fRelease);
  
		virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc( 
				/* [in] */ DWORD dwDirection,
				/* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc);
  
		virtual HRESULT STDMETHODCALLTYPE DAdvise( 
				/* [in] */ FORMATETC __RPC_FAR *pformatetc,
				/* [in] */ DWORD advf,
				/* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
				/* [out] */ DWORD __RPC_FAR *pdwConnection);
  
		virtual HRESULT STDMETHODCALLTYPE DUnadvise( 
				/* [in] */ DWORD dwConnection);
  
		virtual HRESULT STDMETHODCALLTYPE EnumDAdvise( 
				/* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise);

	END_INTERFACE_PART(DataObject)

};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CEnumFormatEtc

class CEnumFormatEtc : public IEnumFORMATETC
{
	private:
		ULONG           m_cRef;         //Object reference count
		ULONG           m_iCur;         //Current element.
		ULONG           m_cfe;          //Number of FORMATETCs in us
		LPFORMATETC     m_prgfe;        //Source of FORMATETCs

	public:
		CEnumFormatEtc(ULONG, LPFORMATETC);
		~CEnumFormatEtc(void);

		//IUnknown members
		STDMETHODIMP         QueryInterface(REFIID, VOID **);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);

		//IEnumFORMATETC members
		STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
		STDMETHODIMP Skip(ULONG);
		STDMETHODIMP Reset(void);
		STDMETHODIMP Clone(IEnumFORMATETC **);
};

typedef CEnumFormatEtc *PCEnumFormatEtc;

/////////////////////////////////////////////////////////////////////////////


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SNAPINDATAOBJECT_H__7D4A685F_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\splitpaneresultsview.cpp ===
// SplitPaneResultsView.cpp: implementation of the CSplitPaneResultsView class.
//
//////////////////////////////////////////////////////////////////////
// Copyright (c) 2000 Microsoft Corporation
//
// 04/06/00 v-marfin 62935 : Show "OK" Instead of "Reset" in the upper pane only

#include "stdafx.h"
#include "snapin.h"
#include "SplitPaneResultsView.h"
#include "HealthmonResultsPane.h"
#include "HMListViewColumn.h"
#include "HMResultsPaneItem.h"
#include "HMScopeItem.h"
#include "HealthmonScopePane.h"
#include "HMObject.h"
#include "EventManager.h"
#include "HMGraphView.h"
#include "DataElement.h"
#include "Rule.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSplitPaneResultsView,CResultsPaneView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSplitPaneResultsView::CSplitPaneResultsView()
{

}

CSplitPaneResultsView::~CSplitPaneResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CSplitPaneResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CSplitPaneResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CResultsPaneView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CResultsPaneView::Create failed.\n"));
		return false;
	}

	return true;
}

//////////////////////////////////////////////////////////////////////
// Results Pane Item Members
//////////////////////////////////////////////////////////////////////

void CSplitPaneResultsView::RemoveItem(int iIndex)
{
	TRACEX(_T("CSplitPaneResultsView::RemoveItem\n"));
	TRACEARGn(iIndex);

	if( iIndex >= m_ResultItems.GetSize() || iIndex < 0 )
	{
		TRACE(_T("FAILED : iIndex is out of array bounds.\n"));
		return;
	}

	CResultsPaneItem* pItem = m_ResultItems[iIndex];

	if( ! GfxCheckObjPtr(pItem,CResultsPaneItem) )
	{
		TRACE(_T("FAILED : pItem is not a valid results pane item pointer.\n"));
		return;
	}

	// for each pane showing this results view, delete the item from it
	for( int i=0; i < m_ResultsPanes.GetSize(); i++ )
	{
		if( GfxCheckObjPtr(m_ResultsPanes[i],CResultsPane) )
		{
			pItem->RemoveItem(m_ResultsPanes[i]);
		}
	}

	delete pItem;
	m_ResultItems.RemoveAt(iIndex);
}

//////////////////////////////////////////////////////////////////////
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////

HRESULT CSplitPaneResultsView::OnGetResultViewType(CString& sViewType,long& lViewOptions)
{
	TRACEX(_T("CSplitPaneResultsView::OnGetResultViewType\n"));
	TRACEARGs(sViewType);
	TRACEARGn(lViewOptions);

	sViewType = _T("{668E5408-8E05-11D2-8ADA-0000F87A3912}");
	lViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

	return S_OK;
}

HRESULT CSplitPaneResultsView::OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem)
{
	TRACEX(_T("CSplitPaneResultsView::OnShow\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelecting);
	TRACEARGn(hScopeItem);

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;

	// set the description bar text
	LPRESULTDATA pIResultData = pHMRP->GetResultDataPtr();

	if( pIResultData )
	{
		CString sDescription;
		sDescription.LoadString(IDS_STRING_HEALTHMON_RESULTSPANE);
		pIResultData->SetDescBarText((LPTSTR)(LPCTSTR)sDescription);

		pIResultData->Release();
	}

	HRESULT hr = S_OK;

	_DHMListView* pUpperList = NULL;

	// get upper list control
	pUpperList = pHMRP->GetUpperListCtrl();
	if( ! pUpperList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetUpperListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	_DHMListView* pLowerList = NULL;

	// get lower list control
	pLowerList = pHMRP->GetLowerListCtrl();
	if( ! pLowerList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetLowerListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	_DHMListView* pStatsList = NULL;

	// get stats list control
	pStatsList = pHMRP->GetStatsListCtrl();
	if( ! pLowerList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetLowerListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		delete m_ResultItems[i];
	}
	m_ResultItems.RemoveAll();

	pUpperList->DeleteAllItems();
	pLowerList->DeleteAllItems();
	pStatsList->DeleteAllItems();

	CScopePaneItem* pOwnerScopeItem = GetOwnerScopeItem();
	if( ! pOwnerScopeItem || ! GfxCheckObjPtr(pOwnerScopeItem,CHMScopeItem) )
	{
		TRACE(_T("FAILED : CResultsPaneView::GetOwnerScopeItem returns NULL pointer.\n"));
		return E_FAIL;
	}

	CHMObject* pObject = ((CHMScopeItem*)(pOwnerScopeItem))->GetObjectPtr();
	if( ! pObject )
	{
		return E_FAIL;
	}

  if( bSelecting )
  {
		CString sText;
		sText.Format(IDS_STRING_CHILDREN_OF_FORMAT,pOwnerScopeItem->GetDisplayName());
		pUpperList->SetTitle(sText);


        // v-marfin 62935 : Show "OK" Instead of "Reset" in the upper pane only
        CString sOK;
        sOK.LoadString(IDS_STRING_OK);
        CString sReset;
        sReset.LoadString(IDS_STRING_RESET);



		// add the children of the selected scope item to the upper pane
		for( int i = 0; i < pOwnerScopeItem->GetChildCount(); i++ )
		{
			CScopePaneItem* pChildScopeItem = pOwnerScopeItem->GetChild(i);
			CHMResultsPaneItem* pItem = new CHMResultsPaneItem;
			CStringArray saNames;
			saNames.Copy(pChildScopeItem->GetDisplayNames());

            // v-marfin 62935 : Show "OK" Instead of "Reset" in the upper pane only
            if (saNames.GetSize() > 1)
            {
                CString sTest = saNames.GetAt(1);
                if (saNames.GetAt(1)==sReset)
                {   
                    saNames.SetAt(1,sOK);
                }
            }

			CUIntArray iaIconIds;
			iaIconIds.Copy(pChildScopeItem->GetIconIds());
			if( ! pItem->Create(this,saNames,iaIconIds,pChildScopeItem->GetIconIndex()) )
			{
				TRACE(_T("FAILED : CHMResultsPaneItem::Create failed.\n"));
				return false;
			}
			pItem->SetToUpperPane();
			m_ResultItems.Add(pItem);			
		}

		sText.Format(IDS_STRING_COUNT_OF_FORMAT,pOwnerScopeItem->GetChildCount());
		pUpperList->SetDescription(sText);

		hr = AddEvents(pHMRP);

		if( ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CResultsPaneView::OnShow failed.\n"));
		}

		hr = CResultsPaneView::OnShow(pPane,bSelecting,hScopeItem);

		if( ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CResultsPaneView::OnShow failed.\n"));
		}

		hr = AddStatistics(pHMRP);

		if( ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CResultsPaneView::OnShow failed.\n"));
		}
		
		USES_CONVERSION;		
		CString sOrder = AfxGetApp()->GetProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("UpperColumnOrder"));
		if( ! sOrder.IsEmpty() && sOrder != pUpperList->GetColumnOrder() )
		{
			pUpperList->SetColumnOrder(sOrder);
		}

		sOrder = AfxGetApp()->GetProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("LowerColumnOrder"));
		if( ! sOrder.IsEmpty() && sOrder != pLowerList->GetColumnOrder() )
		{
			pLowerList->SetColumnOrder(sOrder);
		}

	}
  else
  {
		hr = CResultsPaneView::OnShow(pPane,bSelecting,hScopeItem);

		int iUpperColCount = 0;
		int iLowerColCount = 0;

    for( int i=0; i < GetColumnCount(); i++ )
    {
			CHMListViewColumn* pColumn = (CHMListViewColumn*)GetColumn(i);
			if( pColumn )
			{
				if( pColumn->IsUpperPane() )
				{
					pColumn->SaveWidth(pPane,iUpperColCount++);
				}

				if( pColumn->IsLowerPane() )
				{
					pColumn->SaveWidth(pPane,iLowerColCount++);
				}
			}
    }

		USES_CONVERSION;
		CString sOrder = pUpperList->GetColumnOrder();
		AfxGetApp()->WriteProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("UpperColumnOrder"),sOrder);
		sOrder.Empty();

		sOrder = pLowerList->GetColumnOrder();
		AfxGetApp()->WriteProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("LowerColumnOrder"),sOrder);
		sOrder.Empty();

		for( i = 0; i < GetColumnCount(); i++ )
		{
			CHMListViewColumn* pColumn = (CHMListViewColumn*)GetColumn(i);
			if( pColumn->IsUpperPane() )
			{
				pUpperList->DeleteColumn(0);
			}

			if( pColumn->IsLowerPane() )
			{
				pLowerList->DeleteColumn(0);
			}

			if( pColumn->IsStatsPane() )
			{
				pStatsList->DeleteColumn(0);
			}
		}

		// clean up lower list control
		pLowerList->DeleteAllItems();

		// clean up stats list control
		pStatsList->DeleteAllItems();
		
		RemoveStatistics(pHMRP);
  }

  return S_OK;
}

void CSplitPaneResultsView::AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph /*=true*/)
{
	TRACEX(_T("CSplitPaneResultsView::AddStatistic\n"));
	TRACEARGn(pContainer);
	TRACEARGn(pStatistic);

	// insert item at top of stats list for this statistic

	AddItem(pStatistic->CreateResultsPaneItem(this));

  if( bUpdateGraph )
  {
	  CHMScopeItem* pHMItem = (CHMScopeItem*)GetOwnerScopeItem();

	  if( ! GfxCheckObjPtr(pHMItem,CHMScopeItem) )
	  {
		  TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		  return;
	  }

	  CHMObject* pObject = pHMItem->GetObjectPtr();
	  if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	  {
		  return;
	  }

	  for( int i = 0; i < GetResultsPanesCount(); i++ )
	  {
		  CHealthmonResultsPane* pPane = (CHealthmonResultsPane*)GetResultsPane(i);
		  if( pPane )
		  {
			  _DHMGraphView* pGraphView  = pPane->GetGraphViewCtrl();
	      if( pGraphView )
	      {
		      pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		      long lCurrentStyle = pGraphView->GetStyle();

		      pGraphView->Clear();

		      if( lCurrentStyle & HMGVS_CURRENT )
		      {
			      pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_GROUP);
		      }

		      if( lCurrentStyle & HMGVS_HISTORIC )
		      {
			      pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_GROUP);
		      }

		      pGraphView->SetName(pObject->GetName());
	      }


	      CEventContainer* pContainer = NULL;
	      EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	      if( pContainer )
	      {
		      for(int i = 0; i < pContainer->GetStatisticsCount(); i++ )
		      {
            if( i > pContainer->GetStatisticsCount()-10 )
            {
			        CStatistics* pStat = pContainer->GetStatistic(i);
			        if( pStat )
			        {
				        pStat->UpdateGraph(pGraphView);
			        }
            }
		      }
	      }
		  }
	  }
  }
}

inline HRESULT CSplitPaneResultsView::AddEvents(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CSplitPaneResultsView::AddEvents\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CString sText;
	sText.Format(IDS_STRING_EVENTS_OF_FORMAT,pSPI->GetDisplayName());
	pPane->GetLowerListCtrl()->SetTitle(sText);

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
		for(int i = 0; i < pContainer->GetEventCount(); i++ )
		{
			CEvent* pEvent = pContainer->GetEvent(i);
			if( pEvent )
			{
				CHMEventResultsPaneItem* pEventItem = pEvent->CreateResultsPaneItem(this);
				m_ResultItems.Add(pEventItem);
			}
		}
	}

	sText.Format(IDS_STRING_COUNT_OF_FORMAT,pContainer->GetEventCount());
	pPane->GetLowerListCtrl()->SetDescription(sText);


	return S_OK;
}

inline HRESULT CSplitPaneResultsView::AddStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CSplitPaneResultsView::AddStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CString sText;
	sText.Format(IDS_STRING_STATISTICS_FOR,pSPI->GetDisplayName());
	pPane->GetStatsListCtrl()->SetTitle(sText);

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	_DHMGraphView* pGraphView = pPane->GetGraphViewCtrl();
	if( pGraphView )
	{
		pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		long lCurrentStyle = pGraphView->GetStyle();

		pGraphView->Clear();

		if( lCurrentStyle & HMGVS_CURRENT )
		{
			pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_GROUP);
		}

		if( lCurrentStyle & HMGVS_HISTORIC )
		{
			pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_GROUP);
		}

		pGraphView->SetName(pObject->GetName());
	}


	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
		for(int i = 0; i < pContainer->GetStatisticsCount(); i++ )
		{
      if( i > pContainer->GetStatisticsCount()-10 )
      {
			  CStatistics* pStat = pContainer->GetStatistic(i);
			  if( pStat )
			  {
				  AddStatistic(pContainer,pStat,i==pContainer->GetStatisticsCount()-1);
			  }
      }
		}
	}

	sText.Format(IDS_STRING_COUNT_OF_FORMAT,pContainer->GetStatisticsCount());
	pPane->GetStatsListCtrl()->SetDescription(sText);

	return S_OK;
}

inline HRESULT CSplitPaneResultsView::RemoveStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CSplitPaneResultsView::RemoveStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	pPane->GetGraphViewSink()->SetResultsViewPtr(NULL);

	if(pPane->GetGraphViewCtrl())
	{
		pPane->GetGraphViewCtrl()->Clear();
	}

	CString sWaiting;
	sWaiting.LoadString(IDS_STRING_WAITING);
	pPane->GetStatsListCtrl()->SetTitle(sWaiting);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// GraphView Events Members
//////////////////////////////////////////////////////////////////////

void CSplitPaneResultsView::OnGraphViewStyleChange(_DHMGraphView* pGraphView)
{
	if( ! pGraphView )
	{
		ASSERT(FALSE);
		return;
	}

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return;
	}

	pGraphView->SetName(pObject->GetName());

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
		for(int i = 0; i < pContainer->GetStatisticsCount(); i++ )
		{
      if( i > pContainer->GetStatisticsCount()-10 )
      {
			  CStatistics* pStat = pContainer->GetStatistic(i);
			  if( pStat )
			  {
				  AddStatistic(pContainer,pStat);
			  }
      }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapindataobject.cpp ===
// SnapinDataObject.cpp : implementation file
//

#include "stdafx.h"
#include "ScopePaneItem.h"
#include "ResultsPaneItem.h"
#include "SnapinDataObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSnapinDataObject

UINT CSnapinDataObject::s_cfInternal = 0;
UINT CSnapinDataObject::s_cfExtension = 0;

// *CLEAN ME*
LPCTSTR CF_SNAPIN_INTERNAL = _T("HealthMonitor");
LPCTSTR CF_SNAPIN_EXTENSION = _T("HealthMonitorExtension");

// *CLEAN ME*
// {FBBB8DAE-AB34-11d2-BD62-0000F87A3912}
static const GUID CLSID_SnapIn = 
{	0xfbbb8dae, 0xab34, 0x11d2, { 0xbd, 0x62, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };
//{ 0x69a539f8, 0x9520, 0x11d2, { 0xbd, 0x4a, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };


IMPLEMENT_DYNCREATE(CSnapinDataObject, CCmdTarget)

CSnapinDataObject::CSnapinDataObject()
{
	TRACEX(_T("CSnapinDataObject::CSnapinDataObject\n"));

	EnableAutomation();

	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	if( ! RegisterClipboardFormats() )
	{
		TRACE(_T("FAILED : RegisterClipboardFormats failed.\n"));
		ASSERT(FALSE);
	}

	m_ulCookie = 0;
  m_ItemType  = CCT_UNINITIALIZED;
}

CSnapinDataObject::~CSnapinDataObject()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Clipboard Members

inline bool CSnapinDataObject::RegisterClipboardFormats()
{
	if( ! s_cfInternal )
		s_cfInternal    = RegisterClipboardFormat(CF_SNAPIN_INTERNAL);
	if( ! s_cfExtension )
		s_cfExtension   = RegisterClipboardFormat(CF_SNAPIN_EXTENSION);
  m_cfDisplayName = RegisterClipboardFormat(CCF_DISPLAY_NAME);
  m_cfSPIGuid			= RegisterClipboardFormat(CCF_NODETYPE);
  m_cfSnapinCLSID = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

	return s_cfInternal && s_cfExtension && m_cfDisplayName && m_cfSPIGuid && m_cfSnapinCLSID;
}

/////////////////////////////////////////////////////////////////////////////
// Item Members

DATA_OBJECT_TYPES CSnapinDataObject::GetItemType()
{
	TRACEX(_T("CSnapinDataObject::GetItemType\n"));
	TRACEARGn(m_ItemType);

	return m_ItemType;
}

ULONG CSnapinDataObject::GetCookie()
{
	TRACEX(_T("CSnapinDataObject::GetCookie\n"));
	TRACEARGn(m_ulCookie);

	return m_ulCookie;
}

bool CSnapinDataObject::GetItem(CScopePaneItem*& pSPItem)
{
	TRACEX(_T("CSnapinDataObject::GetItem(SPI)\n"));

	if( GetItemType() != CCT_SCOPE )
	{
		TRACE(_T("WARNING : Item is not of type CCT_SCOPE.\n"));
		pSPItem = NULL;
		return false;
	}

	pSPItem = (CScopePaneItem*)GetCookie();

	if( ! CHECKOBJPTR(pSPItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		TRACE(_T("FAILED : The cookie is invalid or corrupt.\n"));
		pSPItem = NULL;
		return false;
	}

	return true;
}

bool CSnapinDataObject::GetItem(CResultsPaneItem*& pRPItem)
{
	TRACEX(_T("CSnapinDataObject::GetItem(RPI)\n"));

	if( GetItemType() != CCT_RESULT )
	{
		TRACE(_T("WARNING : Item is not of type CCT_RESULT.\n"));
		pRPItem = NULL;
		return false;
	}

	pRPItem = (CResultsPaneItem*)GetCookie();

	if( ! CHECKOBJPTR(pRPItem,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
	{
		TRACE(_T("FAILED : The cookie is invalid or corrupt.\n"));
		pRPItem = NULL;
		return false;
	}

	return true;
}

void CSnapinDataObject::SetItem(CScopePaneItem* pSPItem)
{
	TRACEX(_T("CSnapinDataObject::SetItem(SPI)\n"));
	TRACEARGn(pSPItem);

	if( ! CHECKOBJPTR(pSPItem,RUNTIME_CLASS(CScopePaneItem),sizeof(CScopePaneItem)) )
	{
		TRACE(_T("FAILED : pSPItem is an invalid CScopePaneItem pointer.\n"));
		m_ulCookie = NULL;
		m_ItemType = CCT_UNINITIALIZED;
		return;
	}

#ifndef IA64
	m_ulCookie = (ULONG)pSPItem;
#endif // IA64

	m_ItemType = CCT_SCOPE;
}

void CSnapinDataObject::SetItem(CResultsPaneItem* pRPItem)
{
	TRACEX(_T("CSnapinDataObject::SetItem(RPI)\n"));
	TRACEARGn(pRPItem);

	if( ! CHECKOBJPTR(pRPItem,RUNTIME_CLASS(CResultsPaneItem),sizeof(CResultsPaneItem)) )
	{
		TRACE(_T("FAILED : pRPItem is an invalid CResultsPaneItem pointer.\n"));
		m_ulCookie = NULL;
		m_ItemType = CCT_UNINITIALIZED;
		return;
	}

#ifndef IA64
	m_ulCookie = (ULONG)pRPItem;
#endif // IA64 

	m_ItemType = CCT_RESULT;
}


/////////////////////////////////////////////////////////////////////////////
// DataObject Members

CSnapinDataObject* CSnapinDataObject::GetSnapinDataObject(LPDATAOBJECT lpDataObject)
{
	TRACEX(_T("CSnapinDataObject::GetSnapinDataObject\n"));
	TRACEARGn(lpDataObject);

	if( ! CHECKPTR(lpDataObject,sizeof(IDataObject)) )
	{
		TRACE(_T("FAILED : lpDataObject pointer is invalid!\n"));
		return NULL;
	}

  HGLOBAL hGlobal = NULL;
  CSnapinDataObject* psdo = NULL;

  HRESULT hr = GetDataObject( lpDataObject, CSnapinDataObject::s_cfInternal, sizeof(CSnapinDataObject**), &hGlobal );

  if( hr == DV_E_FORMATETC || ! CHECKHRESULT(hr) )
  {
		return NULL;
  }

  psdo = *((CSnapinDataObject**)(hGlobal));

	if( ! CHECKOBJPTR(psdo,RUNTIME_CLASS(CSnapinDataObject),sizeof(CSnapinDataObject)) )
	{
		return NULL;
	}

  GlobalFree(hGlobal);

  return psdo;
}

HRESULT CSnapinDataObject::GetDataObject(LPDATAOBJECT lpDataObject, UINT cfClipFormat, ULONG nByteCount, HGLOBAL* phGlobal)
{
	TRACEX(_T("CSnapinDataObject::GetDataObject\n"));
	TRACEARGn(lpDataObject);
	TRACEARGn(cfClipFormat);
	TRACEARGn(nByteCount);
	TRACEARGn(phGlobal);

	if( ! CHECKPTR(lpDataObject,sizeof(IDataObject)) )
	{
		TRACE(_T("FAILED : lpDataObject is invalid.\n"));
		return E_FAIL;
	}

  HRESULT hr = S_OK;
  STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
  FORMATETC formatetc = { (unsigned short)cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

  *phGlobal = NULL;

  // Allocate memory for the stream
  stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, nByteCount );

	if( ! stgmedium.hGlobal )
  {
    hr = E_OUTOFMEMORY;
    TRACE(_T("FAILED : Out of Memory.\n"));
		return hr;
  }

  // Attempt to get data from the object
  hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
  if( hr == DV_E_FORMATETC || ! CHECKHRESULT(hr) )
  {
		TRACE(_T("lpDataObject->GetDataFromHere failed.\n"));
		GlobalFree(stgmedium.hGlobal);
		stgmedium.hGlobal = NULL;
		return hr;
  }

  // stgmedium now has the data we need 
  *phGlobal = stgmedium.hGlobal;
  stgmedium.hGlobal = NULL;

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Write Members

HRESULT CSnapinDataObject::WriteGuid(LPSTREAM pStream)
{
	TRACEX(_T("CSnapinDataObject::WriteGuid\n"));
	TRACEARGn(pStream);

	if( ! CHECKPTR(pStream,sizeof(IStream)) )
	{
		TRACE(_T("FAILED : Invalid IStream pointer passed.\n"));
		return E_FAIL;
	}

	LPGUID pGuid = NULL;

	if( GetItemType() == CCT_SCOPE )
	{
		CScopePaneItem* pItem = NULL;
		if( ! GetItem(pItem) )
		{
			return S_OK;
		}

		ASSERT(pItem);

		pGuid = pItem->GetItemType();
	}
	else if( GetItemType() == CCT_RESULT )
	{
		CResultsPaneItem* pItem = NULL;
		if( ! GetItem(pItem) )
		{
			return S_OK;
		}

		ASSERT(pItem);

		pGuid = pItem->GetItemType();

		if( ! pGuid )
		{
			return S_OK;
		}
	}

	if( pGuid == NULL )
	{
		TRACE(_T("FAILED : CScopePaneItem::GetItemType returns NULL.\n"));
		return E_FAIL;
	}

  return pStream->Write( (LPVOID)pGuid, sizeof(GUID), NULL );
}

HRESULT CSnapinDataObject::WriteDisplayName(LPSTREAM pStream)
{
	TRACEX(_T("CSnapinDataObject::WriteDisplayName\n"));
	TRACEARGn(pStream);

	if( ! CHECKPTR(pStream,sizeof(IStream)) )
	{
		TRACE(_T("FAILED : Invalid IStream pointer passed.\n"));
		return E_FAIL;
	}

	CString sDisplayName;

	switch(GetItemType())
	{
		case CCT_SCOPE:
		{
			CScopePaneItem* pItem = NULL;

			if( ! GetItem(pItem) )
			{
				TRACE(_T("FAILED : GetItem failed.\n"));
				return E_FAIL;
			}

			ASSERT(pItem);

			sDisplayName = pItem->GetDisplayName();
		}
		break;

		case CCT_RESULT:
		{
			CResultsPaneItem* pItem = NULL;

			if( ! GetItem(pItem) )
			{
				TRACE(_T("FAILED : GetItem failed.\n"));
				return E_FAIL;
			}

			ASSERT(pItem);

			sDisplayName = pItem->GetDisplayName();
		}
		break;
	}

	ULONG ulSizeofName = sDisplayName.GetLength() + 1;
	ulSizeofName *= sizeof(TCHAR);

	return pStream->Write(sDisplayName, ulSizeofName, NULL);
}

HRESULT CSnapinDataObject::WriteSnapinCLSID(LPSTREAM pStream)
{
	TRACEX(_T("CSnapinDataObject::WriteSnapinCLSID\n"));
	TRACEARGn(pStream);

	if( ! CHECKPTR(pStream,sizeof(IStream)) )
	{
		TRACE(_T("FAILED : Invalid IStream pointer passed.\n"));
		return E_FAIL;
	}

	return pStream->Write(&CLSID_SnapIn,sizeof(CLSID_SnapIn),NULL);
}

HRESULT CSnapinDataObject::WriteDataObject(LPSTREAM pStream)
{
	TRACEX(_T("CSnapinDataObject::WriteDataObject\n"));
	TRACEARGn(pStream);

	if( ! CHECKPTR(pStream,sizeof(IStream)) )
	{
		TRACE(_T("FAILED : Invalid IStream pointer passed.\n"));
		return E_FAIL;
	}

	CSnapinDataObject* pThis = this;
	return pStream->Write(&pThis,sizeof(CSnapinDataObject*),NULL);
}

HRESULT CSnapinDataObject::WriteExtensionData(LPSTREAM pStream)
{
	TRACEX(_T("CSnapinDataObject::WriteExtensionData\n"));
	TRACEARGn(pStream);

	if( ! CHECKPTR(pStream,sizeof(IStream)) )
	{
		TRACE(_T("FAILED : Invalid IStream pointer passed.\n"));
		return E_FAIL;
	}

	switch(GetItemType())
	{
		case CCT_SCOPE:
		{
			CScopePaneItem* pItem = NULL;

			if( ! GetItem(pItem) )
			{
				TRACE(_T("FAILED : GetItem failed.\n"));
				return E_FAIL;
			}

			ASSERT(pItem);

			return pItem->WriteExtensionData(pStream);
		}
		break;

		case CCT_RESULT:
		{
			CResultsPaneItem* pItem = NULL;

			if( ! GetItem(pItem) )
			{
				TRACE(_T("FAILED : GetItem failed.\n"));
				return E_FAIL;
			}

			ASSERT(pItem);

			return pItem->WriteExtensionData(pStream);
		}
		break;
	}

	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// MFC Implementation Members

void CSnapinDataObject::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CSnapinDataObject, CCmdTarget)
	//{{AFX_MSG_MAP(CSnapinDataObject)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSnapinDataObject, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CSnapinDataObject)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISnapinDataObject to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7D4A685E-9056-11D2-BD45-0000F87A3912}
static const IID IID_ISnapinDataObject =
{ 0x7d4a685e, 0x9056, 0x11d2, { 0xbd, 0x45, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CSnapinDataObject, CCmdTarget)
	INTERFACE_PART(CSnapinDataObject, IID_ISnapinDataObject, Dispatch)
	INTERFACE_PART(CSnapinDataObject, IID_IDataObject, DataObject)
END_INTERFACE_MAP()

// {01CB0090-AFCB-11d2-BD6B-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CSnapinDataObject, "SnapIn.SnapinDataObject", 
0x1cb0090, 0xafcb, 0x11d2, 0xbd, 0x6b, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12);

BOOL CSnapinDataObject::CSnapinDataObjectFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject Interface Part

ULONG FAR EXPORT CSnapinDataObject::XDataObject::AddRef()
{
	METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CSnapinDataObject::XDataObject::Release()
{
	METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CSnapinDataObject::XDataObject::QueryInterface(REFIID iid, void FAR* FAR* ppvObj)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
  return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CSnapinDataObject::XDataObject::GetData( 
/* [unique][in] */ FORMATETC __RPC_FAR *pformatetcIn,
/* [out] */ STGMEDIUM __RPC_FAR *pmedium)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)	
	TRACEX(_T("CSnapinDataObject::XDataObject::GetData"));
	TRACEARGn(pformatetcIn);
	TRACEARGn(pmedium);

  HRESULT hr = S_OK;

  // Make sure FORMATETC is something we can handle.
  if( !(DVASPECT_CONTENT & pformatetcIn->dwAspect) || 
      !(TYMED_HGLOBAL    & pformatetcIn->tymed) )
	{
    hr = DATA_E_FORMATETC;
	}
  
  if( S_OK == hr )
  {
    if( s_cfExtension == pformatetcIn->cfFormat )       
		{
			IStream *pStream = NULL;
			// Allocate memory for the stream
			pmedium->hGlobal = GlobalAlloc( GMEM_SHARE, 1024 );

			if( ! pmedium->hGlobal )
			{
				hr = E_OUTOFMEMORY;
				TRACE(_T("FAILED : Out of Memory.\n"));
				return hr;
			}
			hr = CreateStreamOnHGlobal( pmedium->hGlobal, FALSE, &pStream );
      hr = pThis->WriteExtensionData( pStream );
			pStream->Release();
		}
    else 
		{
      hr = DATA_E_FORMATETC;
		}
  }

  return hr;
}


HRESULT FAR EXPORT CSnapinDataObject::XDataObject::GetDataHere( 
/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
/* [out][in] */ STGMEDIUM __RPC_FAR *pmedium)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::GetDataHere"));
	TRACEARGn(pformatetc);
	TRACEARGn(pmedium);

  HRESULT hr = DV_E_FORMATETC;         // Unknown format
  const   CLIPFORMAT cf = pformatetc->cfFormat;
  IStream *pStream = NULL;

  pmedium->pUnkForRelease = NULL;      // by OLE spec

  // Write data to the stream based
  // on the clipformat
  hr = CreateStreamOnHGlobal( pmedium->hGlobal, FALSE, &pStream );
  if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : Failed on call to CreateStreamOnHGlobal.\n"));
    return hr;                       // Minimal error checking
	}

  if( pThis->m_cfDisplayName == cf )
  {
    hr = pThis->WriteDisplayName( pStream );
  }
  else if( pThis->s_cfInternal == cf )
  {
    hr = pThis->WriteDataObject( pStream );
  }
  else if( pThis->s_cfExtension == cf )
  {
    hr = pThis->WriteExtensionData( pStream );
  }
  else if( pThis->m_cfSPIGuid == cf )
  {
    hr = pThis->WriteGuid( pStream );
  }
  else if( pThis->m_cfSnapinCLSID == cf )
  {
    hr = pThis->WriteSnapinCLSID( pStream );
  }

  pStream->Release();

  return hr;
}

HRESULT FAR EXPORT CSnapinDataObject::XDataObject::QueryGetData( 
/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::QueryGetData"));
	TRACEARGn(pformatetc);

  HRESULT hr = S_OK;

  // For this sample, we just do a simple test.
  if( s_cfExtension == pformatetc->cfFormat )
    hr = S_OK;
  else
    hr = S_FALSE;
  
  return hr;
}

HRESULT FAR EXPORT CSnapinDataObject::XDataObject::GetCanonicalFormatEtc( 
/* [unique][in] */ FORMATETC __RPC_FAR *pformatectIn,
/* [out] */ FORMATETC __RPC_FAR *pformatetcOut)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::GetCanonicalFormatEtc"));
	TRACEARGn(pformatectIn);
	TRACEARGn(pformatetcOut);

  return E_NOTIMPL;
}

HRESULT FAR EXPORT CSnapinDataObject::XDataObject::SetData( 
/* [unique][in] */ FORMATETC __RPC_FAR *pformatetc,
/* [unique][in] */ STGMEDIUM __RPC_FAR *pmedium,
/* [in] */ BOOL fRelease)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::SetData"));
	TRACEARGn(pformatetc);
	TRACEARGn(pmedium);
	TRACEARGn(fRelease);

  return E_NOTIMPL;
}


HRESULT FAR EXPORT CSnapinDataObject::XDataObject::EnumFormatEtc( 
/* [in] */ DWORD dwDirection,
/* [out] */ IEnumFORMATETC __RPC_FAR *__RPC_FAR *ppenumFormatEtc)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::EnumFormatEtc"));
	TRACEARGn(dwDirection);
	TRACEARGn(ppenumFormatEtc);

  HRESULT hr = S_OK;
  static FORMATETC ForEtcArr[1];       // Use array so we can add more later

  ForEtcArr[0].cfFormat = (CLIPFORMAT)s_cfExtension;
	ForEtcArr[0].dwAspect = DVASPECT_CONTENT;
	ForEtcArr[0].ptd      = NULL;
	ForEtcArr[0].tymed    = TYMED_HGLOBAL;
	ForEtcArr[0].lindex   = -1;

	switch( dwDirection )
	{
		case DATADIR_GET:
		  *ppenumFormatEtc = new CEnumFormatEtc(1, ForEtcArr);
			break;

    case DATADIR_SET:
    default:
      *ppenumFormatEtc = NULL;
		  break;
	}

	if( NULL == *ppenumFormatEtc )
	{
		hr = E_FAIL;
	}
	else
	{
		(*ppenumFormatEtc)->AddRef();
    hr = S_OK;
	}

  return hr;
}


HRESULT FAR EXPORT CSnapinDataObject::XDataObject::DAdvise( 
/* [in] */ FORMATETC __RPC_FAR *pformatetc,
/* [in] */ DWORD advf,
/* [unique][in] */ IAdviseSink __RPC_FAR *pAdvSink,
/* [out] */ DWORD __RPC_FAR *pdwConnection)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::DAdvise"));
	TRACEARGn(pformatetc);
	TRACEARGn(advf);
	TRACEARGn(pAdvSink);
	TRACEARGn(pdwConnection);

  return E_NOTIMPL;
}


HRESULT FAR EXPORT CSnapinDataObject::XDataObject::DUnadvise( 
/* [in] */ DWORD dwConnection)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::DUnadvise"));
	TRACEARGn(dwConnection);

  return E_NOTIMPL;
}


HRESULT FAR EXPORT CSnapinDataObject::XDataObject::EnumDAdvise( 
/* [out] */ IEnumSTATDATA __RPC_FAR *__RPC_FAR *ppenumAdvise)
{
  METHOD_PROLOGUE(CSnapinDataObject, DataObject)
	TRACEX(_T("CSnapinDataObject::XDataObject::EnumDAdvise"));
	TRACEARGn(ppenumAdvise);

  return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSnapinDataObject message handlers


/////////////////////////////////////////////////////////////////////////////
// CEnumFormatEtc Implementation

/*
 * CEnumFormatEtc::CEnumFormatEtc
 * CEnumFormatEtc::~CEnumFormatEtc
 *
 * Parameters (Constructor):
 *  cFE             ULONG number of FORMATETCs in pFE
 *  prgFE           LPFORMATETC to the array to enumerate.
 */

CEnumFormatEtc::CEnumFormatEtc(ULONG cFE, LPFORMATETC prgFE)
{
	UINT i;

	m_cRef=0;
	m_iCur=0;
	m_cfe=cFE;
	m_prgfe=new FORMATETC[(UINT)cFE];

	if (NULL!=m_prgfe)
	{
		for (i=0; i < cFE; i++)
			m_prgfe[i]=prgFE[i];
	}

	return;
}


CEnumFormatEtc::~CEnumFormatEtc(void)
{
	if (NULL!=m_prgfe)
		delete [] m_prgfe;
}

/*
 * CEnumFormatEtc::QueryInterface
 * CEnumFormatEtc::AddRef
 * CEnumFormatEtc::Release
 *
 * Purpose:
 *  IUnknown members for CEnumFormatEtc object.  For QueryInterface
 *  we only return out own interfaces and not those of the data
 *  object.  However, since enumerating formats only makes sense
 *  when the data object is around, we insure that it stays as
 *  long as we stay by calling an outer IUnknown for AddRef
 *  and Release.  But since we are not controlled by the lifetime
 *  of the outer object, we still keep our own reference count in
 *  order to free ourselves.
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, VOID ** ppv)
{
	*ppv=NULL;

	/*
	* Enumerators are separate objects, not the data object, so
	* we only need to support out IUnknown and IEnumFORMATETC
	* interfaces here with no concern for aggregation.
	*/
	if (IID_IUnknown==riid || IID_IEnumFORMATETC==riid)
		*ppv=this;

	//AddRef any interface we'll return.
	if (NULL!=*ppv)
	{
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}

	return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef(void)
{
	++m_cRef;
	return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release(void)
{
	if (0!=--m_cRef)
		return m_cRef;

	delete this;
	return 0;
}

/*
* CEnumFormatEtc::Next
*
* Purpose:
*  Returns the next element in the enumeration.
*
* Parameters:
*  cFE             ULONG number of FORMATETCs to return.
*  pFE             LPFORMATETC in which to store the returned
*                  structures.
*  pulFE           ULONG * in which to return how many we
*                  enumerated.
*
* Return Value:
*  HRESULT         NOERROR if successful, S_FALSE otherwise,
*/

STDMETHODIMP CEnumFormatEtc::Next(ULONG cFE, LPFORMATETC pFE, ULONG *pulFE)
{
	ULONG               cReturn=0L;

	if (NULL==m_prgfe)
		return ResultFromScode(S_FALSE);

	if (NULL==pulFE)
	{
		if (1L!=cFE)
			return ResultFromScode(E_POINTER);
	}
	else
		*pulFE=0L;

	if (NULL==pFE || m_iCur >= m_cfe)
		return ResultFromScode(S_FALSE);

	while (m_iCur < m_cfe && cFE > 0)
	{
		*pFE++=m_prgfe[m_iCur++];
		cReturn++;
		cFE--;
	}

	if (NULL!=pulFE)
		*pulFE=cReturn;

	return NOERROR;
}

/*
* CEnumFormatEtc::Skip
*
* Purpose:
*  Skips the next n elements in the enumeration.
*
* Parameters:
*  cSkip           ULONG number of elements to skip.
*
* Return Value:
*  HRESULT         NOERROR if successful, S_FALSE if we could not
*                  skip the requested number.
*/

STDMETHODIMP CEnumFormatEtc::Skip(ULONG cSkip)
{
	if (((m_iCur+cSkip) >= m_cfe) || NULL==m_prgfe)
		return ResultFromScode(S_FALSE);

	m_iCur+=cSkip;
	return NOERROR;
}

/*
* CEnumFormatEtc::Reset
*
* Purpose:
*  Resets the current element index in the enumeration to zero.
*
* Parameters:
*  None
*
* Return Value:
*  HRESULT         NOERROR
*/

STDMETHODIMP CEnumFormatEtc::Reset(void)
{
	m_iCur=0;
	return NOERROR;
}

/*
* CEnumFormatEtc::Clone
*
* Purpose:
*  Returns another IEnumFORMATETC with the same state as ourselves.
*
* Parameters:
*  ppEnum          LPENUMFORMATETC * in which to return the
*                  new object.
*
* Return Value:
*  HRESULT         NOERROR or a general error value.
*/

STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC *ppEnum)
{
	PCEnumFormatEtc     pNew;

	*ppEnum=NULL;

	//Create the clone
	pNew=new CEnumFormatEtc(m_cfe, m_prgfe);

	if (NULL==pNew)
		return ResultFromScode(E_OUTOFMEMORY);

	pNew->AddRef();
	pNew->m_iCur=m_iCur;

	*ppEnum=pNew;
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\sortclass.cpp ===
// SortClass.cpp: implementation of the CSortClass class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SortClass.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSortClass::CSortClass(CListCtrl * _pWnd, const int _iCol)
{	
	m_iCol = _iCol;	
	m_pWnd = _pWnd;	
	ASSERT(m_pWnd);
	int max = m_pWnd->GetItemCount();	
	DWORD dw;	
	CString txt;	
	for (int t = 0; t < max; t++)
	{
#ifndef IA64
		dw = m_pWnd->GetItemData(t);
		txt = m_pWnd->GetItemText(t, m_iCol);
		m_pWnd->SetItemData(t, (DWORD) new CSortItem(dw, txt));
#endif // IA64
	}
}

CSortClass::~CSortClass()
{	
	ASSERT(m_pWnd);
	int max = m_pWnd->GetItemCount();
	CSortItem * pItem;
	for (int t = 0; t < max; t++)
	{
		pItem = (CSortItem *) m_pWnd->GetItemData(t);
		ASSERT(pItem);
		m_pWnd->SetItemData(t, pItem->dw);
		delete pItem;
	}
}

void CSortClass::Sort(const bool bAsc)
{	
#ifndef IA64
	if (bAsc)	
	{
		m_pWnd->SortItems(CompareAsc, (DWORD)this);	
	}
	else
	{
		m_pWnd->SortItems(CompareDes, (DWORD)this);
	}
#endif // IA64
}

int CALLBACK CSortClass::CompareAsc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{	
	CSortItem * i1 = (CSortItem *) lParam1;
	CSortItem * i2 = (CSortItem *) lParam2;	
	ASSERT(i1 && i2);
	CSortClass* pSC = (CSortClass*)lParamSort;
	ASSERT(pSC);

	return i1->txt.CompareNoCase(i2->txt);
}

int CALLBACK CSortClass::CompareDes(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{	
	CSortItem * i1 = (CSortItem *) lParam1;
	CSortItem * i2 = (CSortItem *) lParam2;	
	ASSERT(i1 && i2);
	CSortClass* pSC = (CSortClass*)lParamSort;
	ASSERT(pSC);

	return i2->txt.CompareNoCase(i1->txt);
}

CSortClass::CSortItem::CSortItem(const DWORD _dw, const CString & _txt)
{
	dw = _dw;
	txt = _txt;
}

CSortClass::CSortItem::~CSortItem()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\snapindefines.h ===
#ifndef __SNAPINDEFINES_H__
#define __SNAPINDEFINES_H__

// File: SnapinDefines.h
//
// various snapin defines 
//
// Copyright (c) 2000 Microsoft Corporation
//
// v-marfin Bug 61451 
//
//

// AuthTypes for the HttpProvider class
#define AUTHTYPE_VALUE_NONE					0
//#define AUTHTYPE_VALUE_ANONYMOUS			1	
#define AUTHTYPE_VALUE_BASIC				2
#define AUTHTYPE_VALUE_NTLM					4
#define AUTHTYPE_VALUE_KERBEROS				8
#define AUTHTYPE_VALUE_DIGEST				16
#define AUTHTYPE_VALUE_NEGOTIATE			32

// In this particular case localization is not an issue.
// The names of auth. methods are part of the http protocol 
// and don't need to be localized.
#define AUTHTYPE_VALUE_NONE_STRING			_T("None")
#define AUTHTYPE_VALUE_BASIC_STRING			_T("Clear Text (Basic)")
#define AUTHTYPE_VALUE_NEGOTIATE_STRING		_T("Windows Default (Negotiate)")	
#define AUTHTYPE_VALUE_NTLM_STRING			_T("NTLM")
#define AUTHTYPE_VALUE_DIGEST_STRING		_T("Digest")	
#define AUTHTYPE_VALUE_KERBEROS_STRING		_T("Kerberos")
//#define AUTHTYPE_VALUE_ANONYMOUS_STRING		_T("Anonymous")	


#endif // __SNAPINDEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\sortclass.h ===
// SortClass.h: interface for the CSortClass class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_)
#define AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSortClass
{
public:
	CSortClass(CListCtrl * _pWnd, const int _iCol);
	virtual ~CSortClass();		
	
	int m_iCol;	
	int m_iStartingItem;
	int m_iEndingItem;

	CListCtrl * m_pWnd;	
	
	void Sort(const bool bAsc);	
	
	static int CALLBACK CompareAsc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
	static int CALLBACK CompareDes(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

public:	

	class CSortItem	
	{	
		public:		
			virtual  ~CSortItem();
			CSortItem(const DWORD _dw, const CString &_txt);		
			CString txt;		
			DWORD dw;
	};
};
#endif // !defined(AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\splitpaneresultsview.h ===
// SplitPaneResultsView.h: interface for the CSplitPaneResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SPLITPANERESULTSVIEW_H__C3035FC4_B0BE_11D2_BD6C_0000F87A3912__INCLUDED_)
#define AFX_SPLITPANERESULTSVIEW_H__C3035FC4_B0BE_11D2_BD6C_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ResultsPaneView.h"
#include "HMRuleStatus.h"

class CHealthmonResultsPane;
class CStatistics;
class _DHMGraphView;
class CEventContainer;

class CSplitPaneResultsView : public CResultsPaneView
{

DECLARE_DYNCREATE(CSplitPaneResultsView)

// Construction/Destruction
public:
	CSplitPaneResultsView();
	virtual ~CSplitPaneResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

// Results Pane Item Members
public:
	virtual void RemoveItem(int iIndex);

// MMC Notify Handlers
public:
	virtual HRESULT OnGetResultViewType(CString& sViewType,long& lViewOptions);
	virtual HRESULT OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem);

// Eventing and Statistics Members
public:
	virtual void AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph=true);
protected:
	HRESULT AddEvents(CHealthmonResultsPane* pPane);
	virtual HRESULT AddStatistics(CHealthmonResultsPane* pPane);
	virtual HRESULT RemoveStatistics(CHealthmonResultsPane* pPane);

// GraphView Events Members
public:
	virtual void OnGraphViewStyleChange(_DHMGraphView* pGraphView);
};

#endif // !defined(AFX_SPLITPANERESULTSVIEW_H__C3035FC4_B0BE_11D2_BD6C_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\splitter.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "splitter1.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// _DSplitter properties

/////////////////////////////////////////////////////////////////////////////
// _DSplitter operations

BOOL _DSplitter::CreateControl(long lRow, long lColumn, LPCTSTR lpszControlID)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_BSTR;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lRow, lColumn, lpszControlID);
	return result;
}

BOOL _DSplitter::GetControl(long lRow, long lColumn, long* phCtlWnd)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PI4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		lRow, lColumn, phCtlWnd);
	return result;
}

LPUNKNOWN _DSplitter::GetControlIUnknown(long lRow, long lColumn)
{
	LPUNKNOWN result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_UNKNOWN, (void*)&result, parms,
		lRow, lColumn);
	return result;
}

void _DSplitter::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// _DSplitterEvents properties

/////////////////////////////////////////////////////////////////////////////
// _DSplitterEvents operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\statistics.cpp ===
// Statistics.cpp: implementation of the CStatistics class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "Statistics.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CStatistics,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CStatistics::CStatistics()
{

}

CStatistics::~CStatistics()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SnapIn.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\statistics.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Time Members
//////////////////////////////////////////////////////////////////////

inline CString CStatistics::GetStatLocalTime()
{
	CString sTime;
	CString sDate;
	CString sDateTime;

	int iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetTimeFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sTime.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sTime.ReleaseBuffer();

	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,NULL,0);
	iLen = GetDateFormat(LOCALE_USER_DEFAULT,0L,&m_st,NULL,sDate.GetBuffer(iLen+(sizeof(TCHAR)*1)),iLen);
	sDate.ReleaseBuffer();

	sDateTime = sDate + _T("  ") + sTime;	

	return sDateTime;
}

//////////////////////////////////////////////////////////////////////
// Comparison
//////////////////////////////////////////////////////////////////////

inline int CStatistics::CompareTo(CStatistics* pStat)
{
	CTime time1 = m_st;
	CTime time2 = pStat->m_st;

	return time1 == time2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03-15-00 v-marfin  Bug 62069 : Added lib pragmas and #defines
//
//
//
//
//
#if !defined(AFX_STDAFX_H__7D4A6853_9056_11D2_BD45_0000F87A3912__INCLUDED_)
#define AFX_STDAFX_H__7D4A6853_9056_11D2_BD45_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// v-marfin : bug 62069 ----------------------------------------------
#pragma comment (lib, "mmc.lib")
#pragma comment (lib, "Netapi32.lib")
#pragma comment (lib, "version.lib")

#ifndef UNICODE
#define UNICODE
#endif // #ifndef UNICODE 

#ifndef _UNICODE
#define _UNICODE
#endif // #ifndef _UNICODE

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif // #ifndef _WIN32_WINNT

#ifndef WINNT
#define WINNT 0x0400 
#endif // #ifndef WINNT

// -------------------------------------------------------------------



#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxctl.h>					// MFC OLE control classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxtempl.h> // template class support
#include <atlconv.h> // atl string conversions et al

#include "Debug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7D4A6853_9056_11D2_BD45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\splitter1.h ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// _DSplitter wrapper class

class _DSplitter : public COleDispatchDriver
{
public:
	_DSplitter() {}		// Calls COleDispatchDriver default constructor
	_DSplitter(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DSplitter(const _DSplitter& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	BOOL CreateControl(long lRow, long lColumn, LPCTSTR lpszControlID);
	BOOL GetControl(long lRow, long lColumn, long* phCtlWnd);
	LPUNKNOWN GetControlIUnknown(long lRow, long lColumn);
	void AboutBox();
};
/////////////////////////////////////////////////////////////////////////////
// _DSplitterEvents wrapper class

class _DSplitterEvents : public COleDispatchDriver
{
public:
	_DSplitterEvents() {}		// Calls COleDispatchDriver default constructor
	_DSplitterEvents(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	_DSplitterEvents(const _DSplitterEvents& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\statistics.h ===
// Statistics.h: interface for the CStatistics class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STATISTICS_H__5D41A1E3_8CD9_11D3_93A4_00A0CC406605__INCLUDED_)
#define AFX_STATISTICS_H__5D41A1E3_8CD9_11D3_93A4_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMEventResultsPaneItem.h"
#include "HMGraphView.h"

class CStatistics : public CObject  
{

DECLARE_DYNCREATE(CStatistics)

// Construction/Destruction
public:
	CStatistics();
	virtual ~CStatistics();

// Time Members
public:
	CString GetStatLocalTime();
	SYSTEMTIME m_st;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView) { ASSERT(pView);ASSERT(FALSE); return NULL; }
	virtual void SetResultsPaneItem(CHMEventResultsPaneItem* pItem) { ASSERT(pItem);ASSERT(FALSE); }

// Graph Members
public:
	virtual void UpdateGraph(_DHMGraphView* pGraphView) { if( !pGraphView )ASSERT(FALSE); ASSERT(FALSE); }

// Comparison
public:
	virtual int CompareTo(CStatistics* pStat);

// Copy
public:
	virtual CStatistics* Copy() { ASSERT(FALSE); return NULL; }
};

typedef CTypedPtrArray<CObArray,CStatistics*> StatsArray;

#include "Statistics.inl"

#endif // !defined(AFX_STATISTICS_H__5D41A1E3_8CD9_11D3_93A4_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\sysgeneralpage.h ===
#if !defined(AFX_SYSGENERALPAGE_H__C3F44E81_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_SYSGENERALPAGE_H__C3F44E81_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SysGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSysGeneralPage dialog

class CSysGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CSysGeneralPage)

// Construction
public:
	CSysGeneralPage();
	~CSysGeneralPage();

// Dialog Data
public:
	//{{AFX_DATA(CSysGeneralPage)
	enum { IDD = IDD_SYSTEM_GENERAL };
	CString	m_sName;
	CString	m_sComment;
	CString	m_sCreationDate;
	CString	m_sDomain;
	CString	m_sHMVersion;
	CString	m_sModifiedDate;
	CString	m_sOSInfo;
	CString	m_sProcessor;
	CString	m_sWmiVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSysGeneralPage)
	public:
	virtual void OnFinalRelease();
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSysGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSysGeneralPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SYSGENERALPAGE_H__C3F44E81_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\sysgeneralpage.cpp ===
// SysGeneralPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "SysGeneralPage.h"
#include "System.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSysGeneralPage property page

IMPLEMENT_DYNCREATE(CSysGeneralPage, CHMPropertyPage)

CSysGeneralPage::CSysGeneralPage() : CHMPropertyPage(CSysGeneralPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CSysGeneralPage)
	m_sName = _T("");
	m_sComment = _T("");
	m_sCreationDate = _T("");
	m_sDomain = _T("");
	m_sHMVersion = _T("");
	m_sModifiedDate = _T("");
	m_sOSInfo = _T("");
	m_sProcessor = _T("");
	m_sWmiVersion = _T("");
	//}}AFX_DATA_INIT

	CnxPropertyPageInit();

	m_sHelpTopic = _T("HMon21.chm::/dMSgen.htm");
}

CSysGeneralPage::~CSysGeneralPage()
{
}

void CSysGeneralPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CSysGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSysGeneralPage)
	DDX_Text(pDX, IDC_EDIT_NAME, m_sName);
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_sComment);
	DDX_Text(pDX, IDC_STATIC_CREATED, m_sCreationDate);
	DDX_Text(pDX, IDC_STATIC_DOMAIN, m_sDomain);
	DDX_Text(pDX, IDC_STATIC_HM_VERSION, m_sHMVersion);
	DDX_Text(pDX, IDC_STATIC_MODIFIED, m_sModifiedDate);
	DDX_Text(pDX, IDC_STATIC_OS, m_sOSInfo);
	DDX_Text(pDX, IDC_STATIC_PROCESSOR, m_sProcessor);
	DDX_Text(pDX, IDC_STATIC_WMI_VERSION, m_sWmiVersion);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSysGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CSysGeneralPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSysGeneralPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CSysGeneralPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISysGeneralPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {C3F44E80-BA00-11D2-BD76-0000F87A3912}
static const IID IID_ISysGeneralPage =
{ 0xc3f44e80, 0xba00, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CSysGeneralPage, CHMPropertyPage)
	INTERFACE_PART(CSysGeneralPage, IID_ISysGeneralPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSysGeneralPage message handlers

BOOL CSysGeneralPage::OnInitDialog() 
{
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	CSystem* pSystem = (CSystem*)GetObjectPtr();
		
	m_sName = pSystem->GetName();
	m_sComment = pSystem->GetComment();
	pSystem->GetCreateDateTime(m_sCreationDate);
	pSystem->GetModifiedDateTime(m_sModifiedDate);
	pSystem->GetWMIVersion(m_sWmiVersion);	
	pSystem->GetHMAgentVersion(m_sHMVersion);
	
	// get the operating system info
	pSystem->GetOperatingSystemInfo(m_sOSInfo);

	// get the computer system info
	pSystem->GetComputerSystemInfo(m_sDomain,m_sProcessor);

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSysGeneralPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CSysGeneralPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	CnxPropertyPageDestroy();	
}

BOOL CSysGeneralPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	GetObjectPtr()->Rename(m_sName);
	GetObjectPtr()->UpdateComment(m_sComment);

  SetModified(FALSE);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\system.inl ===
// File System.inl
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03-15-00 v-marfin : bug 60291
//                     Fix for HM Version display. Read properties for Major and minor version
//                     as strings instead of ints.
// 03/16/00 v-marfin : bug 60291 (Additional) : Added buildversion and hotfix version to the 
//                     healthmon version string.


#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CSystem::Connect()
{
	TRACEX(_T("CSystem::EnumerateChildren\n"));

	if( m_pSListener == NULL )
	{
		m_pSListener = new CSystemConfigListener;
		m_pSListener->SetObjectPtr(this);
		m_pSListener->Create();
	}

  if( m_pCreationListener == NULL )
  {
    m_pCreationListener = new CConfigCreationListener;
    m_pCreationListener->SetObjectPtr(this);
    m_pCreationListener->Create();
  }

  if( m_pDeletionListener == NULL )
  {
    m_pDeletionListener = new CConfigDeletionListener;
    m_pDeletionListener->SetObjectPtr(this);
    m_pDeletionListener->Create();
  }

	HRESULT hr = S_OK;
	CString sQuery = IDS_STRING_SYSTEMCONFIG_QUERY;
	IWbemObjectSink* pSink = m_pSListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }	

	return hr;
}

inline HRESULT CSystem::EnumerateChildren()
{
	TRACEX(_T("CSystem::EnumerateChildren\n"));

	if( m_pDGListener == NULL )
	{
		m_pDGListener = new CDataGroupConfigListener;
		m_pDGListener->SetObjectPtr(this);
		m_pDGListener->Create();
	}
	else
	{
		IncrementActiveSinkCount();
	}

	HRESULT hr = S_OK;
	CString sQuery;
	sQuery.Format(IDS_STRING_S2DG_ASSOC_QUERY,GetGuid());
	IWbemObjectSink* pSink = m_pDGListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return hr;
}

inline CString CSystem::GetObjectPath()
{
	TRACEX(_T("CSystem::GetObjectPath\n"));

	return IDS_STRING_MOF_SYSTEMOBJECTPATH;
}

inline CString CSystem::GetStatusObjectPath()
{
	TRACEX(_T("CSystem::GetStatusObjectPath\n"));

	return IDS_STRING_MOF_SYSTEMSTATUSOBJECTPATH;
}

inline CHMEvent* CSystem::GetStatusClassObject()
{
	TRACEX(_T("CSystem::GetStatusClassObject\n"));

	CHMEvent* pClassObject = new CHMSystemStatus;

	pClassObject->SetMachineName(GetSystemName());

	if( ! CHECKHRESULT(pClassObject->GetObject(GetStatusObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	pClassObject->GetAllProperties();

	return pClassObject;
}

inline void CSystem::GetWMIVersion(CString& sVersion)
{
	TRACEX(_T("CSystem::GetWMIVersion\n"));

	sVersion.Empty();

	CWbemClassObject IdObject;

	CString sNamespace = _T("\\\\") + GetSystemName() + _T("\\root\\cimv2"); 
	IdObject.SetNamespace(sNamespace);

	HRESULT hr = IdObject.GetObject(_T("__CIMOMIdentification"));
	if( ! CHECKHRESULT(hr) )
	{
		return;
	}

	IdObject.GetProperty(_T("VersionUsedToCreateDB"),sVersion);

  IdObject.Destroy();

  IdObject.SetNamespace(sNamespace);

  hr = IdObject.GetObject(_T("Win32_WMISetting=@"));
  if( ! CHECKHRESULT(hr) )
  {
    return;
  }

  CString sBuildVersion;
  IdObject.GetProperty(_T("BuildVersion"),sBuildVersion);
  
  sVersion = sVersion.Left(5);
  sVersion += sBuildVersion;
}

inline void CSystem::GetHMAgentVersion(CString& sVersion)
{
	TRACEX(_T("CSystem::GetHMAgentVersion\n"));

	sVersion.Empty();

	CWbemClassObject HMVersionObject;

	CString sNamespace;
	sNamespace.Format(IDS_STRING_HEALTHMON_ROOT, GetSystemName()); 
	HMVersionObject.SetNamespace(sNamespace);

	HRESULT hr = HMVersionObject.GetObject(_T("Microsoft_HMVersion=@"));
	if( ! CHECKHRESULT(hr) )
	{
		return;
	}

	// v-marfin : bug 60291
	//            Fix for HM Version display. Read properties for Major and minor version
	//            as strings instead of ints.
	/*int iMajorVersion = 0;
	int iMinorVersion = 0;
	HMVersionObject.GetProperty(_T("iMajorVersion"),iMajorVersion);
	HMVersionObject.GetProperty(_T("iMinorVersion"),iMinorVersion);
	sVersion.Format(_T("%d.%d"),iMajorVersion,iMinorVersion);*/

	// v-marfin : bug 60291 (Additional) Added build number and hotfix number to version string
	CString sMajorVersion  = _T("0");
	CString sMinorVersion  = _T("0");
	CString sBuildVersion  = _T("0");
	CString sHotfixVersion = _T("0");
	HMVersionObject.GetProperty(_T("MajorVersion"),sMajorVersion);
	HMVersionObject.GetProperty(_T("MinorVersion"),sMinorVersion);
	HMVersionObject.GetProperty(_T("BuildVersion"),sBuildVersion);
	HMVersionObject.GetProperty(_T("HotfixVersion"),sHotfixVersion);
	sVersion.Format(_T("%s.%s.%s.%s"),sMajorVersion,sMinorVersion,sBuildVersion,sHotfixVersion);
}

inline BOOL CSystem::GetComputerSystemInfo(CString& sDomain, CString& sProcessor)
{
	TRACEX(_T("CSystem::GetComputerSystemInfo\n"));

	// query for the Win32_ComputerSystem class instances
	CWbemClassObject SystemInfo;

	SystemInfo.SetNamespace(_T("\\\\") + GetSystemName() + _T("\\root\\cimv2"));

	if( ! CHECKHRESULT(SystemInfo.Create(GetSystemName())) )
	{
		return FALSE;
	}

	CString sTemp;
	sTemp.Format(_T("Win32_ComputerSystem.Name=\"%s\""),GetSystemName());
	if( ! CHECKHRESULT(SystemInfo.GetObject(sTemp)) )
	{
		// return;
        return FALSE; // v-marfin 62501
	}

	// read in the Domain

	SystemInfo.GetProperty(_T("Domain"),sDomain);


	// read in the SystemType

	SystemInfo.GetProperty(_T("SystemType"),sProcessor);

    return TRUE; // v-marfin 62501
}

inline void CSystem::GetOperatingSystemInfo(CString& sOSInfo)
{
	TRACEX(_T("CSystem::GetOperatingSystemInfo\n"));

	// query for the Win32_OperatingSystem class instances
	CWbemClassObject SystemInfo;

	SystemInfo.SetNamespace(_T("\\\\") + GetSystemName() + _T("\\root\\cimv2"));

	CString sTemp = _T("Win32_OperatingSystem");
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(SystemInfo.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	ULONG ulReturned = 0L;
	if( SystemInfo.GetNextObject(ulReturned) != S_OK )
	{
		return;
	}

	// read in the caption
	CString sCaption;
	SystemInfo.GetProperty(_T("Caption"),sCaption);


	// read in the BuildNumber
	CString sBuildNumber;
	SystemInfo.GetProperty(_T("BuildNumber"),sBuildNumber);


	// read in the BuildType
	CString sBuildType;
	SystemInfo.GetProperty(_T("BuildType"),sBuildType);


	// read in the CSDVersion
	CString sCSDVersion;
	SystemInfo.GetProperty(_T("CSDVersion"),sCSDVersion);


	sOSInfo.Format(IDS_STRING_SYSINFO_FORMAT,sCaption,sBuildNumber,sBuildType,sCSDVersion);
}

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CSystem::Cut()
{
	TRACEX(_T("CSystem::Cut\n"));
	return false;
}

inline bool CSystem::Copy()
{
	TRACEX(_T("CSystem::Copy\n"));
	return false;
}
	
inline bool CSystem::Paste()
{
	TRACEX(_T("CSystem::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline void CSystem::Serialize(CArchive& ar)
{
	TRACEX(_T("CSystem::Serialize\n"));
	
	CHMObject::Serialize(ar);

	if( ar.IsStoring() )
	{
		ar << GetSystemName();
	}
	else
	{
		CString sName;
		ar >> sName;
		SetSystemName(sName);

		// ping the machine first...adds the system to the lookup table in ConnMgr
		IWbemServices* pIServices = NULL;
		BOOL bAvail;
		HRESULT hr = CnxGetConnection(sName,pIServices,bAvail);

		if( pIServices )
		{
			pIServices->Release();
		}

        //--------------------------
        // Caller will inspect system name to see if serialize was successful
        // v-marfin 62501
        if( ! CHECKHRESULT(hr) )
        {
            CString sFailed = GetSystemName() + FAILED_STRING;
            SetSystemName(sFailed);
            return;
        }
        //--------------------------
	}

}


/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CSystem::CreateScopeItem()
{
	TRACEX(_T("CSystem::CreateScopeItem\n"));

	CSystemScopeItem * pNewItem = new CSystemScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// New Child Creation Members
/////////////////////////////////////////////////////////////////////////////

inline void CSystem::CreateNewChildDataGroup()
{
	TRACEX(_T("CSystem::CreateNewChildDataGroup\n"));

	CString sName = GetUniqueChildName(IDS_STRING_DATA_GROUP_FMT);

	CDataGroup* pNewGroup = new CDataGroup;
	pNewGroup->SetName(sName);
	CreateChild(pNewGroup,IDS_STRING_MOF_HMDG_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);

	if( pNewGroup->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewGroup->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\system.cpp ===
// System.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "System.h"
#include "HMSystem.h"
#include "SystemGroupScopeItem.h"
#include "EventManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSystem

IMPLEMENT_SERIAL(CSystem, CHMObject, 1)

CSystem::CSystem()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_pDGListener = NULL;
  m_pCreationListener = NULL;
  m_pDeletionListener = NULL;
	m_pSListener = NULL;
	m_sTypeName = IDS_STRING_MOF_SYSTEM;
	m_nState = HMS_NODATA;
  m_lTotalActiveSinkCount = 0;
	SetGuid(_T("@"));
}

CSystem::~CSystem()
{

	if( m_pDGListener )
	{
		delete m_pDGListener;
		m_pDGListener = NULL;
	}

  if( m_pCreationListener )
  {
    delete m_pCreationListener;
    m_pCreationListener = NULL;
  }

  if( m_pDeletionListener )
  {
    delete m_pDeletionListener;
    m_pDeletionListener = NULL;
  }

	if( m_pSListener )
	{
		delete m_pSListener;
		m_pSListener = NULL;
	}

	EvtGetEventManager()->RemoveSystemContainer(GetSystemName());

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

void CSystem::UpdateStatus()
{
	TRACEX(_T("CSystem::UpdateStatus\n"));

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
	if( ! pContainer )	
	{
		return;
	}

	SetState(CEvent::GetStatus(pContainer->m_iState));

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CHMScopeItem* pItem = (CHMScopeItem*)GetScopeItem(i);
		if( pItem )
		{
			CStringArray saNames;
			CString sValue;

			// Name of system
			saNames.Add(GetSystemName());

			// Status
			CString sStatus;
			CEvent::GetStatus(pContainer->m_iState,sStatus);
			saNames.Add(sStatus);

            CString sDomain;
            CString sProcessor;
            CString sInfo;

            // GetComputerSystemInfo(sDomain,sProcessor); // v-marfin 62501
            if (!GetComputerSystemInfo(sDomain,sProcessor))
            {
                continue;
            }

            GetOperatingSystemInfo(sInfo);

            // Domain
            saNames.Add(sDomain);
            
            // OS
            saNames.Add(sInfo);

            GetWMIVersion(sInfo);
            // WMI Version
            saNames.Add(sInfo);

			// Normal
			sValue.Format(_T("%d"),pContainer->m_iNumberNormals);
			saNames.Add(sValue);

			// Warning
			sValue.Format(_T("%d"),pContainer->m_iNumberWarnings);
			saNames.Add(sValue);

			// Critical
			sValue.Format(_T("%d"),pContainer->m_iNumberCriticals);
			saNames.Add(sValue);

			// Unknown
			sValue.Format(_T("%d"),pContainer->m_iNumberUnknowns);
			saNames.Add(sValue);

			// Last Message
			CString sLastMessage = pContainer->GetLastEventDTime();
			if( sLastMessage.IsEmpty() )
			{
				sLastMessage.LoadString(IDS_STRING_NONE);
			}
			saNames.Add(sLastMessage);

			// Comment
			saNames.Add(GetComment());

			pItem->SetDisplayNames(saNames);
			pItem->SetIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetOpenIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetItem();			
			CHMScopeItem* pParentItem = (CHMScopeItem*)pItem->GetParent();
			if( pParentItem )
			{
				pParentItem->OnChangeChildState(CEvent::GetStatus(pContainer->m_iState));
			}
		}
	}

	m_lNormalCount = pContainer->m_iNumberNormals;
	m_lWarningCount = pContainer->m_iNumberWarnings;
	m_lCriticalCount = pContainer->m_iNumberCriticals;
	m_lUnknownCount = pContainer->m_iNumberUnknowns;
}

void CSystem::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMObject::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CSystem, CHMObject)
	//{{AFX_MSG_MAP(CSystem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSystem, CHMObject)
	//{{AFX_DISPATCH_MAP(CSystem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISystem to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4FA0-F673-11D2-BDC4-0000F87A3912}
static const IID IID_ISystem =
{ 0xd9bf4fa0, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CSystem, CHMObject)
	INTERFACE_PART(CSystem, IID_ISystem, Dispatch)
END_INTERFACE_MAP()

// {84C4D41D-BB8F-11D2-BD78-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CSystem, "SnapIn.System", 0x84c4d41d, 0xbb8f, 0x11d2, 0xbd, 0x78, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CSystem::CSystemFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CSystem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemeventcontainer.cpp ===
// SystemEventContainer.cpp: implementation of the CSystemEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemEventContainer.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemEventContainer,CEventContainer)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemEventContainer::CSystemEventContainer()
{
	m_pSystemStatusListener = NULL;
}

CSystemEventContainer::~CSystemEventContainer()
{
	DeleteEvents();
	if( m_pSystemStatusListener )
	{
		delete m_pSystemStatusListener;
		m_pSystemStatusListener = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\system.h ===
#if !defined(AFX_SYSTEM_H__D9BF4FA1_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_SYSTEM_H__D9BF4FA1_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// System.h : header file
//

#include "HMObject.h"
#include "DataGroup.h"
#include "HMDataGroupConfiguration.h"
#include "SystemScopeItem.h"
#include "SystemStatusListener.h"
#include "DataGroupConfigListener.h"
#include "ConfigCreationListener.h"
#include "ConfigDeletionListener.h"
#include "SystemConfigListener.h"
#include "HMSystemStatus.h"

/////////////////////////////////////////////////////////////////////////////
// CSystem command target
#define FAILED_STRING   CString(_T(":FAILED"))

class CSystem : public CHMObject
{

DECLARE_SERIAL(CSystem)

// Construction/Destruction
public:
	CSystem();
	virtual ~CSystem();

// WMI Operations
public:
	HRESULT Connect();
	HRESULT EnumerateChildren();
	CString GetObjectPath();
	CString GetStatusObjectPath();
	CHMEvent* GetStatusClassObject();	
	void GetWMIVersion(CString& sVersion);
	void GetHMAgentVersion(CString& sVersion);
	BOOL GetComputerSystemInfo(CString& sDomain, CString& sProcessor);  // v-marfin 62501
	void GetOperatingSystemInfo(CString& sOSInfo);
  long m_lTotalActiveSinkCount;
protected:
	CDataGroupConfigListener* m_pDGListener;
	CSystemConfigListener* m_pSListener;
  CConfigCreationListener* m_pCreationListener;
  CConfigDeletionListener* m_pDeletionListener;	

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
	void Serialize(CArchive& ar);  // v-marfin 62501

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// New Child Creation Members
public:
	void CreateNewChildDataGroup();

// State Members
public:
	virtual void UpdateStatus();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSystem)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSystem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CSystem)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSystem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "System.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SYSTEM_H__D9BF4FA1_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemconfiglistener.cpp ===
// SystemConfigListener.cpp: implementation of the CSystemConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemConfigListener.h"
#include "HMSystem.h"
#include "System.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemConfigListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemConfigListener::CSystemConfigListener()
{
}

CSystemConfigListener::~CSystemConfigListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CSystemConfigListener::Create()
{
	TRACEX(_T("CSystemConfigListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
    IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
    ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CSystemConfigListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE); // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to create Stub Sink!\n")); 
        ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));	
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

    ASSERT(m_pStubSink);

	CHMObject* pObject = GetObjectPtr();
	pObject->IncrementActiveSinkCount();
	
	return true;
}

void CSystemConfigListener::Destroy()
{
	TRACEX(_T("CSystemConfigListener::Destroy\n"));

    if( m_pStubSink )			
    {
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CSystemConfigListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMSystemConfiguration sc;

	if( ! CHECKHRESULT(hr = sc.Create(pClassObject)) )
	{
		return hr;
	}

	sc.GetAllProperties();

	CHMObject* pObject = GetObjectPtr();
	if( ! GfxCheckObjPtr(pObject,CSystem) )
	{
		return E_FAIL;
	}

	pObject->SetGuid(sc.m_sGuid);

  return hr;
}

inline HRESULT CSystemConfigListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CWbemEventListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult == S_OK )
	{
		CHMObject* pObject = GetObjectPtr();
		CSystem* pSystem = (CSystem*)pObject;
		pSystem->DecrementActiveSinkCount();
	}

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemeventcontainer.h ===
// SystemEventContainer.h: interface for the CSystemEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMEVENTCONTAINER_H__5ABFA7D6_8EEC_11D3_93A5_00A0CC406605__INCLUDED_)
#define AFX_SYSTEMEVENTCONTAINER_H__5ABFA7D6_8EEC_11D3_93A5_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EventContainer.h"
#include "SystemStatusListener.h"

class CSystemEventContainer : public CEventContainer  
{

DECLARE_DYNCREATE(CSystemEventContainer)

// Construction/Destruction
public:
	CSystemEventContainer();
	virtual ~CSystemEventContainer();

// Operations
public:
	virtual void DeleteEvent(int iIndex);

// Event Listener
public:
	CSystemStatusListener* m_pSystemStatusListener;

};

#include "SystemEventContainer.inl"

#endif // !defined(AFX_SYSTEMEVENTCONTAINER_H__5ABFA7D6_8EEC_11D3_93A5_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemeventcontainer.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

inline void CSystemEventContainer::DeleteEvent(int iIndex)
{
	CEvent* pEvent = m_Events[iIndex];
	if( pEvent )
	{
		delete pEvent;
	}
	m_Events.RemoveAt(iIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemconfiglistener.h ===
// SystemConfigListener.h: interface for the CSystemConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMCONFIGLISTENER_H__C7515E1B_2012_11D3_BDFD_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMCONFIGLISTENER_H__C7515E1B_2012_11D3_BDFD_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CSystemConfigListener : public CWbemEventListener  
{
DECLARE_DYNCREATE(CSystemConfigListener)

// Construction/Destruction
public:
	CSystemConfigListener();
	virtual ~CSystemConfigListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);

};

#endif // !defined(AFX_SYSTEMCONFIGLISTENER_H__C7515E1B_2012_11D3_BDFD_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroupresultsview.h ===
// SystemGroupResultsView.h: interface for the CSystemGroupResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMGROUPRESULTSVIEW_H__D9BF4F96_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMGROUPRESULTSVIEW_H__D9BF4F96_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CSystemGroupResultsView : public CSplitPaneResultsView  
{

DECLARE_DYNCREATE(CSystemGroupResultsView)

public:
	CSystemGroupResultsView();
	virtual ~CSystemGroupResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_SYSTEMGROUPRESULTSVIEW_H__D9BF4F96_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroupresultsview.cpp ===
// SystemGroupResultsView.cpp: implementation of the CSystemGroupResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemGroupResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemGroupResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemGroupResultsView::CSystemGroupResultsView()
{

}

CSystemGroupResultsView::~CSystemGroupResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CSystemGroupResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CSystemGroupResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Domain
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DOMAIN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// OS
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_OS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// WMI version
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WMI_VERSION);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroup.cpp ===
// SystemGroup.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "SystemGroup.h"
#include "EventManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSystemGroup

IMPLEMENT_SERIAL(CSystemGroup, CHMObject, 1)

CSystemGroup::CSystemGroup()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
	m_nState = HMS_NORMAL;

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	SetGuid(sGuid);
}

CSystemGroup::~CSystemGroup()
{

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

}

int CSystemGroup::AddShortcut(CHMObject* pObject)
{
	TRACEX(_T("CSystemGroup::AddShortcut\n"));
	TRACEARGn(pObject);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		TRACE(_T("FAILED : pObject is not a valid pointer.\n"));
		return -1;
	}

	pObject->SetScopePane(GetScopePane());

	int iIndex = (int)m_Shortcuts.Add(pObject);

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CScopePaneItem* pItem = pObject->CreateScopeItem();

		if( ! pItem->Create(m_pPane,GetScopeItem(i)) )
		{
			ASSERT(FALSE);
			delete pItem;
			return -1;
		}

		if( pObject->GetScopeItemCount() )
		{
			pItem->SetDisplayNames(pObject->GetScopeItem(0)->GetDisplayNames());
		}
		else
		{
			pItem->SetDisplayName(0,pObject->GetName());
		}

		pItem->SetIconIndex(pObject->GetState());
		pItem->SetOpenIconIndex(pObject->GetState());
		
		if( GfxCheckObjPtr(pItem,CHMScopeItem) )
		{
			((CHMScopeItem*)pItem)->SetObjectPtr(pObject);
		}
	
		int iIndex = GetScopeItem(i)->AddChild(pItem);		
		pItem->InsertItem(iIndex);
		pObject->AddScopeItem(pItem);

	}

	EvtGetEventManager()->AddSystemShortcutAssociation(GetGuid(),pObject->GetSystemName());

	return iIndex;
}

void CSystemGroup::RemoveShortcut(CHMObject* pObject)
{
	TRACEX(_T("CSystemGroup::RemoveShortcut\n"));
	TRACEARGn(pObject);

	if( ! pObject )
	{
		return;
	}

	EvtGetEventManager()->RemoveSystemShortcutAssociation(GetGuid(),pObject->GetSystemName());

	for( int i = 0; i < m_Shortcuts.GetSize(); i++ )
	{
		if( m_Shortcuts[i] == pObject )
		{
			for( int j = pObject->GetScopeItemCount()-1; j >= 0; j-- )
			{
				CScopePaneItem* pChildItem = pObject->GetScopeItem(j);					
				if( pChildItem )
				{
					CHMScopeItem* pParentItem = (CHMScopeItem*)pChildItem->GetParent();
					if( pParentItem && pParentItem->GetObjectPtr() == this )
					{
						pObject->RemoveScopeItem(j);
						pParentItem->DestroyChild(pChildItem);
					}
				}
			}
			m_Shortcuts.RemoveAt(i);
			return;
		}
	}
}

void CSystemGroup::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMObject::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CSystemGroup, CHMObject)
	//{{AFX_MSG_MAP(CSystemGroup)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSystemGroup, CHMObject)
	//{{AFX_DISPATCH_MAP(CSystemGroup)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISystemGroup to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4F9D-F673-11D2-BDC4-0000F87A3912}
static const IID IID_ISystemGroup =
{ 0xd9bf4f9d, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CSystemGroup, CHMObject)
	INTERFACE_PART(CSystemGroup, IID_ISystemGroup, Dispatch)
END_INTERFACE_MAP()

// {D9BF4F9E-F673-11D2-BDC4-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CSystemGroup, "SnapIn.SystemGroup", 0xd9bf4f9e, 0xf673, 0x11d2, 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CSystemGroup::CSystemGroupFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSystemGroup message handlers


/////////////////////////////////////////////////////////////////////////////
// CAllSystemsGroup

IMPLEMENT_SERIAL(CAllSystemsGroup, CSystemGroup, 1)

CAllSystemsGroup::CAllSystemsGroup()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_nState = HMS_NORMAL;

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	SetGuid(sGuid);
}

CAllSystemsGroup::~CAllSystemsGroup()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroup.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CSystemGroup::Cut()
{
	TRACEX(_T("CSystemGroup::Cut\n"));
	return false;
}

inline bool CSystemGroup::Copy()
{
	TRACEX(_T("CSystemGroup::Copy\n"));
	return false;
}
	
inline bool CSystemGroup::Paste()
{
	TRACEX(_T("CSystemGroup::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CSystemGroup::Refresh()
{
	TRACEX(_T("CSystemGroup::Refresh\n"));
	return false;
}

inline bool CSystemGroup::ResetStatus()
{
	TRACEX(_T("CSystemGroup::ResetStatus\n"));
	return false;
}

inline CString CSystemGroup::GetUITypeName()
{
	TRACEX(_T("CSystemGroup::GetUITypeName\n"));

	CString sTypeName;
	sTypeName.LoadString(IDS_STRING_SYSTEM_GROUP);

	return sTypeName;
}

inline void CSystemGroup::Serialize(CArchive& ar)
{
	TRACEX(_T("CSystemGroup::Serialize\n"));

	CHMObject::Serialize(ar);

	if( ar.IsStoring() )
	{
		// write out the list of child groups
		ar << GetChildCount();

		for( int i = 0; i < GetChildCount(); i++ )
		{
			GetChild(i)->Serialize(ar);
		}

		// write out the list of shortcuts
		ar << (int)m_Shortcuts.GetSize();

		for( i = 0; i < m_Shortcuts.GetSize(); i++ )
		{
			m_Shortcuts[i]->Serialize(ar);
		}
	}
	else
	{
		// update the scope items to reflect their correct name
		for(int i = 0; i < m_ScopeItems.GetSize(); i++)
		{
			m_ScopeItems[i]->SetDisplayName(0,m_sName);
			m_ScopeItems[i]->SetItem();
		}

		int iChildCount = 0;
		ar >> iChildCount;

		for( i = 0; i < iChildCount; i++ )
		{
			CSystemGroup* pNewGroup = new CSystemGroup;
			pNewGroup->SetScopePane(GetScopePane());
			pNewGroup->SetName(GetUniqueChildName());
			AddChild(pNewGroup);
			pNewGroup->Serialize(ar);			
		}

		int iShortcutCount = 0;
		ar >> iShortcutCount;

		CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
		CSystemGroup* pASG = pPane->GetAllSystemsGroup();
		for( i = 0; i < iShortcutCount; i++ )
		{
			CString sName;
			CString sSystemName;
			ar >> sName;
			ar >> sSystemName;
			AddShortcut(pASG->GetChild(sName));
		}
	}
}


inline void CAllSystemsGroup::Serialize(CArchive& ar)
{
	TRACEX(_T("CAllSystemsGroup::Serialize\n"));

	CHMObject::Serialize(ar);

	if( ar.IsStoring() )
	{
		// write out the list of child groups
		ar << GetChildCount();

		for( int i = 0; i < GetChildCount(); i++ )
		{
			GetChild(i)->Serialize(ar);
		}
	}
	else
	{
		int iChildCount = 0;
		ar >> iChildCount;


		for( int i = 0; i < iChildCount; i++ )
		{
			CSystem* pNewSystem = new CSystem;
			pNewSystem->Serialize(ar);

            //----------------------------------------------
            // v-marfin 62501 - check to see if successful
            /*CString sFailed = pNewSystem->GetSystemName();
            if (sFailed.Right(FAILED_STRING.GetLength()) == FAILED_STRING)
            {
                sFailed = sFailed.Left(sFailed.GetLength() - FAILED_STRING.GetLength());
                pNewSystem->SetSystemName(sFailed);
                delete pNewSystem;
                continue;
            }*/
            BOOL bFailed=FALSE;
            // v-marfin 62501 - check to see if successful
            CString sFailed = pNewSystem->GetSystemName();
            if (sFailed.Right(FAILED_STRING.GetLength()) == FAILED_STRING)
            {
                sFailed = sFailed.Left(sFailed.GetLength() - FAILED_STRING.GetLength());
                pNewSystem->SetSystemName(sFailed);
                bFailed=TRUE;

                CString sMsg;
                sMsg.Format(IDS_STRING_TRANSPORT_ERROR,sFailed);
                AfxMessageBox(sMsg); 
            }
            //----------------------------------------------

            //----------------------------------------------
            // v-marfin 62501 - check to see if successful.
            // When unable to connect to a system, do not even show
            // its icon in the tree. We have to do this hack in the BETA
            // time frame since there are too many other implications of 
            // having the icon appear
            // in the list (i.e. if the user tries to add groups to it, it
            // causes crashes etc.) We should deal with this in the RTM 
            // time frame however. So for now, place the code here and 
            // at final fix time, see the code which is commented out below
            // and use that instead of this.
            if (bFailed)
            {
                delete pNewSystem;
                continue;
            }
            //----------------------------------------------

			pNewSystem->SetScopePane(GetScopePane());

			AddChild(pNewSystem);

            //----------------------------------------------
            // v-marfin 62501 - check to see if successful.
            // When unable to connect to a system, at least show its
            // icon so the user sees that it is inaccessible. We
            // comment out this code for BETA time frame since there
            // are too many other implications of having the icon appear
            // in the list (i.e. if the user tries to add groups to it, it
            // causes crashes etc.) We should deal with this in the RTM 
            // time frame however. So for now, the code to check the 
            // success of connecting will be placed just above here.
            /*if (bFailed)
            {
                delete pNewSystem;
                continue;
            }*/
            //----------------------------------------------
			pNewSystem->Connect();

			CActionPolicy* pPolicy = new CActionPolicy;
			pPolicy->SetSystemName(pNewSystem->GetName());
			pNewSystem->AddChild(pPolicy);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// State Members
/////////////////////////////////////////////////////////////////////////////

inline void CSystemGroup::TallyChildStates()
{
	TRACEX(_T("CSystemGroup::TallyChildStates\n"));

	m_lNormalCount = 0L;
	m_lWarningCount = 0L;
	m_lCriticalCount = 0L;
	m_lUnknownCount = 0L;


	for( int i = 0; i < m_Children.GetSize(); i++ )
	{
		switch( m_Children[i]->GetState() )
		{
			case HMS_NORMAL:
			{
				m_lNormalCount++;
			}
			break;

			case HMS_WARNING:
			{
				m_lWarningCount++;
			}
			break;

			case HMS_CRITICAL:
			{
				m_lCriticalCount++;
			}
			break;

			case HMS_UNKNOWN:
			{
				m_lUnknownCount++;
			}
			break;
		}
	}

	for( i = 0; i < m_Shortcuts.GetSize(); i++ )
	{
		switch( m_Shortcuts[i]->GetState() )
		{
			case HMS_NORMAL:
			{
				m_lNormalCount++;
			}
			break;

			case HMS_WARNING:
			{
				m_lWarningCount++;
			}
			break;

			case HMS_CRITICAL:
			{
				m_lCriticalCount++;
			}
			break;

			case HMS_UNKNOWN:
			{
				m_lUnknownCount++;
			}
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CSystemGroup::CreateScopeItem()
{
	TRACEX(_T("CSystemGroup::CreateScopeItem\n"));

	CSystemGroupScopeItem * pNewItem = new CSystemGroupScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CAllSystemsGroup::CreateScopeItem()
{
	TRACEX(_T("CAllSystemsGroup::CreateScopeItem\n"));

	CAllSystemsScopeItem * pNewItem = new CAllSystemsScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// New Child Creation Members
/////////////////////////////////////////////////////////////////////////////

inline void CSystemGroup::CreateNewChildSystemGroup()
{
	TRACEX(_T("CSystemGroup::CreateNewChildSystemGroup\n"));

	CString sName = GetUniqueChildName(IDS_STRING_SYSTEMGROUP_FMT);

	CSystemGroup* pNewGroup = new CSystemGroup;
	pNewGroup->SetName(sName);
	CHMObject::AddChild(pNewGroup);

	if( pNewGroup->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewGroup->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}

}

/////////////////////////////////////////////////////////////////////////////
// System Child Members
/////////////////////////////////////////////////////////////////////////////

inline CHMObject* CSystemGroup::GetShortcut(const CString& sName)
{
	TRACEX(_T("CSystemGroup::GetShortcut\n"));

	for( int i = 0; i < m_Shortcuts.GetSize(); i++ )
	{
		if( m_Shortcuts[i]->GetName().CompareNoCase(sName) == 0 )
		{
			return m_Shortcuts[i];
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroupscopeitem.cpp ===
// SystemGroupScopeItem.cpp: implementation of the CSystemGroupScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "HealthmonScopePane.h"
#include "SystemGroupScopeItem.h"
#include "SystemGroupResultsView.h"
#include "NewsystemShortcutDlg.h"
#include "SystemGroup.h"
#include "System.h"
#include "GroupGeneralPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {F768EEC3-BA00-11d2-BD76-0000F87A3912}
static GUID GUID_Group = 
{ 0xf768eec3, 0xba00, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CSystemGroupScopeItem,CHMScopeItem)

// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_SYSTEMS,
	IDI_ICON_SYSTEMS_DISABLED,
	IDI_ICON_SYSTEMS_OUTAGE,
	IDI_ICON_SYSTEMS_UNKNOWN,
	IDI_ICON_SYSTEMS_NO_CONNECT,
	IDI_ICON_SYSTEMS_WARNING,
	IDI_ICON_SYSTEMS_CRITICAL
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemGroupScopeItem::CSystemGroupScopeItem()
{
	m_lpguidItemType = &GUID_Group;
}

CSystemGroupScopeItem::~CSystemGroupScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CSystemGroupScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CSystemGroupScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}
	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	// set display name to untitled
	CString sName;
	sName.LoadString(IDS_STRING_UNTITLED);
	SetDisplayName(0,sName);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CSystemGroupScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CSystemGroupScopeItem::CreateResultsPaneView\n"));

	return new CSystemGroupResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CSystemGroupScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CSystemGroupScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_GROUP;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_NEW_SYSTEM_SHORTCUT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_SYSTEM_SHORTCUT_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_SYSTEM;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_MODIFY_SYSTEM_SHORTCUT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_SYSTEM;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_RESET_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_RESET_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
	}

	return hr;
}

HRESULT CSystemGroupScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CSystemGroupScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_GROUP:
		{
			CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
			if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
				return E_FAIL;
			}

			CSystemGroup* pSG = (CSystemGroup*)GetObjectPtr();
			pSG->CreateNewChildSystemGroup();
		}
		break;

		case IDM_NEW_SYSTEM:
		{
			CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
			if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
				return E_FAIL;
			}

			CSystemGroup* pGroup = (CSystemGroup*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pGroup,CSystemGroup) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetObjectPtr returns an invalid pointer.\n"));
				return E_FAIL;
			}

			CSystemGroup* pASG = pPane->GetAllSystemsGroup();			

			CNewSystemShortcutDlg dlg;

			dlg.m_sGroupName = pGroup->GetName();

			for( int i = 0; i < pASG->GetChildCount(); i++ )
			{
				CString sName = pASG->GetChild(i)->GetName();
				dlg.m_saSystems.Add(sName);
				if( pGroup->GetShortcut(sName) )
				{
					dlg.m_uaIncludeFlags.Add(1);
				}
				else
				{
					dlg.m_uaIncludeFlags.Add(0);
				}
			}

			if( dlg.DoModal() == IDOK )
			{
				for( int i = 0; i < dlg.m_saSystems.GetSize(); i++ )
				{
					if( dlg.m_uaIncludeFlags[i] == 1 && ! pGroup->GetShortcut(dlg.m_saSystems[i]) )
					{
						CSystem* pSystem = (CSystem*)pASG->GetChild(dlg.m_saSystems[i]);
						pGroup->AddShortcut(pSystem);
					}
					else
					{
						if( dlg.m_uaIncludeFlags[i] == 0 )
						{
							for( int z = 0; z < GetChildCount(); z++ )
							{
								if( GetChild(z) && GetChild(z)->GetDisplayName().CompareNoCase(dlg.m_saSystems[i]) == 0 )
								{
									GetChild(z)->OnDelete();
								}
							}
							CSystem* pSystem = (CSystem*)pGroup->GetShortcut(dlg.m_saSystems[i]);
							pGroup->RemoveShortcut(pSystem);
						}
					}
				}
			}
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CSystemGroupScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CSystemGroupScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	CGroupGeneralPage* pPage1 = new CGroupGeneralPage;

	pPage1->SetObjectPtr(GetObjectPtr());

  HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );

  hr = lpProvider->AddPage(hPage1);


	return hr;
}

HRESULT CSystemGroupScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CSystemGroupScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_CUT, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
  hr = lpConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroupscopeitem.h ===
// SystemGroupScopeItem.h: interface for the CSystemGroupScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMGROUPSCOPEITEM_H__D9BF4F95_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMGROUPSCOPEITEM_H__D9BF4F95_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CSystemGroupScopeItem : public CHMScopeItem  
{

DECLARE_DYNCREATE(CSystemGroupScopeItem)

// Construction/Destruction
public:
	CSystemGroupScopeItem();
	virtual ~CSystemGroupScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);

// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);
	virtual HRESULT OnExpand(BOOL bExpand) { return CScopePaneItem::OnExpand(bExpand); }
};

#endif // !defined(AFX_SYSTEMGROUPSCOPEITEM_H__D9BF4F95_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemgroup.h ===
#if !defined(AFX_SYSTEMGROUP_H__D9BF4F9F_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMGROUP_H__D9BF4F9F_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SystemGroup.h : header file
//

#include "HMObject.h"
#include "SystemGroupScopeItem.h"
#include "AllSystemsScopeItem.h"
#include "HMSystemStatus.h"
#include "System.h"
#include "ActionPolicy.h"

/////////////////////////////////////////////////////////////////////////////
// CSystemGroup command target

class CSystemGroup : public CHMObject
{

DECLARE_SERIAL(CSystemGroup)

// Construction/Destruction
public:
	CSystemGroup();
	virtual ~CSystemGroup();

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
	virtual bool Refresh();
	virtual bool ResetStatus();
	virtual CString GetUITypeName();
	void Serialize(CArchive& ar);

// State Members
public:
	void TallyChildStates();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// New Child Creation Members
public:
	void CreateNewChildSystemGroup();

// System Shortcut Members
public:
	int AddShortcut(CHMObject* pObject);
	CHMObject* GetShortcut(const CString& sName);
	void RemoveShortcut(CHMObject* pObject);	
protected:
	CTypedPtrArray<CObArray,CHMObject*> m_Shortcuts;

// Attributes
public:
	

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSystemGroup)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSystemGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CSystemGroup)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSystemGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

class CAllSystemsGroup : public CSystemGroup
{

DECLARE_SERIAL(CAllSystemsGroup)

// Construction/Destruction
public:
	CAllSystemsGroup();
	virtual ~CAllSystemsGroup();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// Operations
public:
	void Serialize(CArchive& ar);

// System Shortcut Members
public:
	int AddChild(CHMObject* pObject) { return CHMObject::AddChild(pObject); }
	void RemoveChild(CHMObject* pObject) { CHMObject::RemoveChild(pObject); }
	void DestroyChild(CHMObject* pObject, bool bDeleteClassObject = false) { CHMObject::DestroyChild(pObject,bDeleteClassObject); }

};

#include "SystemGroup.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SYSTEMGROUP_H__D9BF4F9F_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemresultsview.cpp ===
// SystemResultsView.cpp: implementation of the CSystemResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemResultsView.h"
#include "SplitPaneResultsView.h"
#include "HMListViewColumn.h"
#include "HealthmonResultsPane.h"
#include "HealthmonScopePane.h"
#include "HMResultsPaneItem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemResultsView::CSystemResultsView()
{

}

CSystemResultsView::~CSystemResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CSystemResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CSystemResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// GUID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_GUID);
	pColumn->Create(this,sTitle,0,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemresultsview.h ===
// SystemResultsView.h: interface for the CSystemResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMRESULTSVIEW_H__C3F44E6A_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMRESULTSVIEW_H__C3F44E6A_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CSystemResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CSystemResultsView)

// Construction/Destruction
public:
	CSystemResultsView();
	virtual ~CSystemResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_SYSTEMRESULTSVIEW_H__C3F44E6A_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemscopeitem.h ===
// SystemScopeItem.h: interface for the CSystemScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMSCOPEITEM_H__C3F44E69_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMSCOPEITEM_H__C3F44E69_BA00_11D2_BD76_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

#pragma warning( disable:4100 )

class CSystemScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CSystemScopeItem)

// Construction/Destruction
public:
	CSystemScopeItem();
	virtual ~CSystemScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
	virtual HRESULT OnDelete(BOOL bConfirm=TRUE); // v-marfin 62903
	virtual HRESULT OnExpand(BOOL bExpand);
	virtual HRESULT OnRename(const CString& sNewName){ return S_OK; }
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);

};

#pragma warning( default:4100 )

#endif // !defined(AFX_SYSTEMSCOPEITEM_H__C3F44E69_BA00_11D2_BD76_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemsresultsview.h ===
// SystemsResultsView.h: interface for the CSystemsResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMSRESULTSVIEW_H__1E782D94_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMSRESULTSVIEW_H__1E782D94_AB0E_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CSystemsResultsView : public CSplitPaneResultsView  
{

DECLARE_DYNCREATE(CSystemsResultsView)

// Construction/Destruction
public:
	CSystemsResultsView();
	virtual ~CSystemsResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_SYSTEMSRESULTSVIEW_H__1E782D94_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemsscopeitem.cpp ===
// SystemsScopeItem.cpp: implementation of the CSystemsScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemsScopeItem.h"
#include "SystemsResultsView.h"
#include "AllSystemsScopeItem.h"
#include "HealthmonScopePane.h"
#include "ClearEventsDlg.h"
#include "SystemGroup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CSystemsScopeItem,CHMScopeItem)

// {ADE7EC03-B0C1-11d2-BD6C-0000F87A3912}
static GUID GUID_Systems = 
{ 0xade7ec03, 0xb0c1, 0x11d2, { 0xbd, 0x6c, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };


// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_SYSTEMS,
	IDI_ICON_SYSTEMS_DISABLED,
	IDI_ICON_SYSTEMS_OUTAGE,
	IDI_ICON_SYSTEMS_UNKNOWN,
	IDI_ICON_SYSTEMS_NO_CONNECT,
	IDI_ICON_SYSTEMS_WARNING,
	IDI_ICON_SYSTEMS_CRITICAL

};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemsScopeItem::CSystemsScopeItem()
{
	m_lpguidItemType = &GUID_Systems;
}

CSystemsScopeItem::~CSystemsScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CSystemsScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CSystemsScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}
	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_SYSTEMS_NODE);
	SetDisplayName(0,sName);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CSystemsScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CSystemsScopeItem::CreateResultsPaneView\n"));

	return new CSystemsResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CSystemsScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CSystemsScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_SYSTEMS_GROUP_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_GROUP;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_RESET_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_RESET_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

  }

	return hr;
}

HRESULT CSystemsScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CSystemsScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_GROUP:
		{
			CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
			if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
				return E_FAIL;
			}

			CSystemGroup* pMSG = pPane->GetRootGroup();
			pMSG->CreateNewChildSystemGroup();
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
		break;
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemsscopeitem.h ===
// SystemsScopeItem.h: interface for the CSystemsScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMSSCOPEITEM_H__1E782D93_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMSSCOPEITEM_H__1E782D93_AB0E_11D2_BD62_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CSystemsScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CSystemsScopeItem)

// Construction/Destruction
public:
	CSystemsScopeItem();
	virtual ~CSystemsScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnExpand(BOOL bExpand) { return CScopePaneItem::OnExpand(bExpand); }

};

#endif // !defined(AFX_SYSTEMSSCOPEITEM_H__1E782D93_AB0E_11D2_BD62_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemscopeitem.cpp ===
// SystemScopeItem.cpp: implementation of the CSystemScopeItem class.
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/22/00 v-marfin 59675 : Rearranged data group menu items.
// 03/30/00 v-marfin 62696 : Help link fix
// 04/05/00 v-marfin 62903 : Ensure SystemCopeItem's OnDestory is called when 
//                           disconnecting a computer from the scope pane.
#include "stdafx.h"
#include "snapin.h"
#include "SystemScopeItem.h"
#include "SystemResultsView.h"
#include "HealthmonScopePane.h"
#include "ResultsPane.h"
#include "RemoveSystemDlg.h"
#include "System.h"
#include "SysGeneralPage.h"
#include "ActionAssociationPage.h"
#include "SystemGroupScopeItem.h"
#include "AllSystemsScopeItem.h"
#include "SystemGroup.h"
#include "RootScopeItem.h"
#include "RemovesystemDlg.h"
#include "ActionPolicyScopeItem.h"
#include "EventManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemScopeItem,CHMScopeItem)

// {D5D74613-BA11-11d2-BD76-0000F87A3912}
static GUID GUID_System = 
{ 0xd5d74613, 0xba11, 0x11d2, { 0xbd, 0x76, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_SYSTEM,
	IDI_ICON_SYSTEM_DISABLED,
	IDI_ICON_SYSTEM_OUTAGE,
	IDI_ICON_SYSTEM_UNKNOWN,
	IDI_ICON_SYSTEM_NO_CONNECT,
	IDI_ICON_SYSTEM_WARNING,
	IDI_ICON_SYSTEM_CRITICAL

};

// icon table - associates state to icons
static UINT _ShortcutIcons[HMS_MAX_STATES] =
{
	IDI_ICON_SYSTEM_SHORTCUT,
	IDI_ICON_SYSTEM_SHORTCUT_DISABLED,
	IDI_ICON_SYSTEM_SHORTCUT_OUTAGE,
	IDI_ICON_SYSTEM_SHORTCUT_UNKNOWN,
	IDI_ICON_SYSTEM_SHORTCUT_NO_CONNECT,
	IDI_ICON_SYSTEM_SHORTCUT_WARNING,
	IDI_ICON_SYSTEM_SHORTCUT_CRITICAL

};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemScopeItem::CSystemScopeItem()
{
	m_lpguidItemType = &GUID_System;
}

CSystemScopeItem::~CSystemScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CSystemScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CSystemScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = 0L;
		if( pParentItem->GetRuntimeClass()->m_lpszClassName == CString(_T("CAllSystemsScopeItem")) )
		{
			nId = _Icons[i];
		}
		else
		{
			nId = _ShortcutIcons[i];
		}
		
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}
	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_UNTITLED);
	SetDisplayName(0,sName);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CSystemScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CSystemScopeItem::CreateResultsPaneView\n"));

	return new CSystemResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CSystemScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CSystemScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;
		
		// Component...
    sResString.LoadString(IDS_STRING_NEW_COMPONENT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_COMPONENT_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_DATA_GROUP;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
		
	}

    // Add Task Menu Items
    if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
    {
		CONTEXTMENUITEM cmi;
        CString sResString;
        CString sResString2;

	    // Disconnect
	    if( GfxCheckObjPtr(GetParent(),CAllSystemsScopeItem) ) // it is not a shortcut
	    {
		    sResString.LoadString(IDS_STRING_DISCONNECT);
		    cmi.strName           = LPTSTR(LPCTSTR(sResString));
		    cmi.strStatusBarText  = NULL;
		    cmi.lCommandID        = IDM_DISCONNECT;
		    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		    cmi.fFlags            = 0;
		    cmi.fSpecialFlags     = 0;

		    hr = piCallback->AddItem(&cmi);
		    if( !SUCCEEDED(hr) )
		    {
			    TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
			    return hr;
		    }
	    }

        // v-marfin 59675 : rearrange menu items

	    // separator
	    cmi.strName           = NULL;
	    cmi.strStatusBarText  = NULL;
	    cmi.lCommandID        = NULL;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = MF_SEPARATOR;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }


	    // clear events
        sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
	    cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
	    cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	    cmi.lCommandID        = IDM_CLEAR_EVENTS;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = 0;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }

	    // Reset Statistics
        sResString.LoadString(IDS_STRING_RESET_STATISTICS);
	    cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_RESET_STATISTICS_DESC);
	    cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	    cmi.lCommandID        = IDM_RESET_STATISTICS;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = 0;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }



	    // separator
	    cmi.strName           = NULL;
	    cmi.strStatusBarText  = NULL;
	    cmi.lCommandID        = NULL;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = MF_SEPARATOR;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }

	    // reset status
        sResString.LoadString(IDS_STRING_RESET_STATUS);
	    cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
	    cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	    cmi.lCommandID        = IDM_RESET_STATUS;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = 0;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }


	    // check now
        sResString.LoadString(IDS_STRING_CHECK_NOW);
	    cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_CHECK_NOW_DESC);
	    cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	    cmi.lCommandID        = IDM_CHECK_NOW;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = 0;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }

	    // separator
	    cmi.strName           = NULL;
	    cmi.strStatusBarText  = NULL;
	    cmi.lCommandID        = NULL;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    cmi.fFlags            = MF_SEPARATOR;
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }


	    // disable monitoring
        sResString.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS);
	    cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS_DESCRIPTION);
	    cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	    cmi.lCommandID        = IDM_DISABLE_MONITORING;
	    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	    
	    CHMObject* pObject = GetObjectPtr();
        CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();        

        // disable menu item if null object ptr or parent is disabled
	    if( ! pObject || (pParentItem && pParentItem->GetObjectPtr()
                      && !pParentItem->GetObjectPtr()->IsEnabled()) )

	    {
		    cmi.fFlags = MF_DISABLED|MF_GRAYED;
	    }
	    else
	    {
		    int iState = pObject->IsEnabled();
		    if( iState == -1 )
		    {
			    cmi.fFlags = MF_DISABLED|MF_GRAYED;
		    }
		    else if( iState == 0 )
		    {
			    cmi.fFlags = MF_CHECKED;
		    }
		    else if( iState == 1 )
		    {
			    cmi.fFlags = MF_UNCHECKED;
		    }
	    }
	    cmi.fSpecialFlags     = 0;

	    hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
          TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
          return hr;
        }

	}

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CSystemScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CSystemScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_DATA_GROUP:
		{
			CSystem* pSystem = (CSystem*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pSystem,CSystem) )
			{
				return E_FAIL;
			}

			pSystem->CreateNewChildDataGroup();
		}
		break;

		case IDM_DISCONNECT:
		{
			OnDelete();
		}
		break;

		case IDM_EXPORT:
		{
			CString sFilter;
			sFilter.LoadString(IDS_STRING_MOF_FILTER);
			CFileDialog fd(FALSE,_T("MOF"),NULL,OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,sFilter);

			if( fd.DoModal() == IDOK )
			{
				CFile file;
				if( ! file.Open(fd.GetPathName(),CFile::modeCreate|CFile::modeWrite|CFile::shareExclusive) )
				{
					return S_OK;
				}

				CArchive ar(&file,CArchive::store);
				CHMObject* pObject = GetObjectPtr();
				if( pObject )
				{
					pObject->ExportMofFile(ar);
				}
			}
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CSystemScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CSystemScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	// create the pages
	CSysGeneralPage* pPage1 = new CSysGeneralPage;

	pPage1->SetObjectPtr(GetObjectPtr());
	
  HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );

  hr = lpProvider->AddPage(hPage1);

	CActionAssociationPage* pPage2 = new CActionAssociationPage;

	//---------------------------------------------------------------------------------------------
	// v-marfin 62192 : by default the action property page will load its threshold action help.
	//                  so we will override since this is a data group being shown properties, not
	//                  a threshold.
	pPage2->m_sHelpTopic = _T("HMon21.chm::/dmcact.htm");  // v-marfin 62696 :dmcact.htm
	//----------------------------------------------------------------------------------------------

	pPage2->SetObjectPtr(GetObjectPtr());
	
  HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );

  hr = lpProvider->AddPage(hPage2);

	return hr;
}

HRESULT CSystemScopeItem::OnDelete(BOOL bConfirm)  // v-marfin 62903
{
	TRACEX(_T("CSystemScopeItem::OnDelete\n"));

	CHMObject* pObject = GetObjectPtr();

	if( ! GfxCheckObjPtr(pObject,CSystem) )
	{
		return E_FAIL;
	}

	if( ! GetParent() )
	{
		return E_FAIL;
	}

	CScopePaneItem* pItemToSelect = NULL;

	if( GetScopePane() && GetScopePane()->GetSelectedScopeItem() == this )
	{
		pItemToSelect = GetParent();
	}

	if( GfxCheckObjPtr(GetParent(),CAllSystemsScopeItem) ) // it is not a shortcut
	{
		CRemoveSystemDlg dlg;

		if( dlg.DoModal() == IDCANCEL )
		{
			return S_FALSE;
		}

		// first query all the scope items and see if any have open property sheets
		for( int i = 0; i < pObject->GetScopeItemCount(); i++ )
		{
			if( pObject->GetScopeItem(i)->IsPropertySheetOpen(true) )
			{
				AfxMessageBox(IDS_STRING_WARN_PROPPAGE_OPEN);
				return S_OK;
			}
		}

		CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
		if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
		{
			return E_FAIL;
		}

		CSystemGroup* pRootGroup = pPane->GetRootGroup();
		if( ! pRootGroup )
		{
			return E_FAIL;
		}

		EvtGetEventManager()->RemoveSystemContainer(pObject->GetSystemName());
		
		for( i = pObject->GetScopeItemCount() - 1; i >= 0; i-- )
		{
			CHMScopeItem* pParentItem = (CHMScopeItem*)pObject->GetScopeItem(i)->GetParent();
			if( pParentItem && GfxCheckObjPtr(pParentItem,CHMScopeItem) )
			{
				CHMObject* pParentObject = pParentItem->GetObjectPtr();
				if( pParentObject->IsKindOf(RUNTIME_CLASS(CAllSystemsGroup)) )
				{
					pParentItem->DestroyChild(this);
					pParentObject->RemoveChild(pObject);
				}
				else
				{
					((CSystemGroup*)pParentObject)->RemoveShortcut(pObject);
				}
				pParentItem->OnChangeChildState(HMS_NORMAL);
			}
		}

		pObject->Destroy(false);

		delete pObject;

		return S_OK;
	}
	else // this is a shortcut
	{
		// first query the scope item and see if it has any open property sheets
		if( IsPropertySheetOpen() )
		{
			AfxMessageBox(IDS_STRING_WARN_PROPPAGE_OPEN);
			return S_OK;
		}

		CHMScopeItem* pGroupItem = (CHMScopeItem*)GetParent();
		if( ! pGroupItem )
		{
			return S_FALSE;
		}

		CHMScopeItem* pTopmostParentItem = pGroupItem;
		while( pTopmostParentItem->GetParent() && ! pTopmostParentItem->GetParent()->IsKindOf(RUNTIME_CLASS(CRootScopeItem)) )
		{
			pTopmostParentItem = (CHMScopeItem*)pTopmostParentItem->GetParent();
		}

		CSystemGroup* pGroup = (CSystemGroup*)pGroupItem->GetObjectPtr();
		CSystemGroup* pTopmostGroup = (CSystemGroup*)pTopmostParentItem->GetObjectPtr();
		if( pGroup )
		{
			pGroup->RemoveShortcut(GetObjectPtr());
		}

		pGroupItem->OnChangeChildState(HMS_NORMAL);
    pGroupItem->SelectItem();
	}

	if( pItemToSelect )
	{
		pItemToSelect->SelectItem();
	}

	return S_OK;
}

HRESULT CSystemScopeItem::OnExpand(BOOL bExpand)
{
	TRACEX(_T("CSystemScopeItem::OnExpand\n"));
	TRACEARGn(bExpand);

	if( ! GetObjectPtr() )
	{
		return E_FAIL;
	}

	if( GetChildCount() == 1 )
	{
		m_pObject->EnumerateChildren();		
	}

	return CScopePaneItem::OnExpand(bExpand);
}


HRESULT CSystemScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CSystemScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_CUT, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
  hr = lpConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemsresultsview.cpp ===
// SystemsResultsView.cpp: implementation of the CSystemsResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SnapIn.h"
#include "SystemsResultsView.h"
#include "SplitPaneResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemsResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemsResultsView::CSystemsResultsView()
{

}

CSystemsResultsView::~CSystemsResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CSystemsResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CSystemsResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemstatuslistener.cpp ===
// SystemStatusListener.cpp: implementation of the CSystemStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "SystemStatusListener.h"
#include "HMSystemStatus.h"
#include "EventManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CSystemStatusListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystemStatusListener::CSystemStatusListener()
{
	SetEventQuery(IDS_STRING_STATUS_EVENTQUERY);
}

CSystemStatusListener::~CSystemStatusListener()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CSystemStatusListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CWbemClassObject StatusObject;

	if( ! CHECKHRESULT(hr = StatusObject.Create(pClassObject)) )
	{
		return hr;
	}

	StatusObject.SetMachineName(GetObjectPtr()->GetSystemName());

	EvtGetEventManager()->ProcessEvent(&StatusObject);

  return hr;
}

inline HRESULT CSystemStatusListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CSystemStatusListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult != S_OK )
	{
		if( hResult == WBEM_E_CALL_CANCELLED )
			return WBEM_NO_ERROR;

		GetObjectPtr()->SetState(HMS_NODATA,true,true);

		CRuleEvent* pUnknownEvent = new CRuleEvent;

		// create the GUID
		GUID ChildGuid;
		CoCreateGuid(&ChildGuid);

		OLECHAR szGuid[GUID_CCH];
		::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
		pUnknownEvent->m_sStatusGuid = OLE2CT(szGuid);
		pUnknownEvent->m_iState = 6;
		pUnknownEvent->m_sName.LoadString(IDS_STRING_CONNECTION);
		pUnknownEvent->m_sSystemName = GetObjectPtr()->GetSystemName();
		CTime time = CTime::GetCurrentTime();
		time.GetAsSystemTime(pUnknownEvent->m_st);
		
		CnxGetErrorString(hResult,GetObjectPtr()->GetSystemName(),pUnknownEvent->m_sMessage);		
		
		EvtGetEventManager()->ProcessUnknownEvent(GetObjectPtr()->GetSystemName(),pUnknownEvent);
		GetObjectPtr()->UpdateStatus();
						
	}
	else if( lFlags >= 1 && hResult == S_OK )
	{
		//GetObjectPtr()->Refresh();
	}


  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\systemstatuslistener.h ===
// SystemStatusListener.h: interface for the CSystemStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYSTEMSTATUSLISTENER_H__AA380C77_FD89_11D2_BDCE_0000F87A3912__INCLUDED_)
#define AFX_SYSTEMSTATUSLISTENER_H__AA380C77_FD89_11D2_BDCE_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CSystemStatusListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CSystemStatusListener)

// Construction/Destruction
public:
	CSystemStatusListener();
	virtual ~CSystemStatusListener();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);
};

#endif // !defined(AFX_SYSTEMSTATUSLISTENER_H__AA380C77_FD89_11D2_BDCE_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thexpressionpage.cpp ===
// THExpressionPage.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/20/00 v-marfin bug 61162 : Changed default rule to "The status changes to Critical"
// 03/27/00 v-marfin bug 60494 : Set correct value for dropdown combo box.
// 03/30/00 v-marfin bug 62674 : Fix to allow editing of string properties.
// 04/07/00 v-marfin bug 62685 : Do not accept empty property names in OnInitDialog.
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "THExpressionPage.h"
#include "HMObject.h"
#include "HMRuleConfiguration.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTHExpressionPage property page

IMPLEMENT_DYNCREATE(CTHExpressionPage, CHMPropertyPage)

CTHExpressionPage::CTHExpressionPage() : CHMPropertyPage(CTHExpressionPage::IDD)
{
	//{{AFX_DATA_INIT(CTHExpressionPage)
	m_sMeasure = _T("");
	m_sRuleType = _T("");
	m_sCompareTo = _T("");
	m_sDataElement = _T("");
	m_sDuration = _T("");
	m_iComparison = -1;
	m_iDurationType = -1;
	m_iFunctionType = -1;
	m_iCompareTo = -1;
	m_sNumericCompareTo = _T("");
	m_sTime = _T("");
	//}}AFX_DATA_INIT
  m_iIntervalMultiple = -1;

	m_sHelpTopic = _T("HMon21.chm::/dTHexp.htm");
}

CTHExpressionPage::~CTHExpressionPage()
{
}

void CTHExpressionPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTHExpressionPage)
	DDX_Control(pDX, IDC_COMBO_FUNCTION, m_FunctionType);
	DDX_Control(pDX, IDC_COMBO_RULE_TYPE, m_RuleType);
	DDX_Control(pDX, IDC_COMBO_MEASURE, m_Measure);
	DDX_Control(pDX, IDC_COMBO_COMPARISON, m_Comparison);
	DDX_CBString(pDX, IDC_COMBO_MEASURE, m_sMeasure);
	DDX_CBString(pDX, IDC_COMBO_RULE_TYPE, m_sRuleType);
	DDX_Text(pDX, IDC_EDIT_COMPARE_TO, m_sCompareTo);
	DDX_Text(pDX, IDC_EDIT_DATA_ELEMENT, m_sDataElement);
	DDX_Text(pDX, IDC_EDIT_DURATION, m_sDuration);
	DDX_CBIndex(pDX, IDC_COMBO_COMPARISON, m_iComparison);
	DDX_Radio(pDX, IDC_RADIO_DURATION_ANY, m_iDurationType);
	DDX_CBIndex(pDX, IDC_COMBO_FUNCTION, m_iFunctionType);
	DDX_CBIndex(pDX, IDC_COMBO_COMPARE_BOOLEAN, m_iCompareTo);
	DDX_Text(pDX, IDC_EDIT_COMPARE_NUMERIC, m_sNumericCompareTo);
	DDX_Text(pDX, IDC_STATIC_TIME, m_sTime);
	//}}AFX_DATA_MAP

	if( m_iComparison == 8 )
	{
		GetDlgItem(IDC_EDIT_DURATION)->EnableWindow(FALSE);
		GetDlgItem(IDC_SPIN1)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_DURATION)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_DURATION_ANY)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_COMPARE_TO)->EnableWindow(FALSE);
		GetDlgItem(IDC_COMBO_MEASURE)->EnableWindow(FALSE);		
    GetDlgItem(IDC_COMBO_FUNCTION)->EnableWindow(FALSE);		    
	}
	else
	{
		if( m_iDurationType == 1 )
		{
			GetDlgItem(IDC_EDIT_DURATION)->EnableWindow();
			GetDlgItem(IDC_SPIN1)->EnableWindow();
		}
		else
		{
			GetDlgItem(IDC_EDIT_DURATION)->EnableWindow(FALSE);
			GetDlgItem(IDC_SPIN1)->EnableWindow(FALSE);
		}
		GetDlgItem(IDC_RADIO_DURATION)->EnableWindow();
		GetDlgItem(IDC_RADIO_DURATION_ANY)->EnableWindow();
		GetDlgItem(IDC_EDIT_COMPARE_TO)->EnableWindow();
		GetDlgItem(IDC_COMBO_MEASURE)->EnableWindow();		
    GetDlgItem(IDC_COMBO_FUNCTION)->EnableWindow();		    
	}

  int iCurSel = m_Measure.GetCurSel();
  if( iCurSel == -1 || m_dwaPropertyTypes.GetSize() == 0 )
  {
    return;
  }

  if( iCurSel >= m_dwaPropertyTypes.GetSize() )
  {
    GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_HIDE);
    GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_SHOW);
    GetDlgItem(IDC_SPIN2)->ShowWindow(SW_SHOW);
    GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_HIDE);    
    return;
  }

	switch( m_dwaPropertyTypes[iCurSel] )
	{
		case CIM_SINT8:
		case CIM_SINT16:
		case CIM_SINT32:
		case CIM_SINT64:
		case CIM_UINT8:
		case CIM_UINT16:
		case CIM_UINT32:
		case CIM_UINT64:
		case CIM_REAL32:
		case CIM_REAL64:
		{
      GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_SPIN2)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_HIDE);    
      m_CurrentType = Numeric;
		}
		break;

		case CIM_BOOLEAN:
		{
      GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_SPIN2)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_HIDE);    
      m_CurrentType = Boolean;
		}
		break;

		case CIM_STRING:
		case CIM_DATETIME:
		case CIM_REFERENCE:
		case CIM_CHAR16:
		case CIM_OBJECT:
		{
      GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_SPIN2)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_SHOW);    
      m_CurrentType = String;
		}
		break;

		default:
		{
      GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_SPIN2)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_SHOW);    
      m_CurrentType = String;
		}
	}

  int iTotalSeconds = m_iIntervalMultiple*_ttoi(m_sDuration);
  int iHours = iTotalSeconds/3600;
  int iMinutes = (iTotalSeconds/60)%60;
  int iSeconds = iTotalSeconds%60;
  m_sTime.Empty();
  if( iHours )
  {
    CString sHrs;
    sHrs.Format(IDS_STRING_TIME_HOURS_FORMAT,iHours);
    m_sTime += sHrs;
  }

  if( iMinutes )
  {
    CString sMins;
    sMins.Format(IDS_STRING_TIME_MINUTES_FORMAT,iMinutes);
    m_sTime += sMins;
  }

  if( iSeconds )
  {
    CString sSecs;
    sSecs.Format(IDS_STRING_TIME_SECONDS_FORMAT,iSeconds);
    m_sTime += sSecs;
  }

  m_sTime.TrimRight(_T(", "));
  m_sTime = _T("(") + m_sTime + _T(")");  
  GetDlgItem(IDC_STATIC_TIME)->SetWindowText(m_sTime);
}

BEGIN_MESSAGE_MAP(CTHExpressionPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CTHExpressionPage)
	ON_CBN_EDITCHANGE(IDC_COMBO_COMPARISON, OnEditchangeComboComparison)
	ON_CBN_EDITCHANGE(IDC_COMBO_MEASURE, OnEditchangeComboMeasure)
	ON_CBN_EDITCHANGE(IDC_COMBO_RULE_TYPE, OnEditchangeComboRuleType)
	ON_EN_CHANGE(IDC_EDIT_COMPARE_TO, OnChangeEditCompareTo)
	ON_EN_CHANGE(IDC_EDIT_DATA_ELEMENT, OnChangeEditDataElement)
	ON_EN_CHANGE(IDC_EDIT_DURATION, OnChangeEditDuration)
	ON_CBN_SELENDOK(IDC_COMBO_COMPARISON, OnSelendokComboComparison)
	ON_CBN_SELENDOK(IDC_COMBO_MEASURE, OnSelendokComboMeasure)
	ON_CBN_SELENDOK(IDC_COMBO_RULE_TYPE, OnSelendokComboRuleType)
	ON_CBN_EDITCHANGE(IDC_COMBO_FUNCTION, OnEditchangeComboFunction)
	ON_CBN_SELENDOK(IDC_COMBO_FUNCTION, OnSelendokComboFunction)
	ON_BN_CLICKED(IDC_RADIO_DURATION, OnRadioDuration)
	ON_BN_CLICKED(IDC_RADIO_DURATION_ANY, OnRadioDurationAny)
	ON_EN_CHANGE(IDC_EDIT_COMPARE_NUMERIC, OnChangeEditCompareNumeric)
	ON_CBN_SELENDOK(IDC_COMBO_COMPARE_BOOLEAN, OnSelendokComboCompareBoolean)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTHExpressionPage message handlers

BOOL CTHExpressionPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

  GetDlgItem(IDC_COMBO_COMPARE_BOOLEAN)->ShowWindow(SW_HIDE);
  GetDlgItem(IDC_EDIT_COMPARE_NUMERIC)->ShowWindow(SW_HIDE);
  GetDlgItem(IDC_SPIN2)->ShowWindow(SW_HIDE);
  GetDlgItem(IDC_EDIT_COMPARE_TO)->ShowWindow(SW_SHOW);    

	CHMObject* pObject = GetObjectPtr();
	if( ! pObject )
	{
		return FALSE;
	}

	CHMRuleConfiguration rc;

	rc.Create(pObject->GetSystemName());

	rc.GetObject(pObject->GetObjectPath());

	rc.GetAllProperties();

	switch( rc.m_iState )
  {
    case 9:
    {
      m_RuleType.SetCurSel(0);  // critical
    }
    break;

    case 8:
    {
      m_RuleType.SetCurSel(1);
    }
    break;

    case 3:
    {
      m_RuleType.SetCurSel(2);
    }
    break;

    case 1:  // v-marfin 60494
    {
      m_RuleType.SetCurSel(3);
    }
    break;

    case 0:
    {
      // v-marfin bug 61162      m_RuleType.SetCurSel(3);
      // default rule for threshold should be "The status changes to critical"
      m_RuleType.SetCurSel(0);  
    }
    break;
  }

	m_Comparison.SetCurSel(rc.m_iRuleCondition);
	
	UpdateData();

	// get parent object to fill in the data element field
	CWbemClassObject* pClassObject = pObject->GetParentClassObject();

	if( ! pClassObject )
	{
		return FALSE;
	}

	CString sNamespace;
	CString sClass;
	CStringArray saPropertyNames;
  m_iIntervalMultiple = 0;

	pClassObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,m_sDataElement);
	pClassObject->GetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);
	pClassObject->GetProperty(IDS_STRING_MOF_PATH,sClass);


    //---------------------------------------------------------------------------------
    // 62685 : Do not accept empty property names
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saPropertyNames);

    int nSize = (int)saPropertyNames.GetSize()-1;
    for (int x=nSize; x>=0; x--)
    {
        if (saPropertyNames[x].IsEmpty())
        {
            saPropertyNames.RemoveAt(x);
        }
    }
    //
    // This is really a larger problem: When some data collectors are created, they
    // have default properties automatically created via the mof. But upon initial
    // creation, if the user changes the CLASS or INSTANCE for example on the property
    // page and selects different properties, the old properties are not removed. This
    // causes problems when new thresholds are created for the data collector. The solution
    // is to ensure that in the data collector property page, when key data such as CLASS
    // or INSTANCE changes, the existing properties are removed.
    // For now (beta) just remove the empty names from the array.
    //---------------------------------------------------------------------------------
    //

  pClassObject->GetProperty(IDS_STRING_MOF_COLLECTIONINTERVAL,m_iIntervalMultiple);

  if( ! sClass.IsEmpty() )
  {
	  int iIndex = -1;
	  if( (iIndex = sClass.Find(_T("."))) != -1 )
	  {
		  sClass = sClass.Left(iIndex);
	  }    
  }

  CString sQuery;
  pClassObject->GetProperty(IDS_STRING_MOF_QUERY,sQuery);

  if( sClass.IsEmpty() && !sQuery.IsEmpty() )
  {
    sQuery.MakeUpper();
	  int iIndex = -1;
	  if( (iIndex = sQuery.Find(_T("ISA"))) != -1 )
	  {
		  sClass = sQuery.Right(sQuery.GetLength()-iIndex-4);
		  iIndex = sClass.Find(_T(" "));
		  if( iIndex != -1 )
		  {
			  sClass = sClass.Left(iIndex);
		  }
		  sClass.TrimLeft(_T("\""));
		  sClass.TrimRight(_T("\""));
	  }
	  else
	  {
		  iIndex = sQuery.Find(_T("SELECT * FROM "));
		  if( iIndex != -1 )
		  {
			  sClass = sQuery.Right(sQuery.GetLength()-iIndex-14);
			  iIndex = sClass.Find(_T(" "));
			  if( iIndex != -1 )
			  {
				  sClass = sClass.Left(iIndex);
			  }
		  }
	  }
  }

	delete pClassObject;
	pClassObject = NULL;

	m_iFunctionType = rc.m_iUseFlag;

	if( rc.m_iRuleDuration )
	{
		m_sDuration.Format(_T("%d"),rc.m_iRuleDuration);
		m_iDurationType = 1;
		GetDlgItem(IDC_EDIT_DURATION)->EnableWindow();
	}
	else
	{
		m_iDurationType = 0;
	}

	// we need to get the WMI class object that the data element is pointing to
	// so that we can read in the type of each property
	pClassObject = new CWbemClassObject;
	pClassObject->SetNamespace(_T("\\\\") + pObject->GetSystemName() + _T("\\") + sNamespace);
	HRESULT hr = pClassObject->GetObject(sClass);
  pClassObject->GetPropertyNames(saPropertyNames);

    for( int i = 0; i < saPropertyNames.GetSize(); i++ )
	{
        CString sType;
        if( hr == S_OK )
        {
            long lType;
            pClassObject->GetPropertyType(saPropertyNames[i],sType);
			pClassObject->GetPropertyType(saPropertyNames[i],lType);

            // m_dwaPropertyTypes.Add(lType);  // v-marfin 62674

		    // v-marfin 61636 
		    // Send to function that will check first for dup entries and not add
		    // if duplicated.
		    // m_Measure.AddString(_T("[") + sType + _T("] ") + saPropertyNames[i]);
	  
		    if (AddToMeasureCombo(sType,saPropertyNames[i]))   // v-marfin 61811 Check to see if we added the item first
		    {
			    m_dwaPropertyTypes.Add(lType); // v-marfin 62674 Only add if it passed above check

		        if( saPropertyNames[i].CompareNoCase(rc.m_sPropertyName) == 0 )
		        {
			        if( lType == CIM_BOOLEAN )
			        {
			            if( rc.m_sRuleValue == _T("1") )
			            {
				            m_iCompareTo = 1;
			            }
			            else
			            {
				            m_iCompareTo = 0;
			            }
			        }
			        else
			        {
			            m_sCompareTo = rc.m_sRuleValue;
			            m_sNumericCompareTo = rc.m_sRuleValue;
			        }
		        }
            } // if (AddToMeasureCombo(sType,saPropertyNames[i])) 
        }
        else
        {
            m_Measure.AddString(saPropertyNames[i]);
        }
    }

    m_Measure.AddString(_T("HMNumInstancesCollected"));

	if( hr == S_OK )
	{
	    CString sType;
		pClassObject->GetPropertyType(rc.m_sPropertyName,sType);
		m_sMeasure = _T("[") + sType + _T("] ") + rc.m_sPropertyName;
	}
	else
	{
		m_sMeasure = rc.m_sPropertyName;
        m_sCompareTo = rc.m_sRuleValue;
	}

	delete pClassObject;
	pClassObject = NULL;

	UpdateData(FALSE);

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,INT_MAX-1);
    SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,INT_MAX-1);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTHExpressionPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

BOOL CTHExpressionPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! pClassObject )
	{
		return FALSE;
	}

  HRESULT hr = S_OK;

	int iIndex = -1;
	if( (iIndex = m_sMeasure.Find(_T("] "))) != -1 )
	{
		m_sMeasure = m_sMeasure.Right(m_sMeasure.GetLength()-(iIndex+2));
	}

  if( m_CurrentType == String )
  {
    hr = pClassObject->SetProperty(IDS_STRING_MOF_RULEVALUE,m_sCompareTo);
  }
  else if( m_CurrentType == Numeric )
  {
    hr = pClassObject->SetProperty(IDS_STRING_MOF_RULEVALUE,m_sNumericCompareTo);
  }
  else if( m_CurrentType == Boolean )
  {
    CString sValue;
    sValue.Format(_T("%d"),m_iCompareTo);
    hr = pClassObject->SetProperty(IDS_STRING_MOF_RULEVALUE,sValue);
  }

  switch( m_RuleType.GetCurSel() )
  {
    case 0:
    {
      hr = pClassObject->SetProperty(IDS_STRING_MOF_STATE,9);
    }
    break;

    case 1:
    {
      hr = pClassObject->SetProperty(IDS_STRING_MOF_STATE,8);
    }
    break;

    case 2:
    {
      hr = pClassObject->SetProperty(IDS_STRING_MOF_STATE,3);
    }
    break;

    case 3:
    {
		// v-marfin 60494 : Set correct value
      hr = pClassObject->SetProperty(IDS_STRING_MOF_STATE,1);   // 0
    }
    break;
  }
  hr = pClassObject->SetProperty(IDS_STRING_MOF_RULECONDITION,m_Comparison.GetCurSel());
  hr = pClassObject->SetProperty(IDS_STRING_MOF_PROPERTYNAME,m_sMeasure);
  hr = pClassObject->SetProperty(IDS_STRING_MOF_USEFLAG,m_iFunctionType);

	int iDuration;
	if( m_iDurationType == 1 )
	{
		iDuration = _ttoi(m_sDuration);
	}
	else
	{
		iDuration = 0;
	}
	hr = pClassObject->SetProperty(IDS_STRING_MOF_RULEDURATION,iDuration);
	pClassObject->SaveAllProperties();

  CString sName;
  pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

	delete pClassObject;

  CStringArray saPropertyNames;
  CWbemClassObject* pParentObject = GetObjectPtr()->GetParentClassObject();
  if( pParentObject )
  {
	  pParentObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saPropertyNames);
    bool bFound = false;
    for( int i = 0; i < saPropertyNames.GetSize(); i++ )
    {
      if( saPropertyNames[i] == m_sMeasure )
      {
        bFound = true;
        break;
      }
    }

    if( ! bFound )
    {
      saPropertyNames.Add(m_sMeasure);
      pParentObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saPropertyNames);
      pParentObject->SaveAllProperties();
    }

    delete pParentObject;
  }

  SetModified(FALSE);

  GetObjectPtr()->Rename(sName);

	return TRUE;
}

void CTHExpressionPage::OnEditchangeComboComparison() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();	
}

void CTHExpressionPage::OnEditchangeComboMeasure() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnEditchangeComboRuleType() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();	
}

void CTHExpressionPage::OnChangeEditCompareTo() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnChangeEditDataElement() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnChangeEditDuration() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnChangeEditCompareNumeric() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }
	
	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnSelendokComboComparison() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnSelendokComboMeasure() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnSelendokComboRuleType() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnEditchangeComboFunction() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();	
}

void CTHExpressionPage::OnSelendokComboFunction() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();	
}

void CTHExpressionPage::OnRadioDuration() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

void CTHExpressionPage::OnRadioDurationAny() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();	
	SetModified();
}


void CTHExpressionPage::OnSelendokComboCompareBoolean() 
{
  if( m_FunctionType.GetSafeHwnd() == NULL )
  {
    return;
  }

	UpdateData();
	SetModified();
}

//***********************************************************************
// AddToMeasureCombo   v-marfin   bug 61636
//***********************************************************************
BOOL CTHExpressionPage::AddToMeasureCombo(CString &sType, CString &sName)
{
	// Check for duplicate before adding.

	// Format it for display
	CString sEntry = _T("[") + sType + _T("] ") + sName;

	// Does it already exist?  -1 = search entire combo
	if (m_Measure.FindStringExact(-1, (LPCTSTR)sEntry ) != CB_ERR) 
		return FALSE;  // v-marfin 61811 : FALSE means we did not add it

	// Add it
	m_Measure.AddString(sEntry);

	return TRUE;
}

void CTHExpressionPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thgeneralpage.cpp ===
// THGeneralPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "THGeneralPage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTHGeneralPage property page

IMPLEMENT_DYNCREATE(CTHGeneralPage, CHMPropertyPage)

CTHGeneralPage::CTHGeneralPage() : CHMPropertyPage(CTHGeneralPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CTHGeneralPage)
	m_sComment = _T("");
	m_sName = _T("");
	m_sCreationDate = _T("");
	m_sModifiedDate = _T("");
	//}}AFX_DATA_INIT

	CnxPropertyPageInit();

	m_sHelpTopic = _T("HMon21.chm::/dTHgen.htm");

}

CTHGeneralPage::~CTHGeneralPage()
{
}

void CTHGeneralPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CTHGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTHGeneralPage)
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_sComment);
	DDX_Text(pDX, IDC_EDIT_NAME, m_sName);
	DDX_Text(pDX, IDC_STATIC_CREATED, m_sCreationDate);
	DDX_Text(pDX, IDC_STATIC_MODIFIED, m_sModifiedDate);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTHGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CTHGeneralPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CTHGeneralPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CTHGeneralPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ITHGeneralPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {5256615F-C9D1-11D2-BD8D-0000F87A3912}
static const IID IID_ITHGeneralPage =
{ 0x5256615f, 0xc9d1, 0x11d2, { 0xbd, 0x8d, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CTHGeneralPage, CHMPropertyPage)
	INTERFACE_PART(CTHGeneralPage, IID_ITHGeneralPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTHGeneralPage message handlers

BOOL CTHGeneralPage::OnInitDialog() 
{
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();
	
	m_sName = GetObjectPtr()->GetName();
	m_sComment = GetObjectPtr()->GetComment();
	GetObjectPtr()->GetCreateDateTime(m_sCreationDate);
	GetObjectPtr()->GetModifiedDateTime(m_sModifiedDate);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTHGeneralPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	CnxPropertyPageDestroy();	
}

void CTHGeneralPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

BOOL CTHGeneralPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	GetObjectPtr()->Rename(m_sName);
	GetObjectPtr()->UpdateComment(m_sComment);

  SetModified(FALSE);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thgeneralpage.h ===
#if !defined(AFX_THGENERALPAGE_H__52566160_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_THGENERALPAGE_H__52566160_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// THGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTHGeneralPage dialog

class CTHGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CTHGeneralPage)

// Construction
public:
	CTHGeneralPage();
	~CTHGeneralPage();

// Dialog Data
public:
	//{{AFX_DATA(CTHGeneralPage)
	enum { IDD = IDD_THRESHOLD_GENERAL };
	CString	m_sComment;
	CString	m_sName;
	CString	m_sCreationDate;
	CString	m_sModifiedDate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTHGeneralPage)
	public:
	virtual void OnFinalRelease();
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTHGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CTHGeneralPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THGENERALPAGE_H__52566160_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thmessagepage.h ===
#if !defined(AFX_THMESSAGEPAGE_H__6339279D_608F_11D3_BE4D_0000F87A3912__INCLUDED_)
#define AFX_THMESSAGEPAGE_H__6339279D_608F_11D3_BE4D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// THMessagePage.h : header file
//

#include "HMPropertyPage.h"
#include "InsertionStringMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CTHMessagePage dialog

class CTHMessagePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CTHMessagePage)

// Construction
public:
	CTHMessagePage();
	~CTHMessagePage();

// Dialog Data
	//{{AFX_DATA(CTHMessagePage)
	enum { IDD = IDD_THRESHOLD_MESSAGE };
	CEdit	m_ViolationMessage;
	CEdit	m_ResetMessage;
	CString	m_sResetMessage;
	CString	m_sViolationMessage;
	int		m_iID;
	//}}AFX_DATA
	CInsertionStringMenu m_InsertionMenu;
  CInsertionStringMenu m_InsertionMenu2;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTHMessagePage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTHMessagePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditResetMessage();
	afx_msg void OnChangeEditViolationMessage();
	afx_msg void OnButtonInsertion();
	afx_msg void OnButtonInsertion2();
	afx_msg void OnChangeEditId();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THMESSAGEPAGE_H__6339279D_608F_11D3_BE4D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thexpressionpage.h ===
#if !defined(AFX_THEXPRESSIONPAGE_H__5256615E_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_THEXPRESSIONPAGE_H__5256615E_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// THExpressionPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTHExpressionPage dialog

class CTHExpressionPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CTHExpressionPage)

  enum PropertyType { None, Numeric, String, Boolean };

// Construction
public:
	CTHExpressionPage();
	~CTHExpressionPage();

// Dialog Data
public:
	//{{AFX_DATA(CTHExpressionPage)
	enum { IDD = IDD_THRESHOLD_EXPRESSION };
	CComboBox	m_FunctionType;
	CComboBox	m_RuleType;
	CComboBox	m_Measure;
	CComboBox	m_Comparison;
	CString	m_sMeasure;
	CString	m_sRuleType;
	CString	m_sCompareTo;
	CString	m_sDataElement;
	CString	m_sDuration;
	int		m_iComparison;
	int		m_iDurationType;
	int		m_iFunctionType;
	int		m_iCompareTo;
	CString	m_sNumericCompareTo;
	CString	m_sTime;
	//}}AFX_DATA
  CDWordArray m_dwaPropertyTypes;  
  PropertyType m_CurrentType;
  int m_iIntervalMultiple;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTHExpressionPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL AddToMeasureCombo(CString &sType, CString &sName);
	// Generated message map functions
	//{{AFX_MSG(CTHExpressionPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditchangeComboComparison();
	afx_msg void OnEditchangeComboMeasure();
	afx_msg void OnEditchangeComboRuleType();
	afx_msg void OnChangeEditCompareTo();
	afx_msg void OnChangeEditDataElement();
	afx_msg void OnChangeEditDuration();
	afx_msg void OnSelendokComboComparison();
	afx_msg void OnSelendokComboMeasure();
	afx_msg void OnSelendokComboRuleType();
	afx_msg void OnEditchangeComboFunction();
	afx_msg void OnSelendokComboFunction();
	afx_msg void OnRadioDuration();
	afx_msg void OnRadioDurationAny();
	afx_msg void OnChangeEditCompareNumeric();
	afx_msg void OnSelendokComboCompareBoolean();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THEXPRESSIONPAGE_H__5256615E_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thpolicypage.cpp ===
// THPolicyPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "THPolicyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTHPolicyPage property page

IMPLEMENT_DYNCREATE(CTHPolicyPage, CHMPropertyPage)

CTHPolicyPage::CTHPolicyPage() : CHMPropertyPage(CTHPolicyPage::IDD)
{
	EnableAutomation();
	//{{AFX_DATA_INIT(CTHPolicyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CTHPolicyPage::~CTHPolicyPage()
{
}

void CTHPolicyPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMPropertyPage::OnFinalRelease();
}

void CTHPolicyPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTHPolicyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTHPolicyPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CTHPolicyPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CTHPolicyPage, CHMPropertyPage)
	//{{AFX_DISPATCH_MAP(CTHPolicyPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ITHPolicyPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {52566162-C9D1-11D2-BD8D-0000F87A3912}
static const IID IID_ITHPolicyPage =
{ 0x52566162, 0xc9d1, 0x11d2, { 0xbd, 0x8d, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CTHPolicyPage, CHMPropertyPage)
	INTERFACE_PART(CTHPolicyPage, IID_ITHPolicyPage, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTHPolicyPage message handlers

BOOL CTHPolicyPage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();
	
	m_NewBitmap.LoadBitmap(IDB_BITMAP_NEW);
	m_PropertiesBitmap.LoadBitmap(IDB_BITMAP_PROPERTIES);
	m_DeleteBitmap.LoadBitmap(IDB_BITMAP_DELETE);

	SendDlgItemMessage(IDC_BUTTON_NEW,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)(HBITMAP)m_NewBitmap);
	SendDlgItemMessage(IDC_BUTTON_PROPERTIES,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)(HBITMAP)m_PropertiesBitmap);
	SendDlgItemMessage(IDC_BUTTON_DELETE,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)(HBITMAP)m_DeleteBitmap);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTHPolicyPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	m_NewBitmap.DeleteObject();
	m_PropertiesBitmap.DeleteObject();
	m_DeleteBitmap.DeleteObject();

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thmessagepage.cpp ===
// THMessagePage.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/24/00 v-marfin 62191 : help link fix.
// 03/28/00 v-marfin 62489 : set range on alert ID spin control
//
//
#include "stdafx.h"
#include "snapin.h"
#include "THMessagePage.h"
#include "Rule.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTHMessagePage property page

IMPLEMENT_DYNCREATE(CTHMessagePage, CHMPropertyPage)

CTHMessagePage::CTHMessagePage() : CHMPropertyPage(CTHMessagePage::IDD)
{
	//{{AFX_DATA_INIT(CTHMessagePage)
	m_sResetMessage = _T("");
	m_sViolationMessage = _T("");
	m_iID = 0;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dTHmessage.htm");  // v-marfin 62191 : help link fix

}

CTHMessagePage::~CTHMessagePage()
{
}

void CTHMessagePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTHMessagePage)
	DDX_Control(pDX, IDC_EDIT_VIOLATION_MESSAGE, m_ViolationMessage);
	DDX_Control(pDX, IDC_EDIT_RESET_MESSAGE, m_ResetMessage);
	DDX_Text(pDX, IDC_EDIT_RESET_MESSAGE, m_sResetMessage);
	DDX_Text(pDX, IDC_EDIT_VIOLATION_MESSAGE, m_sViolationMessage);
	DDX_Text(pDX, IDC_EDIT_ID, m_iID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTHMessagePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CTHMessagePage)
	ON_EN_CHANGE(IDC_EDIT_RESET_MESSAGE, OnChangeEditResetMessage)
	ON_EN_CHANGE(IDC_EDIT_VIOLATION_MESSAGE, OnChangeEditViolationMessage)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION, OnButtonInsertion)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION2, OnButtonInsertion2)
	ON_EN_CHANGE(IDC_EDIT_ID, OnChangeEditId)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTHMessagePage message handlers

BOOL CTHMessagePage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();

	if( ! m_InsertionMenu.Create(&m_ViolationMessage,GetObjectPtr()) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION)->EnableWindow(FALSE);
	}

	if( ! m_InsertionMenu2.Create(&m_ResetMessage,GetObjectPtr()) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION2)->EnableWindow(FALSE);
	}
	
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

	pClassObject->GetLocaleStringProperty(IDS_STRING_MOF_MESSAGE,m_sViolationMessage);

	pClassObject->GetLocaleStringProperty(IDS_STRING_MOF_RESETMESSAGE,m_sResetMessage);

  pClassObject->GetProperty(IDS_STRING_MOF_ID,m_iID);

	delete pClassObject;
	pClassObject = NULL;

	m_ViolationMessage.SetCaretPos(CPoint(0,0));
	m_ResetMessage.SetCaretPos(CPoint(0,0));

	// v-marfin 62489 : set range on alert ID spin control
	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,INT_MAX-1);

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CTHMessagePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	pClassObject->SetProperty(IDS_STRING_MOF_MESSAGE,m_sViolationMessage);

	pClassObject->SetProperty(IDS_STRING_MOF_RESETMESSAGE,m_sResetMessage);

  pClassObject->SetProperty(IDS_STRING_MOF_ID,m_iID);

	pClassObject->SaveAllProperties();

	delete pClassObject;

	pClassObject = NULL;

  SetModified(FALSE);
	
	return TRUE;
}


void CTHMessagePage::OnChangeEditResetMessage() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified(TRUE);
}

void CTHMessagePage::OnChangeEditViolationMessage() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();		
	SetModified(TRUE);
}

void CTHMessagePage::OnButtonInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}

void CTHMessagePage::OnButtonInsertion2() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu2.DisplayMenu(pt);
	UpdateData();
	SetModified();
}

void CTHMessagePage::OnChangeEditId() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\tree.h ===
// Tree.h: interface for the CTreeNode and CTree classes.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TREE_H__988BB458_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
#define AFX_TREE_H__988BB458_8C93_11D3_BE83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////

template <class T>
class CTreeNode : public CObject
{
// Construction/Destruction
public:
	CTreeNode();
	~CTreeNode();

// Destroy
public:
	virtual void Destroy();

// Parent Members
public:
	CTreeNode<T>* GetParent() { return m_pParent; }
	void SetParent(CTreeNode<T>* pParent) { m_pParent = pParent; }
protected:
	CTreeNode<T>* m_pParent;

// Children Members
public:
	int GetChildCount();
	CTreeNode<T>* GetChild(int iIndex);
	int AddChild(CTreeNode<T>* pNode);
	void RemoveChild(CTreeNode<T>* pNode);
	void RemoveChild(int iIndex);
protected:
	CTypedPtrArray<CObArray,CTreeNode<T>*> m_Children;

// Associations
public:
	int GetAssocCount();
	CTreeNode<T>* GetAssoc(int iIndex);
	int AddAssoc(CTreeNode<T>* pNode);
	void RemoveAssoc(CTreeNode<T>* pNode);
	void RemoveAssoc(int iIndex);
protected:
	CTypedPtrArray<CObArray,CTreeNode<T>*> m_Associations;

// Object Members
public:
	T GetObject() { return m_Object; }
	void SetObject(T Object) { m_Object = Object; }
protected:
	T m_Object;
};

//////////////////////////////////////////////////////////////////////

template<class T>
class CTree : public CObject  
{
// Construction/Destruction
public:
	CTree();
	virtual ~CTree();

// Root Node
public:
	CTreeNode<T>* GetRootNode() { return m_pRootNode; }
	void SetRootNode(CTreeNode<T>* pRootNode) { m_pRootNode = pRootNode; }
protected:
	CTreeNode<T>* m_pRootNode;

};

#include "tree.inl"

//////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_TREE_H__988BB458_8C93_11D3_BE83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thpolicypage.h ===
#if !defined(AFX_THPOLICYPAGE_H__52566163_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_THPOLICYPAGE_H__52566163_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// THPolicyPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTHPolicyPage dialog

class CTHPolicyPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CTHPolicyPage)

// Construction
public:
	CTHPolicyPage();
	~CTHPolicyPage();

// Bitmap Handles
public:
	CBitmap m_NewBitmap;
	CBitmap m_PropertiesBitmap;
	CBitmap m_DeleteBitmap;

// Dialog Data
	//{{AFX_DATA(CTHPolicyPage)
	enum { IDD = IDD_THRESHOLD_POLICY };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTHPolicyPage)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTHPolicyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CTHPolicyPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THPOLICYPAGE_H__52566163_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\tree.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CTreeNode implementation

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

template <class T>
CTreeNode<T>::CTreeNode()
{
}

template <class T>
CTreeNode<T>::~CTreeNode()
{
	Destroy();
	if( GetObject() )
	{
		delete GetObject();
	}
}

//////////////////////////////////////////////////////////////////////
// Destroy
//////////////////////////////////////////////////////////////////////

template <class T>
inline void CTreeNode<T>::Destroy()
{
	for( int i = GetChildCount()-1; i >= 0; i-- )
	{
		RemoveChild(i);
	}
}

//////////////////////////////////////////////////////////////////////
// Children Members
//////////////////////////////////////////////////////////////////////
template <class T>
inline int CTreeNode<T>::GetChildCount()
{
	return (int)m_Children.GetSize();
}

template <class T>
inline CTreeNode<T>* CTreeNode<T>::GetChild(int iIndex)
{
	if( iIndex > m_Children.GetUpperBound() )
	{
		return NULL;
	}

	if( iIndex < 0 )
	{
		return NULL;
	}

	return m_Children[iIndex];
}

template <class T>
inline int CTreeNode<T>::AddChild(CTreeNode<T>* pNode)
{
	return (int)m_Children.Add(pNode);
}

template <class T>
inline void CTreeNode<T>::RemoveChild(CTreeNode<T>* pNode)
{
	for( int i = 0; i < GetChildCount(); i++ )
	{
		CTreeNode<T>* pChildNode = GetChild(i);
		if( pNode == pChildNode )
		{
			RemoveChild(i);
			return;
		}
	}
}

template <class T>
inline void CTreeNode<T>::RemoveChild(int iIndex)
{
	CTreeNode<T>* pChildNode = GetChild(iIndex);
	if( pChildNode )
	{
		delete pChildNode;
		m_Children.RemoveAt(iIndex);
	}
}

//////////////////////////////////////////////////////////////////////
// Association Members
//////////////////////////////////////////////////////////////////////
template <class T>
inline int CTreeNode<T>::GetAssocCount()
{
	return (int)m_Associations.GetSize();
}

template <class T>
inline CTreeNode<T>* CTreeNode<T>::GetAssoc(int iIndex)
{
	if( iIndex > m_Associations.GetUpperBound() )
	{
		return NULL;
	}

	if( iIndex < 0 )
	{
		return NULL;
	}

	return m_Associations[iIndex];
}

template <class T>
inline int CTreeNode<T>::AddAssoc(CTreeNode<T>* pNode)
{
	// disallow multiple associations for the same node
	for( int i = 0; i < GetAssocCount(); i++ )
	{
		if( pNode == GetAssoc(i) )
		{
			return i;
		}
	}

	return (int)m_Associations.Add(pNode);
}

template <class T>
inline void CTreeNode<T>::RemoveAssoc(CTreeNode<T>* pNode)
{
	for( int i = 0; i < GetAssocCount(); i++ )
	{
		CTreeNode<T>* pAssocNode = GetAssoc(i);
		if( pNode == pAssocNode )
		{
			RemoveAssoc(i);
			return;
		}
	}
}

template <class T>
inline void CTreeNode<T>::RemoveAssoc(int iIndex)
{
	CTreeNode<T>* pAssocNode = GetAssoc(iIndex);
	if( pAssocNode )
	{
		m_Associations.RemoveAt(iIndex);
	}
}

//////////////////////////////////////////////////////////////////////
// CTree implementation

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

template <class T>
CTree<T>::CTree()
{
	m_pRootNode = NULL;
}

template <class T>
CTree<T>::~CTree()
{
	if( m_pRootNode )
	{
		delete m_pRootNode;
		m_pRootNode = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\tree.cpp ===
// Tree.cpp: implementation of the CTree class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "Tree.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thschedulepage.cpp ===
// THSchedulePage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "THSchedulePage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTHSchedulePage property page

IMPLEMENT_DYNCREATE(CTHSchedulePage, CHMPropertyPage)

CTHSchedulePage::CTHSchedulePage() : CHMPropertyPage(CTHSchedulePage::IDD)
{
	//{{AFX_DATA_INIT(CTHSchedulePage)
	m_bFriday = FALSE;
	m_bMonday = FALSE;
	m_bSaturday = FALSE;
	m_bSunday = FALSE;
	m_bThursday = FALSE;
	m_bTuesday = FALSE;
	m_bWednesday = FALSE;
	m_EndTime_1 = 0;
	m_EndTime_2 = 0;
	m_OnceDailyTime = 0;
	m_StartTime_1 = 0;
	m_StartTime_2 = 0;
	m_iDataCollection = -1;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dTHsched.htm");

}

CTHSchedulePage::~CTHSchedulePage()
{
}

void CTHSchedulePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTHSchedulePage)
	DDX_Check(pDX, IDC_CHECK_FRIDAY, m_bFriday);
	DDX_Check(pDX, IDC_CHECK_MONDAY, m_bMonday);
	DDX_Check(pDX, IDC_CHECK_SATURDAY, m_bSaturday);
	DDX_Check(pDX, IDC_CHECK_SUNDAY, m_bSunday);
	DDX_Check(pDX, IDC_CHECK_THURSDAY, m_bThursday);
	DDX_Check(pDX, IDC_CHECK_TUESDAY, m_bTuesday);
	DDX_Check(pDX, IDC_CHECK_WEDNESDAY, m_bWednesday);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_1, m_EndTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_2, m_EndTime_2);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_ONCE, m_OnceDailyTime);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_1, m_StartTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_2, m_StartTime_2);
	DDX_Radio(pDX, IDC_RADIO_ALL_DAY, m_iDataCollection);
	//}}AFX_DATA_MAP

	if( pDX->m_bSaveAndValidate )
	{
		m_iActiveDays = 0;

		if( m_bSunday )
		{
			m_iActiveDays |= 0x00000001;
		}

		if( m_bMonday )
		{
			m_iActiveDays |= 0x00000002;
		}

		if( m_bTuesday )
		{
			m_iActiveDays |= 0x00000004;
		}

		if( m_bWednesday )
		{
			m_iActiveDays |= 0x00000008;
		}

		if( m_bThursday )
		{
			m_iActiveDays |= 0x00000010;
		}

		if( m_bFriday )
		{
			m_iActiveDays |= 0x00000020;
		}

		if( m_bSaturday )
		{
			m_iActiveDays |= 0x00000040;
		}
	}

	switch( m_iDataCollection )
	{
		case 0:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_ONCE)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

		case 1:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_ONCE)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(TRUE);
		}
		break;

		case 2:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_ONCE)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

		case 3:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_ONCE)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;
	}
}


BEGIN_MESSAGE_MAP(CTHSchedulePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CTHSchedulePage)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY, OnRadioAllDay)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY_EXCEPT, OnRadioAllDayExcept)
	ON_BN_CLICKED(IDC_RADIO_ONCE_DAILY, OnRadioOnceDaily)
	ON_BN_CLICKED(IDC_RADIO_ONLY_FROM, OnRadioOnlyFrom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTHSchedulePage message handlers

BOOL CTHSchedulePage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();
	
	CHMObject* pObject = GetObjectPtr();
	if( ! pObject )
	{
		return FALSE;
	}

	CWbemClassObject* pClassObject = pObject->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// get the active days
	pClassObject->GetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// get the begin time
	CTime BeginTime;
	pClassObject->GetProperty(IDS_STRING_MOF_BEGINTIME,BeginTime,false);
	
	// get the end time
	CTime EndTime;
	pClassObject->GetProperty(IDS_STRING_MOF_ENDTIME,EndTime,false);

	delete pClassObject;
	pClassObject = NULL;

	if( BeginTime.GetHour() == 0 && BeginTime.GetMinute() == 0 && EndTime.GetHour() == 23 && EndTime.GetMinute() == 59 )
	{
		m_iDataCollection = 0;
	}
	else if( BeginTime.GetHour() == EndTime.GetHour() && BeginTime.GetMinute() == EndTime.GetMinute() )
	{
		m_iDataCollection = 3;
		m_OnceDailyTime = BeginTime;
	}
	else if( BeginTime.GetHour() > EndTime.GetHour() )
	{
		m_iDataCollection = 2;
		m_EndTime_2 = BeginTime;
		m_StartTime_2 = EndTime;
	}
	else
	{
		m_iDataCollection = 1;
		m_StartTime_1 = BeginTime;
		m_EndTime_1 = EndTime;
	}

	if( m_iActiveDays & 0x00000001 )
	{
		m_bSunday = TRUE;
	}

	if( m_iActiveDays & 0x00000002 )
	{
		m_bMonday = TRUE;
	}

	if( m_iActiveDays & 0x00000004 )
	{
		m_bTuesday = TRUE;
	}

	if( m_iActiveDays & 0x00000008 )
	{
		m_bWednesday = TRUE;
	}

	if( m_iActiveDays & 0x00000010 )
	{
		m_bThursday = TRUE;
	}

	if( m_iActiveDays & 0x00000020 )
	{
		m_bFriday = TRUE;
	}

	if( m_iActiveDays & 0x00000040 )
	{
		m_bSaturday = TRUE;
	}


	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTHSchedulePage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CTHSchedulePage::OnRadioAllDay() 
{
	UpdateData();	
	SetModified();
}

void CTHSchedulePage::OnRadioAllDayExcept() 
{
	UpdateData();	
	SetModified();
}

void CTHSchedulePage::OnRadioOnceDaily() 
{
	UpdateData();	
	SetModified();
}

void CTHSchedulePage::OnRadioOnlyFrom() 
{
	UpdateData();	
	SetModified();
}

BOOL CTHSchedulePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CTime BeginTime;
	CTime EndTime;

	switch( m_iDataCollection )
	{
		case 0: // all day
		{
			CTime time(0,0,0,23,59,0);
			EndTime = time;
		}
		break;

		case 1:	// only from x to y
		{
			CTime time1(0,0,0,m_StartTime_1.GetHour(),m_StartTime_1.GetMinute(),0);
			CTime time2(0,0,0,m_EndTime_1.GetHour(),m_EndTime_1.GetMinute(),0);
			BeginTime = time1;
			EndTime = time2;
		}
		break;

		case 2: // all day except x to y
		{
			CTime time1(0,0,0,m_EndTime_2.GetHour(),m_EndTime_2.GetMinute(),0);
			CTime time2(0,0,0,m_StartTime_2.GetHour(),m_StartTime_2.GetMinute(),0);
			BeginTime = time1;
			EndTime = time2;
		}
		break;

		case 3: // once a day at x
		{
			CTime time(0,0,0,m_OnceDailyTime.GetHour(),m_OnceDailyTime.GetMinute(),0);
			BeginTime = EndTime = time;
		}
		break;

	}


	// update the agent object
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// set the active days
	pClassObject->SetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// set the begin time
	pClassObject->SetProperty(IDS_STRING_MOF_BEGINTIME,BeginTime,false);

	// set the end time
	pClassObject->SetProperty(IDS_STRING_MOF_ENDTIME,EndTime,false);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\thschedulepage.h ===
#if !defined(AFX_THSCHEDULEPAGE_H__A455578F_DBB8_11D2_BDA5_0000F87A3912__INCLUDED_)
#define AFX_THSCHEDULEPAGE_H__A455578F_DBB8_11D2_BDA5_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// THSchedulePage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTHSchedulePage dialog

class CTHSchedulePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CTHSchedulePage)

// Construction
public:
	CTHSchedulePage();
	~CTHSchedulePage();

// Dialog Data
	//{{AFX_DATA(CTHSchedulePage)
	enum { IDD = IDD_THRESHOLD_SCHEDULE };
	CSpinButtonCtrl	m_Spin2;
	CSpinButtonCtrl	m_Spin1;
	CComboBox	m_Units;
	BOOL	m_bFriday;
	BOOL	m_bMonday;
	BOOL	m_bSaturday;
	BOOL	m_bSunday;
	BOOL	m_bThursday;
	BOOL	m_bTuesday;
	BOOL	m_bWednesday;
	CTime	m_EndTime_1;
	CTime	m_EndTime_2;
	CTime	m_OnceDailyTime;
	CTime	m_StartTime_1;
	CTime	m_StartTime_2;
	int		m_iDataCollection;
	//}}AFX_DATA

	int m_iActiveDays;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTHSchedulePage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTHSchedulePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioAllDay();
	afx_msg void OnRadioAllDayExcept();
	afx_msg void OnRadioOnceDaily();
	afx_msg void OnRadioOnlyFrom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THSCHEDULEPAGE_H__A455578F_DBB8_11D2_BDA5_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wbemclassobject.cpp ===
// WbemClassObject.cpp: implementation of the CWbemClassObject class.
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/26/00 v-marfin 60751 : In function CreateEnumerator(), if LogicalDisk, assume that error 0x80041001 is due to the 
//                           fact the user does not have logicaldisk perfmon turned on.
//                           Advise them to run "DiskPerf -YV" and reboot.
// 03/30/00 v-marfin 62531 : Allow an empty array as a means of removing a property of type array.
//

#include "stdafx.h"
#include "SnapIn.h"
#include "WbemClassObject.h"
#include "WbemEventListener.h"
#include <objbase.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CWbemClassObject,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWbemClassObject::CWbemClassObject()
{
  m_pIEnumerator = NULL;
  m_pIWbemClassObject = NULL;
}

CWbemClassObject::~CWbemClassObject()
{
  Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

HRESULT CWbemClassObject::Create(const CString& sMachineName)
{
  TRACEX(_T("CWbemClassObject::Create\n"));
  TRACEARGs(sMachineName);

  m_sMachineName = sMachineName;

  return S_OK;
}

HRESULT CWbemClassObject::Create(IWbemClassObject* pObject)
{
  TRACEX(_T("CWbemClassObject::Create\n"));
	TRACEARGn(pObject);

  ASSERT(pObject);
  if( pObject )
  {
    m_pIWbemClassObject = pObject;
    return S_OK;
  }
  else
  {
    return E_FAIL;
  }
}

void CWbemClassObject::Destroy()
{
  TRACEX(_T("CWbemClassObject::Destroy\n"));

  if( m_pIEnumerator )
  {
    m_pIEnumerator->Release();
    m_pIEnumerator = NULL;
  }

  if( m_pIWbemClassObject )
  {
    m_pIWbemClassObject->Release();
    m_pIWbemClassObject = NULL;
  }

	m_sMachineName.Empty();
	m_sNamespace.Empty();
}

//////////////////////////////////////////////////////////////////////
// Property Operations
//////////////////////////////////////////////////////////////////////


// v-marfin

//***********************************************************************************
// GetRawProperty
//
// This function retreives the raw property of the object. No conversions take
// place on it, no formatting, nothing. The user is responsible for determining
// the format and performing any conversions etc.
//***********************************************************************************
HRESULT CWbemClassObject::GetRawProperty(const CString& sProperty, VARIANT& vPropValue)
{
	TRACEX(_T("CWbemClassObject::GetRawProperty\n"));
	TRACEARGs(sProperty);

	ASSERT(m_pIWbemClassObject);
	if( m_pIWbemClassObject == NULL )
	{
		return E_FAIL;
	}

	BSTR bsProperty = sProperty.AllocSysString();
	ASSERT(bsProperty);
	if( bsProperty == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IWbemClassObject::GetRawProperty failed.\n"));
		::SysFreeString(bsProperty);
		return hr;
	}    

	::SysFreeString(bsProperty);

  return hr;
}


//***********************************************************************************
// SetRawProperty
//
// This function sets the raw property of the object. No conversions take
// place on it, no formatting, nothing. The user is responsible for ensuring
// that the data is in its proper format etc.
//***********************************************************************************
HRESULT CWbemClassObject::SetRawProperty(const CString& sProperty, VARIANT& vPropValue)
{
	TRACEX(_T("CWbemClassObject::SetRawProperty\n"));
	TRACEARGs(sProperty);

	ASSERT(m_pIWbemClassObject);
	if( m_pIWbemClassObject == NULL )
	{
		return E_FAIL;
	}

	BSTR bsProperty = sProperty.AllocSysString();
	ASSERT(bsProperty);
	if( bsProperty == NULL )
	{
		return E_FAIL;
	}


	HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IWbemClassObject::SetRawProperty failed.\n"));
		TRACEARGn(hr);
		::SysFreeString(bsProperty);
		return hr;
	}

	VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

	return S_OK;
}















HRESULT CWbemClassObject::GetPropertyNames(CStringArray& saNames)
{
  TRACEX(_T("CWbemClassObject::GetPropertyNames\n"));

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    TRACE(_T("FAILED : m_pIWbemClassObject is NULL\n"));
    return E_FAIL;
  }
	
	HRESULT hr = S_OK;
	SAFEARRAY* psa = NULL;
	if( ! CHECKHRESULT(hr = m_pIWbemClassObject->GetNames(NULL,WBEM_FLAG_ALWAYS|WBEM_FLAG_NONSYSTEM_ONLY,NULL,&psa)) )
	{
		return hr;
	}

	COleSafeArray osa(*psa,VT_BSTR);	

	long lLower = 0L;
	long lUpper = -1L;

	osa.GetLBound(1L,&lLower);
	osa.GetUBound(1L,&lUpper);

	for( long i = lLower; i <= lUpper; i++ )
	{
		BSTR bsPropertyName;
		osa.GetElement(&i,&bsPropertyName);
		saNames.Add(CString(bsPropertyName));
	}

	return hr;
}

HRESULT CWbemClassObject::GetPropertyType(const CString& sPropertyName, CString& sType)
{
  TRACEX(_T("CWbemClassObject::GetPropertyType\n"));

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    TRACE(_T("FAILED : m_pIWbemClassObject is NULL\n"));
    return E_FAIL;
  }
	
	HRESULT hr = S_OK;

	CIMTYPE type;

	if( ! CHECKHRESULT( hr = GetPropertyType(sPropertyName,type) ) )
	{
		return hr;
	}

	sType.Empty();

	if( type & CIM_FLAG_ARRAY )
	{
		sType.LoadString(IDS_STRING_ARRAY_OF);
		type &= ~CIM_FLAG_ARRAY;
	}

	CString sResString;
	switch( type )
	{
		case CIM_ILLEGAL:
		{
			sResString.LoadString(IDS_STRING_CIM_ILLEGAL);
			sType += sResString;
		}
		break;

		case CIM_EMPTY:
		{
			sResString.LoadString(IDS_STRING_CIM_EMPTY);
			sType += sResString;
		}
		break;

		case CIM_SINT8:
		case CIM_SINT16:
		case CIM_SINT32:
		case CIM_SINT64:
		{
			sResString.LoadString(IDS_STRING_CIM_SINT);
			sType += sResString;
		}
		break;


		case CIM_UINT8:
		case CIM_UINT16:
		case CIM_UINT32:
		case CIM_UINT64:
		{
			sResString.LoadString(IDS_STRING_CIM_UINT);
			sType += sResString;
		}
		break;

		case CIM_REAL32:
		case CIM_REAL64:
		{
			sResString.LoadString(IDS_STRING_CIM_REAL);
			sType += sResString;
		}
		break;

		case CIM_BOOLEAN:
		{
			sResString.LoadString(IDS_STRING_CIM_BOOLEAN);
			sType += sResString;
		}
		break;

		case CIM_STRING:
		{
			sResString.LoadString(IDS_STRING_CIM_STRING);
			sType += sResString;
		}
		break;

		case CIM_DATETIME:
		{
			sResString.LoadString(IDS_STRING_CIM_DATETIME);
			sType += sResString;
		}
		break;

		case CIM_REFERENCE:
		{
			sResString.LoadString(IDS_STRING_CIM_REFERENCE);
			sType += sResString;
		}
		break;

		case CIM_CHAR16:
		{
			sResString.LoadString(IDS_STRING_CIM_CHAR16);
			sType += sResString;
		}
		break;

		case CIM_OBJECT:
		{
			sResString.LoadString(IDS_STRING_CIM_OBJECT);
			sType += sResString;
		}
		break;

		default:
		{
			hr = E_FAIL;
			ASSERT(FALSE);
			sType.Empty();
		}
	}

	return hr;
}

HRESULT CWbemClassObject::GetPropertyType(const CString& sPropertyName, CIMTYPE& Type)
{
  TRACEX(_T("CWbemClassObject::GetPropertyType\n"));

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    TRACE(_T("FAILED : m_pIWbemClassObject is NULL\n"));
    return E_FAIL;
  }
	
	HRESULT hr = S_OK;

	BSTR bsProperty = sPropertyName.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

	hr = m_pIWbemClassObject->Get(bsProperty, 0L, NULL, &Type, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( TYPE ) failed.\n"));
		::SysFreeString(bsProperty);
    return hr;
  }

	::SysFreeString(bsProperty);

  return hr;

}

HRESULT CWbemClassObject::SaveAllProperties()
{
  TRACEX(_T("CWbemClassObject::SaveAllProperties\n"));

  ASSERT(!m_sMachineName.IsEmpty());

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);
  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    TRACE(_T("FAILED : m_pIWbemClassObject is NULL\n"));
    return E_FAIL;
  }

  // update this instance
  hr = pServices->PutInstance(m_pIWbemClassObject,WBEM_FLAG_CREATE_OR_UPDATE,NULL,NULL);
	
	pServices->Release();

  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemServices::PutInstance failed\n"));
    return hr;
  }



  return hr;
}

bool CWbemClassObject::GetPropertyValueFromString(const CString& sWMIString, const CString& sPropName, CString& sProperty)
{
  TRACEX(_T("CWbemClassObject::GetPropertyValueFromString\n"));
  TRACEARGs(sWMIString);
	TRACEARGs(sPropName);

	int iStart = -1;
	if( (iStart = sWMIString.Find(sPropName)) != -1 )
	{
		sProperty = sWMIString.Right(sWMIString.GetLength() - iStart);
		int iEnd = sProperty.Find(_T(","));
		if( iEnd == -1 )
		{
			iEnd = sProperty.Find(_T(" AND "));
			if( iEnd == -1 )
			{
				iEnd = sProperty.GetLength();
			}
		}
		sProperty = sProperty.Left(iEnd);
		iStart = sProperty.Find(_T("=")) + 1;
		sProperty = sProperty.Right(sProperty.GetLength()-iStart);
		sProperty.TrimLeft(_T("\""));
		sProperty.TrimRight(_T("\""));
		return true;
	}

	sProperty.Empty();

	return false; // did not find the property name in the path
}

//////////////////////////////////////////////////////////////////////
// WBEM Operations
//////////////////////////////////////////////////////////////////////

HRESULT CWbemClassObject::GetObject(const CString& sObjectPath)
{
  TRACEX(_T("CWbemClassObject::GetObject\n"));
  TRACEARGs(sObjectPath);

  // do not call me if you have not called Destroy first
  ASSERT(m_pIWbemClassObject == NULL);
  
  ASSERT(sObjectPath.GetLength());
  if( sObjectPath.IsEmpty() )
  {
    TRACE(_T("FAILED : sObjectPath is NULL. Failed.\n"));
    return E_FAIL;
  }

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  VERIFY(pServices);
  
  // get the object's signature
	BSTR bsPath = sObjectPath.AllocSysString();
  
	hr = pServices->GetObject(bsPath, 0, NULL, &m_pIWbemClassObject, NULL);
	
	pServices->Release();

  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemServices::GetObject failed.\n"));
		::SysFreeString(bsPath);
    return hr;
  }
	::SysFreeString(bsPath);
	
	return hr;
}

HRESULT CWbemClassObject::GetObjectText(CString& sText)
{
  TRACEX(_T("CWbemClassObject::GetObjectText\n"));

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	HRESULT hr = S_OK;

	BSTR bsText = NULL;

	if( ! CHECKHRESULT(hr = m_pIWbemClassObject->GetObjectText(0L,&bsText)) )
	{
		return hr;
	}

	sText = bsText;

	::SysFreeString(bsText);

	return hr;	
}

HRESULT CWbemClassObject::ExecQuery(BSTR bsQueryString)
{
  TRACEX(_T("CWbemClassObject::ExecQuery\n"));
  TRACEARGs(bsQueryString);

	ASSERT(bsQueryString);
	if( bsQueryString == NULL )
	{
		TRACE(_T("FAILED : bsQueryString is NULL. CWbemClassObject::ExecQuery Failed.\n"));
		return E_FAIL;
	}

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);

	BSTR bsLanguage = SysAllocString(_T("WQL"));
	m_pIEnumerator = NULL;

	// Issue Query
	hr = pServices->ExecQuery(bsLanguage,bsQueryString,WBEM_FLAG_BIDIRECTIONAL,0,&m_pIEnumerator);
	
	SysFreeString(bsLanguage);
	pServices->Release();

	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IWbemServices::ExecQuery failed.\n"));
		return hr;
	}

	ASSERT(m_pIEnumerator);

  SetBlanket(m_pIEnumerator);

  return hr;
}

HRESULT CWbemClassObject::ExecQueryAsync(BSTR bsQueryString, CWbemEventListener* pListener)
{
  TRACEX(_T("CWbemClassObject::ExecQueryAsync\n"));
  TRACEARGs(bsQueryString);

	ASSERT(bsQueryString);
	if( bsQueryString == NULL )
	{
		TRACE(_T("FAILED : bsQueryString is NULL. CWbemClassObject::ExecQuery Failed.\n"));
		return E_FAIL;
	}
	
  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);

	BSTR bsLanguage = SysAllocString(_T("WQL"));
	m_pIEnumerator = NULL;

	// Issue Query
	hr = pServices->ExecQueryAsync(bsLanguage,bsQueryString,WBEM_FLAG_BIDIRECTIONAL,0,pListener->GetSink());
	
	SysFreeString(bsLanguage);
	pServices->Release();

	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IWbemServices::ExecQuery failed.\n"));
		return hr;
	}

  return hr;
}

HRESULT CWbemClassObject::CreateEnumerator(BSTR bsClassName)
{
  TRACEX(_T("CWbemClassObject::CreateEnumerator\n"));

  ASSERT(bsClassName);
  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
    DisplayErrorMsgBox(hr);
		return hr;
	}

	ASSERT(pServices);

	hr = pServices->CreateInstanceEnum(bsClassName,WBEM_FLAG_SHALLOW|                                      
                                      WBEM_FLAG_BIDIRECTIONAL, NULL, &m_pIEnumerator);
	pServices->Release();

	if( !CHECKHRESULT(hr) )
	{
	  // v-marfin 60751 : If LogicalDisk, assume that error 0x80041001 is due to the 
	  //                  fact the user does not have logicaldisk perfmon turned on.
	  //                  Advise them to run "DiskPerf -YV" and reboot.
		if ((hr == 0x80041001) && (CString(bsClassName).CompareNoCase(_T("LogicalDisk")) == 0))
		{
			AfxMessageBox(IDS_WARNING_DISKPERF);
			return hr;
		}

		DisplayErrorMsgBox(hr);
		return hr;
	}

  SetBlanket(m_pIEnumerator);

  return hr;
}

HRESULT CWbemClassObject::CreateClassEnumerator(BSTR bsClassName)
{
  TRACEX(_T("CWbemClassObject::CreateClassEnumerator\n"));
	TRACEARGs(bsClassName);

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
    DisplayErrorMsgBox(hr);
		return hr;
	}

  ASSERT(pServices);

	hr = pServices->CreateClassEnum(bsClassName,WBEM_FLAG_DEEP|
                                      WBEM_FLAG_RETURN_IMMEDIATELY|
                                      WBEM_FLAG_FORWARD_ONLY, NULL, &m_pIEnumerator);
	
	pServices->Release();  
	
	if( !CHECKHRESULT(hr) )
  {    
    DisplayErrorMsgBox(hr);
    return hr;
  }

  SetBlanket(m_pIEnumerator);

  return hr;
}

HRESULT CWbemClassObject::CreateAsyncEnumerator(BSTR bsClassName, CWbemEventListener* pListener)
{
  TRACEX(_T("CWbemClassObject::CreateEnumerator\n"));

  ASSERT(bsClassName);
  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);

	hr = pServices->CreateInstanceEnumAsync(bsClassName,WBEM_FLAG_SHALLOW|
                                      WBEM_FLAG_RETURN_IMMEDIATELY|
                                      WBEM_FLAG_FORWARD_ONLY, NULL, pListener->GetSink() );
	pServices->Release();

  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  return hr;
}

HRESULT CWbemClassObject::GetNextObject(ULONG& uReturned)
{
  ASSERT(m_pIEnumerator);
  if( m_pIEnumerator == NULL )
  {
    return E_FAIL;
  }

  if( m_pIWbemClassObject )
  {
    m_pIWbemClassObject->Release();
    m_pIWbemClassObject = NULL;
  }

  HRESULT hr = m_pIEnumerator->Next(WBEM_INFINITE,1,&m_pIWbemClassObject,&uReturned);
  if( FAILED(hr) )
  {
		TRACEARGn(hr);
    TRACE(_T("WARNING : IEnumWbemClassObject::Next failed to find another instance\n"));    
    return hr;
  }

  return hr;
}

HRESULT CWbemClassObject::Reset()
{
  TRACEX(_T("CWbemClassObject::Reset\n"));
  ASSERT(m_pIEnumerator);
  if( m_pIEnumerator == NULL )
  {
    return E_FAIL;
  }

	HRESULT hr = m_pIEnumerator->Reset();
	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IEnumWbemClassObject::Reset failed.\n"));		
		return hr;
	}

	return hr;
}

HRESULT CWbemClassObject::CreateInstance(BSTR bsClassName)
{
  TRACEX(_T("CWbemClassObject::CreateInstance\n"));
  TRACEARGs(bsClassName);

  // do not call me if you have not called Destroy first
  ASSERT(m_pIWbemClassObject == NULL);
  
  ASSERT(bsClassName);
  if( bsClassName == NULL )
  {
    TRACE(_T("FAILED : bsClassName is NULL. Failed.\n"));
    return E_FAIL;
  }

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);
  
  // get the object's signature
  IWbemClassObject* pClassObject = NULL;
  hr = pServices->GetObject(bsClassName, 0, NULL, &pClassObject, NULL);
	pServices->Release();
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemServices::GetObject failed.\n"));
    return hr;
  }
	
  // create an instance of the class based on the signature
  ASSERT(pClassObject);
  hr = pClassObject->SpawnInstance(0,&m_pIWbemClassObject);  
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::SpawnInstance failed.\n"));
    pClassObject->Release();
    return hr;
  }

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    TRACE(_T("FAILED : An unexpected error occurred with IWbemClassObject::SpawnInstance. Failed\n"));
    return E_FAIL;
  }

  pClassObject->Release();


  return S_OK;
}

HRESULT CWbemClassObject::DeleteInstance(const CString& sClassObjectPath)
{
  TRACEX(_T("CWbemClassObject::DeleteInstance"));
  TRACEARGs(sClassObjectPath);

  if( sClassObjectPath.IsEmpty() )
  {
    TRACE(_T("FAILED : bsClassInstanceName is NULL. Failed.\n"));
    return E_FAIL;
  }

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);
	
	BSTR bsClassInstanceName = sClassObjectPath.AllocSysString();
  hr = pServices->DeleteInstance(bsClassInstanceName,0L,NULL,NULL);
	::SysFreeString(bsClassInstanceName);
	pServices->Release();

  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemServices::DeleteInstance failed.\n"));    
    return hr;
  }

  return hr;
}

HRESULT CWbemClassObject::GetMethod(const CString& sMethodName, CWbemClassObject&	MethodInput)
{
  TRACEX(_T("CWbemClassObject::GetMethod\n"));
	TRACEARGs(sMethodName);

	if( m_pIWbemClassObject == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	IWbemClassObject* pInClass = NULL;
	IWbemClassObject* pOutClass = NULL;
	BSTR bsMethodName = sMethodName.AllocSysString();

	HRESULT hr = m_pIWbemClassObject->GetMethod(bsMethodName, 0, &pInClass, &pOutClass); 
	if( ! CHECKHRESULT(hr) || pInClass == NULL )
	{
		::SysFreeString(bsMethodName);
		return hr;
	}

	ASSERT(pInClass);
		
	IWbemClassObject* pInInst = NULL;

	if( pInClass )
	{
		hr = pInClass->SpawnInstance(0, &pInInst);
		pInClass->Release();
		if( ! CHECKHRESULT(hr) || pInInst == NULL )
		{		
			::SysFreeString(bsMethodName);
			return hr;
		}
	}

	if( pOutClass )
	{
		pOutClass->Release();
	}

	ASSERT(pInInst);	

	MethodInput.Create(pInInst);

	::SysFreeString(bsMethodName);

	return S_OK;
}

HRESULT CWbemClassObject::ExecuteMethod(const CString& sMethodName, const CString& sArgumentName, const CString& sArgumentValue, int& iReturnValue)
{
  TRACEX(_T("CWbemClassObject::ExecuteMethod\n"));
	TRACEARGs(sMethodName);
	TRACEARGs(sArgumentName);
	TRACEARGs(sArgumentValue);

	if( sMethodName.IsEmpty() )
	{
		return E_FAIL;
	}

	if( sArgumentName.IsEmpty() )
	{
		return E_FAIL;
	}

	if( sArgumentValue.IsEmpty() )
	{
		return E_FAIL;
	}

	if( m_pIWbemClassObject == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	CWbemClassObject InInstance;
	CWbemClassObject OutInstance;
	
	HRESULT hr = GetMethod(sMethodName,InInstance);
	if( ! CHECKHRESULT(hr) )
	{
		return hr;
	}

	InInstance.SetProperty(sArgumentName,sArgumentValue);

	hr = ExecuteMethod(sMethodName,InInstance,OutInstance);

	return hr;
}

HRESULT CWbemClassObject::ExecuteMethod(const CString& sMethodName, CWbemClassObject& InInstance, CWbemClassObject& OutInstance)
{
  TRACEX(_T("CWbemClassObject::ExecuteMethod\n"));
	TRACEARGs(sMethodName);

  IWbemServices* pServices = NULL;
	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr = Connect(pServices)) )
	{
		return hr;
	}

  ASSERT(pServices);

  // Call the method
	IWbemClassObject* pOutInst = NULL;
	IWbemClassObject* pInInst = InInstance.GetClassObject();
	CString sPath;
	GetProperty(_T("__PATH"),sPath);
	BSTR bsPath = sPath.AllocSysString();
	BSTR bsMethodName = sMethodName.AllocSysString();	

  hr = pServices->ExecMethod(bsPath, bsMethodName, 0, NULL, pInInst, &pOutInst, NULL);

	if( pInInst )
	{
		pInInst->Release();
	}

	if( ! CHECKHRESULT(hr) )
	{
		::SysFreeString(bsMethodName);
		::SysFreeString(bsPath);
		return hr;
	}

	if( pOutInst )  
	{
		OutInstance.Create(pOutInst);
	}

	::SysFreeString(bsMethodName);
	::SysFreeString(bsPath);

	return S_OK;
}

HRESULT CWbemClassObject::GetLocaleStringProperty(const CString& sProperty, CString& sPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {    
    return E_FAIL;
  }

	HRESULT hr = GetProperty(sProperty,sPropertyValue);
	if( ! CHECKHRESULT(hr) )
	{
		return hr;
	}

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, CString& sPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {    
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( BSTR ) failed.\n"));
		::SysFreeString(bsProperty);
    sPropertyValue.Empty();
    return hr;
  }

	if( V_VT(&vPropValue) != VT_NULL )
	{
		sPropertyValue = V_BSTR(&vPropValue);
	}
	else
	{
		sPropertyValue.Empty();
	}

	VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, int& iPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( int ) failed.\n"));
    iPropertyValue = 0;
		::SysFreeString(bsProperty);
    return hr;
  }    

  iPropertyValue = V_I4(&vPropValue);

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, bool& bPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( int ) failed.\n"));
    bPropertyValue = false;
		::SysFreeString(bsProperty);
    return hr;
  }    

  bPropertyValue = ((V_BOOL(&vPropValue)==VARIANT_TRUE) ? true : false);

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, float& fPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {    
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( float ) failed.\n"));    
    fPropertyValue = 0;
		::SysFreeString(bsProperty);
    return hr;
  }

  fPropertyValue = V_R4(&vPropValue);

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, COleSafeArray& ArrayPropertyValue)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {    
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( SAFEARRAY ) failed.\n"));    
		::SysFreeString(bsProperty);
    return hr;
  }

	if( V_VT(&vPropValue) != VT_NULL )
	{
		ArrayPropertyValue.Attach(vPropValue);
	}
	else
	{
		hr = S_FALSE;
	}

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, CTime& time, bool bConvertToLocalTime /*= true*/)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {    
    return E_FAIL;
  }

	CString sPropertyValue;
	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

  HRESULT hr = m_pIWbemClassObject->Get(bsProperty, 0L, &vPropValue, NULL, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Get( BSTR ) failed.\n"));
		::SysFreeString(bsProperty);
    sPropertyValue.Empty();
    return hr;
  }

	if( V_VT(&vPropValue) != VT_NULL )
	{
		sPropertyValue = V_BSTR(&vPropValue);
	}
	else
	{
		time = CTime();
		VariantClear(&vPropValue);
		::SysFreeString(bsProperty);
		return S_FALSE;
	}

	VariantClear(&vPropValue);

	::SysFreeString(bsProperty);
	bool bIncomplete = false;
	if( sPropertyValue.Find(_T("*")) != -1 )
	{
		sPropertyValue.Replace(_T('*'),_T('0'));
		bIncomplete = true;
	}

	// parse the DTime format string
	SYSTEMTIME st;
	int iBias = -1;
  int iYear;
  int iMonth;
  int iDay;
  int iHour;
  int iMinute;
  int iSecond;
  int iMSeconds;
	
	_stscanf(sPropertyValue,IDS_STRING_DATETIME_FORMAT,&iYear,
																										 &iMonth,
																										 &iDay,
																										 &iHour,
																										 &iMinute,
																										 &iSecond,
																										 &iMSeconds,
																										 &iBias);

  st.wYear = (WORD)iYear;
  st.wMonth = (WORD)iMonth;
  st.wDay = (WORD)iDay;
  st.wHour = (WORD)iHour;
  st.wMinute = (WORD)iMinute;
  st.wSecond = (WORD)iSecond;
  st.wMilliseconds = (WORD)iMSeconds;

	if( bConvertToLocalTime )
	{
		if( iBias != 0 )
		{
			CTime time = st;
			CTime utc;
			if( iBias < 0 )
			{
				iBias = -iBias;
			}
			CTimeSpan ts(0,0,iBias,0);
			utc = time + ts;
			utc.GetAsSystemTime(st);
			st.wDayOfWeek = 0;
		}

		// adjust to the local time zone
 		TIME_ZONE_INFORMATION tzi;
		SYSTEMTIME stLocal;
		GetTimeZoneInformation(&tzi);
		SystemTimeToTzSpecificLocalTime(&tzi,&st,&stLocal);
		time = stLocal;
	}
	else
	{
		if( bIncomplete )
		{
			CTime current = CTime::GetCurrentTime();
			st.wYear = (WORD)current.GetYear();
			st.wMonth = (WORD)current.GetMonth();
			st.wDay = (WORD)current.GetDay();
		}
		time = st;
	}

  sPropertyValue.Empty();

  return hr;
}

HRESULT CWbemClassObject::GetProperty(const CString& sProperty, CStringArray& saPropertyValues)
{
  TRACEX(_T("CWbemClassObject::GetProperty\n"));
	TRACEARGs(sProperty);

	saPropertyValues.RemoveAll();

	COleSafeArray StringArray;
	HRESULT hr = GetProperty(sProperty,StringArray);

	if( hr == S_FALSE )
	{
		return hr;
	}

	// process the strings in the SAFEARRAY
	long lLower = 0L;
	long lUpper = -1L;
	CString sPropertyValue;

	StringArray.GetLBound(1L,&lLower);
	StringArray.GetUBound(1L,&lUpper);

	for( long i = lLower; i <= lUpper; i++ )
	{
		BSTR bsPropertyValue = NULL;
		StringArray.GetElement(&i,&bsPropertyValue);
		sPropertyValue = bsPropertyValue;
		saPropertyValues.Add(sPropertyValue);
	}

  return hr;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, CString sPropertyValue)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
  TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);
	V_VT(&vPropValue) = VT_BSTR;
	V_BSTR(&vPropValue) = sPropertyValue.AllocSysString();

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( string ) failed.\n"));    
		::SysFreeString(bsProperty);
    return hr;
  }

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, int iPropertyValue)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
  TRACEARGs(sProperty);
  TRACEARGn(iPropertyValue);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);
	V_VT(&vPropValue) = VT_I4;
	V_I4(&vPropValue) = iPropertyValue;

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( int ) failed.\n"));
    TRACEARGn(hr);
		::SysFreeString(bsProperty);
    return hr;
  }

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, bool bPropertyValue)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
  TRACEARGs(sProperty);
  TRACEARGn(bPropertyValue);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);
	V_VT(&vPropValue) = VT_BOOL;
	V_BOOL(&vPropValue) = bPropertyValue ? VARIANT_TRUE : VARIANT_FALSE;

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( int ) failed.\n"));
    TRACEARGn(hr);
		::SysFreeString(bsProperty);
    return hr;
  }

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, float fPropertyValue)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
	TRACEARGs(sProperty);
  TRACEARGn(fPropertyValue);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);
	V_VT(&vPropValue) = VT_R4;
	V_R4(&vPropValue) = fPropertyValue;

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( float ) failed."));    
		::SysFreeString(bsProperty);
    return hr;
  }

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, CTime time, bool bConvertToGMTTime /*= true*/)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
  TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

	CString sPropertyValue;

	if( bConvertToGMTTime )
	{
		// format the time to comply with WMI DTime string type
		tm tmGmt = *(time.GetGmtTm());
		sPropertyValue.Format(IDS_STRING_DATETIME_FORMAT2,tmGmt.tm_year,
																										 tmGmt.tm_mon,
																										 tmGmt.tm_mday,
																										 tmGmt.tm_hour,
																										 tmGmt.tm_min,
																										 tmGmt.tm_sec,
																										 0,
																										 _T("+000"));
	}
	else
	{
		sPropertyValue.Format(IDS_STRING_DATETIME_FORMAT2,time.GetYear(),
																										 time.GetMonth(),
																										 time.GetDay(),
																										 time.GetHour(),
																										 time.GetMinute(),
																										 time.GetSecond(),
																										 0,
																										 _T("+000"));
	}

  VARIANT vPropValue;
  VariantInit(&vPropValue);
	V_VT(&vPropValue) = VT_BSTR;
	V_BSTR(&vPropValue) = sPropertyValue.AllocSysString();

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, &vPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( string ) failed.\n"));    
		::SysFreeString(bsProperty);
    return hr;
  }

  VariantClear(&vPropValue);

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, COleSafeArray& ArrayPropertyValue)
{
  TRACEX(_T("CWbemClassObject::SetProperty\n"));
	TRACEARGs(sProperty);

  ASSERT(m_pIWbemClassObject);
  if( m_pIWbemClassObject == NULL )
  {
    return E_FAIL;
  }

	BSTR bsProperty = sProperty.AllocSysString();
  ASSERT(bsProperty);
  if( bsProperty == NULL )
  {
    return E_FAIL;
  }

  LPVARIANT lpvPropValue = LPVARIANT(ArrayPropertyValue);

  HRESULT hr = m_pIWbemClassObject->Put(bsProperty, 0L, lpvPropValue, NULL);
  if( !CHECKHRESULT(hr) )
  {
    TRACE(_T("FAILED : IWbemClassObject::Put( SAFEARRAY ) failed.\n"));
    TRACEARGn(hr);
		::SysFreeString(bsProperty);
    return hr;
  }

	::SysFreeString(bsProperty);

  return S_OK;
}

HRESULT CWbemClassObject::SetProperty(const CString& sProperty, const CStringArray& saPropertyValues)
{
    TRACEX(_T("CWbemClassObject::SetProperty\n"));
	TRACEARGs(sProperty);

    //----------------------------------------------------------------------------------------
    // v-marfin 62531b : Allow an empty array as a means of removing a property of type array
    if( saPropertyValues.GetSize() == 0 )
    {
        HRESULT hr=0;
        VARIANT vNULL;
        VariantInit(&vNULL);
        hr = VariantChangeType(&vNULL,&vNULL,0,VT_NULL);

        hr = SetRawProperty(sProperty,vNULL);
        return hr;
    }
    //----------------------------------------------------------------------------------------

	COleSafeArray StringArray;

	StringArray.CreateOneDim(VT_BSTR,(int)saPropertyValues.GetSize());

	// process the strings in the SAFEARRAY
	CString sPropertyValue;

	for( long i = 0; i < saPropertyValues.GetSize(); i++ )
	{
		BSTR bsPropertyValue = saPropertyValues[i].AllocSysString();
		StringArray.PutElement(&i,bsPropertyValue);
		::SysFreeString(bsPropertyValue);
	}

	HRESULT hr = SetProperty(sProperty,StringArray);

  return hr;
}

inline HRESULT CWbemClassObject::Connect(IWbemServices*& pServices)
{
  TRACEX(_T("CWbemClassObject::Connect\n"));
  TRACEARGn(pServices);

	HRESULT hr = S_OK;

	if( m_sNamespace.IsEmpty() ) // connect to a system
	{
		BOOL bAvail;		
		if( (hr = CnxGetConnection(m_sMachineName,pServices,bAvail)) != S_OK )
		{
			TRACE(_T("FAILED : Could not retrieve a connection for the machine. Failed.\n"));
			return hr;
		}

		if( ! bAvail )
			return E_FAIL;
    
	}
	else // connect to a specific namespace
	{
		if( (hr = CnxConnectToNamespace(m_sNamespace,pServices)) != S_OK )
		{
			TRACE(_T("FAILED : Could not retrieve a connection for the machine. Failed.\n"));
			return hr;
		}
	}

  SetBlanket(pServices);

	return hr;
}

inline HRESULT CWbemClassObject::SetBlanket(LPUNKNOWN pIUnk)
{
  return CoSetProxyBlanket( pIUnk,
                            RPC_C_AUTHN_WINNT,    // NTLM authentication service
                            RPC_C_AUTHZ_NONE,     // default authorization service...
                            NULL,                 // no mutual authentication
                            RPC_C_AUTHN_LEVEL_CONNECT,      // authentication level
                            RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                            NULL,                // use current token
                            EOAC_NONE );          // no special capabilities    
}

inline void CWbemClassObject::DisplayErrorMsgBox(HRESULT hr)
{
  // construct the path and load wbemcomn.dll for error messages
	TCHAR szWinDir[_MAX_PATH];
	GetWindowsDirectory(szWinDir,_MAX_PATH);
  
  CString sModulePath;
  sModulePath.Format(_T("%s\\SYSTEM32\\WBEM\\WBEMCOMN.DLL"),szWinDir);

  HMODULE hModule = LoadLibrary(sModulePath);

  TCHAR szMsg[_MAX_PATH*4];

  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_IGNORE_INSERTS,
                                hModule,
                                hr,
                                0,
                                szMsg,
                                _MAX_PATH*4*sizeof(TCHAR),
                                NULL
                                );

  CString sMsg;

  CString sNamespace = GetNamespace();
  if( sNamespace.IsEmpty() )
  {
    sNamespace.Format(IDS_STRING_HEALTHMON_ROOT,GetMachineName());
  }

  if( dwCount )
  {
    sMsg.Format(IDS_STRING_WMI_ERROR,sNamespace,hr,szMsg);
  }
  else
  {
    CString sUnknown;
    sUnknown.LoadString(IDS_STRING_UNKNOWN);
    sMsg.Format(IDS_STRING_WMI_ERROR,sNamespace,hr,sUnknown);
  }

  AfxMessageBox(sMsg);
  
  FreeLibrary(hModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\ctrlwnd.cpp ===
// CtrlWnd.cpp : implementation file
//

#include "stdafx.h"
#include "CtrlWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CCtrlWnd,CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCtrlWnd

CCtrlWnd::CCtrlWnd()
{
	EnableAutomation();
	m_wndControl.EnableAutomation();
}

CCtrlWnd::~CCtrlWnd()
{
}

BOOL CCtrlWnd::CreateControl(LPCTSTR lpszControlID)
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return FALSE;
	}

	if( m_wndControl.GetSafeHwnd() && ::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		m_wndControl.DestroyWindow();
	}

	CRect rc;
	GetClientRect(&rc);
	
	BOOL bResult = m_wndControl.CreateControl(lpszControlID,NULL,WS_VISIBLE|WS_TABSTOP,rc,this,152);

	return bResult;
}

CWnd* CCtrlWnd::GetControl()
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return NULL;
	}

	if( ! m_wndControl.GetSafeHwnd() || !::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		return NULL;
	}

	return &m_wndControl;
}

LPUNKNOWN CCtrlWnd::GetControlIUnknown()
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return NULL;
	}

	if( ! m_wndControl.GetSafeHwnd() || !::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		return NULL;
	}

	LPUNKNOWN pUnk = m_wndControl.GetControlUnknown();

	if( pUnk )
	{
		pUnk->AddRef();
	}

	return pUnk;
}

BEGIN_MESSAGE_MAP(CCtrlWnd, CWnd)
	//{{AFX_MSG_MAP(CCtrlWnd)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCtrlWnd message handlers

int CCtrlWnd::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	ShowWindow(SW_SHOW);
	
	return 0;
}

void CCtrlWnd::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	if( m_wndControl.GetSafeHwnd() && ::IsWindow(m_wndControl.GetSafeHwnd()) )
		return;

	CRect r;
	GetClientRect(&r);
	
	dc.FillSolidRect(r, GetSysColor(COLOR_3DFACE));
}

void CCtrlWnd::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	if( ! m_wndControl.GetSafeHwnd() && ! ::IsWindow(m_wndControl.GetSafeHwnd()) )
		return;

	CRect rc;
	GetClientRect(&rc);

	m_wndControl.SetWindowPos(NULL,0,0,rc.Width(),rc.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);
}

void CCtrlWnd::PostNcDestroy() 
{
	CWnd::PostNcDestroy();

	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wbemclassobject.h ===
// WbemClassObject.h: interface for the CWbemClassObject class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WBEMCLASSOBJECT_H__8B6E3039_FA29_11D1_8349_0000F87A3912__INCLUDED_)
#define AFX_WBEMCLASSOBJECT_H__8B6E3039_FA29_11D1_8349_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wbemcli.h>

class CWbemEventListener;

class CWbemClassObject : public CObject  
{

DECLARE_DYNCREATE(CWbemClassObject)

// Constructors
public:
	CWbemClassObject();

// Destructor
public:
	virtual ~CWbemClassObject();

// Create/Destroy
public:
  virtual HRESULT Create(const CString& sMachineName);
  virtual HRESULT Create(IWbemClassObject* pObject);
  virtual void Destroy();

// Property Operations
public:
	// v-marfin
	HRESULT GetRawProperty(const CString& sProperty, VARIANT& vPropValue);
	HRESULT SetRawProperty(const CString& sProperty, VARIANT& vPropValue);

	HRESULT GetPropertyNames(CStringArray& saNames);
	HRESULT GetPropertyType(const CString& sPropertyName, CString& sType);
	HRESULT GetPropertyType(const CString& sPropertyName, CIMTYPE& Type);
  virtual HRESULT GetAllProperties() { return S_OK; }
  virtual HRESULT SaveAllProperties();
	static bool GetPropertyValueFromString(const CString& sObjectPath, const CString& sPropName, CString& sProperty);

// WBEM Operations
public:
	HRESULT GetClassName(CString& sClass) { return GetProperty(_T("__CLASS"),sClass); }
	HRESULT GetObject(const CString& sObjectPath);
	HRESULT GetObjectText(CString& sText);
  HRESULT ExecQuery(BSTR bsQueryString);
	HRESULT ExecQueryAsync(BSTR bsQueryString, CWbemEventListener* pListener);
  HRESULT CreateEnumerator(BSTR bsClassName);
	HRESULT CreateClassEnumerator(BSTR bsClassName);
	HRESULT CreateAsyncEnumerator(BSTR bsClassName, CWbemEventListener* pListener);
  HRESULT GetNextObject(ULONG& uReturned);
	HRESULT Reset();
  HRESULT CreateInstance(BSTR bsClassName);
  HRESULT DeleteInstance(const CString& sClassObjectPath);
	HRESULT GetMethod(const CString& sMethodName, CWbemClassObject&	MethodInput);
	HRESULT ExecuteMethod(const CString& sMethodName, const CString& sArgumentName, const CString& sArgumentValue, int& iReturnValue);
	HRESULT ExecuteMethod(const CString& sMethodName, CWbemClassObject& InInstance, CWbemClassObject& OutInstance);

	HRESULT GetLocaleStringProperty(const CString& sProperty, CString& sPropertyValue);
  
  HRESULT GetProperty(const CString& sProperty, CString& sPropertyValue);
  HRESULT GetProperty(const CString& sProperty, int& iPropertyValue);
  HRESULT GetProperty(const CString& sProperty, bool& bPropertyValue);
	HRESULT GetProperty(const CString& sProperty, float& fPropertyValue);
	HRESULT GetProperty(const CString& sProperty, COleSafeArray& ArrayPropertyValue);
	HRESULT GetProperty(const CString& sProperty, CStringArray& saPropertyValues);
	HRESULT GetProperty(const CString& sProperty, CTime& timePropertyValue, bool ConvertToLocalTime = true);

  HRESULT SetProperty(const CString& sProperty, CString sPropertyValue);
  HRESULT SetProperty(const CString& sProperty, int iPropertyValue);
	HRESULT SetProperty(const CString& sProperty, bool bPropertyValue);
	HRESULT SetProperty(const CString& sProperty, float fPropertyValue);
	HRESULT SetProperty(const CString& sProperty, CTime timePropertyValue, bool bConvertToGMTTime = true);
	HRESULT SetProperty(const CString& sProperty, COleSafeArray& ArrayPropertyValue);
	HRESULT SetProperty(const CString& sProperty, const CStringArray& saPropertyValues);
protected:
	HRESULT Connect(IWbemServices*& pServices);
  HRESULT SetBlanket(LPUNKNOWN pIUnk);
  void DisplayErrorMsgBox(HRESULT hr);

// Accessors
public:
	void SetMachineName(const CString& sMachineName) { m_sMachineName = sMachineName; }
	const CString& GetMachineName() const { return m_sMachineName; }
	void SetNamespace(const CString& sNamespace) { m_sNamespace = sNamespace; }
	const CString& GetNamespace() const { return m_sNamespace; }
	IWbemClassObject* GetClassObject() { m_pIWbemClassObject->AddRef(); return m_pIWbemClassObject; }
// Implementation Attributes
protected:
  IEnumWbemClassObject* m_pIEnumerator;
  IWbemClassObject* m_pIWbemClassObject;
  CString m_sMachineName;
	CString m_sNamespace;

};

#endif // !defined(AFX_WBEMCLASSOBJECT_H__8B6E3039_FA29_11D1_8349_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wmibrowsedlg.cpp ===
// WmiBrowseDlg.cpp : implementation file
//
// 03/28/00 v-marfin 62468 : Added efficiencies to help queries with thousands of 
//                           records load faster.
// 03/30/00 v-marfin 62469 : If no occurrences, disable the OK button

#include "stdafx.h"
#include "snapin.h"
#include "WmiBrowseDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWmiBrowseDlg dialog


CWmiBrowseDlg::CWmiBrowseDlg(CWnd* pParent /*=NULL*/)
	: CResizeableDialog(CWmiBrowseDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWmiBrowseDlg)
	m_sTitle = _T("");
	//}}AFX_DATA_INIT
}


void CWmiBrowseDlg::DoDataExchange(CDataExchange* pDX)
{
	CResizeableDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWmiBrowseDlg)
	DDX_Control(pDX, IDC_LIST_WMI_ITEMS, m_Items);
	DDX_Text(pDX, IDC_STATIC_TITLE, m_sTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWmiBrowseDlg, CResizeableDialog)
	//{{AFX_MSG_MAP(CWmiBrowseDlg)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_WMI_ITEMS, OnDblclkListWmiItems)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWmiBrowseDlg message handlers

BOOL CWmiBrowseDlg::OnInitDialog() 
{
	CResizeableDialog::OnInitDialog();

  // subclass header control
  m_Items.SubclassHeaderCtrl();

	// set the extended styles for the list control
	m_Items.SetExtendedStyle(LVS_EX_LABELTIP|LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);

	// set styles for the header control
	CHeaderCtrl* pHdrCtrl = m_Items.GetHeaderCtrl();
  DWORD dwStyle = GetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE);
	dwStyle |= (HDS_DRAGDROP|HDS_BUTTONS);
	SetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE,dwStyle);

	SetControlInfo(IDC_STATIC_TITLE,		ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR);
	SetControlInfo(IDC_LIST_WMI_ITEMS,	ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR | RESIZE_VER);
	SetControlInfo(IDOK,				ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDCANCEL,			ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDC_BUTTON_HELP,ANCHOR_BOTTOM | ANCHOR_LEFT );

	SetWindowText(m_sDlgTitle);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWmiBrowseDlg::OnButtonHelp() 
{
	// TODO: Add your control notification handler code here
	
}

void CWmiBrowseDlg::OnDblclkListWmiItems(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnOK();
	
	*pResult = 0;
}

void CWmiBrowseDlg::OnOK() 
{
	POSITION pos = m_Items.GetFirstSelectedItemPosition();

	if( ! pos )
	{
		return;
	}

	int iIndex = m_Items.GetNextSelectedItem(pos);

	if( iIndex < 0 )
	{
		return;
	}

	m_sSelectedItem = m_Items.GetItemText(iIndex,0);

	CResizeableDialog::OnOK();	
}

/////////////////////////////////////////////////////////////////////////////
// CWmiNamespaceBrowseDlg dialog

BOOL CWmiNamespaceBrowseDlg::OnInitDialog()
{
	CWmiBrowseDlg::OnInitDialog();

	CWaitCursor wait;

	// add column headers to the list ctrl
	CString sColName;
	sColName.LoadString(IDS_STRING_NAME);
	m_Items.InsertColumn(0,sColName);
	m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);

  // insert the root namespace
  m_Items.InsertItem(0,_T("ROOT"));
  if( m_sTitle.CompareNoCase(_T("ROOT")) == 0 )
  {
    m_Items.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);
  }

  // enumerate all namespaces on the system recursively
  EnumerateAllChildNamespaces(_T("ROOT"));

  m_sTitle.Format(IDS_STRING_NAMESPACES_ON_SYSTEM,m_ClassObject.GetMachineName());

  if( m_Items.GetItemCount() == 0 )
  {
    m_Items.DeleteColumn(0);
    m_Items.InsertColumn(0,_T(""));
    CString sNoInstancesFound;
    sNoInstancesFound.LoadString(IDS_STRING_NO_ITEMS_FOUND);
    m_Items.InsertItem(0,sNoInstancesFound);
    m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
    m_Items.EnableWindow(FALSE);
  }


  UpdateData(FALSE);

	return TRUE;
}

void CWmiNamespaceBrowseDlg::EnumerateAllChildNamespaces(const CString& sNamespace)
{
	ULONG ulReturned = 0L;
	int i = 0;

  CWbemClassObject Namespaces;
  
  Namespaces.Create(m_ClassObject.GetMachineName());

  Namespaces.SetNamespace(sNamespace);

	CString sTemp = IDS_STRING_MOF_NAMESPACE;
	BSTR bsTemp = sTemp.AllocSysString();
	if( ! CHECKHRESULT(Namespaces.CreateEnumerator(bsTemp)) )
	{		
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	while( Namespaces.GetNextObject(ulReturned) == S_OK && ulReturned )
	{
		CString sName;		
		Namespaces.GetProperty(IDS_STRING_MOF_NAME,sName);

		CString sTemp2;
		Namespaces.GetProperty(IDS_STRING_MOF_NAMESPACE,sTemp2);

    CString sNamespaceFound = sTemp2 + _T("\\") + sName;
		int iIndex = m_Items.InsertItem(i++,sNamespaceFound);
    if( sNamespaceFound.CompareNoCase(m_sTitle) == 0 )
    {
      m_Items.SetItemState(iIndex,LVIS_SELECTED,LVIS_SELECTED);
      m_Items.EnsureVisible(iIndex,FALSE);
    }
    
    EnumerateAllChildNamespaces(sNamespaceFound);    
	}	

	m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

/////////////////////////////////////////////////////////////////////////////
// CWmiClassBrowseDlg dialog

BOOL CWmiClassBrowseDlg::OnInitDialog()
{
	CWmiBrowseDlg::OnInitDialog();

	CWaitCursor wait;

	// add column headers to the list ctrl
	CString sColName;
	sColName.LoadString(IDS_STRING_NAME);
	m_Items.InsertColumn(0,sColName);
	m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);

	ULONG ulReturned = 0L;
	int i = 0;

	while( m_ClassObject.GetNextObject(ulReturned) == S_OK && ulReturned )
	{
		CString sName;

		m_ClassObject.GetProperty(IDS_STRING_MOF_CLASSNAME,sName);
		m_Items.InsertItem(i++,sName);
		m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
	}

  if( m_Items.GetItemCount() == 0 )
  {
    m_Items.DeleteColumn(0);
    m_Items.InsertColumn(0,_T(""));
    CString sNoInstancesFound;
    sNoInstancesFound.LoadString(IDS_STRING_NO_ITEMS_FOUND);
    m_Items.InsertItem(0,sNoInstancesFound);
    m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
    m_Items.EnableWindow(FALSE);
  }


	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWmiInstanceBrowseDlg dialog

BOOL CWmiInstanceBrowseDlg::OnInitDialog()
{
	CWmiBrowseDlg::OnInitDialog();

	CWaitCursor wait;

	// add column headers to the list ctrl
	CString sColName;
	
	sColName.LoadString(IDS_STRING_PATH);
	m_Items.InsertColumn(0,sColName);
	m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);

	sColName.LoadString(IDS_STRING_NAME);
	m_Items.InsertColumn(1,sColName);
	m_Items.SetColumnWidth(1,LVSCW_AUTOSIZE);

	int order[] = { 1,0 };
	m_Items.SetColumnOrderArray(2,order);

	ULONG ulReturned = 0L;
	int i = 0;
    bool bNamePropertyExists = true;

    // // v-marfin 62468 define CStrings outside of loop for performance purposes
	CString sProperty;          // v-marfin 62468
	CString sNameProperty;      // v-marfin 62468
    HRESULT hr=0;
    int iItemIndex=0;

	while( m_ClassObject.GetNextObject(ulReturned) == S_OK && ulReturned )
	{

		m_ClassObject.GetProperty(IDS_STRING_MOF_RELPATH,sProperty);
		iItemIndex = m_Items.InsertItem(i,sProperty);

        // v-marfin 62468 : Don't check for this if we know the name doesn't exist.
        if (bNamePropertyExists)
        {
		    hr = m_ClassObject.GetProperty(IDS_STRING_MOF_NAME,sNameProperty);
            if( !CHECKHRESULT(hr) )
            {
              bNamePropertyExists = false;
              sNameProperty.Empty();  // v-marfin 62468 
            }
        }

		m_Items.SetItem(iItemIndex,1,LVIF_TEXT,sNameProperty,-1,-1,-1,0L);
		// v-marfin 62468 : m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
		// v-marfin 62468 : m_Items.SetColumnWidth(1,LVSCW_AUTOSIZE);
		i++;

        // v-marfin 62468
        if (i > 1000)
            break;
	}


    m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);  // v-marfin 62468 : 
	m_Items.SetColumnWidth(1,LVSCW_AUTOSIZE);  // v-marfin 62468

  if( ! bNamePropertyExists )
  {
    m_Items.DeleteColumn(1);
  }


  int nCount = m_Items.GetItemCount();

    if( m_Items.GetItemCount() == 0 )
    {
        m_Items.DeleteColumn(1);
        m_Items.DeleteColumn(0);
        m_Items.InsertColumn(0,_T(""));
        CString sNoInstancesFound;
        sNoInstancesFound.LoadString(IDS_STRING_NO_ITEMS_FOUND);
        m_Items.InsertItem(0,sNoInstancesFound);
        m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
        m_Items.EnableWindow(FALSE);
    }
    else
    {
        // v-marfin 62469
        m_Items.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);
    }

    // v-marfin 62469 : If no occurrences, disable the OK button
    GetDlgItem(IDOK)->EnableWindow(nCount);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wmibrowsedlg.h ===
#if !defined(AFX_WMIBROWSEDLG_H__EDFA0EA3_112B_11D3_9386_00A0CC406605__INCLUDED_)
#define AFX_WMIBROWSEDLG_H__EDFA0EA3_112B_11D3_9386_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WmiBrowseDlg.h : header file
//

#include "WbemClassObject.h"
#include "ResizeableDialog.h"
#include "HMList.h"

/////////////////////////////////////////////////////////////////////////////
// CWmiBrowseDlg dialog

class CWmiBrowseDlg : public CResizeableDialog
{
// Construction
public:
	CWmiBrowseDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWmiBrowseDlg)
	enum { IDD = IDD_DIALOG_WMI_BROWSE };
	CHMList	m_Items;
	CString	m_sTitle;
	//}}AFX_DATA
	CString m_sDlgTitle;
	CWbemClassObject m_ClassObject;
	CString m_sSelectedItem;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWmiBrowseDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWmiBrowseDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonHelp();
	virtual void OnOK();
	afx_msg void OnDblclkListWmiItems(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CWmiNamespaceBrowseDlg : public CWmiBrowseDlg
{
// Implementation
protected:
	virtual BOOL OnInitDialog();
  void EnumerateAllChildNamespaces(const CString& sNamespace);
};

class CWmiClassBrowseDlg : public CWmiBrowseDlg
{
// Implementation
protected:
	virtual BOOL OnInitDialog();
};

class CWmiInstanceBrowseDlg : public CWmiBrowseDlg
{
// Implementation
protected:
	virtual BOOL OnInitDialog();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WMIBROWSEDLG_H__EDFA0EA3_112B_11D3_9386_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wmipropertybrowsedlg.cpp ===
// WmiPropertyBrowseDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "WmiPropertyBrowseDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWmiPropertyBrowseDlg dialog


CWmiPropertyBrowseDlg::CWmiPropertyBrowseDlg(CWnd* pParent /*=NULL*/)
	: CResizeableDialog(CWmiPropertyBrowseDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWmiPropertyBrowseDlg)
	m_sTitle = _T("");
	//}}AFX_DATA_INIT
}


void CWmiPropertyBrowseDlg::DoDataExchange(CDataExchange* pDX)
{
	CResizeableDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWmiPropertyBrowseDlg)
	DDX_Control(pDX, IDC_LIST_WMI_ITEMS, m_Items);
	DDX_Text(pDX, IDC_STATIC_TITLE, m_sTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWmiPropertyBrowseDlg, CResizeableDialog)
	//{{AFX_MSG_MAP(CWmiPropertyBrowseDlg)
	ON_BN_CLICKED(IDC_BUTTON_HELP, OnButtonHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWmiPropertyBrowseDlg message handlers

BOOL CWmiPropertyBrowseDlg::OnInitDialog() 
{
	CResizeableDialog::OnInitDialog();

	CWaitCursor wait;

	// set the extended styles for the list control
	m_Items.SetExtendedStyle(LVS_EX_LABELTIP|LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);

	SetControlInfo(IDC_STATIC_TITLE,		ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR);
	SetControlInfo(IDC_LIST_WMI_ITEMS,	ANCHOR_LEFT | ANCHOR_TOP | RESIZE_HOR | RESIZE_VER);
	SetControlInfo(IDOK,				ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDCANCEL,			ANCHOR_BOTTOM | ANCHOR_LEFT );
	SetControlInfo(IDC_BUTTON_HELP,ANCHOR_BOTTOM | ANCHOR_LEFT );

	SetWindowText(m_sDlgTitle);	

	CString sColName;
	sColName.LoadString(IDS_STRING_NAME);
	m_Items.InsertColumn(0,sColName);

	sColName.LoadString(IDS_STRING_TYPE);
	m_Items.InsertColumn(1,sColName);

	CStringArray saNames;

	m_ClassObject.GetPropertyNames(saNames);

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		CString sType;
		int iItemIndex = m_Items.InsertItem(i,saNames[i]);
		m_ClassObject.GetPropertyType(saNames[i],sType);
		m_Items.SetItem(iItemIndex,1,LVIF_TEXT,sType,-1,-1,-1,0L);
		m_Items.SetColumnWidth(0,LVSCW_AUTOSIZE);
		m_Items.SetColumnWidth(1,LVSCW_AUTOSIZE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWmiPropertyBrowseDlg::OnOK() 
{
	POSITION pos = m_Items.GetFirstSelectedItemPosition();

	while( pos != NULL )
	{
		int iItemIndex = m_Items.GetNextSelectedItem(pos);
		m_saProperties.Add(m_Items.GetItemText(iItemIndex,0));
	}

	CResizeableDialog::OnOK();
}

void CWmiPropertyBrowseDlg::OnButtonHelp() 
{
	// TODO: Add your control notification handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wmipropertybrowsedlg.h ===
#if !defined(AFX_WMIPROPERTYBROWSEDLG_H__27A0E3F5_1865_11D3_938B_00A0CC406605__INCLUDED_)
#define AFX_WMIPROPERTYBROWSEDLG_H__27A0E3F5_1865_11D3_938B_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WmiPropertyBrowseDlg.h : header file
//

#include "WbemClassObject.h"
#include "ResizeableDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CWmiPropertyBrowseDlg dialog

class CWmiPropertyBrowseDlg : public CResizeableDialog
{
// Construction
public:
	CWmiPropertyBrowseDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWmiPropertyBrowseDlg)
	enum { IDD = IDD_DIALOG_WMI_PROPERTY_BROWSE };
	CListCtrl	m_Items;
	CString	m_sTitle;
	//}}AFX_DATA
	CString m_sDlgTitle;
	CWbemClassObject m_ClassObject;
	CStringArray m_saProperties;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWmiPropertyBrowseDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWmiPropertyBrowseDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WMIPROPERTYBROWSEDLG_H__27A0E3F5_1865_11D3_938B_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wbemeventlistener.cpp ===
// WbemEventListener.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "WbemEventListener.h"

#ifdef _HEALTHMON_BUILD
#include <wbemcli_i.c>
#else // _HEALTHMON_BUILD
#include "wbemcli.h"
#include "wbemprov.h"
#endif //_HEALTHMON_BUILD

#include "ConnectionManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IUnsecuredApartment* CWbemEventListener::s_pIUnsecApartment = NULL;
long CWbemEventListener::s_lObjCount = 0L;

/////////////////////////////////////////////////////////////////////////////
// CWbemEventListener

IMPLEMENT_DYNCREATE(CWbemEventListener, CCmdTarget)

CWbemEventListener::CWbemEventListener()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_pStubSink = NULL;

	s_lObjCount++;
}

CWbemEventListener::~CWbemEventListener()
{
	Destroy();
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CWbemEventListener::Create()
{
	TRACEX(_T("CWbemEventListener::Create\n"));

    ASSERT(!m_sQuery.IsEmpty());
    if( m_sQuery.IsEmpty() )
    {
        TRACE(_T("FAILED : Query String is empty! Create failed.\n"));
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

	// register for WBEM events

	// first create the unsecured apartment
	HRESULT hr = S_OK;
    IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
    ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CWbemEventListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE); // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to create Stub Sink!\n"));
        ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));	
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

    ASSERT(m_pStubSink);
	
	// third, call connection manager to register for events
    if( !CHECKHRESULT(CnxRegisterEventNotification(sSystemName,m_sQuery,m_pStubSink)) )
    {
        TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

	return true;
}

void CWbemEventListener::Destroy()
{
	TRACEX(_T("CWbemEventListener::Destroy\n"));

	s_lObjCount--;

    if( m_pStubSink )			
    {
		CnxRemoveConnection(m_pHMObject->GetSystemName(),m_pStubSink);
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

/////////////////////////////////////////////////////////////////////////////
// WMI Specific Boiler Plate
/////////////////////////////////////////////////////////////////////////////

HRESULT CWbemEventListener::CreateUnSecuredApartment()
{
	TRACEX(_T("CWbemEventListener::CreateUnSecuredApartment\n"));

	HRESULT hr = CoCreateInstance(CLSID_UnsecuredApartment,
																NULL,
																CLSCTX_LOCAL_SERVER,
																IID_IUnsecuredApartment,
																(LPVOID*)&s_pIUnsecApartment);

	if( ! CHECKHRESULT(hr) || ! GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) )
	{
    TRACE(_T("FAILED : Failed to create IUnsecureApartment Pointer!\n"));    
    return E_FAIL;
  }

	return S_OK;
}

inline IWbemClassObject* CWbemEventListener::GetTargetInstance(IWbemClassObject* pClassObject)
{
	TRACEX(_T("CWbemEventListener::GetTargetInstance\n"));
	TRACEARGn(pClassObject);

	VARIANT v;
	VariantInit(&v);
	IWbemClassObject* pInstance = NULL;
	BSTR bsName = SysAllocString(L"TargetInstance");

	HRESULT hRes = pClassObject->Get(bsName, 0L, &v, NULL, NULL);
	SysFreeString(bsName);

	if( hRes == WBEM_E_NOT_FOUND || !CHECKHRESULT(hRes) )
	{
    TRACE(_T("FAILED : GetObject Failed.\n"));
    return NULL;
	}

	IUnknown* pUnk = (IUnknown*)V_UNKNOWN(&v);

	hRes = pUnk->QueryInterface(IID_IWbemClassObject, (void**)&pInstance);

	if( !CHECKHRESULT(hRes) )
  {
    TRACE(_T("FAILED : IDispatch::QueryInterface(IID_IWbemClassObject) failed.\n"));
    
    return NULL;
  }

  return pInstance;
}

/////////////////////////////////////////////////////////////////////////////
// Event Processing Members
/////////////////////////////////////////////////////////////////////////////

void CWbemEventListener::SetEventQuery(const CString& sQuery)
{
	TRACEX(_T("CWbemEventListener::SetEventQuery\n"));
	TRACEARGs(sQuery);
	
	m_sQuery = sQuery;
}

inline HRESULT CWbemEventListener::OnIndicate(long lObjectCount, IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
{
	TRACEX(_T("CWbemEventListener::OnIndicate\n"));
	TRACEARGn(lObjectCount);
	TRACEARGn(apObjArray);

  for( long l = 0; l < lObjectCount; l++)
  {
    GfxCheckPtr(apObjArray[l],IWbemClassObject);
		IWbemClassObject* pInstance = GetTargetInstance(apObjArray[l]);
		if( pInstance == NULL )
		{
			apObjArray[l]->AddRef();
			ProcessEventClassObject(apObjArray[l]);			
		}
		else
		{
			ProcessEventClassObject(pInstance);
			pInstance->Release();
		}
  }
  
  return WBEM_NO_ERROR;
}

inline HRESULT CWbemEventListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CWbemEventListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult != S_OK )
	{
		if( hResult == WBEM_E_CALL_CANCELLED )
			return WBEM_NO_ERROR;


	}
	else if( lFlags >= 1L && hResult == S_OK )
	{

	}

  return WBEM_NO_ERROR;	
}

inline HRESULT CWbemEventListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
	TRACEX(_T("CWbemEventListener::ProcessEventClassObject\n"));
	TRACEARGn(pClassObject);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Object Association
/////////////////////////////////////////////////////////////////////////////

CHMObject* CWbemEventListener::GetObjectPtr()
{
	TRACEX(_T("CWbemEventListener::GetObjectPtr\n"));

	if( ! GfxCheckObjPtr(m_pHMObject,CHMObject) )
	{
		return NULL;
	}

	return m_pHMObject;
}

void CWbemEventListener::SetObjectPtr(CHMObject* pObj)
{
	TRACEX(_T("CWbemEventListener::SetObjectPtr\n"));
	TRACEARGn(pObj);

	if( ! GfxCheckObjPtr(pObj,CHMObject) )
	{
		m_pHMObject = NULL;
	}

	m_pHMObject = pObj;
}

void CWbemEventListener::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CWbemEventListener, CCmdTarget)
	//{{AFX_MSG_MAP(CWbemEventListener)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CWbemEventListener, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CWbemEventListener)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IWbemEventListener to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {8292FEDB-BD22-11D2-BD7C-0000F87A3912}
static const IID IID_IWbemEventListener =
{ 0x8292fedb, 0xbd22, 0x11d2, { 0xbd, 0x7c, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CWbemEventListener, CCmdTarget)
	INTERFACE_PART(CWbemEventListener, IID_IWbemEventListener, Dispatch)
  INTERFACE_PART(CWbemEventListener, IID_IWbemObjectSink, WbemObjectSink)
END_INTERFACE_MAP()

// {8292FEDC-BD22-11D2-BD7C-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CWbemEventListener, "SnapIn.WbemEventListener", 0x8292fedc, 0xbd22, 0x11d2, 0xbd, 0x7c, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CWbemEventListener::CWbemEventListenerFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// IWbemObjectSink Interface Part
/////////////////////////////////////////////////////////////////////////////

ULONG FAR EXPORT CWbemEventListener::XWbemObjectSink::AddRef()
{
	METHOD_PROLOGUE(CWbemEventListener, WbemObjectSink)
	return pThis->ExternalAddRef();
}

ULONG FAR EXPORT CWbemEventListener::XWbemObjectSink::Release()
{
	METHOD_PROLOGUE(CWbemEventListener, WbemObjectSink)
	return pThis->ExternalRelease();
}

HRESULT FAR EXPORT CWbemEventListener::XWbemObjectSink::QueryInterface(
    REFIID iid, void FAR* FAR* ppvObj)
{
	METHOD_PROLOGUE(CWbemEventListener, WbemObjectSink)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

HRESULT FAR EXPORT CWbemEventListener::XWbemObjectSink::Indicate( 
/* [in] */ long lObjectCount,
/* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
{
	METHOD_PROLOGUE(CWbemEventListener, WbemObjectSink)
	HRESULT hr = pThis->OnIndicate(lObjectCount, apObjArray);
	return hr;
}

HRESULT FAR EXPORT CWbemEventListener::XWbemObjectSink::SetStatus( 
/* [in] */ long lFlags,
/* [in] */ HRESULT hResult,
/* [in] */ BSTR strParam,
/* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{
	METHOD_PROLOGUE(CWbemEventListener, WbemObjectSink)
	HRESULT hr = pThis->OnSetStatus(lFlags,hResult,strParam,pObjParam);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CWbemEventListener message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\wbemeventlistener.h ===
#if !defined(AFX_WBEMEVENTLISTENER_H__8292FEDD_BD22_11D2_BD7C_0000F87A3912__INCLUDED_)
#define AFX_WBEMEVENTLISTENER_H__8292FEDD_BD22_11D2_BD7C_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WbemEventListener.h : header file
//

#include <wbemcli.h>
#include "HMObject.h"

/////////////////////////////////////////////////////////////////////////////
// CWbemEventListener command target

class CWbemEventListener : public CCmdTarget
{

	DECLARE_DYNCREATE(CWbemEventListener)

// Construction/Destruction
public:
	CWbemEventListener();
	virtual ~CWbemEventListener();
protected:
	static long s_lObjCount;

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// WMI Specific Boiler Plate
public:
	IWbemObjectSink* GetSink() { return m_pStubSink; }
protected:
	HRESULT CreateUnSecuredApartment();
	IWbemClassObject* GetTargetInstance(IWbemClassObject* pClassObject);
	static IUnsecuredApartment* s_pIUnsecApartment;
	IWbemObjectSink* m_pStubSink;

// Event Processing Members
public:
	void SetEventQuery(const CString& sQuery);
protected:
	virtual HRESULT OnIndicate(long lObjectCount, IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);
	virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	CString m_sQuery;

// Object Association
public:
	CHMObject* GetObjectPtr();
	void SetObjectPtr(CHMObject* pObj);
protected:
	CHMObject* m_pHMObject;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemEventListener)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:	

	// Generated message map functions
	//{{AFX_MSG(CWbemEventListener)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CWbemEventListener)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CWbemEventListener)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	// IWbemObjectSink Interface Part
	BEGIN_INTERFACE_PART(WbemObjectSink,IWbemObjectSink)

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
                    /* [in] */ long lObjectCount,
                    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);

    virtual HRESULT STDMETHODCALLTYPE SetStatus( 
                    /* [in] */ long lFlags,
                    /* [in] */ HRESULT hResult,
                    /* [in] */ BSTR strParam,
                    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);

	END_INTERFACE_PART(WbemObjectSink)

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMEVENTLISTENER_H__8292FEDD_BD22_11D2_BD7C_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Splitter.rc
//

#define IDS_SPLITTER               1
#define IDS_SPLITTER_PPG           2

#define IDS_SPLITTER_PPG_CAPTION   200

#define IDD_PROPPAGE_SPLITTER      200

#define IDD_ABOUTBOX_SPLITTER      1

#define IDB_SPLITTER               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\ctrlwnd.h ===
#if !defined(AFX_CTRLWND_H__FB3BEA3B_8EC5_11D2_BD40_0000F87A3912__INCLUDED_)
#define AFX_CTRLWND_H__FB3BEA3B_8EC5_11D2_BD40_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CtrlWnd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCtrlWnd window

class CCtrlWnd : public CWnd
{

DECLARE_DYNCREATE(CCtrlWnd)

// Construction
public:
	CCtrlWnd();

// Attributes
public:

protected:
	CWnd m_wndControl;

// Operations
public:
	BOOL CreateControl(LPCTSTR lpszControlID);
	CWnd* GetControl();
	LPUNKNOWN GetControlIUnknown();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCtrlWnd)
	protected:
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCtrlWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCtrlWnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CTRLWND_H__FB3BEA3B_8EC5_11D2_BD40_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitter.h ===
#if !defined(AFX_SPLITTER_H__58BB5D67_8E20_11D2_8ADA_0000F87A3912__INCLUDED_)
#define AFX_SPLITTER_H__58BB5D67_8E20_11D2_8ADA_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Splitter.h : main header file for SPLITTER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSplitterApp : See Splitter.cpp for implementation.

class CSplitterApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPLITTER_H__58BB5D67_8E20_11D2_8ADA_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitter.cpp ===
// Splitter.cpp : Implementation of CSplitterApp and DLL registration.

#include "stdafx.h"
#include "Splitter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSplitterApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x58bb5d5f, 0x8e20, 0x11d2, { 0x8a, 0xda, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CSplitterApp::InitInstance - DLL initialization

BOOL CSplitterApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	AfxEnableControlContainer();

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSplitterApp::ExitInstance - DLL termination

int CSplitterApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterctl.cpp ===
// SplitterCtl.cpp : Implementation of the CSplitterCtrl ActiveX Control class.

#include "stdafx.h"
#include "Splitter.h"
#include "SplitterCtl.h"
#include "SplitterPpg.h"
#include "CtrlWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSplitterCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSplitterCtrl, COleControl)
	//{{AFX_MSG_MAP(CSplitterCtrl)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSplitterCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSplitterCtrl)
	DISP_FUNCTION(CSplitterCtrl, "CreateControl", CreateControl, VT_BOOL, VTS_I4 VTS_I4 VTS_BSTR)
	DISP_FUNCTION(CSplitterCtrl, "GetControl", GetControl, VT_BOOL, VTS_I4 VTS_I4 VTS_PI4)
	DISP_FUNCTION(CSplitterCtrl, "GetControlIUnknown", GetControlIUnknown, VT_UNKNOWN, VTS_I4 VTS_I4)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSplitterCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSplitterCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSplitterCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSplitterCtrl, 1)
	PROPPAGEID(CSplitterPropPage::guid)
END_PROPPAGEIDS(CSplitterCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSplitterCtrl, "SPLITTER.SplitterCtrl.1",
	0x668e5408, 0x8e05, 0x11d2, 0x8a, 0xda, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSplitterCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSplitter =
		{ 0x58bb5d60, 0x8e20, 0x11d2, { 0x8a, 0xda, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const IID BASED_CODE IID_DSplitterEvents =
		{ 0x58bb5d61, 0x8e20, 0x11d2, { 0x8a, 0xda, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSplitterOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_IGNOREACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSplitterCtrl, IDS_SPLITTER, _dwSplitterOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::CSplitterCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSplitterCtrl

BOOL CSplitterCtrl::CSplitterCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SPLITTER,
			IDB_SPLITTER,
			afxRegApartmentThreading,
			_dwSplitterOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// Licensing strings

static const TCHAR BASED_CODE _szLicFileName[] = _T("Splitter.lic");

static const WCHAR BASED_CODE _szLicString[] =
	L"Copyright (c) 1998 Microsoft";


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::CSplitterCtrlFactory::VerifyUserLicense -
// Checks for existence of a user license

BOOL CSplitterCtrl::CSplitterCtrlFactory::VerifyUserLicense()
{
	return AfxVerifyLicFile(AfxGetInstanceHandle(), _szLicFileName,
		_szLicString);
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::CSplitterCtrlFactory::GetLicenseKey -
// Returns a runtime licensing key

BOOL CSplitterCtrl::CSplitterCtrlFactory::GetLicenseKey(DWORD dwReserved,
	BSTR FAR* pbstrKey)
{
	if (pbstrKey == NULL)
		return FALSE;

	*pbstrKey = SysAllocString(_szLicString);
	return (*pbstrKey != NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::CSplitterCtrl - Constructor

CSplitterCtrl::CSplitterCtrl()
{
	InitializeIIDs(&IID_DSplitter, &IID_DSplitterEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::~CSplitterCtrl - Destructor

CSplitterCtrl::~CSplitterCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::OnDraw - Drawing function

void CSplitterCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if( pdc == NULL )
	{
		return;
	}

	if( rcBounds.IsRectEmpty() )
	{
		return;
	}

	if( rcInvalid.IsRectEmpty() )
	{
		return;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::DoPropExchange - Persistence support

void CSplitterCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CSplitterCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();


	// The control can receive mouse notifications when inactive.
	// TODO: if you write handlers for WM_SETCURSOR and WM_MOUSEMOVE,
	//		avoid using the m_hWnd member variable without first
	//		checking that its value is non-NULL.
	dwFlags |= pointerInactive;
	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::OnResetState - Reset control to default state

void CSplitterCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl::AboutBox - Display an "About" box to the user

void CSplitterCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_SPLITTER);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl message handlers

int CSplitterCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_wndSplitter.CreateStatic(this,2,1);

	int iHeight = lpCreateStruct->cy > 100 ? lpCreateStruct->cy / 2 : 300;
	m_wndSplitter.CreateView(0,0,RUNTIME_CLASS(CCtrlWnd),CSize(50,iHeight),NULL);
	m_wndSplitter.CreateView(1,0,RUNTIME_CLASS(CCtrlWnd),CSize(0,iHeight),NULL);

	m_wndSplitter.MoveWindow(CRect(0,0,lpCreateStruct->cx,lpCreateStruct->cy));
	m_wndSplitter.ShowWindow(SW_SHOW);
	m_wndSplitter.UpdateWindow();
		

	return 0;
}

BOOL CSplitterCtrl::OnSetExtent(LPSIZEL lpSizeL) 
{
	if( GetSafeHwnd() )
	{
		CClientDC dc(this);

		SIZE size = *lpSizeL;

		dc.HIMETRICtoDP(&size);

		m_wndSplitter.SetWindowPos(NULL,0,0,size.cx,size.cy,SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);
	}
	
	return COleControl::OnSetExtent(lpSizeL);
}

BOOL CSplitterCtrl::CreateControl(long lRow, long lColumn, LPCTSTR lpszControlID) 
{
	if( lRow < 0 || lColumn < 0 )
	{
		return FALSE;
	}

	if( lRow > 2 || lColumn > 2 )
	{
		return FALSE;
	}

	if( lpszControlID == NULL )
	{
		return FALSE;
	}

	CWnd* pWnd = m_wndSplitter.GetPane(lRow,lColumn);
	if( pWnd && ! pWnd->IsKindOf(RUNTIME_CLASS(CCtrlWnd)) )
	{
		return FALSE;
	}

	CCtrlWnd* pCtrlWnd = (CCtrlWnd*)pWnd;

	BOOL bResult = pCtrlWnd->CreateControl(lpszControlID);
	if( bResult == FALSE )
	{
		return FALSE;
	}

	pWnd = pCtrlWnd->GetControl();
	if( pWnd == NULL )
	{
		return FALSE;
	}

	if( ! pWnd->GetSafeHwnd() || ! ::IsWindow(pWnd->GetSafeHwnd()) )
	{
		return FALSE;
	}

	return TRUE;
}


BOOL CSplitterCtrl::GetControl(long lRow, long lColumn, long FAR* phCtlWnd) 
{
	if( phCtlWnd == NULL )
	{
		return FALSE;
	}

	if( lRow < 0 || lColumn < 0 )
	{
		*phCtlWnd = NULL;
		return FALSE;
	}

	if( lRow > 2 || lColumn > 2 )
	{
		*phCtlWnd = NULL;
		return FALSE;
	}

	CWnd* pWnd = m_wndSplitter.GetPane(lRow,lColumn);
	if( pWnd && ! pWnd->IsKindOf(RUNTIME_CLASS(CCtrlWnd)) )
	{
		*phCtlWnd = NULL;
		return FALSE;
	}

	CCtrlWnd* pCtrlWnd = (CCtrlWnd*)pWnd;

	pWnd = pCtrlWnd->GetControl();
	if( pWnd == NULL )
	{
		*phCtlWnd = NULL;
		return FALSE;
	}

	if( ! pWnd->GetSafeHwnd() || ! ::IsWindow(pWnd->GetSafeHwnd()) )
	{
		*phCtlWnd = NULL;
		return FALSE;
	}

#ifndef IA64
	*phCtlWnd = (long)pWnd->GetSafeHwnd();
#endif // IA64 

	return TRUE;

}

LPUNKNOWN CSplitterCtrl::GetControlIUnknown(long lRow, long lColumn) 
{

	if( lRow < 0 || lColumn < 0 )
	{
		return NULL;
	}

	if( lRow > 2 || lColumn > 2 )
	{
		return NULL;
	}

	CWnd* pWnd = m_wndSplitter.GetPane(lRow,lColumn);
	if( pWnd && ! pWnd->IsKindOf(RUNTIME_CLASS(CCtrlWnd)) )
	{		
		return NULL;
	}

	CCtrlWnd* pCtrlWnd = (CCtrlWnd*)pWnd;

	LPUNKNOWN lpUnk = pCtrlWnd->GetControlIUnknown();

	return lpUnk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterctl.h ===
#if !defined(AFX_SPLITTERCTL_H__58BB5D6F_8E20_11D2_8ADA_0000F87A3912__INCLUDED_)
#define AFX_SPLITTERCTL_H__58BB5D6F_8E20_11D2_8ADA_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// SplitterCtl.h : Declaration of the CSplitterCtrl ActiveX Control class.

#include "SplitterWndEx.h"

/////////////////////////////////////////////////////////////////////////////
// CSplitterCtrl : See SplitterCtl.cpp for implementation.

class CSplitterCtrl : public COleControl
{
	DECLARE_DYNCREATE(CSplitterCtrl)

// Constructor
public:
	CSplitterCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	virtual BOOL OnSetExtent(LPSIZEL lpSizeL);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CSplitterCtrl();

	CSplitterWndEx m_wndSplitter;

	BEGIN_OLEFACTORY(CSplitterCtrl)        // Class factory and guid
		virtual BOOL VerifyUserLicense();
		virtual BOOL GetLicenseKey(DWORD, BSTR FAR*);
	END_OLEFACTORY(CSplitterCtrl)

	DECLARE_OLETYPELIB(CSplitterCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSplitterCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSplitterCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CSplitterCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CSplitterCtrl)
	afx_msg BOOL CreateControl(long lRow, long lColumn, LPCTSTR lpszControlID);
	afx_msg BOOL GetControl(long lRow, long lColumn, long FAR* phCtlWnd);
	afx_msg LPUNKNOWN GetControlIUnknown(long lRow, long lColumn);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CSplitterCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSplitterCtrl)
	dispidCreateControl = 1L,
	dispidGetControl = 2L,
	dispidGetControlIUnknown = 3L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPLITTERCTL_H__58BB5D6F_8E20_11D2_8ADA_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\upgclean\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_HEALTHMONPRV_DESC               101
//#define IDR_TrustPrv                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterppg.cpp ===
// SplitterPpg.cpp : Implementation of the CSplitterPropPage property page class.

#include "stdafx.h"
#include "Splitter.h"
#include "SplitterPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSplitterPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSplitterPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CSplitterPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSplitterPropPage, "SPLITTER.SplitterPropPage.1",
	0x58bb5d62, 0x8e20, 0x11d2, 0x8a, 0xda, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// CSplitterPropPage::CSplitterPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CSplitterPropPage

BOOL CSplitterPropPage::CSplitterPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SPLITTER_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterPropPage::CSplitterPropPage - Constructor

CSplitterPropPage::CSplitterPropPage() :
	COlePropertyPage(IDD, IDS_SPLITTER_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CSplitterPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT

	SetHelpInfo(_T("Names to appear in the control"), _T("SPLITTER.HLP"), 0);
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterPropPage::DoDataExchange - Moves data between page and properties

void CSplitterPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CSplitterPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CSplitterPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterppg.h ===
#if !defined(AFX_SPLITTERPPG_H__58BB5D71_8E20_11D2_8ADA_0000F87A3912__INCLUDED_)
#define AFX_SPLITTERPPG_H__58BB5D71_8E20_11D2_8ADA_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// SplitterPpg.h : Declaration of the CSplitterPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CSplitterPropPage : See SplitterPpg.cpp.cpp for implementation.

class CSplitterPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CSplitterPropPage)
	DECLARE_OLECREATE_EX(CSplitterPropPage)

// Constructor
public:
	CSplitterPropPage();

// Dialog Data
	//{{AFX_DATA(CSplitterPropPage)
	enum { IDD = IDD_PROPPAGE_SPLITTER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CSplitterPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPLITTERPPG_H__58BB5D71_8E20_11D2_8ADA_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterwndex.cpp ===
// SplitWnd.cpp : implementation file
// 
#include "stdafx.h"
#include "SplitterWndEx.h" 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif 

// HitTest return values (values and spacing between values is important)
// Had to adopt this because it has module scope 
enum HitTestValue
{
	noHit = 0,
	vSplitterBox = 1,
	hSplitterBox = 2,
	bothSplitterBox = 3, // just for keyboard
	vSplitterBar1 = 101,
	vSplitterBar15 = 115,
	hSplitterBar1 = 201,
	hSplitterBar15 = 215,
	splitterIntersection1 = 301,
	splitterIntersection225 = 525
}; 

/////////////////////////////////////////////////////////////////////////////
// CSplitterWndEx 

BEGIN_MESSAGE_MAP(CSplitterWndEx, CSplitterWnd)
//{{AFX_MSG_MAP(CSplitterWndEx)
// NOTE - the ClassWizard will add and remove mapping macros here.
//}}AFX_MSG_MAP
END_MESSAGE_MAP() 

CWnd* CSplitterWndEx::GetActivePane(int* pRow, int* pCol)
{
	ASSERT_VALID(this); 
	CWnd* pView = GetFocus();
	// make sure the pane is a child pane of the splitter
	if (pView != NULL && !IsChildPane(pView, pRow, pCol))
	{
		pView = NULL; 
	}
	return pView;
} 

void CSplitterWndEx::SetActivePane( int row, int col, CWnd* pWnd)
{
	// set the focus to the pane
	CWnd* pPane = pWnd == NULL ? GetPane(row, col) : pWnd;
	pPane->SetFocus();
} 

void CSplitterWndEx::StartTracking(int ht)
{
	ASSERT_VALID(this);
	if (ht == noHit)
	{
		return; 
	}

	// GetHitRect will restrict 'm_rectLimit' as appropriate
	GetInsideRect(m_rectLimit); 
	if (ht >= splitterIntersection1 && ht <= splitterIntersection225)
	{
		// split two directions (two tracking rectangles)
		int row = (ht - splitterIntersection1) / 15;
		int col = (ht - splitterIntersection1) % 15; 
		GetHitRect(row + vSplitterBar1, m_rectTracker);
		int yTrackOffset = m_ptTrackOffset.y;
		m_bTracking2 = TRUE;
		GetHitRect(col + hSplitterBar1, m_rectTracker2);
		m_ptTrackOffset.y = yTrackOffset;
	}
	else if (ht == bothSplitterBox)
	{
		// hit on splitter boxes (for keyboard)
		GetHitRect(vSplitterBox, m_rectTracker);
		int yTrackOffset = m_ptTrackOffset.y;
		m_bTracking2 = TRUE;
		GetHitRect(hSplitterBox, m_rectTracker2);
		m_ptTrackOffset.y = yTrackOffset; 

		// center it
		m_rectTracker.OffsetRect(0, m_rectLimit.Height()/2);
		m_rectTracker2.OffsetRect(m_rectLimit.Width()/2, 0);
	}
	else
	{
		// only hit one bar
		GetHitRect(ht, m_rectTracker);
	} 

	// steal focus and capture
	SetCapture();
	SetFocus(); 

	// make sure no updates are pending
	RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW); 

	// set tracking state and appropriate cursor
	m_bTracking = TRUE;
	OnInvertTracker(m_rectTracker);
	if (m_bTracking2)
	{
		OnInvertTracker(m_rectTracker2);
	}
	m_htTrack = ht;
	SetSplitCursor(ht);
} 

/////////////////////////////////////////////////////////////////////////////
// CSplitterWnd command routing 
BOOL CSplitterWndEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (CWnd::OnCommand(wParam, lParam))
	{
		return TRUE; 
	}

	// route commands to the splitter to the parent frame window
	return (BOOL) GetParent()->SendMessage(WM_COMMAND, wParam, lParam);
} 

BOOL CSplitterWndEx::OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult )
{
	if (CWnd::OnNotify(wParam, lParam, pResult))
	{
		return TRUE; 
	}

	// route commands to the splitter to the parent frame window
	*pResult = GetParent()->SendMessage(WM_NOTIFY, wParam, lParam);
	return TRUE;
} 

BOOL CSplitterWndEx::OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{ 
	// The code line below is necessary if using CSplitterWndEx in a regular dll
	// AFX_MANAGE_STATE(AfxGetStaticModuleState()); 
	return CWnd::OnWndMsg(message, wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\splitterwndex.h ===
#ifndef __SPLITTERWNDEX_H__
#define __SPLITTERWNDEX_H__

// SplitWnd.h : implementation file
// 
class CSplitterWndEx : public CSplitterWnd
{
	// Construction
	public:
	CSplitterWndEx() {};
	virtual ~CSplitterWndEx() {}; 

	// Operations
	public: 
	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterWndEx)
	//}}AFX_VIRTUAL 

	// Implementation
	public: 
	// These are the methods to be overridden
	virtual void StartTracking(int ht); 
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL);
	virtual void SetActivePane( int row, int col, CWnd* pWnd = NULL ); 
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	virtual BOOL OnWndMsg( UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult ); 

	// Generated message map functions
	protected:
	//{{AFX_MSG(CSplitterWndEx)
	// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__SPLITTERWNDEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\splitter\stdafx.h ===
#if !defined(AFX_STDAFX_H__58BB5D65_8E20_11D2_8ADA_0000F87A3912__INCLUDED_)
#define AFX_STDAFX_H__58BB5D65_8E20_11D2_8ADA_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <Afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__58BB5D65_8E20_11D2_8ADA_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\cred.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// credentials dialog
//
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword
// 12-18-00 jonn      260752: changed to CredUIPromptForCredentials



#include "headers.hxx"
#include "cred.hpp"
#include "resource.h"
#include <wincred.h>  // CredUIPromptForCredentials


// JonN 10/5/00 188220
// JonN 12/18/00 260752: changed to CredUIPromptForCredentials
bool RetrieveCredentials(
   HWND     hwndParent,
   unsigned promptResID,
   String&  username,
   String&  password)
{
   ASSERT( NULL != hwndParent && 0 != promptResID );

   String strMessageText = String::load(promptResID);
   String strAppTitle = String::load(IDS_APP_TITLE);

   CREDUI_INFO uiInfo;
   ::ZeroMemory( &uiInfo, sizeof(uiInfo) );
   uiInfo.cbSize = sizeof(uiInfo);
   uiInfo.hwndParent = hwndParent;
   uiInfo.pszMessageText = strMessageText.c_str();
   uiInfo.pszCaptionText = strAppTitle.c_str();

   TCHAR achUserName[CREDUI_MAX_USERNAME_LENGTH];
   TCHAR achPassword[CREDUI_MAX_PASSWORD_LENGTH];
   ::ZeroMemory(&achUserName,sizeof(achUserName));
   ::ZeroMemory(&achPassword,sizeof(achPassword));

   DWORD dwErr = CredUIPromptForCredentials(
      &uiInfo,
      NULL,
      NULL,
      NO_ERROR,
      achUserName,
      CREDUI_MAX_USERNAME_LENGTH,
      achPassword,
      CREDUI_MAX_PASSWORD_LENGTH,
      NULL,
      CREDUI_FLAGS_DO_NOT_PERSIST | CREDUI_FLAGS_GENERIC_CREDENTIALS
      );
   if (NO_ERROR != dwErr) // e.g. ERROR_CANCELLED
      return false;

   username = achUserName;
   password = achPassword;

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\helpids.h ===
// Copyright (c) 1997-1999 Microsoft Corporation

#define IDH_IDENT_FULL_NAME                         5101
#define IDH_IDENT_MEMBER_OF                         5102
#define IDH_IDENT_CHANGE_BUTTON                     5103
#define IDH_IDENT_CHANGES_NEW_NAME                  5104
#define IDH_IDENT_CHANGES_PREVIEW_NAME              5105
#define IDH_IDENT_CHANGES_MORE_BUTTON               5106
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN             5107
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX     5108
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP            5109
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX    5110
#define IDH_IDENT_NAMES_DNS_NAME                    5111
#define IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX         5112
#define IDH_IDENT_NAMES_NETBIOS_NAME                5113
#define IDH_IDENT_CHANGE_ADVANCED_BUTTON            5114
#define IDH_COMPUTER_DESCRIPTION                    5115
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\cred.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// credentials dialog 
// 
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword



#ifndef CREDDLG_HPP_INCLUDED
#define CREDDLG_HPP_INCLUDED


// JonN 10/5/00 188220 use CredUIGetPassword
bool RetrieveCredentials(
   HWND     hwndParent,
   unsigned promptResID,
   String&  username,
   String&  password);


#endif   // CREDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\dllmain.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid entry points
// 
// 3-2-98 sburns



#include "headers.hxx"
#include "idpage.hpp"
#include "resource.h"
#include <DiagnoseDcNotFound.hpp>
#include <DiagnoseDcNotFound.h>


HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = L"\\help\\sysdm.hlp";
const wchar_t* RUNTIME_NAME = L"netid";

// default: no debugging

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



Popup popup(IDS_APP_TITLE);



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");

         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");       

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



HPROPSHEETPAGE
CreateNetIDPropertyPage()
{
   LOG_FUNCTION(CreateNetIDPropertyPage);

   // CODEWORK: pass this along to the rest of the UI

   Computer c;
   HRESULT hr = c.Refresh();

   // This should always succeed, but if not, the object falls back to as
   // reasonable a default as can be expected.

   ASSERT(SUCCEEDED(hr));

   bool isWorkstation = false;
   switch (c.GetRole())
   {
      case Computer::STANDALONE_WORKSTATION:
      case Computer::MEMBER_WORKSTATION:
      {
         isWorkstation = true;
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   // JonN 10/4/00 Determine whether this is Whistler Personal
   bool isPersonal = false;
   OSVERSIONINFOEX osvi;
   ::ZeroMemory( &osvi, sizeof(osvi) );
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
   if (GetVersionEx( (LPOSVERSIONINFO)&osvi ))
       isPersonal = !!(osvi.wSuiteMask & VER_SUITE_PERSONAL);

   // this is deleted by the proppage callback function
   return (new NetIDPage(isWorkstation,isPersonal))->Create();
}



// this exported function is also used by the net access wizard.
//
// Bring up a modal error message dialog that shows the user an error message
// and offers to run some diagnostic tests and point the user at some help to
// try to resolve the problem.
// 
// parent - in, the handle to the parent of this dialog.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  If this parameter is null or the empty string, then the
// function does nothing.
//
// dialogTitle - in, title string for the dialog

void
ShowDcNotFoundErrorDialog(
   HWND     parent,
   PCWSTR   domainName,
   PCWSTR   dialogTitle)
{
   LOG_FUNCTION(ShowDcNotFoundErrorDialog);
   ASSERT(Win::IsWindow(parent));
   ASSERT(domainName && domainName[0]);
   
   if (domainName && domainName[0])
   {
      ShowDcNotFoundErrorDialog(
         parent,
         -1,
         domainName,
         dialogTitle,
         String::format(IDS_GENERIC_DC_NOT_FOUND_PARAM, domainName),
         false);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\iddlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Id changes dialog
// 
// 3-10-98 sburns



#include "headers.hxx"
#include "iddlg.hpp"
#include "moredlg.hpp"
#include "resource.h"
#include "helpids.h"
#include "state.hpp"
#include <DiagnoseDcNotFound.hpp>
#include <DiagnoseDcNotFound.h>



static const DWORD HELP_MAP[] =
{
   IDC_MESSAGE,            NO_HELP,
   IDC_FULL_NAME,          IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_FULL_LABEL,         IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_NEW_NAME,           IDH_IDENT_CHANGES_NEW_NAME,
   IDC_MORE,               IDH_IDENT_CHANGES_MORE_BUTTON,
   IDC_DOMAIN_BUTTON,      IDH_IDENT_CHANGES_MEMBER_DOMAIN,
   IDC_WORKGROUP_BUTTON,   IDH_IDENT_CHANGES_MEMBER_WORKGRP,
   IDC_DOMAIN,             IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX,
   IDC_WORKGROUP,          IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX,
   IDC_FIND,               NO_HELP,
   IDC_GROUP,              NO_HELP,
   0, 0
};



IDChangesDialog::IDChangesDialog(bool isPersonal)
   :
   Dialog((isPersonal) ? IDD_CHANGES_PER : IDD_CHANGES, HELP_MAP),
   isInitializing(false),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(IDChangesDialog);
}



IDChangesDialog::~IDChangesDialog()
{
   LOG_DTOR(IDChangesDialog);
}



void
IDChangesDialog::enable(HWND hwnd)
{
   State& state = State::GetInstance();
   bool networkingInstalled = state.IsNetworkingInstalled();
   bool isDc = state.IsMachineDc();
   bool workgroup = Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
   // Note that this can be called via EN_CHANGE before OnInit, so that
   // the workgroup checkbox may not have been properly enabled.

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      !workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_FIND),
      !workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WORKGROUP),
      workgroup && networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WORKGROUP_BUTTON),
      networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DOMAIN_BUTTON),
      networkingInstalled && !isDc);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_GROUP),
      networkingInstalled && !isDc);

   bool b = false;
   if (workgroup)
   {
      b = !Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP).empty();
   }
   else
   {
      b = !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty();
   }

   bool enabled =
         state.ChangesNeedSaving()
      && b
      && !Win::GetTrimmedDlgItemText(hwnd, IDC_NEW_NAME).empty();
   
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), enabled);
}



void
showAndEnableWindow(HWND parent, int resID, int show)
{
   ASSERT(Win::IsWindow(parent));
   ASSERT(resID > 0);
   ASSERT(show == SW_SHOW || show == SW_HIDE);

   HWND window = Win::GetDlgItem(parent, resID);
   Win::ShowWindow(window, show);
   Win::EnableWindow(window, show == SW_SHOW ? true : false);
}



void
SetUppercaseStyle(HWND edit)
{
   LOG_FUNCTION(SetUppercaseStyle);
   ASSERT(Win::IsWindow(edit));

   LONG style = 0;
   HRESULT hr = Win::GetWindowLong(edit, GWL_STYLE, style);
   ASSERT(SUCCEEDED(hr));

   style |= ES_UPPERCASE;
   hr = Win::SetWindowLong(edit, GWL_STYLE, style);
   ASSERT(SUCCEEDED(hr));
}



void
IDChangesDialog::OnInit()
{
   LOG_FUNCTION(IDChangesDialog::OnInit);

   isInitializing = true;

   State& state = State::GetInstance();
   Win::SetDlgItemText(hwnd, IDC_FULL_NAME, state.GetFullComputerName());
   Win::SetDlgItemText(hwnd, IDC_NEW_NAME, state.GetShortComputerName());

   bool joinedToWorkgroup = state.IsMemberOfWorkgroup();
   ASSERT( joinedToWorkgroup || !fIsPersonal );
   Win::CheckDlgButton(
      hwnd,
      IDC_WORKGROUP_BUTTON,
      joinedToWorkgroup ? BST_CHECKED : BST_UNCHECKED);
   Win::CheckDlgButton(
      hwnd,
      IDC_DOMAIN_BUTTON,
      joinedToWorkgroup ? BST_UNCHECKED : BST_CHECKED);
   Win::SetDlgItemText(
      hwnd,
      joinedToWorkgroup ? IDC_WORKGROUP : IDC_DOMAIN,
      state.GetDomainName());

   bool networkingInstalled = state.IsNetworkingInstalled();
   bool tcpInstalled = networkingInstalled && IsTcpIpInstalled();

   int show = tcpInstalled ? SW_SHOW : SW_HIDE;
   showAndEnableWindow(hwnd, IDC_FULL_LABEL, show);
   showAndEnableWindow(hwnd, IDC_FULL_NAME,  show);
   showAndEnableWindow(hwnd, IDC_MORE,       show);

   HWND newNameEdit    = Win::GetDlgItem(hwnd, IDC_NEW_NAME);
   HWND domainNameEdit = Win::GetDlgItem(hwnd, IDC_DOMAIN);  

   Win::Edit_LimitText(
      domainNameEdit,
      tcpInstalled ? Dns::MAX_NAME_LENGTH : DNLEN);
   Win::Edit_LimitText(
      newNameEdit, 
      tcpInstalled ? Dns::MAX_LABEL_LENGTH : MAX_COMPUTERNAME_LENGTH);

   if (!tcpInstalled)
   {
      // Without tcp/ip, new name and domain need to look like netbios, so set
      // the uppercase style on those boxen.

      SetUppercaseStyle(newNameEdit);
      SetUppercaseStyle(domainNameEdit);
   }

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_WORKGROUP), DNLEN);

   // no networking at all further restricts the UI to just NetBIOS-like
   // computer name changes.

   if (!networkingInstalled)
   {
      // enable() will handle disabling the inapplicable ui

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_MESSAGE),
         String::load(IDS_NAME_MESSAGE));
   }
   else
   {
      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_MESSAGE),
         String::load(IDS_NAME_AND_MEMBERSHIP_MESSAGE));
   }
                  
   ClearChanges();
   enable(hwnd);

   isInitializing = false;
}



bool
ValidateNetbiosAndFullNames(HWND dialog, const String& shortName)
{
   LOG_FUNCTION(ValidateNetbiosAndFullNames);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!shortName.empty());

   HRESULT err = S_OK;
   String flatname = Dns::HostnameToNetbiosName(shortName, &err);
   if (flatname.empty() || FAILED(err))
   {
      // the flatname conversion failed.  
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         err,
         String::format(
            IDS_CONVERSION_TO_NETBIOS_NAME_FAILED,
            shortName.c_str()));
      return false;
   }

   if (flatname.is_numeric())
   {
      // the truncated version may be a number. If we catch this here, it is
      // because the name was truncated.. This is because the hostname is
      // checked against being a number in ValidateComputerNames.  401076

      ASSERT(shortName.length() > flatname.length());

      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         String::format(
            IDS_NETBIOS_NAME_NUMERIC,
            flatname.c_str(),
            CNLEN));
      return false;
   }

   if (shortName.length() > flatname.length())
   {
      // warn that the netbios name will be truncated.
      popup.Info(
         dialog,
         String::format(
            IDS_NAME_TRUNCATED,
            CNLEN,
            flatname.c_str()));
   }

   // here the flatname is of the proper length in bytes (because the
   // hostname-to-flatname API guarantees that), is not a number, so the only
   // other possible syntax problem would be illegal characters.

   if (ValidateNetbiosComputerName(flatname) != VALID_NAME)
   {
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         String::format(
            IDS_BAD_NETBIOS_CHARACTERS,
            flatname.c_str()));
      return false;
   }

   State& state = State::GetInstance();
   if (!state.IsNetworkingInstalled())
   {
      // We can't validate these names further without networking, so they
      // pass      
      return true;
   }

   if (state.WasNetbiosComputerNameChanged())
   {
      HRESULT hr = MyNetValidateName(flatname, NetSetupMachine);
      if (FAILED(hr))
      {
         // the netbios name is in use
         popup.Gripe(
            dialog,
            IDC_NEW_NAME,
            hr,
            String::format(IDS_VALIDATE_NAME_FAILED, flatname.c_str()));
         return false;
      }
   }

   // here, the netbios name has not changed with the new short name, or is
   // ok.

   if (!IsTcpIpInstalled())
   {
      // We can't validate the full DNS name of the computer without TCP/IP
      // so the name passes.
      return true;
   }

   HRESULT hr =
      MyNetValidateName(state.GetFullComputerName(), NetSetupDnsMachine);

   if (FAILED(hr) and hr != Win32ToHresult(DNS_ERROR_NON_RFC_NAME))
   {
      // the full dns name is in use
      popup.Gripe(
         dialog,
         IDC_NEW_NAME,
         hr,
         String::format(
            IDS_VALIDATE_NAME_FAILED,
            state.GetFullComputerName().c_str()));
      return false;
   }

   return true;
}



// validates the short name, the full name, and the netbios names, raising
// UI to complain on failures, returns false if any name fails, true if all
// names pass.
//
// this is also good for the tcp/ip not installed case, as the edit control
// limits the text length, and we decided not to allow '.' in netbios names
// any longer

bool
ValidateComputerNames(HWND dialog)
{
   LOG_FUNCTION(ValidateComputerNames);
   ASSERT(Win::IsWindow(dialog));

   State& state = State::GetInstance();
   if (!state.WasShortComputerNameChanged())
   {
      return true;
   }

   String shortName = state.GetShortComputerName();

   String message;
   switch (Dns::ValidateDnsLabelSyntax(shortName))
   {
      case Dns::VALID:
      {
         return ValidateNetbiosAndFullNames(dialog, shortName);
      }
      case Dns::TOO_LONG:
      {
         message =
            String::format(
               IDS_COMPUTER_NAME_TOO_LONG,
               shortName.c_str(),
               Dns::MAX_LABEL_LENGTH);
         break;
      }
      case Dns::NON_RFC:
      {
         message =
            String::format(
               IDS_NON_RFC_COMPUTER_NAME_SYNTAX,
               shortName.c_str());
         if (
            popup.MessageBox(
               dialog,
               message,
               MB_ICONWARNING | MB_YESNO) == IDYES)
         {
            return ValidateNetbiosAndFullNames(dialog, shortName);
         }

         HWND edit = Win::GetDlgItem(dialog, IDC_NEW_NAME);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         return false;
      }
      case Dns::NUMERIC:
      {
         message =
            String::format(IDS_COMPUTER_NAME_NUMERIC, shortName.c_str());
         break;
      }
      case Dns::BAD_CHARS:
      {
         message =
            String::format(
               IDS_COMPUTER_NAME_HAS_BAD_CHARS,
               shortName.c_str());
         break;
      }
      case Dns::INVALID:
      {
         message =
            String::format(
               IDS_BAD_COMPUTER_NAME_SYNTAX,
               shortName.c_str());
         break;
      }
      default:
      {
         ASSERT(false);
         message =
            String::format(IDS_BAD_COMPUTER_NAME_SYNTAX, shortName.c_str());
         break;
      }
   }

   popup.Gripe(dialog, IDC_NEW_NAME, message);

   return false;
}



bool
WorkgroupNameTooLong(const String& name)
{
   LOG_FUNCTION2(WorkgroupNameTooLong, name);
   ASSERT(!name.empty());

   bool result = false;
   do
   {
      // first- cheap length test.  Since a character will never be smaller
      // than 1 byte, if the number of characters exceeds the number of
      // bytes, we know it will never fit.

      if (name.length() > DNLEN)
      {
         result = true;
         break;
      }

      // second- check length of against corresponding UTF8 string
      // utf8bytes is the number of bytes (not characters) required to hold
      // the string in the UTF-8 character set.

      size_t oemBytes = 
         static_cast<size_t>(
            // @@ why isn't this wrapped with a Win function?
            ::WideCharToMultiByte(
               CP_OEMCP,
               0,
               name.c_str(),
               static_cast<int>(name.length()),
               0,
               0,
               0,
               0));

      LOG(String::format(L"name is %1!d! oem bytes", oemBytes));

      if (oemBytes > DNLEN)
      {
         LOG(L"oem length too long");

         result = true;
         break;
      }
   }
   while (0);

   LOG(String::format(L"name %1 too long", result ? L"is" : L"is NOT" ));

   return result;
}



bool
ValidateDomainOrWorkgroupName(HWND dialog)
{
   LOG_FUNCTION(ValidateDomainOrWorkgroupName);
   ASSERT(Win::IsWindow(dialog));

   if (!State::GetInstance().WasMembershipChanged())
   {
      return true;
   }

   HRESULT hr = S_OK;
   int     nameId = 0;   
   String  name;

   if (Win::IsDlgButtonChecked(dialog, IDC_DOMAIN_BUTTON))
   {
      nameId = IDC_DOMAIN;
      name = Win::GetTrimmedDlgItemText(dialog, nameId);
      hr = MyNetValidateName(name, NetSetupDomain);

      if (hr == Win32ToHresult(DNS_ERROR_NON_RFC_NAME))
      {
         // accept non-rfc dns names.  We have to check for the reachability
         // of the domain because NetValidateName will not bother to check
         // reachability for non-rfc names.

         hr = S_OK;
         if (!IsDomainReachable(name))
         {
            hr = Win32ToHresult(ERROR_NO_SUCH_DOMAIN);
         }
      }

      if (hr == Win32ToHresult(ERROR_NO_SUCH_DOMAIN))
      {
         // domain not found.  Call the diagnostic error message dialog.

         ShowDcNotFoundErrorDialog(
            dialog,
            nameId,
            name,
            String::load(IDS_APP_TITLE),
            String::format(IDS_GENERIC_DC_NOT_FOUND_PARAM, name.c_str()),
            false,
            false);
            
         return false;
      }
   }
   else
   {
      nameId = IDC_WORKGROUP;
      name = Win::GetTrimmedDlgItemText(dialog, nameId);

      // we do our own length checking, as the NetValidateName API
      // does not return a distinct error code for length problems. 26968

      if (WorkgroupNameTooLong(name))
      {
         popup.Gripe(
            dialog,
            nameId,
            String::format(
               IDS_WORKGROUP_NAME_TOO_LONG,
               name.c_str(),
               DNLEN));
         return false;
      }

      hr = MyNetValidateName(name, NetSetupWorkgroup);
   }

   if (FAILED(hr))
   {
      popup.Gripe(
         dialog,
         nameId,
         hr,
         String::format(IDS_VALIDATE_NAME_FAILED, name.c_str()));
      return false;
   }

   return true;
}
      


bool
IDChangesDialog::OnOkButton()
{
   State& state = State::GetInstance();
   ASSERT(state.ChangesNeedSaving());

   Win::CursorSetting cursor(IDC_WAIT);

   String preconditionErrorMessage = CheckPreconditions();
   if (!preconditionErrorMessage.empty())
   {
      popup.Error(
         hwnd,
         preconditionErrorMessage);
      return false;
   }

   // computer primary DNS name has already been validated by
   // MoreChangesDialog

   state.SetShortComputerName(Win::GetTrimmedDlgItemText(hwnd, IDC_NEW_NAME));
   bool workgroup =
      Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
   state.SetIsMemberOfWorkgroup(workgroup);
   if (workgroup)
   {
      state.SetDomainName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP));
   }
   else
   {
      state.SetDomainName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));
   }

   // 341483
   if (state.GetShortComputerName().icompare(state.GetDomainName()) == 0)
   {
      // can't have domain/workgroup name same as computer name
      popup.Gripe(
         hwnd,
         IDC_NEW_NAME,
            workgroup
         ?  IDS_COMPUTER_NAME_EQUALS_WORKGROUP_NAME
         :  IDS_COMPUTER_NAME_EQUALS_DOMAIN_NAME);
      return false;
   }

   if (
         !ValidateComputerNames(hwnd)
      || !ValidateDomainOrWorkgroupName(hwnd))
   {
      return false;
   }

   if (state.SaveChanges(hwnd))
   {
      popup.Info(hwnd, IDS_MUST_REBOOT);
      State::GetInstance().SetChangesMadeThisSession(true);      
      return true;
   }

   return false;
}



bool
IDChangesDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   State& state = State::GetInstance();
   switch (controlIDFrom)
   {
      case IDC_MORE:
      {
         if (code == BN_CLICKED)
         {
            MoreChangesDialog dlg(fIsPersonal);
            if (dlg.ModalExecute(hwnd) == MoreChangesDialog::CHANGES_MADE)
            {
               Win::SetDlgItemText(
                  hwnd,
                  IDC_FULL_NAME,
                  state.GetFullComputerName());               
               enable(hwnd);
            }
         }
         break;
      }
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (OnOkButton())
            {
               HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_WORKGROUP_BUTTON:
      case IDC_DOMAIN_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            bool workgroup =
               Win::IsDlgButtonChecked(hwnd, IDC_WORKGROUP_BUTTON);
            state.SetIsMemberOfWorkgroup(workgroup);
            if (workgroup)
            {
               state.SetDomainName(
                  Win::GetTrimmedDlgItemText(hwnd, IDC_WORKGROUP));
            }
            else
            {
               state.SetDomainName(
                  Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));
            }
            enable(hwnd);
         }
         break;
      }
      case IDC_WORKGROUP:
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            state.SetDomainName(
               Win::GetTrimmedDlgItemText(hwnd, controlIDFrom));
            enable(hwnd);
         }
         break;
      }
      case IDC_NEW_NAME:
      {
         if (code == EN_CHANGE)
         {
            // the first time this path is hit, it is because of the SetText
            // in OnInit.  If that is the case, then don't overwrite the
            // short computer name, or we'll clobber the existing netbios name
            // wait till the second time thru this path (which will be due
            // do a user keypress)

            if (!isInitializing)
            {
               state.SetShortComputerName(
                  Win::GetTrimmedDlgItemText(hwnd, controlIDFrom));
               Win::SetDlgItemText(
                  hwnd,
                  IDC_FULL_NAME,
                  state.GetFullComputerName());
            }

            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\iddlg.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Id changes dialog
// 
// 3-10-98 sburns



#ifndef IDDLG_HPP_INCLUDED
#define IDDLG_HPP_INCLUDED



class IDChangesDialog : public Dialog
{
   public:

   IDChangesDialog(bool isPersonal);

   virtual ~IDChangesDialog();

//    enum ExecuteResult
//    {
//       NO_CHANGES,
//       CHANGES_MADE
//    };
// 
//    // hides Dialog::ModalExecute
// 
//    ExecuteResult
//    ModalExecute(HWND parent);

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   // enum OkButtonResult
   // {
   //    VALIDATION_FAILED,
   //    CHANGES_SAVED,
   //    SAVE_FAILED
   // };

   // OkButtonResult
   bool
   OnOkButton();

   void enable(HWND hwnd);

   // no copying allowed
   IDChangesDialog(const IDChangesDialog&);
   const IDChangesDialog& operator=(const IDChangesDialog&);

   bool isInitializing;
   bool fIsPersonal;
};


void
showAndEnableWindow(HWND parent, int resID, int show);


#endif   // IDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\upgclean\upgclean.cpp ===
//#define _WIN32_DCOM
#define RCLENGTH 50

#include <objbase.h>
#include <winsvc.h>
#include <tchar.h>
#include <stdio.h>
#include <wbemcli.h>

int StartWMI()
{
	OutputDebugString (L"StartWMI\n");
	int bFailed = TRUE;
	DWORD dwRC = NULL;

	SC_HANDLE hSvcCtrlMgrDB = OpenSCManager ( NULL , NULL , GENERIC_READ ) ;
	if ( hSvcCtrlMgrDB )
	{
		SC_HANDLE hService = OpenService ( hSvcCtrlMgrDB , L"Windows Management Instrumentation" , SERVICE_START ) ;
		if ( hService ) 
		{
			BOOL RC = StartService ( hService , 0 , NULL ) ;
			if ( RC )
			{
				bFailed = FALSE;
				OutputDebugString (L"Service Started\n");
			}
			else
			{
				dwRC = GetLastError();

				TCHAR RCText[RCLENGTH];
				swprintf(RCText, L"0x%d", dwRC);

				OutputDebugString(L"Service did not start.  Error code: ");
				OutputDebugString(RCText);
				OutputDebugString(L"\r\n");
			}

		}
		else
		{
			dwRC = GetLastError();

			TCHAR RCText[RCLENGTH];
			swprintf(RCText, L"0x%d", dwRC);

			OutputDebugString(L"Could not get handle to service.  Error code: ");
			OutputDebugString(RCText);
			OutputDebugString(L"\r\n");
		}
	}
	else
	{
		dwRC = GetLastError();

		TCHAR RCText[RCLENGTH];
		swprintf(RCText, L"0x%d", dwRC);

		OutputDebugString(L"Could not get handle to SCM.  Error code: ");
		OutputDebugString(RCText);
		OutputDebugString(L"\r\n");
	}
	return bFailed;
}

int StopWMI()
{
	OutputDebugString (L"StopWMI\n");
	int bFailed = TRUE;
	DWORD dwRC = NULL;

	SC_HANDLE hSvcCtrlMgrDB = OpenSCManager (NULL, NULL, GENERIC_READ);
	if ( hSvcCtrlMgrDB )
	{
		SC_HANDLE hService = OpenService (hSvcCtrlMgrDB, L"winmgmt", SERVICE_STOP);
		if ( hService ) 
		{
			SERVICE_STATUS lpServiceStatus;

			BOOL RC = ControlService (hService, SERVICE_CONTROL_STOP, &lpServiceStatus);
			if ( RC )
			{
				bFailed = FALSE;
				OutputDebugString (L"Service Stopped\n");
			}
			else
			{
				dwRC = GetLastError();

				TCHAR RCText[RCLENGTH];
				swprintf(RCText, L"0x%d", dwRC);

				OutputDebugString(L"Service did not be stopped. Error code: ");
				OutputDebugString(RCText);
				OutputDebugString(L"\r\n");
			}
		}
		else
		{
			dwRC = GetLastError();

			TCHAR RCText[RCLENGTH];
			swprintf(RCText, L"0x%d", dwRC);

			OutputDebugString(L"Could not get handle to service.  Error code: ");
			OutputDebugString(RCText);
			OutputDebugString(L"\r\n");
		}
	}
	else
	{
		dwRC = GetLastError();

		TCHAR RCText[RCLENGTH];
		swprintf(RCText, L"0x%d", dwRC);

		OutputDebugString(L"Could not get handle to SCM.  Error code: ");
		OutputDebugString(RCText);
		OutputDebugString(L"\r\n");
	}
	return bFailed;
}

HRESULT DelNamespace (IWbemLocator *pWbemLocator, BSTR bsParentNamespace, BSTR bsTargetNamespace)
{
	HRESULT hres = 0;
	IWbemServices *pWbemServices = NULL;

	hres = pWbemLocator->ConnectServer(bsParentNamespace,
										NULL,
										NULL,
										NULL,
										0L,
										NULL,
										NULL,
										&pWbemServices);
	if (FAILED(hres))
	{
		OutputDebugString(L"Could not connect to parent namespace.\n");
		return hres;
	}
	
	hres = pWbemServices->DeleteInstance(bsTargetNamespace,
										  NULL,
										  NULL,
										  NULL);

	pWbemServices->Release();
	pWbemServices = NULL;

	return hres;
}

HRESULT clean()
{
	OutputDebugString(L"clean function\n");

	HRESULT hres = CoInitialize(NULL);

	hres = CoInitializeSecurity(NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_CONNECT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, 0, 0);

	if (FAILED(hres))
	{
		OutputDebugString(L"CoInitializeSecurity Failed\n");
		return hres;
	}

	IWbemLocator *pIWbemLocator = NULL;

	hres = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
					        IID_IWbemLocator, (LPVOID *) &pIWbemLocator);
	if (FAILED(hres))
	{
		OutputDebugString(L"CoCreateInstance Failed\n");
		CoUninitialize();
		return hres;
	}

	BSTR bsParentNS = NULL;
	BSTR bsTargetNS = NULL;

	// Delete root\healthmon namespace if exists
	bsParentNS = SysAllocString (L"\\\\.\\root");
	bsTargetNS = SysAllocString (L"__namespace.name=\"HealthMon\"");

	hres = DelNamespace(pIWbemLocator, bsParentNS, bsTargetNS);

	SysFreeString(bsParentNS);
	SysFreeString(bsTargetNS);

	if (FAILED(hres))
	{
		OutputDebugString(L"Could not delete root\\healthmon\n");
	}

	// Delete root\cimv2\MicrosoftHealthMonitor namespace if exists
	bsParentNS = SysAllocString (L"\\\\.\\root\\cimv2");
	bsTargetNS = SysAllocString (L"__namespace.name=\"MicrosoftHealthMonitor\"");

	hres = DelNamespace(pIWbemLocator, bsParentNS, bsTargetNS);

	SysFreeString(bsParentNS);
	SysFreeString(bsTargetNS);

	if (FAILED(hres))
	{
		OutputDebugString(L"Could not delete root\\cimv2\\MicrosoftHealthMonitor\n");
	}
	
	pIWbemLocator->Release();
	pIWbemLocator = NULL;
	

	StopWMI();

	CoUninitialize();

	return TRUE;
}


int upgrade()
{
	OutputDebugString(L"upgrade function\n");
	return FALSE;
}


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
#ifdef SAVE
	_strupr (lpCmdLine);
	
	if (wcsstr(lpCmdLine, L"/CLEAN"))
	{
		OutputDebugString(L"clean command line\n");
		return clean();
	}

	if (wcsstr(lpCmdLine, L"/UPGRADE"))
	{
		OutputDebugString(L"upgrade command line\n");
		return upgrade();
	}
	
	return FALSE;
#endif
	return clean();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\idpage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid prop page
// 
// 3-10-98 sburns



#ifndef IDPAGE_HPP_INCLUDED
#define IDPAGE_HPP_INCLUDED



class NetIDPage : public PropertyPage
{
   public:

   // isWorkstation - true if machine is running a workstation product, false
   // if the machine is running a server product.

   NetIDPage(bool isWorkstation, bool isPersonal);

   protected:

   virtual ~NetIDPage();

   // Dialog overrides

   virtual 
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();
   
   virtual
   bool
   OnApply( bool isClosing );

   private:

   // no copying allowed
   NetIDPage(const NetIDPage&);
   const NetIDPage& operator=(const NetIDPage&);

   void
   refresh();

   bool
   evaluateButtonEnablingAndComposeMessageText(String& message);

   NTService certsvc;
   HICON     warnIcon;
   bool      fIsPersonal;
};

   

#endif   // IDPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\idpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// netid prop page
// 
// 3-10-98 sburns



#include "headers.hxx"
#include "idpage.hpp"
#include "resource.h"
#include "helpids.h"
#include "iddlg.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   IDC_IDENTIFICATION_TEXT,   NO_HELP,                         
   IDC_DESCRIPTION_EDIT,      IDH_COMPUTER_DESCRIPTION,
   IDC_FULL_NAME,             IDH_IDENT_FULL_NAME,
   IDC_FULL_NAME_STATIC,      IDH_IDENT_FULL_NAME,
   IDC_DOMAIN,                IDH_IDENT_MEMBER_OF,             
   IDC_ACCOUNT_WIZARD_BUTTON, IDH_IDENT_CHANGE_BUTTON,         
   IDC_CHANGE,                IDH_IDENT_CHANGE_ADVANCED_BUTTON,
   IDC_MEMBER_OF,             IDH_IDENT_MEMBER_OF,             
   IDC_COMPUTER_ICON,         NO_HELP,                         
   IDC_MESSAGE,               NO_HELP,
   IDC_WARNING_ICON,          NO_HELP,
   IDC_CLICK_MESSAGE1,        NO_HELP,
   IDC_CLICK_MESSAGE2,        NO_HELP,
   IDC_REBOOT_MESSAGE,        NO_HELP,
   IDC_STATIC_HELPLESS,       NO_HELP,
   0, 0                              
};



NetIDPage::NetIDPage(bool isWorkstation, bool isPersonal)
   :
   PropertyPage(isWorkstation ? (isPersonal ? IDD_NETID_PER : IDD_NETID)
                              : IDD_NETID_SRV,
                HELP_MAP),
   certsvc(L"CertSvc"),
   warnIcon(0),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(NetIDPage);
}



NetIDPage::~NetIDPage()
{
   LOG_DTOR(NetIDPage);

   State::Delete();

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
appendMessage(String& message, const String& additionalText)
{
   LOG_FUNCTION2(appendMessage, message + L"  " + additionalText);
   ASSERT(!additionalText.empty());

   if (message.empty())
   {
      // add intro first
      message = String::load(IDS_CANT_TWEAK_ID);
   }

   // then bullet items next
   message.append(L"\r\n" + additionalText);
}
      


// return false if the machine is undergoing a role change, or needs to
// be rebooted from a role change (i.e. dcpromo), true otherwise.
// If false, appends which condition to the provided string. 

bool
EvaluateRoleChangeState(String& message)
{
   LOG_FUNCTION(EvaluateRoleChangeState);

   bool result = true;

   switch (GetDsRoleChangeState())
   {
      case ::DsRoleOperationIdle:
      {
         // do nothing
         break;
      }
      case ::DsRoleOperationActive:
      {
         // a role change operation is underway
         result = false;
         appendMessage(message, String::load(IDS_ROLE_CHANGE_IN_PROGRESS));
         break;
      }
      case ::DsRoleOperationNeedReboot:
      {
         // a role change has already taken place, need to reboot before
         // attempting another.
         result = false;
         appendMessage(message, String::load(IDS_ROLE_CHANGE_NEEDS_REBOOT));
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return result;
}



// Returns true if the change and advanced buttons should be enabled, false if
// not.  As an added bonus, also composes the text to appear on the page
// indicating why the buttons are not enabled, and whether the values reflect
// current machine names or a reboot is required.  289623

bool
NetIDPage::evaluateButtonEnablingAndComposeMessageText(String& message)
{
   LOG_FUNCTION(NetIDPage::evaluateButtonEnablingAndComposeMessageText);

   State& state = State::GetInstance();

   bool result = true;

   do
   {
      if (!IsCurrentUserAdministrator())
      {
         // must be an administrator
         result = false;
         message = String::load(IDS_MUST_BE_ADMIN);

         // go no further -- more messages would reveal too much about this
         // machine to a non-admin.
         break;
      }

      // 236596: allow rename on DC's, now.
      // // if (state.IsMachineDc())
      // // {
      // //    // sorry- DCs can't be renamed
      // //    result = false;
      // //    appendMessage(message, String::load(IDS_CANT_RENAME_DC));
      // // }

      if (IsDcpromoRunning())
      {
         result = false;
         appendMessage(message, String::load(IDS_MUST_EXIT_DCPROMO));
      }
      else
      {
         // this test is redundant if dcpromo is running, so only perform
         // it when dcpromo is not running.

         if (IsUpgradingDc())
         {
            // must complete dcpromo, first.
            result = false;
            appendMessage(message, String::load(IDS_MUST_COMPLETE_DCPROMO));
         }
      }

      if (certsvc.IsInstalled())
      {
         // sorry- renaming cert issuers invalidates their certs.
         result = false;
         appendMessage(message, String::load(IDS_CANT_RENAME_CERT_SVC));
      }

      if (!state.IsNetworkingInstalled() && !state.IsMemberOfWorkgroup())
      {
         // domain members need to be able to reach a dc
         result = false;
         appendMessage(message, String::load(IDS_NETWORKING_NEEDED));
      }

      // 362770
      if (!EvaluateRoleChangeState(message))
      {
         // dcpromo is running or was just run
         result = false;

         // the message has been updated for us by EvaluateRoleChangeState
      }
   }
   while (0);

   // show the message whether changes requiring a reboot have been made
   // during this session or any other session (or even if the computer
   // name has been changed by some other entity than ourselves)

   bool show = (state.NeedsReboot() || state.ChangesMadeThisSession());
   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_REBOOT_MESSAGE),
      show ? SW_SHOW : SW_HIDE);
   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      show ? SW_SHOW : SW_HIDE);

   return result;
}



void
NetIDPage::refresh()
{
   LOG_FUNCTION(NetIDPage::refresh);

   State& state = State::GetInstance();
   Win::SetDlgItemText(hwnd, IDC_FULL_NAME, state.GetFullComputerName());
   Win::SetDlgItemText(hwnd, IDC_DOMAIN, state.GetDomainName());
   Win::SetDlgItemText(
      hwnd,
      IDC_MEMBER_OF,
      String::load(
            state.IsMemberOfWorkgroup()
         ?  IDS_MEMBER_OF_WORKGROUP
         :  IDS_MEMBER_OF_DOMAIN));

   String message;
   bool enableButtons =
      evaluateButtonEnablingAndComposeMessageText(message);
   bool networkingInstalled = state.IsNetworkingInstalled();

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_CHANGE), enableButtons);
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_ACCOUNT_WIZARD_BUTTON),
      enableButtons && networkingInstalled && !fIsPersonal );
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE1),
      enableButtons && networkingInstalled && !fIsPersonal );
   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE2),
      enableButtons);

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);

   if (!networkingInstalled)
   {
      // if networking is not installed, then domain join is not an option,
      // so replace the button text to only mention rename.  371999
      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_CLICK_MESSAGE2),
         String::load(IDS_RENAME_PROMPT));
   }
}



void
NetIDPage::OnInit()
{
   LOG_FUNCTION(NetIDPage::OnInit);

   State::Init();

   // JonN 10/24/00 Computer Description
   // CODEWORK It would probably be cleaner to roll the
   // computer description into ComputerState
   SERVER_INFO_101* psi101 = NULL;
   DWORD dwErr = ::NetServerGetInfo( NULL, 101, (LPBYTE*)&psi101 );
   if (0 == dwErr && NULL != psi101)
   {
      if (NULL != psi101->sv101_comment)
      {
         Win::SetDlgItemText(hwnd,
                             IDC_DESCRIPTION_EDIT,
                             psi101->sv101_comment);
         Win::PropSheet_Unchanged(Win::GetParent(hwnd), hwnd);
         ClearChanges(); // clear IDC_DESCRIPTION_EDIT flag
      }
      (void) ::NetApiBufferFree( psi101 );
   }
   else
   { 
      // If we failed to read the comment, disable this field
      Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DESCRIPTION_EDIT), false);
   }

   // JonN 2/20/01 322286
   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DESCRIPTION_EDIT),
      MAXCOMMENTSZ);

   refresh();

   // destroyed in the dtor

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);

   if (SUCCEEDED(hr))
   {
      Win::SendMessage(
         Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
         STM_SETICON,
         reinterpret_cast<WPARAM>(warnIcon),
         0);
   }
}



bool
NetIDPage::OnSetActive()
{
   LOG_FUNCTION(NetIDPage::OnSetActive);

   refresh();

   return true;
}



bool
NetIDPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDC_CHANGE:
      {
         if (code == BN_CLICKED)
         {
            // JonN 4/20/01 
            // Computer Name: warn users to "prepare" computer rename
            //   prior to DC computer rename
            if (State::GetInstance().IsMachineDc())
            {
               if (
                  popup.MessageBox(
                     hwnd,
                     IDS_RENAME_DC_WARNING,
                     MB_ICONWARNING | MB_OKCANCEL | MB_DEFBUTTON2) != IDOK)
               {
                  break;
               }
            }

            IDChangesDialog dlg(fIsPersonal);
            dlg.ModalExecute(hwnd);
            if (State::GetInstance().ChangesMadeThisSession())
            {
               Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
            }
            State::Refresh();
            refresh();

            // JonN 4/24/01 280197
            // wrong button has focus after joining or changing the Domain name
            Win::SetFocus(Win::GetDlgItem(hwnd, IDC_CHANGE));

         }
         break;
      }
      case IDC_ACCOUNT_WIZARD_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            HINSTANCE hNetWiz = LoadLibrary(c_szWizardFilename);
            HRESULT (*pfnNetConnectWizard)(HWND, ULONG, BOOL *);
            BOOL fReboot = FALSE;

            if (hNetWiz) {
                pfnNetConnectWizard = (HRESULT (*)(HWND, ULONG, BOOL *)) GetProcAddress(
                    hNetWiz,
                    "NetAccessWizard"
                );
                
                if (pfnNetConnectWizard) {
                    pfnNetConnectWizard(windowFrom, 0, &fReboot);

                    if (fReboot) {
                        popup.Info(hwnd, IDS_MUST_REBOOT);
                        State::GetInstance().SetChangesMadeThisSession(true);      
                        Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
                    } // if (fReboot)

                    State::Refresh();
                    refresh();

                } // if (pfnNetConnectWizard)

                FreeLibrary(hNetWiz);

            } // if (hNetWiz)
         } 
         break;
      }
      case IDC_DESCRIPTION_EDIT:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(IDC_DESCRIPTION_EDIT);
            Win::PropSheet_Changed(Win::GetParent(hwnd), hwnd);
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
   


bool
NetIDPage::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
   bool result = false;

   switch (message)
   {
      case WM_ACTIVATE:
      {
         refresh();
         result = true;
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}

bool
NetIDPage::OnApply(bool isClosing )
{
   LOG_FUNCTION2(
      NetIDPage::OnApply,
      isClosing ? L"closing" : L"not closing");

   // JonN 10/24/00 Computer Description
   // CODEWORK It would probably be cleaner to roll the
   // computer description into ComputerState

   if (!WasChanged(IDC_DESCRIPTION_EDIT))
      return true;

   // If we got here, Win::PropSheet_Changed() must have been called
   // in OnCommand().

   String strDescription = Win::GetTrimmedDlgItemText(
         hwnd, IDC_DESCRIPTION_EDIT);
   SERVER_INFO_101 si101;
   ::ZeroMemory( &si101, sizeof(si101) );
   si101.sv101_comment = (LMSTR)strDescription.c_str();
   DWORD parmerror = 0;
   DWORD dwErr = ::NetServerSetInfo(
         NULL, 101, (LPBYTE)&si101, &parmerror );
   if (0 != dwErr)
   {
      popup.Gripe(
         hwnd,
         IDC_DESCRIPTION_EDIT,
         Win32ToHresult(dwErr),
         String::format(IDS_CHANGE_DESCRIPTION_FAILED));
      // don't dismiss the property page
      Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
      return true;
   }
   else
   {
         Win::PropSheet_Unchanged(Win::GetParent(hwnd), hwnd);
         ClearChanges(); // clear IDC_DESCRIPTION_EDIT flag
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\moredlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// "More" dialog (spawned from IDChanges)
// 
// 3-11-98 sburns



#include "headers.hxx"
#include "moredlg.hpp"
#include "resource.h"
#include "helpids.h"
#include "state.hpp"
#include "iddlg.hpp"     // showAndEnableWindow



// the max length of a DNS name is 255 utf-8 bytes.  The hostname must be
// at least 1 byte.  Then there's the dot between the hostname and the
// suffix.  So 255 - 1 - 1 = 253.

// note that this is *not* Dns::MAX_NAME_LENGTH

static const int MAX_SUFFIX_LEN = DNS_MAX_NAME_LENGTH - 1 - 1;


static const DWORD HELP_MAP[] =
{
   IDC_DNS,                IDH_IDENT_NAMES_DNS_NAME,
   IDC_CHANGE,             IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX,
   IDC_NETBIOS,            IDH_IDENT_NAMES_NETBIOS_NAME,
   0, 0
};



MoreChangesDialog::MoreChangesDialog(bool isPersonal)
   :
   Dialog(IDD_MORE, HELP_MAP),
   startingSyncDnsNames(false),
   fIsPersonal(isPersonal)
{
   LOG_CTOR(MoreChangesDialog);
}



MoreChangesDialog::~MoreChangesDialog()
{
   LOG_DTOR(MoreChangesDialog);
}



void
MoreChangesDialog::enable()
{
   bool enabled = WasChanged(IDC_DNS); 

   if (WasChanged(IDC_CHANGE))
   {
      if (
            startingSyncDnsNames
         != Win::IsDlgButtonChecked(hwnd, IDC_CHANGE))
      {
         enabled = true;
      }
   }

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), enabled);
}



void
MoreChangesDialog::OnInit()
{
   LOG_FUNCTION(MoreChangesDialog::OnInit);

   State& state = State::GetInstance();

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DNS),
      MAX_SUFFIX_LEN);

   Win::SetDlgItemText(
      hwnd,
      IDC_DNS,
      state.GetComputerDomainDnsName());
   Win::SetDlgItemText(hwnd, IDC_NETBIOS, state.GetNetbiosComputerName());

   startingSyncDnsNames = state.GetSyncDNSNames();
   Win::CheckDlgButton(
      hwnd,
      IDC_CHANGE,
      startingSyncDnsNames ? BST_CHECKED : BST_UNCHECKED);
   if (fIsPersonal) // JonN 10/4/00
      showAndEnableWindow( hwnd, IDC_CHANGE, SW_HIDE );

   ClearChanges();
   enable();
}



MoreChangesDialog::ExecuteResult
MoreChangesDialog::ModalExecute(HWND parent)
{
   if (Dialog::ModalExecute(parent))
   {
      return CHANGES_MADE;
   }

   return NO_CHANGES;
}



// returns
// -1 if a validation error has occurred
// 1 if a change was made
// 0 if no change was made

int
MoreChangesDialog::OnOkButton()
{
   int endCode = 0;
   State& state = State::GetInstance();

   String preconditionErrorMessage = CheckPreconditions();
   if (!preconditionErrorMessage.empty())
   {
      popup.Error(
         hwnd,
         preconditionErrorMessage);
      return -1;
   }

   if (WasChanged(IDC_CHANGE))
   {
      state.SetSyncDNSNames(
         Win::IsDlgButtonChecked(hwnd, IDC_CHANGE));
      endCode = 1;
   }
      
   if (WasChanged(IDC_DNS))
   {
      // compare the new value to the old one.  If they're different,
      // validate and save the new value

      String newDomain = Win::GetTrimmedDlgItemText(hwnd, IDC_DNS);

      if (newDomain.empty())
      {
         state.SetComputerDomainDnsName(newDomain);
         return 1;
      }

      String oldDomain = state.GetComputerDomainDnsName();

      if (newDomain.icompare(oldDomain) != 0)
      {
         switch (
            Dns::ValidateDnsNameSyntax(
               newDomain,
               MAX_SUFFIX_LEN,
               MAX_SUFFIX_LEN))
         {
            case Dns::NON_RFC:
            {
               Win::MessageBox(
                  hwnd,
                  String::format(IDS_NON_RFC_NAME, newDomain.c_str()),
                  String::load(IDS_APP_TITLE),
                  MB_OK | MB_ICONWARNING);

               //lint -e(616) fall-thru
            }
            case Dns::VALID:
            {
               state.SetComputerDomainDnsName(newDomain);
               endCode = 1;
               break;
            }
            case Dns::TOO_LONG:
            {
               endCode = -1;               
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(
                     IDS_DNS_NAME_TOO_LONG,
                     newDomain.c_str(),
                     MAX_SUFFIX_LEN));
               break;
            }
            case Dns::NUMERIC:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(IDS_NUMERIC_DNS_NAME, newDomain.c_str()));
               break;
            }
            case Dns::BAD_CHARS:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(IDS_BAD_DNS_CHARS, newDomain.c_str()));
               break;
            }
            case Dns::INVALID:
            default:
            {
               endCode = -1;
               popup.Gripe(
                  hwnd,
                  IDC_DNS,
                  String::format(
                     IDS_BAD_DNS_SYNTAX,
                     newDomain.c_str(),
                     Dns::MAX_LABEL_LENGTH));
               break;
            }
         }
      }
   }

   return endCode;
}



bool
MoreChangesDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            int endCode = OnOkButton();
            if (endCode != -1)
            {
               HRESULT unused = Win::EndDialog(hwnd, endCode);

               ASSERT(SUCCEEDED(unused));
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            // 0 => no changes made

            HRESULT unused = Win::EndDialog(hwnd, 0);

            ASSERT(SUCCEEDED(unused));
         }
         break;
      }
      case IDC_CHANGE:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            enable();
         }
         break;
      }
      case IDC_DNS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable();
         }
         break;
      }
      default:
      {
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\moredlg.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// "More" dialog (spawned from IDChanges)
// 
// 3-11-98 sburns



#ifndef MOREDLG_HPP_INCLUDED
#define MOREDLG_HPP_INCLUDED



class MoreChangesDialog : public Dialog
{
   public:

   MoreChangesDialog(bool isPersonal);

   virtual ~MoreChangesDialog();

   enum ExecuteResult
   {
      NO_CHANGES,
      CHANGES_MADE
   };

   // hides Dialog::ModalExecute

   ExecuteResult
   ModalExecute(HWND parent);
   
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   int
   OnOkButton();

   void
   enable();

   // no copying allowed
   MoreChangesDialog(const MoreChangesDialog&);
   const MoreChangesDialog& operator=(const MoreChangesDialog&);

   bool startingSyncDnsNames;
   bool fIsPersonal;
};

   

#endif   // MOREDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_UNKNOWN                     1
#define IDS_DEFAULT_WORKGROUP           2
#define IDS_ERROR_READING_MEMBERSHIP    3
#define IDS_APP_TITLE                   4
#define IDS_MEMBER_OF_WORKGROUP         5
#define IDS_MEMBER_OF_DOMAIN            6
#define IDS_NON_RFC_NAME                7
#define IDS_BAD_DNS_SYNTAX              8
#define IDS_DNS_NAME_TOO_LONG           9
#define IDS_COMPUTER_NAME_TOO_LONG      10
#define IDS_BAD_COMPUTER_NAME_SYNTAX    11
#define IDS_VALIDATE_NAME_FAILED        12
#define IDS_JOIN_DOMAIN_FAILED          13
#define IDS_SHORT_NAME_CHANGE_FAILED    14
#define IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME 15
#define IDS_SET_DOMAIN_DNS_NAME_FAILED  16
#define IDS_UNJOIN_FAILED               17
#define IDS_JOIN_WORKGROUP_FAILED       18
#define IDS_RENAME_FAILED               19
#define IDS_COMPUTER_ACCOUNT_ORPHANED   20
#define IDS_WORKGROUP_WELCOME           22
#define IDS_DOMAIN_WELCOME              23
#define IDS_MUST_REBOOT                 24
#define IDS_NAME_AND_MEMBERSHIP_MESSAGE 25
#define IDS_NAME_MESSAGE                26
#define IDS_RENAME_CREDENTIALS          27
#define IDS_NAME_TRUNCATED              28
#define IDS_NON_RFC_COMPUTER_NAME_SYNTAX 29
#define IDS_CONVERSION_TO_NETBIOS_NAME_FAILED 30
#define IDS_BAD_NETBIOS_CHARACTERS      31
#define IDS_CHANGE_DESCRIPTION_FAILED   32
#define IDI_COMPUTER                    101
#define IDI_WARN                        102
#define IDD_CHANGES                     103
#define IDD_MORE                        104
#define IDD_CREDENTIALS                 105
#define IDD_CHANGES_PER                 106
#define IDD_NETID                       112
#define IDC_COMPUTER_ICON               113
#define IDD_NETID_PER                   114
#define IDC_CHANGE                      115
#define IDC_DOMAIN                      116
#define IDC_MEMBER_OF                   117
#define IDC_ACCOUNT_WIZARD_BUTTON       119
#define IDC_FULL_NAME_STATIC            120
#define IDC_IDENTIFICATION_TEXT         121
#define IDC_DESCRIPTION_EDIT            122
#define IDC_FULL_NAME                   1001
#define IDC_NEW_NAME                    1002
#define IDC_MORE                        1003
#define IDC_WORKGROUP_BUTTON            1004
#define IDC_WORKGROUP                   1007
#define IDC_DOMAIN_BUTTON               1008
#define IDC_FIND                        1010
#define IDC_DNS                         1011
#define IDC_NETBIOS                     1013
#define IDC_FULL_LABEL                  1016
#define IDC_MESSAGE                     1017
#define IDC_GROUP                       1018
#define IDC_REBOOT_MESSAGE              1019
#define IDD_NETID_SRV                   1020
#define IDS_MUST_BE_ADMIN               1021
#define IDS_CANT_TWEAK_ID               1022
#define IDS_CANT_RENAME_DC              1023
#define IDS_CANT_RENAME_CERT_SVC        1024
#define IDS_NETWORKING_NEEDED           1025
#define IDC_WARNING_ICON                1026
#define IDC_CLICK_MESSAGE2              1027
#define IDC_CLICK_MESSAGE1              1028
#define IDS_COMPUTER_NAME_NUMERIC       1029
#define IDS_COMPUTER_NAME_HAS_BAD_CHARS 1030
#define IDS_NUMERIC_DNS_NAME            1031
#define IDS_BAD_DNS_CHARS               1032
#define IDS_COMPUTER_NAME_EQUALS_WORKGROUP_NAME 1033
#define IDS_COMPUTER_NAME_EQUALS_DOMAIN_NAME 1034
#define IDS_ROLE_CHANGE_IN_PROGRESS     1035
#define IDS_ROLE_CHANGE_NEEDS_REBOOT    1036
#define IDS_RENAME_PROMPT               1037
#define IDS_MUST_COMPLETE_DCPROMO       1038
#define IDS_PRECHK_DCPROMO_RUNNING 1039
#define IDS_MUST_EXIT_DCPROMO 1040
#define IDS_PRECHK_MUST_COMPLETE_DCPROMO 1041
#define IDS_PRECHK_CANT_RENAME_CERT_SVC 1042
#define IDS_PRECHK_ROLE_CHANGE_IN_PROGRESS 1043
#define IDS_PRECHK_ROLE_CHANGE_NEEDS_REBOOT 1044
#define IDS_PRECHK_NETWORKING_NEEDED 1045
#define IDS_CHANGE_SYNC_FLAG_FAILED 1046
#define IDS_UNJOIN_CREDENTIALS 1047
#define IDS_NETBIOS_NAME_NUMERIC 1048
#define IDS_WORKGROUP_NAME_TOO_LONG 1049
#define IDS_DISK_FULL 1050
#define IDS_JOIN_FAILED 1051
#define IDS_JOIN_CREDENTIALS 1052
#define IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS 1053
#define IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS_SUFFIX 1054
#define IDS_RENAME_COULDNT_UPDATE_SPNS 1055
#define IDS_RENAME_COULDNT_UPDATE_SPNS_SUFFIX 1056
#define IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS 1057
#define IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS_SUFFIX 1058
#define IDS_RENAME_DC_WARNING 1059
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\state.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Tab state
//
// 03-31-98 sburns
// 10-05-00 jonn      changed to CredUIGetPassword



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "cred.hpp"



TCHAR const c_szWizardFilename[] = L"netplwiz.dll";



class Settings
{
   public:

   // default ctor, copy ctor, op=, dtor used

   void
   Refresh();

   String   ComputerDomainDnsName;
   String   DomainName;
   String   FullComputerName;
   String   PolicyDomainDnsName;
   String   ShortComputerName;
   String   NetbiosComputerName;

   bool     SyncDNSNames;
   bool     JoinedToWorkgroup;
   bool     NeedsReboot;
};



static State* instance            = 0;    
static bool   machineIsDc         = false;
static bool   networkingInstalled = false;
static bool   policyInEffect      = false;
static bool   mustReboot          = false;

// no static initialization worries here, as these are rebuilt when the State
// instance is constructed/initialized/refreshed.
static Settings original;
static Settings current; 

// not static String instances to avoid order of static initialization any
// problems
static const wchar_t* TCPIP_PARAMS_KEY = 
   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

static const wchar_t* SYNC_VALUE =
   L"SyncDomainWithMembership";

static const wchar_t* NEW_HOSTNAME_VALUE = L"NV Hostname";
static const wchar_t* NEW_SUFFIX_VALUE   = L"NV Domain";


bool
readSyncFlag()
{
   bool retval = true;

   do
   {
      RegistryKey key;

      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      // default is to sync.
      DWORD data = 1;
      hr = key.GetValue(SYNC_VALUE, data);
      BREAK_ON_FAILED_HRESULT(hr);

      retval = data ? true : false;
   }
   while (0);

   return retval;
}


// JonN 1/03/01 106601
// When the dns suffix checkbox is unchecked,
// domain join fails with a confusing message
//
// LevonE: When Join fails with ERROR_DS_COULDNT_UPDATE_SPNS the UI must check
//       if (HKLM/System/CCS/Services/Tcpip/Parameters/SyncDomainWithMembership
//             == 0x0 &&
//       HKLM/System/CCS/Services/Tcpip/Parameters/NV Domain
//             != AD_Domain_To_Be_Joined)
bool WarnDnsSuffix( const String& refNewDomainName )
{
   if (readSyncFlag())
      return false;
   String strNVDomain;
   RegistryKey key;
   HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
   if (!SUCCEEDED(hr2))
      return false;
   hr2 = key.GetValue(NEW_SUFFIX_VALUE, strNVDomain);
   if (!SUCCEEDED(hr2))
      return false;
   return !!strNVDomain.icompare( refNewDomainName );
}



HRESULT
WriteSyncFlag(HWND dialog, bool flag)
{
   LOG_FUNCTION(WriteSyncFlag);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      hr = key.Create(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.SetValue(SYNC_VALUE, flag ? 1 : 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         IDS_CHANGE_SYNC_FLAG_FAILED);
   }

   return hr;
}



// returns true if the machine is a domain controller running under ds repair
// mode, false if not
   
bool
IsDcInDsRepairMode()
{
   LOG_FUNCTION(IsDcInDsRepairMode);

   // We infer a DC in repair mode if we're told that the machine is a server
   // and the safe boot option is ds repair, and the real product type is
   // LanManNT.
   //
   // By "real" product type, I mean that which is written in the registry,
   // not that which is reported by RtlGetNtProductType.  The API gets the
   // result from shared memory which is adjusted at boot to reflect the
   // ds repair mode (from LanManNt to Server).  The registry entry is not
   // changed by repair mode.
   //
   // We have to check both because it is possible to boot a normal server
   // in ds repair mode.

   DWORD safeBoot = 0;
   NT_PRODUCT_TYPE product = NtProductWinNt;

   HRESULT hr = Computer::GetSafebootOption(HKEY_LOCAL_MACHINE, safeBoot);

   // don't assert the result: the key may not be present

   hr = Computer::GetProductTypeFromRegistry(HKEY_LOCAL_MACHINE, product);
   ASSERT(SUCCEEDED(hr));

   if (safeBoot == SAFEBOOT_DSREPAIR and product == NtProductLanManNt)
   {
      return true;
   }

   return false;
}



void
Settings::Refresh()
{
   LOG_FUNCTION(Settings::Refresh);

   String unknown = String::load(IDS_UNKNOWN);
   ComputerDomainDnsName = unknown;
   DomainName            = unknown;
   FullComputerName      = unknown;
   ShortComputerName     = unknown;
   PolicyDomainDnsName   = unknown;

   SyncDNSNames      = readSyncFlag();
   JoinedToWorkgroup = true;          

   // CODEWORK: we should reconcile this with the Computer object added
   // to idpage.cpp

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      if (info->DomainNameDns)
      {
         DomainName = info->DomainNameDns;
      }
      else if (info->DomainNameFlat)
      {
         DomainName = info->DomainNameFlat;
      }

      // this is the workgroup name iff JoinedToWorkgroup == true
      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machineIsDc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DsRole_RoleStandaloneWorkstation:
         {
            machineIsDc = false;
            JoinedToWorkgroup = true;

            if (DomainName.empty())
            {
               LOG(L"empty domain name, using default WORKGROUP");

               DomainName = String::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleStandaloneServer:
         {
            machineIsDc = false;
            JoinedToWorkgroup = true;

            // I wonder if we're really a DC booted in ds repair mode?

            if (IsDcInDsRepairMode())
            {
               LOG(L"machine is in ds repair mode");

               machineIsDc = true;
               JoinedToWorkgroup = false;

               // we can't determine the domain name (LSA won't tell
               // us when running ds repair mode), so we fall back to
               // unknown.  This is better than "WORKGROUP" -- which is
               // what info contains.

               DomainName = unknown;
            }
            else
            {
               if (DomainName.empty())
               {
                  LOG(L"empty domain name, using default WORKGROUP");

                  DomainName = String::load(IDS_DEFAULT_WORKGROUP);
               }
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machineIsDc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      popup.Error(
         Win::GetDesktopWindow(),
         hr,
         String::load(IDS_ERROR_READING_MEMBERSHIP));

      // fall back to other APIs to fill in the holes as best we can.

      JoinedToWorkgroup = false;
      machineIsDc = false;

      // workstation, server, or DC?  (imprescise, but better than a stick
      // in the eye)
      NT_PRODUCT_TYPE ntp = NtProductWinNt;
      BOOLEAN result = ::RtlGetNtProductType(&ntp);
      if (result)
      {
         switch (ntp)
         {
            case NtProductWinNt:
            {
               break;
            }
            case NtProductServer:
            {
               break;
            }
            case NtProductLanManNt:
            {
               machineIsDc = true;
               break;
            }
            default:
            {
               ASSERT(false);
            }
         }
      }
   }

   networkingInstalled = IsNetworkingInstalled();
   bool isTcpInstalled = networkingInstalled && IsTcpIpInstalled();
   String activeFullName;

   NetbiosComputerName = Computer::GetFuturePhysicalNetbiosName();

   if (isTcpInstalled)
   {
      // When TCP/IP is installed on the computer, then we are interested
      // in the computer DNS domain name suffix, and the short name is the
      // computer's DNS hostname.

      String activeShortName;
      String futureShortName;
      String activeDomainName;
      String futureDomainName;

      RegistryKey key;
      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);
      if (SUCCEEDED(hr))
      {
         // Read these values without checking for failure, as empty string
         // is ok.
         
         activeShortName  = key.GetString(L"Hostname");
         activeDomainName = key.GetString(L"Domain");  
         futureShortName  = key.GetString(NEW_HOSTNAME_VALUE);

         ShortComputerName =
            futureShortName.empty() ? activeShortName : futureShortName;

         // here, check that the value was successfully read, because
         // it may not be present.
         
         hr = key.GetValue(NEW_SUFFIX_VALUE, futureDomainName);
         if (SUCCEEDED(hr))
         {
            ComputerDomainDnsName = futureDomainName;
         }
         else
         {
            ComputerDomainDnsName = activeDomainName;
         }
      }

      // Determine if DNS domain name policy is in effect.  This may change
      // at any moment, asynchronously, so we save the result as a setting.

      policyInEffect =
         Computer::IsDnsSuffixPolicyInEffect(PolicyDomainDnsName);

      // The full computer name is the short name + . + dns domain name
      // if policy is in effect, the policy dns domain name takes precedence
      // over the computer's dns domain name.

      FullComputerName =
         Computer::ComposeFullDnsComputerName(
            ShortComputerName,
            policyInEffect ? PolicyDomainDnsName : ComputerDomainDnsName);
      activeFullName =
         Computer::ComposeFullDnsComputerName(
            activeShortName,
            policyInEffect ? PolicyDomainDnsName : activeDomainName);
   }
   else
   {
      // 371944

      activeFullName = Computer::GetActivePhysicalNetbiosName();

      // when there is no TCP/IP, the short name is the NetBIOS name

      ShortComputerName = NetbiosComputerName;
      FullComputerName  = ShortComputerName;  
   }

   // This test does not take into account domain membership changes, as we
   // have no prior membership info to compare the current membership to.

   NeedsReboot = activeFullName != FullComputerName;
}



void
State::Delete()
{
   LOG_FUNCTION(State::Delete);

   delete instance;
   instance = 0;
}



State&
State::GetInstance()
{
   ASSERT(instance);

   return *instance;
}



void
State::Init()
{
   LOG_FUNCTION(State::Init);
   ASSERT(!instance);

   if (!instance)
   {
      instance = new State();
   }
}



void
State::Refresh()
{
   LOG_FUNCTION(State::Refresh);

   State::Delete();
   State::Init();
}



State::State()
{
   LOG_CTOR(State);

   original.Refresh();
   current = original;
}



State::~State()
{
   LOG_DTOR(State);
}



bool
State::NeedsReboot() const
{
   return original.NeedsReboot;
}



bool
State::IsMachineDc() const
{
   return machineIsDc;
}



bool
State::IsNetworkingInstalled() const
{
   return networkingInstalled;
}



String
State::GetFullComputerName() const
{
   return current.FullComputerName;
}



String
State::GetDomainName() const
{
   return current.DomainName;
}



void
State::SetDomainName(const String& name)
{
//    LOG_FUNCTION2(State::SetDomainName, name);

   current.DomainName = name;
}



bool
State::IsMemberOfWorkgroup() const
{
   return current.JoinedToWorkgroup;
}



void
State::SetIsMemberOfWorkgroup(bool yesNo)
{
   current.JoinedToWorkgroup = yesNo;
}



String
State::GetShortComputerName() const
{
   return current.ShortComputerName;
}



void
State::SetShortComputerName(const String& name)
{
   current.ShortComputerName = name;
   if (!name.empty())
   {
      current.NetbiosComputerName = Dns::HostnameToNetbiosName(name);
      SetFullComputerName();
   }
   else
   {
      // This avoids an assert in Dns::HostnameToNetbiosName and
      // Computer::ComposeFullDnsComputerName.  119901

      current.NetbiosComputerName = name;
      current.FullComputerName = name;
   }
}



bool
State::WasShortComputerNameChanged() const
{
   return
      original.ShortComputerName.icompare(current.ShortComputerName) != 0;
}



bool
State::WasNetbiosComputerNameChanged() const
{
   return
      original.NetbiosComputerName.icompare(current.NetbiosComputerName) != 0;
}



String
State::GetComputerDomainDnsName() const
{
   return current.ComputerDomainDnsName;
}



void
State::SetComputerDomainDnsName(const String& newName)
{
   current.ComputerDomainDnsName = newName;
   SetFullComputerName();
}



void
State::SetFullComputerName()
{
   current.FullComputerName =
      Computer::ComposeFullDnsComputerName(
         current.ShortComputerName,
            policyInEffect
         ?  current.PolicyDomainDnsName
         :  current.ComputerDomainDnsName);
}



bool
State::WasMembershipChanged() const
{
   if (current.DomainName.empty())
   {
      // this can happen when the domain name is not yet set or has been 
      // cleared by the user

      return true;
   }

   return
         (Dns::CompareNames(
            original.DomainName,
            current.DomainName) != DnsNameCompareEqual) // 97064
      || original.JoinedToWorkgroup != current.JoinedToWorkgroup;
}



bool
State::ChangesNeedSaving() const
{
   if (
         original.ComputerDomainDnsName.icompare(
             current.ComputerDomainDnsName) != 0
      || WasMembershipChanged()
      || WasShortComputerNameChanged()
      || SyncDNSNamesWasChanged())
   {
      return true;
   }

   return false;
}



bool
State::GetSyncDNSNames() const
{
   return current.SyncDNSNames;
}



void
State::SetSyncDNSNames(bool yesNo)
{
   current.SyncDNSNames = yesNo;
}



bool
State::SyncDNSNamesWasChanged() const
{
   return original.SyncDNSNames != current.SyncDNSNames;
}



// Prepend the domain name to the user name (making it a fully-qualified name
// in the form "domain\username") if the username does not appear to be an
// UPN, and the username does not appear to be fully-qualified already.
// 
// domainName - netbios or DNS domain name.
// 
// userName - user account name
//
// JonN 6/27/01 26151
//    Attempting to join domain with username "someone\" gives a cryptic error
//    returntype becomes HRESULT, userName becomes IN/OUT parameter
//

HRESULT
MassageUserName(const String& domainName, String& userName)
{
   LOG_FUNCTION(MassageUserName);
//   ASSERT(!userName.empty()); JonN 2/6/01 306520

   static const String UPN_DELIMITER(L"@");
   if (userName.find(UPN_DELIMITER) != String::npos)
   {
      // assume the name is a UPN: foouser@bar.com.  This is not
      // necessarily true, as account names may contain an '@' symbol.
      // If that's the case, then they had better fully-qualify the name
      // as domain\foo@bar....

      return S_OK;
   }

   if (!domainName.empty() && !userName.empty())
   {
      static const String DOMAIN_DELIMITER(L"\\");
      size_t pos = userName.find(DOMAIN_DELIMITER);

      if (pos == String::npos)
      {
         userName = domainName + DOMAIN_DELIMITER + userName;
      }
      //
      // JonN 6/27/01 26151
      // Attempting to join domain with username "someone\" gives a cryptic error
      //
      else if (pos == userName.length() - 1)
      {
         return HRESULT_FROM_WIN32(NERR_BadUsername);
      }
   }

   return S_OK;
}



// Calls NetJoinDomain.  The first call specifies the create computer account
// flag.  If that fails with an access denied error, the call is repeated
// without the flag.  (This is to cover the case where the domain
// administrator may have pre-created the computer account.)
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.
//
// domain - domain to join.  May be the netbios or DNS domain name.
//
// username - user account to be used.  If empty, the currently logged in
// user's context is used.
//
// password - password for the above account.  May be empty.

HRESULT
JoinDomain(
   HWND dialog,
   const String& domainName,
   const String& username,
   const String& password,
   const String& computerDomainDnsName, // 106601
   bool          deferSpn)
{
   LOG_FUNCTION(JoinDomain);
   ASSERT(!domainName.empty());
   ASSERT(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   // first attempt without create flag in case account was precreated
   // 105306

   DWORD flags =
            NETSETUP_JOIN_DOMAIN
         |  NETSETUP_DOMAIN_JOIN_IF_JOINED
         |  NETSETUP_ACCT_DELETE;

   if (deferSpn)
   {
      flags |= NETSETUP_DEFER_SPN_SET;
   }

   HRESULT hr = MyNetJoinDomain(domainName, username, password, flags);

   if (FAILED(hr))
   {
      LOG(L"Retry with account create flag");

      flags |= NETSETUP_ACCT_CREATE;

      hr = MyNetJoinDomain(domainName, username, password, flags);
   }

   if (SUCCEEDED(hr))
   {
      popup.Info(
         dialog,
         String::format(
            IDS_DOMAIN_WELCOME,
            domainName.c_str()));

      HINSTANCE hNetWiz = LoadLibrary(c_szWizardFilename);
      if (hNetWiz) {
         HRESULT (*pfnClearAutoLogon)(VOID) = 
            (HRESULT (*)(VOID)) GetProcAddress(
               hNetWiz,
               "ClearAutoLogon"
            );

         if (pfnClearAutoLogon) {
            (*pfnClearAutoLogon)();
         }
 
         FreeLibrary(hNetWiz);
      }
   }
   else if (hr == Win32ToHresult(ERROR_DISK_FULL)) // 17367
   {
      popup.Error(
         dialog,
         String::format(IDS_DISK_FULL, domainName.c_str()));
   }
   // JonN 1/03/01 106601
   // When the dns suffix checkbox is unchecked,
   // domain join fails with a confusing message
   else if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
   {
      bool fWarnDnsSuffix = WarnDnsSuffix(domainName);
      popup.Error(
         dialog,
         String::format( (fWarnDnsSuffix)
                           ? IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS_SUFFIX
                           : IDS_JOIN_DOMAIN_COULDNT_UPDATE_SPNS,
                          domainName.c_str(),
                          computerDomainDnsName.c_str()));
   }
   else // any other error
   {
      popup.Error(
         dialog,
         hr,
         String::format(IDS_JOIN_DOMAIN_FAILED, domainName.c_str()));
   }

   return hr;
}



// Changes the local computer's DNS domain suffix.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

HRESULT
SetDomainDnsName(HWND dialog)
{
   LOG_FUNCTION2(SetDomainDnsName, current.ComputerDomainDnsName);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr = 
      Win::SetComputerNameEx(
         ComputerNamePhysicalDnsDomain,
         current.ComputerDomainDnsName);

   if (FAILED(hr))
   {
      // 335055       
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_SET_DOMAIN_DNS_NAME_FAILED,
            current.ComputerDomainDnsName.c_str()));
   }

   return hr;
}



// Changes the local netbios computer name, and, if tcp/ip is installed,
// the local DNS hostname.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

HRESULT
SetShortName(HWND dialog)
{
   LOG_FUNCTION2(setShortName, current.ShortComputerName);
   ASSERT(!current.ShortComputerName.empty());

   HRESULT hr = S_OK;

   bool isTcpInstalled = networkingInstalled && IsTcpIpInstalled();
   if (isTcpInstalled)
   {
      // also sets the netbios name

      hr =
         Win::SetComputerNameEx(
            ComputerNamePhysicalDnsHostname,
            current.ShortComputerName);
   }
   else
   {
      String netbiosName =
         Dns::HostnameToNetbiosName(current.ShortComputerName);
      hr =
         Win::SetComputerNameEx(ComputerNamePhysicalNetBIOS, netbiosName);
   }

   // the only reason that this is likely to fail is if the user is not
   // a local administrator.  The other cases are that the machine is
   // in a hosed state.

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_SHORT_NAME_CHANGE_FAILED,
            current.ShortComputerName.c_str()));
   }

   return hr;
}



// Returns true if a new netbios computer name has been saved, but the machine
// has not yet been rebooted.  In other words, true if the netbios computer
// name will change on next reboot.  417570

bool
ShortComputerNameHasChangedSinceReboot()
{
   LOG_FUNCTION(ShortComputerNameHasChangedSinceReboot());

   String active = Computer::GetActivePhysicalNetbiosName();
   String future = Computer::GetFuturePhysicalNetbiosName();

   return (active != future) ? true : false;
}



// Return true if all changes were successful, false if not.  Called when a
// machine is to be joined to a domain, or if a machine is changing membership
// from one domain to another.
//
// workgroup -> domain
// domain A -> domain B
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveDomainChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveDomainChange);
   ASSERT(Win::IsWindow(dialog));

   String username;
   String password;
   if (!RetrieveCredentials(dialog,
                            IDS_JOIN_CREDENTIALS,
                            username,
                            password))
   {
      return false;
   }

   HRESULT hr                   = S_OK; 
   bool    result               = true; 
   bool    joinFailed           = false;
   bool    changedSyncFlag      = false;
   bool    shortNameNeedsChange = false;
   bool    changedShortName     = false;
   bool    dnsSuffixNeedsChange = false;
   bool    changedDnsSuffix     = false;
   bool    isTcpInstalled       = networkingInstalled && IsTcpIpInstalled();

   do
   {
      //
      // JonN 6/27/01 26151
      // Attempting to join domain with username "someone\" gives a cryptic error
      //
      hr = MassageUserName(current.DomainName, username);
      if (FAILED(hr))
      {
         break;
      }

      // update the sync dns suffix flag, if necessary.  We do this before
      // calling NetJoinDomain, so that it will see the new flag and set the
      // DNS suffix accordingly.  This means if the join fails, we need to
      // undo the change to the flag.

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (SUCCEEDED(hr))
         {
            changedSyncFlag = true;
         }

         // we don't break on failure, as the flag is less consequential
         // than the joined state and computer name.
      }

      // update NV Hostname and NV Domain, if necessary.  This is required
      // before calling NetJoinDomain in order to fix bugs 31084 and 40496.
      // If the join fails, then we need to undo this change

      if (
            // short name changed since changes last saved in this session

            (original.ShortComputerName.icompare(
               current.ShortComputerName) != 0)
      
         or ShortComputerNameHasChangedSinceReboot() )
      {
         shortNameNeedsChange = true;
      }
         
      if (original.ComputerDomainDnsName.icompare(
         current.ComputerDomainDnsName) != 0 )
      {
         dnsSuffixNeedsChange = true;
      }

      // JonN 12/5/00 244762
      // NV Domain only applies when TCP/IP is present.
      if (isTcpInstalled && dnsSuffixNeedsChange)
      {
         RegistryKey key;
         hr = key.Open(HKEY_LOCAL_MACHINE,
                       TCPIP_PARAMS_KEY,
                       KEY_WRITE);
         BREAK_ON_FAILED_HRESULT(hr);
         hr = key.SetValue(NEW_SUFFIX_VALUE,
                           current.ComputerDomainDnsName);
         BREAK_ON_FAILED_HRESULT(hr);

         changedDnsSuffix = true;
      }

      hr =
         JoinDomain(
            dialog,
            current.DomainName,
            username,
            password,
            current.ComputerDomainDnsName,
            shortNameNeedsChange);
      if (FAILED(hr))
      {
         joinFailed = true;

         // JonN 12/5/00 244762
         // If we set NW Domain before the join attempt,
         // and the join failed, we need to undo that setting now.
         if (isTcpInstalled && changedDnsSuffix)
         {
            RegistryKey key;
            HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE,
                                   TCPIP_PARAMS_KEY,
                                   KEY_WRITE);
            ASSERT(SUCCEEDED(hr2));
            hr2 = key.SetValue(NEW_SUFFIX_VALUE,
                               original.ComputerDomainDnsName);
            ASSERT(SUCCEEDED(hr2));
         }

         // don't attempt to save any other changes.  If the machine is
         // already joined to a domain, changing the short name will cause the
         // netbios machine name to not match the machine account, and the
         // user will not be able to log in with a domain account.
         //
         // If the machine is not already joined to the domain, then it
         // is possible to change the short name and the dns suffix, and
         // emit a message that those things were changed even though
         // the join failed.

         break;
      }

      // At this point, the machine is joined to the new domain.  But, it will
      // have joined with the old netbios computer name.  So, if the user has
      // changed the name, or the name has been changed at all since the last
      // reboot, then we must rename the machine.
      //
      // ever get the feeling that NetJoinDomain is a poor API?

      if (shortNameNeedsChange)
      {
         // short name changed.

         // JonN 12/5/00 244762
         // We don't set NV Hostname until after the join succeeds.
         if (isTcpInstalled)
         {
            RegistryKey key;
            hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY, KEY_WRITE);
            BREAK_ON_FAILED_HRESULT(hr);
            hr = key.SetValue(NEW_HOSTNAME_VALUE, current.ShortComputerName);
            BREAK_ON_FAILED_HRESULT(hr);

            changedShortName = true;
         }

         bool renameFailed = false;

         hr =
            MyNetRenameMachineInDomain(

               // We need to pass the hostname instead of the
               // netbios name here in order to get the correct DNS hostname
               // and SPN set on the computer object. See ntraid (ntbug9)
               // #128204

               current.ShortComputerName,
               username,
               password,
               NETSETUP_ACCT_CREATE);
         if (FAILED(hr))
         {
            renameFailed = true;

            // JonN 12/5/00 244762
            // If we set NV Hostname before the rename attempt,
            // and the rename failed, we need to undo that setting now.
            if (isTcpInstalled)
            {
               RegistryKey key;
               HRESULT hr2 = key.Open(HKEY_LOCAL_MACHINE,
                                      TCPIP_PARAMS_KEY,
                                      KEY_WRITE);
               ASSERT(SUCCEEDED(hr2));
               hr2 = key.SetValue(NEW_HOSTNAME_VALUE,
                                  original.ShortComputerName);
               ASSERT(SUCCEEDED(hr2));
            }

            // don't fail the whole operation 'cause the rename failed.
            // We make a big noise about how the join worked under the old
            // name.  We need to succeed with the operation as a whole so
            // the change dialog will close and the joined state of the
            // machine is refreshed.  Otherwise, the change dialog stays up,
            // the domain name has changed but we don't realize it, so if
            // the user types a new domain name in the still open change
            // dialog that is the same as the domain the machine was joined
            // to (matching the stale state), we don't attempt to join
            // again.  Whew.

            // JonN 1/03/01 106601
            // When the dns suffix checkbox is unchecked,
            // domain join fails with a confusing message
            if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
            {
               bool fWarnDnsSuffix = WarnDnsSuffix(current.DomainName);
               popup.Error(
                           dialog,
                           String::format( (fWarnDnsSuffix)
                              ? IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS_SUFFIX
                              : IDS_RENAME_JOINED_WITH_OLD_NAME_COULDNT_UPDATE_SPNS,
                           current.ShortComputerName.c_str(),
                           current.DomainName.c_str(),
                           original.ShortComputerName.c_str(),
                           current.ComputerDomainDnsName.c_str()));
            } else {
               popup.Error(
                  dialog,
                  hr,
                  String::format(
                     IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME,
                     current.ShortComputerName.c_str(),
                     current.DomainName.c_str(),
                     original.ShortComputerName.c_str()));
            }


            hr = S_FALSE;
         }

         // don't change the hostname if the rename failed, as this will
         // prevent the user from logging in as the new computer name will not
         // match the sam account name.

         if (!renameFailed)     // 401355
         {
            // now set the new hostname and netbios name

            hr = SetShortName(dialog);

            // this had better work...

            ASSERT(SUCCEEDED(hr));
         }
      }

      // NetJoinDomain will change the DNS suffix, if it succeeded.  If it
      // failed, then we shouldn't change the suffix anyway.  421824

      // this is only true if the sync flag is true: otherwise, we need to
      // save the suffix when join succeeds.

      if (
            !current.SyncDNSNames
         && dnsSuffixNeedsChange
         && !changedDnsSuffix)
      {
         hr = SetDomainDnsName(dialog);

         // this had better work...

         ASSERT(SUCCEEDED(hr));
      }
   }
   while (0);

   if (joinFailed)
   {
      HRESULT hr2 = S_OK;
      if (changedSyncFlag)
      {
         // change the sync flag back to its original state.

         hr2 = WriteSyncFlag(dialog, original.SyncDNSNames);

         // if we can't restore the flag (unlikely), then that's just tough
         // potatos.

         ASSERT(SUCCEEDED(hr2));
      }

   // JonN 11/27/00 233783 JoinDomain reports its own errors
   } else if (FAILED(hr))
   {
      popup.Error(dialog, hr, IDS_JOIN_FAILED);
   }

   return SUCCEEDED(hr) ? true : false;
}



// Call NetUnjoinDomain, first with the account delete flag, if that fails
// then again without it (which almost always "works").  If the first
// attempt fails, but the second succeeds, raise a message to the user
// informing him of the orphaned computer account.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.
//
// domain - domain to unjoin, i.e. the domain the machine is currently
// a member of.
//
// username - user account to be used.  If empty, the currently logged in
// user's context is used.
//
// password - password for the above account.  May be empty.

HRESULT
UnjoinDomain(
   HWND           dialog,
   const String&  domain,
   const String&  username,
   const String&  password)
{
   LOG_FUNCTION(UnjoinDomain);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(!domain.empty());

   // username and password may be empty

   Win::CursorSetting cursor(IDC_WAIT);

   HRESULT hr = S_OK;

   do
   {
      hr =
         MyNetUnjoinDomain(
            username,
            password,
            NETSETUP_ACCT_DELETE);
      if (SUCCEEDED(hr))
      {
         break;
      }

      // try again: not trying to delete the computer account.  If the
      // user cancelled the credential dialog from the second attempt, then
      // this attempt will use the current context.

      LOG(L"Calling NetUnjoinDomain again, w/o account delete");

      hr =
         MyNetUnjoinDomain(
            username,
            password,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      // if we make it here, then the attempt to unjoin and remove the
      // account failed, but the attempt to unjoin and abandon the account
      // succeeded.  So we tell the user about the abandonment, and hope
      // they feel really guilty about it.

      // Don't hassle them.  They just panic.  95386

      LOG(   
         String::format(
            IDS_COMPUTER_ACCOUNT_ORPHANED,
            domain.c_str()));

      // Win::MessageBox(
      //    dialog,
      //    String::format(
      //       IDS_COMPUTER_ACCOUNT_ORPHANED,
      //       domain.c_str()),
      //    String::load(IDS_APP_TITLE),
      //    MB_OK | MB_ICONWARNING);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog,
         hr,
         String::format(
            IDS_UNJOIN_FAILED,
            domain.c_str()));
   }

   return hr;
}



// Return true if all changes were successful, false if not.  Called when the
// current domain membership is to be severed, or when changing from one
// workgroup to another.
// 
// domain -> workgroup
// workgroup A -> workgroup B
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveWorkgroupChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveWorkgroupChange);
   ASSERT(Win::IsWindow(dialog));

   HRESULT hr              = S_OK; 
   bool    result          = true; 
   bool    unjoinFailed    = false;
   bool    changedSyncFlag = false;

   do
   {
      // update the sync dns suffix flag, if the user changed it.  Do this
      // before calling NetUnjoinDomain, which will clear the dns suffix
      // for us.

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (FAILED(hr))
         {
            result = false;
         }
         else
         {
            changedSyncFlag = true;
         }

         // we don't break on failure, as the flag is less consequential
         // than the joined state and computer name.
      }

      // only unjoin if we were previously joined to a domain

      if (!original.JoinedToWorkgroup and networkingInstalled)
      {
         // get credentials for removing the computer account

         String username;
         String password;
         if (!RetrieveCredentials(dialog,
                                  IDS_UNJOIN_CREDENTIALS,
                                  username,
                                  password))
         {
            result = false;
            unjoinFailed = true;
            break;
         }

         //
         // JonN 6/27/01 26151
         // Attempting to join domain with username "someone\" gives a cryptic error
         //
         hr = MassageUserName(original.DomainName, username);
         if (FAILED(hr))
         {
            break;
         }

         hr =
            UnjoinDomain(
               dialog,
               original.DomainName,
               username,
               password);

         // Don't try to change anything else, especially the hostname.  If
         // the unjoin failed, and we change the name locally, this will
         // prevent the user from logging in, as the new computer name will
         // not match the computer account name in the domain.

         if (FAILED(hr))
         {
            result = false;
            unjoinFailed = true;
            break;
         }
      }

      // join the workgroup

      hr = MyNetJoinDomain(current.DomainName, String(), String(), 0);
      if (FAILED(hr))
      {
         // this is extremely unlikely to fail, and if it did, the
         // workgroup would simply be "WORKGROUP"

         result = false;
         popup.Error(
            dialog,
            hr,
            String::format(
               IDS_JOIN_WORKGROUP_FAILED,
               current.DomainName.c_str()));

         break;
      }

      popup.Info(
         dialog,
         String::format(
            IDS_WORKGROUP_WELCOME,
            current.DomainName.c_str()));

      // change the host name, if the user has changed it.

      if (
         original.ShortComputerName.icompare(
            current.ShortComputerName) != 0)
      {
         hr = SetShortName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }

      // change the domain name, if the user changed it.

      if (
         original.ComputerDomainDnsName.icompare(
            current.ComputerDomainDnsName) != 0 )
      {
         hr = SetDomainDnsName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }
   }
   while (0);

   if (unjoinFailed and changedSyncFlag)
   {
      // change the sync flag back to its original state.

      hr = WriteSyncFlag(dialog, original.SyncDNSNames);

      // if we can't restore the flag (unlikely), then that's just tough
      // potatos.

      ASSERT(SUCCEEDED(hr));
   }

   return result;
}



// Return true if all changes succeeded, false otherwise.  Called only
// when domain membership is not to be changed.
//
// dialog - window handle to dialog window to be used as a parent window
// for any child dialogs that may need to be raised.

bool
State::DoSaveNameChange(HWND dialog)
{
   LOG_FUNCTION(State::DoSaveNameChange);
   ASSERT(Win::IsWindow(dialog));

   bool result = true;
   HRESULT hr = S_OK;

   do
   {
      // change the hostname, if the user has made changes

      if (
         original.ShortComputerName.icompare(
            current.ShortComputerName) != 0)
      {
         if (!original.JoinedToWorkgroup and networkingInstalled)
         {
            // machine is joined to a domain -- we need to rename the
            // machine's domain account

            String username;
            String password;
            if (!RetrieveCredentials(dialog,
                                     IDS_RENAME_CREDENTIALS,
                                     username,
                                     password))
            {
               result = false;
               break;
            }

            //
            // JonN 6/27/01 26151
            // Attempting to join domain with username "someone\" gives a cryptic error
            //
            hr = MassageUserName(current.DomainName, username);
            if (FAILED(hr))
            {
               break;
            }

            hr =
               MyNetRenameMachineInDomain(

                  // We need to pass the full hostname instead of just the
                  // netbios name here in order to get the correct DNS
                  // hostname and SPN set on the computer object. See ntraid
                  // (ntbug9) #128204

                  current.ShortComputerName,
                  username,
                  password,
                  NETSETUP_ACCT_CREATE);
            if (FAILED(hr))
            {
               result = false;
               // JonN 1/03/01 106601
               // When the dns suffix checkbox is unchecked,
               // domain join fails with a confusing message
               if (hr == Win32ToHresult(ERROR_DS_COULDNT_UPDATE_SPNS)) // 106601
               {
                  bool fWarnDnsSuffix = WarnDnsSuffix(current.DomainName);
                  popup.Error(
                              dialog,
                              String::format( (fWarnDnsSuffix)
                                   ? IDS_RENAME_COULDNT_UPDATE_SPNS_SUFFIX
                                   : IDS_RENAME_COULDNT_UPDATE_SPNS,
                                 current.ShortComputerName.c_str(),
                                 current.DomainName.c_str(),
                                 current.ComputerDomainDnsName.c_str()));
               } else {
                  popup.Error(
                     dialog,
                     hr,
                     String::format(
                        IDS_RENAME_FAILED,
                        current.ShortComputerName.c_str()));
               }
            }

            // Don't try to change anything else, especially the netbios name.
            // If the rename failed, and we change the name locally, this will
            // prevent the user from logging in, as the new computer name will
            // not match the computer account name in the domain.

            BREAK_ON_FAILED_HRESULT(hr);
         }

         // Set the dns hostname and the netbios name.  If we called
         // NetRenameMachineInDomain, this may redundantly set netbios name
         // (as NetRenameMachineInDomain calls SetComputerNameEx with the
         // netbios name).

         hr = SetShortName(dialog);

         // Since NetRenameMachineInDomain calls SetComputerNameEx, if that
         // failed, the rename would also have failed.  So our 2nd call to
         // SetComputerNameEx in SetShortName is almost certain to succeed.
         // If it does fail, we're not going to attempt to roll back the
         // rename.

         if (FAILED(hr))
         {
            result = false;
            break;
         }
      }

      // update the sync dns suffix flag, if the user changed it

      if (original.SyncDNSNames != current.SyncDNSNames)
      {
         hr = WriteSyncFlag(dialog, current.SyncDNSNames);
         if (FAILED(hr))
         {
            result = false;
         }
      }

      // change the domain name, if the user changed it.

      if (
         original.ComputerDomainDnsName.icompare(
            current.ComputerDomainDnsName) != 0 )
      {
         hr = SetDomainDnsName(dialog);
         if (FAILED(hr))
         {
            result = false;
         }
      }
   }
   while (0);

   return result;
}



bool
State::SaveChanges(HWND dialog)
{
   LOG_FUNCTION(State::SaveChanges);
   ASSERT(Win::IsWindow(dialog));

   // Changes to domain membership are made first, then to the computer name.

   //
   // workgroup -> domain
   // domain A -> domain B
   //

   if (
         (original.JoinedToWorkgroup && !current.JoinedToWorkgroup)
      ||
         (  !original.JoinedToWorkgroup
         && !current.JoinedToWorkgroup
         && original.DomainName.icompare(current.DomainName) != 0) )
   {
      return DoSaveDomainChange(dialog);
   }

   //
   // domain -> workgroup
   // workgroup A -> workgroup B
   //

   else if (
         !original.JoinedToWorkgroup && current.JoinedToWorkgroup
      ||
         original.JoinedToWorkgroup && current.JoinedToWorkgroup
      && original.DomainName.icompare(current.DomainName) != 0)

   {
      return DoSaveWorkgroupChange(dialog);
   }

   //
   // name change only
   //

   ASSERT(original.JoinedToWorkgroup == current.JoinedToWorkgroup);
   ASSERT(original.DomainName == original.DomainName);

   return DoSaveNameChange(dialog);
}



void
State::SetChangesMadeThisSession(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetChangesMadeThisSession,
      yesNo ? L"true" : L"false");

   mustReboot = yesNo;
}



bool
State::ChangesMadeThisSession() const
{
   LOG_FUNCTION2(
      State::ChangesMadeThisSession,
      mustReboot ? L"true" : L"false");

   return mustReboot;
}



String
State::GetNetbiosComputerName() const
{
   return current.NetbiosComputerName;
}



String
State::GetOriginalShortComputerName() const
{
   return original.ShortComputerName;
}



DSROLE_OPERATION_STATE
GetDsRoleChangeState()
{
   LOG_FUNCTION(GetDsRoleChangeState);

   DSROLE_OPERATION_STATE result = ::DsRoleOperationIdle;
   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      if (info)
      {
         result = info->OperationState;
         ::DsRoleFreeMemory(info);
      }
   }

   return result;
}



bool
IsUpgradingDc()
{
   LOG_FUNCTION(IsUpgradingDc);

   bool isUpgrade = false;
   DSROLE_UPGRADE_STATUS_INFO* info = 0;

   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr))
   {
      isUpgrade = ( (info->OperationState & DSROLE_UPGRADE_IN_PROGRESS) ? true : false );
      ::DsRoleFreeMemory(info);

   }

   return isUpgrade;
}



// Evaluate a list of preconditions that must be met before a name change can
// be committed.  Return a string describing the first unmet condition, or
// an empty string if all conditions are met.
// 
// These preconditions are a subset of those checked before enabling the
// button to allow the user to enter changes.  The conditions not checked here
// are those that cannot be changed while the ui is running (logged on as
// local admin, machine is DC)
// 
// 389646

String
CheckPreconditions()
{
   LOG_FUNCTION(CheckPreconditions);

   String result;

   do
   {
      // could have started dcpromo after opening netid

      if (IsDcpromoRunning())
      {
         result = String::load(IDS_PRECHK_DCPROMO_RUNNING);
         break;
      }
      else
      {
         // this test is redundant if dcpromo is running, so only perform
         // it when dcpromo is not running.

         if (IsUpgradingDc())
         {
            result = String::load(IDS_PRECHK_MUST_COMPLETE_DCPROMO);
         }
      }

      // could have installed cert svc after opening netid

      NTService certsvc(L"CertSvc");
      if (certsvc.IsInstalled())
      {
         // sorry- renaming cert issuers invalidates their certs.
         result = String::load(IDS_PRECHK_CANT_RENAME_CERT_SVC);
      }

      // could have completed dcpromo after opening netid

      switch (GetDsRoleChangeState())
      {
         case ::DsRoleOperationIdle:
         {
            // do nothing
            break;
         }
         case ::DsRoleOperationActive:
         {
            // a role change operation is underway
            result = String::load(IDS_PRECHK_ROLE_CHANGE_IN_PROGRESS);
            break;
         }
         case ::DsRoleOperationNeedReboot:
         {
            // a role change has already taken place, need to reboot before
            // attempting another.
            result =  String::load(IDS_PRECHK_ROLE_CHANGE_NEEDS_REBOOT);
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
      if (!result.empty())
      {
         break;
      }

      // could have installed/uninstalled networking after opening
      // netid

      // re-evaluate this here again, which will be globally visible.

      networkingInstalled = IsNetworkingInstalled();

      State& state = State::GetInstance();
      if (!state.IsNetworkingInstalled() && !state.IsMemberOfWorkgroup())
      {
         // domain members need to be able to reach a dc
         result = String::load(IDS_PRECHK_NETWORKING_NEEDED);
      }
   }
   while (0);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\accperm.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    accperm.cxx
    Definition of the ACCPERM class


    The ACCPERM class provides the generic interface to network permissions
    and auditting.


    FILE HISTORY:
	johnl	05-Aug-1991	Confiscated Rustan's original & did my own

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#include <string.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>

#include <perm.hxx>	    // Make these <> when a home is found
#include <subject.hxx>
#include <accperm.hxx>

DEFINE_SLIST_OF(ACCESS_PERMISSION)
DEFINE_SLIST_OF(AUDIT_PERMISSION)

/*******************************************************************

    NAME:	ACCPERM::ACCPERM

    SYNOPSIS:	Constructor for the ACCPERM class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	08-Aug-1991	Created

********************************************************************/

ACCPERM::ACCPERM( ACL_TO_PERM_CONVERTER * paclconv )
    : _slAccessPerms( TRUE ),
      _slAuditPerms( TRUE ),
      _iterslAccessPerms( _slAccessPerms ),
      _iterslAuditPerms( _slAuditPerms ),
      _fDidDeleteAccessPerms( FALSE ),
      _fDidDeleteAuditPerms ( FALSE ),
      _paclconverter( paclconv )
{
    UIASSERT( _paclconverter != NULL ) ;
}

/*******************************************************************

    NAME:	ACCPERM::AddPermission

    SYNOPSIS:	Adds a permssion (audit or access) to the accperm

    ENTRY:	paccessperm - points to a ACCESS_PERMISSION object that
		was created on the heap.

    RETURNS:	NERR_Success if successful, standard error code if not
		successful.

    NOTES:	Any permissions left in the ACCPERM on destruction will
		be *deleted*.

    HISTORY:
	Johnl	14-Aug-1991	Created
	Johnl	07-Jul-1992	Made adds idempotent

********************************************************************/

APIERR ACCPERM::AddPermission	( ACCESS_PERMISSION * paccessperm )
{
    UIASSERT( paccessperm->QueryError() == NERR_Success ) ;

    ITER_SL_OF(ACCESS_PERMISSION) itersl( _slAccessPerms ) ;
    ACCESS_PERMISSION * paccesspermTmp ;

    while ( (paccesspermTmp = itersl.Next()) != NULL )
    {
	if ( paccesspermTmp->QuerySubject()->IsEqual( paccessperm->QuerySubject()) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( itersl ) != NULL ) ;
	    delete( paccesspermTmp ) ;
	    break ;
	}
    }

    return ( _slAccessPerms.Add( paccessperm ) ) ;
}

APIERR ACCPERM::AddPermission	( AUDIT_PERMISSION * pauditperm )
{
    UIASSERT( pauditperm->QueryError() == NERR_Success ) ;

    ITER_SL_OF(AUDIT_PERMISSION) itersl( _slAuditPerms ) ;
    AUDIT_PERMISSION * pauditpermTmp ;

    while ( (pauditpermTmp = itersl.Next()) != NULL )
    {
	if ( pauditpermTmp->QuerySubject()->IsEqual( pauditperm->QuerySubject()) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAuditPerms.Remove( itersl ) != NULL ) ;
	    delete( pauditpermTmp ) ;
	    break ;
	}
    }

    return ( _slAuditPerms.Add( pauditperm ) ) ;
}

/*******************************************************************

    NAME:	ACCPERM::DeletePermission

    SYNOPSIS:	Removes and deletes the passed access permission from
		the permission list.  Equality is based on the address
		of the accessperm.

    ENTRY:	paccessperm - permission to remove

    EXIT:	The permission will be removed from the list

    RETURNS:	TRUE if the deletion successful, FALSE otherwise.

    NOTES:	The same comments apply for the AUDIT_PERMISSION form
		of DeletePermission

    HISTORY:
	Johnl	14-Aug-1991	Created

********************************************************************/

BOOL ACCPERM::DeletePermission( ACCESS_PERMISSION * paccessperm )
{
    ITER_SL_OF(ACCESS_PERMISSION) itersl( _slAccessPerms ) ;
    ACCESS_PERMISSION * paccesspermTmp ;

    while ( (paccesspermTmp = itersl.Next()) != NULL )
    {
	if ( paccesspermTmp == paccessperm )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( itersl ) != NULL ) ;
	    delete( paccessperm ) ;
	    _fDidDeleteAccessPerms = TRUE ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

BOOL ACCPERM::DeletePermission( AUDIT_PERMISSION * pauditperm )
{
    ITER_SL_OF(AUDIT_PERMISSION) itersl( _slAuditPerms ) ;
    AUDIT_PERMISSION * pauditpermTmp ;

    while ( (pauditpermTmp = itersl.Next()) != NULL )
    {
	if ( pauditpermTmp == pauditperm )
	{
	    REQUIRE( _slAuditPerms.Remove( itersl ) != NULL ) ;
	    delete( pauditperm ) ;
	    _fDidDeleteAuditPerms = TRUE ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

/*******************************************************************

    NAME:	ACCPERM::EnumAccesspermissions

    SYNOPSIS:	Retrieves all of the Access/Audit permissions in the
		ACCPERM.

    ENTRY:	See Header for explanation of parameters

    EXIT:

    RETURNS:	TRUE while valid data is returned, FALSE otherwise.

    NOTES:	The same comments apply for EnumAuditPermissions

    HISTORY:
	Johnl	14-Aug-1991	Created

********************************************************************/

BOOL ACCPERM::EnumAccessPermissions( ACCESS_PERMISSION * * ppAccessPermission,
				     BOOL * pfFromBeginning )
{
    if ( *pfFromBeginning )
    {
	_iterslAccessPerms.Reset() ;
	*pfFromBeginning = FALSE ;
	_fDidDeleteAccessPerms = FALSE ;
    }

    if ( _fDidDeleteAccessPerms )
    {
	*ppAccessPermission = _iterslAccessPerms.QueryProp() ;
	_fDidDeleteAccessPerms = FALSE ;
    }
    else
	*ppAccessPermission = _iterslAccessPerms.Next() ;

    return *ppAccessPermission != NULL ;
}

BOOL ACCPERM::EnumAuditPermissions(  AUDIT_PERMISSION * * ppAuditPermission,
				     BOOL * pfFromBeginning )
{
    if ( *pfFromBeginning )
    {
	_iterslAuditPerms.Reset() ;
	*pfFromBeginning = FALSE ;
	_fDidDeleteAuditPerms = FALSE ;
    }

    if ( _fDidDeleteAuditPerms )
    {
	*ppAuditPermission = _iterslAuditPerms.QueryProp() ;
	_fDidDeleteAuditPerms = FALSE ;
    }
    else
	*ppAuditPermission = _iterslAuditPerms.Next() ;

    return *ppAuditPermission != NULL ;
}

/*******************************************************************

    NAME:	ACCPERM::DeleteSubject

    SYNOPSIS:	Removes a subject by name from the access and audit
		permissions list

    ENTRY:	pnlsSubjName - Subject to delete

    EXIT:	The subject will be removed from _slAccessPerms and
		_slAuditPerms.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	07-Jul-1992	Implemented

********************************************************************/

APIERR ACCPERM::DeleteSubject( NLS_STR * pnlsSubjName )
{
    ACCESS_PERMISSION * paccesspermTmp ;
    ITER_SL_OF(ACCESS_PERMISSION) iterslAccess( _slAccessPerms ) ;
    while ( (paccesspermTmp = iterslAccess.Next()) != NULL )
    {
	if ( !::stricmpf( paccesspermTmp->QuerySubject()->QueryDisplayName(),
			  pnlsSubjName->QueryPch() ) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAccessPerms.Remove( iterslAccess ) != NULL ) ;
	    delete( paccesspermTmp ) ;
	    break ;
	}
    }

    AUDIT_PERMISSION * pauditpermTmp ;
    ITER_SL_OF(AUDIT_PERMISSION) iterslAudit( _slAuditPerms ) ;
    while ( (pauditpermTmp = iterslAudit.Next()) != NULL )
    {
	if ( !::stricmpf( pauditpermTmp->QuerySubject()->QueryDisplayName(),
			  pnlsSubjName->QueryPch() ) )
	{
	    /* Glock chokes if you try directly deleting the
	     * return value of the Remove.
	     */
	    REQUIRE( _slAuditPerms.Remove( iterslAudit ) != NULL ) ;
	    delete( pauditpermTmp ) ;
	    break ;
	}
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	ACCPERM::AnyDenyAllsToEveryone

    SYNOPSIS:   Checks to see if Everyone has been denied access by an
                explicit "Everyone (None)" or nobody was granted access

    RETURNS:	pfDenyAll will be set to TRUE and NERR_Success will be
		returned

    NOTES:

    HISTORY:
	Johnl	16-Oct-1992	Created

********************************************************************/

APIERR ACCPERM::AnyDenyAllsToEveryone( BOOL *pfDenyAll )
{
    ACCESS_PERMISSION * paccesspermTmp ;
    ITER_SL_OF(ACCESS_PERMISSION) iterslAccess( _slAccessPerms ) ;
    APIERR err = NERR_Success ;

    *pfDenyAll = FALSE ;
    BOOL fAnyGrants = FALSE ;
    while ( (paccesspermTmp = iterslAccess.Next()) != NULL )
    {
	if ( (err = paccesspermTmp->IsDenyAllForEveryone( pfDenyAll )) ||
	     *pfDenyAll )
	{
	    break ;
        }

        if ( paccesspermTmp->IsGrant() )
            fAnyGrants = TRUE ;
    }

    if ( !err && !fAnyGrants )
        *pfDenyAll = TRUE ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\add_dlg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    Add_Dlg.hxx

    This File contains the definitions for the various Add dialogs


    FILE HISTORY:
	Johnl	13-Sep-1991	Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_NET
#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETGROUP
#define INCL_NETUSER
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <maskmap.hxx>

#include <perm.hxx>
#include <accperm.hxx>
#include <subject.hxx>
#include <helpnums.h>

#include <subjlb.hxx>
#include <permdlg.hxx>
#include <ntacutil.hxx>

#include <security.hxx>
#define SECURITY_EDITOR
#include <usrbrows.hxx>

#include <add_dlg.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>


/*******************************************************************

    NAME:	ADD_DIALOG::ADD_DIALOG

    SYNOPSIS:	Constructor for the basic ADD_DIALOG, calls out to virtual
		Fill and Remove.

    ENTRY:	pszDialogName - Name of dialog in resource file
		hwndParent - Window parent
		pchResType - Type of resource
		pchResName - Name of resource
		pslRemoveSubjList - List of subjects that should be
			removed from the Add listbox
		pchEnumFromLocation - Where to get the users from

    NOTES:

    HISTORY:
	Johnl	13-Sep-1991	Created

********************************************************************/


ADD_DIALOG::ADD_DIALOG( const TCHAR * pszDialogName,
			HWND hwndParent,
			const TCHAR * pchResType,
			const TCHAR * pchResName,
                        const TCHAR * pszHelpFileName,
                        ULONG       * ahcHelp,
			const TCHAR * pchDialogTitle,
			LOCATION & EnumLocation )
    : PERM_BASE_DLG( pszDialogName,
		     hwndParent,
		     pchDialogTitle,
		     pchResType,
		     pchResName,
		     pszHelpFileName,
                     ahcHelp ),
      _lbSubjects( this, LB_ADD_SUBJECT_LISTBOX ),
      _buffLBSelection( 0 )
{
    if ( QueryError() != NERR_Success )
	return ;

    if ( !_buffLBSelection )
    {
	ReportError( _buffLBSelection.QueryError() ) ;
	return ;
    }

    APIERR err ;
    if ( ( err = _lbSubjects.Fill( EnumLocation ))   != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	ADD_DIALOG::RemoveSubject

    SYNOPSIS:	This dialog returns the nth selection of the subject
		listbox.  The caller is subsequently responsible for
		deleting the removed subject

    ENTRY:	iSelection - index of the selected item to return

    EXIT:

    RETURNS:	A pointer to the SUBJECT requested (that should be added
		to the main permission dialog).

    NOTES:	You can only remove each selection once, an assertion error
		will occur if you try and remove an item more then once.

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

SUBJECT * ADD_DIALOG::RemoveSubject( int iSelection )
{
    UIASSERT( iSelection < QuerySelectedSubjectCount() ) ;
    int * aiSelection = (INT *) _buffLBSelection.QueryPtr() ;
    SUBJ_LBI * pSubjLBI = (SUBJ_LBI*)_lbSubjects.QueryItem( aiSelection[iSelection]) ;
    SUBJECT  * pSubj = pSubjLBI->QuerySubject() ;

    /* If the extracted subject is NULL, then it was most likely removed
     * twice, which is a no-no.
     */
    UIASSERT( pSubj != NULL ) ;

    /* Set the subject pointer to NULL so when the LBI is destructed, the
     * subject won't be deleted.
     */
    pSubjLBI->SetSubject( NULL ) ;

    return pSubj ;
}

/*******************************************************************

    NAME:	ADD_DIALOG::OnOK

    SYNOPSIS:	Typical OnOK.  Fills in the selection buffer with the indices
		of all of the items the user selected from the listbox.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

BOOL ADD_DIALOG::OnOK( void )
{
    APIERR err ;

    if ( _lbSubjects.QuerySelCount() > 0 )
    {
	/* Fill the selection buffer with the indices of the selected items
	 */
	if ( ( err = _buffLBSelection.Resize(sizeof(INT) * _lbSubjects.QuerySelCount()) ) ||
	     ( err = _lbSubjects.QuerySelItems( (INT *) _buffLBSelection.QueryPtr(),
						_buffLBSelection.QuerySize() / sizeof(INT))) )
	{
	    MsgPopup( this, (MSGID) err, MPSEV_ERROR ) ;
	    return TRUE ;
	}
    }

    Dismiss( TRUE ) ;
    return TRUE ;
}

ULONG ADD_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_ADD_USER_DLG] ;
}

/*******************************************************************

    NAME:	ADD_PERM_DIALOG::ADD_PERM_DIALOG

    SYNOPSIS:	Add permission dialog constructor

    ENTRY:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

ADD_PERM_DIALOG::ADD_PERM_DIALOG( const TCHAR * pszDialogName,
			HWND hwndParent,
			const TCHAR * pchResType,
			const TCHAR * pchResName,
                        const TCHAR * pszHelpFileName,
                        ULONG       * ahcHelp,
			const TCHAR * pchDialogTitle,
			MASK_MAP * pmaskmapPermNames,
			LOCATION & EnumLocation,
			const TCHAR * pszDefaultPermName  )
    : ADD_DIALOG( pszDialogName,
		  hwndParent,
		  pchResType,
		  pchResName,
                  pszHelpFileName,
                  ahcHelp,
		  pchDialogTitle,
		  EnumLocation ),
      _cbPermNames( this, CB_ADD_PERMNAME ),
      _pmaskmapPermNames( pmaskmapPermNames )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pmaskmapPermNames != NULL ) ;
    UIASSERT( _pmaskmapPermNames->QueryError() == NERR_Success ) ;

    /* Fill the combo-box with all of the common permission names.
     */
    BOOL fFromBeginning = TRUE ;
    BOOL fMoreData ;
    NLS_STR nlsPermName( 40 ) ;
    APIERR err ;

    while ( (err = pmaskmapPermNames->EnumStrings( &nlsPermName,
						   &fMoreData,
						   &fFromBeginning,
						   PERMTYPE_GENERAL ))
		   == NERR_Success &&
	    fMoreData )
    {
	if ( _cbPermNames.AddItem( nlsPermName.QueryPch() ) < 0 )
	{
	    ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	    return ;
	}
    }

    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    /* Select the default permission name as the currently selected item.
     */
    INT iDefaultPos = _cbPermNames.FindItemExact( pszDefaultPermName ) ;
    if ( iDefaultPos < 0 )
    {
	/* Ooops, somebody messed up so select the first item as the default
	 */
	UIASSERT( FALSE ) ;
	iDefaultPos = 0 ;
    }
    _cbPermNames.SelectItem( iDefaultPos ) ;
}

/*******************************************************************

    NAME:	ADD_PERM_DIALOG::QueryPermBitMask

    SYNOPSIS:	Gets the bitfield associated with the current permission
		name selection

    ENTRY:	pPermBits - bitfield that receives mask

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	18-Sep-1991	Created

********************************************************************/

APIERR ADD_PERM_DIALOG::QueryPermBitMask( BITFIELD * pPermBits )
{
    NLS_STR nlsPermName( 48 ) ;
    APIERR err ;
    if ( ( err = nlsPermName.QueryError() ) != NERR_Success ||
	 ( err = _cbPermNames.QueryItemText( &nlsPermName ))  )
    {
	return err ;
    }

    err = _pmaskmapPermNames->StringToBits( nlsPermName, pPermBits, PERMTYPE_GENERAL ) ;

    ASSERT( err != ERROR_NO_ITEMS ) ;

    return err ;
}


/*******************************************************************

    NAME:	SED_NT_USER_BROWSER_DIALOG::SED_NT_USER_BROWSER_DIALOG

    SYNOPSIS:	Regular constructor destructor the this class

    ENTRY:	hwndOwner - Owner window handle
		pszServeResourceLivesOn - Server name ("\\server") the
		    resource we are focused on resides (or NULL if local)
		pmaskmapGenPerms - Pointer to permissions maskmap, used
		    for filling in the permname combo
		fIsContainer - TRUE if we are looking at a container, FALSE
		    otherwise.	Determines what ALIASes to show
		pszDefaultPermName - Default permission name to select in the
		    combo.  Must be a general permission in the access mask

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	11-Mar-1992	Created

********************************************************************/


SED_NT_USER_BROWSER_DIALOG::SED_NT_USER_BROWSER_DIALOG(
			    HWND	  hwndOwner,
			    const TCHAR * pszServerResourceLivesOn,
			    MASK_MAP	* pmaskmapGenPerms,
			    BOOL	  fIsContainer,
			    const TCHAR * pszDefaultPermName,
                            const TCHAR * pszHelpFileName,
                            ULONG       * ahcHelp )
    : NT_USER_BROWSER_DIALOG( USRBROWS_SED_DIALOG_NAME,
			      hwndOwner,
			      pszServerResourceLivesOn,
                              ahcHelp[HC_ADD_USER_DLG],
			      fIsContainer ? USRBROWS_SHOW_ALL |
					     USRBROWS_INCL_ALL
					   :
					     USRBROWS_SHOW_ALL |
					     (USRBROWS_INCL_ALL &
					      ~USRBROWS_INCL_CREATOR),
                              pszHelpFileName,
                              ahcHelp[HC_ADD_USER_MEMBERS_GG_DLG],
                              ahcHelp[HC_ADD_USER_MEMBERS_LG_DLG],
                              ahcHelp[HC_ADD_USER_SEARCH_DLG] ),
      _pmaskmapGenPerms( pmaskmapGenPerms ),
      _cbPermNames( this, CB_PERMNAMES )
{
    if ( QueryError() )
	return ;

    ASSERT( pmaskmapGenPerms != NULL ) ;


    BOOL fFromBeginning = TRUE ;
    BOOL fMoreData ;
    NLS_STR nlsPermName( 48 ) ;
    APIERR err ;

    while ( (err = pmaskmapGenPerms->EnumStrings( &nlsPermName,
						  &fMoreData,
						  &fFromBeginning,
						  PERMTYPE_GENERAL ))
		   == NERR_Success &&
	    fMoreData )
    {
	if ( _cbPermNames.AddItem( nlsPermName.QueryPch() ) < 0 )
	{
	    ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	    return ;
	}
    }

    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

    /* Select the default permission name as the currently selected item.
     */
    if ( pszDefaultPermName != NULL )
    {
	INT iDefaultPos = _cbPermNames.FindItemExact( pszDefaultPermName ) ;
	if ( iDefaultPos < 0 )
	{
	    /* Ooops, somebody messed up so select the first item as the default
	     */
	    DBGEOL("SED_NT_USER_BROWSER_DIALOG::ct - Bad default permission name - " << pszDefaultPermName ) ;
	    iDefaultPos = 0 ;
	}
	_cbPermNames.SelectItem( iDefaultPos ) ;
    }
    else
    {
	_cbPermNames.SelectItem( 0 ) ;
    }
}

SED_NT_USER_BROWSER_DIALOG::~SED_NT_USER_BROWSER_DIALOG()
{
    _pmaskmapGenPerms = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\auditdlg.cxx ===
/**********************************************************************/
/**	      Microsoft Windows NT				     **/
/**	   Copyright(c) Microsoft Corp., 1991			     **/
/**********************************************************************/

/*
    AuditDlg.cxx

    This file contains the implementation for the audit dialogs.

    FILE HISTORY:
	Johnl	06-Sep-1991 Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CC
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>

#include <permdlg.hxx>
#include <auditdlg.hxx>
#include <usrbrows.hxx>
#include <helpnums.h>

#include <uitrace.hxx>

#ifndef min
#define min(a,b)  ((a)<(b)?(a):(b))
#endif

/*******************************************************************

    NAME:	SUBJ_AUDIT_LBI::SUBJ_AUDIT_LBI

    SYNOPSIS:	Constructor for subject audit permissions.  These are
		contained in the SUBJECT_AUDIT_LISTBOX.

    ENTRY:	pauditperm - Pointer to AUDIT_PERMISSION this LBI represents

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

SUBJ_AUDIT_LBI::SUBJ_AUDIT_LBI( AUDIT_PERMISSION * pauditperm )
    : SUBJ_LBI( (SUBJECT *) pauditperm->QuerySubject() ),
      _pAuditPerm( pauditperm )
{
    if ( QueryError() )
	return ;
}

SUBJ_AUDIT_LBI::~SUBJ_AUDIT_LBI()
{
    _pAuditPerm = NULL ;
}

/*******************************************************************

    NAME:	SUBJ_AUDIT_LBI::Paint

    SYNOPSIS:	This Paint method adds an "*" to the subject name if the
		permission isn't inheritted by new containers

    NOTES:

    HISTORY:
	Johnl	15-May-1992	Created

********************************************************************/

void SUBJ_AUDIT_LBI::Paint( LISTBOX * plb,
			    HDC hdc,
			    const RECT * prect,
			    GUILTT_INFO * pguiltt ) const
{
    SUBJECT_LISTBOX * plbSubj = (SUBJECT_LISTBOX *) plb ;

    /* If this subject isn't going to be inheritted by new containers, then
     * mark the subject appropriately.
     */
    APIERR err ;
    NLS_STR nlsSubjName( QuerySubject()->QueryDisplayName() ) ;
    if ( !(err = nlsSubjName.QueryError()) &&
	 !_pAuditPerm->IsContainerPermsInheritted() )
    {
	err = nlsSubjName.AppendChar(TCH('*')) ;
    }

    DM_DTE dmiddte( plbSubj->QueryDisplayMap( QuerySubject()) )  ;
    STR_DTE strdteUserName( err ? QuerySubject()->QueryDisplayName() :
				  nlsSubjName.QueryPch() ) ;
    DISPLAY_TABLE dt( 2, plbSubj->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::SUBJECT_AUDIT_LISTBOX

    SYNOPSIS:	Constructor for listbox that displays SUBJ_AUDIT_LBIs

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

SUBJECT_AUDIT_LISTBOX::SUBJECT_AUDIT_LISTBOX( OWNER_WINDOW * pownerwin,
					      CID cid,
					      ACCPERM * paccperm )
    : SUBJECT_LISTBOX( pownerwin, cid ),
      _paccperm( paccperm )
{
    if ( QueryError() )
	return ;

    UIASSERT( paccperm != NULL ) ;
}

SUBJECT_AUDIT_LISTBOX::~SUBJECT_AUDIT_LISTBOX()
{
    _paccperm = NULL ;
}

/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_AUDIT_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:	APIERR if an error occurred

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

APIERR SUBJECT_AUDIT_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    AUDIT_PERMISSION * pAuditPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAuditPermissions( &pAuditPerm, &fFromBeginning ) )
    {
	UIASSERT( pAuditPerm != NULL ) ;

	SUBJ_AUDIT_LBI * pPermLBI = new SUBJ_AUDIT_LBI( pAuditPerm ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    UIDEBUG(SZ("SUBJECT_AUDIT_LISTBOX::Fill - AddItem failed\n\r")) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
    {
	SelectItem( 0 ) ;
    }

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJECT_AUDIT_LISTBOX::DeleteCurrentItem

    SYNOPSIS:	Removes the currently selected item from the listbox

    EXIT:	Updates the listbox and combobox before exitting

    NOTES:

    HISTORY:
	Johnl	12-Nov-1991	Created

********************************************************************/

void SUBJECT_AUDIT_LISTBOX::DeleteCurrentItem( void )
{
    SUBJ_AUDIT_LBI * pPermLBI = QueryItem() ;
    UIASSERT( pPermLBI != NULL ) ;

    REQUIRE( QueryAccperm()->DeletePermission( pPermLBI->QueryAuditPerm() ) ) ;

    INT i = QueryCurrentItem() ;
    UIASSERT( i >= 0 ) ;

    DeleteItem( i ) ;
    INT cItems = QueryCount() ;

    if ( cItems > 0 )
	SelectItem( min( i, cItems - 1 ) ) ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::SUBJ_LB_AUDIT_GROUP

    SYNOPSIS:	Subject listbox audit group constructor

    ENTRY:	plbSubj - Pointer to listbox this group will deal with
		pbuttonRemove - Pointer to remove button that is grayed
			when the listbox is empty.
		pSetOfAuditCat - Pointer to audit categories so we can
			update and disable as appropriate

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

SUBJ_LB_AUDIT_GROUP::SUBJ_LB_AUDIT_GROUP(
			      SUBJECT_AUDIT_LISTBOX   * plbSubj,
			      PUSH_BUTTON	      * pbuttonRemove,
			      SET_OF_AUDIT_CATEGORIES * psetofauditcategories )

    : _plbSubj( plbSubj ),
      _pbuttonRemove( pbuttonRemove ),
      _fEnabled( TRUE ),
      _psetofauditcategories( psetofauditcategories ),
      _psauditlbiCurrent( NULL )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( psetofauditcategories != NULL ) ;
    UIASSERT( plbSubj		    != NULL ) ;
    UIASSERT( pbuttonRemove	    != NULL ) ;

    plbSubj->SetGroup( this ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::OnUserAction

    SYNOPSIS:	This method intercepts selection change messages coming
		from the listbox.  We need to update the Audit categories
		as appropriate.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    13-Nov-1991 Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::OnUserAction(	CONTROL_WINDOW * pcw,
					  const CONTROL_EVENT  & e )
{
    APIERR err = NERR_Success ;

    if ( pcw == QuerySubjLB() )
    {
	// C7 CODEWORK - remove Glock-pacifier cast
	if ( !(pcw->QueryEventEffects( (const CONTROL_EVENT &)e ) & CVMI_VALUE_CHANGE) )
	    return GROUP_NO_CHANGE ;

	/* If the listbox is empty, then we need to disable all of the controls
	 * that operate on items in the listbox.
	 */
	if ( IsEnabled() && QuerySubjLB()->QueryCount() == 0 )
	{
	    Enable( FALSE ) ;
	    return NERR_Success ;
	}
	else if ( !IsEnabled() && QuerySubjLB()->QueryCount() > 0 )
	{
	    Enable( TRUE ) ;
	}

	if ( !(err = CommitCurrent()) )
	    SetCurrent( QuerySubjLB()->QueryItem() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::SetCurrent

    SYNOPSIS:	Updates the _psubjauditlbiCurrent member and sets the
		audit categories for this item.

    ENTRY:	psubjauditlbiCurrent - Pointer to the new lbi that was just
		    selected or NULL to clear.	If NULL, then the group
		    is disabled, else it is enabled.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::SetCurrent( SUBJ_AUDIT_LBI * psubjauditlbiCurrent )
{
    if ( (_psauditlbiCurrent = psubjauditlbiCurrent) == NULL )
    {
	if ( IsEnabled() )
	{
	    Enable( FALSE ) ;
	}
	return NERR_Success ;
    }
    else
    {
	if ( !IsEnabled() )
	{
	    Enable( TRUE ) ;
	}
    }

    return _psetofauditcategories->ApplyPermissionsToCheckBoxes(
	     QueryCurrentLBI()->QueryAuditPerm()->QuerySuccessAuditBits(),
	     QueryCurrentLBI()->QueryAuditPerm()->QueryFailAuditBits()	) ;
}

/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::CommitCurrent

    SYNOPSIS:	Takes the contents of the audit checkboxes and updates the
		current selection of this group (which is not necesarily
		the current selection of the checkbox).

    ENTRY:

    EXIT:	The Groups "Current" LBI will have been updated based
		on the contents of the set of audit categories object.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	13-Nov-1991	Created

********************************************************************/

APIERR SUBJ_LB_AUDIT_GROUP::CommitCurrent( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentLBI() != NULL )
    {
	err = _psetofauditcategories->QueryUserSelectedBits(
		  QueryCurrentLBI()->QueryAuditPerm()->QuerySuccessAuditBits(),
		  QueryCurrentLBI()->QueryAuditPerm()->QueryFailAuditBits()  ) ;
    }

    return err ;
}
/*******************************************************************

    NAME:	SUBJ_LB_AUDIT_GROUP::Enable

    SYNOPSIS:	Enables or disables the appropriate components of this
		group

    ENTRY:	fEnable - TRUE if the group should be enabled, FALSE to
			  disable the group

    EXIT:	The remove button will be grayed and the listbox will
		have its selection bar removed.  The audit checkboxes
		will be cleared and disabled.


    NOTES:

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

void SUBJ_LB_AUDIT_GROUP::Enable( BOOL fEnable )
{
    _fEnabled = fEnable ;

    if ( !fEnable )
	QuerySubjLB()->RemoveSelection() ;

    QueryRemoveButton()->Enable( fEnable ) ;
    QuerySetOfAuditCategories()->Enable( fEnable, fEnable ? FALSE : TRUE ) ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::MULTI_SUBJ_AUDIT_BASE_DLG

    SYNOPSIS:	This forms the base of the auditting hierarchy for
		NT objects and containers

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991 Created

********************************************************************/

MULTI_SUBJ_AUDIT_BASE_DLG::MULTI_SUBJ_AUDIT_BASE_DLG(
				   const TCHAR		 * pszDialogName,
				   HWND 		   hwndParent,
				   const TCHAR		 * pszDialogTitle,
				   ACL_TO_PERM_CONVERTER * paclconv,
				   const TCHAR		 * pszResourceType,
				   const TCHAR		 * pszResourceName,
				   const TCHAR		 * pszHelpFileName,
                                   ULONG                 * ahcMainDialog )
    : MULTI_SUBJ_PERM_BASE_DLG( pszDialogName,
				hwndParent,
				pszDialogTitle,
				paclconv,
				pszResourceType,
				pszResourceName,
				pszHelpFileName,
                                ahcMainDialog ),
      _subjLB	  ( this, LB_SUBJECT_PERMISSIONS, &_accperm ),
      _SetOfAudits( this,
		    SLT_CHECK_TEXT_1,
		    CHECK_AUDIT_S_1,
		    CHECK_AUDIT_F_1,
		    paclconv->QueryAuditMap(),
		    NULL,
		    NULL,
		    PERMTYPE_SPECIAL ),
      _subjlbauditGroup( &_subjLB, QueryRemoveButton(), &_SetOfAudits )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( (err = _subjLB.QueryError()) ||
	 (err = _SetOfAudits.QueryError()) ||
	 (err = _subjlbauditGroup.QueryError() ))
    {
	ReportError( err ) ;
	return ;
    }
}

MULTI_SUBJ_AUDIT_BASE_DLG::~MULTI_SUBJ_AUDIT_BASE_DLG()
{
    /* Nothing to do */
}

BOOL MULTI_SUBJ_AUDIT_BASE_DLG::OnOK( void )
{
    _subjlbauditGroup.CommitCurrent() ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    if ( WritePermissions( FALSE,
			   FALSE,
			   TREEAPPLY_AUDIT_PERMS )  )
    {
        WrnIfAuditingIsOff();
	Dismiss( TRUE ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::OnAddSubject

    SYNOPSIS:	Adds an NT Account to the auditting listbox

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Mar-1992	Integrated NT user browser

********************************************************************/

APIERR MULTI_SUBJ_AUDIT_BASE_DLG::OnAddSubject( void )
{
    _subjlbauditGroup.CommitCurrent() ;

    HWND hWnd = QueryRobustHwnd();

    NT_USER_BROWSER_DIALOG * pdlgUserBrows = new NT_USER_BROWSER_DIALOG(
		     USRBROWS_DIALOG_NAME,
		     hWnd,
		     QueryAclConverter()->QueryLocation()->QueryServer(),
                     QueryHelpArray()[HC_ADD_USER_DLG],
		     QueryAclConverter()->IsContainer() ?
			(USRBROWS_SHOW_ALL | USRBROWS_INCL_ALL) :
			(USRBROWS_SHOW_ALL |
			 (USRBROWS_INCL_ALL & ~USRBROWS_INCL_CREATOR)),
		     QueryHelpFileName(),
                     QueryHelpArray()[HC_ADD_USER_MEMBERS_GG_DLG],
                     QueryHelpArray()[HC_ADD_USER_MEMBERS_LG_DLG],
                     QueryHelpArray()[HC_ADD_USER_SEARCH_DLG] ) ;


    if ( pdlgUserBrows == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err = NERR_Success ;

    InvalidateRect (hWnd, NULL, 0);
    UpdateWindow (hWnd);


    do { // error breakout

	BOOL fUserPressedOK ;
	if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
	     !fUserPressedOK )
	{
	    break ;
	}

	/* Get the permission name and corresponding bitfield(s) the user
	 * selected.
	 */
	UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
	BITFIELD bitSuccess( (ULONG) 0 ) ;
	BITFIELD bitFail( (ULONG) 0 ) ;
	NLS_STR  nlsDomainName ;
	NLS_STR  nlsDisplayName ;

	if ( ( err = bitSuccess.QueryError() )	     ||
	     ( err = bitFail.QueryError() )	     ||
	     ( err = nlsDisplayName.QueryError())    ||
	     ( err = QueryAclConverter()->QueryLoggedOnDomainInfo(
					     NULL, &nlsDomainName )) )
	{
	    break ;
	}

	/* Iterate though each item selected in the Add dialog and add
	 * it to our permission list.
	 */
	BROWSER_SUBJECT_ITER iterUserSelection( pdlgUserBrows ) ;
	BROWSER_SUBJECT * pBrowserSubject ;

	if ( ! (err = iterUserSelection.QueryError()) )
	{
	    while ( !(err = iterUserSelection.Next( &pBrowserSubject )) &&
		     pBrowserSubject != NULL )
	    {
		AUDIT_PERMISSION * pPerm ;
		SID_NAME_USE SidType = pBrowserSubject->QueryType() ;
		if ( SidType == SidTypeUser )
		{
		    /* If this is a remote account, then cast the type
		     * to our own "private" sid name use SubjTypeRemote.
		     */
		    if ( pBrowserSubject->QueryUserAccountFlags() &
					       USER_TEMP_DUPLICATE_ACCOUNT)
		    {
			SidType = (SID_NAME_USE) SubjTypeRemote ;
		    }
		}

		if ( err = pBrowserSubject->QueryQualifiedName(
						    &nlsDisplayName,
						    &nlsDomainName,
						    TRUE ))
		{
		    break ;
		}

		SUBJECT * pSubj = new NT_SUBJECT(
				       (PSID) *pBrowserSubject->QuerySid(),
				       nlsDisplayName.QueryPch(),
				       pBrowserSubject->QueryType());
		if ( err = (pSubj==NULL? ERROR_NOT_ENOUGH_MEMORY :
			    pSubj->QueryError()))
		{
		    break ;
		}

		/* Deletes the subject automatically if we fail to build the
		 * permission.
		 */
		err = QueryAclConverter()->BuildPermission(
			     (PERMISSION **)&pPerm,
			     FALSE,
			     pSubj,
			     &bitSuccess,
			     &bitFail ) ;

		if (  err ||
		     (err = _accperm.AddPermission( pPerm )) )
		{
		    break ;
		}
	    }
	}
    } while ( FALSE ) ; // error breakout loop

    delete pdlgUserBrows ;

    /* Finally, refresh the contents of the listbox.
     */
    if ( !err )
    {
	err = _subjLB.Fill() ;

	if ( _subjLB.QueryCount() > 0 )
	{
	    _subjLB.SelectItem( 0 ) ;
	    _subjlbauditGroup.SetCurrent( _subjLB.QueryItem( 0 ) ) ;
	}
	else
	{
	    _subjlbauditGroup.SetCurrent( NULL ) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Deletes the currently selected subject from the listbox

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	26-Mar-1992	Implemented

********************************************************************/

void MULTI_SUBJ_AUDIT_BASE_DLG::OnDeleteSubject( void )
{
    //
    //	If we are about to remove the last item, then move the focus and
    //	defaultness to the OK button.
    //
    if ( _subjLB.QueryCount() == 1 )
    {
        _buttonOK.ClaimFocus() ;
        QueryRemoveButton()->MakeDefault() ;
        _buttonOK.MakeDefault() ;
    }

    _subjLB.DeleteCurrentItem() ;

    if ( _subjLB.QueryCount() > 0 )
    {
	_subjlbauditGroup.SetCurrent( _subjLB.QueryItem() ) ;
    }
    else
    {
	_subjlbauditGroup.SetCurrent( NULL ) ;
    }
}


/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::Initialize

    SYNOPSIS:	Gets the audit permission and sets the checkboxes as
		appropriate

    ENTRY:

    EXIT:	pfUserQuit is set to TRUE if the user decided to bag out

    RETURNS:	NERR_Success if successful, error otherwise

    NOTES:

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_AUDIT_BASE_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* This call will initialize the accperm
     */
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success || *pfUserQuit )
	return err ;

    if ( err = _subjLB.Fill() )
    {
	UIDEBUG(SZ("MULTI_SUBJ_AUDIT_BASE_DLG::ct - Permission list Fill Failed\n\r")) ;
	return err ;
    }

    _subjlbauditGroup.Enable( _subjLB.QueryCount() > 0 ) ;
    _subjLB.ClaimFocus() ;

    if ( _subjLB.QueryCount() > 0 )
    {
	_subjLB.SelectItem( 0 ) ;
	_subjlbauditGroup.SetCurrent( _subjLB.QueryItem(0) ) ;
    }
    else
    {
	_subjlbauditGroup.SetCurrent( NULL ) ;
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff

    SYNOPSIS:	MsgPopup a warning if the auditing is off.

    ENTRY:

    RETURNS:	

    NOTES:

    HISTORY:
	congpay	15-Dec-1992	Created

********************************************************************/

void MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff (void)
{
    LSA_POLICY lsaPolicy (QueryAclConverter()->QueryLocation()->QueryServer(),
                          POLICY_VIEW_AUDIT_INFORMATION);

    LSA_AUDIT_EVENT_INFO_MEM lsaAeim;
    APIERR err;
    if (((err = lsaPolicy.QueryError()) != NERR_Success) ||
        ((err = lsaPolicy.GetAuditEventInfo (&lsaAeim)) != NERR_Success))
    {
        DBGEOL ("MULTI_SUBJ_AUDIT_BASE_DLG::WrnIfAuditingIsOff Error" << err << "getting auditing Info.");
    }
    else
    {
        if (!lsaAeim.IsAuditingOn())
            MsgPopup (this,
                      IDS_AUDIT_OFF_WARNING,
                      MPSEV_WARNING,
                      MP_OK);
    }
}

/*******************************************************************

    NAME:	CONT_AUDIT_DLG::CONT_AUDIT_DLG

    SYNOPSIS:	NT Container Auditting dialog constructor.  Used
		items such as directories etc.	This dialog just adds
		the checkbox for applying permissions to the contents
		of this container.

    ENTRY:	See MULTI_SUBJ_AUDIT_BASE_DLG

    NOTES:	The NT Object auditting dialog uses the same dialog template,
		so we need to show and enable the container apply checkbox

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

CONT_AUDIT_DLG::CONT_AUDIT_DLG( const TCHAR *		pszDialogName,
				HWND			hwndParent,
				const TCHAR *		pszDialogTitle,
				ACL_TO_PERM_CONVERTER * paclconv,
				const TCHAR *		pszResourceType,
				const TCHAR *		pszResourceName,
				const TCHAR *		pszHelpFileName,
                                ULONG       *           ahcMainDialog,
				const TCHAR *		pszAssignToContContentsTitle,
				const TCHAR *		pszTreeApplyHelpText,
				const TCHAR *		pszTreeApplyConfirmation )
    : MULTI_SUBJ_AUDIT_BASE_DLG( pszDialogName,
				 hwndParent,
				 pszDialogTitle,
				 paclconv,
				 pszResourceType,
				 pszResourceName,
				 pszHelpFileName,
                                 ahcMainDialog ),
      _sltfontTreeApplyHelpText ( this, SLT_TREE_APPLY_HELP_TEXT ),
      _checkAssignToContContents( this, CHECK_APPLY_TO_CONT ),
      _pszTreeApplyConfirmation ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToContContentsTitle == NULL )
    {
	_checkAssignToContContents.Show( FALSE ) ;
	_checkAssignToContContents.Enable( FALSE ) ;
    }
    else
    {
	_checkAssignToContContents.Show( TRUE ) ;
	_checkAssignToContContents.Enable( TRUE ) ;
	_checkAssignToContContents.SetText( pszAssignToContContentsTitle ) ;

#if 0
	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
        }
#endif
    }
}

CONT_AUDIT_DLG::~CONT_AUDIT_DLG()
{
    /* Nothing to do */
}

BOOL CONT_AUDIT_DLG::IsAssignToExistingObjChecked( void )
{
    //
    //  This dialog doesn't support object permissions
    //
    return FALSE ;
}

/*******************************************************************

    NAME:	CONT_AUDIT_DLG::OnOK

    SYNOPSIS:	Normal apply permissions dialog, adds the Apply to container checkbox

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	01-May-1992	Created

********************************************************************/

BOOL CONT_AUDIT_DLG::OnOK( void )
{
    QuerySubjLBGroup()->CommitCurrent() ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    APIERR err ;
    BOOL fAssignToTree = FALSE ;
    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsResName(40) ;
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          IsAssignToExistingObjChecked(),
			  TREEAPPLY_AUDIT_PERMS) )
    {
        WrnIfAuditingIsOff();
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

        if ( fAssignToTree || QueryAclConverter()->IsNewObjectsSupported() )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}


/*******************************************************************

    NAME:	OBJECT_AUDIT_DLG::OBJECT_AUDIT_DLG

    SYNOPSIS:	Constructor for the Object Audit Dialog class.	Used for
		Auditting NT Objects (files etc.).

    ENTRY:	See MULTI_SUBJ_AUDIT_BASE_DLG

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

OBJECT_AUDIT_DLG::OBJECT_AUDIT_DLG( const TCHAR *	    pszDialogName,
				    HWND		    hwndParent,
				    const TCHAR *	    pszDialogTitle,
				    ACL_TO_PERM_CONVERTER * paclconv,
				    const TCHAR *	    pszResourceType,
				    const TCHAR *	    pszResourceName,
				    const TCHAR *	    pszHelpFileName,
                                    ULONG       *           ahcMainDialog )
    : MULTI_SUBJ_AUDIT_BASE_DLG( pszDialogName,
				 hwndParent,
				 pszDialogTitle,
				 paclconv,
				 pszResourceType,
				 pszResourceName,
				 pszHelpFileName,
                                 ahcMainDialog )
{
    if ( QueryError() )
	return ;
}

OBJECT_AUDIT_DLG::~OBJECT_AUDIT_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       CONT_NEWOBJ_AUDIT_DLG::CONT_NEWOBJ_AUDIT_DLG

    SYNOPSIS:   NT Container with new object Auditting dialog constructor.
                Used for directories etc.  This dialog just adds
                the checkbox for applying permissions to the existing
                contents of this container.

    ENTRY:      See CONT_AUDIT_DLG

    HISTORY:
        Johnl   01-Apr-1993     Created

********************************************************************/

CONT_NEWOBJ_AUDIT_DLG::CONT_NEWOBJ_AUDIT_DLG(
                                const TCHAR *           pszDialogName,
				HWND			hwndParent,
				const TCHAR *		pszDialogTitle,
				ACL_TO_PERM_CONVERTER * paclconv,
				const TCHAR *		pszResourceType,
				const TCHAR *		pszResourceName,
				const TCHAR *		pszHelpFileName,
                                ULONG       *           ahcMainDialog,
                                const TCHAR *           pszAssignToContContentsTitle,
                                const TCHAR *           pszAssignToObjTitle,
				const TCHAR *		pszTreeApplyHelpText,
				const TCHAR *		pszTreeApplyConfirmation )
    : CONT_AUDIT_DLG( pszDialogName,
                      hwndParent,
                      pszDialogTitle,
                      paclconv,
                      pszResourceType,
                      pszResourceName,
                      pszHelpFileName,
                      ahcMainDialog,
                      pszAssignToContContentsTitle,
                      pszTreeApplyHelpText,
                      pszTreeApplyConfirmation ),
      _checkAssignToObj( this, CHECK_APPLY_TO_OBJ )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToObjTitle == NULL )
    {
        _checkAssignToObj.Show( FALSE ) ;
        _checkAssignToObj.Enable( FALSE ) ;
    }
    else
    {
        _checkAssignToObj.SetText( pszAssignToObjTitle ) ;
        _checkAssignToObj.SetCheck( TRUE ) ;
    }
}

CONT_NEWOBJ_AUDIT_DLG::~CONT_NEWOBJ_AUDIT_DLG()
{
    /* Nothing to do */
}

BOOL CONT_NEWOBJ_AUDIT_DLG::IsAssignToExistingObjChecked( void )
{
    return _checkAssignToObj.QueryCheck() ;
}



/*******************************************************************

    NAME:	LM_AUDITTING_DLG::LM_AUDITTING_DLG

    SYNOPSIS:	This is the Lan Manager File and directory auditting dialog

    ENTRY:	Same as parent
		pszAssignToContContentsTitle is the name of the checkbox.  If
		    it is NULL (as it should be for files) then the checkbox
		    will be hidden and disabled.

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991 Created

********************************************************************/

LM_AUDITTING_DLG::LM_AUDITTING_DLG( const TCHAR *    pszDialogName,
				    HWND	     hwndParent,
				    const TCHAR *    pszDialogTitle,
				    ACL_TO_PERM_CONVERTER * paclconv,
				    const TCHAR *    pszResourceType,
				    const TCHAR *    pszResourceName,
				    const TCHAR *    pszHelpFileName,
                                    ULONG       *    ahcMainDialog,
				    const TCHAR *    pszAssignToContContentsTitle,
				    const TCHAR *    pszTreeApplyHelpText,
				    const TCHAR *    pszTreeApplyConfirmation )
   : MAIN_PERM_BASE_DLG( pszDialogName,
			 hwndParent,
			 pszDialogTitle,
			 paclconv,
			 pszResourceType,
			 pszResourceName,
			 pszHelpFileName,
                         ahcMainDialog ),
     _checkAssignToContContents( this, CHECK_APPLY_TO_CONT ),
     _SetOfAudits	       ( this,
				 SLT_CHECK_TEXT_1,
				 CHECK_AUDIT_S_1,
				 CHECK_AUDIT_F_1,
				 paclconv->QueryAuditMap(),
				 NULL,
				 NULL,
				 PERMTYPE_SPECIAL ),
    _sltfontTreeApplyHelpText  ( this, SLT_TREE_APPLY_HELP_TEXT ),
    _pszTreeApplyConfirmation  ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( _SetOfAudits.QueryError() )
    {
	ReportError( _SetOfAudits.QueryError() ) ;
	return ;
    }

    if ( pszAssignToContContentsTitle == NULL )
    {
	_checkAssignToContContents.Show( FALSE ) ;
	_checkAssignToContContents.Enable( FALSE ) ;
    }
    else
    {
	_checkAssignToContContents.SetText( pszAssignToContContentsTitle ) ;

	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
	}
    }
}

LM_AUDITTING_DLG::~LM_AUDITTING_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	LM_AUDITTING_DLG::Initialize

    SYNOPSIS:	Gets the audit permission and sets the checkboxes as
		appropriate

    ENTRY:

    EXIT:	pfUserQuit is set to TRUE if the user decided to bag out

    RETURNS:	NERR_Success if successful, error otherwise

    NOTES:

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR LM_AUDITTING_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* This call will initialize the accperm
     */
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success || *pfUserQuit )
	return err ;

    AUDIT_PERMISSION * pAuditPerm ;
    BOOL fFromBeginning = TRUE ;
    if ( _accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) )
    {
	_pbitsSuccess = pAuditPerm->QuerySuccessAuditBits() ;
	_pbitsFailed  = pAuditPerm->QueryFailAuditBits() ;
	err = _SetOfAudits.ApplyPermissionsToCheckBoxes( _pbitsSuccess, _pbitsFailed ) ;
	if ( err != NERR_Success )
	    return err ;

	/* There should only be one Audit record in the accperm
	 */
	UIASSERT( !_accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) ) ;
    }
    else
    {
	/* There must be one audit permission in the accperm, if there isn't,
	 * then something is wrong.
	 */
	UIASSERT( FALSE ) ;
	return ERROR_GEN_FAILURE ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	LM_AUDITTING_DLG::OnOK( void )

    SYNOPSIS:	Typical OnOK processing - Grab the newly selected bits and
		write them out, put up an error if an error ocurred.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

BOOL LM_AUDITTING_DLG::OnOK( void )
{
    _SetOfAudits.QueryUserSelectedBits( _pbitsSuccess, _pbitsFailed ) ;

    APIERR err ;
    BOOL fAssignToTree = FALSE ;
    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	NLS_STR nlsResName ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          fAssignToTree,
			  TREEAPPLY_AUDIT_PERMS) )
    {
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

	if ( fAssignToTree )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netid\state.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state
// 
// 3-11-98 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED

extern TCHAR const c_szWizardFilename[];



String
CheckPreconditions();



// Returns the dc role change status of the machine.

DSROLE_OPERATION_STATE
GetDsRoleChangeState();



// Return false if the machine is undergoing a DC upgrade, true otherwise.
// 388578

bool
IsUpgradingDc();






// Singleton state of the UI.

class State
{
   public:

   static
   void
   Delete();

   static
   State&
   GetInstance();

   static
   void
   Init();

   static
   void
   Refresh();

   bool
   ChangesNeedSaving() const;

   bool
   IsMachineDc() const;

   bool
   IsMemberOfWorkgroup() const;

   bool
   IsNetworkingInstalled() const;

   void
   SetIsMemberOfWorkgroup(bool yesNo);

   String
   GetComputerDomainDnsName() const;

   void
   SetComputerDomainDnsName(const String& newName);

   bool
   ComputerDomainDnsNameWasChanged() const;

   String
   GetFullComputerName() const;

   String
   GetNetbiosComputerName() const;

   String
   GetShortComputerName() const;

   void
   SetShortComputerName(const String& name);

   bool
   WasShortComputerNameChanged() const;

   bool
   WasNetbiosComputerNameChanged() const;

   String
   GetOriginalShortComputerName() const;

   String
   GetDomainName() const;

   void
   SetDomainName(const String& name);

   bool
   WasMembershipChanged() const;

   bool
   GetSyncDNSNames() const;

   void
   SetSyncDNSNames(bool yesNo);

   bool
   SyncDNSNamesWasChanged() const;

   bool
   SaveChanges(HWND dialog);

   // indicates that changes have been made in this session.

   bool
   ChangesMadeThisSession() const;

   void
   SetChangesMadeThisSession(bool yesNo);

   // indicates that changes have been made in this or prior sessions, or
   // the computer name has been changed by some other means than ourselves.

   bool
   NeedsReboot() const;

   private:

   // Init() actually builds the instance
   State();

   // Delete destroys the instance
   ~State();

   // not implemented:  no copying allowed
   State(const State&);
   const State& operator=(const State&);

   bool
   DoSaveDomainChange(HWND dialog);

   bool
   DoSaveWorkgroupChange(HWND dialog);

   bool
   DoSaveNameChange(HWND dialog);

   void
   SetFullComputerName();
};



#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\fmxproc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    fmxproc.cxx
    This file contains FMExtensionProcW.

    FILE HISTORY:
        rustanl     02-May-1991     Created
        Yi-HsinS    12-Sept-1991    Make it fit into the real world
        Yi-HsinS    12-Sept-1991    Unicode Work
        JonN        10-July-2000    130459: Disabled this capability for _WIN64;
                                    the FMExtensionProcW interface is not
                                    64-bit compatible.

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntioapi.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETACCESS
#define INCL_NETAUDIT
#define INCL_NETUSE
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <netlib.h>
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MENU
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <lmobj.hxx>
#include <lmodev.hxx>
#include <security.hxx>
#include <netname.hxx>
#include <maskmap.hxx>
#include <fmx.hxx>
#include <fsenum.hxx>
#include <uiassert.hxx>
#include <errmap.hxx>

#include <permstr.hxx>

#include <accperm.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>

#include <ntfsacl.hxx>


// this must lack the SZ for string concat to work
#define FMXPROC "FMExtensionProcW:  "

// This load-by-name is permissible, since BLT never sees it
#define FMX_MENU SZ("FMXMenu")

EXT_BUTTON aExtButton[] = { IDM_PERMISSION, 0, 0 } ;


extern HINSTANCE hModule; // Exported from libmain

APIERR CheckMenuAccess( HWND          hwndFMX,
                        BOOL *        pfPerm,
                        BOOL *        pfAudit,
                        BOOL *        pfOwner ) ;

//
//  Help context array.  Do lookups by using the following formula:
//
//       IsNT << 2 |  IsDir << 1 | !IsPerms
//
//  And use the index for the lookup
//
ULONG ahc[8] = {   HC_SED_LM_FILE_PERMS_DLG,
                   HC_SED_LM_FILE_AUDITS_DLG,
                   HC_SED_LM_DIR_PERMS_DLG,
                   HC_SED_LM_DIR_AUDITS_DLG,
                   HC_SED_NT_FILE_PERMS_DLG,
                   HC_SED_NT_FILE_AUDITS_DLG,
                   HC_SED_NT_DIR_PERMS_DLG,
                   HC_SED_NT_DIR_AUDITS_DLG
               } ;
inline ULONG LookupHC( BOOL fIsNT, BOOL fIsDir, BOOL fIsPerms )
{
    return ahc[(fIsNT << 2) |  (fIsDir << 1) | !fIsPerms] ;
}

/*******************************************************************

    NAME:       FMExtensionProcW

    SYNOPSIS:   File Manager Extension Procedure

    ENTRY:      hwnd        See FMX spec for details
                wEvent
                lParam

    EXIT:       See FMX spec for details

    RETURNS:    See FMX spec for details

    NOTES:

    HISTORY:
        rustanl     02-May-1991     Created
        yi-hsins    12-Sept-1991    Make it fit the real world
        JohnL       21-Jan-1991     Added Permissions stuff
        JonN        10-July-2000    130459: Disabled this capability for _WIN64;
                                    the FMExtensionProcW interface is not
                                    64-bit compatible.

********************************************************************/

LONG FMExtensionProcW( HWND hwnd, WORD wEvent, LONG lParam )
{
#ifndef _WIN64 // 130459
    static HWND vhwnd = NULL;
    static UINT vwMenuDelta = 0;
#ifdef ACLEDIT_IS_REAL_EXTENSION
    static HMENU vhMenu = NULL;
#endif

    if ( wEvent != FMEVENT_UNLOAD && vhwnd != NULL )
    {
        //  vhwnd is assumed to be hwnd
        if ( vhwnd != hwnd )
        {
            DBGEOL( FMXPROC "hwnd != vhwnd: hwnd = "
                    << (UINT_PTR)hwnd << ", vhwnd = " << (UINT_PTR)vhwnd );
        }
    }

    if ( wEvent < 100 )
    {
        switch ( wEvent )
        {
        case IDM_PERMISSION:
            {
                EditPermissionInfo( hwnd ) ;
            }
            break ;

        case IDM_AUDITING:
            {
                EditAuditInfo( hwnd ) ;
            }
            break ;

        case IDM_OWNER:
            {
                EditOwnerInfo( hwnd ) ;
            }
            break ;

        default:
            DBGEOL(FMXPROC "Unexpected menu ID");
            break;
        }
        return 0;
    }

    switch ( wEvent )
    {
    case FMEVENT_LOAD:
        {
            FMS_LOAD * pfmsload = (FMS_LOAD *)lParam;

            if ( vhwnd != NULL )
            {
                //  This should not happen, but don't assert, since this
                //  is File Man's code.  This will happen, for example,
                //  if File Man GPs without giving the FMEVENT_UNLOAD
                //  notification.
                DBGEOL(FMXPROC "Multiple initializations!");
            }
            vhwnd = hwnd;
            vwMenuDelta = pfmsload->wMenuDelta;

            pfmsload->dwSize = sizeof( FMS_LOAD );

#ifdef ACLEDIT_IS_REAL_EXTENSION
//
//  Winfile loads Acledit as a hybrid extension that knows our menu.  It
//  passes us the menu on the menu item init so we don't need to do this
//  work.
//

            RESOURCE_STR nlsMenuName( IDS_NETWORK_NAME ) ;
            if ( nlsMenuName.QueryError() != NERR_Success )
            {
                DBGEOL(FMXPROC "NLS_STR::Load failed");
                return FALSE;       // failed to install FMX
            }

            // MENU_TEXT_LEN is defined in wfext.h, in BYTES
            if ( nlsMenuName.QueryTextSize() > sizeof(pfmsload->szMenuName) )
            {
                DBGEOL(FMXPROC "Menu item too long for FM's buffer");
                return FALSE;       // failed to install FMX
            }

            APIERR err ;
            if ( err = nlsMenuName.MapCopyTo( pfmsload->szMenuName,
                                              sizeof(pfmsload->szMenuName)))
            {
                DBGEOL(FMXPROC "MapCopyTo failed with error " << err ) ;
                return FALSE ;
            }

            //  Compute hMenu
            HMENU hMenu = ::LoadMenu( ::hModule, FMX_MENU );
            if ( hMenu == NULL )
            {
                DBGEOL(FMXPROC "LoadMenu failed");
                return FALSE;       // failed to install FMX
            }

            pfmsload->hMenu = hMenu;
            vhMenu = hMenu;
#endif //!ACLEDIT_IS_REAL_EXTENSION
        }
        return TRUE;        // success

    case FMEVENT_UNLOAD:
        vhwnd = NULL;
        vwMenuDelta = 0;
        return 0;

    case FMEVENT_INITMENU:
        {
            #define PERM_MENU_ITEM_OFFSET     0
            #define AUDIT_MENU_ITEM_OFFSET    1
            #define OWNER_MENU_ITEM_OFFSET    2

            BOOL fPerm  = TRUE,
                 fAudit = TRUE,
                 fOwner = TRUE ;
            (void) ::CheckMenuAccess(  hwnd, &fPerm, &fAudit, &fOwner ) ;

            //
            //  Enable (by default) if an error occurred in CheckMenuAccess
            //
            POPUP_MENU menu( (HMENU) lParam /*vhMenu*/ ) ;
            menu.EnableItem( PERM_MENU_ITEM_OFFSET,  fPerm,  MF_BYPOSITION ) ;
            menu.EnableItem( AUDIT_MENU_ITEM_OFFSET, fAudit, MF_BYPOSITION ) ;
            menu.EnableItem( OWNER_MENU_ITEM_OFFSET, fOwner, MF_BYPOSITION ) ;
        }
        return 0;

    case FMEVENT_TOOLBARLOAD:
        {
            FMS_TOOLBARLOAD  * pfmstoolbarload = (FMS_TOOLBARLOAD *)lParam;
            pfmstoolbarload->dwSize = sizeof(FMS_TOOLBARLOAD) ;
            pfmstoolbarload->lpButtons = aExtButton ;
            pfmstoolbarload->cButtons = 1 ;
            pfmstoolbarload->cBitmaps = 1 ;
	    pfmstoolbarload->idBitmap = BMID_SECURITY_TOOLBAR ;
	    pfmstoolbarload->hBitmap  = NULL ;
        }
        return TRUE ;

#ifdef ACLEDIT_IS_REAL_EXTENSION
    case FMEVENT_HELPSTRING:
	{
	    FMS_HELPSTRING * pfmshelp = (FMS_HELPSTRING *) lParam ;
	    MSGID msgHelp ;
	    switch ( pfmshelp->idCommand )
	    {
	    case IDM_PERMISSION:
		msgHelp = IDS_FM_HELP_PERMISSION_MENU_ITEM ;
		break ;

	    case IDM_AUDITING:
		msgHelp = IDS_FM_HELP_AUDITING_MENU_ITEM ;
		break ;

	    case IDM_OWNER:
		msgHelp = IDS_FM_HELP_OWNER_MENU_ITEM ;
		break ;

	    case ( -1 ):
	    default:
		msgHelp = IDS_FM_HELP_SECURITY_MENU ;
		break ;
	    }

	    RESOURCE_STR nlsHelp( msgHelp ) ;
	    if ( !nlsHelp.QueryError() )
	    {
		(void) nlsHelp.MapCopyTo( pfmshelp->szHelp,
					  sizeof( pfmshelp->szHelp )) ;
	    }
	}
	break ;
#endif

    //
    //  Somebody's pressed F1 on the security menu item selection
    //
    case FMEVENT_HELPMENUITEM:
        {
            APIERR err = NERR_Success ;
            BOOL   fIsFile ;
            BOOL   fIsNT ;
            BOOL   fIsLocal ;
            NLS_STR nlsSelItem;
            NLS_STR nlsServer ;
            RESOURCE_STR nlsHelpFile( IDS_FILE_PERM_HELP_FILE ) ;

            if ( (err = nlsSelItem.QueryError())  ||
                 (err = nlsServer.QueryError())   ||
                 (err = nlsHelpFile.QueryError()) ||
                 (err = ::GetSelItem( hwnd, 0, &nlsSelItem, &fIsFile )))
            {
                DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                       << " server path") ;
                break ;
            }


            err = ::TargetServerFromDosPath( nlsSelItem, &fIsLocal, &nlsServer );
            if (  ( err != NERR_Success )
               && ( err != NERR_InvalidDevice )
               )
            {
                DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                       << " server path") ;
                break ;
            }
            else if ( err == NERR_InvalidDevice )
            {
                //
                // Since LM can't determine the path, we will try all
                // providers to see if any one of them supports the
                // drive.
                //

                NLS_STR nlsDrive( nlsSelItem );
                ISTR istr( nlsDrive );
                BUFFER buffer( MAX_PATH );
                DWORD cbBufferSize;
                DWORD nDialogType;
                DWORD nHelpContext;

                if (  ( err = nlsDrive.QueryError())
                   || ( err = buffer.QueryError())
                   )
                {
                    break;
                }

                //
                // Get the drive letter of the selected item
                //
                istr += 2;
                nlsDrive.DelSubStr( istr ); 

                switch ( lParam )
                {
                case IDM_OWNER:
                    nDialogType = WNPERM_DLG_OWNER;
                    break;

                case IDM_AUDITING:
                    nDialogType = WNPERM_DLG_AUDIT;
                    break;

                case IDM_PERMISSION:
                    nDialogType = WNPERM_DLG_PERM;
                    break;
                }

                cbBufferSize = buffer.QuerySize();

                err = WNetFMXGetPermHelp( (LPWSTR) nlsDrive.QueryPch(),
                                          nDialogType,
                                          !fIsFile,
                                          buffer.QueryPtr(),
                                          &cbBufferSize,
                                          &nHelpContext );

                if ( err == WN_MORE_DATA )
                {
                    err = buffer.Resize( cbBufferSize );
                    err = err ? err : WNetFMXGetPermHelp( 
                                          (LPWSTR) nlsDrive.QueryPch(),
                                          nDialogType,
                                          !fIsFile,
                                          buffer.QueryPtr(),
                                          &cbBufferSize,
                                          &nHelpContext );
                }

                if ( err == NERR_Success )
                {
                    ::WinHelp( hwnd,
                               (LPTSTR) buffer.QueryPtr(),
                               HELP_CONTEXT,
                               nHelpContext );
                }

                break;
            }

            //
            //  If the partition is local, then we must be on NT
            //
            if ( fIsLocal )
                fIsNT = TRUE ;
            else
            {
                LOCATION locDrive( nlsServer, FALSE ) ;
                if ( (err = locDrive.QueryError()) ||
                     (err = locDrive.CheckIfNT( &fIsNT )) )
                {
                    DBGEOL("Acledit FMExtensionProcW - Error " << err << " getting "
                          << " location info") ;
                    break ;
                }
            }

            ULONG hc = HC_SED_LM_FILE_PERMS_DLG;
            switch ( lParam )
            {
            case IDM_OWNER:
                hc = HC_TAKEOWNERSHIP_DIALOG ;
                break ;

            case IDM_AUDITING:
            case IDM_PERMISSION:
                hc = LookupHC( fIsNT, !fIsFile, lParam == IDM_PERMISSION) ;
                break ;
            }

            DBGEOL("Calling help on context " << (HEX_STR) hc) ;
            ::WinHelp( hwnd, nlsHelpFile, HELP_CONTEXT, hc ) ;
        }
        break ;


    default:
        DBGEOL(FMXPROC "Unexpected wEvent param: " << (HEX_STR)wEvent );
        break;
    }
#endif // 130459

    return 0;

}  // FMExtensionProcW



/*******************************************************************

    NAME:       CheckMenuAccess

    SYNOPSIS:   Checks to see if the user would be able to do anything
                with the current selection (i.e., can read the DACL,
                write the SACL etc.)

    ENTRY:      hwndFMX - FMX hwnd
                pfPerm
                pfAudit - If TRUE the menu item should be enabled, FALSE if
                pfOwner     disabled

    RETURNS:    NERR_Success if succesful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Jan-1992     Created

********************************************************************/

APIERR CheckMenuAccess( HWND          hwndFMX,
                        BOOL *        pfPerm,
                        BOOL *        pfAudit,
                        BOOL *        pfOwner )
{
    APIERR err = NERR_Success ;
    *pfPerm = *pfAudit = *pfOwner = TRUE ;
    FMX fmx( hwndFMX );
    BOOL   fIsFile ;
    NLS_STR nlsSelItem;
    BOOL   fRC = TRUE,    // Read control
           fWD = TRUE,    // Write DAC
           fWO = TRUE,    // Write Owner
           fWS = TRUE ;   // Read/Write SACL

    do { // error breakout

        //
        //  Something must be selected
        //
        if ( fmx.QuerySelCount() == 0 )
        {
            *pfPerm = *pfAudit = *pfOwner = FALSE ;
            break ;
        }

        if ( (err = nlsSelItem.QueryError()) ||
             (err = ::GetSelItem( hwndFMX, 0, &nlsSelItem, &fIsFile )))
        {
            break ;
        }

        BOOL fIsLocal ;
        NLS_STR  nlsServer( RMLEN ) ;
        if (err = nlsServer.QueryError())
            break;

        err = ::TargetServerFromDosPath( nlsSelItem,
                                         &fIsLocal,
                                         &nlsServer );


        if ( err == NERR_InvalidDevice )
        {
            //
            // Try other providers, nPermCap will be 0 if no provider
            // supports this drive and all menu items will be grayed out.
            //
            NLS_STR nlsDrive( nlsSelItem );
            ISTR istr( nlsDrive );

            if ( err = nlsDrive.QueryError() )
                break;

            istr += 2;
            nlsDrive.DelSubStr( istr );

            DWORD nPermCap = WNetFMXGetPermCaps( (LPWSTR) nlsDrive.QueryPch());
            *pfPerm = !!( nPermCap & WNPERMC_PERM );
            *pfAudit = !!( nPermCap & WNPERMC_AUDIT );
            *pfOwner = !!( nPermCap & WNPERMC_OWNER );

            err = NERR_Success;
            break;
        }


        BOOL fIsNT ;
        BOOL fIsMultiSelect = (fmx.QuerySelCount() > 1 ) ;
        LOCATION locDrive( fIsLocal ? NULL : nlsServer.QueryPch(), FALSE ) ;
        if ( (err = locDrive.QueryError()) ||
             (err = locDrive.CheckIfNT( &fIsNT ))  )
        {
            UIDEBUG(SZ("::EditFSAcl - locDrive failed to construct\n\r")) ;
            break ;
        }

        if ( !fIsNT )
        {
            //
            //  If LM (or something else), disable the owner but leave the
            //  Audit/Permission menu items enabled (we don't check to see
            //  if the share is share level or user level).
            //
            *pfOwner = FALSE ;
            break ;
        }

        //
        //  We know it's NT, but is the resource on an NTFS partition?
        //
        BOOL  fIsNTFS ;
        if ( err = IsNTFS( nlsSelItem, &fIsNTFS ))
        {
            break ;
        }

        if ( !fIsNTFS )
        {
            *pfPerm  = FALSE ;
            *pfAudit = FALSE ;
            *pfOwner = FALSE ;
            break ;
        }

        //
        //  Leave the menu items alone if we're on an NTFS partition but there
        //  is a multi-selection
        //
        if ( fIsMultiSelect )
            break ;

        //
        //  Check to see if we have permission/privilege to read the security
        //  descriptors
        //
        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         READ_CONTROL,
                                         &fRC )) )
        {
            fRC = TRUE ;
            TRACEEOL("CheckMenuAccess - READ_CONTROL_ACCESS check failed with error " << ::GetLastError() ) ;
        }

        //
        //  How about to write the security descriptor?
        //
        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         WRITE_DAC,
                                         &fWD )) )
        {
            fWD = TRUE ;
        }

        if ( !fRC && !fWD )
        {
            *pfPerm = FALSE ;
        }

        //
        //  Check to see if the user can write to the owner SID
        //

        BOOL fOwnerPrivAdjusted = FALSE ;
        ULONG ulOwnerPriv = SE_TAKE_OWNERSHIP_PRIVILEGE ;
        if ( ! ::NetpGetPrivilege( 1, &ulOwnerPriv ) )
        {
            fOwnerPrivAdjusted = TRUE ;
        }

        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         WRITE_OWNER,
                                         &fWO )) )
        {
            fWO = TRUE ;
        }

        if ( !fWO && !fRC )
        {
            *pfOwner = FALSE ;
        }

        if ( fOwnerPrivAdjusted )
            ::NetpReleasePrivilege() ;

        //
        //  Check to see if the user can read/write the SACL
        //

        BOOL fAuditPrivAdjusted = FALSE ;
        ULONG ulAuditPriv = SE_SECURITY_PRIVILEGE ;
        if ( ! ::NetpGetPrivilege( 1, &ulAuditPriv ) )
        {
            fAuditPrivAdjusted = TRUE ;
        }

        if ( (err = ::CheckFileSecurity( nlsSelItem,
                                         ACCESS_SYSTEM_SECURITY,
                                         &fWS )) )
        {
            *pfAudit = TRUE ;
            DBGEOL("CheckMenuAccess - ACCESS_SYSTEM_SECURITY check failed with error " << ::GetLastError() ) ;
        }
        else
            *pfAudit = fWS ;

        if ( fAuditPrivAdjusted )
            ::NetpReleasePrivilege() ;

    } while (FALSE) ;


    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\lmaclcon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    LMACLCon.cxx

    This file contains the Lanman LM_ACL_TO_PERM_CONVERTER code.



    FILE HISTORY:
        Johnl   02-Aug-1991     Created

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_NETLIB
#define INCL_NETWKSTA
#include <lmui.hxx>

#include <base.hxx>
#include <maskmap.hxx>
#include <lmoacces.hxx>
#include <fsenum.hxx>
#include <strnumer.hxx>

extern "C"
{
    #include <lmaudit.h>
    #include <mnet.h>
}

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <lmodom.hxx>
#include <lmowks.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>
#include <security.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <ipermapi.hxx>
#include <permprg.hxx>
#include <permstr.hxx>
#include <ntfsacl.hxx>      // For the tree apply dialogs

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::ACL_TO_PERM_CONVERTER

    SYNOPSIS:

    ENTRY:      pszLocation - NULL for local workstation
                              "\\server" for server
                              "Domain"   for domain name



    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   18-Aug-1991     Created
        Johnl   25-Sep-1991     Added Location object

********************************************************************/

ACL_TO_PERM_CONVERTER::ACL_TO_PERM_CONVERTER( const TCHAR * pszServer,
                                              MASK_MAP * paccessmap,
                                              MASK_MAP * pauditmap,
                                              BOOL fIsNT,
                                              BOOL fIsContainer,
                                              BOOL fIsNewObjectsSupported,
                                              BOOL fShowMnemonics )
    : _location              ( pszServer ),
      _fReadOnly             ( FALSE ),
      _fIsNT                 ( fIsNT ),
      _fIsContainer          ( fIsContainer ),
      _fIsNewObjectsSupported( fIsNewObjectsSupported ),
      _fShowMnemonics        ( fShowMnemonics ),
      _paccmaskmap           ( paccessmap ),
      _pauditmaskmap         ( pauditmap ),
      _hwndErrorParent       ( NULL ),
      _nlsLoggedOnDC         ( (const TCHAR *)NULL ),
      _nlsLoggedOnDomain     ( (const TCHAR *)NULL )
{
    APIERR err ;
    if ( (err = _location.QueryError()) ||
         (err = _nlsLoggedOnDC.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

ACL_TO_PERM_CONVERTER::~ACL_TO_PERM_CONVERTER()
{
    _paccmaskmap = NULL ;
    _pauditmaskmap = NULL ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap

    SYNOPSIS:   Returns the New object access map

    RETURNS:    The default is to return NULL which indicates new
                objects are not supported.

    NOTES:      This will only be implemented for NT objects that are
                containers and support new sub-object permissions

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

MASK_MAP * ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::BuildPermission

    SYNOPSIS:   Builds the appropriate permission object based on the
                environment (i.e., NT, NT Cont, LM etc.).

    ENTRY:      See Header for parameter details

    EXIT:       *ppPerm will point to a newly allocated permission of the
                appropriate type

    RETURNS:    NERR_Success of successful

    NOTES:      The subject will automatically be deleted if an error
                occurred

    HISTORY:
        Johnl   18-Sep-1991     Moved from LM_ACL_TO_PERM_CONVERTER

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::BuildPermission(
                                   PERMISSION * * ppPerm,
                                   BOOL fAccessPermission,
                                   SUBJECT  * pSubj,
                                   BITFIELD * pbits1,
                                   BITFIELD * pbits2,
                                   BOOL       fContainerPermsInheritted )
{
    ASSERT( pSubj != NULL ) ;
    ASSERT( pSubj->QueryError() == NERR_Success ) ;
    ASSERT( pbits1 != NULL ) ;

    /* Allocate the correct PERMISSION object
     */
    if ( fAccessPermission )
    {
        if ( IsNewObjectsSupported() )
        {
            UIASSERT( IsNT() ) ;

            BOOL fIsMapped =  QueryAccessMap()->IsPresent( pbits1 ) &&
                              (pbits2 != NULL ?
                                QueryNewObjectAccessMap()->IsPresent( pbits2 ) :
                                TRUE) ;
#ifdef TRACE
            if ( !fIsMapped )
                TRACEEOL("\tBuildPermission: Warning - Adding Non-Mapped access mask\n") ;
#endif
            *ppPerm = new NT_CONT_ACCESS_PERMISSION( pSubj,
                                                     pbits1,
                                                     pbits2,
                                                     fContainerPermsInheritted,
                                                     fIsMapped ) ;
        }
        else
        {
            /* Regular old permission.  Check whether we are
             * looking at an NT system or a LM system.
             */
            UIASSERT( pbits2 == NULL ) ;

            if ( IsNT() )
            {
                *ppPerm = new ACCESS_PERMISSION( pSubj,
                                                 pbits1,
                                                 fContainerPermsInheritted,
                                                 QueryAccessMap()->IsPresent( pbits1 ) ) ;
            }
            else
            {
                *ppPerm = new LM_ACCESS_PERMISSION( pSubj,
                                                    pbits1,
                                                    !IsContainer() ) ;
            }
        }

    }
    else
    {
        *ppPerm = new AUDIT_PERMISSION( pSubj, pbits1, pbits2, fContainerPermsInheritted,
                                        QueryAuditMap()->IsPresent( pbits1 ) &&
                                        QueryAuditMap()->IsPresent( pbits2 ) ) ;
    }

    APIERR err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( ppPerm == NULL ||
         (err = (*ppPerm)->QueryError()) )
    {
        if ( ppPerm == NULL )
            delete pSubj ;
        else
            delete *ppPerm ;

        *ppPerm = NULL ;
    }

    return err ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo

    SYNOPSIS:   Gets a DC from the domain the current user is logged onto or
                /and the domain the user is currently logged onto

    ENTRY:      pnlsDC - String to receive the DC name (maybe NULL)
                pnlsDomain - String to receive the domain name (maybe NULL)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   10-Sep-1992     Created

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                                                       NLS_STR * pnlsDomain )
{
    APIERR err = NERR_Success ;
    err = ::QueryLoggedOnDomainInfo( pnlsDC,
                                     pnlsDomain,
                                     QueryWritePermHwnd() ) ;

#ifdef DEBUG
    if ( !err )
    {
        if ( pnlsDomain != NULL )
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo - User is logged onto " << pnlsDomain->QueryPch() ) ;

        if ( pnlsDC != NULL )
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo - User is logged onto "
                 << " DC " << pnlsDC->QueryPch() ) ;
    }
#endif  // DEBUG

    return err ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryInherittingResource

    SYNOPSIS:   Default implementation - Asserts out if not redefined.
                Only LM needs this since only LM has the concept of
                inheritting permissions.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR ACL_TO_PERM_CONVERTER::QueryInherittingResource(
                                             NLS_STR * pnlsInherittingResName )
{
    UNREFERENCED( pnlsInherittingResName ) ;
    UIASSERT(!SZ("Not Implemented!\n\r")) ;
    return ERROR_GEN_FAILURE ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryOwnerName

    SYNOPSIS:   The default implmentation returns NULL (indicating this
                object doesn't support an owner).

    HISTORY:    Johnl   16-Nov-1992     Created

********************************************************************/

const TCHAR * ACL_TO_PERM_CONVERTER::QueryOwnerName( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::LM_ACL_TO_PERM_CONVERTER

    SYNOPSIS:   Constructor for the LM acl converter

    ENTRY:      pchServer - What server this resource is on (NULL if local)
                pchResourceName - Name of resource suitable for passing
                    to NetAccess APIs
                paccessmap - Pointer to access perm. MAP_MASK object
                pauditmap  - Pointer to audit perm. MAP_MASK object

    EXIT:       If a construction error occurs, Report error will be called
                appropriately.

    NOTES:      If one of the MASK_MAPs are NULL, then no conversion
                will be performed on the corresponding ACE type (i.e.,
                if paccessmap is NULL, then no Access permission ACEs will
                be interpreted).  They will be stored internally so they
                can be written back out, but they won't be publicly
                available.


    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

LM_ACL_TO_PERM_CONVERTER::LM_ACL_TO_PERM_CONVERTER(
                          const TCHAR * pszServer,
                          const TCHAR * pchResourceName,
                          MASK_MAP    * paccessmap,
                          MASK_MAP    * pauditmap,
                          BOOL          fIsContainer,
                          PSED_FUNC_APPLY_SEC_CALLBACK pfuncCallback,
                          ULONG_PTR     ulCallbackContext,
                          BOOL          fIsBadIntersection )
    : ACL_TO_PERM_CONVERTER( pszServer, paccessmap, pauditmap, FALSE,
                             fIsContainer, FALSE ),
      _lmobjNetAccess1     ( pszServer, pchResourceName ),
     _pfuncCallback        ( pfuncCallback ),
     _ulCallbackContext    ( ulCallbackContext ),
     _fIsBadIntersection   ( fIsBadIntersection )
{
    if ( QueryError() != NERR_Success )
        return ;

    if ( _lmobjNetAccess1.QueryError() != NERR_Success )
    {
        ReportError( _lmobjNetAccess1.QueryError() ) ;
        return ;
    }

    /* There are no read only resources in LM, either you have access or you
     * don't.
     */
    SetReadOnlyFlag( FALSE ) ;
}

LM_ACL_TO_PERM_CONVERTER::~LM_ACL_TO_PERM_CONVERTER()
{
    _pfuncCallback = NULL;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERT::GetPermissions

    SYNOPSIS:   Fills in the passed ACCPERM object with the appropriate
                permission information

    ENTRY:      pAccperm - Pointer to the ACCPERM that will receive the
                    permissions.
                fAccessPerms - TRUE if the Access permissions should be
                    retrieved, FALSE if Audit permissions should be retrieved

    EXIT:

    RETURNS:

    NOTES:      If the resource is inheritting its ACL, then we get the
                inheritting permissions *automatically*, the only overhead
                that might be avoidable is the work of converting the
                ACL to an ACCPERM (should be very small when compared to
                the network calls).  If performance is a problem, we may
                want to consider changing this.

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::GetPermissions( ACCPERM * pAccperm,
                                                 BOOL      fAccessPerms )
{
    UNREFERENCED( fAccessPerms ) ;
    UIDEBUG( SZ("LM_ACL_TO_PERM_CONVERTER::GetPermissions\n\r")) ;
    UIASSERT( pAccperm != NULL ) ;

    APIERR err ;

    err = _lmobjNetAccess1.GetInfo() ;
    BOOL fInherittingPermissions = FALSE ;
    if ( err != NERR_Success )
    {
        UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::GetPermissions - Failed on GetInfo - resource:\n\r")) ;
        UIDEBUG( _lmobjNetAccess1.QueryName() ) ;
        UIDEBUG(SZ("\n\r")) ;

        switch ( err )
        {
        case NERR_ResourceNotFound:
            {
                //
                //  Audits never inherit from the parent dir but we
                //  still need to pick up the access permissions that
                //  me be inherited
                //

                /* No ACL was found on this resource, so try and find
                 * the resource we are inheritting from (if any).
                 */
                err = FindInherittingResource() ;
                switch ( err )
                {
                case NERR_ResourceNotFound:
                    //
                    //  We just show a blank dialog if this is a bad
                    //  intersection
                    //
                    if ( _fIsBadIntersection )
                        break ;

                    return IERR_ACLCONV_LM_NO_ACL ;

                case NERR_Success:
                    fInherittingPermissions = TRUE ;
                    break ;

                default:
                    return err ;
                }
            }
            break ;

        case ERROR_NOT_SUPPORTED:
            return IERR_ACLCONV_CANT_EDIT_PERM_ON_LM_SHARE_LEVEL;

        default:
            return err ;
        }

    }

    //
    //  If we have a bad intersection, then wipe the slate clean and start
    //  with a blank permission set.
    //
    if ( _fIsBadIntersection || err == NERR_ResourceNotFound )
    {
        fInherittingPermissions = FALSE ;
        if ( err = _lmobjNetAccess1.CreateNew() )
            return err ;
    }

    /* Fill in the auditting permissions
     *
     *  For LM, the auditting permissions don't apply to a subject, only to
     *  the resource, so a dummy LM_SUBJECT is created.
     *
     *  Note that there will only ever be one audit permission created for
     *  LM auditting.
     */
    {
        /* Map AA_AUDIT_ALL to AA_S_ALL (i.e., implicit all to explicit all).
         */
        //
        //  If the access permissions are inherited, then there weren't any
        //  audits set on the resource.
        //
        USHORT usSuccessAuditFlags = 0;
        if ( !fInherittingPermissions )
        {
            usSuccessAuditFlags =
                             _lmobjNetAccess1.QueryAuditFlags() & AA_AUDIT_ALL ?
                             AA_S_ALL :
                             _lmobjNetAccess1.QueryAuditFlags() & AA_S_ALL ;
        }

        BITFIELD bitSuccess( usSuccessAuditFlags  ) ;
        if ( bitSuccess.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        USHORT usFailAuditFlags = 0 ;
        if ( !fInherittingPermissions )
        {
            usFailAuditFlags= _lmobjNetAccess1.QueryAuditFlags() & AA_AUDIT_ALL ?
                             AA_F_ALL :
                             _lmobjNetAccess1.QueryAuditFlags() & AA_F_ALL ;
        }

        BITFIELD bitFailure( FailToSuccessAuditFlags( usFailAuditFlags ) ) ;

        if ( bitFailure.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( NULL, FALSE ) ;
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        AUDIT_PERMISSION * pPermAudit ;
        err = BuildPermission( (PERMISSION **)&pPermAudit,
                               FALSE,   // Audit permission
                               pSubj,   // No subject name
                               &bitSuccess,
                               &bitFailure ) ;
        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAudit )) != NERR_Success )
        {
            delete pPermAudit ;
            return err ;
        }
    }

    /* Get the access permissions
     */
    for ( int i = 0 ; i < (int)_lmobjNetAccess1.QueryACECount() ; i++ )
    {
        access_list * paccess_list = _lmobjNetAccess1.QueryACE( i ) ;
        UIASSERT( paccess_list != NULL ) ;

        /* We have to mask out the group bit from the access permissions.
         */
        BITFIELD bitAccessPerm((USHORT)(paccess_list->acl_access & ACCESS_ALL));
        if ( bitAccessPerm.QueryError() != NERR_Success )
            return bitAccessPerm.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( paccess_list->acl_ugname,
                                       paccess_list->acl_access & ACCESS_GROUP);
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        ACCESS_PERMISSION * pPermAccess ;
        err = BuildPermission( (PERMISSION **) &pPermAccess,
                               TRUE,    // Access permission
                               pSubj,
                               &bitAccessPerm,
                               NULL ) ;

        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAccess )) != NERR_Success )
        {
            delete pPermAccess ;
            return err ;
        }
    }

    if ( ( err == NERR_Success ) && ( fInherittingPermissions ) )
        return IERR_ACLCONV_LM_INHERITING_PERMS ;

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::GetBlankPermissions

    SYNOPSIS:   Initializes the ACCPERM object with the "default"
                blank permission

    ENTRY:      pAccperm - Pointer to accperm object

    EXIT:       The Access permission list will be empty, and the audit
                permission list will contain a single audit permission
                with no bits enabled.

    RETURNS:    NERR_Success or some standard error code.

    NOTES:

    HISTORY:
        Johnl   Aug-21-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::GetBlankPermissions( ACCPERM * pAccperm )
{
    pAccperm->QueryAccessPermissionList()->Clear() ;
    pAccperm->QueryAuditPermissionList()->Clear() ;

    /* Fill in the auditting permissions
     *
     *  Note that there will only ever be one audit permission created for
     *  LM auditting.
     */
    {
        BITFIELD bitSuccess( (USHORT) 0 ) ;
        if ( bitSuccess.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        BITFIELD bitFailure( (USHORT) 0 ) ;
        if ( bitFailure.QueryError() != NERR_Success )
            return bitSuccess.QueryError() ;

        SUBJECT * pSubj = new LM_SUBJECT( NULL, FALSE ) ;
        if ( pSubj == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( pSubj->QueryError() != NERR_Success )
        {
            APIERR err = pSubj->QueryError() ;
            delete pSubj ;
            return err ;
        }

        /* Build permission will delete the subject if it fails
         */
        AUDIT_PERMISSION * pPermAudit ;
        APIERR err = BuildPermission( (PERMISSION **)&pPermAudit,
                                      FALSE,   // Audit permission
                                      pSubj,   // No subject name
                                      &bitSuccess,
                                      &bitFailure ) ;
        if ( err != NERR_Success )
            return err ;

        if ( (err = pAccperm->AddPermission( pPermAudit )) != NERR_Success )
        {
            delete pPermAudit ;
            return err ;
        }
    }

    /* We have to validate the net access object because we may not have
     * called GetInfo on it.  This also empties it of all permissions.
     */
    APIERR err = _lmobjNetAccess1.CreateNew() ;
    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::WritePermissions

    SYNOPSIS:   Apply the permissions to the requested resources

    ENTRY:      accperm - List of permissions (audit & access) to be
                        applied to the designated resource
                fApplyToSubContainers - TRUE if subdirs should have perms set
                fApplyToSubObjects - TRUE if files should have perms set
                applyflags - specifies whether Audit/Access/Both permissions
                        should be set.
                pfReportError - Indicates if the caller should notify the
                        user in case of error

    EXIT:

    RETURNS:

    NOTES:      accperm can't be const because the Enum* methods can't be
                const.

    HISTORY:
        Johnl   29-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::WritePermissions(
                         ACCPERM &        accperm,
                         BOOL             fApplyToSubContainers,
                         BOOL             fApplyToSubObjects,
                         TREE_APPLY_FLAGS applyflags,
                         BOOL            *pfReportError )
{
    UIASSERT( sizeof( short ) == sizeof( USHORT ) ) ;
    UNREFERENCED( applyflags ) ;

    *pfReportError = TRUE ;
    _lmobjNetAccess1.ClearPerms() ;

    /* Set the audit flags
     */
    BOOL fFromBeginning = TRUE ;
    AUDIT_PERMISSION *pAuditPerm ;

    /* If there is no audit permission for this ACL, then we will assume
     * that means no auditting on this resource.
     */
    short sAuditFlags = 0 ;
    if ( accperm.EnumAuditPermissions( &pAuditPerm, & fFromBeginning ) )
    {
        sAuditFlags = (USHORT) *pAuditPerm->QuerySuccessAuditBits() ;

        sAuditFlags |= SuccessToFailAuditFlags(
                                    (USHORT)*pAuditPerm->QueryFailAuditBits()) ;

        /* There should only be one Audit record in the accperm
         */
        UIASSERT( !accperm.EnumAuditPermissions( &pAuditPerm,
                                                 &fFromBeginning ) ) ;
    }

    APIERR err = _lmobjNetAccess1.SetAuditFlags( sAuditFlags ) ;
    if ( err != NERR_Success )
        return err ;

    /* Iterate through the permissions and set them appropriately
     */
    fFromBeginning = TRUE ;
    ACCESS_PERMISSION *pAccessPerm ;
    while ( accperm.EnumAccessPermissions( &pAccessPerm, &fFromBeginning ) )
    {
        UIASSERT( pAccessPerm->QuerySubject()->IsGroup() ||
                  pAccessPerm->QuerySubject()->IsUser()    ) ;

        short sAccessMask = (USHORT) *pAccessPerm->QueryAccessBits() ;
        err = _lmobjNetAccess1.SetPerm(
                                   pAccessPerm->QuerySubject()->QueryDisplayName(),
                                   (pAccessPerm->QuerySubject()->IsGroup() ?
                                            PERMNAME_GROUP :
                                            PERMNAME_USER),
                                   sAccessMask ) ;
        if ( err != NERR_Success )
            return err ;
    }

    DWORD dwReturnStatus; // just a dummy
    if ( !err &&  _pfuncCallback != NULL )
    {
        //
        //  Sorta hack, hack
        //
        if ( _ulCallbackContext )
        {
            LM_CALLBACK_INFO *pLMCtxt = (LM_CALLBACK_INFO *) _ulCallbackContext ;
            pLMCtxt->plmobjNetAccess1 = &_lmobjNetAccess1 ;
        }

        if ( err = _pfuncCallback( QueryWritePermHwnd(),
                                   NULL,
                                   _ulCallbackContext,
                                   NULL,
                                   NULL,
                                   (BOOLEAN)fApplyToSubContainers,
                                   (BOOLEAN)fApplyToSubObjects,
                                   &dwReturnStatus ) )
        {
            *pfReportError = FALSE ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::FindInherittingResource

    SYNOPSIS:   Finds what resource, if any, the current resource is
                inheritting its permissions from.

    ENTRY:      pnlsInherittingResName - Pointer to string that will
                contain the resource name the permissions are being
                inheritted from

                The data member _lmobjNetAccess1 should be pointing to
                the resource we are interested in.

    RETURNS:    NERR_ResourceNotFound if there are no inheritting resources.

    NOTES:      Assumes the resident NET_ACCESS_1 object already contains
                a valid resource (that doesn't have an ACL on it).

                Currently, we are assuming the resource is a drive path.

                The _lmobjNetAccess1 member will be restored to its
                original value before exitting (i.e., resource name).

                We check the parent directory, then the drive permissions.

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::FindInherittingResource( void )
{
    UIASSERT( _lmobjNetAccess1.QueryError() == NERR_Success ) ;

    NLS_STR nlsResName = _lmobjNetAccess1.QueryName() ;
    NLS_STR nlsResNameSave = nlsResName ;

    APIERR err ;
    if ( (err = nlsResName.QueryError() ) != NERR_Success ||
         (err = nlsResNameSave.QueryError() ) != NERR_Success )
    {
        return err ;
    }

    ISTR istrResName( nlsResName ) ;

    BOOL fDone  = FALSE ;
    BOOL fCheckParentDir = TRUE ;
    while ( !fDone )
    {
        if ( fCheckParentDir )
        {
            /* Check the parent directory by removing the last component
             */
            if ( nlsResName.strrchr( &istrResName, TCH('\\') ) )
            {
                /* Found a '\\', truncate the
                 * string starting with the found '\\'
                 */
                nlsResName.DelSubStr( istrResName ) ;
            }
            else
            {
                /* We were passed an "X:" which we aren't ever expecting
                 */
                UIASSERT(FALSE) ;
            }
            fCheckParentDir = FALSE ;
        }
        else
        {
            /* Truncate everything after the ':' and check the drive
             * permissions
             */
            ISTR istrColon( nlsResName ) ;
            REQUIRE( nlsResName.strchr( &istrColon, TCH(':') ) ) ;
            nlsResName.DelSubStr( ++istrColon ) ;
            fDone = TRUE ;
        }

        /* We now have a candidate for resources to be inheritted from,
         * attempt to get the ACL and watch for any errors.
         */

        err = _lmobjNetAccess1.SetName( nlsResName ) ;
        if ( err != NERR_Success )
        {
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            break ;
        }

        err = _lmobjNetAccess1.GetInfo() ;
        switch ( err )
        {
        case NERR_Success:
            _nlsInherittingResName = nlsResName ;
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::FindInherittingResource - Found inheritting resource\n\r")) ;
            return _nlsInherittingResName.QueryError() ;

        case NERR_ResourceNotFound:     // No ACL on this resource
            if ( fDone )
            {
                REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave )
                                                             == NERR_Success ) ;
                UIDEBUG(SZ("LM_ACL_TO_PERM_CONVERTER::FindInherittingResource - No resource to inherit from\n\r")) ;
                return err ;
            }
            break ;

        default:
            REQUIRE( _lmobjNetAccess1.SetName( nlsResNameSave ) ==NERR_Success);
            return err ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::QueryInherittingResource

    SYNOPSIS:   Simple access method to saved inheritting resource name

    ENTRY:      pnlsInherittingResName

    RETURNS:    Error code of copy

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::QueryInherittingResource(
                                              NLS_STR * pnlsInherittingResName )
{
    *pnlsInherittingResName = _nlsInherittingResName ;
    return pnlsInherittingResName->QueryError() ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::QueryFailingSubject

    SYNOPSIS:   Returns the first User/Group that is currently in the
                ACL but is no longer in the UAS of the server.

    ENTRY:      pnlsSubjUniqueName - Pointer to NLS_STR that will receive the
                    subject.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This should be called immediately after WritePermissions and
                only if WritePermissions returned NERR_UserNotFound.

    HISTORY:
        Johnl   24-Oct-1991     Created

********************************************************************/

APIERR LM_ACL_TO_PERM_CONVERTER::QueryFailingSubject(
                                                  NLS_STR * pnlsSubjUniqueName )
{
    enum PERMNAME_TYPE nametype ;
    return _lmobjNetAccess1.QueryFailingName( pnlsSubjUniqueName, &nametype ) ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::FailToSuccessAuditFlags

    SYNOPSIS:   Maps the failed audit bits to the success audit bits.
                This is necessary because the failed audit bits in the
                acl editor or represented by the success audit bits (i.e.,
                both success and fail use the same mask map).

    ENTRY:      usFailAuditMask - Mask of failed audit bits

    RETURNS:    A mask of success audit bits that correspond to the
                failed audit bits

    NOTES:      The Write and Create audit mask have the same value, so we
                will assert they are the same and use one of them.

    HISTORY:
        Johnl   01-Oct-1991     Created

********************************************************************/

USHORT LM_ACL_TO_PERM_CONVERTER::FailToSuccessAuditFlags(USHORT usFailAuditMask)
{
    UIASSERT( AA_F_WRITE == AA_F_CREATE ) ;

    USHORT usSuccessMask = 0 ;

    usSuccessMask |= (usFailAuditMask & AA_F_OPEN   ? AA_S_OPEN : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_WRITE  ? AA_S_WRITE : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_DELETE ? AA_S_DELETE : 0 ) ;
    usSuccessMask |= (usFailAuditMask & AA_F_ACL    ? AA_S_ACL : 0 ) ;

    return usSuccessMask ;
}

/*******************************************************************

    NAME:       LM_ACL_TO_PERM_CONVERTER::SuccessFailAuditFlags

    SYNOPSIS:   Same as FailToSuccessAuditFlags only in reverse.

    NOTES:

    HISTORY:
        Johnl   01-Oct-1991     Created

********************************************************************/

USHORT LM_ACL_TO_PERM_CONVERTER::SuccessToFailAuditFlags(
                                                     USHORT usSuccessAuditMask )
{
    UIASSERT( AA_S_WRITE == AA_S_CREATE ) ;

    USHORT usFailedMask = 0 ;

    usFailedMask |= (usSuccessAuditMask & AA_S_OPEN   ? AA_F_OPEN : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_WRITE  ? AA_F_WRITE : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_DELETE ? AA_F_DELETE : 0 ) ;
    usFailedMask |= (usSuccessAuditMask & AA_S_ACL    ? AA_F_ACL : 0 ) ;

    return usFailedMask ;
}

/*******************************************************************

    NAME:       LM_CANCEL_TREE_APPLY::WriteSecurity

    SYNOPSIS:   Writes permission/audit info to a LM server

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Note that we have to check for existing info since LM doesn't
                support setting audit and permissions separately.

    HISTORY:
        Johnl   24-Oct-1992     Created

********************************************************************/

APIERR LM_CANCEL_TREE_APPLY::WriteSecurity( ULONG_PTR     ulContext,
                                            const TCHAR * pszFileName,
                                            BOOL          fIsFile,
                                            BOOL        * pfContinue  )
{
    LM_TREE_APPLY_CONTEXT * pCtxt = (LM_TREE_APPLY_CONTEXT*) ulContext ;
    APIERR err ;
    *pfContinue = TRUE ;

    NET_ACCESS_1 lmobjNewRes( pCtxt->plmobjNetAccess1->QueryServerName(),
                              pszFileName ) ;

    if ( !(err = lmobjNewRes.QueryError() ) )
    {
        BOOL fWriteNew = TRUE ;
        BOOL fWillInheritFromParent = FALSE ;

        switch ( err = lmobjNewRes.GetInfo() )
        {
        case NERR_Success:
            fWriteNew = FALSE ;
            // Fall through

        case NERR_ResourceNotFound:
            if ( err )
            {
                if ( (err = lmobjNewRes.CreateNew()) ||
                     (err = lmobjNewRes.SetAuditFlags( 0 )) )
                {
                    break ;
                }
            }
            err = NERR_Success ;

            /* If we are dealing with permissions (not auditting)
             *     and we are in tree apply mode (thus the parent dir will
             *         have the permission and this file will inherit from it)
             *     and the resource is a file
             *     and nothing is auditted
             * then set the flag indicating the ACL should be deleted
             * from the resource
             */
            if ( (pCtxt->fApplyToSubContainers ||
                  pCtxt->fApplyToDirContents     ) &&
                 pCtxt->sedpermtype != SED_AUDITS  &&
                 fIsFile                           &&
                 !pCtxt->plmobjNetAccess1->QueryAuditFlags())
            {
                fWillInheritFromParent = TRUE ;
                break ;
            }

            if ( pCtxt->sedpermtype == SED_AUDITS )
            {
                err = lmobjNewRes.SetAuditFlags(
                                   (short)pCtxt->plmobjNetAccess1->QueryAuditFlags() ) ;
            }
            else
            {
                UIASSERT( pCtxt->sedpermtype == SED_ACCESSES ) ;
                err = lmobjNewRes.CopyAccessPerms( *pCtxt->plmobjNetAccess1 ) ;
            }
            break ;

        default:
            break ;
        }


        if ( !err )
        {
            if ( fWillInheritFromParent )
            {
                /* Only delete the ACL if an ACL exists on the file
                 */
                if ( !fWriteNew )
                    err = lmobjNewRes.Delete() ;
            }
            else if ( fWriteNew )
                err = lmobjNewRes.WriteNew() ;
            else
                err = lmobjNewRes.Write() ;
        }
    }

    return err ;
}




/*******************************************************************

    NAME:       QueryLoggedOnDomainInfo

    SYNOPSIS:   Gets a DC from the domain the current user is logged onto or
                /and the domain the user is currently logged onto

    ENTRY:      pnlsDC - String to receive the DC name (may be NULL)
                pnlsDomain - String to receive the domain name (may be NULL)
                hwnd - Window handle to use for reporting non-fatal errors

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the workstation is not started or the user is logged on
                locally, then *pnlsDC will be set to the empty string.

    HISTORY:
        Johnl   10-Sep-1992     Created

********************************************************************/

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                                NLS_STR * pnlsDomain,
                                HWND      hwnd )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsLoggedOnDomain( DNLEN+1 ) ;
    NLS_STR nlsLoggedOnDC( RMLEN+1 ) ;      // Default to the empty string

    do { // error break out
        TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH+1] ;
        DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH;
        WKSTA_10 wksta10( NULL ) ;

        // get the computer name
        if ( !::GetComputerName( achComputerName, &cchComputerName ))
        {
            err = ::GetLastError() ;
            DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
                   "error getting the computer name, error " << err ) ;
            break ;
        }

        //
        // get the logon domain info from a WKSTA object
        //
        if ( (err = wksta10.QueryError()) ||
             (err = nlsLoggedOnDomain.QueryError()) ||
             (err = nlsLoggedOnDC.QueryError())     ||
             (err = wksta10.GetInfo())    ||
             (err = nlsLoggedOnDomain.CopyFrom( wksta10.QueryLogonDomain())) )
        {
            //
            //   If the network isn't started, then we have to be logged on
            //   locally.
            //

            if ( (err == ERROR_NO_NETWORK) ||
                 (err == NERR_WkstaNotStarted) )
            {
                err = NERR_Success ;
            }
            else
            {
                break ;
            }

            ALIAS_STR nlsComputer( achComputerName ) ;
            if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) )
            {
                ;
            }

            /* Don't need to continue. The wksta is not started, so we
             * use logged on domain==localmachine and empty string for the
             * DC name.
             */
            break ;
        }

        /* Check if the logged on domain is the same as the computer
         * name.  If it is, then the user is logged on locally.
         */
        if ( !::I_MNetComputerNameCompare( achComputerName,
                                           wksta10.QueryLogonDomain()))
        {
            TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
                     " user is logged on locally") ;
            ALIAS_STR nlsComputer( achComputerName ) ;
            if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )))
            {
                break ;
            }

            /* Don't need to continue since the logged on domain is
             * the local machine.
             */
            break ;
        }

        //
        //   If not interested in a DC, then don't get one
        //
        if ( pnlsDC == NULL )
            break ;

        DOMAIN_WITH_DC_CACHE domLoggedOn( wksta10.QueryLogonDomain(),
                                          TRUE ) ;
        TRACEEOL("::QueryLoggedOnDomainInfo - About to get logged on DC @ " << ::GetTickCount() / 100) ;
        if ( (err = domLoggedOn.GetInfo()) ||
             (err = nlsLoggedOnDC.CopyFrom( domLoggedOn.QueryAnyDC())) )
        {
            DBGEOL("::QueryLoggedOnDomainInfo, " <<
                   " error " << err << " on domain get info for " <<
                   wksta10.QueryLogonDomain() ) ;

            //
            //  There are some errors which we will just warn the user
            //  but allow them to continue though the "focused" dc will
            //  switch to the local machine.
            //
            if ( err == NERR_DCNotFound )
            {
                RESOURCE_STR nlsError( err ) ;
                if ( nlsError.QueryError() )
                {
                    DEC_STR numStr( err ) ;
                    if ( (err = numStr.QueryError()) ||
                         (err = nlsError.CopyFrom( numStr )) )
                    {
                        break ;
                    }
                }

                ::MsgPopup( hwnd,
                            IDS_CANT_FOCUS_ON_LOGGED_ON_DOMAIN,
                            MPSEV_WARNING,
                            MP_OK,
                            wksta10.QueryLogonDomain(),
                            nlsError ) ;

                err = NERR_Success ;
                //
                // Leave nlsLoggedOnDC empty for the local machine
                //
            }
            else
            {
                break ;
            }
        }
        TRACEEOL("::QueryLoggedOnDomainInfo - Done getting logged on DC @ " << ::GetTickCount() / 100) ;
    } while (FALSE) ;


    if ( !err )
    {
        if ( pnlsDC != NULL )
            err = pnlsDC->CopyFrom( nlsLoggedOnDC ) ;

        if ( !err && pnlsDomain != NULL )
            err = pnlsDomain->CopyFrom( nlsLoggedOnDomain ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\ntaclcon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    NTACLCon.cxx

    This file contains the NT NT_ACL_TO_PERM_CONVERTER code.



    FILE HISTORY:
        Johnl   27-Sep-1991     Created

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#include <lmui.hxx>
#include <base.hxx>
#include <maskmap.hxx>
#include <lmoacces.hxx>
#include <errmap.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <strlst.hxx>

#define  INCL_BLT_CONTROL
#define  INCL_BLT_DIALOG
#include <blt.hxx>

extern "C"
{
    #include <lmaudit.h>
}

#include <fsenum.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>
#include <ipermapi.hxx>
#include <permstr.hxx>

#include <security.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntfsacl.hxx>
#include <ntacutil.hxx>

#include <dbgstr.hxx>


/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::NT_ACL_TO_PERM_CONVERTER

    SYNOPSIS:   Constructor for the NT acl converter

    ENTRY:      pchServer - What server this resource is on (NULL if local)
                pchResourceName - Name of resource suitable for passing
                    to NetAccess APIs
                paccessmap - Pointer to access perm. MAP_MASK object
                paccessmapNewObject - Pointer to new object access perm
                                      MAP_MASK object
                pauditmap  - Pointer to audit perm. MAP_MASK object

    NOTES:

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

NT_ACL_TO_PERM_CONVERTER::NT_ACL_TO_PERM_CONVERTER(
                          const TCHAR * pszServer,
                          const TCHAR * pchResourceName,
                          MASK_MAP    * paccessmap,
                          MASK_MAP    * paccessmapNewObject,
                          MASK_MAP    * pauditmap,
                          BOOL          fIsContainer,
                          BOOL          fIsNewObjectsSupported,
                          PSECURITY_DESCRIPTOR psecdesc,
                          PGENERIC_MAPPING pGenericMapping,
                          PGENERIC_MAPPING pGenericMappingNewObjects,
                          BOOL          fMapSpecificToGeneric,
                          BOOL          fCantReadACL,
                          BOOL          fCantWriteACL,
                          PSED_FUNC_APPLY_SEC_CALLBACK pfuncCallback,
                          ULONG_PTR     ulCallbackContext,
                          HANDLE        hInstance,
                          LPDWORD       lpdwReturnStatus,
                          BOOL          fShowMnemonics    )
    : ACL_TO_PERM_CONVERTER( pszServer,
                             paccessmap,
                             pauditmap,
                             TRUE,
                             fIsContainer,
                             fIsNewObjectsSupported,
                             fShowMnemonics ),
      _pmaskmapNewObject     ( paccessmapNewObject ),
      _psecuritydesc         ( psecdesc ),
      _fCantReadACL          ( fCantReadACL ),
      _pfuncCallback         ( pfuncCallback ),
      _ulCallbackContext     ( ulCallbackContext ),
      _pGenericMapping       ( pGenericMapping ),
      _pGenericMappingNewObjects( pGenericMappingNewObjects ),
      _fMapSpecificToGeneric ( fMapSpecificToGeneric ),
      _hInstance             ( hInstance ),
      _lpdwReturnStatus      ( lpdwReturnStatus ),
      _possecdescNewItemPerms( NULL ),
      _nlsOwner              ()
{
    if ( QueryError() != NERR_Success )
        return ;

    UNREFERENCED( pchResourceName ) ;

    if ( pfuncCallback == NULL )
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERT::ct - NULL callback") ;
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    if ( _nlsOwner.QueryError() )
    {
        ReportError( _nlsOwner.QueryError() ) ;
        return ;
    }

    SetReadOnlyFlag( fCantWriteACL ) ;
}

NT_ACL_TO_PERM_CONVERTER::~NT_ACL_TO_PERM_CONVERTER()
{
    _pmaskmapNewObject = NULL ;
    _psecuritydesc = NULL ;
    _pfuncCallback = NULL ;

    delete _possecdescNewItemPerms ;
    _possecdescNewItemPerms = NULL ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap

    SYNOPSIS:   Returns the new object maskmap

    NOTES:

    HISTORY:
        Johnl   27-Sep-1991     Created

********************************************************************/

MASK_MAP * NT_ACL_TO_PERM_CONVERTER::QueryNewObjectAccessMap( void ) const
{
    return _pmaskmapNewObject ;
}

/*******************************************************************

    NAME:       ACL_TO_PERM_CONVERTER::QueryOwnerName

    SYNOPSIS:   Returns the owner of this security descriptor

    RETURNS:    Pointer to the owner

    NOTES:      _nlsOwner is initialized in SidsToNames

    HISTORY:
        Johnl   16-Nov-1992     Created

********************************************************************/

const TCHAR * NT_ACL_TO_PERM_CONVERTER::QueryOwnerName( void ) const
{
    return _nlsOwner.QueryPch() ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::GetPermissions

    SYNOPSIS:   Fills in the passed ACCPERM object with the appropriate
                permission information

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   14-Aug-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::GetPermissions( ACCPERM * pAccperm,
                                                 BOOL      fAccessPerm )
{
    if ( IsNonReadable() )
    {
        //
        //  If we are editing Audit info and we couldn't read it, then we
        //  can't write it (it is privilege based).
        //
        return  fAccessPerm ?
                    IERR_ACLCONV_CANT_VIEW_CAN_EDIT :
                    ERROR_PRIVILEGE_NOT_HELD ;
    }

    APIERR err = SecurityDesc2Accperm( _psecuritydesc, pAccperm, fAccessPerm );

    BOOL fRecognizedAcl = TRUE ;
    if ( err == IERR_UNRECOGNIZED_ACL )
    {
        /* If it's unrecognized, find out if the user can write it before
         * returning an error
         */
        err = NERR_Success ;
        fRecognizedAcl = FALSE ;
    }

    if ( !err )
    {
        if ( IsReadOnly() )
        {
            err = fRecognizedAcl ? IERR_ACLCONV_READ_ONLY :
                                   IERR_ACLCONV_NONST_ACL_CANT_EDIT ;
        }
        else
        {
            err = fRecognizedAcl ? NERR_Success :
                                   IERR_ACLCONV_NONST_ACL_CAN_EDIT ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::GetBlankPermissions

    SYNOPSIS:   Initializes the ACCPERM object with the "default"
                blank permission

    ENTRY:      pAccperm - Pointer to accperm object

    EXIT:       The accperm will contain the default empty permission set

    RETURNS:    NERR_Success or some standard error code.

    NOTES:

    HISTORY:
        Johnl   Aug-21-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::GetBlankPermissions( ACCPERM * pAccperm )
{
    pAccperm->QueryAccessPermissionList()->Clear() ;
    pAccperm->QueryAuditPermissionList()->Clear() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::WritePermissions

    SYNOPSIS:   Apply the permissions to the requested resources

    ENTRY:      accperm - List of permissions (audit & access) to be
                        applied to the designated resource

    EXIT:

    RETURNS:

    NOTES:      accperm can't be const because the Enum* methods can't be
                const.

    HISTORY:
        Johnl   29-Aug-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::WritePermissions(
                         ACCPERM & accperm,
                         BOOL  fApplyToSubContainers,
                         BOOL  fApplyToSubObjects,
                         enum  TREE_APPLY_FLAGS applyflags,
                         BOOL *pfReportError )
{
    APIERR err ;
    OS_SECURITY_DESCRIPTOR ossecdescNew ;
    OS_ACL osaclSaclOrDaclTemp ;

    *pfReportError = TRUE ;
    if ( ( err = ossecdescNew.QueryError() ) ||
         ( err = osaclSaclOrDaclTemp.QueryError()  ))
    {
        return err ;
    }

    /* Check which type of security we are applying and set the appropriate
     * ACL (the ACL is copied so we don't care about it anymore)
     */
    switch ( applyflags )
    {
    case TREEAPPLY_ACCESS_PERMS:
        err = ossecdescNew.SetDACL( TRUE, &osaclSaclOrDaclTemp ) ;
        break ;
    case TREEAPPLY_AUDIT_PERMS:
        err = ossecdescNew.SetSACL( TRUE, &osaclSaclOrDaclTemp ) ;
        break ;
    default:
        UIASSERT(FALSE) ;
        err = ERROR_INVALID_PARAMETER ;
        break ;
    }

    if ( (err ) ||
         (err = Accperm2SecurityDesc( &accperm,
                                &ossecdescNew,
                                applyflags == TREEAPPLY_ACCESS_PERMS )) )
    {
        return err ;
    }

    /* Only build the new object security descriptor if necessary
     */
    if ( IsContainer() &&
         (err = BuildNewObjectPerms( ossecdescNew )) )
    {
        return err ;
    }

    PSECURITY_DESCRIPTOR psecdescNew = (PSECURITY_DESCRIPTOR) ossecdescNew ;

#ifdef TRACE
    DBGEOL(SZ("WritePermissions calling callback with the following security descriptor:"));
    ossecdescNew.DbgPrint() ;

    if ( fApplyToSubObjects )
    {
        DBGEOL(SZ("WritePermissions calling callback with the following New Item security descriptor:"));
        QueryNewObjectPerms()->DbgPrint() ;
    }
#endif

    /* Any errors returned by the callback should have been reported by the
     * callback.  So ignore the error return.
     */
    if ( err = _pfuncCallback( QueryWritePermHwnd(),
                          _hInstance,
                          _ulCallbackContext,
                          psecdescNew,
                          IsContainer() ?
                                QueryNewObjectPerms()->QueryDescriptor() :
                                NULL,
                          (BOOLEAN)fApplyToSubContainers,
                          (BOOLEAN)fApplyToSubObjects,
                          _lpdwReturnStatus ) )
    {
        TRACEEOL("WritePermissions - Callback returned error code " << (ULONG) err ) ;
        *pfReportError = FALSE ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::QueryFailingSubject

    SYNOPSIS:   Returns the first User/Group that is currently in the
                ACL but is no longer in the UAS of the server.

    ENTRY:      pnlsSubjUniqueName - Pointer to NLS_STR that will receive the
                    subject.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This should be called immediately after WritePermissions and
                only if WritePermissions returned NERR_UserNotFound.

    HISTORY:
        Johnl   24-Oct-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::QueryFailingSubject( NLS_STR * pnlsSubjUniqueName )
{
    UIASSERT(!SZ("Not implemented")) ;
    UNREFERENCED( pnlsSubjUniqueName ) ;
    //enum PERMNAME_TYPE nametype ;
    //return _accperm.QueryFailingName( pnlsSubjUniqueName, &nametype ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm

    SYNOPSIS:   Converts a security descriptor to an ACCPERM object

    ENTRY:      psecdesc - Pointer to security descriptor to convert
                pAccperm - Pointer to accperm to receive the security
                    descriptor's information
                fAccessPerm - TRUE if the Access permissions should be
                    retrieved, FALSE if the Audit permissions should be
                    retrieved.

    EXIT:       The Accperm will contain the information stored in the
                security descriptor

    RETURNS:    NERR_Success if successful, error code otherwise including
                the IERR_ACLCONV_* manifests.

    NOTES:      psecdesc can be NULL (gives World full access if DACL).

                The Passed Accperm should be empty.

    HISTORY:
        Johnl   20-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm(
                                     const PSECURITY_DESCRIPTOR psecdesc,
                                           ACCPERM *            pAccperm,
                                           BOOL                 fAccessPerm )
{
    TRACEEOL( SZ("NT_ACL_TO_PERM_CONVERTER::SecurityDesc2Accperm - Entered") ) ;
    APIERR err = NERR_Success ;

    if ( psecdesc == NULL )
    {
        DBGEOL(SZ("SecurityDesc2Accperm - Warning, Passed NULL security descriptor")) ;
    }

    OS_SECURITY_DESCRIPTOR ossecdesc( psecdesc ) ;
    if ( ossecdesc.QueryError() )
        return ossecdesc.QueryError() ;

    if ( fAccessPerm )
    {
        OS_ACL * posaclDACL = NULL ;
        BOOL     fDACLPresent ;
        if ( (err = ossecdesc.QueryDACL( &fDACLPresent,
                                         &posaclDACL )) )
        {
            return err ;
        }

        /* If the user is editting the DACL and it isn't present, then
         * it means "World" Full access.
         */
        if ( !fDACLPresent || ( fDACLPresent && (posaclDACL == NULL)) )
        {
            ACCESS_PERMISSION * pPermAccess = NULL ;
            OS_SID ossidWorld( NULL ) ;
            if ((err = ossidWorld.QueryError()) ||
                (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
                                                            &ossidWorld )) ||
                (err = CreateNewPermission( (PERMISSION **) &pPermAccess,
                                            TRUE,
                                            (PSID) ossidWorld,
                                            GENERIC_ALL,
                                            FALSE,
                                            0,
                                            FALSE ))
                || (err = pAccperm->AddPermission( pPermAccess )))
            {
                DBGEOL("SecurityDesc2Accperm - Build permission or QuerySystemSid Failed, error code "
                        << (ULONG) err ) ;

                /* CreateNewPermission will set this to NULL if it fails
                 */
                delete pPermAccess ;
                return err ;
            }

        }
        else
        {
            UIASSERT( fDACLPresent && posaclDACL != NULL ) ;

            OS_DACL_SUBJECT_ITER subjiterDacl( posaclDACL,
                                               _pGenericMapping,
                                               _pGenericMappingNewObjects,
                                               !_fMapSpecificToGeneric,
                                               pAccperm->IsContainer() ) ;
            if ( subjiterDacl.QueryError() )
                return subjiterDacl.QueryError() ;

            /* Loop through each SID and create a subject and permission
             * as appropriate.
             */
            while ( subjiterDacl.Next( &err ) )
            {
                /* Check for some of the permission combinations that we
                 * don't handle
                 */
                /* If the permission is a Deny all permission, then the access
                 * mask should be all zeros.  This is important because an all
                 * zero bitfield indicates a deny all permissions in the permission
                 * scheme.
                 */
                if ( ( subjiterDacl.HasThisAce() &&
                      (!subjiterDacl.IsDenyAll()  &&
                       subjiterDacl.QueryAccessMask() == 0)) ||
                     pAccperm->IsContainer() &&
                     (( subjiterDacl.HasNewObjectAce() &&
                       (!subjiterDacl.IsNewObjectDenyAll()  &&
                        subjiterDacl.QueryNewObjectAccessMask() == 0)) ||
                      ( subjiterDacl.HasNewContainerAce() &&
                       (!subjiterDacl.IsNewContainerDenyAll()  &&
                        subjiterDacl.QueryNewContainerAccessMask() == 0)))   )
                {
                    UIDEBUG(SZ("SecurityDesc2Accperm - Partial Denies or internal error encountered\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }

                //
                //  If the container isn't inheriting anything then we can't
                //  process this ACL.
                //
		if ( pAccperm->IsContainer() &&
		     !subjiterDacl.HasThisAce() )
		{
		    UIDEBUG(SZ("SecurityDesc2Accperm - Inherit only ACE found\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }


                ACCESS_PERMISSION * pPermAccess ;
                if ( (err = CreateNewPermission(
                                    (PERMISSION **) &pPermAccess,
                                    TRUE,
                                    (PSID) *(subjiterDacl.QuerySID()),
                                    subjiterDacl.QueryAccessMask(),
                                    pAccperm->QueryAclConverter()->IsNewObjectsSupported() &&
                                          subjiterDacl.HasNewObjectAce(),
                                    subjiterDacl.QueryNewObjectAccessMask(),
                                    pAccperm->IsContainer() &&
                                         subjiterDacl.HasNewContainerAce()))
                    || (err = pAccperm->AddPermission( pPermAccess )))
                {
                    DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;

                    /* CreateNewPermission will set this to NULL if it fails
                     */
                    delete pPermAccess ;
                    return err ;
                }
            }
        }
    }

    /* Get the SACL from the security descriptor
     */
    if ( !err &&
         !fAccessPerm &&
         ossecdesc.QueryControl()->IsSACLPresent() )
    {
        OS_ACL * posaclSACL = NULL ;
        BOOL     fSACLPresent ;

        if ( (err = ossecdesc.QuerySACL( &fSACLPresent, &posaclSACL )) )
            return err ;
        UIASSERT( fSACLPresent ) ;

        /* If the ACL is NULL, then no one is granted permissions.
         */
        if ( posaclSACL != NULL )
        {
            OS_SACL_SUBJECT_ITER subjiterSacl( posaclSACL,
                                               _pGenericMapping,
                                               _pGenericMappingNewObjects,
                                               !_fMapSpecificToGeneric,
                                               pAccperm->IsContainer() ) ;
            if ( subjiterSacl.QueryError() )
                return subjiterSacl.QueryError() ;

            /* Loop through each SID and create a subject and permission
             * as appropriate.
             */
            while ( subjiterSacl.Next( &err ) )
            {
                /* If this subject only has alarm ACEs, then skip him because
                 * we are only interested in Audit Aces.
                 */
                if ( !subjiterSacl.HasAuditAces() )
                    continue ;

                BOOL fNotPropagated = pAccperm->IsContainer() &&
                           (
                            //
                            //  Either there isn't a success audit ace
                            //  else there is a success audit ace but it
                            //  only applies to this and not to new objects
                            //  or containers
                            //
                            ( !subjiterSacl.HasThisAuditAce_S() ||
                               (subjiterSacl.HasThisAuditAce_S()         &&
                                !subjiterSacl.HasNewObjectAuditAce_S()   &&
                                !subjiterSacl.HasNewContainerAuditAce_S()
                               )
                            )
                            &&
                            (
                              !subjiterSacl.HasThisAuditAce_F() ||
                               (subjiterSacl.HasThisAuditAce_F()         &&
                                !subjiterSacl.HasNewObjectAuditAce_F()   &&
                                !subjiterSacl.HasNewContainerAuditAce_F()
                               )
                            )
                           ) ;

                /* Check for some of the permission combinations that we
                 * don't handle, these are (in order):
                 *
                 * 1) Success inherit bits must have "This", New Object,
                 *      New Container and not Inherit only set
                 *
                 * 2) Same rule for Failed inherit bits as for Success
                 * 3) The access mask for the different inherit options
                 *      must be the same (if mask will be 0 if no audit, so
                 *      we don't have to check if an audit actually exists).
                 *
                 * OR
                 *    The container doesn't propragate object/container audits
                 *    (as in an inherited owner)
                 */
                if ( pAccperm->IsContainer() &&
                     !(
                        (
                           //
                           //  Either there are isn't a success ACE else it has
                           //  a success for this, objects and containers
                           //
                           (!subjiterSacl.HasThisAuditAce_S() ||
                             (subjiterSacl.HasThisAuditAce_S()         &&
                              subjiterSacl.HasNewObjectAuditAce_S()    &&
                              subjiterSacl.HasNewContainerAuditAce_S()
                             )
                           ) &&

                           //
                           //  Either there are isn't a failure ACE else it has
                           //  a failure for this, objects and containers
                           //
                           (!subjiterSacl.HasThisAuditAce_F() ||
                             (subjiterSacl.HasThisAuditAce_F()         &&
                              subjiterSacl.HasNewObjectAuditAce_F()    &&
                              subjiterSacl.HasNewContainerAuditAce_F()
                             )
                           ) &&

                         //
                         //  The access masks must be equal between success
                         //  and failure
                         //
                         (subjiterSacl.QueryAuditAccessMask_S() ==
                              subjiterSacl.QueryNewObjectAuditAccessMask_S()) &&
                         (subjiterSacl.QueryAuditAccessMask_F() ==
                              subjiterSacl.QueryNewObjectAuditAccessMask_F()) &&
                         (subjiterSacl.QueryAuditAccessMask_S() ==
                              subjiterSacl.QueryNewContainerAuditAccessMask_S()) &&
                         (subjiterSacl.QueryAuditAccessMask_F() ==
                              subjiterSacl.QueryNewContainerAuditAccessMask_F())

                        ) ||
                        (
                           fNotPropagated
                        )
                      )
                   )
                {
                    UIDEBUG(SZ("SecurityDesc2Accperm - Bad mix of inheritance flags or Audit bits do not match\n\r")) ;
                    return IERR_UNRECOGNIZED_ACL ;
                }

                AUDIT_PERMISSION * pPermAccess ;
                if ( (err = CreateNewPermission( (PERMISSION **) &pPermAccess,
                                                FALSE,
                                                (PSID) *(subjiterSacl.QuerySID()),
                                                subjiterSacl.QueryAuditAccessMask_S(),
                                                TRUE,
                                                subjiterSacl.QueryAuditAccessMask_F(),
                                                !fNotPropagated ))
                    || (err = pAccperm->AddPermission( pPermAccess )))
                {
                    DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;

                    /* CreateNewPermission will set this to NULL if it fails
                     */
                    delete pPermAccess ;
                    return err ;
                }
            }
        }
    }

    //
    //  Now retrieve the owner SID
    //
    OS_SID * possidOwner ;
    BOOL fPresent ;
    PSID psidOwner = NULL ;
    if ( !err &&
         fAccessPerm &&
         !(err = ossecdesc.QueryOwner( &fPresent, &possidOwner )) &&
         fPresent &&
         possidOwner != NULL )
    {
        psidOwner = possidOwner->QueryPSID() ;
    }

    if ( !err )
        err = SidsToNames( pAccperm, fAccessPerm, psidOwner ) ;

    TRACEEOL(SZ("SecurityDesc2Accperm - returning error code ") << (ULONG) err ) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::CreateNewPermission

    SYNOPSIS:   Helper routine.  Creates a new subject and calls build
                permission with the appropriate parameters.

    ENTRY:      ppPermission - Pointer to ACCESS_PERMISSION or AUDIT_PERMISSION
                    that will receive the newly allocated permission
                fAccess - TRUE if access permissions, FALSE if audit perms
                psidSubject - SID of the new permission
                Mask1 - Access mask for this or success audit mask
                fMask2Used - TRUE if the Mask2 parameter is used
                Mask2 - Access mask for new items or failed audit mask
                fContainerPermsInheritted - TRUE if the container perms are
                    inheritted, FALSE otherwise

    EXIT:       ppPermission will point to a newly created permission suitable
                for adding to the permission list or audit list

    RETURNS:    NERR_Success if successful, error code otherwise.  If an error
                occurs, then all memory will be deleted by this method.

    NOTES:

    HISTORY:
        Johnl   10-Mar-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::CreateNewPermission(
                                        PERMISSION ** ppPermission,
                                        BOOL          fAccess,
                                        PSID          psidSubject,
                                        ACCESS_MASK   Mask1,
                                        BOOL          fMask2Used,
                                        ACCESS_MASK   Mask2,
                                        BOOL          fContainerPermsInheritted )
{
    APIERR err = NERR_Success ;

    SUBJECT * pSubj = new NT_SUBJECT( (PSID) psidSubject ) ;

    if ( pSubj == NULL )
        return ERROR_NOT_ENOUGH_MEMORY ;
    else if ( pSubj->QueryError() != NERR_Success )
    {
        err =  pSubj->QueryError() ;
        delete pSubj ;
        return err ;
    }

    UIASSERT( sizeof(ULONG) == sizeof(ACCESS_MASK) ) ;
    BITFIELD bitsThis( (ULONG) Mask1 ) ;
    BITFIELD bitsMask2( (ULONG) Mask2 ) ;
    if ( (err = bitsThis.QueryError()) ||
         (err = bitsMask2.QueryError()) )
    {
        return err ;
    }

    //
    //  If this isn't a container, then we effectively ignore the container
    //  flag by always setting it to TRUE
    //

    if ( !IsContainer() )
        fContainerPermsInheritted = TRUE ;

#ifdef TRACE
    TRACEEOL("CreateNewPermission - Building the following permission:") ;
    TRACEEOL("\t" << (fAccess ? "Access Permission" : "Audit Permission") ) ;
    OS_SID ossidSubj( psidSubject ) ;
    ossidSubj.DbgPrint() ;

    TRACEEOL("\tMask 1 (Container/Success) = " << (HEX_STR) Mask1) ;
    HEX_STR hexstrMask2( Mask2 ) ;
    TRACEEOL("\tMask 2 (Object/Fail)       = " << (fMask2Used ? hexstrMask2.QueryPch() :
                                                             SZ("Not Used")) ) ;
    TRACEEOL("\tfContainerPermsInheritted   = " << (fContainerPermsInheritted ?
                                                   "TRUE" : "FALSE")) ;
    TRACEEOL("=====================================================") ;
#endif //TRACE

    err = BuildPermission( ppPermission,
                           fAccess,    // Access or Audit permission
                           pSubj,
                           &bitsThis,
                           fMask2Used ? &bitsMask2 : NULL,
                           fContainerPermsInheritted ) ;
    if ( err != NERR_Success )
    {
        DBGEOL(SZ("SecurityDesc2Accperm - Build permission failed, error code ") << (ULONG) err ) ;
        return err ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::Accperm2SecurityDesc

    SYNOPSIS:   Converts an ACCPERM to an NT Security Descriptor

    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm
                fAccessPerm - TRUE if the Access permissions should be
                    converted, FALSE if the Audit permissions should be
                    converted.

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM


    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      An all zero access mask for access permissions is assumed
                to indicate Deny All permissions.

                The Deny All access permissions will be put into the DACL
                before any grants.

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::Accperm2SecurityDesc(
                                 ACCPERM * pAccperm,
                                 OS_SECURITY_DESCRIPTOR * possecdescNew,
                                 BOOL    fAccessPerms )

{
    APIERR err = NERR_Success ;

    OS_SECURITY_DESCRIPTOR ossecdescOld( _psecuritydesc ) ;
    if ( ossecdescOld.QueryError() )
        return ossecdescOld.QueryError() ;

    /* Copy the Owner and primary group from the original security descriptor
     */
    OS_SID * possidOwner ;
    OS_SID * possidGroup ;
    BOOL fContainsOwner, fContainsGroup ;

    if ( (err = ossecdescOld.QueryOwner( &fContainsOwner, &possidOwner )) ||
         (err = ossecdescOld.QueryGroup( &fContainsGroup, &possidGroup ))   )
    {
        DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" constructing owner & group")) ;
        return err ;
    }

    if ( fContainsOwner )
    {
        if ( err = possecdescNew->SetOwner( *possidOwner ) )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during SetOwner")) ;
            return err ;
        }
    }
    else
        UIDEBUG(SZ("NT_ACL_..._CONVERTER::Accperm2SecurityDesc - Warning - client supplied Sec. Desc. has no Owner\n\r")) ;

    if ( fContainsGroup )
    {
        if ( err = possecdescNew->SetGroup( *possidGroup ) )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during SetGroup")) ;
            return err ;
        }
    }
    else
    {
        UIDEBUG(SZ("NT_ACL_..._CONVERTER::Accperm2SecurityDesc - Warning - client supplied Sec. Desc. has no Group\n\r")) ;
    }

    /* We assume the access mask is a ULONG in various places in the following
     * code.
     */
    UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
    OS_ACE osace ;
    if ( osace.QueryError() )
        return osace.QueryError() ;

    /* Set the security descriptor to contain the correct items (DACL or SACL)
     * based on fAccessPerms.
     */
    if ( fAccessPerms )
    {
        OS_ACL * posaclDACL ;
        BOOL fDaclPresent ;
        if ( err = possecdescNew->QueryDACL( &fDaclPresent, &posaclDACL ))
            return err ;
        UIASSERT( fDaclPresent ) ;

        /* If the DACL is NULL, create an empty dummy one
         */
        if ( posaclDACL == NULL )
        {
            OS_ACL osaclDACL ;
            if ( (err = osaclDACL.QueryError()) ||
                 (err = possecdescNew->SetDACL( TRUE, &osaclDACL )) ||
                 (err = possecdescNew->QueryDACL( &fDaclPresent, &posaclDACL )))
            {
                return err ;
            }
            UIASSERT( posaclDACL != NULL ) ;
        }

        if ( (err = ConvertDenyAllAccessPerms( pAccperm, posaclDACL )) ||
             (err = ConvertAllowAccessPerms( pAccperm, posaclDACL))      )
        {
            DBGEOL(SZ("Accperm2SecurityDesc - Error ") << (ULONG) err << SZ(" during Convert*AccessPerms")) ;
        }
    }
    else
    {
        /* Convert the Auditting information into an NT Security descriptor.
         */
        OS_ACL * posaclSACL ;
        BOOL fSaclPresent ;
        if ( err = possecdescNew->QuerySACL( &fSaclPresent, &posaclSACL ))
            return err ;
        UIASSERT( fSaclPresent ) ;
        UIASSERT( posaclSACL != NULL ) ;

        osace.SetType( SYSTEM_AUDIT_ACE_TYPE ) ;
        AUDIT_PERMISSION * pAuditPerm ;
        BOOL fStartFromBeginning = TRUE ;

        /* Enumerate all audit permissions in the accperm, then scan the
         * original security descriptor and copy all Alarms in the
         * SACL into our new security descriptor.
         */
        while ( pAccperm->EnumAuditPermissions( &pAuditPerm,
                                                &fStartFromBeginning ) )
        {
            /* We may need to add this subject twice, once for success and
             * once for failure if the access masks aren't the same.
             */
            const OS_SID * possidSubject =
               ((NT_SUBJECT*)pAuditPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
                break ;

            if ( pAccperm->IsContainer() )
            {
                osace.SetInheritFlags( pAuditPerm->IsContainerPermsInheritted()?
                                       OBJECT_INHERIT_ACE |
                                           CONTAINER_INHERIT_ACE :
                                       0 ) ;

            }


            BITFIELD * pbitsSuccess = pAuditPerm->QuerySuccessAuditBits() ;
            BITFIELD * pbitsFail = pAuditPerm->QueryFailAuditBits() ;

            osace.SetAccessMask( (ACCESS_MASK) *pbitsSuccess ) ;

            //
            // If the bitfields are equal and non-zero, then we can optimize away one of
            // the ACEs by setting this ACE as both success and failed
            //
            if ( *pbitsSuccess == *pbitsFail &&
                 osace.QueryAccessMask() != 0 )
            {
                osace.SetAceFlags((osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                   SUCCESSFUL_ACCESS_ACE_FLAG |
                                   FAILED_ACCESS_ACE_FLAG       ) ;
                if ( err = posaclSACL->AddACE( MAXULONG, osace ) )
                    break ;
            }
            else
            {
                osace.SetAceFlags((osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                  SUCCESSFUL_ACCESS_ACE_FLAG ) ;
                if ( osace.QueryAccessMask() != 0 &&
                     (err = posaclSACL->AddACE( MAXULONG, osace )) )
                    break ;

                osace.SetAccessMask( (ACCESS_MASK) *pbitsFail ) ;
                osace.SetAceFlags( (osace.QueryAceFlags() & VALID_INHERIT_FLAGS)|
                                   FAILED_ACCESS_ACE_FLAG ) ;
                if ( osace.QueryAccessMask() != 0 &&
                     (err = posaclSACL->AddACE( MAXULONG, osace )) )
                    break ;
            }
        }

#if 0
        //
        // Don't support alarm ACEs in this build
        //

        if ( err )
            return err ;

        /* Now copy all of the ALARM aces in the original security descriptor
         * to our new security descriptor that will be passed to the client.
         */
        OS_ACL * posaclOldSACL ;
        BOOL     fSACLPresent ;
        ULONG cAces ;
        OS_SECURITY_DESCRIPTOR ossecdescOld( _psecuritydesc ) ;
        if ( ossecdescOld.QueryError() )
            return ossecdescOld.QueryError() ;

        if ( (err = ossecdescOld.QuerySACL( &fSACLPresent, &posaclOldSACL )) ||
             !fSACLPresent ||
             (err = posaclOldSACL->QueryACECount( &cAces )) )
        {
            return err ;
        }

        for ( ULONG iAce = 0 ; iAce < cAces ; iAce++ )
        {
            if ( (err = posaclOldSACL->QueryACE( iAce, &osace )))
                break ;

            if ( osace.QueryType() == SYSTEM_ALARM_ACE_TYPE )
            {
                if ( err = posaclSACL->AddACE( MAXULONG, osace ))
                    break ;
            }
        }
#endif
    }

    //
    //  One of the above AddAces may return this if we fill the security
    //  descriptor.
    //
    if ( err == ERROR_INSUFFICIENT_BUFFER )
    {
        DBGEOL("Accperm2SecDesc - Mapping ERROR_INSUFFICIENT_BUFFER to " <<
               "IERR_TOO_MANY_USERS") ;

        err = IERR_TOO_MANY_USERS ;
    }

    if ( err )
        TRACEEOL(SZ("Accperm2SecDesc returning error ") << (ULONG) err ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::ConvertDenyAllAccessPerms

    SYNOPSIS:   Finds all of they deny all permissions in the passed
                accperm and appends them as aces to the passed DACL.

    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM

    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      An all zero access mask for access permissions is assumed
                to indicate Deny All permissions.

                The deny all aces have the generic all bit set.


    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::ConvertDenyAllAccessPerms(
                                                        ACCPERM * pAccperm,
                                                        OS_ACL  * posaclDACL )
{
    APIERR err ;
    OS_ACE osace ;
    BITFIELD bitsPerms( (ULONG) 0 ) ;
    BITFIELD bitsNewObjPerms( (ULONG) 0 ) ;
    if ( (err = bitsNewObjPerms.QueryError()) ||
         (err = bitsNewObjPerms.QueryError())        ||
         (err = osace.QueryError())             )
    {
        return err ;
    }

    osace.SetType( ACCESS_DENIED_ACE_TYPE ) ;
    osace.SetAccessMask( GENERIC_ALL ) ;

    ACCESS_PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    while ( pAccperm->EnumAccessPermissions( &pPerm,
                                             &fFromBeginning )  )
    {
        BOOL fThisIsDeny = (0 == (ULONG)*pPerm->QueryAccessBits());
        BOOL fNewObjIsDeny = ( pPerm->IsNewObjectPermsSupported() &&
                               pPerm->IsNewObjectPermsSpecified() &&
                             (0 == (ULONG)*pPerm->QueryNewObjectAccessBits())) ;

        /* If this isn't a deny all permission for either this resource or
         * new objects, then ignore it.
         */
        if ( fThisIsDeny || fNewObjIsDeny )
        {
            const OS_SID * possidSubject =
                ((NT_SUBJECT*)pPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
                break ;

            if ( fNewObjIsDeny )
            {
                /* New items should only have OI and IO set.  If you set CI,
                 * then when the DACL is inheritted, the new object permission
                 * would get applied to the container.
                 */
                osace.SetInheritFlags( OBJECT_INHERIT_ACE    |
                                       INHERIT_ONLY_ACE ) ;
                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                    break ;
            }

            if ( fThisIsDeny )
            {
                if ( pAccperm->IsContainer() &&
                     pPerm->IsContainerPermsInheritted() )
                {
                    osace.SetInheritFlags( CONTAINER_INHERIT_ACE ) ;
                }
                else
                {
                    osace.SetInheritFlags( 0 ) ;
                }

                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                    break ;
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::ConvertAllowAccessPerms

    SYNOPSIS:   Finds all Access allowed permissions in the accperm and
                appends them to the DACL.


    ENTRY:      pAccperm - Pointer to the accperm to convert
                psecdesc - Pointer to security descriptor that will
                    receive the converted accperm

    EXIT:       The security descriptor will contain the permissions reflected
                in the ACCPERM


    RETURNS:    NERR_Success if successful, error code otherwise


    NOTES:      We treat aliases as groups

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::ConvertAllowAccessPerms(
                                                   ACCPERM * pAccperm,
                                                   OS_ACL  * posaclDACL )
{
    APIERR err ;
    OS_ACE osace ;
    BITFIELD bitsPerms( (ULONG) 0 ) ;
    BITFIELD bitsNewObjPerms( (ULONG) 0 ) ;
    if ( (err = bitsPerms.QueryError())       ||
         (err = bitsNewObjPerms.QueryError()) ||
         (err = osace.QueryError())             )
    {
        return err ;
    }

    osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

    ACCESS_PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    while ( pAccperm->EnumAccessPermissions( &pPerm,
                                             &fFromBeginning )  )
    {
        BOOL fThisIsDeny = (0 == (ULONG)*pPerm->QueryAccessBits());
        BOOL fNewObjIsDeny = ( pPerm->IsNewObjectPermsSupported() &&
                               pPerm->IsNewObjectPermsSpecified() &&
                             (0 == (ULONG)*pPerm->QueryNewObjectAccessBits())) ;

        /* Ignore any Deny All permissions
         *
         */
        if ( (!fThisIsDeny ||
             (pPerm->IsNewObjectPermsSupported() && !fNewObjIsDeny )))
        {
            const OS_SID * possidSubject =
                  ((NT_SUBJECT*)pPerm->QuerySubject())->QuerySID() ;

            UIASSERT( possidSubject->IsValid() ) ;
            if ( err = osace.SetSID( *possidSubject ) )
            {
                DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                       (ULONG) err << SZ(" on osace.SetSID")) ;
                break ;
            }

            /* If the object supports new object permissions and this isn't
             * a deny permission, then add a new object ace.
             */
            if ( pPerm->IsNewObjectPermsSupported() &&
                 pPerm->IsNewObjectPermsSpecified() &&
                 !fNewObjIsDeny )
            {
                TRACEEOL(SZ("ConvertAllowAccessPerms - Added New Object Permission")) ;
                osace.SetAccessMask( *pPerm->QueryNewObjectAccessBits()) ;

                /* New items should only have OI and IO set.  If you set CI,
                 * then when the DACL is inheritted, the new object permission
                 * would get applied to the container.
                 */
                osace.SetInheritFlags( OBJECT_INHERIT_ACE    |
                                       INHERIT_ONLY_ACE ) ;
                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                {
                    DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                           (ULONG) err << SZ(" on New Obj. Add ACE")) ;
                    break ;
                }
            }

            if ( !fThisIsDeny )
            {
                TRACEEOL(SZ("ConvertAllowAccessPerms - Adding This/container Permission")) ;
                osace.SetAccessMask( (ULONG)*pPerm->QueryAccessBits()) ;

                if ( pAccperm->IsContainer() &&
                     pPerm->IsContainerPermsInheritted() )
                {
                    osace.SetInheritFlags( CONTAINER_INHERIT_ACE ) ;
                }
                else
                {
                    osace.SetInheritFlags( 0 ) ;
                }

                if ( err = posaclDACL->AddACE( MAXULONG, osace ) )
                {
                    DBGEOL(SZ("NT ACL Conv::ConvertAllowAccessPerms - error ") <<
                           (ULONG) err << SZ(" on Add ACE")) ;
                    osace.DbgPrint() ;
                    posaclDACL->DbgPrint() ;
                    break ;
                }
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::BuildNewObjectPerms

    SYNOPSIS:   Given a security descriptor for the container, this method
                selects all of the permissions that should be applied
                to objects and builds a security descriptor suitable for
                applying directly to existing objects.

    ENTRY:      ossecContainer - Continer security descriptor

    EXIT:       _possecdescNewItemPerms will be set to the newly built
                   security descriptor with the appropriate item permissions

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   06-May-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::BuildNewObjectPerms(
                                const OS_SECURITY_DESCRIPTOR & ossecContainer )
{
    UIASSERT( ossecContainer.IsValid() ) ;
    APIERR err = NERR_Success ;

    /* If we are doing this a second time, delete the old one
     */
    if ( _possecdescNewItemPerms != NULL )
    {
        delete _possecdescNewItemPerms ;
        _possecdescNewItemPerms = NULL ;
    }

    do { // Error breakout

        _possecdescNewItemPerms = new OS_SECURITY_DESCRIPTOR ;

        err = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (_possecdescNewItemPerms == NULL) ||
             (err = _possecdescNewItemPerms->QueryError()) ||
             (err = _possecdescNewItemPerms->Copy( ossecContainer )) )
        {
            break ;
        }

        //
        //  Now look for any Creator Owner or Creator Group SIDs and remove
        //  them if present
        //
        OS_ACL * posacl ;
        BOOL     fACLPresent ;
        if ( (err = _possecdescNewItemPerms->QueryDACL( &fACLPresent,
                                                        &posacl )) ||
             (fACLPresent &&
              posacl != NULL &&
             (err = RemoveUndesirableACEs( posacl ))) )
        {
            break ;
        }

        if ( (err = _possecdescNewItemPerms->QuerySACL( &fACLPresent,
                                                        &posacl )) ||
             (fACLPresent &&
             (err = RemoveUndesirableACEs( posacl ))) )
        {
            break ;
        }

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::RemoveUndesirableACEs

    SYNOPSIS:	Removes any ACEs from the passed *container* ACL that
                we don't want to get inheritted onto objects

    ENTRY:      posacl - ACL to remove ACEs from (SACL or DACL)

    EXIT:       posacl will have all ACEs removed that contain the Creator
                Owner SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      posacl is assumed to belong to a container (directory etc.).

    HISTORY:
        Johnl   28-Aug-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::RemoveUndesirableACEs( OS_ACL * posacl )
{
    UIASSERT( posacl != NULL ) ;
    APIERR err = NERR_Success ;

    do { // error breakout

        OS_ACE osace ;
        OS_SID * possid ;
        OS_SID ossidCreatorOwner ;
        OS_SID ossidCreatorGroup ;
        ULONG cAces ;
        if ( (err = osace.QueryError()) ||
             (err = posacl->QueryACECount( &cAces)) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
                                                         &ossidCreatorOwner )) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorGroup,
                                                         &ossidCreatorGroup )))
        {
            break ;
        }

        for ( ; cAces > 0 ; cAces-- )
        {
            if ( (err = posacl->QueryACE( cAces-1, &osace )) ||
                 (err = osace.QuerySID( &possid )) )
            {
                break ;
            }

            /* We only remove ACEs that contain the creator owner/group SID
             * or are not inheritted by new objects
             */
            if ( !osace.IsInherittedByNewObjects() ||
                 *possid == ossidCreatorOwner      ||
                 *possid == ossidCreatorGroup        )
            {
                if ( (err = posacl->DeleteACE( cAces-1 )))
                {
                    break ;
                }
            }
            else
            {
                /* Clear the inherit flags since they have no meaning
                 * for non-containers
                 */
                osace.SetInheritFlags( 0 ) ;
            }
        }
    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       NT_ACL_TO_PERM_CONVERTER::SidsToNames

    SYNOPSIS:   This method converts all of the SIDs in the passed Accperm
                to displayable subject names

    ENTRY:      pAccperm - Pointer to ACCPERM class containing the list of
                    Access and Audit permissions
                fAccessPerms - TRUE if we are dealing with Access permissions,
                    FALSE for audit permissions
                psidOwner - Pointer to the owner SID.  If this is NULL, then
                    the owner will not be retrieved and _nlsOwner will be the
                    empty string.

    EXIT:       All NT subjects in the accperm will have their name set to
                the account name and account type

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   30-Apr-1992     Created

********************************************************************/

APIERR NT_ACL_TO_PERM_CONVERTER::SidsToNames( ACCPERM * pAccperm,
                                              BOOL      fAccessPerms,
                                              PSID      psidOwner )
{
    APIERR err = NERR_Success ;
    ULONG  cSids = fAccessPerms ? pAccperm->QueryAccessPermCount() :
                                  pAccperm->QueryAuditPermCount() ;

    //
    //  Add one in case we are going to get the owner's name
    //
    BUFFER buffPSIDs( (UINT) (sizeof( PSID ) * (cSids + 1 )) ) ;
    if ( err = buffPSIDs.QueryError() )
    {
        return err ;
    }

    PSID * apsid = (PSID *) buffPSIDs.QueryPtr() ;
    PERMISSION * pPerm ;
    BOOL fFromBeginning = TRUE ;
    BOOL fDone = FALSE ;
    UINT i = 0 ;

    //
    //  Build the array of PSIDs suitable for passing to LSATranslateSidsToNames
    //
    while ( TRUE )
    {
        if ( fAccessPerms )
        {
            fDone = !pAccperm->EnumAccessPermissions( (ACCESS_PERMISSION**)&pPerm,
                                                      &fFromBeginning ) ;
        }
        else
        {
            fDone = !pAccperm->EnumAuditPermissions( (AUDIT_PERMISSION**)&pPerm,
                                                    &fFromBeginning ) ;
        }

        if ( fDone )
            break ;

        NT_SUBJECT * pNTSubj = (NT_SUBJECT *) pPerm->QuerySubject() ;
        apsid[i++] = pNTSubj->QuerySID()->QuerySid() ;
    }

    //
    //  Include the owner SID (for the "Owner:" field in the dialog) if
    //  requested
    //

    if ( psidOwner != NULL )
    {
        apsid[i++] = psidOwner ;
    }

    //
    //  If no names to convert, then just return
    //
    if ( i == 0 )
    {
        return NERR_Success ;
    }

    BUFFER buffUserFlags( i * sizeof( ULONG )) ;
    BUFFER buffSidNameUse( i* sizeof( SID_NAME_USE )) ;
    STRLIST strlistNames ;
    const TCHAR * pszServer = pAccperm->QueryAclConverter()->
                                                QueryLocation()->QueryServer() ;
    API_SESSION APISession( pszServer, TRUE ) ;
    LSA_POLICY LSAPolicyTarget( pszServer ) ;
    OS_SID ossidUsersDomain ;

    if ( err ||
        (err = APISession.QueryError())        ||
        (err = buffUserFlags.QueryError())     ||
        (err = buffSidNameUse.QueryError())    ||
        (err = LSAPolicyTarget.QueryError())      ||
        (err = ossidUsersDomain.QueryError())     ||
	(err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessUser,
                                                    &ossidUsersDomain )) ||
        (err = ossidUsersDomain.TrimLastSubAuthority()) )
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error " << (ULONG) err
                << " returned from SAMServer or GetAccountDomain") ;
        return err ;
    }

    if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSAPolicyTarget,
                                      ossidUsersDomain.QueryPSID(),
                                      apsid,
                                      i,
                                      TRUE,
                                      &strlistNames,
                                      (ULONG*) buffUserFlags.QueryPtr(),
                                      (SID_NAME_USE*) buffSidNameUse.QueryPtr(),
                                      NULL,
                                      pszServer )))
    {
        DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error " << (ULONG) err
                << " returned from GetQualifiedAccountNames") ;
        return err ;
    }

    /* Set each of the account names to the looked up name
     */
    fDone = FALSE ;
    fFromBeginning = TRUE ;
    i = 0 ;
    SID_NAME_USE * aSidNameUse = (SID_NAME_USE*) buffSidNameUse.QueryPtr() ;
    ULONG *        aUserFlags  = (ULONG *) buffUserFlags.QueryPtr() ;
    ITER_STRLIST iterNames( strlistNames ) ;
    NLS_STR * pnlsName ;
    while ( TRUE )
    {
        if ( fAccessPerms )
        {
            fDone = !pAccperm->EnumAccessPermissions( (ACCESS_PERMISSION**)&pPerm,
                                                     &fFromBeginning ) ;
        }
        else
        {
            fDone = !pAccperm->EnumAuditPermissions( (AUDIT_PERMISSION**)&pPerm,
                                                    &fFromBeginning ) ;
        }

        if ( fDone )
            break ;

        NT_SUBJECT * pNTSubj = (NT_SUBJECT *) pPerm->QuerySubject() ;
	REQUIRE( (pnlsName = iterNames.Next()) != NULL ) ;
	SID_NAME_USE SidUse = aSidNameUse[i] ;

	if ( SidUse == SidTypeDeletedAccount )
	{
	    //
	    //	If this is a deleted account, then just filter it from the
	    //	user list
	    //
	    if ( fAccessPerms )
	    {
		REQUIRE( pAccperm->DeletePermission( (ACCESS_PERMISSION*) pPerm )) ;
	    }
	    else
	    {
		REQUIRE( pAccperm->DeletePermission( (AUDIT_PERMISSION*) pPerm )) ;
	    }
	}
	else
	{
	    if ( SidUse == SidTypeUser &&
		 aUserFlags[i] & USER_TEMP_DUPLICATE_ACCOUNT )
	    {
		SidUse = (SID_NAME_USE) SubjTypeRemote ;
	    }
	    pNTSubj->SetNameUse( SidUse ) ;

	    if ( (err = pNTSubj->SetDisplayName( *pnlsName )))
	    {
		break ;
	    }
	}

        i++ ;
    }

    //
    //  Fill in the owner string if it was requested
    //
    if ( !err && psidOwner != NULL )
    {
        REQUIRE( (pnlsName = iterNames.Next()) != NULL ) ;
        err = _nlsOwner.CopyFrom( *pnlsName ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\ipermapi.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    IPermAPI.cxx


    Internal generic permission edittor API implementation

    FILE HISTORY:
	Johnl	07-Aug-1991	Created

*/
#include <ntincl.hxx>
#include <ntseapi.h>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <accperm.hxx>
#include <aclconv.hxx>
#include <permdlg.hxx>
#include <auditdlg.hxx>

#include <dbgstr.hxx>
#include <uiassert.hxx>

#include <ipermapi.hxx>

/*******************************************************************

    NAME:	I_GenericSecurityEditor

    SYNOPSIS:	This function creates the main permission editor or auditting
		editor dialogs.

    ENTRY:	See ipermapi.hxx for a complete explanation of all
		parameters.

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Updated with real dialogs

********************************************************************/

APIERR I_GenericSecurityEditor(
    HWND		    hwndParent,
    ACL_TO_PERM_CONVERTER * paclconv,
    enum SED_PERM_TYPE	    permType,
    BOOL		    fIsNT,
    BOOL		    fIsContainer,
    BOOL		    fSupportsNewObjectPerms,
    const TCHAR		  * pszDialogTitle,
    const TCHAR		  * pszResType,
    const TCHAR		  * pszResName,
    const TCHAR 	  * pszSpecialAccessName,
    const TCHAR 	  * pszDefaultPermName,
    const TCHAR           * pszHelpFileName,
    ULONG                 * ahcHelp,
    const TCHAR		  * pszNewObjectSpecialAccessName,
    const TCHAR           * pszAssignToExistingContTitle,
    const TCHAR           * pszAssignToExistingObjTitle,
    const TCHAR 	  * pszTreeApplyHelpText,
    const TCHAR 	  * pszTreeApplyConfirmation )
{
    UIASSERT( hwndParent != NULL ) ;
    UIASSERT( paclconv != NULL && paclconv->QueryError() == NERR_Success ) ;
    UIASSERT( (permType == SED_AUDITS) || (permType == SED_ACCESSES) ) ;

    MAIN_PERM_BASE_DLG * ppermdlg = NULL ;

    /* Here we determine which dialog we want to show the user.  Note that
     * the Initialize and destructor methods are virtual.
     */
    if ( !fIsNT )
    {
	if ( permType == SED_ACCESSES )
	{
	    if ( fIsContainer )
	    {
		/* LM Directory permissions.  Note there is no difference
		 * in the dialogs thus we can use the same dialog template
		 */
		ppermdlg = new CONT_ACCESS_PERM_DLG(
						  MAKEINTRESOURCE(IDD_SED_LM_CONT_PERM),
						  hwndParent,
						  pszDialogTitle,
						  paclconv,
						  pszResType,
						  pszResName,
						  pszHelpFileName,
						  pszSpecialAccessName,
                                                  pszDefaultPermName,
                                                  ahcHelp,
						  pszAssignToExistingContTitle,
						  pszTreeApplyHelpText,
						  pszTreeApplyConfirmation );

	    }
	    else
	    {
		/* LM Single object non-container access permissions dialog
		 */
		ppermdlg = new OBJECT_ACCESS_PERMISSION_DLG(
							  MAKEINTRESOURCE(IDD_SED_OBJECT_PERM),
							  hwndParent,
							  pszDialogTitle,
							  paclconv,
							  pszResType,
							  pszResName,
							  pszHelpFileName,
							  pszSpecialAccessName,
							  pszDefaultPermName,
                                                          ahcHelp ) ;


	    }
	}
	else
	{
	    /* LM Auditting - Uses the same dialog, the only variation
	     * is that for files, the checkbox title should be NULL, this
	     * will hide and disable checkbox.
	     */
	    ppermdlg = new LM_AUDITTING_DLG( MAKEINTRESOURCE(IDD_SED_LM_AUDITING_DLG),
					     hwndParent,
					     pszDialogTitle,
					     paclconv,
					     pszResType,
					     pszResName,
					     pszHelpFileName,
                                             ahcHelp,
					     pszAssignToExistingContTitle,
					     pszTreeApplyHelpText,
					     pszTreeApplyConfirmation ) ;
	}
    }
    else
    {
	/* This is an NT ACL we will be dealing with
	 */

	if ( permType == SED_ACCESSES )
	{
	    if ( fIsContainer )
	    {
		if ( fSupportsNewObjectPerms )
		{
		    //
		    //	NT Container object that supports New Object
		    //	permissions
		    //
		    ppermdlg = new NT_CONT_ACCESS_PERM_DLG(
                                                MAKEINTRESOURCE(IDD_SED_NT_CONT_NEWOBJ_PERM_DLG),
						hwndParent,
						pszDialogTitle,
						paclconv,
						pszResType,
						pszResName,
						pszHelpFileName,
						pszSpecialAccessName,
						pszDefaultPermName,
                                                ahcHelp,
						pszNewObjectSpecialAccessName,
                                                pszAssignToExistingContTitle,
                                                pszAssignToExistingObjTitle,
						pszTreeApplyHelpText,
						pszTreeApplyConfirmation ) ;
		}
		else
		{
		    //
		    //	NT Container object that does not support New Object
		    //	permissions
		    //
		    ppermdlg = new NT_CONT_NO_OBJ_ACCESS_PERM_DLG(
						MAKEINTRESOURCE(IDD_SED_NT_CONT_PERM),
						hwndParent,
						pszDialogTitle,
						paclconv,
						pszResType,
						pszResName,
						pszHelpFileName,
						pszSpecialAccessName,
						pszDefaultPermName,
                                                ahcHelp,
						pszAssignToExistingContTitle,
						pszTreeApplyHelpText,
						pszTreeApplyConfirmation ) ;
		}
	    }
	    else
	    {
		/* NT Object access permissions dialog
		 */
		ppermdlg = new NT_OBJECT_ACCESS_PERMISSION_DLG(
							  MAKEINTRESOURCE(IDD_SED_NT_OBJECT_PERM),
							  hwndParent,
							  pszDialogTitle,
							  paclconv,
							  pszResType,
							  pszResName,
							  pszHelpFileName,
							  pszSpecialAccessName,
                                                          pszDefaultPermName,
                                                          ahcHelp ) ;

	    }
	}
	else
	{
	    if ( fIsContainer )
            {
		if ( fSupportsNewObjectPerms )
		{
                    /* NT Container and object auditting dialog
                     */
                    ppermdlg = new CONT_NEWOBJ_AUDIT_DLG(
                                           MAKEINTRESOURCE(IDD_SED_NT_CONT_NEWOBJ_AUDITING_DLG),
                                           hwndParent,
                                           pszDialogTitle,
                                           paclconv,
                                           pszResType,
                                           pszResName,
                                           pszHelpFileName,
                                           ahcHelp,
                                           pszAssignToExistingContTitle,
                                           pszAssignToExistingObjTitle,
                                           pszTreeApplyHelpText,
                                           pszTreeApplyConfirmation ) ;
                }
                else
                {
                    /* NT Container auditting dialog
                     */
                    ppermdlg = new CONT_AUDIT_DLG( MAKEINTRESOURCE(IDD_SED_NT_CONT_AUDITING_DLG),
                                           hwndParent,
                                           pszDialogTitle,
                                           paclconv,
                                           pszResType,
                                           pszResName,
                                           pszHelpFileName,
                                           ahcHelp,
                                           pszAssignToExistingContTitle,
                                           pszTreeApplyHelpText,
                                           pszTreeApplyConfirmation ) ;
                }
	    }
	    else
	    {
		/* NT Object auditting dialog
		 */
		ppermdlg = new OBJECT_AUDIT_DLG( MAKEINTRESOURCE(IDD_SED_NT_CONT_AUDITING_DLG),
						 hwndParent,
						 pszDialogTitle,
						 paclconv,
						 pszResType,
						 pszResName,
						 pszHelpFileName,
                                                 ahcHelp ) ;
	    }
	}
    }

    if ( ppermdlg == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }
    else if ( ppermdlg->QueryError() != NERR_Success )
    {
	DBGEOL("::I_GenericSecurityEditor - permission dialog failed to construct") ;
	return ppermdlg->QueryError() ;
    }

    APIERR err ;
    BOOL fUserQuit ;
    if ( !(err = ppermdlg->Initialize( &fUserQuit,
				       (permType == SED_ACCESSES) )) &&
	 !fUserQuit )
    {
	err = ppermdlg->Process() ;
    }

    delete ppermdlg ;

    return err ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\libmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    Libmain.cxx

    Library initialization for the Acl Editor



    FILE HISTORY:
        JohnL   15-Apr-1992     Scavenged from Shell's Libmain

*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETLIB
#include <lmui.hxx>

extern "C"
{
    #include <dos.h>

    #include <uimsg.h>
    #include <uirsrc.h>
}


#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <ellipsis.hxx>

#include <uitrace.hxx>
#include <string.hxx>

/*      Local prototypes         */

// reorged these for Glock
extern "C"
{
    BOOL NEAR PASCAL LIBMAIN              ( HINSTANCE hInst,
                                            UINT   wDataSeg,
                                            UINT   wHeapSize,
                                            LPSTR  lpCmdLine  );

/* Under Win32, DllMain simply calls LIBMAIN.
 */
BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved ) ;


INT FAR PASCAL WEP                    ( UINT   wWord      );
}

#define FAR_HEAPS_DLL 5  /* Maximum numbe of far heaps for ::new */

HINSTANCE  hModule = NULL;     // exported


/*****
 *
 *  LIBMAIN
 *
 *  Purpose:
 *      Initialize DLL, which includes:
 *        - save away instance handle
 *        - set current capabilities
 *
 *  Parameters:
 *      hInst           Instance handle of DLL
 *
 *  Returns:
 *      TRUE            Init OK
 *      FALSE           Init failed
 */

BOOL /* NEAR PASCAL */ LIBMAIN    ( HINSTANCE          hInst,
                                    UINT            wDataSeg,
                                    UINT            wHeapSize,
                                    LPSTR           lpCmdLine       )
{
    UNREFERENCED (wDataSeg);
    UNREFERENCED (lpCmdLine);
    UNREFERENCED( wHeapSize ) ;

    ::hModule = hInst;

    APIERR err ;
    if ( (err = BLT::Init(hInst,
                          IDRSRC_ACLEDIT_BASE, IDRSRC_ACLEDIT_LAST,
                          IDS_UI_ACLEDIT_BASE, IDS_UI_ACLEDIT_LAST)) ||
         (err = BASE_ELLIPSIS::Init()) )
    {
        return FALSE ;
    }

    /*
     * BLT functionality not available until after this comment
     */

    return TRUE;
}  /* LIBMAIN */

/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   Win32 DLL Entry point.  This function gets called when
                a process or thread attaches/detaches itself to this DLL.
                We simply call the Win3 appropriate DLL function.

    ENTRY:      hDll - DLL Module handle
                dwReason - Indicates attach/detach
                lpvReserved - Not used

    EXIT:

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      This is the typical Win32 DLL entry style.

                This is Win32 only.

    HISTORY:
        Johnl   01-Nov-1991     Created

********************************************************************/

#ifdef WIN32
BOOL DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    UNREFERENCED( lpvReserved ) ;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return LIBMAIN( hDll, 0, 0, NULL ) ;

    case DLL_PROCESS_DETACH:
        return WEP( 0 ) ;

    default:
        break ;
    }

    return TRUE ;
}
#endif //WIN32

/*
 *  WEP   (Windows Export Proc--short and cryptic name because
 *         this function is not given an ordinal)
 *
 *  When Windows unloads a driver, it calls this function so that
 *  the driver can do any last minute clean-ups.  Then, Windows
 *  calls the WEP function.  All Windows libraries are required to
 *  contain this function.  It should be included in the .def file
 *  but should not be given an ordinal.
 *
 */

INT WEP ( UINT wWord )
{
#ifdef WIN32
    UNREFERENCED( wWord ) ;
#endif

    BASE_ELLIPSIS::Term() ;
    BLT::Term( ::hModule ) ;

#ifndef WIN32
    MEM_MASTER::Term();    /*  Terminate use of the global heap  */
#endif //!WIN32
    return 1;
}  /* WEP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\ntfsacl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

    NTFSAcl.cxx

    This file contains the implementation for the NT File System ACL
    Editor.  It is just a front end for the Generic ACL Editor that is
    specific to the NTFS.

    FILE HISTORY:
        Johnl   30-Dec-1991     Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntioapi.h>
    #include <ntseapi.h>
}

#include <ntmasks.hxx>

#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS      // For NET_ACCESS_1 reference
#define INCL_NETUSE
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <strnumer.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <uibuffer.hxx>
#include <strlst.hxx>
#include <fsenum.hxx>
#include <errmap.hxx>

#include <lmodev.hxx>
#include <lmoacces.hxx>


extern "C"
{
    #include <netlib.h>         // For NetpGetPrivilege
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>
#include <fmx.hxx>

extern "C"
{
    #include <sedapi.h>
    #include <helpnums.h>
}


#include <cncltask.hxx>
#include <uiassert.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>
#include <permstr.hxx>
#include <ntfsacl.hxx>

DWORD SedCallback( HWND                   hwndParent,
                   HANDLE                 hInstance,
                   ULONG_PTR              ulCallbackContext,
                   PSECURITY_DESCRIPTOR   psecdesc,
                   PSECURITY_DESCRIPTOR   psecdescNewObjects,
                   BOOLEAN                fApplyToSubContainers,
                   BOOLEAN                fApplyToSubObjects,
                   LPDWORD                StatusReturn
                 ) ;


typedef struct _NTFS_CALLBACK_INFO
{
    HWND hwndFMXOwner ;
    enum SED_PERM_TYPE  sedpermtype ;
} NTFS_CALLBACK_INFO ;

void InitializeNTFSGenericMapping( PGENERIC_MAPPING pNTFSGenericMapping,
                                   BOOL fIsDirectory ) ;

APIERR GetSecurity( const TCHAR *      pszFileName,
                    BUFFER *           pbuffSecDescData,
                    enum SED_PERM_TYPE sedpermtype,
                    BOOL  *            pfAuditPrivAdjusted ) ;

APIERR CompareNTFSSecurityIntersection( HWND hwndFMX,
                                        enum SED_PERM_TYPE sedpermtype,
                                        PSECURITY_DESCRIPTOR psecdesc,
                                        BOOL *           pfOwnerEqual,
                                        BOOL *           pfACLEqual,
                                        NLS_STR *        pnlsFailingFile,
                                        PGENERIC_MAPPING pGenericMapping,
                                        PGENERIC_MAPPING pGenericMappingObjects,
                                        BOOL             fMapGenAll,
                                        BOOL             fIsContainer ) ;

/* The following two arrays define the permission names for NT Files.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidFilePermNames[] =
{
    IDS_FILE_PERM_SPEC_READ,
    IDS_FILE_PERM_SPEC_WRITE,
    IDS_FILE_PERM_SPEC_EXECUTE,

    IDS_FILE_PERM_SPEC_DELETE,
    IDS_FILE_PERM_SPEC_CHANGE_PERM,
    IDS_FILE_PERM_SPEC_CHANGE_OWNER,

    IDS_FILE_PERM_GEN_NO_ACCESS,
    IDS_FILE_PERM_GEN_READ,
    IDS_FILE_PERM_GEN_MODIFY,
    IDS_FILE_PERM_GEN_ALL
} ;

SED_APPLICATION_ACCESS sedappaccessFilePerms[] =
    {
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_READ,         0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_WRITE,        0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_EXECUTE,      0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_DELETE,       0, NULL },
      //{ SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_READ_PERM,    0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_CHANGE_PERM,  0, NULL },
      { SED_DESC_TYPE_RESOURCE_SPECIAL, FILE_PERM_SPEC_CHANGE_OWNER, 0, NULL },

      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_NO_ACCESS,    0, NULL },
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_READ,         0, NULL },
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_MODIFY,       0, NULL }
      ,
      { SED_DESC_TYPE_RESOURCE,         FILE_PERM_GEN_ALL,          0, NULL }
    } ;

#define COUNT_FILEPERMS_ARRAY   (sizeof(sedappaccessFilePerms)/sizeof(SED_APPLICATION_ACCESS))

/* The following two arrays define the permission names for NT directories.  Note
 * that each index in one array corresponds to the index in the other array.
 * The second array will be modifed to contain a string pointer pointing to
 * the corresponding IDS_* in the first array.
 */
MSGID msgidDirPermNames[] =
{
    IDS_DIR_PERM_SPEC_READ,
    IDS_DIR_PERM_SPEC_WRITE,
    IDS_DIR_PERM_SPEC_EXECUTE,
    IDS_DIR_PERM_SPEC_DELETE,
    IDS_DIR_PERM_SPEC_CHANGE_PERM,
    IDS_DIR_PERM_SPEC_CHANGE_OWNER,

    IDS_DIR_PERM_GEN_NO_ACCESS,
    IDS_DIR_PERM_GEN_LIST,
    IDS_DIR_PERM_GEN_READ,
    IDS_DIR_PERM_GEN_DEPOSIT,
    IDS_DIR_PERM_GEN_PUBLISH,
    IDS_DIR_PERM_GEN_MODIFY,
    IDS_DIR_PERM_GEN_ALL,

    IDS_NEWFILE_PERM_SPEC_READ,
    IDS_NEWFILE_PERM_SPEC_WRITE,
    IDS_NEWFILE_PERM_SPEC_EXECUTE,
    IDS_NEWFILE_PERM_SPEC_DELETE,
    IDS_NEWFILE_PERM_SPEC_CHANGE_PERM,
    IDS_NEWFILE_PERM_SPEC_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessDirPerms[] =
{
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_READ,        0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_WRITE,       0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_EXECUTE,     0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_DELETE,      0, NULL },
  //{ SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_READ_PERM,   0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_CHANGE_PERM, 0, NULL },
  { SED_DESC_TYPE_RESOURCE_SPECIAL, DIR_PERM_SPEC_CHANGE_OWNER,0, NULL },

  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_NO_ACCESS,NEWFILE_PERM_GEN_NO_ACCESS, NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_LIST,     NEWFILE_PERM_GEN_LIST,      NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_READ,     NEWFILE_PERM_GEN_READ,      NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_DEPOSIT,  NEWFILE_PERM_GEN_DEPOSIT,   NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_PUBLISH,  NEWFILE_PERM_GEN_PUBLISH,   NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_MODIFY,   NEWFILE_PERM_GEN_MODIFY,    NULL },
  { SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  DIR_PERM_GEN_ALL,      NEWFILE_PERM_GEN_ALL,       NULL },

  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_READ,         0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_WRITE,        0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_EXECUTE,      0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_DELETE,       0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_CHANGE_PERM,  0, NULL },
  { SED_DESC_TYPE_NEW_OBJECT_SPECIAL, NEWFILE_PERM_SPEC_CHANGE_OWNER, 0, NULL }
} ;

#define COUNT_DIRPERMS_ARRAY    (sizeof(sedappaccessDirPerms)/sizeof(SED_APPLICATION_ACCESS))

/* The following two arrays define the auditting names for NT directories and
 * directories.
 */
MSGID msgidFileAuditNames[] =
{
    IDS_FILE_AUDIT_READ,
    IDS_FILE_AUDIT_WRITE,
    IDS_FILE_AUDIT_EXECUTE,
    IDS_FILE_AUDIT_DELETE,
    IDS_FILE_AUDIT_CHANGE_PERM,
    IDS_FILE_AUDIT_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessFileAudits[] =
    {
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_READ,        0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_WRITE,       0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_EXECUTE,     0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_DELETE,      0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_PERM, 0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_OWNER,0, NULL }
    } ;

#define COUNT_FILE_AUDITPERMS_ARRAY   (sizeof(sedappaccessFileAudits)/sizeof(SED_APPLICATION_ACCESS))


/* The following two arrays define the auditting names for NT directories and
 * directories.
 */
MSGID msgidDirAuditNames[] =
{
    IDS_DIR_AUDIT_READ,
    IDS_DIR_AUDIT_WRITE,
    IDS_DIR_AUDIT_EXECUTE,
    IDS_DIR_AUDIT_DELETE,
    IDS_DIR_AUDIT_CHANGE_PERM,
    IDS_DIR_AUDIT_CHANGE_OWNER
} ;

SED_APPLICATION_ACCESS sedappaccessDirAudits[] =
    {
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_READ,        0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_WRITE,       0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_EXECUTE,     0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_DELETE,      0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_PERM, 0, NULL },
      { SED_DESC_TYPE_AUDIT, FILE_AUDIT_CHANGE_OWNER,0, NULL }
    } ;

#define COUNT_DIR_AUDITPERMS_ARRAY   (sizeof(sedappaccessDirAudits)/sizeof(SED_APPLICATION_ACCESS))


extern HINSTANCE hModule; // Exported from libmain


/*******************************************************************

    NAME:       EditNTFSAcl

    SYNOPSIS:   This Procedure prepares the structures necessary for the
                generic ACL editor, specifically for NT FS (FileSystem)
                ACLs.

    ENTRY:      hwndParent - Parent window handle, this should be the
                    FMX Window handle
                pszServer - Name of server the resource resides on
                    (in the form "\\server")
                pszResource - Fully qualified name of resource we will
                    edit (suitable for passing to GetFileSecurity)
                sedpermtype - either SED_ACCESSES or SED_AUDITS
                fIsFile - TRUE if the resource is a file, FALSE if the
                    resource is a directory

    EXIT:

    RETURNS:

    NOTES:      We assume we are dealing with an NTFS volume by the time
                this function is called.

    HISTORY:
        Johnl   25-Dec-1992     Created

********************************************************************/

APIERR EditNTFSAcl( HWND                hwndParent,
                    const TCHAR *       pszServer,
                    const TCHAR *       pszResource,
                    enum SED_PERM_TYPE  sedpermtype,
                    BOOL                fIsFile )
{
    APIERR err ;
    BUFFER buffSecDescData( 1024 ) ;
    BOOL   fCantRead     = FALSE ;      // Did we read the Owner?
    BOOL   fCantWrite    = FALSE ;      // Is it read only?
    BOOL   fPrivAdjusted = FALSE ;      // Do we need to restore our token?
    BOOL   fCheckSecurity= TRUE ;       // Check security unless bad intersection
    const TCHAR * pszSecCheckFile = pszResource ;

    do { // error breakout

        PSECURITY_DESCRIPTOR pSecurityDesc = NULL ;

        switch ( err = ::GetSecurity( pszResource,
                                      &buffSecDescData,
                                      sedpermtype,
                                      &fPrivAdjusted ) )
        {
        case ERROR_ACCESS_DENIED:
            fCantRead = TRUE ;

            //
            //  If they can't read the SACL then they don't have the privilege
            //
            if ( sedpermtype == SED_AUDITS )
            {
                err = ERROR_PRIVILEGE_NOT_HELD ;
                break ;
            }

            err = NERR_Success ;
            break ;

        case NO_ERROR:
            pSecurityDesc = (PSECURITY_DESCRIPTOR) buffSecDescData.QueryPtr() ;
            break ;

        default:
            break ;
        }
        if ( err )
            break ;

        GENERIC_MAPPING NTFSGenericMapping ;
        InitializeNTFSGenericMapping( &NTFSGenericMapping, !fIsFile ) ;

        FMX  fmx( hwndParent ) ;
        BOOL fIsMultiSelect = fmx.QuerySelCount() > 1 ;

        //
        //  We may need to substitute our own security descriptor here
        //  depending on the intersection of security descriptors because
        //  we can't set a NULL owner on a self relative security descriptor
        //  (which we will most likely get).
        //
        OS_SECURITY_DESCRIPTOR ossecdesc( fIsMultiSelect ?
                                          pSecurityDesc : NULL, TRUE ) ;
        OS_ACL osacl( NULL ) ;
        DEC_STR nlsSelectCount( fmx.QuerySelCount() ) ;
        if ( fIsMultiSelect )
        {
            BOOL fOwnerEqual = FALSE, fACLEqual = FALSE ;
            NLS_STR nlsFailingFile ;
            MSGID idsPromptToContinue = IDS_BAD_INTERSECTION ;
            if ( fCantRead                      ||
                 (err = ossecdesc.QueryError()) ||
                 (err = nlsSelectCount.QueryError()) ||
                 (err = CompareNTFSSecurityIntersection( hwndParent,
                                                         sedpermtype,
                                                         pSecurityDesc,
                                                         &fOwnerEqual,
                                                         &fACLEqual,
                                                         &nlsFailingFile,
                                                         &NTFSGenericMapping,
                                                         &NTFSGenericMapping,
                                                         TRUE,
                                                         !fIsFile )) )
            {
                //
                //  If we didn't have access to read one of the security
                //  descriptors, then give the user the option of continuing
                //
                if ( fCantRead || err == ERROR_ACCESS_DENIED )
                {
                    pszResource = fCantRead ? pszResource :
                                              nlsFailingFile.QueryPch() ;
                    idsPromptToContinue = IERR_MULTI_SELECT_AND_CANT_READ ;
                    fCantRead = TRUE ;
                    err = NERR_Success ;
                }
                else
                {
                    break ;
                }
            }

            //
            // Substitute the blank security descriptor only if we need to
            //
            if ( !fACLEqual || !fOwnerEqual || fCantRead )
            {
                pSecurityDesc = ossecdesc.QueryDescriptor() ;
            }

            if ( !fACLEqual || fCantRead )
            {
                switch ( ::MsgPopup( hwndParent,
                                     (MSGID) idsPromptToContinue,
                                     MPSEV_WARNING,
                                     MP_YESNO,
                                     pszResource,
                                     nlsFailingFile,
                                     MP_YES ))
                {
                case IDYES:
                    {
                        if ( (err = ossecdesc.SetDACL( TRUE, &osacl )) ||
                             (err = ossecdesc.SetSACL( TRUE, &osacl )) ||
                             (err = ossecdesc.SetOwner( FALSE, NULL, 0 )) ||
                             (err = ossecdesc.SetGroup( FALSE, NULL, 0 ))   )
                        {
                            break ;
                        }

                        //
                        //  We've just made the ACL equal.  Note that we don't
                        //  check the security if the ACLs aren't equal (some
                        //  may allow access, others may not).
                        //
                        fACLEqual = TRUE ;
                        fCantRead = FALSE ;
                        fCheckSecurity = FALSE ;
                    }
                    break ;

                case IDNO:
                default:
                    break ;
                }
            }
            if ( err || !fACLEqual || fCantRead )
                break ;

            if ( !fOwnerEqual &&
                 (err = ossecdesc.SetOwner( FALSE, NULL, 0 )) )
            {
                break ;
            }
        } // if IsMultiSelect


        /* Retrieve the resource strings appropriate for the type of object we
         * are looking at
         */

        MSGID msgidTypeName = fIsFile ? IDS_FILE : IDS_DIRECTORY ;
        MSGID msgidApplySubCont = sedpermtype == SED_ACCESSES ?
                                       IDS_NT_ASSIGN_PERM_TITLE:
                                       IDS_NT_ASSIGN_AUDITS_TITLE ;
        MSGID msgidApplySubObj   =sedpermtype == SED_ACCESSES ?
                                       IDS_NT_ASSIGN_FILE_PERM_TITLE :
                                       IDS_NT_ASSIGN_FILE_AUDITS_TITLE ;

        RESOURCE_STR nlsTypeName( msgidTypeName ) ;
        RESOURCE_STR nlsSpecial( fIsFile ? IDS_NT_FILE_SPECIAL_ACCESS :
                                           IDS_NT_DIR_SPECIAL_ACCESS ) ;
        RESOURCE_STR nlsDefaultPermName( fIsFile ? IDS_FILE_PERM_GEN_READ :
                                                   IDS_DIR_PERM_GEN_READ   ) ;
        RESOURCE_STR nlsHelpFileName   ( IDS_FILE_PERM_HELP_FILE ) ;
        RESOURCE_STR nlsResourceName   ( fIsFile ? IDS_FILE_MULTI_SEL :
                                                   IDS_DIRECTORY_MULTI_SEL ) ;

        NLS_STR  nlsApplyToSubCont ;
        NLS_STR  nlsApplyToSubObj ;
        NLS_STR  nlsSpecialNewObj ;
        NLS_STR  nlsApplyToSubContConfirmation ;

        /* We only need the ApplyTo title and the NewObjSpecial strings if
         * this resource is a directory.
         */
        if ( !fIsFile )
        {
            if ( (err = nlsApplyToSubCont.Load( msgidApplySubCont )) ||
                 (err = nlsApplyToSubObj.Load(  msgidApplySubObj  )) ||
                 (err = nlsSpecialNewObj.Load(IDS_NT_NEWOBJ_SPECIAL_ACCESS)) ||
                 (err = nlsApplyToSubContConfirmation.Load( IDS_TREE_APPLY_WARNING )))
            {
                /* Fall through
                 */
            }
        }

        if ( err ||
             ( err = nlsTypeName.QueryError() ) ||
             ( err = nlsSpecial.QueryError() )  ||
             ( err = nlsDefaultPermName.QueryError()) ||
             ( err = nlsHelpFileName.QueryError()) )
        {
            break ;
        }

        //
        //  Replace the resource name with the "X files selected" string
        //  if we are in a multi-select situation
        //
        if ( fIsMultiSelect )
        {
            if ( (err = nlsResourceName.QueryError()) ||
                 (err = nlsResourceName.InsertParams( nlsSelectCount )))
            {
                break ;
            }
            pszResource = nlsResourceName.QueryPch() ;
        }

        SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc ;
        SED_HELP_INFO sedhelpinfo ;

        sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;

        sedobjdesc.Revision                    = SED_REVISION1 ;
        sedobjdesc.IsContainer                 = !fIsFile ;
        sedobjdesc.AllowNewObjectPerms         = !fIsFile ;
        sedobjdesc.MapSpecificPermsToGeneric   = TRUE ;
        sedobjdesc.GenericMapping              = &NTFSGenericMapping ;
        sedobjdesc.GenericMappingNewObjects    = &NTFSGenericMapping ;
        sedobjdesc.HelpInfo                    = &sedhelpinfo ;
        sedobjdesc.ObjectTypeName              = (LPTSTR) nlsTypeName.QueryPch() ;
        sedobjdesc.ApplyToSubContainerTitle    = (LPTSTR) nlsApplyToSubCont.QueryPch() ;
        sedobjdesc.ApplyToObjectsTitle         = (LPTSTR) nlsApplyToSubObj.QueryPch() ;
        sedobjdesc.ApplyToSubContainerConfirmation
                                               = (LPTSTR) nlsApplyToSubContConfirmation.QueryPch() ;
        sedobjdesc.SpecialObjectAccessTitle    = (LPTSTR) nlsSpecial.QueryPch() ;
        sedobjdesc.SpecialNewObjectAccessTitle = (LPTSTR) nlsSpecialNewObj.QueryPch() ;

        /* Now we need to load the global arrays with the permission names
         * from the resource file.
         */
        UINT cArrayItems ;
        MSGID * msgidPermNames ;
        PSED_APPLICATION_ACCESS pappaccess ;
        ULONG hcMainDlg, hcSpecial, hcNewItemSpecial, hcAddUser,
                         hcAddMemberLG, hcAddMemberGG, hcAddSearch ;
        ACCESS_MASK WriteAccessReq ;
        BOOL fPrivAdjusted = FALSE;
        ULONG ulAuditPriv  = SE_SECURITY_PRIVILEGE ;

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            hcAddUser        = HC_SED_USER_BROWSER_DIALOG ;
            hcAddMemberLG    = HC_SED_USER_BROWSER_LOCALGROUP ;
            hcAddMemberGG    = HC_SED_USER_BROWSER_GLOBALGROUP ;
            hcAddSearch      = HC_SED_USER_BROWSER_FINDUSER ;
            WriteAccessReq   = WRITE_DAC ;

            if ( fIsFile )
            {
                cArrayItems = COUNT_FILEPERMS_ARRAY ;
                msgidPermNames = msgidFilePermNames ;
                pappaccess = sedappaccessFilePerms ;
                hcMainDlg        = HC_SED_NT_FILE_PERMS_DLG ;
                hcSpecial        = HC_SED_NT_SPECIAL_FILES_FM ;
            }
            else
            {
                cArrayItems = COUNT_DIRPERMS_ARRAY ;
                msgidPermNames = msgidDirPermNames ;
                pappaccess = sedappaccessDirPerms ;
                hcMainDlg        = HC_SED_NT_DIR_PERMS_DLG ;
                hcSpecial        = HC_SED_NT_SPECIAL_DIRS_FM ;
                hcNewItemSpecial = HC_SED_NT_SPECIAL_NEW_FILES_FM ;
            }
            break ;

        case SED_AUDITS:
            hcAddUser        = HC_SED_USER_BROWSER_AUDIT_DLG ;
            hcAddMemberLG    = HC_SED_USER_BR_AUDIT_LOCALGROUP ;
            hcAddMemberGG    = HC_SED_USER_BR_AUDIT_GLOBALGROUP ;
            hcAddSearch      = HC_SED_USER_BR_AUDIT_FINDUSER ;
            WriteAccessReq   = ACCESS_SYSTEM_SECURITY ;

            if ( fCheckSecurity )
            {
                if (err = ::NetpGetPrivilege( 1, &ulAuditPriv ) )
                {
                    break ;
                }
                else
                    fPrivAdjusted = TRUE ;
            }

            if ( fIsFile )
            {
                cArrayItems = COUNT_FILE_AUDITPERMS_ARRAY ;
                msgidPermNames = msgidFileAuditNames ;
                pappaccess = sedappaccessFileAudits ;
                hcMainDlg        = HC_SED_NT_FILE_AUDITS_DLG ;
            }
            else
            {
                cArrayItems = COUNT_DIR_AUDITPERMS_ARRAY ;
                msgidPermNames = msgidDirAuditNames ;
                pappaccess = sedappaccessDirAudits ;
                hcMainDlg        = HC_SED_NT_DIR_AUDITS_DLG ;
            }
            break ;

        default:
            UIASSERT(!SZ("Bad permission type")) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

        if ( fCheckSecurity )
        {
            BOOL fCanWrite ;
            if ( err = ::CheckFileSecurity( pszSecCheckFile,
                                            WriteAccessReq,
                                            &fCanWrite ) )
            {
                break ;
            }
            fCantWrite = !fCanWrite ;

            if ( fPrivAdjusted )
                NetpReleasePrivilege() ;
        }

        /* Loop through each permission title retrieving the text from the
         * resource file and setting the pointer in the array.  The memory
         * will be deleted when strlistPermNames is destructed.
         */
        STRLIST strlistPermNames ;
        for ( UINT i = 0 ; i < cArrayItems ; i++ )
        {
            RESOURCE_STR * pnlsPermName = new RESOURCE_STR( msgidPermNames[i]) ;
            err = (pnlsPermName==NULL) ? ERROR_NOT_ENOUGH_MEMORY :
                                         pnlsPermName->QueryError() ;
            if (  err ||
                 (err = strlistPermNames.Add( pnlsPermName )) )
            {
                delete pnlsPermName ;
                break ;
            }
            pappaccess[i].PermissionTitle = (LPTSTR) pnlsPermName->QueryPch() ;
        }
        if ( err )
            break ;

        SED_APPLICATION_ACCESSES SedAppAccesses ;
        SedAppAccesses.Count           = cArrayItems ;
        SedAppAccesses.AccessGroup     = pappaccess ;
        SedAppAccesses.DefaultPermName = (LPTSTR) nlsDefaultPermName.QueryPch() ;
        sedhelpinfo.aulHelpContext[HC_MAIN_DLG]                    = hcMainDlg ;
        sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = hcSpecial ;
        sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = hcNewItemSpecial ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG]                = hcAddUser ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG]     = hcAddMemberLG ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG]     = hcAddMemberGG ;
        sedhelpinfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] = hcAddSearch ;



        DWORD dwSedReturnStatus ;
        NTFS_CALLBACK_INFO callbackinfo ;
        callbackinfo.hwndFMXOwner = hwndParent ;

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            callbackinfo.sedpermtype= SED_ACCESSES ;
            err = SedDiscretionaryAclEditor( hwndParent,
                                            ::hModule,
                                            (LPTSTR) pszServer,
                                            &sedobjdesc,
                                            &SedAppAccesses,
                                            (LPTSTR) pszResource,
                                            (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
                                            (ULONG_PTR) &callbackinfo,
                                            pSecurityDesc,
                                            (BOOLEAN)fCantRead,
                                            (BOOLEAN)fCantWrite,
                                            &dwSedReturnStatus,
                                            0 ) ;
            break ;

        case SED_AUDITS:
            callbackinfo.sedpermtype = SED_AUDITS ;
            err = SedSystemAclEditor( hwndParent,
                                     ::hModule,
                                     (LPTSTR) pszServer,
                                     &sedobjdesc,
                                     &SedAppAccesses,
                                     (LPTSTR) pszResource,
                                     (PSED_FUNC_APPLY_SEC_CALLBACK) SedCallback,
                                     (ULONG_PTR) &callbackinfo,
                                     pSecurityDesc,
                                     fCantRead || fCantWrite,
                                     &dwSedReturnStatus,
                                     0 ) ;
            break ;

        default:
            UIASSERT(!SZ("Bad type") ) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

    } while (FALSE) ;

    /* We need to revert to ourselves if we were doing auditting
     */
    if ( fPrivAdjusted )
    {
        APIERR errTmp = NetpReleasePrivilege() ;
        if ( errTmp )
        {
            DBGEOL("::EditNTFSAcl - Warning: NetpReleasePrivilege return error "
                   << errTmp ) ;
        }
    }

    TRACEEOL(SZ("::EditNTFSAcl returning error code ") << (ULONG) err ) ;

    if ( err )
    {
        ::MsgPopup( hwndParent, (MSGID) err ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       SedCallback

    SYNOPSIS:   Security Editor callback for the NTFS ACL Editor

    ENTRY:      See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:      The callback context should be the FMX Window handle.  This
                is so we can support setting permissions on multiple files/
                directories if we ever decide to do that.

    HISTORY:
        Johnl   17-Mar-1992     Filled out

********************************************************************/


DWORD SedCallback( HWND                   hwndParent,
                   HANDLE                 hInstance,
                   ULONG_PTR              ulCallbackContext,
                   PSECURITY_DESCRIPTOR   psecdesc,
                   PSECURITY_DESCRIPTOR   psecdescNewObjects,
                   BOOLEAN                fApplyToSubContainers,
                   BOOLEAN                fApplyToSubObjects,
                   LPDWORD                StatusReturn
                 )
{
    UNREFERENCED( hInstance ) ;
    APIERR err = NO_ERROR ;
    NTFS_CALLBACK_INFO *pcallbackinfo = (NTFS_CALLBACK_INFO *)ulCallbackContext;
    HWND hwndFMXWindow = pcallbackinfo->hwndFMXOwner ;
    OS_SECURITY_INFORMATION osSecInfo ;
    BOOL fDepthFirstTraversal = TRUE ;
    BOOL fApplyToDirContents  = FALSE ;
    BOOL fIsFile ;
    BOOL fBlowAwayDACLOnCont  = FALSE ;
    NLS_STR nlsSelItem( 128 ) ;
    RESOURCE_STR nlsCancelDialogTitle( IDS_CANCEL_TASK_APPLY_DLG_TITLE ) ;
    BOOL fPrivAdjusted = FALSE;

    if ( (err = nlsSelItem.QueryError()) ||
         (err = nlsCancelDialogTitle.QueryError()) ||
         (err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile )) )
    {
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        ::MsgPopup( hwndParent, (MSGID) err ) ;
        return err ;
    }

    switch ( pcallbackinfo->sedpermtype )
    {
    case SED_ACCESSES:
        osSecInfo.SetDACLReference( TRUE ) ;
        fApplyToDirContents = !fIsFile && fApplyToSubObjects ;

        //
        //  Check to see if we should do a depth first or breadth first
        //  traversal of the selected directory.  If we have traverse
        //  on the directory already, then do depth first.  If we don't,
        //  then do a breadth first and hope we are granting ourselves
        //  traverse.
        //
        if ( fApplyToSubContainers || fApplyToDirContents )
        {
            if ( err = ::CheckFileSecurity( nlsSelItem,
                                            FILE_TRAVERSE | FILE_LIST_DIRECTORY,
                                            &fDepthFirstTraversal ))
            {
                DBGEOL("SedCallBack - ::CheckFileSecurity failed with error " << err ) ;
                *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
                ::MsgPopup( hwndParent, (MSGID) err ) ;
                return err ;
            }
            TRACEEOL("SedCallBack - Depth first = " << fDepthFirstTraversal ) ;
        }
        break ;

    case SED_AUDITS:
        {
            osSecInfo.SetSACLReference( TRUE ) ;
            fApplyToDirContents = !fIsFile && fApplyToSubObjects ;;
            ULONG ulAuditPriv  = SE_SECURITY_PRIVILEGE ;

            if (err = ::NetpGetPrivilege( 1, &ulAuditPriv ) )
            {
                break ;
            }
            else
                fPrivAdjusted = TRUE ;
        }
        break ;

    case SED_OWNER:

        osSecInfo.SetOwnerReference( TRUE ) ;

        //
        //  Do a breadth first traversal since taking ownership grants
        //  additional privileges
        //
        fDepthFirstTraversal = FALSE ;

        //
        //  Containers and objects get the same security descriptor
        //
        psecdescNewObjects = psecdesc ;

        if ( !fIsFile )
        {
            switch ( ::MsgPopup( hwndParent,
                                 IDS_OWNER_APPLY_TO_DIR_PROMPT,
                                 MPSEV_INFO,
                                 MP_YESNOCANCEL ))
            {
            case IDYES:
                fApplyToSubContainers = TRUE ;
                fApplyToSubObjects    = TRUE ;
                fBlowAwayDACLOnCont   = TRUE ;
                fApplyToDirContents   = TRUE ;
                break ;

            case IDNO:
                fApplyToSubContainers = FALSE ;
                fApplyToSubObjects    = FALSE ;
                fBlowAwayDACLOnCont   = FALSE ;
                fApplyToDirContents   = FALSE ;
                break ;

            case IDCANCEL:
            default:
                *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
                return ERROR_GEN_FAILURE ;  // any nonzero error code
            }
        }

        break ;

    default:
        UIASSERT( FALSE ) ;
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return ERROR_GEN_FAILURE ;
    }

    FMX fmx( hwndFMXWindow );
    UINT uiCount = fmx.QuerySelCount() ;
    BOOL fDismissDlg = TRUE ;

    //
    //  QuerySelCount only returns the number of selections in the files window,
    //  thus if the focus is in the directory window, then we will just make
    //  the selection count one for out "for" loop.
    //
    if ( fmx.QueryFocus() == FMFOCUS_TREE )
    {
        uiCount = 1 ;
    }

    //
    //  If we only have to apply permissions to a single item or we are
    //  taking ownership of a file, then just
    //  do it w/o bringing up the cancel task dialog.
    //
    if (  uiCount == 1 &&
          !fApplyToSubContainers &&
          !fApplyToSubObjects    &&
          !fApplyToDirContents )
    {
        // Try Admins Group First
        OS_SECURITY_DESCRIPTOR osSecAdmin;
        OS_SID ossidAdmins;

        NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                             &ossidAdmins );
        osSecAdmin.SetOwner(ossidAdmins);
        osSecAdmin.SetGroup(ossidAdmins);

        //
        // CODEWORK We skip this hack unless taking ownership.  Note that the
        // osSecAdmin and ossidAdmins should also be removed.
        //
        if ( SED_OWNER != pcallbackinfo->sedpermtype
          || !::SetFileSecurity( (LPTSTR) nlsSelItem.QueryPch(),
                                          osSecInfo,
                                          osSecAdmin.QueryDescriptor() ) )
        {// if it fails try owner account
            if ( !::SetFileSecurity( (LPTSTR) nlsSelItem.QueryPch(),
                                              osSecInfo,
                                              psecdesc ) )
            {
                err = ::GetLastError() ;
            }
        }
        if ( err )
        {
            DBGEOL("NTFS SedCallback - Error " << (ULONG)err << " applying security to " <<
               nlsSelItem ) ;
            ::MsgPopup( hwndParent, (MSGID) err ) ;
            *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        }
    }
    else
    {
        NTFS_TREE_APPLY_CONTEXT Ctxt( nlsSelItem, osSecInfo ) ;
        Ctxt.State                = APPLY_SEC_FMX_SELECTION ;
        Ctxt.hwndFMXWindow        = hwndFMXWindow ;
        Ctxt.sedpermtype          = pcallbackinfo->sedpermtype ;
        Ctxt.iCurrent             = 0 ;
        Ctxt.uiCount              = uiCount ;
        Ctxt.fDepthFirstTraversal = fDepthFirstTraversal ;
        Ctxt.fApplyToDirContents  = fApplyToDirContents ;
        Ctxt.fBlowAwayDACLOnCont  = fBlowAwayDACLOnCont ;
        Ctxt.StatusReturn         = StatusReturn ;
        Ctxt.psecdesc             = psecdesc ;
        Ctxt.psecdescNewObjects   = psecdescNewObjects ;
        Ctxt.fApplyToSubContainers= fApplyToSubContainers ;
        Ctxt.fApplyToSubObjects   = fApplyToSubObjects ;

        NTFS_CANCEL_TREE_APPLY CancelTreeApply( hwndParent,
                                                &Ctxt,
                                                nlsCancelDialogTitle ) ;

        if ( (err = CancelTreeApply.QueryError()) ||
             (err = CancelTreeApply.Process( &fDismissDlg )) )
        {
            *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
            ::MsgPopup( hwndParent, (MSGID) err ) ;
        }
    }

    if ( !err )
    {
        //
        // Refresh the file manager window if permissions is updated
        // (Take ownership of a tree also writes a new DACL)
        //
        if ( pcallbackinfo->sedpermtype == SED_ACCESSES ||
             pcallbackinfo->sedpermtype == SED_OWNER )
        {
            fmx.Refresh();
        }

        if ( *StatusReturn == 0 )
            *StatusReturn = SED_STATUS_MODIFIED ;
    }

    if ( fPrivAdjusted )
    {
        APIERR errTmp = NetpReleasePrivilege() ;
        if ( errTmp )
        {
            DBGEOL("::EditNTFSAcl - Warning: NetpReleasePrivilege return error "
                   << errTmp ) ;
        }
    }

    if ( !err && !fDismissDlg )
    {
        //
        //  Don't dismiss the dialog if the user canceled the tree
        //  apply.  This tells the ACL editor not to dismiss the permissions
        //  dialog (or auditing or owner).
        //
        err = ERROR_GEN_FAILURE ;
    }

    return err ;
}

/*******************************************************************

    NAME:       CANCEL_TREE_APPLY::DoOneItem

    SYNOPSIS:   This is the time slice call for the tree apply

    ENTRY:      ulContext - Context passed to the constructor

    RETURNS:    NERR_Success if this time slice was successful, error
                code otherwise (which will be displayed to the user).

    NOTES:

    HISTORY:
        Johnl   22-Oct-1992     Created

********************************************************************/

APIERR CANCEL_TREE_APPLY::DoOneItem( ULONG_PTR ulContext,
                                     BOOL  *pfContinue,
                                     BOOL  *pfDisplayErrors,
                                     MSGID *pmsgidAlternateMessage )
{
    TREE_APPLY_CONTEXT * pCtxt = (TREE_APPLY_CONTEXT*) ulContext ;
    *pfDisplayErrors = TRUE ;
    *pfContinue      = TRUE ;
    APIERR err = NERR_Success ;
    APIERR errTrav = NERR_Success;
    BOOL fSuccess ;

    switch ( pCtxt->State )
    {
    case APPLY_SEC_IN_FS_ENUM:
        {
            UIASSERT( pCtxt->pfsenum != NULL ) ;

            fSuccess = pCtxt->pfsenum->Next() ;

            NLS_STR nlsFileName ;
            if ( (err = nlsFileName.QueryError()) ||
                 (err = pCtxt->pfsenum->QueryName( &nlsFileName )))
            {
                break ;
            }

            REQUIRE( UpdateStatus( nlsFileName ) == NERR_Success ) ;

            //
            //  Only write the security if the enumeration was successful
            //
            if ( fSuccess )
            {
ApplySecurity:
                err = WriteSecurity( ulContext,
                                     nlsFileName,
                                     !(pCtxt->pfsenum->QueryAttr()&_A_SUBDIR),
                                     pfContinue ) ;
                if ( !*pfContinue )
                {
                    delete pCtxt->pfsenum ;
                    pCtxt->pfsenum = NULL ;
                }

                //
                //  Report any traversal errors after attempting to apply
                //  security to the container we failed to traverse
                //

                if ( errTrav )
                    err = errTrav;

                break ;
            }
            else if ((err = pCtxt->pfsenum->QueryLastError()) != ERROR_NO_MORE_FILES)
            {
                *pmsgidAlternateMessage = IDS_CANCEL_TASK_TRAV_ERROR_MSG ;

                //
                //  Apply security even in the error case if we're not at the
                //  selected directory.  This handles the case of hitting a no
                //  access directory as the only selection
                //

                if ( pCtxt->pfsenum->QueryTotalFiles() )
                {
                    errTrav = err;
                    goto ApplySecurity;
                }

                //
                //  falls through and deletes the enumerator
                //
            }
            else
            {
                //
                //  Running out of files is a success error code
                //
                err = NERR_Success ;
                TRACEEOL("SedCallBack - Traversed " << pCtxt->pfsenum->QueryTotalFiles() <<
                        " files and directories") ;
            }
            delete pCtxt->pfsenum ;
            pCtxt->pfsenum = NULL ;
            pCtxt->State = APPLY_SEC_FMX_POST_FS_ENUM ;
        }
        break ;


    case APPLY_SEC_FMX_POST_FS_ENUM:
        //
        //  Apply security to the container after everything under this has
        //  been applied if we are doing a depth first traversal.
        //
        if ( pCtxt->fDepthFirstTraversal )
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;
            if ( err = WriteSecurity( ulContext,
                                      pCtxt->nlsSelItem,
                                      pCtxt->fIsSelFile,
                                      pfContinue ))
            {
                // Fall through
            }
        }
        pCtxt->State = APPLY_SEC_FMX_SELECTION ;
        break ;

    case APPLY_SEC_FMX_SELECTION:

        /* Have we went through all of the selected items?
         */
        if ( pCtxt->iCurrent >= pCtxt->uiCount )
        {
            *pfContinue = FALSE ;
            break ;
        }

        /* Get the current selection and apply the permissions
         */
        if (err = ::GetSelItem( pCtxt->hwndFMXWindow,
                                pCtxt->iCurrent++,
                                &pCtxt->nlsSelItem,
                                &pCtxt->fIsSelFile ) )
        {
            break ;
        }

        //
        //  If we're doing the breadthfirst traversal, then apply to the
        //  container before traversing, else apply after traversing.
        //  If it's a file, then always apply.
        //
        if (( !pCtxt->fDepthFirstTraversal || pCtxt->fIsSelFile ) ||
            ( (!pCtxt->fApplyToSubContainers && !pCtxt->fApplyToDirContents) &&
              !pCtxt->fIsSelFile ))
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;
            if ( err = WriteSecurity( ulContext,
                                      pCtxt->nlsSelItem,
                                      pCtxt->fIsSelFile,
                                      pfContinue ))
            {
                break ;
            }
        }

        //
        //  If the user checked the apply to tree box or apply to existing file
        //  checkbox and this is a container then apply the
        //  permissions down the sub-tree optionally to files
        //
        if ( (pCtxt->fApplyToSubContainers || pCtxt->fApplyToDirContents)
             && !pCtxt->fIsSelFile )
        {
            UpdateStatus( pCtxt->nlsSelItem ) ;

            //
            //  Determine whether we should apply permissions to both
            //  directories and files, directories only or files only
            //
            enum FILE_TYPE filetype ;
            switch ((pCtxt->fApplyToSubContainers << 1) + pCtxt->fApplyToDirContents )
            {
            case 3:
                filetype = FILTYP_ALL_FILES ;
                break ;

            case 2:
                filetype = FILTYP_DIRS ;
                break ;

            case 1:
                filetype = FILTYP_FILES ;
                break ;

            default:
                UIASSERT( FALSE ) ;
            }

            pCtxt->pfsenum = new W32_FS_ENUM( pCtxt->nlsSelItem,
                                              SZ("*.*"),
                                              filetype,
                                              pCtxt->fDepthFirstTraversal,
                                              pCtxt->fApplyToSubContainers ?
                                                      0xffffffff : 0 ) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( pCtxt == NULL ||
                 (err = pCtxt->pfsenum->QueryError() ))
            {
                break ;
            }
            //
            //  Next time around, start doing the enumeration
            //
            pCtxt->State = APPLY_SEC_IN_FS_ENUM ;
        }
        break ;
    }

    if ( err && *pCtxt->StatusReturn == 0 )
    {
        *pCtxt->StatusReturn = (pCtxt->iCurrent-1 ? SED_STATUS_NOT_ALL_MODIFIED :
                                SED_STATUS_FAILED_TO_MODIFY);
    }

    return err ;
}

/*******************************************************************

    NAME:       NTFS_CANCEL_TREE_APPLY::WriteSecurity

    SYNOPSIS:   Write security to an NTFS volume

    ENTRY:      ulContext - Pointer to NTFS_TREE_APPLY_CONTEXT
                pszFileName - File to apply to
                fIsFile - TRUE if object, FALSE if container
                pfContinue - Set to FALSE if the apply should be
                    terminated.

    RETURNS:    NERR_Success if successful, error code otherwise

    HISTORY:
        Johnl   23-Oct-1992     Created

********************************************************************/

APIERR NTFS_CANCEL_TREE_APPLY::WriteSecurity( ULONG_PTR     ulContext,
                                              const TCHAR * pszFileName,
                                              BOOL          fIsFile,
                                              BOOL        * pfContinue )
{
    APIERR err = NERR_Success ;
    NTFS_TREE_APPLY_CONTEXT * pCtxt = (NTFS_TREE_APPLY_CONTEXT*) ulContext ;
    SECURITY_INFORMATION SecInfoTmp = (SECURITY_INFORMATION) pCtxt->osSecInfo ;
    *pfContinue = TRUE ;

    //
    //  If any of the "container" flags are set and we are looking at a
    //  file, then use the object security descriptor, else use the container
    //  /object security descriptor.
    //
    PSECURITY_DESCRIPTOR psecdescTmp =  fIsFile &&
                                       (pCtxt->fApplyToSubContainers ||
                                        pCtxt->fApplyToSubObjects    ||
                                        pCtxt->fApplyToDirContents) ?
                                          pCtxt->psecdescNewObjects :
                                          pCtxt->psecdesc ;

    //
    //  Taking ownership also optionally blows away the DACL at the user's
    //  request
    //
    if ( !fIsFile && (pCtxt->sedpermtype == SED_OWNER) )
    {
        OS_ACL osDACL ;
        OS_ACE osACE ;
        OS_SID ossidUser ;
        OS_SECURITY_DESCRIPTOR ossecdesc( psecdescTmp, TRUE ) ;

        if ( (err = osDACL.QueryError())    ||
             (err = osACE.QueryError())     ||
             (err = ossidUser.QueryError()) ||
             (err = ossecdesc.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessOwner,
                                                         &ossidUser )) )
        {
            // Fall through
        }

        if ( !err )
        {
            //
            //  Put an ACE that grants full control and that will be
            //  inherited to new objects and new containers on this
            //  container.  The SID is the currently logged on user.
            //
            osACE.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;
            osACE.SetInheritFlags( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) ;
            osACE.SetAccessMask( GENERIC_ALL ) ;

            if ( (err = osACE.SetSID( ossidUser )) ||
                 (err = osDACL.AddACE( 0, osACE )) ||
                 (err = ossecdesc.SetDACL( TRUE, &osDACL )) )
            {
                // Fall through
            }
        }

        if ( !err)
        {
            OS_SECURITY_DESCRIPTOR osSecAdmin;
            OS_SID ossidAdmins;
            NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                                 &ossidAdmins );
            osSecAdmin.SetOwner(ossidAdmins);
            osSecAdmin.SetGroup(ossidAdmins);
            osSecAdmin.SetDACL( TRUE, &osDACL );
            // Try Admins Group First
            if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                              SecInfoTmp,
                                              osSecAdmin.QueryDescriptor() ) )
            {
                // if it fails try owner account
                if (!::SetFileSecurity( (LPTSTR) pszFileName,  // Take ownership
                                      SecInfoTmp,
                                      ossecdesc ))
                {
                    err = ::GetLastError() ;
                }
            }
        }
        //
        //  Now check if they have traversal permission.  If they do, then
        //  leave the ACL alone, else ask them if they want to blow away the
        //  DACL
        //
        BOOL fCanTraverse ;
        if ( !err &&
             !(err = ::CheckFileSecurity( (LPTSTR) pszFileName,
                                           FILE_TRAVERSE | FILE_LIST_DIRECTORY,
                                           &fCanTraverse )) &&
             !fCanTraverse )
        {
            switch ( ::MsgPopup( this,
                                 IDS_OWNER_NUKE_DACL_WARNING,
                                 MPSEV_INFO,
                                 MP_YES| MP_CANCEL,
                                 pszFileName ))
            {
            case IDYES:


                if ( !::SetFileSecurity( (LPTSTR) pszFileName,  // Blow away DACL
                                         DACL_SECURITY_INFORMATION,
                                         ossecdesc ))
                {
                    err = ::GetLastError() ;
                }
                break ;

            default:
            case IDNO:
            case IDCANCEL:
                *pfContinue = FALSE ;
                break ;
            }
        }
    }
    else    // if ( !fIsFile && (pCtxt->sedpermtype == SED_OWNER) )
    {
        if ((pCtxt->sedpermtype == SED_OWNER))
        {
            OS_SECURITY_DESCRIPTOR osSecAdmin;
            OS_SID ossidAdmins;
            NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                                 &ossidAdmins );
            osSecAdmin.SetOwner(ossidAdmins);
            osSecAdmin.SetGroup(ossidAdmins);

            // Try Admins Group First
            if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                          SecInfoTmp,
                                          osSecAdmin.QueryDescriptor() ) )
            {
                // if it fails try owner account
                if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                      SecInfoTmp,
                                      psecdescTmp ))
                {
                    err = ::GetLastError() ;
                }
            }
        }
        else if ( !::SetFileSecurity( (LPTSTR) pszFileName,
                                      SecInfoTmp,
                                      psecdescTmp ))
            {
                err = ::GetLastError() ;
            }
    }
    return err ;
}

/*******************************************************************

    NAME:       CompareNTFSSecurityIntersection

    SYNOPSIS:   Determines if the files/dirs currently selected have
                equivalent security descriptors

    ENTRY:      hwndFMX - FMX Hwnd used for getting selection
                sedpermtype - Interested in DACL or SACL
                psecdesc - Baseline security descriptor to compare against
                pfOwnerEqual - Set to TRUE if all the owners are equal
                pfACLEqual - Set to TRUE if all of the DACLs/SACLs are
                    equal.  If FALSE, then pfOwnerEqual should be ignored

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The first non-equal ACL causes the function to exit.

                On a 20e with 499 files selected locally, it took 35.2 minutes
                to read the security descriptors from the disk and 14 seconds
                to determine the intersection.  So even though the Compare
                method uses an n^2 algorithm, it only takes up 0.6% of the
                wait time.

    HISTORY:
        Johnl   05-Nov-1992      Created

********************************************************************/

APIERR CompareNTFSSecurityIntersection( HWND hwndFMX,
                                        enum SED_PERM_TYPE sedpermtype,
                                        PSECURITY_DESCRIPTOR psecdesc,
                                        BOOL * pfOwnerEqual,
                                        BOOL * pfACLEqual,
                                        NLS_STR *        pnlsFailingFile,
                                        PGENERIC_MAPPING pGenericMapping,
                                        PGENERIC_MAPPING pGenericMappingObjects,
                                        BOOL             fMapGenAll,
                                        BOOL             fIsContainer )
{
    TRACEEOL("::CompareNTFSSecurityIntersection - Entered @ " << ::GetTickCount()/100) ;

    FMX fmx( hwndFMX );
    UIASSERT( fmx.QuerySelCount() > 1 ) ;
    APIERR err ;
    OS_SECURITY_DESCRIPTOR ossecdesc1( psecdesc ) ;
    UINT cSel = fmx.QuerySelCount() ;

    NLS_STR nlsSel( PATHLEN ) ;
    BUFFER  buffSecDescData( 1024 ) ;
    if ( (err = nlsSel.QueryError()) ||
         (err = buffSecDescData.QueryError()) )
    {
        return err ;
    }

    *pfOwnerEqual = TRUE ;
    *pfACLEqual = TRUE ;

    for ( UINT i = 1 ; i < cSel ; i++ )
    {
        if ( (err = ::GetSelItem( hwndFMX, i, &nlsSel, NULL )) ||
             (err = ::GetSecurity( nlsSel,
                                   &buffSecDescData,
                                   sedpermtype,
                                   NULL )) )
        {
            break ;
        }

        BOOL fACLEqual = FALSE ;
        BOOL fOwnerEqual = FALSE ;
        PSECURITY_DESCRIPTOR psecdesc2 = (PSECURITY_DESCRIPTOR)
                                                  buffSecDescData.QueryPtr() ;

        OS_SECURITY_DESCRIPTOR ossecdesc2( psecdesc2 ) ;
        if ( (err = ossecdesc2.QueryError()) ||
             (err = ossecdesc1.Compare( &ossecdesc2,
                                        &fOwnerEqual,
                                         NULL,
                                        sedpermtype == SED_ACCESSES ?
                                                &fACLEqual : NULL,
                                        sedpermtype == SED_AUDITS   ?
                                                &fACLEqual : NULL ,
                                        pGenericMapping,
                                        pGenericMappingObjects,
                                        fMapGenAll,
                                        fIsContainer )) )

        {
            break ;
        }

        if ( !fACLEqual )
        {
            *pfACLEqual = FALSE ;
            return pnlsFailingFile->CopyFrom( nlsSel ) ;
        }

        if ( *pfOwnerEqual && !fOwnerEqual )
        {
            *pfOwnerEqual = FALSE ;
        }
    }

    //
    //  Some errors aren't fatal (like ERROR_ACCESS_DENIED)
    //
    APIERR errtmp = pnlsFailingFile->CopyFrom( nlsSel ) ;
    if ( errtmp )
        err = errtmp ;

    TRACEEOL("::CompareNTFSSecurityIntersection - Left    @ " << ::GetTickCount()/100) ;
    return err ;
}



/*******************************************************************

    NAME:       EditOwnerInfo

    SYNOPSIS:   This function sets up the parameters for calling the
                SedTakeOwnership API.

    ENTRY:      hwndFMXWindow - Window handle received by the File manager
                extensions.

    NOTES:

    HISTORY:
        Johnl   13-Feb-1992     Implemented with real code

********************************************************************/

void EditOwnerInfo( HWND  hwndFMXWindow )
{
    AUTO_CURSOR cursorHourGlass ;

    APIERR err = NERR_Success;
    BOOL   fIsFile ;
    BOOL   fCantRead  = FALSE ;                   // Did we read the Owner?
    BOOL   fCantWrite = FALSE ;                   // Can we write the owner?
    UINT   uiCount ;
    NLS_STR nlsSelItem;


    PSECURITY_DESCRIPTOR psecdesc = NULL ;
    BUFFER buffSecDescData( 1024 ) ;
    RESOURCE_STR nlsHelpFileName( IDS_FILE_PERM_HELP_FILE ) ;

    if (  ( err = buffSecDescData.QueryError() )
       || ( err = nlsHelpFileName.QueryError() )
       )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    FMX fmx( hwndFMXWindow );

    /* If the focus is in tree portion of the filemanager (left pane) then
     * one directory is selected.
     */
    uiCount = (fmx.QueryFocus() == FMFOCUS_TREE ? 1 : fmx.QuerySelCount()) ;
    DBGEOL( SZ("::EditOwnerInfo - ") << uiCount << SZ(" files selected")) ;

    BOOL fIsNTFS ;
    BOOL fIsLocal ;
    NLS_STR  nlsServer( RMLEN ) ;
    if ( (err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile )) ||
         (err = ::IsNTFS( nlsSelItem, &fIsNTFS ))                        ||
         (err = nlsServer.QueryError()))
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    err = ::TargetServerFromDosPath( nlsSelItem,
                                     &fIsLocal,
                                     &nlsServer );

    if ( err == NERR_InvalidDevice )
    {
        NLS_STR nlsDrive( nlsSelItem );
        ISTR istr( nlsDrive );

        err = nlsDrive.QueryError();
        if ( err == NERR_Success )
        {
            istr += 2;
            nlsDrive.DelSubStr( istr );

            err = WNetFMXEditPerm( (LPWSTR) nlsDrive.QueryPch(),
                                   hwndFMXWindow,
                                   WNPERM_DLG_OWNER );
        }
    }

    if ( err != NERR_Success )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err );
        return;
    }

    if ( !fIsNTFS )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) IERR_OWNER_NOT_NTFS_VOLUME ) ;
        return ;
    }

    /* We display the filename and get the security descriptor
     * if there is only 1 item selected
     */
    if ( uiCount == 1)
    {
        switch ( err = ::GetSecurity( nlsSelItem,
                                          &buffSecDescData,
                                          SED_OWNER,
                                          NULL ) )
        {
        case NO_ERROR:
            psecdesc = (PSECURITY_DESCRIPTOR) buffSecDescData.QueryPtr() ;
            break ;

        case ERROR_ACCESS_DENIED:
            err = NERR_Success ;
            fCantRead = TRUE ;
            psecdesc  = NULL ;
            break ;

        default:
            {
                ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
                return ;
            }
        }

    }

    MSGID  msgidObjType = 0, msgidObjName = 0 ;
    if ( uiCount > 1 )
    {
        msgidObjType = IDS_FILES_AND_DIRS ;
    }
    else
    {
        if ( fIsFile )
            msgidObjType = IDS_FILE ;
        else
            msgidObjType = IDS_DIRECTORY ;

        BOOL fPrivAdjusted = FALSE;
        ULONG ulOwnerPriv  = SE_TAKE_OWNERSHIP_PRIVILEGE ;

        if ( (err = ::NetpGetPrivilege( 1, &ulOwnerPriv )) &&
             (err != ERROR_PRIVILEGE_NOT_HELD) )
        {
            ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
            return ;
        }
        else
        {
            BOOL fCanWrite ;
            if ( err = ::CheckFileSecurity( nlsSelItem,
                                            WRITE_OWNER,
                                            &fCanWrite ))
            {
                ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
                ::NetpReleasePrivilege() ;
                return ;
            }

            fCantWrite = !fCanWrite ;
            ::NetpReleasePrivilege() ;
        }
    }

    RESOURCE_STR nlsTypeName( msgidObjType ) ;
    if ( (err = nlsSelItem.QueryError() ) ||
         (err = nlsTypeName.QueryError())   )
    {
        ::MsgPopup( hwndFMXWindow, (MSGID) err ) ;
        return ;
    }

    NTFS_CALLBACK_INFO callbackinfo ;
    callbackinfo.hwndFMXOwner = hwndFMXWindow ;
    callbackinfo.sedpermtype= SED_OWNER ;

    DWORD dwSedStatus ;

    SED_HELP_INFO sedhelpinfo ;
    sedhelpinfo.pszHelpFileName = (LPWSTR) nlsHelpFileName.QueryPch() ;
    sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = HC_TAKEOWNERSHIP_DIALOG ;

    err = SedTakeOwnership(  hwndFMXWindow,
                             ::hModule,
                             fIsLocal ? NULL : (LPTSTR) nlsServer.QueryPch(),
                             (LPTSTR) nlsTypeName.QueryPch(),
                             uiCount==1 ? (LPTSTR)nlsSelItem.QueryPch() : NULL,
                             uiCount,
                             SedCallback,
                             (ULONG_PTR) &callbackinfo,
                             psecdesc,
                             (BOOLEAN)fCantRead,
                             (BOOLEAN)fCantWrite,
                             &dwSedStatus,
                             &sedhelpinfo,
                             0
                             ) ;
}

/*******************************************************************

    NAME:       ::GetSecurity

    SYNOPSIS:   Retrieves a security descriptor from an NTFS file/directory

    ENTRY:      pszFileName - Name of file/dir to get security desc. for
                pbuffSecDescData - Buffer to store the data into
                sedpermtype - Are we getting audit/access info
                pfAuditPrivAdjusted - Set to TRUE if audit priv was enabled.
                    Set this to NULL if the privilege has already been adjusted

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   05-Nov-1992     Broke out

********************************************************************/

APIERR GetSecurity( const TCHAR *      pszFileName,
                        BUFFER *           pbuffSecDescData,
                        enum SED_PERM_TYPE sedpermtype,
                        BOOL  *            pfAuditPrivAdjusted )
{
    OS_SECURITY_INFORMATION osSecInfo ;
    DWORD dwLengthNeeded ;
    APIERR err = NERR_Success ;

    if ( pfAuditPrivAdjusted )
        *pfAuditPrivAdjusted = FALSE ;

    do { // error breakout
        if ( (err = pbuffSecDescData->QueryError()) )
        {
            break ;
        }

        switch ( sedpermtype )
        {
        case SED_ACCESSES:
            osSecInfo.SetDACLReference() ;
            //
            //  Fall through, we want the owner and group if we are getting
            //  the DACL
            //

        case SED_OWNER:
            osSecInfo.SetOwnerReference() ;
            osSecInfo.SetGroupReference() ;
            break ;

        case SED_AUDITS:
            osSecInfo.SetSACLReference() ;

            if ( pfAuditPrivAdjusted != NULL )
            {
                /* We will need to enable the SeAuditPrivilege to read/write the
                 * SACL for NT.
                 */
                ULONG ulAuditPriv = SE_SECURITY_PRIVILEGE ;
                if ( err = ::NetpGetPrivilege( 1, &ulAuditPriv ))
                {
                    break ;
                }
                *pfAuditPrivAdjusted = TRUE ;
            }
            break ;

        default:
            UIASSERT(FALSE) ;
            err = ERROR_GEN_FAILURE ;
            break ;
        }
        if ( err )
            break ;

        //
        //  Try once with a 1k buffer, if it doesn't fit then we will try again
        //  with the known required size which should succeed unless another
        //  error occurs, in which case we bail.
        //
        BOOL  fCantRead = FALSE ;                   // Did we read the ACL?
        PSECURITY_DESCRIPTOR pSecurityDesc = NULL ;
        if (!::GetFileSecurity( (LPTSTR) pszFileName,
                                osSecInfo,
                                (PSECURITY_DESCRIPTOR)pbuffSecDescData->QueryPtr(),
                                pbuffSecDescData->QuerySize(),
                                &dwLengthNeeded ))
        {
            err = ::GetLastError() ;
            switch ( err )
            {
            case ERROR_INSUFFICIENT_BUFFER:
                {
                    err = pbuffSecDescData->Resize( (UINT) dwLengthNeeded ) ;
                    if ( err )
                        break ;

                    /* If this guy fails then we bail
                     */
                    if (!::GetFileSecurity( (LPTSTR) pszFileName,
                                            osSecInfo,
                                            (PSECURITY_DESCRIPTOR)pbuffSecDescData->QueryPtr(),
                                            pbuffSecDescData->QuerySize(),
                                            &dwLengthNeeded ))
                    {
                        err = ::GetLastError() ;
                        break ;
                    }
                }
                break ;

            default:
                /* Fall through to the next switch statement which is the error
                 * handler for this block
                 */
                break ;
            }
        }
    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       InitializeNTFSGenericMapping

    SYNOPSIS:   Initializes the passed generic mapping structure
                appropriately depending on whether this is a file
                or a directory.

    ENTRY:      pNTFSGenericMapping - Pointer to GENERIC_MAPPING to be init.
                fIsDirectory - TRUE if directory, FALSE if file

    EXIT:

    RETURNS:

    NOTES:      Note that Delete Child was removed from Generic Write.

    HISTORY:
        Johnl   27-Feb-1992     Created

********************************************************************/

void InitializeNTFSGenericMapping( PGENERIC_MAPPING pNTFSGenericMapping,
                                   BOOL fIsDirectory )
{
    UNREFERENCED( fIsDirectory ) ;
    pNTFSGenericMapping->GenericRead    = FILE_GENERIC_READ ;
    pNTFSGenericMapping->GenericWrite   = FILE_GENERIC_WRITE ;
    pNTFSGenericMapping->GenericExecute = FILE_GENERIC_EXECUTE ;
    pNTFSGenericMapping->GenericAll     = FILE_ALL_ACCESS ;

}


/*******************************************************************

    NAME:       ::IsNTFS

    SYNOPSIS:   This function checks the given resource and attempts to
                determine if it points to an NTFS partition.

    ENTRY:      pszResource - Pointer to file/directory name (may be UNC)

                pfIsNTFS - Pointer to BOOL that will receive the results

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   08-May-1992     Created

********************************************************************/

APIERR IsNTFS( const TCHAR * pszResource, BOOL * pfIsNTFS )
{
    UIASSERT( pszResource != NULL && pfIsNTFS != NULL ) ;

    *pfIsNTFS = FALSE ;
    APIERR err    = NERR_Success ;
    DWORD dwAttributes;
    TCHAR szResourceTemp[2 * MAX_PATH]; // Allow for long computer and share names

    do { // error breakout
        lstrcpyn( szResourceTemp, pszResource, sizeof(szResourceTemp) / sizeof(TCHAR) );

        // Strip the path to root form, acceptable to GetVolumeInformation
        if ((szResourceTemp[0] == TEXT('\\')) && (szResourceTemp[1] == TEXT('\\')))
        {
            // It's a UNC path.  Find the fourth backslash (if there is
            // one) and truncate after that character
            int     cBackslashes = 2;
            TCHAR*  pChar = &(szResourceTemp[2]);

            while ((*pChar) && (cBackslashes < 4))
            {
                if (*pChar == TEXT('\\'))
                {
                    cBackslashes++;
                }

                pChar = CharNext(pChar);
            }

            if (*pChar)
            {
                *pChar = TEXT('\0');
            }
            else
            {
                // A bogus path was passed in
                err = ERROR_FILE_NOT_FOUND;
                break;
            }
        }
        else
        {
            // It's a drive-based path.  Truncate after the first three
            // characters ("x:\")
            szResourceTemp[3] = TEXT('\0');
        }

        if ( FALSE == GetVolumeInformation( szResourceTemp,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &dwAttributes,
                                            NULL,
                                            NULL))
        {
            // If we failed because we were denied access, then
            // we can probably assume the filesystem supports ACLs
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                DBGEOL("::IsNTFS - Unable to determine volume information "
                        << " (access denied) assuming the file system is NTFS") ;
                *pfIsNTFS = TRUE;
                break;
            }

            // Otherwise, set an error code and break out
            err = GetLastError();
            DBGEOL("::IsNTFS - GetVolumeInformation failed with error "
                     << (ULONG) err ) ;
            break;
        }

        TRACEEOL("::IsNTFS - File system attributes are " << (HEX_STR) dwAttributes ) ;

        if ( dwAttributes & FS_PERSISTENT_ACLS )
        {
            *pfIsNTFS = TRUE;
        }

    } while ( FALSE );

    return err ;
}

/*******************************************************************

    NAME:       CheckFileSecurity

    SYNOPSIS:   Checks to see if the current user has access to the file or
                directory

    ENTRY:      pszFileName - File or directory name
                DesiredAccess - Access to check for
                pfAccessGranted - Set to TRUE if access was granted

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the check requires enabled privileges, they must be enabled
                before this call.

    HISTORY:
        Johnl   15-Jan-1993     Created

********************************************************************/

APIERR CheckFileSecurity( const TCHAR * pszFileName,
                          ACCESS_MASK   DesiredAccess,
                          BOOL        * pfAccessGranted )
{
    APIERR err = NERR_Success ;
    *pfAccessGranted = TRUE ;

    do { // error breakout

        //
        // Convert the DOS device name ("X:\") to an NT device name
        // (looks something like "\dosdevices\X:\")
        //
        int cbFileName = strlenf( pszFileName ) * sizeof( TCHAR ) ;
        UNICODE_STRING  UniStrNtFileName ;
        ::memsetf( (PVOID)&UniStrNtFileName, '\0', sizeof(UniStrNtFileName) );

        if (!RtlDosPathNameToNtPathName_U( pszFileName,
                                           &UniStrNtFileName,
                                           NULL,
                                           NULL))
        {
            UIASSERT( FALSE ) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        OBJECT_ATTRIBUTES           oa ;
        IO_STATUS_BLOCK             StatusBlock ;
        InitializeObjectAttributes( &oa,
                                    &UniStrNtFileName,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    0 );


        //
        //  Check to see if we have permission/privilege to read the security
        //
        HANDLE hFile ;
        if ( (err = ERRMAP::MapNTStatus(::NtOpenFile(
                               &hFile,
                               DesiredAccess,
                               &oa,
                               &StatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               0 ))) )
        {

            TRACEEOL("CheckFileSecurity - check failed with error " << err <<
                     " with desired access " << (HEX_STR) DesiredAccess ) ;

            if ( err == ERROR_ACCESS_DENIED )
            {
                *pfAccessGranted = FALSE ;
                err = NERR_Success ;
            }
        }
        else
            ::NtClose( hFile ) ;

        if (UniStrNtFileName.Buffer != 0)
            RtlFreeUnicodeString( &UniStrNtFileName );

    } while ( FALSE ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\owner.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*

    Owner.cxx

    This file contains the implementation for the Set Ownership dialog.


    FILE HISTORY:
        Johnl   12-Feb-1992     Created

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_DIALOG
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

extern "C"
{
    #include <netlib.h>         // For NetpGetPrivilege
    #include <mnet.h>
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

#include <stdlib.h>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>
#include <security.hxx>
#include <subject.hxx>
#include <permstr.hxx>
#include <ntacutil.hxx>
#include <uintlsa.hxx>
#include <uintsam.hxx>
#include <strnumer.hxx>
#include <apisess.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <subject.hxx>
#include <perm.hxx>

#include <helpnums.h>
#include <owner.hxx>



/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::TAKE_OWNERSHIP_DLG

    SYNOPSIS:   Constructor for the Take ownership dialog

    ENTRY:      pszDialogName - Resource template
                hwndParent    - Parent window handle
                uiCount       - Number of objects we are about to take
                                ownership of
                pchResourceType - Name of the resource type ("File" etc.)
                pchResourceName - Name of the resource ("C:\status.doc")
                psecdesc        - Pointer to security descriptor that contains
                                  the owner sid.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created
        beng    06-Apr-1992     Replaced ltoa

********************************************************************/


TAKE_OWNERSHIP_DLG::TAKE_OWNERSHIP_DLG(
                    const TCHAR * pszDialogName,
                    HWND          hwndParent,
                    const TCHAR * pszServer,
                    UINT          uiCount,
                    const TCHAR * pchResourceType,
                    const TCHAR * pchResourceName,
                    PSECURITY_DESCRIPTOR psecdesc,
                    PSED_HELP_INFO psedhelpinfo
                   )
    : DIALOG_WINDOW       ( pszDialogName, hwndParent ),
      _sltResourceType    ( this, SLT_OWNER_RESOURCE_TYPE ),
      _sleResourceName    ( this, SLE_OWNER_RESOURCE_NAME ),
      _sltOwner           ( this, SLT_OWNER ),
      _sleOwnerName       ( this, SLE_OWNER_NAME ),
      _sltXObjectsSelected( this, SLT_X_OBJECTS_SELECTED ),
      _buttonTakeOwnership( this, BUTTON_TAKE_OWNERSHIP ),
      _buttonOK           ( this, IDOK ),
      _pszServer          ( pszServer  ),
      _nlsHelpFileName    ( psedhelpinfo->pszHelpFileName ),
      _ulHelpContext      ( psedhelpinfo->aulHelpContext[HC_MAIN_DLG] )
{
    APIERR err ;
    AUTO_CURSOR niftycursor ;

    if ( QueryError() )
        return ;

    if ( err = _nlsHelpFileName.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }

    /* If more then one object is selected, then the dialog only displays
     * the message: "%d Files/Directories Selected", thus we need to
     * disable the other controls and enable the X-Objects selected SLT.
     */
    if ( uiCount > 1 )
    {
        _sltResourceType.Show( FALSE ) ;
        _sltResourceType.Enable( FALSE ) ;
        _sleResourceName.Show( FALSE ) ;
        _sleResourceName.Enable( FALSE ) ;
        _sltOwner.Show( FALSE ) ;
        _sltOwner.Enable( FALSE ) ;
        _sleOwnerName.Show( FALSE ) ;
        _sleOwnerName.Enable( FALSE ) ;

        _sltXObjectsSelected.Enable( TRUE ) ;
        _sltXObjectsSelected.Show( TRUE ) ;

        RESOURCE_STR nlsXObjSelectedTitle( IDS_X_OBJECTS_SELECTED ) ;
        ALIAS_STR    nlsResType( pchResourceType ) ;
        const NLS_STR *    apnlsInsertParams[3] ;
        DEC_STR      nlsCount( uiCount );

        apnlsInsertParams[0] = &nlsCount ;
        apnlsInsertParams[1] = &nlsResType ;
        apnlsInsertParams[2] = NULL ;

        if ( (err = nlsXObjSelectedTitle.QueryError()) ||
             (err = nlsCount.QueryError())  ||
             (err = nlsXObjSelectedTitle.InsertParams( apnlsInsertParams )))
        {
            ReportError( err ) ;
            return ;
        }

        _sltXObjectsSelected.SetText( nlsXObjSelectedTitle ) ;
    }
    else
    {
        /* Need to put together the resource name field which will look
         * something like: "File Name:"
         */
        RESOURCE_STR nlsResourceTitle( IDS_RESOURCE_TITLE ) ;
        ALIAS_STR    nlsResourceType( pchResourceType ) ;
        const NLS_STR    * apnlsInsertParams[2] ;

        apnlsInsertParams[0] = &nlsResourceType ;
        apnlsInsertParams[1] = NULL ;

        if ( (err = nlsResourceTitle.QueryError()) ||
             (err = nlsResourceTitle.InsertParams( apnlsInsertParams )))
        {
            ReportError( err ) ;
            return ;
        }

    /* Watch for any "(&?)" accelerators in the resource title
     * and move it to end of title
     * like this "file(&f) name:" --> "file name(&f):"
     *
     * Note that this will work only if there exists 1 left paren.
     */
    ISTR istrAccelStart( nlsResourceTitle ) ;
    if (   NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
        && nlsResourceTitle.strchr( &istrAccelStart, TCH('(') ))
    {
    /* We found an "(", if next is not "&", then ignore it
     */
    ISTR istrAccelNext( istrAccelStart ) ;
    if ( nlsResourceTitle.QueryChar( ++istrAccelNext ) == TCH('&'))
    {
        /* We found an "&", if it is doubled, then ignore it, else restore it
         */
        if ( nlsResourceTitle.QueryChar( ++istrAccelNext ) != TCH('&'))
        {
        NLS_STR nlsAccelWork(64) ;
        ISTR istrAccelWork( nlsAccelWork) ;
        ISTR istrAccelWork2( nlsAccelWork) ;
        ISTR istrAccelRestore( istrAccelStart) ;

        /* save Accelerators
         */
        nlsAccelWork.CopyFrom( nlsResourceTitle ) ;
        nlsAccelWork.strchr( &istrAccelWork2, TCH('(') ) ;
            nlsAccelWork.DelSubStr( istrAccelWork, istrAccelWork2 ) ;
        nlsAccelWork.strchr( &istrAccelWork, TCH(')') ) ;
        nlsAccelWork.strchr( &istrAccelWork2, TCH(':') ) ;
            nlsAccelWork.DelSubStr( ++istrAccelWork, ++istrAccelWork2 ) ;

        /* remove "(&?)"
         */
        istrAccelNext += 2 ;
            nlsResourceTitle.DelSubStr( istrAccelStart, istrAccelNext ) ;
        
        /* restore Accelerators
         */
        nlsResourceTitle.strchr( &istrAccelRestore, TCH(':') ) ;
        nlsResourceTitle.InsertStr( nlsAccelWork, istrAccelRestore ) ;
        }
    }
    }

        _sltResourceType.SetText( nlsResourceTitle ) ;
        _sleResourceName.SetText( pchResourceName ) ;


        /* Now figure out the owner name from the security descriptor
         */
        OS_SECURITY_DESCRIPTOR osSecDescOwner( psecdesc ) ;
        OS_SID * possidOwner ;
        BOOL     fOwnerPresent ;

        if ( ( err = osSecDescOwner.QueryError() ) ||
             ( err = osSecDescOwner.QueryOwner( &fOwnerPresent, &possidOwner )))
        {
            ReportError( err ) ;
            return ;
        }

        /* If the owner's not present in the security descriptor, then we
         * will display "No current owner" or some such in the owner field.
         */
        if ( !fOwnerPresent )
        {
            DBGEOL(SZ("TAKE_OWNERSHIP_DLG::ct - Security descriptor doesn't have an owner SID.")) ;
            RESOURCE_STR nlsNoOwnerTitle( IDS_NO_OWNER ) ;
            if ( err = nlsNoOwnerTitle.QueryError() )
            {
                ReportError( err ) ;
                return ;
            }

            _sleOwnerName.SetText( nlsNoOwnerTitle ) ;
        }
        else
        {
            NLS_STR nlsOwnerName ;
            if ( (err = nlsOwnerName.QueryError())  ||
                 (err = possidOwner->QueryName( &nlsOwnerName,
                                                pszServer,
                                                NULL )) )
            {
                ReportError( err ) ;
                return ;
            }

            _sleOwnerName.SetText( nlsOwnerName ) ;
        }
    }

    _buttonOK.ClaimFocus() ;
}

TAKE_OWNERSHIP_DLG::~TAKE_OWNERSHIP_DLG()
{
    /* Nothing to do
     */
}


/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::OnCommand

    SYNOPSIS:   Watches for the user pressing the "Take Ownership" button
                and does the call out appropriately.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created
        ChuckC  07-May-1993     Special case lookup of "None"

********************************************************************/

BOOL TAKE_OWNERSHIP_DLG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;
    BOOL   fDismiss = TRUE ;
    BOOL fPrivAdjusted = FALSE ;    // Only used when the take ownership button is
                                    // pressed

    switch ( event.QueryCid() )
    {
    case BUTTON_TAKE_OWNERSHIP:
        {

            /* To build the new security descriptor we do the folloing:
             *
             *  0) See if the current process SIDs are recognized on the
             *     remote machine (by doing TranslateSidsToNames), if that
             *     succeeds, use those, otherwise do steps 1-4
             *     and popup a message with who the new owner/group is.
             *  1) Look up owner/primary group SID on the local machine
             *     If necessary, special case the None primary group.
             *  2) Look up the names from the SIDs we just looked up locally
             *  3) Look up the SIDs on the remote machine with the names we
             *          we just looked up
             *  4) Put these SIDs into the security security descriptor
             */
            OS_SECURITY_DESCRIPTOR ossecdescNew ;
            API_SESSION            APISession( _pszServer, TRUE ) ;
            LSA_POLICY             LSAPolicyLocalMachine( NULL ) ;
            LSA_POLICY             LSAPolicyRemoteMachine( _pszServer ) ;
            LSA_TRANSLATED_SID_MEM LSATransSidMem ;
            LSA_REF_DOMAIN_MEM     LSARefDomainMem ;
            LSA_TRANSLATED_NAME_MEM LSATransNameMem ;
            OS_SID ossidOwner ;
            OS_SID ossidGroup ;
            NLS_STR nlsNewOwner ;
            NLS_STR nlsNewOwnerDom ;
            NLS_STR nlsNewGroup ;
            NLS_STR nlsNewGroupDom ;
            NLS_STR nlsQualifiedOwner ;
            NLS_STR nlsQualifiedGroup ;


            do {    // error break out, not a loop

                AUTO_CURSOR niftycursor ;

                //
                //  Enable the SeTakeOwnershipPrivilege
                //
                ULONG ulTakeOwnershipPriv = SE_TAKE_OWNERSHIP_PRIVILEGE ;
                if ( err = ::NetpGetPrivilege( 1, &ulTakeOwnershipPriv ))
                {
                    if ( err != ERROR_PRIVILEGE_NOT_HELD )
                    {
                        break ;
                    }
                    //
                    // The user doesn't have the privilege but they may have
                    // permission, so go ahead and try it anyway
                    //
                    err = NERR_Success ;
                    TRACEEOL("TAKE_OWNERSHIP_DLG::OnCommand - Take Ownership Privilege not held by user") ;
                }
                else
                {
                    fPrivAdjusted = TRUE ;
                }

                if ( (err = ossecdescNew.QueryError())              ||
                     (err = ossidOwner.QueryError())                ||
                     (err = ossidGroup.QueryError())                ||
                     (err = APISession.QueryError())                ||
                     (err = LSAPolicyLocalMachine.QueryError())     ||
                     (err = LSAPolicyRemoteMachine.QueryError())    ||
                     (err = LSATransSidMem.QueryError())            ||
                     (err = LSARefDomainMem.QueryError())           ||
                     (err = LSATransNameMem.QueryError())           ||
                     (err = nlsNewOwner.QueryError())               ||
                     (err = nlsNewOwnerDom.QueryError())            ||
                     (err = nlsQualifiedOwner.QueryError())         ||
                     (err = nlsNewGroup.QueryError())               ||
                     (err = nlsNewGroupDom.QueryError())            ||
                     (err = nlsQualifiedGroup.QueryError())         ||
                     (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                     UI_SID_CurrentProcessOwner,
                                     &ossidOwner ))                 ||
                     (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                     UI_SID_CurrentProcessPrimaryGroup,
                                     &ossidGroup ))    )
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                            " constructing LSA stuff.") ;
                    break ;
                }

                PSID apsid[2] ;
                apsid[0] = ossidOwner.QueryPSID() ;
                apsid[1] = ossidGroup.QueryPSID() ;

                /* Try looking up the SIDs on the remote machine.  If this
                 * succeeds, then use these
                 */
                if (!_pszServer) // local
                {
                    if ( (err = LSAPolicyLocalMachine.TranslateSidsToNames(
                                                        apsid,
                                                        2,
                                                        &LSATransNameMem,
                                                        &LSARefDomainMem)))
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateSidsToNames on remote machine") ;
                        break ;
                    } 
                } // local

                //
                // stick them new SIDs into the the security descriptor
                if ( !_pszServer && (LSATransNameMem.QueryUse(0) != SidTypeInvalid) &&
                     (LSATransNameMem.QueryUse(0) != SidTypeUnknown) &&
                     (LSATransNameMem.QueryUse(1) != SidTypeInvalid) &&
                     (LSATransNameMem.QueryUse(1) != SidTypeUnknown)   )
                {
                    /* Local lookup succeeded, we can use these
                     * for the owner and group SIDs
                     *
                     * Fall through...
                     */
                }
                else
                {
                    /* We have to do it the hard way.
                     */
                    UINT nSids = 2 ;           // number of sids we need resolve
                    BOOL fLookupGroup = TRUE ; // initially, we need both
                    PULONG pulGroupRID = 0 ;
                    OS_SID ossidUseThisGroup ;
                    LSA_ACCT_DOM_INFO_MEM RemoteDomain ;

                    if ((err = ossidGroup.QueryLastSubAuthority(&pulGroupRID))||
                        (err = ossidUseThisGroup.QueryError()) ||
                        (err = RemoteDomain.QueryError()))
                    {
                        break ;
                    }

                    //
                    //  get the account domain SID on remote machine
                    //
                    if (err = LSAPolicyRemoteMachine.GetAccountDomain(
                                   &RemoteDomain))
                    {
                        break ;
                    }

                    if (*pulGroupRID == DOMAIN_GROUP_RID_USERS)
                    {
                        //
                        // we have a "None" or "Domain Users" as primary group
                        // they both have the same RID, but if we translated
                        // it to its name and looked up the name None on a DC,
                        // it wont be found (since it will be "Domain Users"
                        // instead). so we build the SID up by hand
                        // instead of looking it up.
                        //

                        //
                        //  build up the SID
                        //
                        OS_SID ossidDomainUsers( RemoteDomain.QueryPSID(),
                                           (ULONG) DOMAIN_GROUP_RID_USERS );
                        if ((err = ossidDomainUsers.QueryError()) ||
                            (err = ossidUseThisGroup.Copy(ossidDomainUsers)))
                        {
                            break ;
                        }


                        //
                        // dont bother looking up the group.
                        //
                        nSids = 1 ;
                        fLookupGroup = FALSE ;
                    } // DOMAIN_GROUP_RID_USERS


                    if (_pszServer == NULL) 
                    {
                        // the domain lookup failed and this is on the 
                        // local machine so use the local machine sids
                        //
                        if ( (err = LSAPolicyLocalMachine.TranslateSidsToNames(
                                                          apsid,
                                                          nSids,
                                                          &LSATransNameMem,
                                                          &LSARefDomainMem)))
                            break ;
                        if ( (err = LSATransNameMem.QueryName( 0, &nlsNewOwner )) ||
                             (err = LSARefDomainMem.QueryName(
                                           LSATransNameMem.QueryDomainIndex( 0 ),
                                           &nlsNewOwnerDom)))
                            break ;
                        if ( fLookupGroup && (
                                (err = LSATransNameMem.QueryName( 1, &nlsNewGroup )) ||
                                (err = LSARefDomainMem.QueryName(
                                           LSATransNameMem.QueryDomainIndex( 1 ),
                                           &nlsNewGroupDom))))
                            break ;

                    }
                    else // this is a remote connection - find out who owns the session
                    {
                        PUNICODE_STRING pwszNewOwner = NULL;
                        PUNICODE_STRING pwszNewOwnerDom = NULL;
                        UNICODE_STRING wszServer;

                        wszServer.Length = (UINT) (sizeof (WCHAR) * wcslen (_pszServer));  // bytes w/o NULL
                        wszServer.MaximumLength = wszServer.Length + sizeof (WCHAR);       // bytes w/ NULL
                        wszServer.Buffer = (PWSTR) _pszServer;

                        if (err = LsaGetRemoteUserName(&wszServer,
                                                   &pwszNewOwner, 
                                                   &pwszNewOwnerDom))
                            break;

                        if (err = nlsNewOwner.MapCopyFrom(pwszNewOwner->Buffer))
                            break;
                        if (err = nlsNewOwnerDom.MapCopyFrom(pwszNewOwnerDom->Buffer))
                            break;
                        RtlFreeUnicodeString(pwszNewOwner);
                        RtlFreeUnicodeString(pwszNewOwnerDom);

                        //
                        // dont bother looking up the group.
                        //
                        ossidUseThisGroup = ossidGroup;
                        nSids = 1 ;
                        fLookupGroup = FALSE ;
                    }

                    //
                    //  If the domain name matches the local domain name
                    //  (indicating the accounts exist on the local machine),
                    //  substitute the remote machine name for the local domain
                    //  name and continue, otherwise use the real domain name.
                    //

                    NLS_STR nlsLocalDomain ;
                    LSA_ACCT_DOM_INFO_MEM LocalDomain ;

                    if ((err = nlsLocalDomain.QueryError()) ||
                        (err = LocalDomain.QueryError())    ||
                        (err = LSAPolicyLocalMachine.GetAccountDomain(
                                   &LocalDomain)) ||
                        (err = LocalDomain.QueryName( &nlsLocalDomain )))
                    {
                        break ;
                    }

                    if( !::I_MNetComputerNameCompare( nlsNewOwnerDom,
                                                      nlsLocalDomain ))
                    {
                        if (err = RemoteDomain.QueryName(&nlsNewOwnerDom))
                            break ;
                    }

                    if( fLookupGroup && !::I_MNetComputerNameCompare( nlsNewGroupDom,
                                                                          nlsLocalDomain))
                    {
                        if (err = RemoteDomain.QueryName(&nlsNewGroupDom))
                            break ;
                    }

                    if ((err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                       &nlsQualifiedOwner,
                                       nlsNewOwner,
                                       nlsNewOwnerDom )) ||
                        (fLookupGroup && (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                       &nlsQualifiedGroup,
                                       nlsNewGroup,
                                       nlsNewGroupDom ))) )
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateSidsToNames on local machine") ;
                        break ;
                    }

                    TRACEEOL("TAKE_OWNERSHIP_DLG::OnCommand - qualified owner "
                              << " and group: " << nlsQualifiedOwner << "  "
                              << nlsQualifiedGroup ) ;

                    //
                    //  Now we have the names of the user and group.  Lookup the
                    //  sids on the remote machine
                    //
                    const TCHAR * apsz[2] ;
                    apsz[0] = nlsQualifiedOwner.QueryPch() ;
                    apsz[1] = nlsQualifiedGroup.QueryPch() ;
                    ULONG ulDummy = 0xffffffff ;
                    if ( (err = LSAPolicyRemoteMachine.TranslateNamesToSids(
                                                         apsz,
                                                         nSids,
                                                         &LSATransSidMem,
                                                         &LSARefDomainMem)) ||
                         LSATransSidMem.QueryFailingNameIndex( &ulDummy ) )
                    {
                        DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                               " calling TranslateNamesToSids or QueryFailingNameIndex failed") ;

                        //
                        //  Map any partial lookups or "Group not found" error
                        //  to "Account not found"
                        //
                        if ( (ulDummy != 0xffffffff) ||
                             (err = NERR_GroupNotFound) )
                        {
                            err = IDS_OWNER_ACCOUNT_NOT_FOUND ;
                        }

                        RESOURCE_STR nlsError( (MSGID) err ) ;
                        if ( err = nlsError.QueryError() )
                        {
                            DEC_STR decStr( err ) ;
                            if ( (err = decStr.QueryError() ) ||
                                 (err = nlsError.CopyFrom( decStr )) )
                            {
                                break ;
                            }
                        }

                        NLS_STR * apnls[3] ;

                        //
                        //  If ulDummy is 1, then the group account wasnt found,
                        //  else it will be either 0 or -1, in which case we
                        //  will always display the primary group name
                        //
                        apnls[0] = (fLookupGroup && (ulDummy == 1)) ?
                                   &nlsQualifiedGroup :
                                   &nlsQualifiedOwner ;
                        apnls[1] = &nlsError ;
                        apnls[2] = NULL ;

                        MsgPopup( this,
                                  IDS_OWNER_CANT_FIND_OWNR_OR_GRP,
                                  MPSEV_ERROR,
                                  HC_DEFAULT_HELP,
                                  MP_OK,
                                  apnls ) ;
                        fDismiss = FALSE ;
                        break ;
                    } // remote lookup failure

                    //
                    // now build the new owner SID based on looked up info
                    //
                    OS_SID ossidNewOwner( LSARefDomainMem.QueryPSID(
                                          LSATransSidMem.QueryDomainIndex(0) ),
                                          LSATransSidMem.QueryRID( 0 )  ) ;

                    if ( (err = ossidNewOwner.QueryError()) ||
                         (err = ossidOwner.Copy( ossidNewOwner )) )
                    {
                        break ;
                    }

                    //
                    // either build the new group SID based on looked up info
                    // or copy from the one we built ourselves if it is the
                    // None group.
                    //
                    if (fLookupGroup)
                    {
                        OS_SID ossidNewGroup( LSARefDomainMem.QueryPSID(
                                          LSATransSidMem.QueryDomainIndex(1) ),
                                          LSATransSidMem.QueryRID( 1 )  ) ;

                        if ((err = ossidNewGroup.QueryError()) ||
                            (err = ossidGroup.Copy( ossidNewGroup )) )
                        {
                            break ;
                        }
                    }
                    else
                    {
                        if (err = ossidGroup.Copy( ossidUseThisGroup ))
                            break ;
                    }
                } // "doing it the hard way"

                //
                // stick them new SIDs into the the security descriptor
                //
                if (err = ossecdescNew.SetOwner( ossidOwner ))
                {
                    break;
                }
                if (err = ossecdescNew.SetGroup( ossidGroup ))
                {
                    break ;
                }

                //
                // User error messages are handled by the callback method
                // We only dismiss if the OnTakeOwnership was successful
                // (we don't display an error if it fails).
                //
                APIERR errOnTakeOwner ;
                if ( errOnTakeOwner =  OnTakeOwnership( ossecdescNew ))
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - OnTakeOwnership "
                           << "returned " << errOnTakeOwner ) ;
                    fDismiss = FALSE ;
                }

            } while (FALSE) ;

            if ( err )
            {
                DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Error " << err <<
                       " returned from OnTakeOwnership") ;
                MsgPopup( this, err ) ;
                fDismiss = FALSE ;
            }

            if ( fDismiss )
            {
                Dismiss() ;
            }

            //
            // Restore the original token if we successfully got the privilege
            //
            if ( fPrivAdjusted )
            {
                APIERR errTmp = NetpReleasePrivilege() ;
                if ( errTmp )
                {
                    DBGEOL("TAKE_OWNERSHIP_DLG::OnCommand - Warning: NetpReleasePrivilege return error "
                           << errTmp ) ;
                }
            }
            return TRUE ;

        }

        default:
            break ;
    }

    return DIALOG_WINDOW::OnCommand( event ) ;
}


/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::OnTakeOwnership

    SYNOPSIS:   Called when the user presses the TakeOwnership button

    ENTRY:      ossecdescNew - Security descriptor that contains the currently
                    logged on user as the new owner

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Feb-1992     Created

********************************************************************/

APIERR TAKE_OWNERSHIP_DLG::OnTakeOwnership( const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner )
{
    UNREFERENCED( ossecdescNewOwner ) ;
    DBGEOL(SZ("TAKE_OWNERSHIP_DLG::OnTakeOwnership Called")) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::QueryHelpContext

    SYNOPSIS:   Standard QueryHelpContext

    HISTORY:
        Johnl   12-Feb-1992     Created

********************************************************************/

ULONG TAKE_OWNERSHIP_DLG::QueryHelpContext( void )
{
    return _ulHelpContext;
}

/*******************************************************************

    NAME:       TAKE_OWNERSHIP_DLG::QueryHelpFile

    SYNOPSIS:   Returns the help file to use for this dialog

    HISTORY:
        Johnl   11-Sep-1992     Created

********************************************************************/

const TCHAR * TAKE_OWNERSHIP_DLG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _nlsHelpFileName.QueryPch() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\permdlg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    PermDlg.cxx

    This file contains the implementation for the access permission dialogs.

    FILE HISTORY:
	Johnl	06-Aug-1991	Created

*/
#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntlsa.h>
    #include <ntioapi.h>
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <security.hxx>
#include <lmodom.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntacutil.hxx>
#include <maskmap.hxx>
#include <apisess.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>
#include <add_dlg.hxx>
#include <permdlg.hxx>
#include <perm.hxx>

#define  SECURITY_EDITOR
#include <usrbrows.hxx>

#include <uitrace.hxx>

/*******************************************************************

    NAME:	PERM_BASE_DLG::PERM_BASE_DLG

    SYNOPSIS:	Base permission dialog (for both access and audit permissions)

    ENTRY:	pszDialogName - Resource file name of dialog
		hwndParent - handle of parent window
		paclconv - pointer to aclconverter
		pchResType - UI string to use for resource type name (if NULL,
			     resource name is blank)  A colon will be
			     appended to this name (if it doesn't already
			     *contain* a colon).
		pchResName - UI string to use for resource name (if NULL,
			     resource name is blank).
		hcMainDialog - Help context for this dialog

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	07-Aug-1991	Created

********************************************************************/

PERM_BASE_DLG::PERM_BASE_DLG(const TCHAR * pszDialogName,
			     HWND hwndParent,
			     const TCHAR * pszDialogTitle,
			     const TCHAR * pchResType,
			     const TCHAR * pchResName,
			     const TCHAR * pszHelpFileName,
                             ULONG       * ahcMainDialog  )
    : DIALOG_WINDOW   ( pszDialogName, hwndParent ),
      _sltResourceType( this, SLT_RESOURCE_TYPE ),
      _sleResourceName( this, SLE_RESOURCE_NAME ),
      _pszHelpFileName( pszHelpFileName ),
      _ahcDialogHelp  ( ahcMainDialog ),
      _buttonOK       ( this, IDOK ),
      _buttonCancel   ( this, IDCANCEL ),
      _nlsResName     ( pchResName ),
      _nlsResType     ( pchResType )
{
    if ( QueryError() != NERR_Success )
    {
	UIDEBUG(SZ("PERM_BASE_DLG::ct - Parent or control returned error\n\r")) ;
	UIASSERT(FALSE);     // For debugging purposes
	return ;
    }

    UIASSERT( pszDialogTitle != NULL ) ;
    SetText( pszDialogTitle ) ;

    /* We need to resize the Resource type field and reposition the
     * resource name field.  We also append a colon after the resource
     * type.
     */
    ALIAS_STR	 nlsResName( pchResName == NULL ? SZ("") : pchResName ) ;
    NLS_STR	 nlsResType( pchResType ) ;
    RESOURCE_STR nlsColon( (USHORT) IDS_OBJTYPE_OBJNAME_SEPARATOR ) ;

    APIERR err ;
    if ( ( err = nlsResType.QueryError() ) ||
	 ( err = nlsColon.QueryError() )     )
    {
	ReportError( err ) ;
	return ;
    }


    /* If the resource name doesn't already have a colon, then
     * append one on.
     */
    ISTR istrDummy( nlsResType ) ;
    if ( nlsResType.strlen() > 0 && !nlsResType.strstr( &istrDummy, nlsColon ))
    {
	nlsResType += nlsColon ;
	if ( nlsResType.QueryError() )
	{
	    ReportError( nlsResType.QueryError() ) ;
	    return ;
	}
    }

    _sltResourceType.SetText( nlsResType ) ;
    _sleResourceName.SetText( nlsResName ) ;

    XYPOINT xyResType = _sltResourceType.QueryPos() ;
    UINT uiStartOfResName = xyResType.QueryX() ;

    /* Find out where the end of the Resource Type field is and resize the
     * control window to the correct size.
     */
    {
	DISPLAY_CONTEXT dcResType( _sltResourceType.QueryHwnd() ) ;

        // kkntbug#11847
        // Select appropriate font into the specified DC before get text extent.
        // Unless this process, text extent might not be correct.
        EVENT event(WM_GETFONT, 0, 0L);
        HFONT hFont = (HFONT)event.SendTo(_sltResourceType.QueryHwnd());
        if (hFont)
        {
            hFont = dcResType.SelectFont(hFont);
        }

	XYDIMENSION dxyResType = dcResType.QueryTextExtent( nlsResType ) ;
	_sltResourceType.SetSize( dxyResType ) ;
	uiStartOfResName += dxyResType.QueryWidth() ;

        // kkntbug#11847
        // +10 is just looks nice... (of course, it works w/o this.)
        // e.g. "Label: Name" is looks better than "Label:Name"
        uiStartOfResName += 10;
        // restore object.
        if (hFont)
        {
            dcResType.SelectFont(hFont);
        }

    }

    /* Place the Resource name in the appropriate place and resize the field
     * appropriately.  We assume the right edge of the control is in the
     * correct place (i.e., the rightmost position).
     */
    XYPOINT xypointResName = _sleResourceName.QueryPos() ;
    UINT xOldPos = xypointResName.QueryX() ;
    xypointResName.SetX( uiStartOfResName ) ;
    _sleResourceName.SetPos( xypointResName ) ;

    XYDIMENSION dxyResName = _sleResourceName.QuerySize() ;
    dxyResName.SetWidth( dxyResName.QueryWidth() -
			  ( xOldPos > (UINT)xypointResName.QueryX() ?
			    xOldPos - xypointResName.QueryX() :
			    xypointResName.QueryX() - xOldPos) ) ;

    _sleResourceName.SetSize( dxyResName.QueryWidth(),
				  dxyResName.QueryHeight() ) ;

    _buttonOK.ClaimFocus() ;
}

PERM_BASE_DLG::~PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	PERM_BASE_DLG::QueryHelpContext

    SYNOPSIS:	Typical help context for the main dialog

    HISTORY:
	Johnl	28-Apr-1992	Created

********************************************************************/

ULONG PERM_BASE_DLG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_MAIN_DLG] ;
}

/*******************************************************************

    NAME:	PERM_BASE_DLG::QueryHelpFile

    SYNOPSIS:	Returns the client specific help file name

    NOTES:

    HISTORY:
	Johnl	02-Sep-1992	Created

********************************************************************/

const TCHAR * PERM_BASE_DLG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _pszHelpFileName ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::MAIN_PERM_BASE_DLG

    SYNOPSIS:	Base permission dialog (for both access and audit permissions)

    ENTRY:	pszDialogName - Resource file name of dialog
		hwndParent - handle of parent window
		paclconv - pointer to aclconverter
		pchResType - UI string to use for resource type name (if NULL,
			     resource name is blank)
		pchResName - UI string to use for resource name (if NULL,
			     resource name is blank).
		hcMainDialog - Help context for the main dialog

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	07-Aug-1991	Created

********************************************************************/

MAIN_PERM_BASE_DLG::MAIN_PERM_BASE_DLG(  const TCHAR * pszDialogName,
					 HWND	       hwndParent,
					 const TCHAR * pszDialogTitle,
					 ACL_TO_PERM_CONVERTER * paclconv,
					 const TCHAR * pchResType,
					 const TCHAR * pchResName,
					 const TCHAR * pszHelpFileName,
                                         ULONG       * ahcMainDialog   )
    : PERM_BASE_DLG( pszDialogName,
		     hwndParent,
		     pszDialogTitle,
		     pchResType,
		     pchResName,
		     pszHelpFileName,
                     ahcMainDialog ),
      _accperm	   ( paclconv )
{
    if ( QueryError() != NERR_Success )
	return ;

    if ( _accperm.QueryError() != NERR_Success )
    {
	ReportError( _accperm.QueryError() ) ;
	return ;
    }

    /* This gives the ACL converter a window handle to use when
     * calling the callback (or if we can't get the logged on domain).
     */
    QueryAclConverter()->SetWritePermHwnd( QueryRobustHwnd() ) ;
}

MAIN_PERM_BASE_DLG::~MAIN_PERM_BASE_DLG()
{
    /* Nothing to do */
}


/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::GetPermissions

    SYNOPSIS:	Gets the network resources and gives the user the
		option to cancel if appropriate.

    ENTRY:      pfUserQuit indicates if the user aborted, is only
		    valid if NERR_Success is returned
		fAccessPerms - Is TRUE if the access permissions should
		    be retrieved, FALSE if the Audit permissions should
		    be retrieved.


    EXIT:

    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Broke from constructor

********************************************************************/

APIERR MAIN_PERM_BASE_DLG::GetPermissions( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    /* Assume the user didn't quit
     */
    *pfUserQuit = FALSE ;

    APIERR err = _accperm.GetPermissions( fAccessPerms ) ;
    switch ( err )
    {
    case NERR_Success:
	break ;

    case IERR_ACLCONV_NONST_ACL_CANT_EDIT:
	{
	    MsgPopup( this,
		      (MSGID) IERR_ACLCONV_NONST_ACL_CANT_EDIT,
		      MPSEV_WARNING,
		      MP_OK,
		      QueryResName(),
		      NULL,
		      MP_OK ) ;

	    *pfUserQuit = TRUE ;
	    err = NERR_Success ;
	}
	break ;

    case IERR_ACLCONV_READ_ONLY:
	{
	    MsgPopup( this,
		      (MSGID) IERR_ACLCONV_READ_ONLY,
                      MPSEV_INFO,
		      MP_OK,
		      QueryResName(),
		      NULL,
		      MP_OK ) ;

	    err = NERR_Success ;
	}
	break ;

    case IERR_ACLCONV_NONST_ACL_CAN_EDIT:
    case IERR_ACLCONV_CANT_VIEW_CAN_EDIT:
    case IERR_ACLCONV_LM_NO_ACL:
	{
	    if ( IDNO == MsgPopup( this,
				   (MSGID) err,
				   MPSEV_WARNING,
				   MP_YESNO,
				   QueryResName(),
				   NULL,
				   MP_NO ) )

	    {
		err = NERR_Success ;
		*pfUserQuit = TRUE ;
		break ;
	    }

	    /* They answered "Yes" to overwriting the current permissions,
	     * so go ahead and get a blank permission set.
	     */
	    err = _accperm.GetBlankPermissions() ;
	    if ( err != NERR_Success )
	    {
		return err ;
	    }

	}
	break ;

    case IERR_ACLCONV_LM_INHERITING_PERMS:
	{
	    NLS_STR nlsInherittingResName ;
	    if ( nlsInherittingResName.QueryError() != NERR_Success )
	    {
		return nlsInherittingResName.QueryError() ;
	    }

	    err = _accperm.QueryAclConverter()->
			       QueryInherittingResource( &nlsInherittingResName ) ;
	    if ( err != NERR_Success )
	    {
		break ;
	    }

	    if ( IDNO == MsgPopup( QueryOwnerHwnd(),
				   (USHORT) IERR_ACLCONV_LM_INHERITING_PERMS,
				   MPSEV_WARNING,
				   MP_YESNO,
				   QueryResName(),
				   nlsInherittingResName.QueryPch(),
				   MP_NO ) )
	    {
		*pfUserQuit = TRUE ;
		err = NERR_Success ;
	    }

	    /* They answered "Yes" to explicitly assigning the current permissions,
	     * which are now stored in the accperm object
	     */
	}
	break ;

    default:
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::WritePermissions

    SYNOPSIS:	Attempts to write the permissions, displays
		errors and gets user input as necessary.

    ENTRY:	_accperm should be set to the interested resource

		fApplyToExistingCont - Same meaning as
			       ACL_TO_PERM_CONVERTER::WritePermissions
                fApplyToObj - Same...

    EXIT:


    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Broke from constructor

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::WritePermissions( BOOL fApplyToExistingCont,
                                           BOOL fApplyToObj,
					   enum TREE_APPLY_FLAGS applyflags )
{
    APIERR err = NERR_Success ;
    BOOL fRet = FALSE ;
    BOOL fDone = FALSE ;
    BOOL fReportErrors = TRUE ;

    while ( !fDone )
    {
	AUTO_CURSOR cursHourGlass ;

	err = _accperm.WritePermissions( fApplyToExistingCont,
                                         fApplyToObj,
					 applyflags,
					 &fReportErrors ) ;

	switch ( err )
	{
	case NERR_Success:
	    fRet = TRUE ;
	    fDone = TRUE ;
	    break ;

	/* Somebody has deleted a user/group out from under us, thus we can
	 * no longer write the ACL.  Tell the user which subject failed and
	 * ask if they want to remove it and try again.
	 */
	case NERR_UserNotFound:
	    {
		NLS_STR nlsUniqueSubjectID ;
		if ( err = _accperm.QueryFailingSubject( &nlsUniqueSubjectID ) )
		    break ;

		switch ( MsgPopup( this, (MSGID) IERR_CONTINUE_AFTER_USERGROUP_NOT_FOUND,
				   MPSEV_WARNING, MP_YESNO, nlsUniqueSubjectID ) )
		{
		case IDNO:
		    fDone = TRUE ;
		    break ;

		/* Note that the if an error occured while trying to delete
		 * the subject, the continue will take us back to the top
		 * of the while loop, which will then fall out because
		 * err is non-zero.
		 */
		case IDYES:
		    err = _accperm.DeleteSubject( &nlsUniqueSubjectID ) ;
		    continue ;

		default:
		    UIASSERT(!SZ("How the heck did we get here?") ) ;
		    break ;
		}
	    }

	default:
	    /* Some other error occurred, we will fall out of the loop.
	     */
	    fDone = TRUE ;
	    break ;
	}
    }

    //
    // Some of our clients may have already reported the error to the user, if so,
    // simply return
    //
    if ( err && fReportErrors )
    {
	MsgPopup( this, (MSGID) err ) ;
    }

    return fRet ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::OnOK

    SYNOPSIS:	Attempts to write out new permissions when the user
		presses the OK button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	29-Aug-1991	Created

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::OnOK( void )
{
    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    //
    //  If nothing is granted, warn the user.  Note that you
    //  can't deny everyone access under LM
    //
    APIERR err ;
    BOOL fIsDenyAll = FALSE ;
    if ( IsNT() &&
         (err = _accperm.AnyDenyAllsToEveryone( &fIsDenyAll )) )
    {
	::MsgPopup( this, (MSGID) err ) ;
	return TRUE ;
    }

    if (  fIsDenyAll )
    {
	switch ( ::MsgPopup( this,
			     IDS_DENY_ALL_EVERYONE_WARNING,
			     MPSEV_WARNING,
			     MP_YESNO,
			     QueryResName(),
			     MP_NO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    return TRUE ;
	}
    }

    if ( WritePermissions( FALSE, FALSE ) )
	Dismiss() ;

    return TRUE ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::Initialize

    SYNOPSIS:	Gets the permissions from the resource

    EXIT:	The accperm will be initialized and ready to go else
		the user quit and the user quit flag is set.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MAIN_PERM_BASE_DLG::Initialize( BOOL * pfUserQuit, BOOL fAccessPerms )
{
    return GetPermissions( pfUserQuit, fAccessPerms ) ;
}

/*******************************************************************

    NAME:	MAIN_PERM_BASE_DLG::MayRun

    SYNOPSIS:	Updates window hwnd so correct window will get locked down


    NOTES:

    HISTORY:
	Johnl	30-Oct-1992	Created

********************************************************************/

BOOL MAIN_PERM_BASE_DLG::MayRun( void )
{
    //
    //	Reset the hwnd so it points to this dialog
    //
    QueryAclConverter()->SetWritePermHwnd( QueryHwnd() ) ;
    return TRUE ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::MULTI_SUBJ_PERM_BASE_DLG

    SYNOPSIS:	Place holder constructor for this class, passes all of
		the parameters along.

    NOTES:	Note that at construction time, we don't know if this dialog
		is read only or not.  The read only flag is set during the
		Initialize call.

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

MULTI_SUBJ_PERM_BASE_DLG::MULTI_SUBJ_PERM_BASE_DLG(
			  const TCHAR * 	   pszDialogName,
			  HWND			   hwndParent,
			  const TCHAR * 	   pszDialogTitle,
			  ACL_TO_PERM_CONVERTER  * paclconv,
			  const TCHAR * 	   pszResourceType,
			  const TCHAR * 	   pszResourceName,
			  const TCHAR * 	   pszHelpFileName,
                          ULONG       *            ahcMainDialog )
    : MAIN_PERM_BASE_DLG   ( pszDialogName,
			     hwndParent,
			     pszDialogTitle,
			     paclconv,
			     pszResourceType,
			     pszResourceName,
			     pszHelpFileName,
                             ahcMainDialog ),
      _buttonAdd	   ( this, BUTTON_ADD ),
      _buttonRemove        ( this, BUTTON_REMOVE )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("MULTI_SUBJ_PERM_BASE_DLG::ct - Parent returned error\n\r")) ;
	return ;
    }
}

MULTI_SUBJ_PERM_BASE_DLG::~MULTI_SUBJ_PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize

    SYNOPSIS:	Gets the permissions, fills the listbox and combobox

    EXIT:	The dialog should be ready to go or an error will have
		occurred.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The Add button will be disabled if this dialog is read only

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = MAIN_PERM_BASE_DLG::Initialize( pfUserQuit, fAccessPerms ) ;
    if ( err != NERR_Success )
	return err ;
    else if ( *pfUserQuit )
	return NERR_Success ;

    if ( (err = _plbPermissionList->Fill() ) != NERR_Success )
    {
	UIDEBUG(SZ("MULTI_SUBJ_ACCESS_PERM_BASE_DLG::ct - Permission list Fill Failed\n\r")) ;
	return err ;
    }


    if ( !IsReadOnly() )
    {
	/* Fill the combo-box with all of the common permission names.
	 */
	MASK_MAP * pmaskmapPermNames = _accperm.QueryAclConverter()->QueryAccessMap() ;
	BOOL fFromBeginning = TRUE ;
	BOOL fMoreData ;
	NLS_STR nlsPermName( 40 ) ;
	INT iPermPosition = 0 ;

	/* Insert each of the permissions into the permission combo.  The
	 * permissions are inserted in the order they exist in the
	 * MaskMap and alwas at the beginning of the combo box
	 * (i.e., before any "Special Access...").  This is what
	 * iPermPosition is used for.
	 */
	while ( (err = pmaskmapPermNames->EnumStrings( &nlsPermName,
						       &fMoreData,
						       &fFromBeginning,
						       PERMTYPE_GENERAL ))
		       == NERR_Success &&
		fMoreData )
	{
	    if ( _cbPermissionName.InsertItem( iPermPosition++,
					       nlsPermName.QueryPch() ) < 0 )
	    {
		return ERROR_NOT_ENOUGH_MEMORY ;
	    }
	}

	if ( err != NERR_Success )
	    return err ;
    }
    else
    {
	QueryRemoveButton()->Enable( FALSE ) ;
	QueryAddButton()->Enable( FALSE ) ;
    }

    /* If the listbox is empty, then we need to disable the combo box,
     * else initialize it to the currently selected permission in the
     * listbox.  Order is important.
     */
    _psubjlbGroup->UpdateSubjectListbox() ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::OnCommand

    SYNOPSIS:	Looks for the Add or remove button getting pressed

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

BOOL MULTI_SUBJ_PERM_BASE_DLG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {
    case BUTTON_REMOVE:
	OnDeleteSubject() ;
	break ;

    case BUTTON_ADD:
        {
	    APIERR err = OnAddSubject() ;
	    if ( err != NERR_Success )
	         ::MsgPopup( this, (MSGID) err ) ;
        }
	break ;

    default:
	return MAIN_PERM_BASE_DLG::OnCommand( e ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_PERM_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Default definition for OnDeleteSubject
		and OnAddSubject (does nothing).

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

void MULTI_SUBJ_PERM_BASE_DLG::OnDeleteSubject( void )
{
    UIASSERT(!SZ("For show only!")) ;
}

APIERR MULTI_SUBJ_PERM_BASE_DLG::OnAddSubject( void )
{
    return NERR_Success ;
}



/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::MULTI_SUBJ_ACCESS_PERM_BASE_DLG

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	Don't do anything with the listbox pointer and the
		group pointer because they haven't been fully constructed
		yet!!

    HISTORY:
	Johnl	6-Aug-1991	Created

********************************************************************/

MULTI_SUBJ_ACCESS_PERM_BASE_DLG::MULTI_SUBJ_ACCESS_PERM_BASE_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   SUBJECT_PERM_LISTBOX *   plbPermissionList,
			   SUBJ_LB_GROUP *	    psubjlbGroup,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : MULTI_SUBJ_PERM_BASE_DLG( pszDialogName,
				hwndParent,
				pszDialogTitle,
				paclconv,
				pszResourceType,
				pszResourceName,
				pszHelpFileName,
                                ahcMainDialog ),
      _plbPermissionList      ( plbPermissionList ),
      _psubjlbGroup	      ( psubjlbGroup ),
      _cbPermissionName       ( this, CB_PERM_NAME ),
      _sltCBTitle             ( this, SLT_PERM_NAME_TITLE ),
      _pszDefaultPermName     ( pszDefaultPermName )
{
    if ( QueryError() != NERR_Success )
    {
	UIDEBUG(SZ("MULTI_SUBJ_ACCESS_PERM_BASE_DLG::ct - Parent returned error\n\r")) ;
	return ;
    }

    ASSERT( plbPermissionList != NULL ) ;
    ASSERT( psubjlbGroup      != NULL ) ;

    if ( (pszSpecialAccessName != NULL) &&
	 (_cbPermissionName.InsertItem( _cbPermissionName.QueryCount(),
					pszSpecialAccessName )) < 0 )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }
}

MULTI_SUBJ_ACCESS_PERM_BASE_DLG::~MULTI_SUBJ_ACCESS_PERM_BASE_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnCommand

    SYNOPSIS:	Typcial OnCommand, catches the Special permission Double-Click

    NOTES:

    HISTORY:
	Johnl		    Created

********************************************************************/

BOOL MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {

    /* Double clicking in the Subject listbox brings up the container
     * permissions dialog.  However we do not want to bring it up if the
     * client doesn't allow access to the special permissions dialog
     */
    case LB_SUBJECT_PERMISSIONS:
	if ( e.QueryCode() == LBN_DBLCLK )
	{
	    if ( _plbPermissionList->QuerySpecialAccessName().strlen() > 0 )
	    {
		APIERR err = OnSpecial( _plbPermissionList->QueryItem() ) ;
		if ( err != NERR_Success )
		    ::MsgPopup( this, (MSGID) err ) ;
		_psubjlbGroup->UpdateSubjectListbox() ;
	    }
	}
	break ;


    default:
	return MULTI_SUBJ_PERM_BASE_DLG::OnCommand( e ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnDeleteSubject

    SYNOPSIS:	Deletes the current item from the Permission listbox

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

void MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnDeleteSubject( void )
{
    //
    //	If we are about to remove the last item, then move the focus and
    //	defaultness to the OK button.
    //
    if ( _psubjlbGroup->QuerySubjLB()->QueryCount() == 1 )
    {
	_buttonOK.ClaimFocus() ;
        QueryRemoveButton()->MakeDefault() ;
        _buttonOK.MakeDefault() ;
    }

    _plbPermissionList->DeleteCurrentItem() ;
    _psubjlbGroup->UpdateSubjectListbox() ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnAddSubject

    SYNOPSIS:	This method gets called when the user presses the
		"Add" button.  It displays the permission Add dialog.

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	This puts up the correct dialog based on whether we are looking
		at an NT machine or a Lanman machine.

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnAddSubject( void )
{
    APIERR err = NERR_Success ;
    HWND hWnd = QueryRobustHwnd();

    if ( IsNT() )
    {
	SED_NT_USER_BROWSER_DIALOG * pdlgUserBrows = new
		SED_NT_USER_BROWSER_DIALOG( hWnd,
			 QueryAclConverter()->QueryLocation()->QueryServer(),
			 QueryAclConverter()->QueryAccessMap(),
			 QueryAclConverter()->IsContainer(),
			 QueryDefaultPermName(),
			 QueryHelpFileName(),
                         QueryHelpArray() ) ;


	if ( pdlgUserBrows == NULL )
	    return ERROR_NOT_ENOUGH_MEMORY ;

        InvalidateRect (hWnd, NULL, 0);
        UpdateWindow (hWnd);

	do { // error breakout

	    BOOL fUserPressedOK ;
	    if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
		 !fUserPressedOK )
	    {
		break ;
	    }

	    AUTO_CURSOR niftycursor ;

	    /* Get the permission name and corresponding bitfield(s) the user
	     * selected.
	     */
	    AUTO_CURSOR cursHourGlass ;
	    NLS_STR nlsPermName( 48 ) ;
	    NLS_STR nlsDisplayName( 50 ) ;
	    NLS_STR nlsDomainName( DNLEN ) ;
	    UIASSERT( sizeof(ACCESS_MASK) == sizeof(ULONG)) ;
	    BITFIELD bitPerms( (ULONG) 0 ) ;
	    BITFIELD bitNewObjPerms( (ULONG) 0 ) ;

	    if ( ( err = nlsPermName.QueryError() )    ||
		 ( err = nlsDisplayName.QueryError())  ||
		 ( err = nlsDomainName.QueryError())   ||
		 ( err = bitPerms.QueryError() )       ||
		 ( err = bitNewObjPerms.QueryError() ) ||
		 ( err = pdlgUserBrows->QuerySelectedPermName( &nlsPermName ))||
		 ( err = QueryAclConverter()->QueryLoggedOnDomainInfo(
						   NULL, &nlsDomainName ))    ||
		 ( err = QueryAclConverter()->QueryAccessMap()->
		   StringToBits( nlsPermName, &bitPerms, PERMTYPE_GENERAL )))
	    {
		break ;
	    }

	    BOOL fIsNewPermsSpecified = TRUE ;
	    if ( QueryAclConverter()->IsNewObjectsSupported() )
	    {
		if ( err = QueryAclConverter()->QueryNewObjectAccessMap()->
		   StringToBits( nlsPermName, &bitNewObjPerms, PERMTYPE_GENERAL ))
		{
		    //
		    //	If the object permissions doesn't have this permission
		    //	category, then it should be marked as not specified
		    //
		    if ( err == ERROR_NO_ITEMS )
		    {
			fIsNewPermsSpecified = FALSE ;
			err = NERR_Success ;
		    }
		    else
		    {
			break ;
		    }
		}
	    }

	    /* Iterate though each item selected in the Add dialog and add
	     * it to our permission list.
	     */
	    BROWSER_SUBJECT_ITER iterUserSelection( pdlgUserBrows ) ;
	    BROWSER_SUBJECT * pBrowserSubject ;

	    if ( ! (err = iterUserSelection.QueryError()) )
	    {
		while ( !(err = iterUserSelection.Next( &pBrowserSubject )) &&
			 pBrowserSubject != NULL )
		{
		    ACCESS_PERMISSION * pPerm ;
		    SID_NAME_USE SidType = pBrowserSubject->QueryType() ;
		    if ( SidType == SidTypeUser )
		    {
			/* If this is a remote account, then cast the type
			 * to our own "private" sid name use SubjTypeRemote.
			 */
			if ( pBrowserSubject->QueryUserAccountFlags() &
						   USER_TEMP_DUPLICATE_ACCOUNT)
			{
			    SidType = (SID_NAME_USE) SubjTypeRemote ;
			}
		    }

		    if ( err = pBrowserSubject->QueryQualifiedName(
							&nlsDisplayName,
							&nlsDomainName,
							TRUE ))
		    {
			break ;
		    }

		    SUBJECT * pSubj = new NT_SUBJECT(
					   (PSID) *pBrowserSubject->QuerySid(),
					   nlsDisplayName,
					   SidType,
					   pBrowserSubject->QuerySystemSidType() );
		    if ( err = (pSubj==NULL? ERROR_NOT_ENOUGH_MEMORY :
				pSubj->QueryError()))
		    {
			break ;
		    }

		    /* Deletes the subject automatically if we fail to build the
		     * permission.
		     */
		    err = QueryAclConverter()->BuildPermission(
				 (PERMISSION **)&pPerm,
				 TRUE,
				 pSubj,
				 &bitPerms,
				 QueryAclConverter()->IsNewObjectsSupported() &&
				    fIsNewPermsSpecified ?
				    &bitNewObjPerms : NULL ) ;
		    if (  err ||
			 (err = _accperm.AddPermission( pPerm )) )
		    {
			break ;
		    }
		}
	    }
	} while ( FALSE ) ; // error breakout loop

	delete pdlgUserBrows ;
    }
    else
    {
	/* The following is for Lanman (downlevel) only.
	 */
	RESOURCE_STR nlsDialogTitle( IDS_ADD_PERM_DIALOG_TITLE ) ;
	if ( err = nlsDialogTitle.QueryError() )
	{
	    return err ;
	}

	AUTO_CURSOR autoHourGlass ;
	ADD_PERM_DIALOG *pdlgAddPerm = new ADD_PERM_DIALOG( MAKEINTRESOURCE(IDD_SED_LM_ADD_PERM_DLG),
							    QueryRobustHwnd(),
							    QueryResType(),
							    QueryResName(),
                                                            QueryHelpFileName(),
                                                            QueryHelpArray(),
							    nlsDialogTitle,
							    QueryAccessMap(),
							    *((LOCATION *)QueryAclConverter()->QueryLocation()),
							    QueryDefaultPermName() ) ;

	if ( pdlgAddPerm == NULL )
	    return ERROR_NOT_ENOUGH_MEMORY ;

	BOOL fUserPressedOK ;
	err = pdlgAddPerm->Process( &fUserPressedOK ) ;

	if ( err == NERR_Success && fUserPressedOK )
	{
	    AUTO_CURSOR cursHourGlass ;

	    /* Get the access mask
	     */
	    BITFIELD bitPermMask( (ULONG) 0 ) ;

	    err = pdlgAddPerm->QueryPermBitMask( &bitPermMask ) ;
	    if ( err != NERR_Success )
	    {
		delete pdlgAddPerm ;
		return err ;
	    }

	    /* Grab all of the selections from listbox and add them with the
	     * appropriate permissions to the Add Dialog.
	     */
	    for ( int iNewSubj = 0 ;
		  iNewSubj < pdlgAddPerm->QuerySelectedSubjectCount() ;
		  iNewSubj++ )
	    {
		ACCESS_PERMISSION * pPerm ;

		/* Deletes the subject automatically if we fail to build the
		 * permission.
		 */
		err = QueryAclConverter()->BuildPermission( (PERMISSION **)&pPerm,
							    TRUE,
							    pdlgAddPerm->RemoveSubject(iNewSubj),
							    &bitPermMask ) ;

		if (  err ||
		     (err = _accperm.AddPermission( pPerm )) )
		{
		    break ;
		}
	    }
	}

	delete pdlgAddPerm ;
    }

    /* Now replenish the listbox with the newly added items
     */
    if ( err ||
	 (err = _plbPermissionList->Fill() ) != NERR_Success )
    {
	return err ;
    }

    _psubjlbGroup->UpdateSubjectListbox() ;

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnSpecial

    SYNOPSIS:	Brings up the default special dialog

    ENTRY:	pAccessPermLBI - the access item to display in the special
		    dialog.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnSpecial( SUBJ_PERM_LBI * pAccessPermLBI )
{
    APIERR err ;

    if ( !pAccessPermLBI->QueryAccessPerm()->IsMapped() )
    {
        ::MsgPopup( this,
                    IDS_NOT_MAPPED_WARNING,
                    MPSEV_WARNING,
                    MP_OK ) ;
        return NERR_Success ;
    }

    NLS_STR nlsDialogTitle( _plbPermissionList->QuerySpecialAccessName() ) ;

    if ( (err = nlsDialogTitle.QueryError() ))
    {
	return err ;
    }

    UIASSERT( pAccessPermLBI != NULL ) ;

    /* If the dialog title has an "..." following it, then strip it (the dialog
     * title is derived from the special access name which generally looks
     * like ("Special Access..." or "Special NEW File Access..." etc.).
     */
    ISTR istrEllipsis( nlsDialogTitle ) ;
    ALIAS_STR nlsEllipsis( SZ("..." ) ) ;
    if ( nlsDialogTitle.strstr( &istrEllipsis, nlsEllipsis ))
    {
	/* Check to make sure the ellipsis is at the end of the string
	 */
	ISTR istrEllipsisEnd( istrEllipsis ) ;
	istrEllipsisEnd += nlsEllipsis.QueryTextLength() ;

	if ( nlsDialogTitle.QueryChar( istrEllipsisEnd ) == TCH('\0'))
	{
	    nlsDialogTitle.DelSubStr( istrEllipsis ) ;
	}
    }

    SPECIAL_DIALOG * pSpecDialog ;
    if ( IsNT() )
    {
	pSpecDialog = new NT_SPECIAL_DIALOG(
			      MAKEINTRESOURCE(IDD_SPECIAL_PERM_DLG),
			      QueryHwnd(),
			      QueryResType(),
			      QueryResName(),
			      QueryHelpFileName(),
			      nlsDialogTitle,
			      pAccessPermLBI->QueryAccessPerm()->QueryAccessBits(),
			      pAccessPermLBI->QueryMaskMap(),
			      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                              QueryHelpArray(),
			      IsReadOnly() ) ;
    }
    else
    {
	/* This is a downlevel Lanman client
	 */
	pSpecDialog = new SPECIAL_DIALOG(
			      MAKEINTRESOURCE(IDD_SED_LM_SPECIAL_PERM_DLG),
			      QueryHwnd(),
			      QueryResType(),
			      QueryResName(),
			      QueryHelpFileName(),
			      nlsDialogTitle,
			      pAccessPermLBI->QueryAccessPerm()->QueryAccessBits(),
			      pAccessPermLBI->QueryMaskMap(),
			      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                              QueryHelpArray(),
			      IsReadOnly() ) ;
    }

    if ( pSpecDialog == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }

    do { // error breakout loop

	BOOL fUserPressedOK ;
	if ( (err = pSpecDialog->QueryError()) ||
	     (err = pSpecDialog->Process( &fUserPressedOK )))
	{
	    break ;
	}

	_plbPermissionList->InvalidateItem( _plbPermissionList->QueryCurrentItem() ) ;
    } while (FALSE) ;

    delete pSpecDialog ;

    /* We have to refresh the permission name even if an error occurred,
     * otherwise the "Special Accessname" hangs around in the combo box
     */
    pAccessPermLBI->RefreshPermName() ;
    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnNewObjectSpecial

    SYNOPSIS:	Default implementation (does nothing).

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_ACCESS_PERM_BASE_DLG::OnNewObjectSpecial( SUBJ_PERM_LBI * pSubjPermLBI )
{
    UNREFERENCED( pSubjPermLBI ) ;
    ASSERT(!SZ("For show only!"));
    return NERR_Success ;
}

/*******************************************************************

    NAME:	OBJECT_ACCESS_PERMISSION_DLG::OBJECT_ACCESS_PERMISSION_DLG

    SYNOPSIS:	Basic constructor for Object Access Permission dialog
		This is a real dialog

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

OBJECT_ACCESS_PERMISSION_DLG::OBJECT_ACCESS_PERMISSION_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : MULTI_SUBJ_ACCESS_PERM_BASE_DLG( pszDialogName,
				       hwndParent,
				       pszDialogTitle,
				       paclconv,
				       pszResourceType,
				       pszResourceName,
				       pszHelpFileName,
				       &_lbPermissionList,
				       &_subjlbGroup,
				       pszSpecialAccessName,
				       pszDefaultPermName,
                                       ahcMainDialog ),
      _lbPermissionList( this,
			 LB_SUBJECT_PERMISSIONS,
			 &_accperm,
			 pszSpecialAccessName ),
      _subjlbGroup     ((MULTI_SUBJ_ACCESS_PERM_BASE_DLG *) this,
			 &_lbPermissionList,
			 QueryPermNameCombo(),
                         QueryRemoveButton(),
                         QueryComboBoxTitle() )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("OBJECT_ACCESS_PERMISSION_DLG::ct - Parent or control returned error\n\r")) ;
	UIASSERT(FALSE);     // For debugging purposes
	return ;
    }

    if ( _subjlbGroup.QueryError() )
    {
	ReportError( _subjlbGroup.QueryError() ) ;
	UIDEBUG(SZ("OBJECT_ACCESS_PERMISSION_DLG::ct - _subjlbGroup report error\n\r")) ;
	return ;
    }
}

OBJECT_ACCESS_PERMISSION_DLG::~OBJECT_ACCESS_PERMISSION_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_OBJECT_ACCESS_PERMISSION_DLG::NT_OBJECT_ACCESS_PERMISSION_DLG

    SYNOPSIS:	Basic constructor for Object Access Permission dialog
		This is a real dialog

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

NT_OBJECT_ACCESS_PERMISSION_DLG::NT_OBJECT_ACCESS_PERMISSION_DLG(
			   const TCHAR *	    pszDialogName,
			   HWND 		    hwndParent,
			   const TCHAR *	    pszDialogTitle,
			   ACL_TO_PERM_CONVERTER *  paclconv,
			   const TCHAR *	    pszResourceType,
			   const TCHAR *	    pszResourceName,
			   const TCHAR *	    pszHelpFileName,
			   const TCHAR *	    pszSpecialAccessName,
			   const TCHAR *	    pszDefaultPermName,
                           ULONG       *            ahcMainDialog )
    : OBJECT_ACCESS_PERMISSION_DLG( pszDialogName,
				    hwndParent,
				    pszDialogTitle,
				    paclconv,
				    pszResourceType,
				    pszResourceName,
				    pszHelpFileName,
				    pszSpecialAccessName,
				    pszDefaultPermName,
                                    ahcMainDialog ),
      _sleOwner( this, SLE_OWNER )
{
    if ( QueryError() )
    {
	UIDEBUG(SZ("NT_OBJECT_ACCESS_PERMISSION_DLG::ct - Parent or control returned error\n\r")) ;
	return ;
    }
}

NT_OBJECT_ACCESS_PERMISSION_DLG::~NT_OBJECT_ACCESS_PERMISSION_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_OBJECT_ACCESS_PERMISSION_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_OBJECT_ACCESS_PERMISSION_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = OBJECT_ACCESS_PERMISSION_DLG::Initialize( pfUserQuit,
							    fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::MULTI_SUBJ_CONT_ACCESS_PERM_BASE

    SYNOPSIS:	Basic constructor of the Container access permissions dialog

    NOTES:	If the checkbox title is NULL, then we will disable and hide
		the checkbox.

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

MULTI_SUBJ_CONT_ACCESS_PERM_BASE::MULTI_SUBJ_CONT_ACCESS_PERM_BASE(
		      const TCHAR *	       pszDialogName,
		      HWND		       hwndParent,
		      const TCHAR *	       pszDialogTitle,
		      ACL_TO_PERM_CONVERTER *  paclconv,
		      const TCHAR *	       pszResourceType,
		      const TCHAR *	       pszResourceName,
		      const TCHAR *	       pszHelpFileName,
		      SUBJECT_PERM_LISTBOX *   plbPermissionList,
		      SUBJ_LB_GROUP *	       psubjlbGroup,
		      const TCHAR *	       pszSpecialAccessName,
		      const TCHAR *	       pszDefaultPermName,
                      ULONG       *            ahcMainDialog,
		      const TCHAR *	       pszAssignToExistingContTitle,
		      const TCHAR *	       pszTreeApplyHelpText,
		      const TCHAR *	       pszTreeApplyConfirmation )
    : MULTI_SUBJ_ACCESS_PERM_BASE_DLG( pszDialogName,
				       hwndParent,
				       pszDialogTitle,
				       paclconv,
				       pszResourceType,
				       pszResourceName,
				       pszHelpFileName,
				       plbPermissionList,
				       psubjlbGroup,
				       pszSpecialAccessName,
				       pszDefaultPermName,
                                       ahcMainDialog ),
      _checkAssignToExistingContainers( this, CHECK_APPLY_TO_CONT ),
      _sltfontTreeApplyHelpText       ( this, SLT_TREE_APPLY_HELP_TEXT ),
      _pszTreeApplyConfirmation       ( pszTreeApplyConfirmation )
{
    if ( QueryError() )
	return ;

    if ( pszAssignToExistingContTitle != NULL )
    {
	_checkAssignToExistingContainers.SetText( pszAssignToExistingContTitle ) ;

#if 0
	if ( pszTreeApplyHelpText != NULL )
	{
	    _sltfontTreeApplyHelpText.SetText( pszTreeApplyHelpText ) ;
        }
#endif
    }
    else
    {
	_checkAssignToExistingContainers.Show( FALSE ) ;
	_checkAssignToExistingContainers.Enable( FALSE ) ;
    }
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK( void )
{
    APIERR err ;
    BOOL fAssignToTree = FALSE ;

    if ( IsReadOnly() )
    {
	Dismiss( TRUE ) ;
	return TRUE ;
    }

    //
    //  If no grants, warn the user.
    //
    BOOL fIsDenyAll = FALSE ;
    if (  IsNT() &&
          (err = _accperm.AnyDenyAllsToEveryone( &fIsDenyAll )) )
    {
	::MsgPopup( this, (MSGID) err ) ;
	return TRUE ;
    }

    if (  fIsDenyAll )
    {
	switch ( ::MsgPopup( this,
			     IDS_DENY_ALL_EVERYONE_WARNING,
			     MPSEV_WARNING,
			     MP_YESNO,
			     QueryResName(),
			     MP_NO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	default:
	    return TRUE ;
	}
    }


    if ( IsAssignToExistingContChecked() )
    {
	NLS_STR nlsResName(40) ;
	NLS_STR nlsTreeApplyConfirmation( _pszTreeApplyConfirmation ) ;
	if ( (err = nlsResName.QueryError()) ||
	     (err = QueryResName( &nlsResName )) ||
	     (err = nlsTreeApplyConfirmation.InsertParams( 1, &nlsResName )) )
	{
	    ::MsgPopup( this, (MSGID) err ) ;
	    return FALSE ;
	}

	switch ( MsgPopup( this,
			   IDS_PERCENT_1,
			   MPSEV_WARNING,
			   MP_YESNO,
			   nlsTreeApplyConfirmation ))
	{
	case IDYES:
	    fAssignToTree = TRUE ;
	    break ;

	default:
	    UIASSERT(FALSE) ;
	    /* fall through
	     */

	case IDNO:
	    return TRUE ;
	}
    }

    if ( WritePermissions(fAssignToTree,
                          IsAssignToExistingObjChecked(),
			  TREEAPPLY_ACCESS_PERMS ) )
    {
	Dismiss( TRUE ) ;
    }
    else
    {
	//
	// Set the OK button to "Close" if the tree apply failed (ignore any
	// errors).
	//

        if ( fAssignToTree || QueryAclConverter()->IsNewObjectsSupported() )
	{
	    RESOURCE_STR nlsClose( IDS_CLOSE ) ;
	    if ( !nlsClose.QueryError() )
	    {
		_buttonCancel.SetText( nlsClose ) ;
	    }
	}
    }

    return TRUE ;
}

MULTI_SUBJ_CONT_ACCESS_PERM_BASE::~MULTI_SUBJ_CONT_ACCESS_PERM_BASE()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize

    SYNOPSIS:	Disables the tree apply checkbox if we are readonly

    EXIT:	The dialog should be ready to go or an error will have
		occurred.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The Remove button will be disabled if this dialog is read only

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

APIERR MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize( BOOL * pfUserQuit,
						     BOOL fAccessPerms )
{
    APIERR err = MULTI_SUBJ_ACCESS_PERM_BASE_DLG::Initialize( pfUserQuit,
							      fAccessPerms ) ;

    /* Note that this gets called even if the user cancelled an intermediate
     * message dialog
     */
    if ( !err && IsReadOnly() )
    {
	_checkAssignToExistingContainers.Enable( FALSE ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked

    SYNOPSIS:   Returns TRUE if permissions should be applied to existing
                objects, FALSE otherwise

    HISTORY:
        Johnl   31-Mar-1993     Created

********************************************************************/

BOOL MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked( void )
{
    return FALSE ;
}

/*******************************************************************

    NAME:	CONT_ACCESS_PERM_DLG::CONT_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

CONT_ACCESS_PERM_DLG::CONT_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
		       const TCHAR *		   pszAssignToExistingContTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : MULTI_SUBJ_CONT_ACCESS_PERM_BASE( pszDialogName,
					hwndParent,
					pszDialogTitle,
					paclconv,
					pszResourceType,
					pszResourceName,
					pszHelpFileName,
					&_lbPermissionList,
					&_subjlbGroup,
					pszSpecialAccessName,
					pszDefaultPermName,
                                        ahcMainDialog,
					pszAssignToExistingContTitle,
					pszTreeApplyHelpText,
					pszTreeApplyConfirmation ),
      _lbPermissionList( this, LB_SUBJECT_PERMISSIONS, &_accperm, pszSpecialAccessName ),
      _subjlbGroup( ( MULTI_SUBJ_ACCESS_PERM_BASE_DLG *) this,
		    &_lbPermissionList,
		    QueryPermNameCombo(),
                    QueryRemoveButton(),
                    QueryComboBoxTitle() )
{
    if ( QueryError() )
	return ;
}

/*******************************************************************

    NAME:	CONT_ACCESS_PERM_DLG::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL CONT_ACCESS_PERM_DLG::OnOK( void )
{
    APIERR err ;
    BOOL fDismissDialog ;
    if ( err = _subjlbGroup.OnEnter( &fDismissDialog ) )
    {
	return err ;
    }

    if ( fDismissDialog )
    {
	return MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK() ;
    }

    return TRUE ;
}

CONT_ACCESS_PERM_DLG::~CONT_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_NO_OBJ_ACCESS_PERM_DLG::NT_CONT_NO_OBJ_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_NO_OBJ_ACCESS_PERM_DLG::NT_CONT_NO_OBJ_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
                       const TCHAR *               pszAssignToExistingContTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : CONT_ACCESS_PERM_DLG( pszDialogName,
			    hwndParent,
			    pszDialogTitle,
			    paclconv,
			    pszResourceType,
			    pszResourceName,
			    pszHelpFileName,
			    pszSpecialAccessName,
			    pszDefaultPermName,
                            ahcMainDialog,
			    pszAssignToExistingContTitle,
			    pszTreeApplyHelpText,
                            pszTreeApplyConfirmation ),
    _sleOwner( this, SLE_OWNER )
{
    if ( QueryError() )
	return ;
}

NT_CONT_NO_OBJ_ACCESS_PERM_DLG::~NT_CONT_NO_OBJ_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_NO_OBJ_ACCESS_PERM_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_CONT_NO_OBJ_ACCESS_PERM_DLG::Initialize( BOOL * pfUserQuit,
						   BOOL fAccessPerms )
{
    APIERR err = CONT_ACCESS_PERM_DLG::Initialize( pfUserQuit,
						   fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::NT_CONT_ACCESS_PERM_DLG

    SYNOPSIS:	Basic constructor for the NT Container access permission dialog
		This is a real dialog.

    ENTRY:	Same as parent

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_ACCESS_PERM_DLG::NT_CONT_ACCESS_PERM_DLG(
		       const TCHAR *		   pszDialogName,
		       HWND			   hwndParent,
		       const TCHAR *		   pszDialogTitle,
		       ACL_TO_PERM_CONVERTER *	   paclconv,
		       const TCHAR *		   pszResourceType,
		       const TCHAR *		   pszResourceName,
		       const TCHAR *		   pszHelpFileName,
		       const TCHAR *		   pszSpecialAccessName,
		       const TCHAR *		   pszDefaultPermName,
                       ULONG       *               ahcMainDialog,
		       const TCHAR *		   pszNewObjectSpecialAccessName,
		       const TCHAR *		   pszAssignToExistingContTitle,
                       const TCHAR *               pszAssignToExistingObjTitle,
		       const TCHAR *		   pszTreeApplyHelpText,
		       const TCHAR *		   pszTreeApplyConfirmation )
    : MULTI_SUBJ_CONT_ACCESS_PERM_BASE( pszDialogName,
					hwndParent,
					pszDialogTitle,
					paclconv,
					pszResourceType,
					pszResourceName,
					pszHelpFileName,
					&_lbPermissionList,
					&_subjlbGroup,
					pszSpecialAccessName,
					pszDefaultPermName,
                                        ahcMainDialog,
					pszAssignToExistingContTitle,
					pszTreeApplyHelpText,
					pszTreeApplyConfirmation ),
      _lbPermissionList( this, LB_SUBJECT_PERMISSIONS, &_accperm,
			 pszSpecialAccessName, pszNewObjectSpecialAccessName ),
      _subjlbGroup( this,
		    &_lbPermissionList,
		    QueryPermNameCombo(),
                    QueryRemoveButton(),
                    QueryComboBoxTitle() ),
      _sleOwner( this, SLE_OWNER ),
      _checkApplyToExistingObjects( this, CHECK_APPLY_TO_OBJ )
{
    if ( QueryError() )
	return ;

    //
    //  Add the New Object Special Access item to the combo box
    //
    if ( (pszNewObjectSpecialAccessName != NULL) &&
	 (QueryPermNameCombo()->InsertItem( QueryPermNameCombo()->QueryCount(),
					    pszNewObjectSpecialAccessName ) < 0) )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    //
    //  Set the assign to existing objects checkbox if the string is non-NULL
    //
    if ( pszAssignToExistingObjTitle != NULL )
    {
        _checkApplyToExistingObjects.SetText( pszAssignToExistingObjTitle ) ;
        _checkApplyToExistingObjects.SetCheck( TRUE ) ;
    }
    else
    {
        _checkApplyToExistingObjects.Enable( FALSE ) ;
        _checkApplyToExistingObjects.Show( FALSE ) ;
    }

}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::OnOK

    SYNOPSIS:	Write the permissions out and check the apply to flags
		as appropriate.

    EXIT:	A message will be displayed to the user if an error
		occurred.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERM_DLG::OnOK( void )
{
    APIERR err ;
    BOOL fDismissDialog ;
    if ( err = _subjlbGroup.OnEnter( &fDismissDialog ) )
    {
	return err ;
    }

    if ( fDismissDialog )
    {
	return MULTI_SUBJ_CONT_ACCESS_PERM_BASE::OnOK() ;
    }

    return TRUE ;
}

NT_CONT_ACCESS_PERM_DLG::~NT_CONT_ACCESS_PERM_DLG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::OnNewObjectSpecial

    SYNOPSIS:	Brings up the New Object special dialog

    ENTRY:	pAccessPermLBI - the access item to display in the special
		    dialog.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERM_DLG::OnNewObjectSpecial( SUBJ_PERM_LBI * pAccessPermLBI )
{
    if ( !pAccessPermLBI->QueryAccessPerm()->IsMapped() )
    {
        ::MsgPopup( this,
                    IDS_NOT_MAPPED_WARNING,
                    MPSEV_WARNING,
                    MP_OK ) ;
        return NERR_Success ;
    }

    NLS_STR nlsDialogTitle( ((NT_CONT_SUBJECT_PERM_LISTBOX*)
			    QuerySubjectPermListbox())->
			     QuerySpecialNewObjectAccessName() ) ;
    APIERR err ;

    if ( (err = nlsDialogTitle.QueryError() ))
    {
	return err ;
    }

    UIASSERT( pAccessPermLBI != NULL ) ;

    /* If the dialog title has an "..." following it, then strip it (the dialog
     * title is derived from the special access name which generally looks
     * like ("Special Access..." or "Special File Access..." etc.).
     */
    ISTR istrEllipsis( nlsDialogTitle ) ;
    ALIAS_STR nlsEllipsis( SZ("..." ) ) ;
    if ( nlsDialogTitle.strstr( &istrEllipsis, nlsEllipsis ))
    {
	/* Check to make sure the ellipsis is at the end of the string
	 */
	ISTR istrEllipsisEnd( istrEllipsis ) ;
	istrEllipsisEnd += nlsEllipsis.QueryTextLength() ;

	if ( nlsDialogTitle.QueryChar( istrEllipsisEnd ) == TCH('\0'))
	{
	    nlsDialogTitle.DelSubStr( istrEllipsis ) ;
	}
    }

    NT_CONT_ACCESS_PERMISSION * pntcontperm = (NT_CONT_ACCESS_PERMISSION*)
					    pAccessPermLBI->QueryAccessPerm() ;

    NEW_OBJ_SPECIAL_DIALOG * pSpecDialog = new NEW_OBJ_SPECIAL_DIALOG(
				      MAKEINTRESOURCE(IDD_SED_NEW_OBJ_SPECIAL_PERM_DLG),
				      QueryHwnd(),
				      QueryResType(),
				      QueryResName(),
				      QueryHelpFileName(),
				      nlsDialogTitle,
				      pntcontperm->QueryNewObjectAccessBits(),
				      pAccessPermLBI->QueryNewObjectMaskMap(),
				      pAccessPermLBI->QuerySubject()->QueryDisplayName(),
                                      QueryHelpArray(),
				      IsReadOnly(),
				      pntcontperm->IsNewObjectPermsSpecified() ) ;

    if ( pSpecDialog == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    BOOL fUserPressedOK ;
    if ( ( err = pSpecDialog->QueryError()) ||
	 ( err = pSpecDialog->Process( &fUserPressedOK )))
    {
	return err ;
    }

    if ( fUserPressedOK )
    {
	pntcontperm->SetNewObjectPermsSpecified( !pSpecDialog->IsNotSpecified());

	err = pAccessPermLBI->RefreshPermName() ;
	if ( err != NERR_Success )
	    return err ;

	QuerySubjectPermListbox()->InvalidateItem( QuerySubjectPermListbox()->QueryCurrentItem() ) ;
    }

    delete pSpecDialog ;

    /* We have to refresh the permission name even if an error occurred,
     * otherwise the "Special Accessname" hangs around in the combo box
     */
    pAccessPermLBI->RefreshPermName() ;
    return NERR_Success ;

}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERM_DLG::Initialize

    SYNOPSIS:	Fills in the owner field after we have gotten the
		permissions

    ENTRY:	Same as base Initialize

    HISTORY:
	Johnl	16-Nov-1992	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERM_DLG::Initialize( BOOL * pfUserQuit,
						    BOOL fAccessPerms )
{
    APIERR err = MULTI_SUBJ_CONT_ACCESS_PERM_BASE::Initialize( pfUserQuit,
							       fAccessPerms ) ;
    if ( !err && QueryAclConverter()->QueryOwnerName() != NULL )
    {
	_sleOwner.SetText( QueryAclConverter()->QueryOwnerName() ) ;
    }

    if ( !err && IsReadOnly() )
        _checkApplyToExistingObjects.Enable( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       MULTI_SUBJ_CONT_ACCESS_PERM_BASE::IsAssignToExistingObjChecked

    SYNOPSIS:   Returns TRUE if permissions should be applied to existing
                objects, FALSE otherwise

    HISTORY:
        Johnl   31-Mar-1993     Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERM_DLG::IsAssignToExistingObjChecked( void )
{
    return _checkApplyToExistingObjects.QueryCheck() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\perm.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    perm.cxx

    This file contains the implementation for the PERMISSION class and
    the derived classes.



    FILE HISTORY:
	Johnl	05-Aug-1991	Created

*/
#include <ntincl.hxx>

#define INCL_DOSERRORS
#define INCL_NETERRORS
#include <lmui.hxx>
#include <base.hxx>
#include <bitfield.hxx>
#include <accperm.hxx>


#include <uiassert.hxx>
#include <uitrace.hxx>

#include <perm.hxx>

/*******************************************************************

    NAME:	PERMISSION::PERMISSION

    SYNOPSIS:	Constructor for PERMISSION class

    ENTRY:	psubject - Client allocated SUBJECT object (we will free)
		bitsInitPerm - Initial bitflags

    EXIT:

    RETURNS:

    NOTES:	psubject will be freed on destruction by this class using
		delete.

		pbitsInitPerm cannot be NULL.

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/


PERMISSION::PERMISSION(  SUBJECT  * psubject,
                         BITFIELD * pbitsInitPerm,
                         BOOL       fContainerPermsInheritted,
                         BOOL       fIsMapped )
    : _psubject                 ( psubject ),
      _bitsPermFlags            ( *pbitsInitPerm ),
      _fContainerPermsInheritted( fContainerPermsInheritted ),
      _fIsMapped                ( fIsMapped ),
      _bitsSpecialFlags         ( *pbitsInitPerm ),
      _fSpecialContInheritted   ( fContainerPermsInheritted ),
      _fSpecialIsMapped         ( fIsMapped )
{

    APIERR err ;
    if ( ((err = _psubject->QueryError()) != NERR_Success) ||
	 ((err = _bitsPermFlags.QueryError() != NERR_Success )) ||
	 ((err = _bitsSpecialFlags.QueryError() != NERR_Success ))   )
    {
	ReportError( err ) ;
	return ;
    }

}

/*******************************************************************

    NAME:	PERMISSION::~PERMISSION

    SYNOPSIS:	Typical destructor

    NOTES:	Deletes the subject when destructed

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

PERMISSION::~PERMISSION()
{
    delete _psubject ;
    _psubject = NULL ;
}

BITFIELD * PERMISSION::QueryPermBits( void )
{
    return &_bitsPermFlags ;
}

/*******************************************************************

    NAME:	PERMISSION::SetPermission

    SYNOPSIS:	Given the mask map and permission name, set the permission
		bits appropriately

    ENTRY:	nlsPermName - Name to set permission to (looked up in
		     mask maps)
		pmapThis - Mask map object that tells us how to interpret
		     the permission name
		pmapNewObj - Not used here, will be used by NT derived
		     permissions

    EXIT:	The permission bits of this permission will be set if
		a match is found, else the special bits will be restored
		if no permission name in the mask map matches the passed
		permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::SetPermission( const NLS_STR & nlsPermName,
				  MASK_MAP * pmapThis,
				  MASK_MAP * pmapNewObj )
{
    UNREFERENCED( pmapNewObj ) ;
    ASSERT( pmapThis != NULL ) ;

    /* Lookup the bits associated with the new permission name
     */
    APIERR err = pmapThis->StringToBits( nlsPermName,
					 QueryPermBits(),
					 PERMTYPE_GENERAL ) ;

    /* The preceding call should always succeed, unless this is a special
     * permission.
     */
    switch ( err )
    {
    case ERROR_NO_ITEMS:
       err = RestoreSpecial() ;
       break ;

    case NERR_Success:
        SetMappedStatus( TRUE ) ;
        SetContainerPermsInheritted( TRUE ) ;
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	PERMISSION::SaveSpecial

    SYNOPSIS:	Store away the current bitfields so they can be restored
		at some later time.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::SaveSpecial( void )
{
    APIERR err = _bitsSpecialFlags.Resize( _bitsPermFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _fSpecialContInheritted = _fContainerPermsInheritted ;
    _fSpecialIsMapped       = _fIsMapped ;
    _bitsSpecialFlags       = _bitsPermFlags ;
    UIASSERT( _bitsSpecialFlags.QueryError() == NERR_Success ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	PERMISSION::RestoreSpecial

    SYNOPSIS:	Restores the bits that were saved as special bits

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR PERMISSION::RestoreSpecial( void )
{
    APIERR err = _bitsPermFlags.Resize( _bitsSpecialFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _bitsPermFlags             = _bitsSpecialFlags ;
    _fContainerPermsInheritted = _fSpecialContInheritted ;
    _fIsMapped                 = _fSpecialIsMapped ;
    UIASSERT( _bitsPermFlags.QueryError() == NERR_Success ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	PERMISSION::IsNewObjectPermsSupported

    SYNOPSIS:	Defaults for several query functions

    NOTES:	These are all virtual.

    HISTORY:
	Johnl	14-May-1992	Created

********************************************************************/

BOOL PERMISSION::IsNewObjectPermsSupported( void ) const
{
    return FALSE ;
}

BITFIELD * PERMISSION::QueryNewObjectAccessBits( void )
{
    return NULL ;
}

BOOL PERMISSION::IsNewObjectPermsSpecified( void ) const
{
    return FALSE ;
}

/*******************************************************************

    NAME:	ACCESS_PERMISSION::ACCESS_PERMISSION

    SYNOPSIS:	Constructor for Access permission

    ENTRY:	Same as parent

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

ACCESS_PERMISSION::ACCESS_PERMISSION(  SUBJECT  * psubject,
                                       BITFIELD * pbitsInitPerm,
                                       BOOL       fContainerPermsInheritted,
                                       BOOL       fIsMapped )
    : PERMISSION( psubject, pbitsInitPerm, fContainerPermsInheritted, fIsMapped )
{
    if ( QueryError() != NERR_Success )
	return ;
}

ACCESS_PERMISSION::~ACCESS_PERMISSION()
{
    /*Nothing to do*/
}

BITFIELD * ACCESS_PERMISSION::QueryAccessBits( void )
{
    return ((ACCESS_PERMISSION *) this)->QueryPermBits() ;
}

/*******************************************************************

    NAME:	ACCESS_PERMISSION::IsGrantAll
		ACCESS_PERMISSION::IsDenyAll

    SYNOPSIS:	Returns TRUE if the passed access permission is a grant all or
		deny all (respectively).

    ENTRY:	bitsPermMask - Bitfield containing the access mask to check

    NOTES:	This is assumed to be an NT style permission

    HISTORY:
	Johnl	16-May-1992	Created

********************************************************************/

BOOL ACCESS_PERMISSION::IsGrantAll( const BITFIELD & bitsPermMask ) const
{
    /* Cast away the warning about operator::ULONG being a non-const
     * member - this should be fixed in the bitfield class
     */
    return (GENERIC_ALL & (ULONG) ((BITFIELD &) bitsPermMask )) ;
}

BOOL ACCESS_PERMISSION::IsDenyAll( const BITFIELD & bitsPermMask ) const
{
    return ( 0 == (ULONG) ((BITFIELD &)bitsPermMask )) ;
}


APIERR ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    APIERR err ;
    if ( err = QuerySubject()->IsEveryoneGroup( pfDenyAll ) )
	return err ;

    BITFIELD * pbf = (BITFIELD *) ((ACCESS_PERMISSION *) this)->QueryAccessBits() ;

    *pfDenyAll = *pfDenyAll && (0 == (ULONG) *pbf) ;
    return NERR_Success ;
}

BOOL ACCESS_PERMISSION::IsGrant( void ) const
{
    BITFIELD * pbf = (BITFIELD *) ((ACCESS_PERMISSION *) this)->QueryAccessBits() ;
    return 0 != (ULONG) *pbf ;
}

/*******************************************************************

    NAME:	LM_ACCESS_PERMISSION::LM_ACCESS_PERMISSION

    SYNOPSIS:	Constructor for Access permission

    ENTRY:	Same as parent
		fIsFile - Is this permission for a file?

    NOTES:

    HISTORY:
	Johnl	26-May-1992	Created

********************************************************************/

LM_ACCESS_PERMISSION::LM_ACCESS_PERMISSION( SUBJECT  * psubject,
					    BITFIELD * pbitsInitPerm,
					    BOOL       fIsFile )
    : ACCESS_PERMISSION( psubject, pbitsInitPerm, TRUE ),
      _fIsFile	       ( fIsFile )
{
    if ( QueryError() != NERR_Success )
	return ;

    /* Strip the Create bit if this is for a file
     */
    if ( fIsFile )
    {
	*QueryPermBits() &= (USHORT) ~ACCESS_CREATE ;
    }
}

LM_ACCESS_PERMISSION::~LM_ACCESS_PERMISSION()
{
    /*Nothing to do*/
}

/*******************************************************************

    NAME:	LM_ACCESS_PERMISSION::IsGrantAll
		LM_ACCESS_PERMISSION::IsDenyAll

    SYNOPSIS:	Returns TRUE if the passed access permission is a grant all or
		deny all (respectively).

    ENTRY:	bitfield - Bitfield containing the access mask to check

    NOTES:	This is assumed to be a LAN Manager style permission

    HISTORY:
	Johnl	26-May-1992	Created

********************************************************************/

BOOL LM_ACCESS_PERMISSION::IsGrantAll( const BITFIELD & bitsPermMask ) const
{
    return (!_fIsFile) ?
	   ( ACCESS_ALL == (USHORT) ((BITFIELD &)bitsPermMask)) :
	   ( (ACCESS_ALL & ~ACCESS_CREATE) ==
				 ((USHORT) ((BITFIELD &)bitsPermMask))) ;
}

BOOL LM_ACCESS_PERMISSION::IsDenyAll( const BITFIELD & bitsPermMask ) const
{
    return ( 0 == (USHORT) ((BITFIELD &)bitsPermMask )) ;
}

APIERR LM_ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    //
    //	You can't deny everyone under LM
    //
    *pfDenyAll = FALSE ;
    return NERR_Success ;
}

BOOL LM_ACCESS_PERMISSION::IsGrant( void ) const
{
    //
    // Everything is grant under LM
    //
    return TRUE ;
}

/*******************************************************************

    NAME:	AUDIT_PERMISSION::AUDIT_PERMISSION

    SYNOPSIS:	Audit permission constructor

    ENTRY:	Same as parent except bitsFailFlags indicate the failed
		audit bits

    NOTES:	pbitsFailFlags cannot be NULL.

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

AUDIT_PERMISSION::AUDIT_PERMISSION(   SUBJECT  * psubject,
				      BITFIELD * pbitsSuccessFlags,
                                      BITFIELD * pbitsFailFlags,
                                      BOOL       fPermsInherited,
                                      BOOL       fIsMapped )
    : PERMISSION( psubject, pbitsSuccessFlags, fPermsInherited, fIsMapped ),
      _bitsFailAuditFlags( *pbitsFailFlags )
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err = _bitsFailAuditFlags.QueryError() ;
    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }
}

AUDIT_PERMISSION::~AUDIT_PERMISSION()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::NT_CONT_ACCESS_PERMISSION

    SYNOPSIS:	NT Container access permission object

    ENTRY:	Same as parent except pbitsInitNewObjectPerm are the access
		bits for newly created objects contained in this
		container

    NOTES:	pbitsInitNewObj maybe NULL, in which case the
		_fNewObjectPermsSpecified flag will be set to FALSE.

    HISTORY:
	Johnl	05-Aug-1991	Created
	Johnl	07-Jan-1992	Changed const & bit fields to pointers
				to allow for NULL parameters

********************************************************************/

NT_CONT_ACCESS_PERMISSION::NT_CONT_ACCESS_PERMISSION(
					    SUBJECT  * psubject,
					    BITFIELD * pbitsInitPerm,
					    BITFIELD * pbitsInitNewObjectPerm,
                                            BOOL       fIsInherittedByContainers,
                                            BOOL       fIsMapped )
    : ACCESS_PERMISSION         ( psubject,
                                  pbitsInitPerm,
                                  fIsInherittedByContainers,
                                  fIsMapped),
      _bitsNewObjectPerm	( (ULONG) 0 ),
      _fNewObjectPermsSpecified ( pbitsInitNewObjectPerm==NULL ? FALSE : TRUE ),
      _bitsSpecialNewFlags	( (ULONG) 0 ),
      _fSpecialNewPermsSpecified( _fNewObjectPermsSpecified )
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _bitsNewObjectPerm.QueryError())  ||
	 (err = _bitsSpecialNewFlags.QueryError())  )
    {
	ReportError( err ) ;
	return ;
    }

    if ( pbitsInitNewObjectPerm != NULL )
    {
	if ( (err = _bitsNewObjectPerm.Resize( pbitsInitNewObjectPerm->QueryCount())) ||
	     (err = _bitsSpecialNewFlags.Resize( pbitsInitNewObjectPerm->QueryCount())) )
	{
	    ReportError( err ) ;
	    return ;
	}

	/* These will always succeed
	 */
	_bitsNewObjectPerm = *pbitsInitNewObjectPerm ;
	_bitsSpecialNewFlags = *pbitsInitNewObjectPerm ;
    }
}

NT_CONT_ACCESS_PERMISSION::~NT_CONT_ACCESS_PERMISSION()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::SetPermission

    SYNOPSIS:	Given the mask map and permission name, set the permission
		bits appropriately

    ENTRY:	nlsPermName - Name to set permission to (looked up in
		     mask maps)
		pmapThis - Mask map object that tells us how to interpret
		     the permission name
		pmapNewObj - Not used here, will be used by NT derived
		     permissions

    EXIT:	The permission bits of this permission will be set if
		a match is found, else the special bits will be restored
		if no permission name in the mask map matches the passed
		permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::SetPermission( const NLS_STR & nlsPermName,
				  MASK_MAP * pmapThis,
				  MASK_MAP * pmapNewObj )
{
    ASSERT( pmapNewObj != NULL ) ;

    /* Lookup the bits associated with the new permission name
     */
    APIERR err = pmapNewObj->StringToBits( nlsPermName,
					   QueryNewObjectAccessBits(),
					   PERMTYPE_GENERAL ) ;

    /* The preceding call should always succeed, unless this is a special
     * permission or the new object permissions are not specified.
     */
    switch ( err )
    {
    case ERROR_NO_ITEMS:
	SetNewObjectPermsSpecified( FALSE ) ;
	if (err = PERMISSION::SetPermission( nlsPermName, pmapThis, pmapNewObj))
	{
	    if ( err == ERROR_NO_ITEMS )
	    {
		err = RestoreSpecial() ;
	    }
	}
	else
	{
	    SetContainerPermsInheritted( TRUE ) ;
	}
	break ;

    case NERR_Success:
	SetNewObjectPermsSpecified( TRUE ) ;
	SetContainerPermsInheritted( TRUE ) ;
	err = PERMISSION::SetPermission( nlsPermName, pmapThis, pmapNewObj ) ;
	break ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::SaveSpecial

    SYNOPSIS:	Store away the current bitfields so they can be restored
		at some later time.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::SaveSpecial( void )
{
    APIERR err = _bitsSpecialNewFlags.Resize( _bitsNewObjectPerm.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _fSpecialNewPermsSpecified = IsNewObjectPermsSpecified() ;
    _bitsSpecialNewFlags = _bitsNewObjectPerm ;
    UIASSERT( _bitsSpecialNewFlags.QueryError() == NERR_Success ) ;

    return ACCESS_PERMISSION::SaveSpecial() ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::RestoreSpecial

    SYNOPSIS:	Restores the bits that were saved as special bits

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	25-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_ACCESS_PERMISSION::RestoreSpecial( void )
{
    APIERR err = _bitsNewObjectPerm.Resize( _bitsSpecialNewFlags.QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    _bitsNewObjectPerm = _bitsSpecialNewFlags ;
    UIASSERT( _bitsNewObjectPerm.QueryError() == NERR_Success ) ;
    SetNewObjectPermsSpecified( _fSpecialNewPermsSpecified ) ;

    return ACCESS_PERMISSION::RestoreSpecial() ;
}

/*******************************************************************

    NAME:	NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSupported

    SYNOPSIS:	Defaults for several query functions

    NOTES:	These are all virtual.

    HISTORY:
	Johnl	14-May-1992	Created

********************************************************************/

BOOL NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSupported( void ) const
{
    return TRUE ;
}

BITFIELD * NT_CONT_ACCESS_PERMISSION::QueryNewObjectAccessBits( void )
{
    return &_bitsNewObjectPerm ;
}

BOOL NT_CONT_ACCESS_PERMISSION::IsNewObjectPermsSpecified( void ) const
{
    return _fNewObjectPermsSpecified ;
}

APIERR NT_CONT_ACCESS_PERMISSION::IsDenyAllForEveryone( BOOL * pfDenyAll ) const
{
    //
    //	If the container permissions are deny all and either the new object
    //	permissions aren't specified or they are specified and they are
    //	0, then return TRUE.
    //
    APIERR err = ACCESS_PERMISSION::IsDenyAllForEveryone( pfDenyAll ) ;
    BITFIELD * pbf = (BITFIELD *) ((NT_CONT_ACCESS_PERMISSION *) this)->QueryNewObjectAccessBits() ;

    if ( ! err && *pfDenyAll )
    {
	*pfDenyAll = (!IsNewObjectPermsSpecified()) ||
		     (0 == (ULONG) *pbf) ;
    }

    return err ;
}

BOOL NT_CONT_ACCESS_PERMISSION::IsGrant( void ) const
{
    BITFIELD * pbf = (BITFIELD *) ((NT_CONT_ACCESS_PERMISSION *) this)->QueryNewObjectAccessBits() ;

    return ACCESS_PERMISSION::IsGrant() ||
            (IsNewObjectPermsSpecified() && (0 != (ULONG) *pbf) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\permprg.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    permprg.cxx
    Sample ACCPERM class client


    FILE HISTORY:
        rustanl     22-May-1991     Created
        Johnl       12-Aug-1991     Modified for new generic scheme

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntioapi.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETACCESS
#define INCL_NETAUDIT
#define INCL_NETUSE
#include <lmui.hxx>

extern "C"
{
    #include <helpnums.h>
    #include <mpr.h>
    #include <npapi.h>
}
#include <wfext.h>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <uitrace.hxx>
#include <lmobj.hxx>
#include <lmodev.hxx>
#include <security.hxx>
#include <netname.hxx>
#include <maskmap.hxx>
#include <fmx.hxx>
#include <fsenum.hxx>

#include <permstr.hxx>

#include <accperm.hxx>
#include <ipermapi.hxx>
#include <permprg.hxx>

#include <ntfsacl.hxx>

/* Local prototypes
 */
APIERR EditFSACL( HWND               hwndParent,
		  enum SED_PERM_TYPE sedpermtype  ) ;

APIERR CompareLMSecurityIntersection( HWND		 hwndFMX,
				      const TCHAR *	 pszServer,
				      enum SED_PERM_TYPE sedpermtype,
				      BOOL *		 pfACLEqual,
				      NLS_STR * 	 pnlsFailingFile ) ;

DWORD SedLMCallback( HWND                   hwndParent,
                     HANDLE                 hInstance,
                     ULONG_PTR              ulCallbackContext,
                     PSECURITY_DESCRIPTOR   psecdesc,
                     PSECURITY_DESCRIPTOR   psecdescNewObjects,
                     BOOLEAN                fApplyToSubContainers,
                     BOOLEAN                fApplyToSubObjects,
                     LPDWORD                StatusReturn
                   ) ;

/* Lanman permissions:
 */
#define ACCESS_GEN_NONE          (ACCESS_NONE)
#define ACCESS_GEN_SEE_USE       (ACCESS_READ|ACCESS_EXEC)

#define ACCESS_GEN_CHANGES_FILE  (ACCESS_GEN_SEE_USE|ACCESS_WRITE|ACCESS_ATRIB|ACCESS_DELETE)
#define ACCESS_GEN_FULL_FILE     (ACCESS_GEN_CHANGES_FILE|ACCESS_PERM)

#define ACCESS_GEN_CHANGES_DIR   (ACCESS_GEN_SEE_USE|ACCESS_WRITE|ACCESS_CREATE|ACCESS_ATRIB|ACCESS_DELETE)
#define ACCESS_GEN_FULL_DIR      (ACCESS_GEN_CHANGES_DIR|ACCESS_PERM)

US_IDS_PAIRS aLMDirAccessIdsPairs[] =
{
    { ACCESS_GEN_NONE,        IDS_GEN_LM_ACCESSNAME_DENY_ALL, PERMTYPE_GENERAL },
    { ACCESS_GEN_SEE_USE,     IDS_GEN_LM_ACCESSNAME_SEE_USE,  PERMTYPE_GENERAL },
    { ACCESS_GEN_CHANGES_DIR, IDS_GEN_LM_ACCESSNAME_CHANGES,  PERMTYPE_GENERAL },
    { ACCESS_GEN_FULL_DIR,    IDS_GEN_LM_ACCESSNAME_FULL,     PERMTYPE_GENERAL },

    { ACCESS_READ,               IDS_LM_ACCESSNAME_READ,   PERMTYPE_SPECIAL },
    { ACCESS_WRITE,              IDS_LM_ACCESSNAME_WRITE,  PERMTYPE_SPECIAL },
    { ACCESS_EXEC,               IDS_LM_ACCESSNAME_EXEC,   PERMTYPE_SPECIAL },
    { ACCESS_DELETE,             IDS_LM_ACCESSNAME_DELETE, PERMTYPE_SPECIAL },
    { ACCESS_ATRIB,              IDS_LM_ACCESSNAME_ATRIB,  PERMTYPE_SPECIAL },
    { ACCESS_PERM,               IDS_LM_ACCESSNAME_PERM,   PERMTYPE_SPECIAL },
    { ACCESS_CREATE,             IDS_LM_ACCESSNAME_CREATE, PERMTYPE_SPECIAL },
} ;
#define SIZEOF_LM_DIR_ACCESSPAIRS   11  // Items in above array

US_IDS_PAIRS aLMFileAccessIdsPairs[] =
{
    { ACCESS_GEN_NONE,        IDS_GEN_LM_ACCESSNAME_DENY_ALL, PERMTYPE_GENERAL },
    { ACCESS_GEN_SEE_USE,     IDS_GEN_LM_ACCESSNAME_SEE_USE,  PERMTYPE_GENERAL },
    { ACCESS_GEN_CHANGES_FILE,IDS_GEN_LM_ACCESSNAME_CHANGES,  PERMTYPE_GENERAL },
    { ACCESS_GEN_FULL_FILE,   IDS_GEN_LM_ACCESSNAME_FULL,     PERMTYPE_GENERAL },

    { ACCESS_READ,               IDS_LM_ACCESSNAME_READ,   PERMTYPE_SPECIAL },
    { ACCESS_WRITE,              IDS_LM_ACCESSNAME_WRITE,  PERMTYPE_SPECIAL },
    { ACCESS_EXEC,               IDS_LM_ACCESSNAME_EXEC,   PERMTYPE_SPECIAL },
    { ACCESS_DELETE,             IDS_LM_ACCESSNAME_DELETE, PERMTYPE_SPECIAL },
    { ACCESS_ATRIB,              IDS_LM_ACCESSNAME_ATRIB,  PERMTYPE_SPECIAL },
    { ACCESS_PERM,               IDS_LM_ACCESSNAME_PERM,   PERMTYPE_SPECIAL },
} ;
#define SIZEOF_LM_FILE_ACCESSPAIRS   10  // Items in above array

/* The Lanman audit flags that we will deal with look like:
 *
 * We always use the Success form of the flag.  To differentiate between
 * success and failure, two bitfields are used.  When the ACL is written
 * out to the resource, the aclconverter will substitute the success bitfield
 * with the corresponding failed bitfields.
 *
 *      Flag               Applies To
 *    -----------         ------------
 *    AA_S_OPEN           // FILE
 *    AA_S_WRITE          // FILE
 *    AA_S_CREATE         //      DIR
 *    AA_S_DELETE         // FILE DIR
 *    AA_S_ACL            // FILE DIR
 *    AA_F_OPEN           // FILE
 *    AA_F_WRITE          // FILE
 *    AA_F_CREATE         //      DIR
 *    AA_F_DELETE         // FILE DIR
 *    AA_F_ACL            // FILE DIR
 */

/* Auditting mask map for LM Files:
 *
 * Note: When the permissions are written back out to disk, the failure
 *       Audit mask manifests will need to be substituted (we only use
 *       the success audit masks while processing, we just keep two
 *       bitfield objects for success and failure).
 */
US_IDS_PAIRS aLMFileAuditSidPairs[] =
            {   { AA_S_OPEN,    IDS_LM_AUDIT_NAME_OPEN,   PERMTYPE_SPECIAL },
                { AA_S_WRITE,   IDS_LM_AUDIT_NAME_WRITE,  PERMTYPE_SPECIAL },
                { AA_S_DELETE,  IDS_LM_AUDIT_NAME_DELETE, PERMTYPE_SPECIAL },
                { AA_S_ACL,     IDS_LM_AUDIT_NAME_ACL,    PERMTYPE_SPECIAL },
            } ;
#define SIZEOF_LM_FILE_AUDITPAIRS  4

/* Auditting mask map for LM Directories:
 */
US_IDS_PAIRS aLMDirAuditSidPairs[] =
            {   { AA_S_OPEN,             IDS_LM_AUDIT_NAME_OPEN,         PERMTYPE_SPECIAL },
                { AA_S_CREATE|AA_S_WRITE,IDS_LM_AUDIT_NAME_CREATE_WRITE, PERMTYPE_SPECIAL },
                { AA_S_DELETE,           IDS_LM_AUDIT_NAME_DELETE,       PERMTYPE_SPECIAL },
                { AA_S_ACL,              IDS_LM_AUDIT_NAME_ACL,          PERMTYPE_SPECIAL },
            } ;
#define SIZEOF_LM_DIR_AUDITPAIRS  4


/*******************************************************************

    NAME:       EditFSACL

    SYNOPSIS:   This internal function is called when the user selects
                the Permissions or Auditting menu item from the file
                manager.

                It builds the appropriate objects depending
                on the target file system.

    ENTRY:      hwndParent - Handle to parent window
                sedpermtype - Indicates if we want to edit permissions or
                        Audits

    EXIT:

    RETURNS:    NERR_Success if successful, appropriate error code otherwise
                (we will display any errors that occur).

    NOTES:

    HISTORY:
        Johnl   16-Aug-1991     Created

********************************************************************/

APIERR EditFSACL( HWND hwndParent,
                  enum SED_PERM_TYPE sedpermtype )
{
    AUTO_CURSOR cursorHourGlass ;

    APIERR err = NERR_Success;
    APIERR errSecondary = NERR_Success ;  // Don't report there errors
    BOOL   fIsNT ;
    ACL_TO_PERM_CONVERTER * paclconverter = NULL ; // gets deleted

    do { // error breakout

	FMX fmx( hwndParent );
        BOOL   fIsFile ;
        NLS_STR nlsSelItem;

        if ( fmx.QuerySelCount() == 0 )
        {
            err = IERR_NOTHING_SELECTED ;
            break ;
        }

        if ( (err = nlsSelItem.QueryError()) ||
	     (err = ::GetSelItem( hwndParent, 0, &nlsSelItem, &fIsFile )))
        {
            break ;
        }

        UIDEBUG(SZ("::EditFSACL - Called on file/dir: ")) ;
        UIDEBUG( nlsSelItem.QueryPch() ) ;
        UIDEBUG(SZ("\n\r")) ;

	BOOL fIsLocal ;
	NLS_STR  nlsServer( RMLEN ) ;
	if ( (err = nlsServer.QueryError()) ||
	     (err = ::TargetServerFromDosPath( nlsSelItem,
					       &fIsLocal,
					       &nlsServer )) )

        {
            //
            // have better error message for devices we dont support
            //
            if ( err == NERR_InvalidDevice )
            {
                NLS_STR nlsDrive( nlsSelItem );
                ISTR istr( nlsDrive );

                if ( err = nlsDrive.QueryError())
                    break;

                istr += 2;
                nlsDrive.DelSubStr( istr );

                err = WNetFMXEditPerm( (LPWSTR) nlsDrive.QueryPch(),
                                       hwndParent,
                                       sedpermtype == SED_AUDITS
                                       ? WNPERM_DLG_AUDIT
                                       : WNPERM_DLG_PERM );

            }
            break ;
        }


	//
	//  We only support multi-select if the selection is homogenous
	//
	BOOL fIsMultiSelect = (fmx.QuerySelCount() > 1 ) ;
	if ( fIsMultiSelect )
	{
	    if ( fmx.IsHeterogeneousSelection( &fIsFile ) )
	    {
		err = IERR_MIXED_MULTI_SEL ;
		break ;
	    }
	}

	LOCATION locDrive( fIsLocal ? NULL : nlsServer.QueryPch() ) ;
        if ( (err = locDrive.QueryError()) ||
             (err = locDrive.CheckIfNT( &fIsNT ))  )
        {
            UIDEBUG(SZ("::EditFSAcl - locDrive failed to construct\n\r")) ;
            break ;
        }

        /* If we are looking at an NT resource, then we will go through the
         * front door.  If we are looking at a Lanman ACL, then we will go
         * through the back door.
         */
        if ( fIsNT )
        {
            /* We know it's NT, but is the resource on an NTFS partition?
             */
            BOOL  fIsNTFS ;
            if ( err = IsNTFS( nlsSelItem, &fIsNTFS ))
            {
                break ;
            }

            if ( !fIsNTFS )
            {
                err = IERR_NOT_NTFS_VOLUME ;
            }
            else
	    {
		if ( errSecondary= ::EditNTFSAcl(
					hwndParent,
					locDrive.QueryServer(),
                                        nlsSelItem.QueryPch(),
                                        sedpermtype,
                                        fIsFile ) )
                {
                    DBGEOL(SZ("::EditFSAcl - Error returned from EditNTFSAcl - error code: ") << (ULONG) errSecondary ) ;
                }
            }

            /* We return here even on success
             */
            break ;
	}

	//
	//  If this is a multi-selection, determine if the intersection of
	//  ACLs is the same.
	//

	BOOL fIsBadIntersection = FALSE ;
	BOOL fACLEqual = TRUE ;
	DEC_STR nlsSelectCount( fmx.QuerySelCount() ) ;
	if ( fIsMultiSelect )
	{
	    NLS_STR nlsFailingFile ;
	    if ( (err = nlsFailingFile.QueryError() ) ||
		 (err = nlsSelectCount.QueryError() ) ||
		 (err = CompareLMSecurityIntersection( hwndParent,
						       nlsServer,
						       sedpermtype,
						       &fACLEqual,
						       &nlsFailingFile )) )
	    {
		break ;
	    }

	    if ( !fACLEqual )
	    {
		switch ( ::MsgPopup( hwndParent,
				     (MSGID) IDS_BAD_INTERSECTION,
				     MPSEV_WARNING,
				     MP_YESNO,
				     nlsSelItem,
				     nlsFailingFile,
				     MP_YES ))
		{
		case IDYES:
		    fACLEqual = TRUE ;	// Will use empty ACL
		    fIsBadIntersection = TRUE ;
		    break ;

		case IDNO:
		default:
		    return NERR_Success ;
		}
	    }
	}
	if ( err || !fACLEqual )
	    break ;

        /* Get all of the stuff that is specific for Lan Manager
         */
        MASK_MAP maskmapAccess, maskmapNewObjectAccess, maskmapAudit ;
        NLS_STR  nlsDialogTitle,
                 nlsSpecialAccessName,
                 nlsNewObjectSpecialAccessName,
                 nlsAssignToExistingContTitle,
                 nlsAssignNewObjToExistingTitle,
		 nlsHelpFileName,
                 nlsAssignToTreeConfirmation,
                 nlsDefaultPermName ;

        if ( ( err = maskmapAccess.QueryError() )                  ||
             ( err = maskmapNewObjectAccess.QueryError() )         ||
             ( err = maskmapAudit.QueryError() )                   ||
             ( err = nlsDialogTitle.QueryError() )                 ||
             ( err = nlsSpecialAccessName.QueryError() )           ||
             ( err = nlsNewObjectSpecialAccessName.QueryError() )  ||
             ( err = nlsAssignToExistingContTitle.QueryError() )   ||
	     ( err = nlsHelpFileName.QueryError() )		   ||
             ( err = nlsAssignToTreeConfirmation.QueryError() )    ||
             ( err = nlsAssignNewObjToExistingTitle.QueryError() ) ||
             ( err = nlsDefaultPermName.QueryError() )               )
        {
            UIDEBUG(SZ("::EditFSAcl - Failed to construct basic objects\n\r")) ;
            break ;
        }

        US_IDS_PAIRS * pusidspairAccess = NULL,
                     * pusidspairAudit = NULL ;
        UINT cAccessPairs = 0, cAuditPairs = 0 ;
        MSGID msgIDSDialogTitle,
              msgIDSSpecialAccessName,
              msgIDDefaultPermName ;
        ULONG ahc[7] ;

        /* Based on what we are doing, choose and build the correct
         * task oriented object set of MASK_MAPs, acl converters and resource
         * strings.
         */
        if ( fIsFile )
        {
            pusidspairAccess = (US_IDS_PAIRS *) &aLMFileAccessIdsPairs ;
            cAccessPairs     = (UINT) SIZEOF_LM_FILE_ACCESSPAIRS ;
            pusidspairAudit  = (US_IDS_PAIRS *) &aLMFileAuditSidPairs ;
            cAuditPairs      = (UINT) SIZEOF_LM_FILE_AUDITPAIRS ;

            msgIDSSpecialAccessName = (MSGID) IDS_LM_FILE_SPECIAL_ACCESS_NAME ;
            msgIDSDialogTitle = (MSGID) sedpermtype == SED_ACCESSES ?
                                   IDS_LM_FILE_PERMISSIONS_TITLE :
                                   IDS_LM_FILE_AUDITS_TITLE ;
            msgIDDefaultPermName = IDS_FILE_PERM_GEN_READ ;

            ahc[HC_MAIN_DLG] = sedpermtype == SED_ACCESSES ?
                                  HC_SED_LM_FILE_PERMS_DLG :
                                  HC_SED_LM_FILE_AUDITS_DLG ;
            ahc[HC_SPECIAL_ACCESS_DLG] = HC_SED_LM_SPECIAL_FILES_FM ;
        }
        else
        {
            pusidspairAccess = (US_IDS_PAIRS *) &aLMDirAccessIdsPairs ;
            cAccessPairs     = (UINT) SIZEOF_LM_DIR_ACCESSPAIRS ;
            pusidspairAudit  = (US_IDS_PAIRS *) &aLMDirAuditSidPairs ;
            cAuditPairs      = (UINT) SIZEOF_LM_DIR_AUDITPAIRS ;

            msgIDSSpecialAccessName = (MSGID) IDS_LM_DIR_SPECIAL_ACCESS_NAME ;
            msgIDSDialogTitle = (MSGID) sedpermtype == SED_ACCESSES ?
                                  IDS_LM_DIR_PERMISSIONS_TITLE :
                                  IDS_LM_DIR_AUDITS_TITLE  ;
            msgIDDefaultPermName = IDS_DIR_PERM_GEN_READ ;

            ahc[HC_MAIN_DLG] = sedpermtype == SED_ACCESSES ?
                                  HC_SED_LM_DIR_PERMS_DLG :
                                  HC_SED_LM_DIR_AUDITS_DLG ;
            ahc[HC_SPECIAL_ACCESS_DLG] = HC_SED_LM_SPECIAL_DIRS_FM ;

            if ( ( err = nlsAssignToExistingContTitle.Load((MSGID)
                              sedpermtype == SED_ACCESSES ?
                                   IDS_LM_DIR_ASSIGN_PERM_TITLE :
                                   IDS_LM_DIR_ASSIGN_AUDIT_TITLE)) ||
                 ( err = nlsAssignToTreeConfirmation.Load(
                                   IDS_TREE_APPLY_WARNING ))         )
            {
                break ;
            }
        }
        ahc[HC_ADD_USER_DLG] = HC_SED_LANMAN_ADD_USER_DIALOG ;

        if ( ( err = maskmapAccess.Add( pusidspairAccess, (USHORT)cAccessPairs ) )||
             ( err = maskmapAudit.Add( pusidspairAudit, (USHORT)cAuditPairs ) )   ||
             ( err = nlsDialogTitle.Load( msgIDSDialogTitle ))            ||
             ( err = nlsSpecialAccessName.Load( msgIDSSpecialAccessName ))||
	     ( err = nlsDefaultPermName.Load( msgIDDefaultPermName ))	  ||
	     ( err = nlsHelpFileName.Load( IDS_FILE_PERM_HELP_FILE )) )
        {
            break ;
	}

        LM_CALLBACK_INFO callbackinfo;
        callbackinfo.hwndFMXOwner = hwndParent;
        callbackinfo.sedpermtype = sedpermtype;

	paclconverter = new LM_ACL_TO_PERM_CONVERTER( locDrive.QueryServer(),
                               nlsSelItem,
                               &maskmapAccess,
                               &maskmapAudit,
                               !fIsFile,
                               (PSED_FUNC_APPLY_SEC_CALLBACK) SedLMCallback,
			       (ULONG_PTR) &callbackinfo,
			       fIsBadIntersection );

        err = (paclconverter == NULL ? ERROR_NOT_ENOUGH_MEMORY :
                                       paclconverter->QueryError()) ;

        if ( err )
        {
            break ;
        }

	RESOURCE_STR nlsResType((MSGID)( fIsFile ? IDS_FILE : IDS_DIRECTORY)) ;


	RESOURCE_STR nlsResourceName( fIsFile ? IDS_FILE_MULTI_SEL :
						IDS_DIRECTORY_MULTI_SEL ) ;

        if ( nlsResType.QueryError() != NERR_Success )
        {
            UIDEBUG(SZ("EditFSAcl - Unable to Load Resource type strings\n\r")) ;
            break ;
	}

	//
	//  Replace the resource name with the "X files selected" string
	//  if we are in a multi-select situation
	//
	const TCHAR * pszResource = nlsSelItem ;
	if ( fIsMultiSelect )
	{
	    if ( (err = nlsResourceName.QueryError()) ||
		 (err = nlsResourceName.InsertParams( nlsSelectCount )))
	    {
		break ;
	    }
	    pszResource = nlsResourceName.QueryPch() ;
	}

        //
        //  Finally, call the real ACL editor with all of the parameters we have
        //  just prepared.
        //
        err = I_GenericSecurityEditor( hwndParent,
                                       paclconverter,
                                       sedpermtype,
                                       fIsNT,
                                       !fIsFile,
                                       FALSE,
                                       nlsDialogTitle,
                                       nlsResType,
				       pszResource,
                                       nlsSpecialAccessName,
				       nlsDefaultPermName,
                                       nlsHelpFileName,
                                       ahc,
                                       nlsNewObjectSpecialAccessName,
                                       fIsFile ? NULL :
                                          nlsAssignToExistingContTitle.QueryPch(),
                                       NULL,
                                       NULL,
                                       nlsAssignToTreeConfirmation ) ;

        if ( err != NERR_Success )
        {
            UIDEBUG(SZ("::EditFSAcl - I_GenericSecurityEditor failed\n\r")) ;
            break ;
        }

    } while (FALSE) ;

    delete paclconverter ;

    if ( err )
    {
        MsgPopup( hwndParent, (MSGID) err ) ;
    }

    return err ? err : errSecondary ;
}


void EditAuditInfo( HWND  hwndFMXWindow )
{
    (void) EditFSACL( hwndFMXWindow,
                      SED_AUDITS ) ;
}

void EditPermissionInfo( HWND  hwndFMXWindow )
{
    (void) EditFSACL( hwndFMXWindow,
                      SED_ACCESSES ) ;
}

/*******************************************************************

    NAME:       SedLMCallback

    SYNOPSIS:   Security Editor callback for the LM ACL Editor

    ENTRY:      See sedapi.hxx

    EXIT:

    RETURNS:

    NOTES:      The callback context should be the FMX Window handle.  This
                is so we can support setting permissions on multiple files/
                directories if we ever decide to do that.

    HISTORY:
        Yi-HsinS   17-Sept-1992     Filled out

********************************************************************/


DWORD SedLMCallback( HWND                   hwndParent,
                     HANDLE                 hInstance,
                     ULONG_PTR              ulCallbackContext,
                     PSECURITY_DESCRIPTOR   psecdesc,
                     PSECURITY_DESCRIPTOR   psecdescNewObjects,
                     BOOLEAN                fApplyToSubContainers,
                     BOOLEAN                fApplyToSubObjects,
                     LPDWORD                StatusReturn
                   )
{
    UNREFERENCED( hInstance ) ;
    UNREFERENCED( psecdesc ) ;
    UNREFERENCED( psecdescNewObjects ) ;

    APIERR err ;
    LM_CALLBACK_INFO *pcallbackinfo = (LM_CALLBACK_INFO *) ulCallbackContext;
    HWND hwndFMXWindow = pcallbackinfo->hwndFMXOwner ;

    FMX fmx( hwndFMXWindow );
    UINT uiCount = fmx.QuerySelCount() ;
    BOOL fDismissDlg = TRUE ;
    BOOL fDepthFirstTraversal = FALSE ;

    NLS_STR nlsSelItem( 128 ) ;
    RESOURCE_STR nlsCancelDialogTitle( IDS_CANCEL_TASK_APPLY_DLG_TITLE ) ;
    if ( (err = nlsSelItem.QueryError()) ||
	 (err = nlsCancelDialogTitle.QueryError()) )
    {
	*StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	::MsgPopup( hwndParent, (MSGID) err ) ;
        return err ;
    }

    //
    //	QuerySelCount only returns the number of selections in the files window,
    //	thus if the focus is in the directory window, then we will just make
    //	the selection count one for out "for" loop.
    //
    if ( fmx.QueryFocus() == FMFOCUS_TREE )
    {
	uiCount = 1 ;
    }

    BOOL fIsFile ;
    if ( err = ::GetSelItem( hwndFMXWindow, 0, &nlsSelItem, &fIsFile ) )
    {
	::MsgPopup( hwndParent, (MSGID) err ) ;
	*StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    //
    //	If we only have to apply permissions to a single item or we are
    //	taking ownership of a file, then just
    //	do it w/o bringing up the cancel task dialog.
    //
    if (  uiCount == 1 &&
	  !fApplyToSubContainers &&
	  !fApplyToSubObjects)
    {
	err = pcallbackinfo->plmobjNetAccess1->Write() ;

	if ( err )
	{
	    DBGEOL("LM SedCallback - Error " << (ULONG)err << " applying security to " <<
	       nlsSelItem ) ;
	    ::MsgPopup( hwndParent, (MSGID) err ) ;
	    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	}
    }
    else
    {
        //
        //  Note that the LM Perm & Audit dialogs only have a single checkbox
        //  for applying permissions to the whole tree (and all items in
        //  the tree).
        //
	LM_TREE_APPLY_CONTEXT Ctxt( nlsSelItem ) ;
	Ctxt.State		  = APPLY_SEC_FMX_SELECTION ;
	Ctxt.hwndFMXWindow	  = hwndFMXWindow ;
	Ctxt.sedpermtype	  = pcallbackinfo->sedpermtype ;
	Ctxt.iCurrent		  = 0 ;
	Ctxt.uiCount		  = uiCount ;
	Ctxt.fDepthFirstTraversal = fDepthFirstTraversal ;
        Ctxt.fApplyToDirContents  = fApplyToSubContainers ;
	Ctxt.StatusReturn	  = StatusReturn ;
	Ctxt.fApplyToSubContainers= fApplyToSubContainers ;
	Ctxt.fApplyToSubObjects   = fApplyToSubObjects ;
	Ctxt.plmobjNetAccess1	  = pcallbackinfo->plmobjNetAccess1 ;

	LM_CANCEL_TREE_APPLY CancelTreeApply( hwndParent,
					      &Ctxt,
					      nlsCancelDialogTitle ) ;
	if ( (err = CancelTreeApply.QueryError()) ||
	     (err = CancelTreeApply.Process( &fDismissDlg )) )
	{
	    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	    ::MsgPopup( hwndParent, (MSGID) err ) ;
	}
    }

    if ( !err )
    {
        // Refresh the file manager window if permissions is updated
        if ( pcallbackinfo->sedpermtype == SED_ACCESSES )
	    fmx.Refresh();

	if ( *StatusReturn == 0 )
	    *StatusReturn = SED_STATUS_MODIFIED ;
    }

    if ( !err && !fDismissDlg )
    {
	//
	//  Don't dismiss the dialog if the user canceled the tree
	//  apply.  This tells the ACL editor not to dismiss the permissions
	//  dialog (or auditing or owner).
	//
	err = ERROR_GEN_FAILURE ;
    }

    return err ;
}

/*******************************************************************

    NAME:	TargetServerFromDosPath

    SYNOPSIS:	Given a DOS path, gets the server name the path lives on

    ENTRY:	nlsDosPath - Dos path to get server for
		pfIsLocal  - Set to TRUE if the path is on the local machine
		pnlsTargetServer - Receives server path is on

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	If the workstation isn't started, then the path is assumed
		to be on the local machine.

    HISTORY:
	Johnl	12-Oct-1992	Broke out as a function

********************************************************************/

APIERR TargetServerFromDosPath( const NLS_STR & nlsDosPath,
				BOOL	* pfIsLocal,
				NLS_STR * pnlsTargetServer )
{
    UIASSERT( pfIsLocal != NULL && pnlsTargetServer != NULL ) ;

    *pfIsLocal = FALSE;

    APIERR err = NERR_Success ;
    do { // error breakout

        NLS_STR nlsDriveName;
        if (  ( err = nlsDriveName.QueryError())
           || ( err = nlsDriveName.CopyFrom( nlsDosPath, 4 ))
           )
        {
            break;
        }

        UINT nDriveType = ::GetDriveType( nlsDriveName );

        if (  ( nDriveType == DRIVE_REMOVABLE )
           || ( nDriveType == DRIVE_FIXED )
           || ( nDriveType == DRIVE_CDROM )
           || ( nDriveType == DRIVE_RAMDISK )
           )
        {
            *pfIsLocal = TRUE;
            *pnlsTargetServer = SZ("");
            break;
        }

	NET_NAME netnameSelItem( nlsDosPath ) ;
	if ( (err = netnameSelItem.QueryError()))
        {
            break ;
        }

	err = netnameSelItem.QueryComputerName( pnlsTargetServer );

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:	CompareLMSecurityIntersection

    SYNOPSIS:	Determines if the files/dirs currently selected have
		equivalent security descriptors

    ENTRY:	hwndFMX - FMX Hwnd used for getting selection
		pszServer - The server the resource lives
		sedpermtype - Interested in DACL or SACL
		pfACLEqual - Set to TRUE if all of the DACLs/SACLs are
		    equal.  If FALSE, then pfOwnerEqual should be ignored
		pnlsFailingFile - Filled with the first file name found to
		    be not equal

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The first non-equal ACL causes the function to exit.

		On a 20e with 499 files selected locally, it took 35.2 minutes
		to read the security descriptors from the disk and 14 seconds
		to determine the intersection.	So even though the Compare
		method uses an n^2 algorithm, it only takes up 0.6% of the
		wait time.

    HISTORY:
	Johnl	05-Nov-1992	 Created

********************************************************************/

APIERR CompareLMSecurityIntersection( HWND		 hwndFMX,
				      const TCHAR *	 pszServer,
				      enum SED_PERM_TYPE sedpermtype,
				      BOOL *		 pfACLEqual,
				      NLS_STR * 	 pnlsFailingFile )
{
    TRACEEOL("::CompareLMSecurityIntersection - Entered @ " << ::GetTickCount()/100) ;
    FMX fmx( hwndFMX );
    UIASSERT( fmx.QuerySelCount() > 1 ) ;

    APIERR err ;
    UINT cSel = fmx.QuerySelCount() ;
    BOOL fNoACE = FALSE ;	    // Set to TRUE if the resource has no ACE

    NLS_STR nlsSel( PATHLEN ) ;
    if ( (err = nlsSel.QueryError()) ||
	 (err = ::GetSelItem( hwndFMX, 0, &nlsSel, NULL )))
    {
	return err ;
    }

    //
    //	Get the first ACL and use it to compare against
    //
    NET_ACCESS_1 netacc1Base( pszServer, nlsSel ) ;
    switch ( err = netacc1Base.GetInfo() )
    {
    case NERR_ResourceNotFound:
	fNoACE = TRUE ;
	if ( err = netacc1Base.CreateNew() )
	    return err ;
	break ;

    case NERR_Success:
	break ;

    case ERROR_NOT_SUPPORTED: // This will only be returned by LM2.x Share-level
                              // server
        return IERR_ACLCONV_CANT_EDIT_PERM_ON_LM_SHARE_LEVEL;

    default:
	return err ;
    }

    *pfACLEqual = TRUE ;

    for ( UINT i = 1 ; i < cSel ; i++ )
    {
	if ( (err = ::GetSelItem( hwndFMX, i, &nlsSel, NULL )) )
	{
	    break ;
	}

	NET_ACCESS_1 netacc1( pszServer, nlsSel ) ;
	switch ( err = netacc1.GetInfo() )
	{
	case NERR_ResourceNotFound:
	    if ( fNoACE )
	    {
		err = NERR_Success ;
		continue ;  // Ignore the error
	    }
	    else
	    {
		*pfACLEqual = FALSE ;
	    }
	    break ;

	default:
	    break ;
	}
	if ( err || !*pfACLEqual )
	    break ;

	if ( sedpermtype == SED_AUDITS )
	{
	    if ( netacc1Base.QueryAuditFlags() != netacc1.QueryAuditFlags() )
	    {
		*pfACLEqual = FALSE ;
		break ;
	    }
	}
	else
	{
	    UIASSERT( sedpermtype == SED_ACCESSES ) ;

	    if ( !netacc1Base.CompareACL( &netacc1 ) )
	    {
		*pfACLEqual = FALSE ;
		break ;
	    }
	}
    }

    if ( !*pfACLEqual )
    {
	err = pnlsFailingFile->CopyFrom( nlsSel ) ;
    }

    TRACEEOL("::CompareLMSecurityIntersection - Left    @ " << ::GetTickCount()/100) ;
    return err ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\subject.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*

    Subject.cxx

    This file contains the implementation for the SUBJECT class


    FILE HISTORY:
	Johnl	05-Aug-1991	Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
}

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>
#include <uiassert.hxx>
#include <string.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#include <subject.hxx>

#ifndef max
    #define max(a,b)  ( (a) > (b) ? (a) : (b) )
#endif //!max
/*******************************************************************

    NAME:	SUBJECT::SUBJECT

    SYNOPSIS:	Base SUBJECT class constructor

    ENTRY:	pszUserGroupDispName is the display name for this user/group
		fIsGroup is TRUE if this is a group, FALSE if a user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

SUBJECT::SUBJECT( SUBJECT_TYPE SubjType )
    : _SubjType( SubjType )
{
    /* Nothing to do */
}

SUBJECT::~SUBJECT()
{
}

enum UI_SystemSid SUBJECT::QuerySystemSubjectType( void ) const
{
    return UI_SID_Invalid ;
}

APIERR SUBJECT::IsEveryoneGroup( BOOL * pfIsEveryone ) const
{
    UIASSERT( pfIsEveryone != NULL ) ;
    *pfIsEveryone = FALSE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	LM_SUBJECT::LM_SUBJECT

    SYNOPSIS:	Lanman subject constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

LM_SUBJECT::LM_SUBJECT( const TCHAR * pszUserGroupName, BOOL fIsGroup )
    : SUBJECT( fIsGroup ? SubjTypeGroup : SubjTypeUser ),
      _nlsDisplayName( pszUserGroupName )
{
    if ( _nlsDisplayName.QueryError() != NERR_Success )
    {
	ReportError( _nlsDisplayName.QueryError() ) ;
	return ;
    }
}

LM_SUBJECT::~LM_SUBJECT()
{
}

/*******************************************************************

    NAME:	LM_SUBJECT::QueryDisplayName

    SYNOPSIS:	Returns the name the user will see when looking at this
		subject

    ENTRY:

    EXIT:

    RETURNS:	Pointer to the string for display

    NOTES:

    HISTORY:
	Johnl	26-Dec-1991	Broke out from SUBJECT base class

********************************************************************/

const TCHAR * LM_SUBJECT::QueryDisplayName( void ) const
{
    return _nlsDisplayName.QueryPch() ;
}

/*******************************************************************

    NAME:	LM_SUBJECT::IsEqual

    SYNOPSIS:	Compares the account names for this LM subject

    ENTRY:	psubj - Pointer to subject to compare with

    RETURNS:	TRUE if equal, FALSE if not equal.

    NOTES:

    HISTORY:
	Johnl	09-Jul-1992	Created

********************************************************************/

BOOL LM_SUBJECT::IsEqual( const SUBJECT * psubj ) const
{
    return !::stricmpf( QueryDisplayName(), psubj->QueryDisplayName() ) ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::NT_SUBJECT

    SYNOPSIS:	NT Subject constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	We copy the SID so we can modify it without any problems.

    HISTORY:
	Johnl	26-Dec-1991	Created

********************************************************************/

UCHAR NT_SUBJECT::_cMaxWellKnownSubAuthorities = 0 ;

NT_SUBJECT::NT_SUBJECT( PSID		  psidSubject,
			const TCHAR *	  pszDisplayName,
			SID_NAME_USE	  type,
			enum UI_SystemSid SystemSidType )
    : SUBJECT	     ( (SUBJECT_TYPE) type ),
      _ossid	     ( psidSubject, TRUE ),
      _nlsDisplayName( pszDisplayName ),
      _SystemSidType ( SystemSidType )
{
    APIERR err ;

    if ( (err = _nlsDisplayName.QueryError()) ||
	 (err = _ossid.QueryError()) )
    {
	ReportError( err ) ;
	return ;
    }

    /* If this is the first time through, initialize
     * _cMaxWellKnownSubAuthorities
     */
    if ( _cMaxWellKnownSubAuthorities == 0 )
    {
	do { // error break out

	    UCHAR cMaxSubAuthorities = 0, *pcSubAuthorities = 0 ;
	    OS_SID ossidWellKnown ;

	    if ( (err = ossidWellKnown.QueryError()) ||
		 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = *pcSubAuthorities ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Interactive,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Network,
							     &ossidWellKnown)) ||
		 (err = ossidWellKnown.QuerySubAuthorityCount( &pcSubAuthorities )))
	    {
		break ;
	    }
	    cMaxSubAuthorities = max( cMaxSubAuthorities, *pcSubAuthorities ) ;

	    /* There is nothing else to fail on so set the static variable
	     */
	    _cMaxWellKnownSubAuthorities = cMaxSubAuthorities ;

	} while (FALSE) ;

	if ( err )
	{
	    ReportError( err ) ;
	    return ;
	}
    }

    /* Check the sub-authority count and if it is less then or equal to
     * our max count, compare the SID to the special cased well known sids.
     */
    UCHAR * pcSubAuthorities ;
    if ( (err = _ossid.QuerySubAuthorityCount( &pcSubAuthorities )) )
    {
	ReportError( err ) ;
	return ;
    }

    if ( *pcSubAuthorities <= _cMaxWellKnownSubAuthorities )
    {
	do { // error break out

	    OS_SID ossidWellKnown ;
	    if ( (err = ossidWellKnown.QueryError()) ||
		 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_World ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Interactive,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_Interactive ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_CreatorOwner ;
		break ;
	    }

	    if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Network,
							     &ossidWellKnown)) )
	    {
		break ;
	    }
	    if ( ossidWellKnown == _ossid )
	    {
		_SystemSidType = UI_SID_Network ;
		break ;
	    }

	} while (FALSE) ;

	if ( err )
	{
	    ReportError( err ) ;
	    return ;
	}
    }
}

NT_SUBJECT::~NT_SUBJECT()
{
}

/*******************************************************************

    NAME:	NT_SUBJECT::QueryDisplayName

    SYNOPSIS:	Returns the name the user will see when looking at this
		subject

    ENTRY:

    EXIT:

    RETURNS:	Pointer to the string for display

    NOTES:

    HISTORY:
	Johnl	26-Dec-1991	Created

********************************************************************/

const TCHAR * NT_SUBJECT::QueryDisplayName( void ) const
{
    return _nlsDisplayName.QueryPch() ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::QuerySystemSubjectType

    SYNOPSIS:	Returns the type of SID if the sid is a well known SID

    RETURNS:	A UI_SystemSid

    NOTES:

    HISTORY:
	Johnl	3-Jun-1992	Created

********************************************************************/

enum UI_SystemSid NT_SUBJECT::QuerySystemSubjectType( void ) const
{
    return _SystemSidType ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::IsEqual

    SYNOPSIS:	Compares the account names for this LM subject

    ENTRY:	psubj - Pointer to subject to compare with

    RETURNS:	TRUE if equal, FALSE if not equal.

    NOTES:

    HISTORY:
	Johnl	09-Jul-1992	Created

********************************************************************/

BOOL NT_SUBJECT::IsEqual( const SUBJECT * psubj ) const
{
    NT_SUBJECT * pntsubj = (NT_SUBJECT *) psubj ;

    return *QuerySID() == *pntsubj->QuerySID() ;
}

/*******************************************************************

    NAME:	NT_SUBJECT::IsEveryoneGroup

    SYNOPSIS:	Checks to see if this subject contains the "World" well
		known sid.

    ENTRY:	pfIsEveryone - Set to TRUE if this is the Everyone sid,
		    FALSE otherwise.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1992	Created

********************************************************************/

APIERR NT_SUBJECT::IsEveryoneGroup( BOOL * pfIsEveryone ) const
{
    UIASSERT( pfIsEveryone != NULL ) ;

    APIERR err ;
    OS_SID ossidEveryone ;
    if ( (err = ossidEveryone.QueryError()) ||
	 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_World,
						     &ossidEveryone )) )
    {
	return err ;
    }

    *pfIsEveryone = ::EqualSid( ossidEveryone.QueryPSID(), QuerySID()->QueryPSID() ) ;
    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\specdlg.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*

    SpecDlg.cxx

    This dialog contains the implementation for the Permissions Special
    dialog.

    The Special Dialog is a dialog that contains a set of check boxes
    that the user can select.  Each check box is associated with a
    particular bitfield.




    FILE HISTORY:
	Johnl	29-Aug-1991	Created

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <subjlb.hxx>
#include <perm.hxx>

#include <permdlg.hxx>
#include <specdlg.hxx>

#include <dbgstr.hxx>
#include <uitrace.hxx>

/*******************************************************************

    NAME:	SPECIAL_DIALOG::SPECIAL_DIALOG

    SYNOPSIS:	Special dialog constructor

    ENTRY:	pszDialogName - Resource name of dialog
		hwndParent - Owner window handle
		pszResourceType - UI string of resource type
		pszResourceName - UI string of resource type
		pAccessPerm - Pointer to access permission we are going
			to display
		pAccessMaskMap - Pointer to MASK_MAP object the pAccessPerm
			is using.

    EXIT:	The checkbox names will be set and the appropriate check
		boxes selected based on the current permissions mask

    NOTES:	It is assumed there are up to COUNT_OF_CHECKBOXES check boxes
		in the dialog and they should all be disabled and hidden
		by default.  This class enables and displays all used
		checkboxes automatically.


    HISTORY:
	Johnl	29-Aug-1991	Created

********************************************************************/

SPECIAL_DIALOG::SPECIAL_DIALOG( const TCHAR * pszDialogName,
				HWND	      hwndParent,
				const TCHAR * pszResourceType,
				const TCHAR * pszResourceName,
				const TCHAR * pszHelpFileName,
				const TCHAR * pszDialogTitle,
				BITFIELD    * pbitsAccessPerm,
				MASK_MAP    * pAccessMaskMap,
				const TCHAR * pszSubjName,
                                ULONG       * ahcHelp,
				BOOL	      fIsReadOnly )
    : PERM_BASE_DLG	     ( pszDialogName,
			       hwndParent,
			       pszDialogTitle,
			       pszResourceType,
			       pszResourceName,
			       pszHelpFileName,
                               ahcHelp ),
      _sleSubjectName        ( this, SLE_SUBJECT_NAME ),
      _cwinPermFrame	     ( this, FRAME_PERMISSION_BOX ),
      _pbitsAccessPerm	     ( pbitsAccessPerm ),
      _pAccessMaskMap	     ( pAccessMaskMap ),
      _cUsedCheckBoxes	     ( 0 ),
      _pAccessPermCheckBox   ( NULL ),
      _fIsReadOnly	     ( fIsReadOnly )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pAccessMaskMap != NULL ) ;

    _sleSubjectName.SetText( pszSubjName ) ;

    _pAccessPermCheckBox = (ACCESS_PERM_CHECKBOX *) new BYTE[COUNT_OF_CHECKBOXES*sizeof(ACCESS_PERM_CHECKBOX)] ;
    if ( _pAccessPermCheckBox == NULL )
    {
	ReportError( (APIERR) ERROR_NOT_ENOUGH_MEMORY ) ;
	return ;
    }

    APIERR err ;
    if ( (err = SetCheckBoxNames( _pAccessMaskMap, IsReadOnly() )) ||
	 (err = ApplyPermissionsToCheckBoxes( QueryAccessBits() )) )
    {
	ReportError( err ) ;
	return ;
    }

    /* After setting the names, resize the dialog and reposition the
     * controls so it looks nice.
     */
    Resize() ;

}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::~SPECIAL_DIALOG

    SYNOPSIS:	Standard destructor

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

SPECIAL_DIALOG::~SPECIAL_DIALOG()
{
    _pAccessMaskMap = NULL ;

    // UPDATED for C++ V 2.0; old version:
    //   delete [_cUsedCheckBoxes] _pAccessPermCheckBox ;
    //

    for ( INT i = 0 ; i < (INT)_cUsedCheckBoxes ; i++ )
    {
        _pAccessPermCheckBox[i].ACCESS_PERM_CHECKBOX::~ACCESS_PERM_CHECKBOX() ;
    }
    delete (void *) _pAccessPermCheckBox ;

    _pAccessPermCheckBox = NULL ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Gets the access mask the user selected and dismisses the dialog

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

BOOL SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	QueryUserSelectedBits( QueryAccessBits() ) ;
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}

ULONG SPECIAL_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_SPECIAL_ACCESS_DLG] ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::SetCheckBoxNames

    SYNOPSIS:	Constructs each checkbox with its bitfield and permission name

    ENTRY:	pAccessMap - Pointer to the MASK_MAP the ACCESS_PERMISSION
		    is using
		fReadOnly - TRUE if the checkboxes are read only (i.e., visible
		    but disabled).

    EXIT:	Each used dialog will have its name set and be enabled
		and visible.  The _cUsedCheckboxes will be set to the
		number of checkboxes that were successfully constructed.

    RETURNS:	An APIERR if an error occurred

    NOTES:	This is a *construction* method (i.e., meant to be called
		from the constructor).

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SPECIAL_DIALOG::SetCheckBoxNames( MASK_MAP * pAccessMaskMap,
					 BOOL	    fReadOnly )
{
    BOOL fMoreData ;
    BOOL fFromBeginning = TRUE ;
    NLS_STR nlsSpecialPermName( 40 ) ;
    BITFIELD bitMask( *QueryAccessBits() ) ;
    APIERR err ;

    if ( bitMask.QueryError() )
	return bitMask.QueryError() ;

    ACCESS_PERM_CHECKBOX * pcheckTemp = (ACCESS_PERM_CHECKBOX *) _pAccessPermCheckBox ;

    /* Loop through all of the special permission names and construct
     * each checkbox with the permission name and assocated bitmap.
     */
    while ( ( err = pAccessMaskMap->EnumStrings( &nlsSpecialPermName,
						 &fMoreData,
						 &fFromBeginning,
						 PERMTYPE_SPECIAL ) ) == NERR_Success
	    && fMoreData
	    && _cUsedCheckBoxes < COUNT_OF_CHECKBOXES )
    {
	err = pAccessMaskMap->StringToBits( nlsSpecialPermName,
					    &bitMask,
					    PERMTYPE_SPECIAL ) ;
	if ( err != NERR_Success )
	    return err ;

	new (pcheckTemp) ACCESS_PERM_CHECKBOX( this, CHECK_PERM_1 + _cUsedCheckBoxes,
					       nlsSpecialPermName,
					       bitMask ) ;
	if ( pcheckTemp->QueryError() != NERR_Success )
	    return pcheckTemp->QueryError() ;

	pcheckTemp->Show( TRUE ) ;
	pcheckTemp->Enable( !fReadOnly ) ;

	_cUsedCheckBoxes++ ;
	pcheckTemp++ ;
    }

    if ( err != NERR_Success )
    {
	return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::Resize

    SYNOPSIS:	This method looks at the size of this dialog and resizes
		it appropriately (i.e., takes up the slack if only one
		column of buttons is used.

    ENTRY:	It is assumed the dialog is as it will be displayed (i.e.,
		the text of the buttons set etc.  It doesn't matter if the
		checkboxes are checked or not.

    EXIT:	The dialog will be resized as appropriate and the controls
		that need to be moved will be moved.

    RETURNS:	NERR_Success if successful, otherwise a standard error code

    NOTES:

    HISTORY:
	Johnl	04-Aug-1991	Created

********************************************************************/

void SPECIAL_DIALOG::Resize( void )
{
#if 0  // We don't currently support resizing

    /* We don't need to resize vertically if the whole column is full.
     */
    if ( !IsFilledVertically() )
    {
	/* Get the current size and positions of the components we are
	 * interested in.
	 */
	XYDIMENSION xydimFrame = _cwinPermFrame.QuerySize() ;
	XYDIMENSION xydimDialog = QuerySize() ;
	XYPOINT     xyptFrame  = _cwinPermFrame.QueryPos() ;
	XYRECT	    rectBottomChkBox( QueryCheckBox(QueryCount()-1), FALSE );

#if 0
	XYDIMENSION xydimBottomChkBox = QueryCheckBox( QueryCount() - 1 )->QuerySize() ;
	XYPOINT     xyptBottomChkBox =
#endif

	rectBottomChkBox.ConvertScreenToClient( QueryOwnerHwnd() );

#if 0
	cdebug << SZ("Frame dimensions: (") << xydimFrame.QueryHeight() << SZ(",") << xydimFrame.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Frame Pos:        (") << xyptFrame.QueryX() << SZ(",") << xyptFrame.QueryY() << SZ(")") << dbgEOL ;
	cdebug << SZ("Check Box dim:    (") << xydimBottomChkBox.QueryHeight() << SZ(",") << xydimBottomChkBox.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Check Box Pos:    (") << xyptBottomChkBox.QueryX() << SZ(",") << xyptBottomChkBox.QueryY() << SZ(")") << dbgEOL ;
	cdebug << SZ("Dialog dim:       (") << xydimDialog.QueryHeight() << SZ(",") << xydimDialog.QueryWidth() << SZ(")") << dbgEOL ;
#endif

	INT dyCheckBox = rectBottomChkBox.CalcHeight();

	/* Size the bottom of the frame so it is 1/2 the height of a checkbox
	 * from the bottom of the lowest checkbox and size the bottom of the
	 * dialog so it is 3/4 the height of a checkbox from the bottom of
	 * the frame.
	 */
	xydimFrame.SetHeight( rectBottomChkBox.QueryBottom() + dyCheckBox / 2 ) ;
	xydimDialog.SetHeight( xydimFrame.QueryHeight() + 3 * dyCheckBox / 4 ) ;

	/* Set the new sizes
	 */
#if 0
	cdebug << dbgEOL << dbgEOL << SZ("New dimensions:") << dbgEOL ;
	cdebug << SZ("Frame dimensions: (") << xydimFrame.QueryHeight() << SZ(",") << xydimFrame.QueryWidth() << SZ(")") << dbgEOL ;
	cdebug << SZ("Dialog dim:       (") << xydimDialog.QueryHeight() << SZ(",") << xydimDialog.QueryWidth() << SZ(")") << dbgEOL ;
#endif
	//_cwinPermFrame.SetSize( xydimFrame ) ;
	//SetSize( xydimDialog ) ;
    }
#endif
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::ApplyPermissionsToCheckBoxes

    SYNOPSIS:	This method checks all of the checkboxes that have the
		same bits set as the passed bitfield.

    ENTRY:	pBitField - Pointer to bitfield which contains the checkmark
		    criteria.

    EXIT:	All appropriate checkboxes will be selected or deselected
		as appropriate.

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SPECIAL_DIALOG::ApplyPermissionsToCheckBoxes( BITFIELD * pBitField )
{
    for ( int i = 0 ; i < (int)QueryCount() ; i++ )
    {
	BITFIELD bitTemp( *pBitField ) ;
	if ( bitTemp.QueryError() != NERR_Success )
	    return bitTemp.QueryError() ;

	/* Mask out all of the bits except for the ones we care about then
	 * check the box if the masks are equal.
	 */
	bitTemp &= *QueryCheckBox(i)->QueryBitMask() ;
	QueryCheckBox(i)->SetCheck( *QueryCheckBox(i)->QueryBitMask() == bitTemp ) ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SPECIAL_DIALOG::QueryUserSelectedBits

    SYNOPSIS:	Builds a bitfield by examining all of the selected
		checkboxes and the associated bitfields.

    ENTRY:	pbitsUserSelected - Pointer to bitfield that will receive
		    the built bitfield.

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

void SPECIAL_DIALOG::QueryUserSelectedBits( BITFIELD * pbitsUserSelected )
{
    pbitsUserSelected->SetAllBits( OFF ) ;

    for ( int i = 0 ; i < (int)QueryCount() ; i++ )
    {
	if ( QueryCheckBox(i)->QueryCheck() )
	    *pbitsUserSelected |= *QueryCheckBox(i)->QueryBitMask() ;
    }
}

/*******************************************************************

    NAME:	ACCESS_PERM_CHECKBOX::ACCESS_PERM_CHECKBOX

    SYNOPSIS:	Constructor for the ACCESS_PERM_CHECKBOX

    ENTRY:	powin - Pointer to owner window
		cid - Control ID of this checkbox
		nlsPermName - Name of this checkbox
		bitsMask - The bitfield this checkbox is associated with

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

ACCESS_PERM_CHECKBOX::ACCESS_PERM_CHECKBOX( OWNER_WINDOW * powin, CID cid,
					    const NLS_STR & nlsPermName,
					    BITFIELD & bitsMask )
    : CHECKBOX( powin, cid ),
      _bitsMask( bitsMask )
{
    if ( QueryError() != NERR_Success )
	return ;

    SetText( nlsPermName ) ;
}

/*******************************************************************

    NAME:	NT_SPECIAL_DIALOG::NT_SPECIAL_DIALOG

    SYNOPSIS:	Constructor for the new object special dialog

    ENTRY:	Same as parent

    EXIT:	The checkboxes of the special dialog will be associated
		with the "Permit" button in the magic group.

    RETURNS:

    NOTES:	If the default button is BUTTON_PERMIT then the permission
		will be checked against GENERIC_ALL and ALL will be selected
		if appropriate.

    HISTORY:
	Johnl	18-Nov-1991	Created

********************************************************************/

NT_SPECIAL_DIALOG::NT_SPECIAL_DIALOG(
			 const TCHAR * pszDialogName,
			 HWND	       hwndParent,
			 const TCHAR * pszResourceType,
			 const TCHAR * pszResourceName,
			 const TCHAR * pszHelpFileName,
			 const TCHAR * pszDialogTitle,
			 BITFIELD    * pbitsAccessPerm,
			 MASK_MAP    * pAccessMaskMap,
			 const TCHAR * pszSubjectName,
                         ULONG       * ahcHelp,
			 BOOL	       fIsReadOnly,
			 INT	       cMagicGroupButtons,
			 CID	       cidDefaultMagicGroupButton )
    : SPECIAL_DIALOG( pszDialogName,
		      hwndParent,
		      pszResourceType,
		      pszResourceName,
		      pszHelpFileName,
		      pszDialogTitle,
		      pbitsAccessPerm,
		      pAccessMaskMap,
		      pszSubjectName,
                      ahcHelp,
		      fIsReadOnly ),
      _mgrpSelectionOptions( this,
			     BUTTON_PERMIT,
			     cMagicGroupButtons,
			     cidDefaultMagicGroupButton )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( err = _mgrpSelectionOptions.QueryError() )
    {
	ReportError( err ) ;
	return ;
    }

    /* Check if the GENERIC_ALL is set so we should set the "All" button
     */
    if ( (cidDefaultMagicGroupButton == BUTTON_PERMIT) &&
	 (GENERIC_ALL & (ULONG) *pbitsAccessPerm ))
    {
	_mgrpSelectionOptions.SetSelection( BUTTON_ALL ) ;
    }


    /* We need to associate the check boxes with the Permit/Not specified
     * magic group.
     */
    for ( UINT i = 0 ; i < QueryCount() ; i++ )
    {
        //
        //  Temporary necessary to keep x86 cfront form faulting
        //
	ACCESS_PERM_CHECKBOX * pcbYuck = QueryCheckBox( i );
	
	err = _mgrpSelectionOptions.AddAssociation( BUTTON_PERMIT, pcbYuck );
	
	if( err != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
    }

    if ( fIsReadOnly )
    {
	_mgrpSelectionOptions.Enable( FALSE ) ;
    }
}

NT_SPECIAL_DIALOG::~NT_SPECIAL_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NT_SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Redefines the base OK.	Sets the bits if the permit
		radio button is selected

    RETURNS:

    NOTES:

    HISTORY:
	JohnL	31-Mar-1992	Created

********************************************************************/

BOOL NT_SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	if ( IsAllSpecified() )
	{
	    *QueryAccessBits() = (ULONG) GENERIC_ALL ;
	}
	else
	{
	    QueryUserSelectedBits( QueryAccessBits() ) ;
	}
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}

/*******************************************************************

    NAME:	NEW_OBJ_SPECIAL_DIALOG::NEW_OBJ_SPECIAL_DIALOG

    SYNOPSIS:	Constructor for the new object special dialog

    ENTRY:	Same as parent

    EXIT:	The checkboxes of the special dialog will be associated
		with the "Permit" button in the magic group.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	18-Nov-1991	Created

********************************************************************/

NEW_OBJ_SPECIAL_DIALOG::NEW_OBJ_SPECIAL_DIALOG(
			 const TCHAR * pszDialogName,
			 HWND	       hwndParent,
			 const TCHAR * pszResourceType,
			 const TCHAR * pszResourceName,
			 const TCHAR * pszHelpFileName,
			 const TCHAR * pszDialogTitle,
			 BITFIELD    * pbitsAccessPerm,
			 MASK_MAP    * pAccessMaskMap,
			 const TCHAR * pszSubjectName,
                         ULONG       * ahcHelp,
			 BOOL	       fIsReadOnly,
			 BOOL	       fPermsSpecified )
    : NT_SPECIAL_DIALOG( pszDialogName,
			 hwndParent,
			 pszResourceType,
			 pszResourceName,
			 pszHelpFileName,
			 pszDialogTitle,
			 pbitsAccessPerm,
			 pAccessMaskMap,
			 pszSubjectName,
                         ahcHelp,
			 fIsReadOnly,
			 3,
			 fPermsSpecified ? BUTTON_PERMIT : BUTTON_NOT_SPECIFIED  )
{
    if ( QueryError() )
    {
	return ;
    }
}

NEW_OBJ_SPECIAL_DIALOG::~NEW_OBJ_SPECIAL_DIALOG()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NEW_OBJ_SPECIAL_DIALOG::OnOK

    SYNOPSIS:	Redefines the base OK.	Sets the bits if the permit
		radio button is selected

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	18-Nov-1991	Created
	JohnL	31-Mar-1992	Added Generic All case

********************************************************************/

BOOL NEW_OBJ_SPECIAL_DIALOG::OnOK( void )
{
    if ( !IsReadOnly() )
    {
	if ( IsAllSpecified() )
	{
	    *QueryAccessBits() = (ULONG) GENERIC_ALL ;
	}
	else if ( !IsNotSpecified() )
	{
	    QueryUserSelectedBits( QueryAccessBits() ) ;
	}
	else
	{
	    ASSERT("FALSE") ;
	}
    }

    Dismiss( TRUE ) ;

    return TRUE ;
}


ULONG NEW_OBJ_SPECIAL_DIALOG::QueryHelpContext( void )
{
    return QueryHelpArray()[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\bin\dummy.cxx ===
extern i ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\bin\makefile.inc ===
build_def:
    @echo del ntlanman.def
    -del ntlanman.def

ntlanman.def: 
    @echo Build ntlanman.def
    cp ntlmnpx.def ntlanman.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\subjlb.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    SubjLB.cxx

    This File contains the implementation for the subject and permission
    listboxes.



    FILE HISTORY:
	Johnl	20-Aug-1991	Created
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

*/
#include <ntincl.hxx>

extern "C"
{
    #include <ntseapi.h>
    #include <ntsam.h>
    #include <ntlsa.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETLIB
#define INCL_NETGROUP
#define INCL_NETUSER
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>

#include <maskmap.hxx>
#include <colwidth.hxx>

#include <lmouser.hxx>
#include <lmoeusr.hxx>
#include <lmogroup.hxx>
#include <slist.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

#ifndef min
#define min(a,b)  ((a)<(b)?(a):(b))
#endif

#include <permstr.hxx>
#include <perm.hxx>
#include <accperm.hxx>
#include <subject.hxx>
#include <permdlg.hxx>

#include <subjlb.hxx>
#include <usrbrows.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>

extern "C"
{
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

DEFINE_SLIST_OF( SUBJECT )

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::SUBJECT_LISTBOX

    SYNOPSIS:	Constructor for Subject listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

********************************************************************/

SUBJECT_LISTBOX::SUBJECT_LISTBOX( OWNER_WINDOW * pownerwin, CID cid )
    : BLT_LISTBOX( pownerwin, cid ),
      _bmpblock()
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _bmpblock.QueryError()) != NERR_Success )
    {
	DBGEOL("SUBJECT_LISTBOX::ct - Display maps failed to construct " << err) ;
	ReportError( err ) ;
	return ;
    }

    _anColWidth[0] = _bmpblock.QueryDisplayMap(SidTypeAlias)->QueryWidth() + 2 ;
    _anColWidth[1] = COL_WIDTH_SUBJECT_NAME ;
}

SUBJECT_LISTBOX::~SUBJECT_LISTBOX()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_PERM_LBI objects, by default, we
		fill the listbox with all of the subjects in the domain.

    ENTRY:	location - Where to get the list of users & groups

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

		At this level in the hierarchy, we expect to be used only
		for a LM resource.

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::Fill( LOCATION & location )
{
    AUTO_CURSOR autocursor ;
    BOOL fIsNT ;

    APIERR err = location.CheckIfNT( &fIsNT ) ;
    if ( err )
    {
	return err ;
    }

    if ( fIsNT )
    {
	UIASSERT( FALSE ) ;
	return NERR_Success ;
    }

    DeleteAllItems() ;

    /* Add all of the users to the listbox
     */
    {
	USER0_ENUM user0enum( location ) ;
	APIERR err = user0enum.GetInfo() ;
	if ( err != NERR_Success )
	    return err ;

	USER0_ENUM_ITER ue0( user0enum ) ;
	const USER0_ENUM_OBJ * puser0 ;

	while ( (puser0 = ue0( &err )) != NULL )
	{
            if ( err != NERR_Success )
                break;

	    SUBJECT * psubj = new LM_SUBJECT( puser0->QueryName(), FALSE ) ;

	    if ( psubj == NULL )
		return ERROR_NOT_ENOUGH_MEMORY ;

	    err = AddSubject( psubj, TRUE ) ;
	    if ( err != NERR_Success )
	    {
		delete psubj ;
		break;
	    }
	}

        if ( err != NERR_Success )
            return err;
    }

    /* Add all of the groups to the listbox
     */
    {
	GROUP0_ENUM group0enum( location ) ;
	APIERR err = group0enum.GetInfo() ;
	if ( err != NERR_Success )
	    return err ;

	GROUP0_ENUM_ITER ue0( group0enum ) ;
	const GROUP0_ENUM_OBJ * pgroup0 ;

	while ( (pgroup0 = ue0()) != NULL )
	{
	    SUBJECT * psubj = new LM_SUBJECT( pgroup0->QueryName(), TRUE ) ;

	    if ( psubj == NULL )
		return ERROR_NOT_ENOUGH_MEMORY ;


	    err = AddSubject( psubj, TRUE ) ;
	    if ( err != NERR_Success )
	    {
		delete psubj ;
		return err ;
	    }
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::AddSubject

    SYNOPSIS:	Adds a SUBJECT object to the subject listbox

    ENTRY:	psubj - Pointer to newly created subject

    RETURNS:	Returns NERR_Success if successful, error code otherwise

    NOTES:	If *psubj has its error variable set, then this method
		simply returns that error value

    HISTORY:
	Johnl	13-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::AddSubject( SUBJECT * psubj,
				    BOOL fDeleteContentsOnDestruction  )
{
    UIASSERT( psubj != NULL ) ;
    if ( psubj->QueryError() != NERR_Success )
	return psubj->QueryError() ;

    SUBJ_LBI * pSubjLBI = new SUBJ_LBI( psubj, fDeleteContentsOnDestruction ) ;
    if ( pSubjLBI == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    }
    else if ( psubj->QueryError() != NERR_Success )
    {
	APIERR err = psubj->QueryError() ;
	return err ;
    }

    if ( AddItem( pSubjLBI ) < 0 )
    {
	DBGEOL( "SUBJECT_LISTBOX::Fill - AddItem failed" ) ;
	return ERROR_NOT_ENOUGH_MEMORY ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::QueryDisplayMap

    SYNOPSIS:	Chooses the correct displaymap (group or user) based
		on the passed subject

    ENTRY:	psubj - Pointer to SUBJECT

    RETURNS:	Pointer to appropriate display map

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created
	JohnL	03-Jun-1992	Updated for well known subjects
        DavidHov 22-Mar-1193    Update for c8.  Returned non-const
                                ptr because DM_DTE constructor
                                requires non-const array.
        JonN        14-Oct-1994 Draws bitmaps from SUBJECT_BITMAP_BLOCK

********************************************************************/

DISPLAY_MAP * SUBJECT_LISTBOX::QueryDisplayMap( SUBJECT * psubj )

{
    BOOL fRemote = FALSE;
    SUBJECT_TYPE subjtype = psubj->QueryType();
    if (subjtype == SubjTypeRemote)
    {
        subjtype = SubjTypeUser;
        fRemote = TRUE;
    }

    return _bmpblock.QueryDisplayMap( (SID_NAME_USE)subjtype,
                                      psubj->QuerySystemSubjectType(),
                                      fRemote );
}

/*******************************************************************

    NAME:	SUBJECT_LISTBOX::Remove

    SYNOPSIS:	This method removes all of the subjects contained in the
		passed slist.

    ENTRY:	pslSubjects - Pointer to slist of items to remove

    EXIT:	This subject listbox will no longer contain the passed
		subjects

    RETURNS:	NERR_Success if successful, failure code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Sep-1991	Created

********************************************************************/

APIERR SUBJECT_LISTBOX::Remove( SLIST_OF( SUBJECT ) * pslSubjects )
{
    ITER_SL_OF( SUBJECT ) itersl( *pslSubjects ) ;
    SUBJECT * pSubj ;

    while ( (pSubj = itersl.Next()) != NULL )
    {
	SUBJ_LBI subjlbiTemp( pSubj, FALSE ) ;

	INT iSearchItem = FindItem( subjlbiTemp ) ;
	if ( iSearchItem >= 0 )
	{
	    DeleteItem( iSearchItem ) ;
	}
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::SUBJ_LBI

    SYNOPSIS:	LBIs that go into the SUBJECT_LISTBOX constructor

    ENTRY:	psubj - Pointer to subject this SUBJ_LBI represents

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

SUBJ_LBI::SUBJ_LBI( SUBJECT * psubj, BOOL fDeleteContentsOnDestruction )
    : _psubj( psubj ),
      _fDeleteContentsOnDest( fDeleteContentsOnDestruction )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _psubj != NULL ) ;
}

SUBJ_LBI::~SUBJ_LBI()
{
    if ( _fDeleteContentsOnDest )
	delete _psubj ;

    _psubj = NULL ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::Paint

    SYNOPSIS:	Typical LBI paint method for Subject Permission LBIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    13-Sep-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

void SUBJ_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect, GUILTT_INFO * pguiltt ) const
{
    SUBJECT_LISTBOX * plbSubj = (SUBJECT_LISTBOX *) plb ;

    DM_DTE dmiddte( plbSubj->QueryDisplayMap( QuerySubject()) )  ;
    STR_DTE strdteUserName( QuerySubject()->QueryDisplayName() ) ;

    DISPLAY_TABLE dt( 2, plbSubj->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJ_LBI::Compare

    SYNOPSIS:	Typical LBI compare for sorting purposes

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	Names are sorted on the display names of the subjects

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

int SUBJ_LBI::Compare( const LBI * plbi ) const
{
    SUBJ_LBI * psubjpermlbi = (SUBJ_LBI *) plbi ;

    return ::strcmpf( QuerySubject()->QueryDisplayName(),
		      psubjpermlbi->QuerySubject()->QueryDisplayName() ) ;
}

WCHAR SUBJ_LBI::QueryLeadingChar( void ) const
{
    ALIAS_STR nls( QuerySubject()->QueryDisplayName() ) ;
    ISTR istr( nls ) ;

    return nls.QueryChar( istr ) ;
}











/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::SUBJECT_PERM_LISTBOX

    SYNOPSIS:	Constructor for permissions listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991

********************************************************************/

SUBJECT_PERM_LISTBOX::SUBJECT_PERM_LISTBOX( OWNER_WINDOW * pownerwin,
					    CID cid,
					    ACCPERM * paccperm,
					    const TCHAR * pszSpecialAccessName )
    : SUBJECT_LISTBOX( pownerwin, cid ),
      _paccperm( paccperm ),
      _nlsSpecialPermName( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL ),
      _nlsSpecialAccessName( pszSpecialAccessName == NULL ? SZ("") : pszSpecialAccessName )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _paccperm != NULL ) ;

    APIERR err ;
    if ( ( err = _nlsSpecialPermName.QueryError() ) ||
	 ( err = _nlsSpecialAccessName.QueryError() )  )
    {
	DBGEOL( "SUBJECT_PERM_LISTBOX::ct - Display maps failed to construct " << err ) ;
	ReportError( err ) ;
	return ;
    }

    /* This is the permission name field
     */
    _anColWidth[ QueryNextUnusedColumn() ] = COL_WIDTH_AWAP ;

}

SUBJECT_PERM_LISTBOX::~SUBJECT_PERM_LISTBOX()
{
    _paccperm = NULL ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with SUBJ_PERM_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

APIERR SUBJECT_PERM_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    ACCESS_PERMISSION * pAccessPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAccessPermissions( &pAccessPerm, &fFromBeginning ) )
    {
	UIASSERT( pAccessPerm != NULL ) ;

	SUBJ_PERM_LBI * pPermLBI = new SUBJ_PERM_LBI( pAccessPerm,
		       QueryAccperm()->QueryAclConverter()->QueryAccessMap() ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    DBGEOL( "SUBJECT_PERM_LISTBOX::Fill - AddItem failed" ) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::SetCurrentPermission

    SYNOPSIS:	The currently selected SUBJ_PERM_LBI will get its
		permission bits set to the name corresponding
		to the passed permission name (must belong to
		the access mask map).

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/


APIERR SUBJECT_PERM_LISTBOX::SetCurrentPermission( const NLS_STR & nlsPermName )
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;

    /* Can't call this method if nothing is selected (Combo should be disabled)
     */
    UIASSERT( pPermLBI != NULL ) ;

    return pPermLBI->SetPermission( nlsPermName ) ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::QueryCurrentPermName

    SYNOPSIS:	Gets the string of the currently selected SUBJ_PERM_LBI

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	20-Aug-1991	Created
********************************************************************/

APIERR SUBJECT_PERM_LISTBOX::QueryCurrentPermName( NLS_STR * pnlsPermName ) const
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;

    /* Can't call this method if nothing is selected (Combo should be disabled)
     */
    UIASSERT( pPermLBI != NULL ) ;

    *pnlsPermName = pPermLBI->QueryPermName() ;

    return pnlsPermName->QueryError() ;
}

/*******************************************************************

    NAME:	SUBJECT_PERM_LISTBOX::DeleteCurrentItem

    SYNOPSIS:	Removes the currently selected item from the listbox

    EXIT:	Updates the listbox and combobox before exitting

    NOTES:

    HISTORY:
	Johnl	21-Aug-1991	Created

********************************************************************/

void SUBJECT_PERM_LISTBOX::DeleteCurrentItem( void )
{
    SUBJ_PERM_LBI * pPermLBI = QueryItem() ;
    UIASSERT( pPermLBI != NULL ) ;

    REQUIRE( QueryAccperm()->DeletePermission( pPermLBI->QueryAccessPerm() ) ) ;

    INT i = QueryCurrentItem() ;
    UIASSERT( i >= 0 ) ;

    DeleteItem( i ) ;
    INT cItems = QueryCount() ;

    if ( cItems > 0 )
	SelectItem( min( i, cItems - 1 ) ) ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::SUBJ_PERM_LBI_BASE

    SYNOPSIS:	LBIs that go into the SUBJECT_PERM_LISTBOX constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	DON'T CALL RefreshPermName from this constructor!!  It will
		call this->RefreshPermName and not the derived refreshpermname

    HISTORY:
	Johnl	20-Aug-1991	Created

********************************************************************/

SUBJ_PERM_LBI_BASE::SUBJ_PERM_LBI_BASE( SUBJECT * pSubj, MASK_MAP * pmaskmap )
    : SUBJ_LBI( pSubj ),
      _pMaskMap( pmaskmap ),
      _nlsPermName( 48 )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( _pMaskMap != NULL ) ;

    if ( _nlsPermName.QueryError() != NERR_Success )
    {
	ReportError( _nlsPermName.QueryError() ) ;
	return ;
    }
}

SUBJ_PERM_LBI_BASE::~SUBJ_PERM_LBI_BASE()
{
    _pMaskMap = NULL ;
}

ACCESS_PERMISSION * SUBJ_PERM_LBI_BASE::QueryAccessPerm( void ) const
{
    UIASSERT(!SZ("Did you forget to redefine derived QueryAccessPerm?") ) ;
    return NULL ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::Paint

    SYNOPSIS:	Typical LBI paint method for Subject Permission LBIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	    20-Aug-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

void SUBJ_PERM_LBI_BASE::Paint( LISTBOX * plb, HDC hdc, const RECT * prect, GUILTT_INFO * pguiltt ) const
{
    SUBJECT_PERM_LISTBOX * plbperm = (SUBJECT_PERM_LISTBOX *) plb ;

    NLS_STR nlsPermName( _nlsPermName ) ;
    NLS_STR nlsMnemonics( 15 ) ;

    APIERR err = NERR_Success ;
    if ( (err = nlsPermName.QueryError())  ||
         (err = nlsMnemonics.QueryError()) ||
         !plbperm->IsMnemonicsDisplayed()           ||
	 (err = BuildPermMnemonic( QueryAccessPerm(),
				   QueryMaskMap(),
				   &nlsMnemonics )) ||
	 (err = nlsPermName.AppendChar( TCH(' ')))  ||
	 (err = nlsPermName.Append( nlsMnemonics ))   )
    {
	/* Non-Fatal error, fall through
	 */
    }

    //
    //	Get the new item permission mnemonics if they are supported
    //	and the container mnemonics aren't empty
    //
    if ( !err &&
         QueryAccessPerm()->IsNewObjectPermsSupported() &&
         (nlsMnemonics.strlen() > 0) &&
         plbperm->IsMnemonicsDisplayed() )
    {
	if ((err = BuildPermMnemonic( QueryAccessPerm(),
				      QueryNewObjectMaskMap(),
				      &nlsMnemonics,
				      TRUE	    )) ||
	    (err = nlsPermName.AppendChar( TCH(' ')))  ||
	    (err = nlsPermName.Append( nlsMnemonics ))	 )
	{
	    /* Non-Fatal error, fall through
	     */
	}
    }

    DM_DTE dmiddte( plbperm->QueryDisplayMap( QuerySubject() ) ) ;
    STR_DTE strdteUserName( QuerySubject()->QueryDisplayName() ) ;
    STR_DTE strdtePermName( err ? _nlsPermName : nlsPermName ) ;

    DISPLAY_TABLE dt( 3, plbperm->QueryColumnWidths() ) ;
    dt[0] = &dmiddte ;
    dt[1] = &strdteUserName ;
    dt[2] = &strdtePermName ;

    dt.Paint( plb, hdc, prect, pguiltt ) ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::RefreshPermName

    SYNOPSIS:	After the bitmask has been changed, call this to update
		its permission string.

    EXIT:	The lbi will be updated with the appropriate permission name

    RETURNS:	NERR_Success if successful

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::RefreshPermName( void )
{
    APIERR err ;

    err = QueryMaskMap()->BitsToString( *(QueryAccessPerm()->QueryAccessBits()),
					&_nlsPermName,
					PERMTYPE_GENERAL ) ;

    if ( (err != NERR_Success) && (err != ERROR_NO_ITEMS) )
    {
	DBGEOL( "SUBJ_PERM_LBI_BASE::ct - BitsToString Failed" << err ) ;
	return err ;
    }

    /* If the bitmask doesn't correspond to a PERMTYPE_GENERAL permission,
     * (thus it wasn't found by BitsToString) we will assign the "Special"
     * keyword to this bitmask.
     */
    if ( err == ERROR_NO_ITEMS )
    {

	if ( (err = _nlsPermName.Load( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL)) ||
	     (err = QueryAccessPerm()->SaveSpecial())				     )
	{
	    return err ;
	}
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::SetPermission

    SYNOPSIS:	This method sets the bits of this permission based
		on the passed string.  The string should correspond
		to a string in the mask map.

    ENTRY:	nlsPermName - Permission name to set the permission bits to.

    EXIT:	The permission bits will be changed to the bits that
		correspond to the permission name.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::SetPermission( const NLS_STR & nlsPermName )
{
    APIERR err = QueryAccessPerm()->SetPermission( nlsPermName,
						   QueryMaskMap(),
						   QueryNewObjectMaskMap() ) ;
    if ( !err )
	err = SetPermName( nlsPermName ) ;

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::QueryNewObjectMaskMap

    SYNOPSIS:	Return the new object mask map

    RETURNS:	Pointer to this LBI's mask map object

    NOTES:	At this level we don't have a mask map so we return NULL

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

MASK_MAP * SUBJ_PERM_LBI_BASE::QueryNewObjectMaskMap( void ) const
{
    return NULL ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::SUBJ_PERM_LBI

    SYNOPSIS:	Basic constructor

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

SUBJ_PERM_LBI::SUBJ_PERM_LBI( ACCESS_PERMISSION * pAccessPerm,
			      MASK_MAP * pmaskmap )
	: SUBJ_PERM_LBI_BASE( (SUBJECT *) pAccessPerm->QuerySubject(), pmaskmap ),
	  _pAccessPerm( pAccessPerm )
{
    APIERR err = RefreshPermName() ;
    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::QueryAccessPerm

    SYNOPSIS:	Virtual access method to get to the underlying ACCESS_PERMISSION
		object

    RETURNS:	Pointer to the access permission

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

ACCESS_PERMISSION * SUBJ_PERM_LBI::QueryAccessPerm( void ) const
{
    return _pAccessPerm ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI::~SUBJ_PERM_LBI

    SYNOPSIS:	Small destructor

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

SUBJ_PERM_LBI::~SUBJ_PERM_LBI()
{
    _pAccessPerm = NULL ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJECT_PERM_LISTBOX::NT_CONT_SUBJECT_PERM_LISTBOX

    SYNOPSIS:	Typical constructor for the NT Container subject permission
		listbox.

    ENTRY:	Same as parent
		pszSpecialNewObjectAccessName - String that brings up the
		New Sub-Object Special dialog

    NOTES:

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

NT_CONT_SUBJECT_PERM_LISTBOX::NT_CONT_SUBJECT_PERM_LISTBOX( OWNER_WINDOW * pownerwin,
					    CID cid,
					    ACCPERM * paccperm,
					    const TCHAR * pszSpecialAccessName,
					    const TCHAR * pszSpecialNewObjectAccessName )
    : SUBJECT_PERM_LISTBOX( pownerwin, cid, paccperm, pszSpecialAccessName ),
      _nlsSpecialNewObjectAccessName( pszSpecialNewObjectAccessName == NULL ? SZ("")
					       : pszSpecialNewObjectAccessName )
{
    if ( QueryError() != NERR_Success )
	return ;

    /* _nlsSpecialNewObjectAccessName is an ALIAS_STR
     */
    UIASSERT( !_nlsSpecialNewObjectAccessName.QueryError() ) ;
}

NT_CONT_SUBJECT_PERM_LISTBOX::~NT_CONT_SUBJECT_PERM_LISTBOX()
{
    /* Nothing to do */
}


/*******************************************************************

    NAME:	NT_CONT_SUBJECT_PERM_LISTBOX::Fill

    SYNOPSIS:	Fill the listbox with NT_CONT_SUBJ_PERM_LBI objects that are
		retrieved from the accperm object.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The listbox is first emptied of all items.

    HISTORY:
	Johnl	27-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJECT_PERM_LISTBOX::Fill( void )
{
    SetRedraw( FALSE ) ;
    DeleteAllItems() ;

    NT_CONT_ACCESS_PERMISSION * pAccessPerm ;
    BOOL fFromBeginning = TRUE ;

    while ( QueryAccperm()->EnumAccessPermissions( (ACCESS_PERMISSION **)&pAccessPerm, &fFromBeginning ) )
    {
	UIASSERT( pAccessPerm != NULL ) ;

	NT_CONT_SUBJ_PERM_LBI * pPermLBI = new NT_CONT_SUBJ_PERM_LBI( pAccessPerm,
		       QueryAccperm()->QueryAclConverter()->QueryAccessMap(),
		       QueryAccperm()->QueryAclConverter()->QueryNewObjectAccessMap() ) ;

	if ( AddItem( pPermLBI ) < 0 )
	{
	    DBGEOL( "NT_CONT_SUBJECT_PERM_LISTBOX::Fill - AddItem failed" ) ;
	    SetRedraw( TRUE ) ;
	    Invalidate( TRUE ) ;
	    return ERROR_NOT_ENOUGH_MEMORY ;
	}
    }

    if ( QueryCount() > 0 )
	SelectItem( 0 ) ;

    SetRedraw( TRUE ) ;
    Invalidate( TRUE ) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::NT_CONT_SUBJ_PERM_LBI

    SYNOPSIS:	Basic constructor

    ENTRY:	Same as parent
		pNTContAccessPerm - Access permission this LBI will
		    display
		pNewObjectMaskMap - Mask map to use for the new object
		    permissions

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

NT_CONT_SUBJ_PERM_LBI::NT_CONT_SUBJ_PERM_LBI(
			   NT_CONT_ACCESS_PERMISSION * pNTContAccessPerm,
			   MASK_MAP * pmaskmap,
			   MASK_MAP * pNewObjectMaskMap )
    : SUBJ_PERM_LBI_BASE( (SUBJECT *) pNTContAccessPerm->QuerySubject(), pmaskmap ),
      _pNTContAccessPerm( pNTContAccessPerm ),
      _pNewObjectMaskMap( pNewObjectMaskMap )
{
    APIERR err = RefreshPermName() ;
    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}


/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::RefreshPermName

    SYNOPSIS:	Updates this LBI's permission name based on the current
		access bits

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created
	Johnl	16-Jan-1991	Changed to not call parent (have to check
				strings resolve to same name).

********************************************************************/

APIERR NT_CONT_SUBJ_PERM_LBI::RefreshPermName( void )
{
    APIERR err	    = NERR_Success ;
    BOOL   fFound   = FALSE ;
    int    nID ;
    BITFIELD bitContPerm( (ULONG) 0 ) ;
    BITFIELD bitNewObjPerm( (ULONG) 0 ) ;

    if ( (err = bitContPerm.QueryError()) ||
	 (err = bitNewObjPerm.QueryError()) )
    {
	return err ;
    }

    //
    //  If the permissions aren't propagated, then this is automatically a
    //  special permission
    //

    if ( !QueryAccessPerm()->IsContainerPermsInheritted() )
    {
        fFound = FALSE ;
    }
    else
    {
        /* Loop through each high level container permission looking for a match
         * between the container permission and the mask map entry.  If a match
         * is found, then check for a match with the new object permissions.  If
         * they match, then we have found the correct permissions name, otherwise
         * keep looking.  If none match, then this is a special permission.
         */
        UINT cTotalItems = QueryMaskMap()->QueryCount() ;
        for ( UINT i = 0 ; i < cTotalItems && !fFound && !err ; i++ )
        {

            if ( !(err = QueryMaskMap()->QueryBits( i,
                                                    &bitContPerm,
                                                    &_nlsPermName,
                                                    &nID ))            &&
                 (nID == PERMTYPE_GENERAL)                             &&
                 (bitContPerm == *QueryAccessPerm()->QueryAccessBits())  )
            {
                /* The container permissions match, but do the new object
                 * permissions?
                 */

                if ( err = QueryNewObjectMaskMap()->StringToBits(
                                                              _nlsPermName,
                                                              &bitNewObjPerm,
                                                              PERMTYPE_GENERAL))
                {
                    /* If err is ERROR_NO_ITEMS then assume the permission category
                     * didn't specify New object permissions.  Which means
                     * we may match if this subject doesn't have new object
                     * permissions specified
                     */
                    if ( err == ERROR_NO_ITEMS )
                    {
                        err = NERR_Success ;

                        if ( !_pNTContAccessPerm->IsNewObjectPermsSpecified() )
                        {
                            fFound = TRUE ;
                        }
                    }
                }
                else if ( _pNTContAccessPerm->IsNewObjectPermsSpecified() &&
                          (bitNewObjPerm == *_pNTContAccessPerm->
                                              QueryNewObjectAccessBits()))
                {
                    fFound = TRUE ;
                }
            }
        }
    }

    if ( !err )
    {
	if ( !fFound )
	{
	    if ( (err = _nlsPermName.Load( (MSGID) IDS_GEN_ACCESSNAME_SPECIAL)) ||
		 (err = QueryAccessPerm()->SaveSpecial()) )
	    {
		/* Fall through and return */
	    }
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	SUBJ_PERM_LBI_BASE::::BuildPermMnemonic

    SYNOPSIS:	Builds a string that contains the letter mnemonics
		contained in the special permission strings.

    ENTRY:	pAccessPerm - Access permission to build the mnemonic for
		pmaskmapPerms - Mask Map to use for retrieving the mnemonics
		pnlsMnemonics - Pointer to the string that will receive the
		    Mnemonic
		fIsNewPerm - TRUE if we should build the mnemonic for the
		    new item permissions specified for this access permission

    EXIT:	*pnlsMnemonics will contain one of:

		    1) A valid mnemonic such as "(RWX)"
		    2) The empty string if no mnemonics were found
		    3) "(Not Specified)" if New perms are not specified
		    4) "(None)" if no perms are granted
                    5) "(All)" if all perms are granted
                    6) "(Partial)" if we can't represent this perm

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	We expect the permission names in the mask map to look
		like:  "Perm Name (P)"

    HISTORY:
	Johnl	09-Mar-1992	Created

********************************************************************/

APIERR SUBJ_PERM_LBI_BASE::BuildPermMnemonic(
				       ACCESS_PERMISSION * pAccessPerm,
				       MASK_MAP 	 * pmaskmapPerms,
				       NLS_STR		 * pnlsMnemonics,
				       BOOL		   fIsNewPerm ) const
{
    UIASSERT( pnlsMnemonics != NULL && !(pnlsMnemonics->QueryError()) ) ;
    UIASSERT( !fIsNewPerm ||
	      (fIsNewPerm && pAccessPerm->IsNewObjectPermsSupported()) ) ;

    BITFIELD * pBits = !fIsNewPerm ? pAccessPerm->QueryAccessBits() :
				     pAccessPerm->QueryNewObjectAccessBits() ;
    UIASSERT( pBits != NULL ) ;
    APIERR err = NERR_Success ;

    //
    //  Special case the Not specified, No Access, Partial and All cases
    //
    if ( !pAccessPerm->IsMapped() )
    {
        //
        //  Only supply a mnemonic for the container if this is a container
        //
        if ( !pAccessPerm->IsNewObjectPermsSupported() ||
             !fIsNewPerm )
        {
            err = pnlsMnemonics->Load( IDS_NOT_MAPPED_MNEMONIC ) ;
        }
        else
            *pnlsMnemonics = SZ("") ;
    }
    else if (  pAccessPerm->IsNewObjectPermsSupported() &&
               fIsNewPerm                               &&
               !pAccessPerm->IsNewObjectPermsSpecified() )
    {
	err = pnlsMnemonics->Load( IDS_NOT_SPECIFIED_MNEMONIC ) ;
    }
    else if ( pAccessPerm->IsDenyAll( *pBits ) )
    {
	err = pnlsMnemonics->Load( IDS_NO_ACCESS_MNEMONIC ) ;
    }
    else if ( pAccessPerm->IsGrantAll( *pBits ) )
    {
	err = pnlsMnemonics->Load( IDS_FULL_ACCESS_MNEMONIC ) ;
    }
    else
    {
	/* Need to build the mnemonic by hand
	 */
	NLS_STR  nlsPermName( 32 ) ;
	BITFIELD bitsMask   ( *pBits ) ;  // Initialize size
	BITFIELD bitsScratch( *pBits ) ;
	BITFIELD bitsPerm   ( *pBits ) ;
	int	 nPermID ;

	*pnlsMnemonics = SZ("") ;
	if ( (err = pnlsMnemonics->AppendChar(MNEMONIC_START_CHAR)) ||
	     (err = nlsPermName.QueryError() )		   ||
	     (err = bitsMask.QueryError() )		   ||
	     (err = bitsPerm.QueryError() )		     )
	{
	    return err ;
	}

	UINT cNumElem = pmaskmapPerms->QueryCount() ;
	for ( UINT i = 0 ; i < cNumElem ; i++ )
	{
	    if ( err = pmaskmapPerms->QueryBits( i,
						 &bitsMask,
						 &nlsPermName,
						 &nPermID ))
	    {
		return err ;
	    }

	    /* If the permission we are looking at in the mask map is a
	     *	  special permission and the access mask contains all
	     *	  of the bits in this special permission, then append the
	     *	  letter mnemonic.
	     */
	    bitsScratch =  bitsMask ;
	    bitsScratch &= bitsPerm ;
	    if ( (nPermID == PERMTYPE_SPECIAL)	  &&
		 ( bitsScratch == bitsMask)   )
	    {
		ISTR istrMnemonicStart( nlsPermName ) ;
		if ( nlsPermName.strchr( &istrMnemonicStart,
					 MNEMONIC_SEARCH_CHAR ))
		{
		    /* Loop through the mnemonic character list appending to
		     * the end of the mnemonic string.
		     */
		    while ((nlsPermName.QueryChar(++istrMnemonicStart )
							     !=TCH('\0')) &&
			   (nlsPermName.QueryChar(  istrMnemonicStart )
						     != MNEMONIC_END_CHAR ))
		    {
                        /* #2687 23-Oct-93 v-katsuy */
		        /* In Japan, accelerators format is "File(&F)".
		         * And in this case, resource strings as "File(&F) (F)".
		         * OK, We use accelerators for nemonic strings without '&'.
		         */
		        if (   NETUI_IsDBCS()
                            && nlsPermName.QueryChar( istrMnemonicStart ) == TCH('&'))
                        {
		            continue;
                        }
			if ( err = pnlsMnemonics->AppendChar(
				  nlsPermName.QueryChar( istrMnemonicStart )))

			{
			    return err ;
			}
		    } // while
		}
	    }
	} // for

	/* If we actually added any mnemonics (other then the openning "("),
	 *     then close the string.
	 * Otherwise
	 *     Make the string the empty string.
	 */
	if ( pnlsMnemonics->QueryNumChar() > 1 )
	{
	    err = pnlsMnemonics->AppendChar(MNEMONIC_END_CHAR) ;
	}
	else
	{
	    *pnlsMnemonics = SZ("") ;
	    err = pnlsMnemonics->QueryError() ;
	}
    }

    //
    //  Lastly, we may need to append a marker indicating this permission
    //  will not be propagated to new containers.
    //
    //   if (    this is the new perm mnemonic and Object perms supported
    //        OR Object perms are not supported
    //        AND container perms aren't inheritted
    //
    if ( !err )
    {
        if ( ( (!fIsNewPerm &&
                pAccessPerm->IsNewObjectPermsSupported()
               ) ||
               (!pAccessPerm->IsNewObjectPermsSupported())
             ) &&
	     !pAccessPerm->IsContainerPermsInheritted() )
	{
	    err = pnlsMnemonics->AppendChar(MNEMONIC_NOT_INHERITTED_MARKER) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::QueryAccessPerm

    SYNOPSIS:	Virtual access method to get to the underlying ACCESS_PERMISSION
		object

    RETURNS:	Pointer to the access permission

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

ACCESS_PERMISSION * NT_CONT_SUBJ_PERM_LBI::QueryAccessPerm( void ) const
{
    return _pNTContAccessPerm ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::QueryNewObjectMaskMap

    SYNOPSIS:	Return the new object mask map

    RETURNS:	Pointer to this LBI's mask map object

    NOTES:

    HISTORY:
	Johnl	29-Sep-1991	Created

********************************************************************/

MASK_MAP * NT_CONT_SUBJ_PERM_LBI::QueryNewObjectMaskMap( void ) const
{
    return _pNewObjectMaskMap ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_PERM_LBI::~NT_CONT_SUBJ_PERM_LBI

    SYNOPSIS:	Small destructor

    NOTES:

    HISTORY:
	Johnl	26-Sep-1991	Created

********************************************************************/

NT_CONT_SUBJ_PERM_LBI::~NT_CONT_SUBJ_PERM_LBI()
{
    _pNewObjectMaskMap = NULL ;
    _pNTContAccessPerm= NULL ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::SUBJ_LB_GROUP

    SYNOPSIS:	Subject listbox group constructor

    ENTRY:	pOwnerDlg - Pointer to dialog that owns us.  This is so
			    we have access to the OnSpecial and
			    OnNewObjectSpecial methods.
		plbSubj - Pointer to listbox this group will deal with
		pcbPermName - Pointer to combobox that is linked to the
			listbox
		pbuttonRemove - Pointer to remove button that is grayed
                        when the listbox is empty.
                psltCBTitle - Combo box title (grayed when combo is disabled)

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	30-Aug-1991	Created

********************************************************************/

SUBJ_LB_GROUP::SUBJ_LB_GROUP( MULTI_SUBJ_ACCESS_PERM_BASE_DLG * pOwnerDlg,
			      SUBJECT_PERM_LISTBOX * plbSubj,
			      COMBOBOX		   * pcbPermName,
                              PUSH_BUTTON          * pbuttonRemove,
                              SLT                  * psltCBTitle )

    : _pOwnerDlg        ( pOwnerDlg ),
      _plbSubj          ( plbSubj ),
      _pcbPermName      ( pcbPermName ),
      _pbuttonRemove    ( pbuttonRemove ),
      _psltCBTitle      ( psltCBTitle ),
      _fEnabled         ( TRUE ),
      _fIsDropped       ( FALSE ),
      _fOnSpecialHandled( TRUE )
{
    if ( QueryError() != NERR_Success )
	return ;

    UIASSERT( pOwnerDlg      != NULL ) ;
    UIASSERT( plbSubj	     != NULL ) ;
    UIASSERT( pcbPermName    != NULL ) ;
    UIASSERT( pbuttonRemove  != NULL ) ;

    /* We don't set the buttons to be part of this group since we don't
     * care if they "change" state.  We only need to disable them if the
     * listbox is emptied or is readonly.
     */
    plbSubj->SetGroup( this ) ;
    pcbPermName->SetGroup( this ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::OnUserAction

    SYNOPSIS:	This method handles the cooridination of information between
		the Permissions combo-box and the permissions listbox.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	If the combo is dropped down and the message is a selection
		change method, then ignore it.

    HISTORY:
	Johnl	    20-Aug-1991 Created
	beng	    08-Oct-1991 Win32 conversion

********************************************************************/

APIERR SUBJ_LB_GROUP::OnUserAction( CONTROL_WINDOW * pcw,
				    const CONTROL_EVENT & e )
{
    if ( pcw == QueryPermNameCombo() )
    {
	/* We can never become enabled by the combobox, only the listbox
	 * changing can enable us
	 */
	if ( !IsEnabled() )
	    return GROUP_NO_CHANGE ;

	switch ( e.QueryCode() )
	{
	case CBN_DROPDOWN:
	    SetDropDownFlag( TRUE ) ;
	    break ;

        case CBN_CLOSEUP:
            SetDropDownFlag( FALSE ) ;
            if ( !IsOnSpecialHandled() )
	    {
		NLS_STR nlsPermName( 40 ) ;
		APIERR err = QueryPermNameCombo()->QueryItemText( &nlsPermName ) ;
		if ( err != NERR_Success )
		    return err ;
		return UpdatePermNameCombo( nlsPermName ) ;
            }
            else
            {
                SetOnSpecialHandled( FALSE ) ;
            }
	    break ;

	case CBN_SELCHANGE:
	    if ( IsDroppedDown() )
	    {
		break ;
	    }
	    else
	    {
		NLS_STR nlsPermName( 40 ) ;
		APIERR err = QueryPermNameCombo()->QueryItemText( &nlsPermName ) ;
		if ( err != NERR_Success )
		    return err ;
		return UpdatePermNameCombo( nlsPermName ) ;
	    }
	    break ;

	default:
	    break ;
	}
    }
    else
    {
	UIASSERT( pcw == QuerySubjLB() ) ;
	// C7 CODEWORK - remove Glock-pacifier cast
	if ( pcw->QueryEventEffects( (const CONTROL_EVENT &)e ) & CVMI_VALUE_CHANGE )
	    return UpdateSubjectListbox() ;
    }

    return GROUP_NO_CHANGE ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::UpdateSubjectListbox

    SYNOPSIS:	The listbox has changed so we need to update the listbox
		and update the associated combo box.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::UpdateSubjectListbox( void )
{
    /* If the listbox is empty, then we need to disable all of the controls
     * that operate on items in the listbox.
     */
    if ( QuerySubjLB()->QueryCount() == 0 )
    {
	if ( IsEnabled() )
	{
	    Enable( FALSE ) ;
	}

	return NERR_Success ;
    }
    else if ( !IsEnabled() && QuerySubjLB()->QueryCount() > 0 )
    {
	Enable( TRUE ) ;
    }

    APIERR err ;
    NLS_STR nlsPermName( 40 ) ;

    if ( (err = nlsPermName.QueryError()) ||
	 (err = QuerySubjLB()->QueryCurrentPermName( &nlsPermName )))
    {
	return err ;
    }

    /* If the dialog is read only, then we need to add and remove the
     * permission names in the combo as opposed to just selecting
     * existing names.
     */
    if ( IsReadOnly() )
    {
	/* If the new selection is the same as the old selection, then leave
	 * it, else remove the old selection and put in the new selection.
	 */
	if ( nlsPermName != *QueryLastROSelection() )
	{
	    INT i = QueryPermNameCombo()->FindItemExact( *QueryLastROSelection() ) ;

	    /* Only delete it if we found it (we won't find it the first
	     * time through here)
	     */
	    if ( i >= 0 )
	    {
		QueryPermNameCombo()->DeleteItem( i ) ;
	    }

	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( ((i = QueryPermNameCombo()->InsertItem( 0, nlsPermName )) <0) ||
		 (err = SetLastROSelection( nlsPermName )) )
	    {
		// fall through
	    }
	}

	/* Reset the combo to the correct permission name
	 */
	INT i = QueryPermNameCombo()->FindItemExact( nlsPermName ) ;
	if ( i >= 0 )
	{
	    QueryPermNameCombo()->SelectItem( i ) ;
	}

	return err ;
    }

    /* The user just changed the listbox, so reflect the changes in
     * the combo box by selecting the corresponding permission name
     */
    INT i = QueryPermNameCombo()->FindItemExact( nlsPermName ) ;
    if ( i >= 0 )
    {
	QueryPermNameCombo()->SelectItem( i ) ;

	/* If the new permission name is not the "Special" permission name,
	 * then we need to remove the "Special" permission name if it was
	 * there from the previous selection.
	 */
	if ( nlsPermName != QuerySubjLB()->QuerySpecialPermName() )
	{
	    INT iSpec = QueryPermNameCombo()->FindItemExact(
			      QuerySubjLB()->QuerySpecialPermName() ) ;
	    if ( iSpec >= 0 )
		REQUIRE( QueryPermNameCombo()->DeleteItem( iSpec ) ) ;
	}
    }
    else
    {
	/* The user selected "Special" in the listbox, which isn't in
	 * the combo box, so we need to add it.
	 */

	UIASSERT( nlsPermName == QuerySubjLB()->QuerySpecialPermName() ) ;

	if ( QueryPermNameCombo()->AddItem( nlsPermName ) < 0 )
	    return ERROR_NOT_ENOUGH_MEMORY ;

	i = QueryPermNameCombo()->FindItemExact( QuerySubjLB()->QuerySpecialPermName() ) ;
	UIASSERT( i >= 0 ) ;
	QueryPermNameCombo()->SelectItem( i ) ;

	/* Since the current permission is a special permission, save it
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	UIASSERT( pPermLBI != NULL ) ;
	err = pPermLBI->QueryAccessPerm()->SaveSpecial() ;
	if ( err != NERR_Success )
	    return err ;

    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SUBJ_LB_GROUP::UpdatePermNameCombo

    SYNOPSIS:	The permission name combo has been twiddled, so we need
		to update the listbox appropriately

    ENTRY:	nlsPermName - New permission name the user just selected in
		the combo

    EXIT:

    RETURNS:

    CAVEATS:	The name is slightly misleading, it should more appropriately
		read UpdateListboxFromPermNameCombo

    NOTES:	This will only be called when we truly wish to change the
		selection (i.e., not when we are dropped down).

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::UpdatePermNameCombo( const NLS_STR & nlsPermName )
{
    APIERR err ;

    /* The combobox changed so we need to update the listbox.
     */

    if ( nlsPermName == QuerySubjLB()->QuerySpecialAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
	}
	return err ;
    }

    err = QuerySubjLB()->SetCurrentPermission( nlsPermName ) ;
    if ( err != NERR_Success )
	return err ;

    QuerySubjLB()->InvalidateItem( QuerySubjLB()->QueryCurrentItem() ) ;

    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::OnEnter

    SYNOPSIS:	Notifies the group the user hit enter (thus the dialog is
		about to be dismissed).  This method gives us a chance
		to say "Hey! Don't do that!" and bring up a dialog if
		necessary.

		This method implements the behaviour of the user dropping
		the permission combo, selecting a "Special ..." permission
		and hitting enter, which brings up the dialog.

    ENTRY:

    EXIT:	pfDismissDialog is set to TRUE if it is OK to go ahead and
		dismiss the dialog, else it is set to FALSE because we have
		brought up our own dialog.

    RETURNS:	NERR_Success if successful, error code otherwise (if an
		error occurred, then pfDismissDialog should be ignored).

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR SUBJ_LB_GROUP::OnEnter( BOOL * pfDismissDialog )
{
    /* If the permname combo isn't dropped down, then we don't need
     * to do anything.
     */
    if ( !IsDroppedDown() )
    {
	*pfDismissDialog = TRUE ;
	return NERR_Success ;
    }

    /* They have the permission combo dropped down, if it is just a permission
     * selection, then we will set the permission and return, otherwise it
     * is a "Special ..." selection, thus we need to bring up a dialog
     * as appropriate.
     */
    NLS_STR nlsComboSelection ;
    APIERR err = QueryPermNameCombo()->QueryItemText( &nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    if ( nlsComboSelection == QuerySubjLB()->QuerySpecialAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
        }

        SetOnSpecialHandled( TRUE ) ;
	*pfDismissDialog = FALSE ;
        return err ;
    }

    err = QuerySubjLB()->SetCurrentPermission( nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    QuerySubjLB()->InvalidateItem( QuerySubjLB()->QueryCurrentItem() ) ;

    *pfDismissDialog = TRUE ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::Enable

    SYNOPSIS:	Enables or disables the appropriate components of this
		group

    ENTRY:	fEnable - TRUE if the group should be enabled, FALSE to
			  disable the group

    EXIT:	The remove button will be grayed, the perm. combo will
		be disabled and have its selection removed.

    NOTES:	If the data is read only, then this method will disable the
		the Remove buttons also.

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/


void SUBJ_LB_GROUP::Enable( BOOL fEnable )
{
    _fEnabled = fEnable ;

    if ( !fEnable )
    {
	QueryPermNameCombo()->RemoveSelection() ;
    }

    QueryPermNameCombo()->Enable( fEnable ) ;
    QueryPermNameLabel()->Enable( fEnable ) ;
    QueryRemoveButton()->Enable( !IsReadOnly() && fEnable ) ;
}


/*******************************************************************

    NAME:	SUBJ_LB_GROUP::IsReadOnly

    SYNOPSIS:	Returns TRUE if the dialog this group is contained in is
		read only.

    NOTES:

    HISTORY:
	Johnl	05-May-1992	Moved from header because of circular
				dependencies.

********************************************************************/

BOOL SUBJ_LB_GROUP::IsReadOnly( void ) const
{
    return (((SUBJ_LB_GROUP *) this)->QueryOwnerDlg())->IsReadOnly() ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_LB_GROUP::UpdatePermNameCombo

    SYNOPSIS:	We just check to see if the new selection is the
		New Object Access choice, if so, we bring up the new
		object access dialog, otherwise we just pass the
		message on to the parent.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	This will only be called when we truly wish to change the
		selection (i.e., not when we are dropped down).

    HISTORY:
	Johnl	22-Aug-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJ_LB_GROUP::UpdatePermNameCombo( const NLS_STR & nlsNewPermName )
{
    if ( nlsNewPermName == QueryNTContSubjLB()->QuerySpecialNewObjectAccessName() )
    {
	/* Throw up the new object special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	APIERR err = QueryOwnerDlg()->OnNewObjectSpecial( pPermLBI ) ;
	if ( err == NERR_Success )
	{
	     if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
	}
	return err ;
    }

    return SUBJ_LB_GROUP::UpdatePermNameCombo( nlsNewPermName ) ;
}

/*******************************************************************

    NAME:	NT_CONT_SUBJ_LB_GROUP::OnEnter

    SYNOPSIS:	Notifies the group the user hit enter (thus the dialog is
		about to be dismissed).  This method gives us a chance
		to say "Hey! Don't do that!" and bring up a dialog if
		necessary.

		This method implements the behaviour of the user dropping
		the permission combo, selecting a "Special ..." permission
		and hitting enter, which brings up the dialog.

    ENTRY:

    EXIT:	pfDismissDialog is set to TRUE if it is OK to go ahead and
		dismiss the dialog, else it is set to FALSE because we have
		brought up our own dialog.

    RETURNS:	NERR_Success if successful, error code otherwise (if an
		error occurred, then pfDismissDialog should be ignored).

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR NT_CONT_SUBJ_LB_GROUP::OnEnter( BOOL * pfDismissDialog )
{
    /* If the permname combo isn't dropped down, then we don't need
     * to do anything.
     */
    if ( !IsDroppedDown() )
    {
	*pfDismissDialog = TRUE ;
	return NERR_Success ;
    }

    /* They have the permission combo dropped down, if it is just a permission
     * selection, then we will set the permission and return, otherwise it
     * is a "Special ..." selection, thus we need to bring up a dialog
     * as appropriate.
     */
    NLS_STR nlsComboSelection ;
    APIERR err = QueryPermNameCombo()->QueryItemText( &nlsComboSelection ) ;
    if ( err != NERR_Success )
	return err ;

    if ( nlsComboSelection == QueryNTContSubjLB()->QuerySpecialNewObjectAccessName() )
    {
	/* Throw up the special access dialog
	 */
	SUBJ_PERM_LBI * pPermLBI = QuerySubjLB()->QueryItem() ;
	if ( (err = QueryOwnerDlg()->OnNewObjectSpecial( pPermLBI )) == NERR_Success )
	{
	    if ( (err = pPermLBI->RefreshPermName()) == NERR_Success )
		err = UpdateSubjectListbox() ;
        }

        SetOnSpecialHandled( TRUE ) ;
	*pfDismissDialog = FALSE ;
	return err ;
    }

    return SUBJ_LB_GROUP::OnEnter( pfDismissDialog ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\acledit\sedapi.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    SEDApi.cxx

    This file contains the public security editor APIs.



    FILE HISTORY:
	Johnl	26-Dec-1991	Created

*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntseapi.h>
    #include <ntlsa.h>
    #include <ntioapi.h>
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <fontedit.hxx>
#include <dbgstr.hxx>

#include <security.hxx>
#include <lmodom.hxx>
#include <uintsam.hxx>
#include <uintlsa.hxx>
#include <ntacutil.hxx>
#include <maskmap.hxx>

#include <accperm.hxx>
#include <aclconv.hxx>
#include <permstr.hxx>

#include <specdlg.hxx>
#include <add_dlg.hxx>
#include <permdlg.hxx>
#include <perm.hxx>
#include <uitrace.hxx>

#include <owner.hxx>

extern "C"
{
    #include <sedapi.h>
    #include <lmuidbcs.h>       // NETUI_IsDBCS()
}

#include <ipermapi.hxx>

/* Private prototype
 */
DWORD
I_NTAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR		     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadAcl,
        BOOLEAN                      CantWriteDacl,
	LPDWORD 		     SEDStatusReturn,
        BOOLEAN                      fAccessPerms,
        DWORD                        dwFlags
	) ;

/*************************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT

    SYNOPSIS:	Simple derived class that simply calls the passed callback
		function when the user presses the Take Ownership button.

    INTERFACE:

    PARENT:	TAKE_OWNERSHIP_DLG

    USES:

    CAVEATS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

**************************************************************************/

class TAKE_OWNERSHIP_WITH_CALLOUT : public TAKE_OWNERSHIP_DLG
{
private:
    PSED_FUNC_APPLY_SEC_CALLBACK _pfuncApplySecurityCallbackRoutine ;
    ULONG_PTR   	 _ulCallbackContext ;
    HWND			 _hwndParent ;
    HANDLE			 _hInstance ;

    /* Stores the status returned by the security callback during dialog
     * processing.
     */
    DWORD			 _dwStatus ;

public:
    TAKE_OWNERSHIP_WITH_CALLOUT(
			HWND	      hwndParent,
			HANDLE	      hInstance,
			const TCHAR * pszServer,
			UINT	      uiCount,
			const TCHAR * pchResourceType,
			const TCHAR * pchResourceName,
			PSECURITY_DESCRIPTOR psecdesc,
			ULONG_PTR     ulCallbackContext,
			PSED_FUNC_APPLY_SEC_CALLBACK pfuncApplySecurityCallback,
                        PSED_HELP_INFO psedhelpinfo
			       ) ;

    virtual APIERR OnTakeOwnership( const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner ) ;

    DWORD QuerySEDStatus( void ) const
	{ return _dwStatus ; }
} ;

/*******************************************************************

    NAME:	SedTakeOwnership

    SYNOPSIS:	Displays the current owner of the passed security
		descriptor and allows the user to set the owner to
		themselves.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	JohnL	12-Feb-1992	Created

********************************************************************/

DWORD
SedTakeOwnership(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	LPTSTR			     ObjectTypeName,
	LPTSTR			     ObjectName,
	UINT			     CountOfObjects,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadOwner,
        BOOLEAN                      CantWriteOwner,
	LPDWORD 		     SEDStatusReturn,
        PSED_HELP_INFO               HelpInfo,
        DWORD                        Flags
	)
{
    APIERR err = NERR_Success ;

    if ( (ObjectTypeName == NULL		) ||
         (ApplySecurityCallbackRoutine == NULL  ) ||
         (Flags != 0)  )

    {
	UIDEBUG(SZ("::SedTakeOwnership - Invalid parameter\n\r")) ;
	*SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return ERROR_INVALID_PARAMETER ;
    }

    if ( CouldntReadOwner && CantWriteOwner )
    {
        err = ERROR_ACCESS_DENIED ;
        ::MsgPopup( Owner, (MSGID) err ) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return err ;
    }

    if ( CouldntReadOwner && !CantWriteOwner )
    {
	switch (MsgPopup( Owner,
			  (MSGID)IERR_OWNER_CANT_VIEW_CAN_EDIT,
			  MPSEV_WARNING,
			  MP_YESNO ))
	{
	case IDYES:
	    break ;

	case IDNO:
	    *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	    return NO_ERROR ;

	default:
	    UIASSERT(FALSE) ;
	    break ;
	}
    }

    TAKE_OWNERSHIP_WITH_CALLOUT dlgTakeOwner( Owner,
					      Instance,
					      Server,
					      CountOfObjects,
					      ObjectTypeName,
					      ObjectName,
					      SecurityDescriptor,
					      CallbackContext,
					      ApplySecurityCallbackRoutine,
                                              HelpInfo ) ;

    if ( err = dlgTakeOwner.Process() )
    {
	DBGEOL(SZ("::SedTakeOwnerShip - dlgTakeOwner failed to construct, error code ") << (ULONG) err ) ;
	MsgPopup( Owner, (MSGID) err ) ;
	*SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    *SEDStatusReturn = dlgTakeOwner.QuerySEDStatus() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	SedDiscretionaryAclEditor

    SYNOPSIS:	Public API for DACL editting.  See SEDAPI.H for a complete
		description of the parameters.

    RETURNS:	One of the SED_STATUS_* return codes

    NOTES:

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
SedDiscretionaryAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadDacl,
        BOOLEAN                      CantWriteDacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
	)
{
    return I_NTAclEditor( Owner,
			  Instance,
			  Server,
			  ObjectType,
			  ApplicationAccesses,
			  ObjectName,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
			  SecurityDescriptor,
                          CouldntReadDacl,
                          CantWriteDacl,
			  SEDStatusReturn,
                          TRUE,
                          Flags ) ;
}

/*******************************************************************

    NAME:	SedSystemAclEditor

    SYNOPSIS:	Public API for SACL editting.  See SEDAPI.H for a complete
		description of the parameters.

    RETURNS:	One of the SED_STATUS_* return codes

    NOTES:

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
SedSystemAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadWriteSacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
	)
{
    return I_NTAclEditor( Owner,
			  Instance,
			  Server,
			  ObjectType,
			  ApplicationAccesses,
			  ObjectName,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
			  SecurityDescriptor,
                          CouldntReadWriteSacl,
                          CouldntReadWriteSacl,
			  SEDStatusReturn,
                          FALSE,
                          Flags ) ;
}

/*******************************************************************

    NAME:	I_NTAclEditor

    SYNOPSIS:   Private API for ACL editting.  The parameters are the
		same as SedDiscretionaryAclEditor and SedSystemAclEditor
		except for one additional parameter, which is:

		fAccessPerms - TRUE if we are going to edit a DACL, FALSE
		    if we are going to edit a SACL

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	If the ObjectType Name contains an accelerator, then it will
		be removed from the title of the dialog (i.e., "&File" will
		be changed to "File" for the dialog title).

    HISTORY:
	Johnl	27-Dec-1991	Created

********************************************************************/

DWORD
I_NTAclEditor(
	HWND			     Owner,
	HANDLE			     Instance,
	LPTSTR			     Server,
	PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
	PSED_APPLICATION_ACCESSES    ApplicationAccesses,
	LPTSTR			     ObjectName,
	PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
	ULONG_PTR			     CallbackContext,
	PSECURITY_DESCRIPTOR	     SecurityDescriptor,
        BOOLEAN                      CouldntReadAcl,
        BOOLEAN                      CantWriteAcl,
	LPDWORD 		     SEDStatusReturn,
        BOOLEAN                      fAccessPerms,
        DWORD                        Flags
	)
{
    APIERR err ;
    AUTO_CURSOR niftycursor ;

    if ( (ApplicationAccesses == NULL		) ||
	 (ApplySecurityCallbackRoutine == NULL	) ||
         (ObjectType->Revision != SED_REVISION1 ) ||
         (Flags != 0)  )
    {
	UIDEBUG(SZ("::AclEditor - ApplicationAccesses Ptr, SedCallBack or revision\n\r")) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return ERROR_INVALID_PARAMETER ;
    }

    //
    //  Kick 'em out if they can't read or write the resource
    //
    if ( CouldntReadAcl && CantWriteAcl )
    {
        err = fAccessPerms ? ERROR_ACCESS_DENIED : ERROR_PRIVILEGE_NOT_HELD ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
        return err ;
    }

#ifdef DEBUG
    {
	UIDEBUG(SZ("::AclEditor - Converting the following Security Descriptor:\n\r")) ;
	OS_SECURITY_DESCRIPTOR tmp( SecurityDescriptor ) ;
	UIASSERT( tmp.IsValid() ) ;
	tmp.DbgPrint() ;
    }
#endif

    /* Build the access masks from the array of permission mappings the
     * client passed in.
     */
    MASK_MAP AccessMap, NewObjectAccessMap, AuditAccessMap ;
    UIASSERT( sizeof( ACCESS_MASK ) == sizeof( ULONG ) ) ;
    BITFIELD bitAccess1( (ULONG) 0 ),
             bitAccess2( (ULONG) 0 ) ;
    BOOL fUseMnemonics = FALSE ;

    if ( ( err = AccessMap.QueryError() )	  ||
	 ( err = NewObjectAccessMap.QueryError()) ||
	 ( err = AuditAccessMap.QueryError())	  ||
	 ( err = bitAccess1.QueryError() )	   ||
	 ( err = bitAccess2.QueryError() )  )
    {
	UIDEBUG(SZ("::AclEditor - Mask map construction failure\n\r")) ;
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    for ( ULONG i = 0 ; (i < ApplicationAccesses->Count) && !err ; i++ )
    {
	bitAccess1 = (ULONG) ApplicationAccesses->AccessGroup[i].AccessMask1 ;
	bitAccess2 = (ULONG) ApplicationAccesses->AccessGroup[i].AccessMask2 ;
	UIASSERT( !bitAccess1.QueryError() && !bitAccess2.QueryError() ) ;
        UIASSERT( ApplicationAccesses->AccessGroup[i].PermissionTitle != NULL ) ;

        if ( ApplicationAccesses->AccessGroup[i].PermissionTitle == NULL )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }
        ALIAS_STR nlsPermName( ApplicationAccesses->AccessGroup[i].PermissionTitle ) ;
        ISTR istrStartMnem( nlsPermName ) ;

        //
        //  If the client doesn't specify any mnemonics, then we don't want
        //  to show "(All)", "(None)" etc.
        //
        if ( !fUseMnemonics &&
             nlsPermName.strchr( &istrStartMnem, MNEMONIC_START_CHAR ) )
        {
            fUseMnemonics = TRUE ;
        }


	if ( (fAccessPerms &&
	      ApplicationAccesses->AccessGroup[i].Type == SED_DESC_TYPE_AUDIT)||
	     (ApplicationAccesses->AccessGroup[i].AccessMask1 ==
					   ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED))
	{
	    DBGEOL("::AclEditor - Audit type for access permission or "
		   << " not specified access mask for container/object perms") ;
	    err = ERROR_INVALID_PARAMETER ;
	    continue ;
	}

	switch ( ApplicationAccesses->AccessGroup[i].Type )
	{
	case SED_DESC_TYPE_RESOURCE:
	    /* We don't allow this type of permission description if new
	     * objects are supported.
	     */
	    if ( ObjectType->AllowNewObjectPerms )
	    {
		UIASSERT(!SZ("Invalid object description")) ;
		err = ERROR_INVALID_PARAMETER ;
		break ;
	    }

	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_GENERAL ) ;
	    break ;

	case SED_DESC_TYPE_RESOURCE_SPECIAL:
	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_NEW_OBJECT_SPECIAL:
	    err = NewObjectAccessMap.Add( bitAccess1,
					  nlsPermName,
					  PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_AUDIT:
	    err = AuditAccessMap.Add( bitAccess1,
				      nlsPermName,
				      PERMTYPE_SPECIAL ) ;
	    break ;

	case SED_DESC_TYPE_CONT_AND_NEW_OBJECT:
	    err = AccessMap.Add( bitAccess1, nlsPermName, PERMTYPE_GENERAL ) ;
	    if ( !err &&
		 ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED != (ULONG) bitAccess2 )
	    {
		err = NewObjectAccessMap.Add( bitAccess2,
					      nlsPermName,
					      PERMTYPE_GENERAL ) ;
	    }
	    break ;

	default:
	    UIASSERT(!SZ("::AclEditor - Bad permission description")) ;
	    err = ERROR_INVALID_PARAMETER ;
	}
    }


    if ( err )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err;
    }

    NT_ACL_TO_PERM_CONVERTER ntaclconv(
			  (const TCHAR *) Server,
			  (const TCHAR *) ObjectName,
			  fAccessPerms ? &AccessMap : NULL,
			  (fAccessPerms && ObjectType->AllowNewObjectPerms?
				  &NewObjectAccessMap : NULL),
			  !fAccessPerms ? &AuditAccessMap : NULL,
			  ObjectType->IsContainer,
			  ObjectType->AllowNewObjectPerms,
			  SecurityDescriptor,
                          ObjectType->GenericMapping,
                          ObjectType->AllowNewObjectPerms ?
                              ObjectType->GenericMappingNewObjects :
                              ObjectType->GenericMapping,
			  ObjectType->MapSpecificPermsToGeneric,
                          CouldntReadAcl,
                          CantWriteAcl,
			  ApplySecurityCallbackRoutine,
			  CallbackContext,
                          Instance,
                          SEDStatusReturn,
                          fUseMnemonics  ) ;

    /* We construct nlsObjectType using an NLS_STR (as opposed to an ALIAS_STR)
     * because nlsObjectType might be NULL.  We need to insert the correct
     * object tile into the dialog's title (i.e., "NT Directory Permissions").
     */
    NLS_STR	 nlsObjectType( (const TCHAR *) ObjectType->ObjectTypeName ) ;
    RESOURCE_STR nlsDialogTitle( fAccessPerms ? IDS_NT_OBJECT_PERMISSIONS_TITLE:
						IDS_NT_OBJECT_AUDITS_TITLE  ) ;

    if ( (err = ntaclconv.QueryError())      ||
	 (err = nlsDialogTitle.QueryError()) ||
	 (err = nlsObjectType.QueryError())  ||
	 (err = nlsDialogTitle.InsertParams( nlsObjectType ))  )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
	return err ;
    }

    /* Watch for any "(&?)" accelerators in the object type and remove them if
     * found (we don't want the ampersand to show up in the dialog title box).
     * In Japan, accelerators format is "(&?)".
	 */
    ISTR istrAccelStart( nlsDialogTitle ) ;
    if (   NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
        && nlsDialogTitle.strchr( &istrAccelStart, TCH('(') ))
    {
	/* We found an "(", if next is not "&", then ignore it
	 */
	ISTR istrAccelNext( istrAccelStart ) ;
	if ( nlsDialogTitle.QueryChar( ++istrAccelNext ) == TCH('&'))
	{
	    /* We found an "&", if it is doubled, then ignore it, else remove these
	     */
	    if ( nlsDialogTitle.QueryChar( ++istrAccelNext ) != TCH('&'))
	    {
	    	/* we don't want "(&?) " (include space)
	    	 */
	    	istrAccelNext += 3 ;
	        nlsDialogTitle.DelSubStr( istrAccelStart, istrAccelNext ) ;
	    }
	}
    }
    /* Watch for any "&" accelerators in the object type and remove them if
     * found (we don't want the ampersand to show up in the dialog title box).
     */
    else if (   !NETUI_IsDBCS() /* #2894 22-Oct-93 v-katsuy */
             && nlsDialogTitle.strchr( &istrAccelStart, TCH('&') ))
    {
	/* We found an "&", if it is doubled, then ignore it, else remove it
	 */
	ISTR istrAmpersand( istrAccelStart ) ;
	if ( nlsDialogTitle.QueryChar( ++istrAmpersand ) != TCH('&'))
	{
	    nlsDialogTitle.DelSubStr( istrAccelStart, istrAmpersand ) ;
	}
    }

    err = I_GenericSecurityEditor(
	    Owner,
	    &ntaclconv,
	    fAccessPerms ? SED_ACCESSES : SED_AUDITS,
	    TRUE,
	    ObjectType->IsContainer,
	    ObjectType->AllowNewObjectPerms,
	    nlsDialogTitle,
	    ObjectType->ObjectTypeName,
	    ObjectName,
	    ObjectType->SpecialObjectAccessTitle,
	    ApplicationAccesses->DefaultPermName,
	    ObjectType->HelpInfo->pszHelpFileName,
            ObjectType->HelpInfo->aulHelpContext,
	    ObjectType->SpecialNewObjectAccessTitle,
            ObjectType->ApplyToSubContainerTitle,
            ObjectType->ApplyToObjectsTitle,
            NULL,
	    ObjectType->ApplyToSubContainerConfirmation ) ;

    if ( err )
    {
        *SEDStatusReturn = SED_STATUS_FAILED_TO_MODIFY ;
    }

    return err ;
}


/*******************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT::TAKE_OWNERSHIP_WITH_CALLOUT

    SYNOPSIS:	Simply constructor for ownership with callback dialog

    ENTRY:	ulCallbackContext - Callback context to be passed to the
		    callback function
		pfuncApplySecurityCallback - Pointer to function to apply
		    the new owner security descriptor to.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

********************************************************************/

TAKE_OWNERSHIP_WITH_CALLOUT::TAKE_OWNERSHIP_WITH_CALLOUT(
		    HWND	  hwndParent,
		    HANDLE	  hInstance,
		    const TCHAR * pszServer,
		    UINT	  uiCount,
		    const TCHAR * pchResourceType,
		    const TCHAR * pchResourceName,
		    PSECURITY_DESCRIPTOR psecdesc,
		    ULONG_PTR 	 ulCallbackContext,
		    PSED_FUNC_APPLY_SEC_CALLBACK pfuncApplySecurityCallback,
                    PSED_HELP_INFO psedhelpinfo
			   )
    : TAKE_OWNERSHIP_DLG( MAKEINTRESOURCE(IDD_SED_TAKE_OWNER),
			  hwndParent,
			  pszServer,
			  uiCount,
			  pchResourceType,
			  pchResourceName,
			  psecdesc,
                          psedhelpinfo ),
      _pfuncApplySecurityCallbackRoutine( pfuncApplySecurityCallback ),
      _ulCallbackContext		( ulCallbackContext ),
      _dwStatus 			( SED_STATUS_NOT_MODIFIED ),
      _hwndParent			( hwndParent ),
      _hInstance			( hInstance )
{
    if ( QueryError() )
	return ;

    if ( pfuncApplySecurityCallback == NULL )
    {
	ReportError( ERROR_INVALID_PARAMETER ) ;
	return ;
    }
}

/*******************************************************************

    NAME:	TAKE_OWNERSHIP_WITH_CALLOUT::OnTakeOwnership

    SYNOPSIS:	Simply calls the function callback member with the
		passed security descriptor.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	13-Feb-1992	Created

********************************************************************/

APIERR TAKE_OWNERSHIP_WITH_CALLOUT::OnTakeOwnership(
			  const OS_SECURITY_DESCRIPTOR & ossecdescNewOwner )
{
    APIERR err = _pfuncApplySecurityCallbackRoutine(
		   QueryHwnd(),
		   _hInstance,
		   _ulCallbackContext,
		   (PSECURITY_DESCRIPTOR) ossecdescNewOwner,
		   NULL,
		   FALSE,
		   FALSE,
		   &_dwStatus ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\h\errornum.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*

    ErrorNum.h - Defines base manifests for error numbers and string IDs


    FILE HISTORY:
	Johnl	15-Apr-1992	Created


*/

#ifndef _ERRORNUM_H_
#define _ERRORNUM_H_

#define










#endif // _ERRORNUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    HelpNums.h
    Help context context codes


    FILE HISTORY:
    Johnl   1/5/91	Created

*/

/*
 * Dialog Help Contexts
 */

/*
 * Error Message Help 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\aappx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    aappx.cxx
    This file contains the class definitions for the ADMIN_APP extension
    manager interface object.


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created.

*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <adminapp.hxx>



//
//  AAPP_MENU_EXT methods.
//

/*******************************************************************

    NAME:       AAPP_MENU_EXT :: AAPP_MENU_EXT

    SYNOPSIS:   AAPP_MENU_EXT class constructor.

    ENTRY:      pszDllName              - Name of this extension's DLL.

                dwDelta                 - Menu ID delta for this extension.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     21-Oct-1992     Created.

********************************************************************/
AAPP_MENU_EXT :: AAPP_MENU_EXT( const TCHAR * pszDllName,
                                DWORD         dwDelta )
  : UI_MENU_EXT( pszDllName, dwDelta ),
    _nlsHelpFileName()
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "AAPP_MENU_EXT failed to construct" );
        return;
    }

    if( !_nlsHelpFileName )
    {
        ReportError( _nlsHelpFileName.QueryError() );
        return;
    }

}   // AAPP_MENU_EXT :: AAPP_MENU_EXT


/*******************************************************************

    NAME:       AAPP_MENU_EXT :: ~AAPP_MENU_EXT

    SYNOPSIS:   AAPP_MENU_EXT class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     21-Oct-1992     Created.

********************************************************************/
AAPP_MENU_EXT :: ~AAPP_MENU_EXT( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // AAPP_MENU_EXT :: ~AAPP_MENU_EXT



//
//  AAPP_EXT_MGR_IF methods.
//

/*******************************************************************

    NAME:       AAPP_EXT_MGR_IF :: AAPP_EXT_MGR_IF

    SYNOPSIS:   AAPP_EXT_MGR_IF class constructor.

    ENTRY:      paapp                   - Points to the "owning" ADMIN_APP.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
AAPP_EXT_MGR_IF :: AAPP_EXT_MGR_IF( ADMIN_APP * paapp )
  : UI_EXT_MGR_IF(),
    _paapp( paapp )
{
    UIASSERT( paapp != NULL );
    UIASSERT( paapp->QueryError() == NERR_Success );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "AAPP_EXT_MGR_IF failed to construct" );
        return;
    }

}   // AAPP_EXT_MGR_IF :: AAPP_EXT_MGR_IF


/*******************************************************************

    NAME:       AAPP_EXT_MGR_IF :: ~AAPP_EXT_MGR_IF

    SYNOPSIS:   AAPP_EXT_MGR_IF class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
AAPP_EXT_MGR_IF :: ~AAPP_EXT_MGR_IF( VOID )
{
    _paapp = NULL;

}   // AAPP_EXT_MGR_IF :: ~AAPP_EXT_MGR_IF


/*******************************************************************

    NAME:       AAPP_EXT_MGR_IF :: LoadExtension

    SYNOPSIS:   Loads an extension.

    ENTRY:      pszExtensionDll         - The name of the extension DLL.

                dwDelta                 - The menu/control ID delta for
                                          the extension.

    RETURNS:    UI_EXT *                - The new extension object.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT * AAPP_EXT_MGR_IF :: LoadExtension( const TCHAR * pszExtensionDll,
                                           DWORD         dwDelta )
{
    UIASSERT( _paapp != NULL );

    UI_EXT * pExt = _paapp->LoadMenuExtension( pszExtensionDll,
                                               dwDelta );

    return pExt;

}   // AAPP_EXT_MGR_IF :: LoadExtension


/*******************************************************************

    NAME:       AAPP_EXT_MGR_IF :: GetExtensionList

    SYNOPSIS:   Returns the list of potential extension DLLs.

    RETURNS:    STRLIST *               - The list of extension DLLs.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
STRLIST * AAPP_EXT_MGR_IF :: GetExtensionList( VOID )
{
    UIASSERT( _paapp != NULL );

    STRLIST * psl = _paapp->GetMenuExtensionList();

    return psl;

}   // AAPP_EXT_MGR_IF :: GetExtensionList


/*******************************************************************

    NAME:       AAPP_EXT_MGR_IF :: ActivateExtension

    SYNOPSIS:   Responsible for activating the given extension.  For
                AAPP extensions, also invokes help if appropriate.

    ENTRY:      pExt                    - Actually an AAPP_MENU_EXT *.

                dwId                    - Menu ID to get activated.

    HISTORY:
        KeithMo     21-Oct-1992     Created.

********************************************************************/
VOID AAPP_EXT_MGR_IF :: ActivateExtension( HWND hwndParent,
                                           UI_EXT * pExt,
                                           DWORD    dwId )
{
    UIASSERT( pExt != NULL );
    UIASSERT( _paapp != NULL );

    if( dwId >= OMID_EXT_HELP )
    {
        //
        //  Menu IDs >= OMID_EXT_HELP are actually context sensitive
        //  help requests.
        //

        _paapp->ActivateHelp( ((AAPP_MENU_EXT *)pExt)->QueryHelpFileName(),
                              HELP_CONTEXT,
                              (DWORD_PTR)(dwId - OMID_EXT_HELP) );
    }
    else
    if( dwId == VIDM_HELP_ON_EXT )
    {
        //
        //  This is not an activation, it is a cry for help.
        //

        _paapp->ActivateHelp( ((AAPP_MENU_EXT *)pExt)->QueryHelpFileName(),
                              HELP_INDEX,
                              0 );
    }
    else
    {
        //
        //  Menu IDs > 0 are "real" menu IDs.  Activate the
        //  extension.
        //

        pExt->Activate( hwndParent, dwId );
    }

}   // AAPP_EXT_MGR_IF :: ActivateExtension
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\acledit\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    HelpNums.h
    Help context context codes


    FILE HISTORY:
    Johnl	15-Apr-1992	Created


*/

/*
 * Take Ownership dialog help
 */
#define HC_TAKEOWNERSHIP_DIALOG 	4201

/*
 * Security dialogs
 */
#define HC_SED_USER_BROWSER_DIALOG      4300  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_LOCALGROUP  4301  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_GLOBALGROUP 4302  // NT File/Dir user browser dialog
#define HC_SED_USER_BROWSER_FINDUSER    4303  // NT File/Dir user browser dialog

#define HC_SED_LANMAN_ADD_USER_DIALOG   4311  // LM Add user dialog

#define HC_SED_NT_FILE_PERMS_DLG        4312  // Main NT File Perm dialog
#define HC_SED_NT_DIR_PERMS_DLG         4313  // Main NT Directory perm dialog
#define HC_SED_NT_SPECIAL_FILES_FM      4314
#define HC_SED_NT_SPECIAL_DIRS_FM       4315
#define HC_SED_NT_SPECIAL_NEW_FILES_FM  4316

#define HC_SED_NT_FILE_AUDITS_DLG       4317  // Main NT File Audits dialog
#define HC_SED_NT_DIR_AUDITS_DLG        4318  // Main NT Directory Audits dialog

#define HC_SED_LM_FILE_PERMS_DLG        4319  // Main LM File Perm dialog
#define HC_SED_LM_DIR_PERMS_DLG         4320  // Main LM Directory perm dialog
#define HC_SED_LM_SPECIAL_FILES_FM      4321
#define HC_SED_LM_SPECIAL_DIRS_FM       4322

#define HC_SED_LM_FILE_AUDITS_DLG       4323  // Main LM File Audits dialog
#define HC_SED_LM_DIR_AUDITS_DLG        4324  // Main LM Directory Audits dialog

#define HC_SED_USER_BROWSER_AUDIT_DLG    4325
#define HC_SED_USER_BR_AUDIT_LOCALGROUP  4326  // NT File/Dir user browser dialog
#define HC_SED_USER_BR_AUDIT_GLOBALGROUP 4327  // NT File/Dir user browser dialog
#define HC_SED_USER_BR_AUDIT_FINDUSER    4328  // NT File/Dir user browser dialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\h\adminapp.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    Adminapp.h

    Resource numbers for class ADMIN_APP.


    FILE HISTORY:
        JonN    02-Aug-1991     Split from adminapp.hxx
        rustanl 13-Aug-1991     Added propdlg string manifests
        rustanl 04-Sep-1991     Removed IDM_FIND
        Yi-HsinS27-Dec-1991     Use IDS_UI_ADMIN_BASE in uimsg.h
        JonN    20-Feb-1992     Moved IDM_NEWGROUP to User Manager
        Yi-HsinS21-Feb-1992     Added IDS_LOCAL_MACHINE, IDS_ADMIN_DIFF_SERV,
                                IDS_ADMIN_DIFF_DOM
        JonN    25-Aug-1992     Merged DisplayError() into MsgPopup()
        KeithMo 19-Oct-1992     Added support for application extensions.

*/

#ifndef _ADMINAPP_H_
#define _ADMINAPP_H_

#include <uimsg.h>

/* Common Menu manifests.  Admin apps must use these in their menu resource
 * file.
 */
#define IDM_ADMINAPP_BASE                   5050

#define IDM_NEWOBJECT                       (IDM_ADMINAPP_BASE+0)
#define IDM_PROPERTIES                      (IDM_ADMINAPP_BASE+2)
#define IDM_COPY                            (IDM_ADMINAPP_BASE+3)
#define IDM_DELETE                          (IDM_ADMINAPP_BASE+4)
#define IDM_EXIT                            (IDM_ADMINAPP_BASE+5)

#define IDM_SETFOCUS                        (IDM_ADMINAPP_BASE+6)

#define IDM_CONFIRMATION                    (IDM_ADMINAPP_BASE+8)
#define IDM_SAVE_SETTINGS_ON_EXIT           (IDM_ADMINAPP_BASE+9)
#define IDM_REFRESH                         (IDM_ADMINAPP_BASE+10)
#define IDM_REFRESH_INTERVAL                (IDM_ADMINAPP_BASE+11)
#define IDM_RAS_MODE                        (IDM_ADMINAPP_BASE+12)
#define IDM_FONT_PICK                       (IDM_ADMINAPP_BASE+13)

#define IDM_HELP_CONTENTS                   (IDM_ADMINAPP_BASE+20)
#define IDM_HELP_SEARCH                     (IDM_ADMINAPP_BASE+21)
#define IDM_HELP_HOWTOUSE                   (IDM_ADMINAPP_BASE+22)
#define IDM_HELP_KEYBSHORTCUTS              (IDM_ADMINAPP_BASE+23)

#define IDM_ABOUT                           (IDM_ADMINAPP_BASE+24)

#define IDM_ADMINAPP_LAST                   (IDM_ADMINAPP_BASE+99)

//
//  This message is posted to the ADMIN_APP whenever the [F1] key
//  is pressed while a menu is dropped down.  This allows the
//  app to invoke help for the selected menu item.
//
//  CODEWORK:  Should we be using RegisterWindowMessage for this?
//

#define WM_MENU_ITEM_HELP                   (WM_USER+1213)

//
//  NOTE:  Admin apps should *NEVER* use menu IDs greater than
//  IDM_AAPPX_BASE.  All menu IDs above this value are reserved
//  for app extensions.
//

#define IDM_AAPPX_BASE                      (IDM_ADMINAPP_BASE+10000)

//
//  These VIDM_* values are "virtual menu IDs".  These are sent
//  to extensions as activation notifications.  Values < 100 are
//  reserved for use by the extensions themselves.
//

#define VIDM_ADMINAPP_BASE                  100
#define VIDM_ADMINAPP_LAST                  (VIDM_ADMINAPP_BASE + 99)

#define VIDM_APP_BASE                       (VIDM_ADMINAPP_BASE + 100)
#define VIDM_APP_LAST                       (VIDM_ADMINAPP_BASE + 399)

//
//  This offset is applied to the extension's menu IDs when context
//  sensitive help is requested for one of the extension's menu items.
//

#define OMID_EXT_HELP                       500

//
//  IDM_AAPPX_DELTA is the "inter-delta offset" for extension
//  menu IDs.
//

#define IDM_AAPPX_DELTA                     1000

//
//  This virtual menu ID is sent to the extension when "Help on
//  Extension" is requested.
//

#define VIDM_HELP_ON_EXT                    (VIDM_ADMINAPP_BASE)

/* Admin app. IERR_ manifests:
 */

#define IERR_ADMINAPP_BASE              (IDS_UI_ADMIN_BASE)

#define IERR_USERQUIT                   (IERR_ADMINAPP_BASE+1)
#define IERR_NO_COMMAND_LINE            (IERR_ADMINAPP_BASE+2)
#define IERR_INVALID_COMMAND_LINE       (IERR_ADMINAPP_BASE+3)
#define IERR_CANCEL_NO_ERROR            (IERR_ADMINAPP_BASE+4)

#define IERR_ADMINAPP_LAST              (IERR_ADMINAPP_BASE+99)

/* Admin app. IDS_ manifests:
 */
#define IDS_ADMINAPP_BASE               (IERR_ADMINAPP_LAST+1)

#define IDS_OBJECTS_IN_DOMAIN           (IDS_ADMINAPP_BASE+0)
#define IDS_OBJECTS_ON_SERVER           (IDS_ADMINAPP_BASE+1)

#define IDS_ADMIN_DIFF_SERVDOM          (IDS_ADMINAPP_BASE+2)
#define IDS_ADMIN_DIFF_SERV             (IDS_ADMINAPP_BASE+3)
#define IDS_ADMIN_DIFF_DOM              (IDS_ADMINAPP_BASE+4)

#define IDS_LANMAN                      (IDS_ADMINAPP_BASE+5)

#ifndef WIN32
#define IDS_LANMAN_DRV                  (IDS_ADMINAPP_BASE+6)
#define IERR_LANMAN_DRV_NOT_LOADED      (IDS_ADMINAPP_BASE+7)
#define IERR_OTHER_LANMAN_DRV_LOAD_ERR  (IDS_ADMINAPP_BASE+8)
#endif // !WIN32

#define IDS_PROPDLG_PB_Close            (IDS_ADMINAPP_BASE+12)

#define IDS_NO_FOCUS_QUIT_APP           (IDS_ADMINAPP_BASE+13)

#define IDS_LOCAL_MACHINE               (IDS_ADMINAPP_BASE+14)

#define IDS_FAST_SWITCH                 (IDS_ADMINAPP_BASE+16)
#define IDS_SLOW_SWITCH                 (IDS_ADMINAPP_BASE+17)

#define IDS_ADMINAPP_LAST               (IDS_ADMINAPP_BASE+99)

//
//  This is the resource ID for the menu ID to help context
//  lookup table.
//

#define IDHC_MENU_TO_HELP               19900

typedef INT (*PF_ShellAboutA) (
    HWND   hWnd,
    LPCSTR szApp,
    LPCSTR szOtherStuff,
    HICON  hIcon);

typedef INT (*PF_ShellAboutW) (
    HWND   hWnd,
    LPCWSTR szApp,
    LPCWSTR szOtherStuff,
    HICON  hIcon);

#ifndef UNICODE
#define PF_ShellAbout PF_ShellAboutA
#define SHELLABOUT_NAME "ShellAboutA"
#else
#define PF_ShellAbout PF_ShellAboutW
#define SHELLABOUT_NAME "ShellAboutW"
#endif

#define SHELL32_DLL_NAME SZ("SHELL32.DLL")

#endif //_ADMINAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\adminper.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    adminper.cxx
    ADMIN_PERFORMER and LOC_ADMIN_PERFORMER class



    FILE HISTORY:
        o-SimoP     09-Aug-1991     Created
        o-SimoP     20-Aug-1991     CR changes, attended by ChuckC,
                                    ErichCh, RustanL, JonN and me
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <adminlb.hxx>
#include <asel.hxx>

#include <propdlg.hxx>
#include <adminper.hxx>


/*******************************************************************

    NAME:       ADMIN_PERFORMER::ADMIN_PERFORMER

    SYNOPSIS:   Constructor for ADMIN_PERFORMER

    ENTRY:      powin -         pointer to owner window

                adminsel  -     ADMIN_SELECTION reference, selection
                                of groups or users. It is assumed that
                                the object should not be changed during
                                the lifetime of this object.

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

ADMIN_PERFORMER::ADMIN_PERFORMER(
        const OWNER_WINDOW    * powin,
        const ADMIN_SELECTION & adminsel )
    : PERFORMER( powin ),
      _adminsel( adminsel )
{
    if( QueryError() != NERR_Success )
        return;

    UIASSERT( adminsel.QueryError() == NERR_Success );
}


/*******************************************************************

    NAME:       ADMIN_PERFORMER::~ADMIN_PERFORMER

    SYNOPSIS:   Destructor for ADMIN_PERFORMER

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

ADMIN_PERFORMER::~ADMIN_PERFORMER()
{
    ;
}


/*******************************************************************

    NAME:       ADMIN_PERFORMER::QueryObjectCount

    SYNOPSIS:   Returns the number of items in ADMIN_SELECTION that was
                passed in to constructor

    RETURNS:    the number of items in ADMIN_SELECTION that was
                passed in to constructor

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

UINT ADMIN_PERFORMER::QueryObjectCount() const
{
    return _adminsel.QueryCount();
}


/*******************************************************************

    NAME:       ADMIN_PERFORMER::QueryObjectName

    SYNOPSIS:   Returns pointer to the name of object

    RETURNS:    pointer to the name of object

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

const TCHAR * ADMIN_PERFORMER::QueryObjectName( UINT iObject ) const
{
    return _adminsel.QueryItemName( iObject );
}


/*******************************************************************

    NAME:       ADMIN_PERFORMER::QueryObjectItem

    SYNOPSIS:   Returns pointer to the LBI of object

    RETURNS:    pointer to the LBI of object

    HISTORY:
        Thomaspa     10-Apr-1992     Created

********************************************************************/

const ADMIN_LBI * ADMIN_PERFORMER::QueryObjectItem( UINT iObject ) const
{
    return _adminsel.QueryItem( iObject );
}


/*******************************************************************

    NAME:       LOC_ADMIN_PERFORMER::LOC_ADMIN_PERFORMER

    SYNOPSIS:   Constructor for LOC_ADMIN_PERFORMER

    ENTRY:      powin -         pointer to owner window

                adminsel  -     ADMIN_SELECTION reference, selection
                                of groups or users. It is assumed that
                                the object should not be changed during
                                the lifetime of this object.

                loc   -         LOCATION reference, current focus.
                                It is assumed that the object should
                                not be changed during the lifetime of
                                this object.

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

LOC_ADMIN_PERFORMER::LOC_ADMIN_PERFORMER(
        const OWNER_WINDOW    * powin,
        const ADMIN_SELECTION & adminsel,
        const LOCATION        & loc )
    : ADMIN_PERFORMER( powin, adminsel ),
      _loc( loc )
{

    if( QueryError() != NERR_Success )
        return;

    UIASSERT( _loc.QueryError() == NERR_Success );
}


/*******************************************************************

    NAME:       LOC_ADMIN_PERFORMER::~LOC_ADMIN_PERFORMER

    SYNOPSIS:   Destructor for LOC_ADMIN_PERFORMER

    HISTORY:
        o-SimoP     09-Aug-1991     Created

********************************************************************/

LOC_ADMIN_PERFORMER::~LOC_ADMIN_PERFORMER()
{
    ;
}


/*******************************************************************

    NAME:       LOC_ADMIN_PERFORMER::QueryLocation

    SYNOPSIS:   return the refrence LOCATION object

    RETURNS:    reference to LOCATION obj that was passed to constructor

    HISTORY:
        o-SimoP     13-Aug-1991     Created

********************************************************************/

const LOCATION & LOC_ADMIN_PERFORMER::QueryLocation() const
{
    return _loc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\adminapp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    AdminApp.cxx
    This file contains the base methods for the ADMIN_APP class.

    FILE HISTORY:
        Johnl       10-May-1991 Created
        kevinl      12-Aug-1991 Added Refresh
        kevinl      04-Sep-1991 Code Rev Changes: JonN, RustanL, KeithMo,
                                                  DavidHov, ChuckC
        rustanl     11-Sep-1991 Lots of small features
        kevinl      17-Sep-1991 Remove old timer info.
        jonn        14-Oct-1991 Installed refresh lockcount
        terryk      18-Nov-1991 SET_FOCUS_DLG's parent class changed.
        jonn        26-Dec-1991 Remembers maximized/restored state
                                Added msRefreshInterval ctor parameter
        Yi-HsinS     6-Feb-1992 Added another parameter to ADMIN_APP,
                                indicating whether to select servers only,
                                domains only or both servers and domains
        jonn        20-Feb-1992 Moved OnNewGroupMenuSel to User Manager
        beng        31-Mar-1992 Removed wsprintf, much tracing
        beng        24-Apr-1992 Change APPLICATION command-line support
        beng        07-May-1992 Remove startup dialogs; use system about box
        Yi-HsinS    15-May-1992 Added OnStartUpSetFocusFailed()
        Yi-HsinS    27-May-1992 Make SetNetworkFocus virtual and added
                                W_SetNetworkFocus and IsDismissApp
        KeithMo     19-Oct-1992 Extension mechanism.
        CongpaY     10-Dec-1992 Dynamically link shell32.dll
        YiHsinS     31-Jan-1993 Added HandleFocusError
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETSERVER
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_MENU
#include <blt.hxx>

#include <lmowks.hxx>
#include <lmoloc.hxx>

#include <strnumer.hxx>

#include <dbgstr.hxx>

#include <adminapp.hxx>
#include <focusdlg.hxx>
#include <setfocus.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <getfname.hxx>
#include <slowcach.hxx>
#include <fontpick.hxx>

#if defined(WIN32)
extern "C"
{
    #include <commdlg.h>    // for HELPMSGSTRING
}
#endif


extern "C"
{
    #include <mnet.h>       // for IsSlowTransport
    #include <lmuidbcs.h>   // for NETUI_IsDBCS
}

//
//  CODEWORK!  This should probably be in NETLIB.H or something...
//

#ifdef UNICODE
#define TO_UPPER(x)     ((WCHAR)(::CharUpper((LPTSTR)x)))
#else   // !UNICODE
#error not implemented
#endif  // UNICODE


#if !defined(WIN32) // BUGBUG - should depend on NT, not Win32

extern "C"
{
    #include <wnintrn.h>

    typedef BOOL (FAR PASCAL * I_AUTOLOGON_PROC)( HWND,
                                                 const TCHAR *,
                                                 BOOL,
                                                 BOOL * );
}


//  This is the version of the Winnet driver that contains the
//  I_AutoLogon entry point.  This may change for new versions of
//  the product.  This driver is assumed to be loaded when the
//  AdminApp starts up.  If not, AdminApp will not start.

#define LANMAN_DRV_NAME         SZ("LANMAN30.DRV")

//  This is the name of the I_AutoLogon function.  It is not likely
//  to change in future versions, although it might.

#define I_AUTOLOGON_NAME        SZ("I_AutoLogon")

#endif // NT


//
//  This is the format of the menu ID to help context table.
//

extern "C"
{
    typedef struct
    {
        WORD mid;
        WORD hc;

    } MENUHCPAIR, * LPMENUHCTABLE;
}


/* The following are key names used to save settings in the ini file.
 */
#define AA_INIKEY_SAVE_SETTINGS         SZ("SaveSettings")
#define AA_INIKEY_CONFIRMATION          SZ("Confirmation")
#define AA_INIKEY_WINDOW                SZ("Window")

#define AA_INIKEY_FONT_FACENAME         SZ("FontFaceName")
#define AA_INIKEY_FONT_HEIGHT           SZ("FontHeight")
#define AA_INIKEY_FONT_WEIGHT           SZ("FontWeight")
#define AA_INIKEY_FONT_ITALIC           SZ("FontItalic")

// We need Charset for DBCS only
#define AA_INIKEY_FONT_CHARSET          SZ("FontCharSet")

#define AA_SHARED_SECTION               SZ("Shared Parameters")
#define AA_RAS_MODE                     SZ("RAS Mode")

//
//  Switch character.  Note that this must be ANSI, *not* UNICODE!
//

#define SWITCH_CHAR '/'


//
//  This is the maximum buffer size used when reading .ini keys
//  for the extension DLLs.
//

#define MAX_KEY_LIST_BUFFER_SIZE        4096    // TCHARs

/*
 *  These are the minimum and maximum sizes allowed for the font picker
 */
#ifdef FE_SB
#define FONTPICK_SIZE_MIN 9
#else
#define FONTPICK_SIZE_MIN 10
#endif

#define FONTPICK_SIZE_MAX 32


DEFINE_MI4_NEWBASE( ADMIN_APP, APPLICATION,
                               APP_WINDOW,
                               TIMER_CALLOUT,
                               ADMIN_INI );

extern "C"
{
    //
    //  This stub will become unnecessary when we move to C8.
    //
    LRESULT _EXPORT CALLBACK AdminappMsgFilterProc( INT nCode, WPARAM wParam, LPARAM lParam )
        { return ADMIN_APP::MsgFilterProc( nCode, wParam, lParam ); }
}


HWND  ADMIN_APP::_hWndMain = NULL;
HHOOK ADMIN_APP::_hMsgHook = NULL;


/*******************************************************************

    NAME:      ADMIN_APP::ADMIN_APP

    SYNOPSIS:  ADMIN_APP Constructor, does the following:

        Performs necessary global initialization

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl       10-May-1991 Created
        rustanl     28-Aug-1991 Multiply inherit from APPLICATION;
                                implemented menu accelerator support
        rustanl     12-Sep-1991 Multiply inherit from ADMIN_INI
        beng        23-Oct-1991 Win32 conversion
        JonN        26-Dec-1991 Keeps track of restored position/size
                                Added msRefreshInterval parameter
        beng        24-Apr-1992 Change APPLICATION cmdline support
        beng        07-May-1992 Remove startup dialog support;
                                use system about box
        beng        03-Aug-1992 Base class ctor changed
        KeithMo     21-Oct-1992 Added extension support.

********************************************************************/

ADMIN_APP::ADMIN_APP( HINSTANCE   hInstance,
                      INT      nCmdShow,
                      MSGID    IDS_AppName,
                      MSGID    IDS_ObjectName,
                      MSGID    IDS_WinIniSection,
                      MSGID    IDS_HelpFileName,
                      UINT     idMinR,
                      UINT     idMaxR,
                      UINT     idMinS,
                      UINT     idMaxS,
                      UINT     idMenu,
                      UINT     idAccel,
                      UINT     idIcon,
                      BOOL     fGetPDC,
                      ULONG    msRefreshInterval,
                      SELECTION_TYPE selType,
                      BOOL     fConfirmation,
                      ULONG    maskDomainSources,
                      ULONG    nSetFocusHelpContext,
                      ULONG    nSetFocusServerTypes,
                      MSGID    idsExtSection )
    :   APPLICATION( hInstance, nCmdShow, idMinR, idMaxR, idMinS, idMaxS ),
        APP_WINDOW( (const TCHAR *)NULL, idIcon, idMenu ),
        TIMER_CALLOUT(),
        ADMIN_INI(),
        _flocGetPDC            ( fGetPDC ),
        _timerRefresh          ( this, msRefreshInterval, FALSE),
                // Starts off disabled, see _uRefreshLockCount
        _paccel                ( NULL ),
        _menuitemSaveSettings  ( this, IDM_SAVE_SETTINGS_ON_EXIT ),
        _pmenuitemConfirmation ( NULL ),
        _pmenuitemRasMode      ( NULL ),
        _nlsAppName            ( MAX_ADMINAPP_NAME_LEN ),
        _nlsObjectName         ( MAX_ADMINAPP_OBJECTNAME_LEN ),
        _nlsWinIniSection      ( MAX_ADMINAPP_INISECTIONNAME_LEN ),
        _nlsHelpFileName       ( MAX_ADMINAPP_HELPFILENAME_LEN ),
        _nlsMenuMnemonics      (),
        _nSetFocusServerTypes  ( nSetFocusServerTypes ),
        // _uRefreshLockCount     ( 1 ),
                // Refresh starts out disabled exactly once, Run()ning
                // the ADMIN_APP will enable it.
        _xyposRestoredPosition ( 0, 0 ),
        _xydimRestoredSize     ( 0, 0 )
        // _fIsMinimized          ( FALSE ),
        // _fIsMinimized          ( FALSE ),
        // _maskDomainSources     ( maskDomainSources ),
        // _nSetFocusHelpContext  ( nSetFocusHelpContext ),
                // BUGBUG should be initialized here (heap space in CL.EXE)
{
    _fInCancelMode = FALSE;
    _hWndMain = QueryHwnd();
    _hMsgHook = NULL;
    _midSelected = 0;
    _flagsSelected = 0;
    _idIcon = idIcon;
    _pfontPicked = NULL;
    _plogfontPicked = NULL;
    _pmenuApp = NULL;
    _pExtMgr = NULL;
    _pExtMgrIf = NULL;
    _uRefreshLockCount = 1;
    _fIsMinimized = FALSE;
    _fIsMaximized = FALSE;
    _selType = selType;
    _maskDomainSources = maskDomainSources;
    _nSetFocusHelpContext = nSetFocusHelpContext;
    _msgHelpCommDlg = ::RegisterWindowMessage( (LPCWSTR) HELPMSGSTRING );

    UIASSERT( _maskDomainSources != 0 );

    TRACEEOL( "ADMIN_APP::ctor(): nCmdShow = " << nCmdShow );

    if ( QueryError() != NERR_Success )
       return;

    AUTO_CURSOR cursorHourGlass;

    APIERR err;
    if ( (err = _locFocus.QueryError()            ) ||
         (err = SetAcceleratorTable( idAccel )    ) ||
         (err = _menuitemSaveSettings.QueryError()) ||
         (err = _nlsAppName.QueryError()          ) ||
         (err = _nlsObjectName.QueryError()       ) ||
         (err = _nlsWinIniSection.QueryError()    ) ||
         (err = _nlsMenuMnemonics.QueryError()    ) ||
         (err = _nlsHelpFileName.QueryError()     ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Construct the POPUP_MENUs.
    //

    _pmenuApp  = new POPUP_MENU( this );

    err = ( _pmenuApp == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : _pmenuApp->QueryError();

    if( err == NERR_Success )
    {
        err = BuildMenuMnemonicList();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( fConfirmation )
    {
        _pmenuitemConfirmation = new MENUITEM( this, IDM_CONFIRMATION );
        if (  ( _pmenuitemConfirmation == NULL )
           || ( (err = _pmenuitemConfirmation->QueryError()) != NERR_Success )
           )
        {
            ReportError( err? err : ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    if ( MENUITEM::ItemExists( this, IDM_RAS_MODE ) )
    {
        _pmenuitemRasMode = new MENUITEM( this, IDM_RAS_MODE );
        if (  ( _pmenuitemRasMode == NULL )
           || ( (err = _pmenuitemRasMode->QueryError()) != NERR_Success )
           )
        {
            ReportError( err? err : ERROR_NOT_ENOUGH_MEMORY );
            return;
        }
    }

    /* Load all of the strings from the resource file
    ** CODEWORK - use RESOURCE_STR here
     */
    if ( (err = _nlsAppName.Load( IDS_AppName )            ) ||
         (err = _nlsObjectName.Load( IDS_ObjectName )      ) ||
         (err = _nlsWinIniSection.Load( IDS_WinIniSection )) ||
         (err = _nlsHelpFileName.Load( IDS_HelpFileName )  )    )
    {
        ReportError( err );
        return;
    }

    if( ( idsExtSection != 0 ) &&
        ( err = _nlsExtSection.Load( idsExtSection ) ) )
    {
        ReportError( err );
        return;
    }

    /* Set the ADMIN_INI app name.
     */
//fix kksuzuka: #1103
//Now, IDS_UMAPPNAME is used as Dialog caption, Shell about, and registry key.
//To disp Japanese in Caption or Shell about, we loclize it.
//But we can't use DBCS as registry key, so I make ADMIN_APP() using
// IDS_UMINISECTIONNAME as registry key.
    err = SetAppName( (NETUI_IsDBCS()) ? _nlsWinIniSection.QueryPch()
                                       : _nlsAppName.QueryPch() );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    /* Set the caption, in case something goes wrong during the load process
     */
    SetText( _nlsAppName );

    /* Set the caption for message popups
     */
    POPUP::SetCaption( IDS_AppName );

    /* Check ini file to see whether or not Confirmation and Save Settings
     * on Exit are to be checked.
     */
    INT nValue;

    if ( fConfirmation )
    {
        if ( Read( AA_INIKEY_CONFIRMATION, &nValue, 1 ) != NERR_Success )
            nValue = 1;
        _pmenuitemConfirmation->SetCheck( nValue != 0 );
    }

    /*
     *  Read information on the initial font
     */
    do // false loop
    {
        _plogfontPicked = new LOGFONT();
        if (_plogfontPicked == NULL)
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY );
            DBGEOL( "ADMIN_APP::ctor(): error allocating LOGFONT" );
            return;
        }
        ::memsetf( _plogfontPicked, 0, sizeof(LOGFONT) );

        NLS_STR nls;
        INT nHeight, nWeight, nItalic, nCharset;
#ifdef FE_SB
        CHARSETINFO csi;
        DWORD dw = ::GetACP();

        if (!::TranslateCharsetInfo((DWORD *)UIntToPtr(dw), &csi, TCI_SRCCODEPAGE))
            csi.ciCharset = ANSI_CHARSET;
#endif

        APIERR errTemp;

        if (   (errTemp = ( (NETUI_IsDBCS())
                               ? Read( AA_INIKEY_FONT_FACENAME,
                                       &nls ,
                                       TEXT("MS Shell Dlg"))
                               : Read( AA_INIKEY_FONT_FACENAME,
                                       &nls)))        != NERR_Success
            || (errTemp = nls.CopyTo( _plogfontPicked->lfFaceName,
                                      LF_FACESIZE*sizeof(TCHAR) ))
                                                        != NERR_Success
            || (errTemp = Read( AA_INIKEY_FONT_HEIGHT,
                                &nHeight,
#ifdef FE_SB // We use FONTPICK_SIZE_MIN as default font height.
                                (NETUI_IsDBCS() ?
                                    BLTPoints2LogUnits(FONTPICK_SIZE_MIN) : 0) ))
                                                        != NERR_Success
#else
                                0 )) != NERR_Success
#endif
            || (errTemp = Read( AA_INIKEY_FONT_WEIGHT,
                                &nWeight,
                                0 )) != NERR_Success
            || (errTemp = Read( AA_INIKEY_FONT_ITALIC,
                                &nItalic,
                                0 )) != NERR_Success
// DBCS: We need Charset
            || ( NETUI_IsDBCS() &&
                 (errTemp = Read( AA_INIKEY_FONT_CHARSET,
                                &nCharset,
                                csi.ciCharset )) != NERR_Success )
           )
        {
            DBGEOL( "Admin app: could not read font info " << errTemp );
            break;
        }
        else
        {
            _plogfontPicked->lfHeight = (nHeight > 0) ? -nHeight : 0;
            _plogfontPicked->lfWeight = (nWeight > 0) ?  nWeight : 0;
            _plogfontPicked->lfItalic = (nItalic)     ?  TRUE    : FALSE;
            if ( NETUI_IsDBCS() )
                _plogfontPicked->lfCharSet = (BYTE)nCharset;

            TRACEEOL(   "Admin app: read font face name \"" << nls
                     << "\", font height " << nHeight
                     << ", font weight " << nWeight
                     << ", font italic " << nItalic
                    );
        }

        _pfontPicked = new FONT( *_plogfontPicked );
        errTemp = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pfontPicked == NULL
            || (errTemp = _pfontPicked->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "ADMIN_APP::ctor: FONT::ctor error " << errTemp );
            delete _pfontPicked;
            _pfontPicked = NULL;
            break;
        }

        /*
         *  We cannot call OnFontPickChange here, since it is a virtual
         *  which is redefined in the derived classes, but we are still
         *  in the ctor.  Instead we delay this until Run().
         */

    } while (FALSE); // false loop

    if ( Read( AA_INIKEY_SAVE_SETTINGS, &nValue, 1 ) != NERR_Success )
        nValue = 1;
    _menuitemSaveSettings.SetCheck( nValue != 0 );

    /* Read the previous window size and position from the ini file, and
     * resize and reposition window accordingly.  If any error occurs,
     * leave window size and position alone.
     */
    {
        NLS_STR nls;
        if ( nls.QueryError() == NERR_Success &&
             Read( AA_INIKEY_WINDOW, &nls ) == NERR_Success )
        {
            STRLIST strlist( nls.QueryPch(), SZ(" \t,;") );
            // BUGBUG.  How is this checked for errors?  Through BASE?
            if ( strlist.QueryNumElem() == 5 )
            {
                INT an[ 5 ];
                ITER_STRLIST iterstrlist( strlist );
                const NLS_STR * pnls;
                INT i = 0;
                while ( ( pnls = iterstrlist.Next()) != NULL )
                {
                    //  First character must be numeric or a dash
                    ISTR istr( *pnls );
                    WCHAR wch = pnls->QueryChar( istr );
                    if ( wch != TCH('-') && ( wch < TCH('0') || wch > TCH('9') ))
                        break;      // bad ini line

                    an[ i ] = pnls->atoi();
                    i++;
                }

                if ( i == 5 )
                {
                    // ini line was good; now deal with the window

                    //
                    //  Before we start moving things around, sanity
                    //  check the window position & size.
                    //

                    if( ( an[2] > 0 ) &&                // width & height...
                        ( an[3] > 0 ) &&                // ...must be positive
                        ( ( an[0] + an[2] ) > 0 ) &&    // window must be...
                        ( ( an[1] + an[3] ) > 0 ) &&    // ...visible on screen
                        ( an[0] < ::GetSystemMetrics( SM_CXSCREEN ) ) &&
                        ( an[1] < ::GetSystemMetrics( SM_CYSCREEN ) ) )
                    {
                        //
                        //  CODEWORK:  Should we be using the Win 3.1
                        //  Get/SetWindowPlacement API?
                        //

                        SetPos( XYPOINT( an[ 0 ], an[ 1 ] ), FALSE );
                        SetSize( an[ 2 ], an[ 3 ], FALSE );

                        _fIsMaximized = an[4];
                    }
                }
#if defined(DEBUG)
                else
                {
                    DBGEOL( "Admin app: could not initialize window position" );
                }
#endif // DEBUG
            }
        }
    }

    //
    //  Read the RAS Mode flag -- delayed until ADMIN_APP::Run()
    //  so that the proper SetRasMode() virtual will be called.
    //
    //
    //  Hook the message filter so we can capture F1 in a menu.
    //

    _hMsgHook = ::SetWindowsHookEx( WH_MSGFILTER,
                                    (HOOKPROC)AdminappMsgFilterProc,
                                    NULL,
                                    ::GetCurrentThreadId() );
}


/*******************************************************************

    NAME:       ADMIN_APP::AutoLogon

    SYNOPSIS:   Checks if user is logged on.  If not, the user
                is asked to log on.

    EXIT:       If the function returns NERR_Success, the user is
                logged on.

    RETURNS:    An API error code, which is NERR_Success on success.
                Any other error code should cause the application
                to be terminated.
                If the error code is IERR_USERQUIT, the user decided
                to quit.  Then, no error message should be displayed,
                but the app should nevertheless terminate.

    NOTES:
        Under NT, this function does nothing.

    HISTORY:
        rustanl 24-Jun-1991 Created using LoadModule et al.
        beng    24-Oct-1991 Port to Win32, and then disabled for NT

********************************************************************/

APIERR ADMIN_APP::AutoLogon() const
{
#if defined(WIN32) // BUGBUG - should depend on NT, not Win32

    // Under NT, we're already logged onto the system.

    return NERR_Success;
#else
    static TCHAR * pszLanmanDrv = LANMAN_DRV_NAME;
    static TCHAR * pszI_AutoLogon = I_AUTOLOGON_NAME;

    // CODEWORK: roll all this DLL manipulation into a separate library.

    if ( ::GetModuleHandle( pszLanmanDrv ) == NULL )
    {
       //  Lanman.drv is not present
       return IERR_LANMAN_DRV_NOT_LOADED;
    }

    // Since Lanman.drv is already loaded, do a LoadModule to it.
    // We then know that this will not cause another call to its
    // LibEntry.
    // BUGBUG
    //
    // Note that LoadLibrary actually returns an instance handle,
    // not a module handle (as claimed in the 3.0 SDK).

    HMODULE hLanmanDrv = ::LoadLibrary( pszLanmanDrv );
#if defined(WIN32)
    if (hLanmanDrv == 0)
        return ::GetLastError();
#else
    if ( hLanmanDrv < (HANDLE)32 )
    {
       //  CODEWORK.  Map the error code now contained in hLanmanDrv
       //  to an API error code, and then return it.
       return IERR_OTHER_LANMAN_DRV_LOAD_ERR;
    }
#endif

    I_AUTOLOGON_PROC pfnI_AutoLogon = (I_AUTOLOGON_PROC )
                                     ::GetProcAddress( hLanmanDrv,
                                                       pszI_AutoLogon );
    if ( pfnI_AutoLogon == NULL )
    {
#if defined(WIN32)
        return ::GetLastError();
#else
        return IERR_OTHER_LANMAN_DRV_LOAD_ERR;
#endif
    }

    APIERR err;
    if ( (*pfnI_AutoLogon)( QueryHwnd(), _nlsAppName.QueryPch(), TRUE, NULL ))
       err = NERR_Success;
    else
       err = IERR_USERQUIT;

    ::FreeLibrary( hLanmanDrv );

    return err;
#endif // !WIN32
}


/*******************************************************************

    NAME:       ADMIN_APP::~ADMIN_APP

    SYNOPSIS:   Admin app. destructor, performs the following:
                    Attempts to save main window size in the .ini file
                    Attempts to save Confirmation option in the .ini file

    NOTES:      Save Settings on Exit is stored immediately after it is
                changed, so it's not saved from here.

    HISTORY:
       Johnl    13-May-1991     Created
       rustanl  12-Sep-1991     Save window size and confirmation in ini file
       JonN     26-Dec-1991     Stores restored position/size
       beng     31-Mar-1992     Removed wsprintf
       KeithMo  30-Jul-1992     Fixed problem with negative position.
       KeithMo  10-Sep-1992     Call REG_KEY::DestroyAccessPoints, just in case.
       KeithMo  17-Sep-1992     Used GetPlacement() to get screen position.
       DavidHov 20-Oct-1992     Removed call to REG_KEY::DestroyAccessPoints();
                                function now obsolete.

********************************************************************/

ADMIN_APP::~ADMIN_APP()
{
    if ( IsSavingSettingsOnExit())
    {
        //  Save restored Window size and position

        STACK_NLS_STR( nlsOut, 5*(CCH_INT+1) );
        ASSERT(!!nlsOut); // owner-alloc, "can't" fail

        //
        //  These will hold the window's restored position,
        //  restored size, and maximized flag.
        //

        INT x, y;
        INT width, height;
        INT maximized;

        //
        //  Get the current window placement.
        //

        WINDOWPLACEMENT placement;
        placement.length = sizeof(WINDOWPLACEMENT);

        APIERR err = GetPlacement( &placement );

        if( err == NERR_Success )
        {
            //
            //  Extract the info from the placement structure.
            //

            RECT rcTmp = placement.rcNormalPosition;

            x = (INT)rcTmp.left;
            y = (INT)rcTmp.top;

            width  = (INT)( rcTmp.right  - rcTmp.left );
            height = (INT)( rcTmp.bottom - rcTmp.top  );

            maximized = ( placement.showCmd == SW_SHOWMAXIMIZED ) ? 1 : 0;
        }
        else
        {
            //
            //  GetPlacement() failed, so we'll make an
            //  "educated guess" based on info we've
            //  accumulated during the life of the application.
            //

            x = _xyposRestoredPosition.QueryX();
            y = _xyposRestoredPosition.QueryY();

            width  = _xydimRestoredSize.QueryWidth();
            height = _xydimRestoredSize.QueryHeight();

            maximized = _fIsMaximized ? 1 : 0;
        }

        if( x < 0 )
        {
            nlsOut.AppendChar(TCH('-'));
            x = -x;
        }

        nlsOut.Append(DEC_STR(x));
        nlsOut.AppendChar(TCH(' '));

        if( y < 0 )
        {
            nlsOut.AppendChar(TCH('-'));
            y = -y;
        }

        nlsOut.Append(DEC_STR(y));
        nlsOut.AppendChar(TCH(' '));

        nlsOut.Append(DEC_STR(width));
        nlsOut.AppendChar(TCH(' '));
        nlsOut.Append(DEC_STR(height));
        nlsOut.AppendChar(TCH(' '));
        nlsOut.Append(DEC_STR(maximized));

        if ( Write( AA_INIKEY_WINDOW, nlsOut.QueryPch() ) != NERR_Success )
        {
            //  nothing else we could do
            DBGEOL( "ADMIN_APP dt:  Writing window size failed" );
        }

        //  Save Confirmation

        if ( _pmenuitemConfirmation != NULL )
        {
            if ( Write( AA_INIKEY_CONFIRMATION,
                      ( IsConfirmationOn() ? 1 : 0 )) != NERR_Success )
            {
               //  nothing else we could do
               DBGEOL( "ADMIN_APP dt:  Writing confirmation failed" );
            }
            delete _pmenuitemConfirmation;
            _pmenuitemConfirmation = NULL;
        }

        /*
         *  write information on the initial font
         */
        do // false loop
        {
            if (_plogfontPicked == NULL)
            {
                DBGEOL( "ADMIN_APP::dtor(): no LOGFONT" );
                break;
            }

            INT nHeight = _plogfontPicked->lfHeight;
            nHeight = (nHeight < 0) ? -nHeight : 0;
            INT nWeight = _plogfontPicked->lfWeight;
            nWeight = (nWeight > 0) ?  nWeight : 0;
            INT nItalic = _plogfontPicked->lfItalic;
            nItalic = (nItalic)     ?  TRUE    : FALSE;

            APIERR errTemp;
            if (   (errTemp = Write( AA_INIKEY_FONT_FACENAME,
                                     _plogfontPicked->lfFaceName ))
                                                            != NERR_Success
                || (errTemp = Write( AA_INIKEY_FONT_HEIGHT,
                                     nHeight )) != NERR_Success
                || (errTemp = Write( AA_INIKEY_FONT_WEIGHT,
                                     nWeight )) != NERR_Success
                || (errTemp = Write( AA_INIKEY_FONT_ITALIC,
                                     nItalic )) != NERR_Success
                || ( NETUI_IsDBCS() &&
                     (errTemp = Write( AA_INIKEY_FONT_CHARSET,
                                       _plogfontPicked->lfCharSet )) != NERR_Success )

               )
            {
                DBGEOL(   "Admin app: could not write font info "
                       << errTemp );
                break;
            }
            else
            {
                TRACEEOL(   "Admin app: wrote font face name \""
                         << _plogfontPicked->lfFaceName
                         << "\", font height "
                         << _plogfontPicked->lfHeight
                         << ", font weight "
                         << _plogfontPicked->lfWeight
                         << "\", font italic "
                         << _plogfontPicked->lfItalic
                        );
            }

        } while (FALSE); // false loop

        ADMIN_INI aini( AA_SHARED_SECTION );

        err = aini.QueryError();

        if( err == NERR_Success )
        {
            err = aini.Write( AA_RAS_MODE, InRasMode() ? 1 : 0 );
        }

        if( err != NERR_Success )
        {
            DBGEOL( "ADMIN_APP dt: Writing RAS Mode flag failed" );
        }

        //  Also, write out the Save Settings on Exit option, since this
        //  option would otherwise not be written out unless the option
        //  is changed.
        if ( Write( AA_INIKEY_SAVE_SETTINGS,
                    ( IsSavingSettingsOnExit() ? 1 : 0 )) != NERR_Success )
        {
            //  nothing else we could do
            DBGEOL( "ADMIN_APP dt:  Writing Save Settings on Exit failed" );
        }
    }

    delete _pmenuitemConfirmation;
    _pmenuitemConfirmation = NULL;
    delete _pmenuitemRasMode;
    _pmenuitemRasMode = NULL;

    delete _pfontPicked;
    _pfontPicked = NULL;
    delete _plogfontPicked;
    _plogfontPicked = NULL;

    //
    //  Nuke the extensions.  Note that we always delete
    //  the extension manager *before* deleting the interface.
    //

    delete _pExtMgr;
    _pExtMgr = NULL;
    delete _pExtMgrIf;
    _pExtMgrIf = NULL;

    //
    //  Kill the POPUP_MENU objects.
    //

    delete _pmenuApp;
    _pmenuApp = NULL;

    //
    //  Unhook our message filter.
    //

    if( _hMsgHook != NULL )
    {
        ::UnhookWindowsHookEx( _hMsgHook );
        _hMsgHook = NULL;
    }

    //
    //  Notify WinHelp if we activated help.
    //

    ::WinHelp( QueryHwnd(),
               (TCHAR *)_nlsHelpFileName.QueryPch(),
               (UINT) HELP_QUIT,
               0 );

#if defined(DEBUG)
    if (   !( _uRefreshLockCount==0 && !_fIsMinimized )
        && !( _uRefreshLockCount==1 &&  _fIsMinimized ) )
    {
        DBGEOL( "Lock count not cleared!" );
        DBGEOL( "Current lock count is " << (LONG)_uRefreshLockCount );
    }
#endif // DEBUG

    delete _paccel;

}


/*******************************************************************

    NAME:       ADMIN_APP::MsgFilterProc

    SYNOPSIS:   This static method gets called to filter messages
                generated for dialogs, menus, and a few other less
                useful times.

    ENTRY:      nCode                   - One of the MSGF_* values.

                wParam                  - Should be zero.

                lParam                  - Actually points to a MSG structure.

    RETURNS:    LONG                    - ~0 if message was handled,
                                           0 if it wasn't.

    HISTORY:
        KeithMo     23-Oct-1992     Created.

********************************************************************/
LRESULT ADMIN_APP::MsgFilterProc( INT nCode, WPARAM wParam, LPARAM lParam )
{
    if( nCode == MSGF_MENU )
    {
        const MSG * pMsg = (MSG *)lParam;

        //
        //  It's a menu message.  If the user pressed [F1] inside
        //  a menu, then post ourselves a WM_MENU_ITEM_HELP message.
        //

        if( ( pMsg->message == WM_KEYDOWN ) && ( pMsg->wParam == VK_F1 ) )
        {
            ::PostMessage( _hWndMain, WM_MENU_ITEM_HELP, 0, 0 );
        }
    }

    return ::CallNextHookEx( _hMsgHook, nCode, wParam, lParam );

}   // ADMIN_APP::MsgFilterProc


/*******************************************************************

    NAME:       ADMIN_APP::ParseCommandLine

    SYNOPSIS:   Gets the server/domain name the user wants to administer
                from the command line.

    ENTRY:      pnlsServDom - pointer to receiver string

    EXIT:       pnlsServDom contains the supposed server or domain

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
       Johnl    10-May-1991 Created
       rustanl  12-Sep-1991 No error return for no command line
       beng     23-Oct-1991 Win32 conversion
       beng     24-Apr-1992 Uses APPLICATION cmdline member fcns; Unicode fix
       KeithMo  02-Feb-1993 Parse fast/slow mode control switches.
       JonN     25-Mar-1993 Slow mode detection

********************************************************************/

APIERR ADMIN_APP::ParseCommandLine( NLS_STR * pnlsServDom,
                                    BOOL * pfSlowModeFlag )
{
    ASSERT( pnlsServDom != NULL );

    INT          cArgs = QueryArgc();
    INT          iArg  = 1;
    RESOURCE_STR nlsFast( IDS_FAST_SWITCH );
    RESOURCE_STR nlsSlow( IDS_SLOW_SWITCH );
    FOCUS_CACHE_SETTING setting = FOCUS_CACHE_UNKNOWN;

    //
    //  Ensure our switch strings loaded.
    //

    APIERR err = nlsFast.QueryError();

    if( err == NERR_Success )
    {
        err = nlsSlow.QueryError();
    }

    //
    //  Check for domain/server parameter.
    //
    //  CODEWORK check for multiple switches and/or domains

    for ( iArg = 1; (err == NERR_Success) && (iArg < cArgs); iArg++ )
    {
        const CHAR * pszArg = QueryArgv()[iArg];
        UIASSERT( pszArg != NULL );

        if( *pszArg != SWITCH_CHAR )
        {
            NLS_STR nlsParam;
            nlsParam.MapCopyFrom( pszArg );
            *pnlsServDom = nlsParam;
            err = pnlsServDom->QueryError();
        }
        else
        {
            NLS_STR nlsParam;
            nlsParam.MapCopyFrom( pszArg );
            err = nlsParam.QueryError();

            if( err == NERR_Success )
            {
                ISTR istr( nlsParam );
                ++istr;

                if( nlsParam._stricmp( nlsFast, istr ) == 0 )
                {
                    setting = FOCUS_CACHE_FAST;
                }
                else
                if( nlsParam._stricmp( nlsSlow, istr ) == 0 )
                {
                    setting = FOCUS_CACHE_SLOW;
                }
            }
        }
    }

    if ( err == NERR_Success && pfSlowModeFlag != NULL )
    {
        *pfSlowModeFlag = (setting != FOCUS_CACHE_UNKNOWN );
    }

    if (   err == NERR_Success
        && SupportsRasMode()
        && setting != FOCUS_CACHE_UNKNOWN
       )
    {
        SetRasMode( (setting == FOCUS_CACHE_SLOW) );
    }

    return err;
}


/*******************************************************************

    NAME:      ADMIN_APP::W_SetNetworkFocus

    SYNOPSIS:  Sets the focus to the requested object (Domain, server etc.),
               or returns an error.  This method does not refresh the
               information in the listboxes; rather, it more or less
               simply syntactically validates the new focus and
               sets the caption.

    ENTRY:     nlsNetworkFocus - Name of server/domain to set the focus
               to.  NULL if the user's logged on domain is preferred.

    EXIT:      Sets the internal focus variables correctly if the the call
               succeeds.

    RETURNS:   An error code if unsuccessful or NERR_Success if successful.

    NOTES:     When NULL or "" is passed in, the focus will be to either
               the logon domain or local computer depending on the
               _selType.
                   SEL_SRV_ONLY => local computer
                   SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN => local computer
                   SEL_DOM_ONLY => logon domain or PDC of the logon domain
                   SEL_SRV_DOM_ONLY => logon domain or PDC of the logon domain


    HISTORY:
       Johnl    13-May-1991     Created
       rustanl  02-Jul-1991     Changed LOCATION::SetAndValidate call to
                                a LOCATION::Set call.
       Yi-HsinS 06-Feb-1992     Use QuerySelectionType
       Yi-HsinS 13-May-1992     Separated from SetNetworkFocus

********************************************************************/

APIERR ADMIN_APP::W_SetNetworkFocus( const TCHAR * pchServDomain,
                                     FOCUS_CACHE_SETTING setting )
{
#ifdef TRACE
    const CHAR * apszSettings[] = { "SLOW", "FAST", "UNKNOWN" };
    TRACEEOL( "ADMIN_APP::W_SetNetworkFocus( \"" << pchServDomain << "\", "
              << apszSettings[setting] << " )" );
#endif

    // CODEWORK.  The following used to be one call to
    // LOCATION::SetAndValidate.  That call is now replaced by
    // LOCATION::Set.  The former call treated NULL and "" as specifying
    // the logon domain, whereas the latter treats NULL and "" as
    // specifying the local workstation (which is consistent with the
    // LOCATION constructor).  Therefore, the following branching
    // statement is used.  This could perhaps be cleaned up a bit
    // somehow.
    AUTO_CURSOR autocur;

    APIERR err = NERR_Success;

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

    if (  (  ( QuerySelectionType() != SEL_SRV_ONLY  )
          && ( QuerySelectionType() != SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN ))
       && (pchServDomain == NULL || pchServDomain[ 0 ] == TCH('\0') )
       )
    {
        err = _locFocus.Set( LOC_TYPE_LOGONDOMAIN, _flocGetPDC );
    }
    else
    {

#if 0

// This is an experimental extension to ADMIN_APP which will allow
// admin applications to run focused on the local machine without
// the local server started.
//
// This causes Server Manager to misbehave when you explicitly set
// focus to yourself.  In particular, it changes the window title
// to "Server Manager - Local Machine" (which is OK) and leaves a
// single computer in the listbox with a blank name (which is not OK).
//
// Event Viewer has its own solution to this problem.  This should
// really be taken care of inside User Manager.  Unfortunately we
// cannot copy this code into UM, since _locFocus is private.

        // CODEWORK code lifted from LOCATION::QueryDisplayName,
        // should be common code
        TCHAR pszServer[ MAX_COMPUTERNAME_LENGTH+1 ];
        DWORD dwLength = sizeof(pszServer) / sizeof(TCHAR);
        NLS_STR nlsComputerName;

        if ( ::GetComputerName( pszServer, &dwLength ) )
        {
            nlsComputerName = SZ("\\\\"); // CODEWORK constant
            err = nlsComputerName.Append( pszServer );
        }
        else
        {
            err = ::GetLastError();
        }

        if (   (err == NERR_Success)
            && !::I_MNetComputerNameCompare( nlsComputerName, pchServDomain )
           )
        {
            pchServDomain = NULL;
        }

#endif // 0

        if (err == NERR_Success)
        {
            err = _locFocus.Set( pchServDomain, _flocGetPDC );
        }
    }

    if (err == NERR_Success)
    {
        if (setting == FOCUS_CACHE_UNKNOWN)
        {
//
// We could have been called from either Run() or from FOCUS_DLG.  If we
// were called from Run(), the cache has not yet been checked.  So we
// check it here, and if this is redundant, it al least isn't harmful.
// Errors are non-fatal.
//
            TRACEEOL( "ADMIN_APP::W_SetNetworkFocus: extra cache read" );
            SLOW_MODE_CACHE cache;
            APIERR errTemp;
            if (   (errTemp = cache.QueryError()) != NERR_Success
                || (errTemp = cache.Read()) != NERR_Success
               )
            {
                TRACEEOL( "ADMIN_APP::W_SetNetworkFocus: cache read failure " << errTemp );
            }
            else
            {
                setting = (FOCUS_CACHE_SETTING) cache.Query( _locFocus );
            }
//
// If we still don't know, resort to slow mode detection
//
            if (setting == FOCUS_CACHE_UNKNOWN)
                setting = DetectSlowTransport( _locFocus.QueryServer() );
        }

        SetRasMode( setting == FOCUS_CACHE_SLOW );
    }

#if defined(DEBUG) && defined(TRACE)
    DWORD finish = ::GetTickCount();
    TRACEEOL( "ADMIN_APP::W_SetNetworkFocus() took " << finish-start << " ms" );
#endif

    return err;
}

/*******************************************************************

    NAME:      ADMIN_APP::DetectSlowTransport

    SYNOPSIS:  Determines whether the app's target focus is across a
               slow or fast link

    RETURNS:   FOCUS_CACHE_SETTING

    HISTORY:
        JonN       11-May-1993   Created

********************************************************************/

FOCUS_CACHE_SETTING ADMIN_APP::DetectSlowTransport( const TCHAR * pchServer ) const
{
    FOCUS_CACHE_SETTING setting = FOCUS_CACHE_UNKNOWN;
    if (pchServer == NULL)
    {
        TRACEEOL( "ADMIN_APP::DetectSlowTransport: PDC not known" );
        setting = FOCUS_CACHE_UNKNOWN;
    }
    else
    {
        BOOL fSlowTransport = FALSE;
        APIERR err = IsSlowTransport( pchServer, &fSlowTransport );
        if (err != NERR_Success)
        {
            TRACEEOL( "ADMIN_APP::DetectSlowTransport: DetectSlowTransport error " << err );
            setting = FOCUS_CACHE_FAST;
        }
        else
        {
            setting = (fSlowTransport) ? FOCUS_CACHE_SLOW
                                       : FOCUS_CACHE_FAST;
        }
    }

#ifdef TRACE
    const CHAR * apszSettings[] = { "SLOW", "FAST", "UNKNOWN" };
    TRACEEOL( "ADMIN_APP::DetectSlowTransport returns "
              << apszSettings[setting] );
#endif

    return setting;
}

/*******************************************************************

    NAME:      ADMIN_APP::SetNetworkFocus

    SYNOPSIS:  Set the focus of the app

    ENTRY:     pchServDomain - the focus to set to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS   13-May-1992   Created

********************************************************************/

APIERR ADMIN_APP::SetNetworkFocus( HWND hwndOwner,
                                   const TCHAR * pchServDomain,
                                   FOCUS_CACHE_SETTING setting )
{
    UNREFERENCED( hwndOwner );

    APIERR err = W_SetNetworkFocus( pchServDomain, setting );
    return err? err : SetAdminCaption();
}

/*******************************************************************

    NAME:      ADMIN_APP::IsDismissApp

    SYNOPSIS:  Check if we should dismiss the app when
               "err" occurred in SET_FOCUS_DIALOG.

    ENTRY:     err - the error that occurred in SET_FOCUS_DIALOG

    EXIT:

    RETURNS:   TRUE if we should dismiss the app, FALSE otherwise

    NOTES:

    HISTORY:
        Yi-HsinS   13-May-1992   Created

********************************************************************/

BOOL ADMIN_APP::IsDismissApp( APIERR err )
{
    UNREFERENCED( err );
    return TRUE;
}

/*******************************************************************

    NAME:      ADMIN_APP::SetAdminCaption

    SYNOPSIS:  Sets the correct caption of the main window

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   13-May-1991 Created
        beng    23-Oct-1991 Win32 conversion
        beng    22-Nov-1991 Removed STR_OWNERALLOC

********************************************************************/

APIERR ADMIN_APP::SetAdminCaption()
{
    MSGID idsCaptionText;
    const TCHAR * pchServDomain;
    RESOURCE_STR nlsLocal( IDS_LOCAL_MACHINE );

    if ( nlsLocal.QueryError() != NERR_Success )
        return nlsLocal.QueryError();

    if ( IsServer() )
    {
        idsCaptionText = IDS_OBJECTS_ON_SERVER;
        pchServDomain = _locFocus.QueryServer();
        if ( pchServDomain == NULL  )
        {
            pchServDomain = nlsLocal.QueryPch();
        }
    }
    else
    {
        //  A LOCATION object should either be a server or a domain
        UIASSERT( IsDomain());

        idsCaptionText = IDS_OBJECTS_IN_DOMAIN;
        pchServDomain = _locFocus.QueryDomain();
    }

    NLS_STR nlsCaption( MAX_RES_STR_LEN );

    if ( nlsCaption.QueryError() )
        return nlsCaption.QueryError();

    const ALIAS_STR nlsFocus( pchServDomain );

    const NLS_STR *apnlsParams[3];
    apnlsParams[0] = &_nlsObjectName;
    apnlsParams[1] = &nlsFocus;
    apnlsParams[2] = NULL;
    APIERR err = nlsCaption.Load( idsCaptionText );
    if (err == NERR_Success)
        err = nlsCaption.InsertParams(apnlsParams);
    if (err != NERR_Success)
        return err;

    SetText( nlsCaption );

    return NERR_Success;
}


/*******************************************************************

    NAME:      ADMIN_APP::OnMenuCommand

    SYNOPSIS:  Redefine APP_WINDOW's OnMenuCommand so we can make the
               appropriate call outs.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
       Johnl   13-May-1991     Created
       jonn    14-Oct-1991     Installed refresh lockcount

********************************************************************/

BOOL ADMIN_APP::OnMenuCommand( MID midMenuItem )
{
    switch ( midMenuItem )
    {
    case IDM_NEWOBJECT:
       OnNewObjectMenuSel();
       break;

    case IDM_PROPERTIES:
       OnPropertiesMenuSel();
       break;

    case IDM_COPY:
       OnCopyMenuSel();
       break;

    case IDM_DELETE:
       OnDeleteMenuSel();
       break;

    case IDM_EXIT:
       OnExitMenuSel();
       break;

    case IDM_SETFOCUS:
       {
           LockRefresh();
           OnSetFocusMenuSel();
           UnlockRefresh();
       }
       break;

    case IDM_REFRESH:
       {
           LockRefresh();
           OnRefreshMenuSel();
           UnlockRefresh();
       }
       break;

    case IDM_RAS_MODE:
       OnSlowModeMenuSel();
       break;

    case IDM_FONT_PICK:
       OnFontPickMenuSel();
       break;

    case IDM_CONFIRMATION:
       UIASSERT( _pmenuitemConfirmation != NULL );
       _pmenuitemConfirmation->SetCheck( !IsConfirmationOn());
       break;

    case IDM_SAVE_SETTINGS_ON_EXIT:
       _menuitemSaveSettings.SetCheck( !IsSavingSettingsOnExit());
       //  Save to ini file.  Ignore any error.
       Write( AA_INIKEY_SAVE_SETTINGS, ( IsSavingSettingsOnExit() ? 1 : 0 ));
       break;

    case IDM_REFRESH_INTERVAL:
       OnRefreshIntervalMenuSel();
       break;


    case IDM_HELP_CONTENTS:
       OnHelpMenuSel( ADMIN_HELP_CONTENTS );
       break;

    case IDM_HELP_SEARCH:
       OnHelpMenuSel( ADMIN_HELP_SEARCH );
       break;

    case IDM_HELP_HOWTOUSE:
       OnHelpMenuSel( ADMIN_HELP_HOWTOUSE );
       break;

    case IDM_HELP_KEYBSHORTCUTS:
       OnHelpMenuSel( ADMIN_HELP_KEYBSHORTCUTS );
       break;

    case IDM_ABOUT:
       OnAboutMenuSel();
       break;

    default:
       if( midMenuItem >= IDM_AAPPX_BASE )
       {
           ActivateExtension( QueryHwnd(), (DWORD)midMenuItem );
           break;
       }
       else
           return APP_WINDOW::OnMenuCommand( midMenuItem );
    }

    return TRUE;
}


/*******************************************************************

    NAME:      ADMIN_APP::QueryCurrentFocus

    SYNOPSIS:  Returns the text string that represents the current
               network focus (either a server or domain).  The return
               text contains OEM text.

    ENTRY:     pnlsCurrentFocus points to the NLS_STR to receive the
               string.

    EXIT:

    RETURNS:   Error code if copy failed.

    NOTES:

    HISTORY:
        Johnl   13-May-1991     Created
        rustanl 03-Sep-1991     Changed implementation to use
                                LOCATION::QueryName

********************************************************************/

APIERR ADMIN_APP::QueryCurrentFocus( NLS_STR * pnlsCurrentFocus ) const
{
    *pnlsCurrentFocus = _locFocus.QueryName();

    return pnlsCurrentFocus->QueryError();
}


/*******************************************************************

    NAME:      ADMIN_APP::QueryFocusType

    SYNOPSIS:  Returns one of the enum FOCUS_TYPE constants depending
               on the type of object that currently has the network
               focus (i.e., the string contained in _nlsNetworkFocus).

    RETURNS:   One of:
                   FOCUS_SERVER
                   FOCUS_DOMAIN
                   FOCUS_NONE

    NOTES:

    HISTORY:
       Johnl   13-May-1991     Created

********************************************************************/

enum FOCUS_TYPE ADMIN_APP::QueryFocusType() const
{
    if ( IsServer() )
       return FOCUS_SERVER;

    UIASSERT( IsDomain() );
    return FOCUS_DOMAIN;
}


/*******************************************************************

    NAME:      ADMIN_APP::IsConfirmationOn

    SYNOPSIS:  Returns TRUE if the Confirmation menu item is checked.

    HISTORY:
       Johnl    17-May-1991     Created
       rustanl  11-Sep-1991     Use _menuitemConfirmation

********************************************************************/

BOOL ADMIN_APP::IsConfirmationOn() const
{
    UIASSERT( _pmenuitemConfirmation != NULL );
    return _pmenuitemConfirmation->IsChecked();
}


/*******************************************************************

    NAME:       ADMIN_APP::IsSavingSettingsOnExit

    SYNOPSIS:   Returns whether or not the application is saving
                settings on exit

    RETURNS:    TRUE if application is saving settings on exit;
                FALSE otherwise

    NOTES:      This method can be called even if the construction of
                this object failed.  If construction failed, this method
                will return FALSE, which indicates that the caller should
                not save the settings.

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

BOOL ADMIN_APP::IsSavingSettingsOnExit() const
{
    return ( QueryError() == NERR_Success && _menuitemSaveSettings.IsChecked());
}


/*******************************************************************

    NAME:       ADMIN_APP::InRasMode

    SYNOPSIS:   Returns whether or not RAS mode is enabled.

    RETURNS:    TRUE if RAS mode is enabled,
                FALSE otherwise

    HISTORY:
        KeithMo     01-Feb-1993     Created.

********************************************************************/

BOOL ADMIN_APP::InRasMode( VOID ) const
{
    return ( (_pmenuitemRasMode != NULL) && (_pmenuitemRasMode->IsChecked()) );
}


/*******************************************************************

    NAME:       ADMIN_APP::SetRasMode

    SYNOPSIS:   Enables/disables RAS mode.

    HISTORY:
        KeithMo     01-Feb-1993     Created.

********************************************************************/

VOID ADMIN_APP::SetRasMode( BOOL fRasMode )
{
    if (_pmenuitemRasMode == NULL)
    {
        ASSERT( !fRasMode );
    }
    else
    {
        _pmenuitemRasMode->SetCheck( fRasMode );
    }
}


/*******************************************************************

    NAME:      ADMIN_APP::OnRefreshMenuSel

    SYNOPSIS:  Called when the Refresh menu item is selected.  This simply
               calls OnRefresh.

    NOTES:

    HISTORY:
        Johnl   14-May-1991     Created
        rustanl 04-Sep-1991     Added call to OnRefreshNow

********************************************************************/

VOID ADMIN_APP::OnRefreshMenuSel()
{
    APIERR err = OnRefreshNow();
    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    RefreshExtensions( QueryHwnd() );
}


/*******************************************************************

    NAME:       ADMIN_APP::OnTimerNotification

    SYNOPSIS:   Called every time

    ENTRY:      tid -       ID of timer that matured

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID ADMIN_APP::OnTimerNotification( TIMER_ID tid )
{
    if ( _timerRefresh.QueryID() == tid )
    {
        OnRefresh();
        return;
    }

    // call parent class
    TIMER_CALLOUT::OnTimerNotification( tid );
}


/*******************************************************************

    NAME:      ADMIN_APP::OnTimer

    SYNOPSIS:  Redefinition of ADMIN_APPs on timer method.  Calls OnRefresh
               if the specified time has passed.

    RETURNS:   TRUE if this was our timer message.

    NOTES:

    HISTORY:
       Johnl   17-May-1991     Created

********************************************************************/

BOOL ADMIN_APP::OnTimer( const TIMER_EVENT & eventTimer )
{
    eventTimer.QueryID();

    return APP_WINDOW::OnTimer( eventTimer );
}


/*******************************************************************

    NAME:      ADMIN_APP::OnRefreshIntervalMenuSel

    SYNOPSIS:  Puts up the Refresh Interval dialog and sets the new
               refresh interval.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
       Johnl   14-May-1991     Created

********************************************************************/

VOID ADMIN_APP::OnRefreshIntervalMenuSel()
{
#if 0
    REFRESH_INTERVAL_DIALOG dlgRefreshInterval( this, ... );

    APIERR err = dlgRefreshInterval.Process();

    if ( usResponse == Ok )
    {
    }
#endif
}


/*******************************************************************

    NAME:      ADMIN_APP::OnSetFocusMenuSel

    SYNOPSIS:  This method calls GetNetworkFocusFromUser in response
               to the set focus menu item being selected.

    NOTES:     Calls OnRefresh (after disabling the timer) to cause the
               main window to be refreshed.

    HISTORY:
       Johnl    20-May-1991     Created
       rustanl  04-Sep-1991     Call DoSetFocusDialog
       jonn     14-Oct-1991     Installed refresh lockcount

********************************************************************/

VOID ADMIN_APP::OnSetFocusMenuSel()
{
    LockRefresh();

    if ( DoSetFocusDialog( TRUE ))
    {
        UnlockRefresh();
    }
    else
    {
        UnlockRefresh();
        Close();
    }
}


/*******************************************************************

    NAME:      ADMIN_APP::OnAboutMenuSel

    SYNOPSIS:  Displays the system standard About box

    NOTES:

    HISTORY:
        Johnl       14-May-1991 Created
        beng        07-May-1992 Use system "about" box
        KeithMo     23-Nov-1992 SHELL32.DLL is now unicode enabled.
        CongpaY     10-Dec-1992 Dynamically link shell32.dll

********************************************************************/

VOID ADMIN_APP::OnAboutMenuSel()
{
    HINSTANCE hShell32Dll;
    PF_ShellAbout pfShellAbout = NULL;

    if (((hShell32Dll = LoadLibrary ((LPCTSTR) SHELL32_DLL_NAME)) == NULL) ||
        ((pfShellAbout = (PF_ShellAbout) GetProcAddress (hShell32Dll,
                                                        SHELLABOUT_NAME)) == NULL))
    {
        ::MsgPopup( this,
                    (APIERR) GetLastError(),
                    MPSEV_ERROR );
        return;
    }

    HMODULE hmod = BLT::CalcHmodRsrc(_idIcon);
    HICON   hIcon =   ::LoadIcon (hmod, MAKEINTRESOURCE(_idIcon));
    if  (pfShellAbout (QueryHwnd(),
                       (LPCTSTR)_nlsAppName.QueryPch(),
                       NULL,
                       hIcon ) == -1 )
    {
        ::MsgPopup( this,
                    (APIERR)ERROR_NOT_ENOUGH_MEMORY,    // just a guess...
                    MPSEV_ERROR );
    }

    FreeLibrary (hShell32Dll);
}


/*******************************************************************

    NAME:      ADMIN_APP::LockRefresh

    SYNOPSIS:  Locks the admin apps timer

    NOTES:     LockRefresh and UnlockRefresh should be used only in
               pairs.  They manipulate a lockcount, where refresh is
               enabled only if the lockcount is 0.  These methods are
               not idempotent!!

    HISTORY:
        Johnl       17-May-1991 Created
        rustanl     05-Sep-1991 Removed old _fOkToCallOnRefresh member
        rustanl     10-Sep-1991 Use _timerRefresh
        jonn        14-Oct-1991 Installed refresh lockcount

********************************************************************/

VOID ADMIN_APP::LockRefresh()
{
    if ( _uRefreshLockCount++ == 0 )
    {
        _timerRefresh.Enable( FALSE );
        StopRefresh();
    }
}


/*******************************************************************

    NAME:      ADMIN_APP::UnlockRefresh

    SYNOPSIS:  Unlocks the admin apps timer

    NOTES:     LockRefresh and UnlockRefresh should be used only in
               pairs.  They manipulate a lockcount, where refresh is
               enabled only if the lockcount is 0.  These methods are
               not idempotent!!

    HISTORY:
        Johnl       17-May-1991 Created
        rustanl     05-Sep-1991 Removed old _fOkToCallOnRefresh member
        rustanl     10-Sep-1991 Use _timerRefresh
        jonn        14-Oct-1991 Installed refresh lockcount

********************************************************************/

VOID ADMIN_APP::UnlockRefresh()
{
    UIASSERT( _uRefreshLockCount > 0 );
    if ( --_uRefreshLockCount == 0 )
    {
        _timerRefresh.Enable( TRUE );
    }
}


/*******************************************************************

    NAME:       ADMIN_APP::StopRefresh

    SYNOPSIS:   Stops outstanding app-specific automatic refresh work

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID ADMIN_APP::StopRefresh()
{
    // do nothing
}


/*******************************************************************

    NAME:      ADMIN_APP::IsRefreshEnabled

    SYNOPSIS:  Returns TRUE if the refresh timer is enabled

    HISTORY:
       Johnl    17-May-1991     Created
       rustanl  10-Sep-1991     Changed to use _timerRefresh

********************************************************************/

BOOL ADMIN_APP::IsRefreshEnabled()
{
    return _timerRefresh.IsEnabled();
}


/*******************************************************************

    NAME:      ADMIN_APP::OnResize

    SYNOPSIS:  When the window is minimized/maximized/restored, we need to
               stop/enable/enable the timer.

    NOTES:     Keeps track of previous minimized-state in _fIsMinimized,
                and keeps track of the size and position of the window
                in restored state.

    HISTORY:
       Johnl    21-May-1991     Created
       rustanl  10-Sep-1991     Removed call to OnRefresh
       jonn     14-Oct-1991     Installed refresh lockcount
       jonn     26-Dec-1991     Keeps track of restore position/size

********************************************************************/

BOOL ADMIN_APP::OnResize( const SIZE_EVENT& sizeevent )
{
    BOOL fIsNowMinimized = sizeevent.IsMinimized();
    BOOL fIsNowRestored = sizeevent.IsNormal();

    _fIsMaximized = sizeevent.IsMaximized();

    if ( fIsNowRestored )
    {
        _xyposRestoredPosition = QueryPos();
        _xydimRestoredSize = QuerySize();
    }

    if ( _fIsMinimized != fIsNowMinimized )
    {
        _fIsMinimized = fIsNowMinimized;

        if ( fIsNowMinimized )
            LockRefresh();
        else
            UnlockRefresh();
    }

    return APP_WINDOW::OnResize( sizeevent );
}

/*******************************************************************

    NAME:      ADMIN_APP::OnMove

    SYNOPSIS:  When the window is moved, we need to store the new
               position.

    NOTES:

    HISTORY:
        Yi-HsinS    30-June-1992     Created
        KeithMo     29-Jul-1992      Don't save position if minimized.

********************************************************************/

BOOL ADMIN_APP::OnMove( const MOVE_EVENT& moveevent )
{
    if( !_fIsMinimized )
    {
        _xyposRestoredPosition = QueryPos();
    }

    return APP_WINDOW::OnMove( moveevent );
}

/*******************************************************************

    NAME:      ADMIN_APP::QueryLocation

    SYNOPSIS:  Returns the focus of the application

    RETURNS:   Location where the focus is set

    HISTORY:
       rustanl      19-Jul-1991     Created
       rustanl      04-Sep-1991     Renamed QueryFocus to QueryLocation

********************************************************************/

const LOCATION & ADMIN_APP::QueryLocation() const
{
    return _locFocus;
}


/*******************************************************************

    NAME:      ADMIN_APP::OnExitMenuSel

    SYNOPSIS:  Virtual called when the Exit menu item is selected

    NOTES:     Sends this window a WM_CLOSE message

    HISTORY:
        Johnl       16-May-1991     Created
        rustanl     05-Sep-1991     Use new APP_WINDOW::Close method

********************************************************************/

VOID ADMIN_APP::OnExitMenuSel()
{
    Close();
}


/*******************************************************************

    NAME:     ADMIN_APP::FilterMessage

    SYNOPSIS: Filters menu accelerator related messages

    ENTRY:    pmsg -      Pointer to message structure

    RETURNS:  Whether or not message should be filtered.  If
              filtered, some other message may have been
              inserted in the message queue.

    HISTORY:
      rustanl     28-Aug-1991     Created

********************************************************************/

BOOL ADMIN_APP::FilterMessage( MSG * pmsg )
{
    return (_paccel != NULL) ? _paccel->Translate( this, pmsg )
                             : APPLICATION::FilterMessage( pmsg );
}


/*******************************************************************

    NAME:       ADMIN_APP::Run

    SYNOPSIS:   Second stage constructor

    ENTRY:      Application constructed successfully

    RETURNS:    Application exit value; the caller this not display
                this error--if it should also be displayed, it should
                be displayed before the end of this method.

    NOTES:      ReportError should not be called from this method,
                since it is not a constructor.

                After this method returns, the application will terminate.

    HISTORY:
        rustanl     29-Aug-1991 Created
        jonn        14-Oct-1991 Installed refresh lockcount
        beng        23-Oct-1991 Win32 conversion
        beng        24-Apr-1992 Change cmdline parsing
        beng        07-May-1992 App no longer displays startup dialog

********************************************************************/

INT ADMIN_APP::Run()
{
    /*
     *  The constructor remembers whether the profile indicates that the
     *  app should be maximized, storing this in _fIsMaximized.  However,
     *  this value is overwritten in OnResize(), which will be triggered by
     *  ShowWindow().  Therefore, we must transfer this flag to a
     *  temporary where it will not be overwritten.
     */
   BOOL fDoMaximize = _fIsMaximized;

    /*
     *  We could not call OnFontPickChange in the ctor, since it is a virtual
     *  which is redefined in the derived classes.  Instead we delay this
     *  until Run().
     */

    if (_pfontPicked != NULL)
    {
        OnFontPickChange( *_pfontPicked );
    }


    // Check if the user is logged on (and whether they want to log on).
    //
    APIERR err = AutoLogon();
    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
        return err;
    }

    // Display the main window.
    //

    ::ShowWindow( QueryHwnd(), SW_SHOWDEFAULT );

    //
    // If the user assigned a hotkey in Program Manager, we must remove
    // that hotkey from the invisible timer window and assign it to the
    // main window.
    // JonN July 5 1995
    //
    ULONG vkeyHotkey = BLT_MASTER_TIMER::ClearMasterTimerHotkey();
    if (vkeyHotkey != NULL)
    {
        ULONG_PTR retval = Command( WM_SETHOTKEY, vkeyHotkey );
        TRACEEOL(    "ADMIN_APP::Run(): WM_SETHOTKEY( " << vkeyHotkey
                  << " ) returned = " << retval );
    }

    if (   fDoMaximize    // registry indicates app should start maximized
        && !IsMinimized() // Program Manager did not request minimized start
       )
    {
        ::ShowWindow( QueryHwnd(), SW_SHOWMAXIMIZED );
    }

    // Get the focus name from the command line and syntactically validate it.
    //
    NLS_STR nlsNetworkFocus;
    BOOL fSlowModeCmdLineFlag = FALSE;
    err = ParseCommandLine( &nlsNetworkFocus, &fSlowModeCmdLineFlag );
    if ( err == NERR_Success )
    {
        TCHAR *pszTmp = (TCHAR *) nlsNetworkFocus.QueryPch() ;

        //
        // if _selType is server and no backslash, add it
        //
        if (_selType == SEL_SRV_ONLY ||
            _selType == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN ||
            _selType == SEL_SRV_EXPAND_LOGON_DOMAIN)
        {
            if (  pszTmp
               && (pszTmp[0] != TCH('\0'))
               && (::strncmpf(pszTmp,SZ("\\\\"),2) != 0) )
            {
                ISTR istr(nlsNetworkFocus) ;
                nlsNetworkFocus.InsertStr(SZ("\\\\"),istr) ;
                err = nlsNetworkFocus.QueryError() ;
            }
        }

        if (err == NERR_Success)
        {
            FOCUS_CACHE_SETTING setting = FOCUS_CACHE_UNKNOWN;
            if (fSlowModeCmdLineFlag)
                setting = (InRasMode()) ? FOCUS_CACHE_SLOW : FOCUS_CACHE_FAST;
            err = SetNetworkFocus( QueryHwnd(), nlsNetworkFocus, setting );
        }
    }

    if ( err == NERR_Success )
    {
        //  The name is syntactically valid
        //
        err = OnRefreshNow( TRUE );
    }


    // Focus was not set successfully.  Bring up Set Focus dialog
    // to allow user to select new focus.
    //
    if ( err != NERR_Success )
    {
        INT nRet = OnStartUpSetFocusFailed( err );
        if ( nRet == IERR_USERQUIT )
            return nRet;
    }

    // Start automatic refreshes.  This is done _exactly once_ to undo
    // the effect of the lock count starting at 1.
    //
    UnlockRefresh();

    if( SupportsRasMode() )
    {
        (void) SLOW_MODE_CACHE::Write( _locFocus,
                                       ( InRasMode() ? SLOW_MODE_CACHE_SLOW
                                                     : SLOW_MODE_CACHE_FAST ));
    }

    INT nRet = APPLICATION::Run();  // Run the message loop
    Show( FALSE );                  // Hide the main window
    return nRet;
}

/*******************************************************************

    NAME:       ADMIN_APP::OnStartUpSetFocusFailed

    SYNOPSIS:   Pop up the set focus dialog if focus is not set successfully

    ENTRY:      APIERR err - the error that occurred when trying to set
                             focus on startup

    RETURNS:

    NOTES:      virtual method

    HISTORY:
        Yi-HsinS    11-May-1992 Created
        beng        05-Aug-1992 Correct for various string sources

********************************************************************/

INT ADMIN_APP::OnStartUpSetFocusFailed( APIERR err )
{
    // If the error is workstation not started, no point trying
    // to popup the set focus dialog.
    //
    if ( err == NERR_WkstaNotStarted )
    {
        ::MsgPopup( this, err );
        return IERR_USERQUIT;
    }

    if( err == ERROR_MR_MID_NOT_FOUND )
    {
        //
        //  This is not exactly the best message to display, but it sure
        //  beats the text associated with ERROR_MR_MID_NOT_FOUND...
        //

        err = IDS_BLT_UNKNOWN_ERROR;
    }

    //  Setting focus according to command line or using default
    //  focus failed.  Ask if user wants to set new focus.  If so,
    //  bring up focus dialog; if not, quit the app.

    // First we load the error that caused the problem.  If we
    // can't load the error, then we bag out.
    //
    INT nReply;
    NLS_STR nlsError( MAX_RES_STR_LEN );
    APIERR errStr = nlsError.QueryError();

    if (errStr == NERR_Success)
    {
        errStr = nlsError.Load(err);
        if (errStr == ERROR_MR_MID_NOT_FOUND)
            errStr = nlsError.LoadSystem(err);
    }

    if (errStr != NERR_Success)
    {
         ::MsgPopup( this, err );
         nReply = IDYES;
    }
    else
    {
         MSGID msgid;
         switch ( QuerySelectionType() )
         {
             case SEL_SRV_ONLY:
             case SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN:
                 msgid = IDS_ADMIN_DIFF_SERV;
                 break;

             case SEL_DOM_ONLY:
                 msgid = IDS_ADMIN_DIFF_DOM;
                 break;

             case SEL_SRV_AND_DOM:
                 msgid = IDS_ADMIN_DIFF_SERVDOM;
                 break;
         }

         nReply = ::MsgPopup( QueryRobustHwnd(),
                              msgid,
                              MPSEV_ERROR,
                              MP_YESNO,
                              nlsError.QueryPch(),
                              NULL,
                              MP_YES );
    }

    if ( nReply == IDNO ||
         ! DoSetFocusDialog( FALSE ))
    {
        //  User decided to quit.  Don't display any message, but simply
        //  quit the app.
        return IERR_USERQUIT;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:       ADMIN_APP::DoSetFocusDialog

    SYNOPSIS:   Calls out to the Set Focus dialog

    ENTRY:      fAlreadyHasGoodFocus -  Indicates whether or not
                                        the main window has proper
                                        focus on something at the
                                        time this method is called

    EXIT:       If method returns TRUE, focus has successfully
                been set and main window has been refreshed.
                If method returns FALSE, user has decided to
                quit the app.

    RETURNS:    TRUE if main window successfully displays some
                    focus
                FALSE if user decided to quit app; caller should
                    then make this wish come through

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

BOOL ADMIN_APP::DoSetFocusDialog( BOOL fAlreadyHasGoodFocus )
{
    SET_FOCUS_DLG setfocusdlg( this,
                               fAlreadyHasGoodFocus,
                               QuerySelectionType(),
                               QueryDomainSources(),
                               IsServer() ? NULL
                                          : QueryLocation().QueryDomain(),
                               QuerySetFocusHelpContext(),
                               _nSetFocusServerTypes );

    BOOL fSuccess;
    APIERR err = setfocusdlg.Process( &fSuccess );

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
        return fAlreadyHasGoodFocus;
    }

    return fSuccess;
}


/*******************************************************************

    NAME:       ADMIN_APP::OnHelpMenuSel

    SYNOPSIS:   Invokes WinHelp for one of the Help menu items.

    ENTRY:      helpOptions             - Specifies which menu item
                                          was selected.

    EXIT:       Tries to invoke help, may fail.  Such is life.

    HISTORY:
        KeithMo     16-Aug-1992     Created.

********************************************************************/

VOID ADMIN_APP::OnHelpMenuSel( enum HELP_OPTIONS helpOptions )
{
    UINT      nHelpCommand = 0;
    DWORD_PTR dwpData       = 0;

    switch( helpOptions )
    {
    case ADMIN_HELP_CONTENTS :
        nHelpCommand = (UINT) HELP_FINDER;
        break;

    case ADMIN_HELP_SEARCH :
        nHelpCommand = (UINT) HELP_PARTIALKEY;
        dwpData = (DWORD_PTR)SZ("");
        break;

    case ADMIN_HELP_HOWTOUSE :
        nHelpCommand = (UINT) HELP_HELPONHELP;
        break;

    case ADMIN_HELP_KEYBSHORTCUTS :
        nHelpCommand = (UINT) HELP_CONTEXT;
        dwpData = QueryHelpContext( ADMIN_HELP_KEYBSHORTCUTS );
        break;

    default :
        DBGEOL( "ADMIN_APP::OnHelpMenuSel - bogus helpOptions" );
        ASSERT( FALSE );
        break;
    }

    ActivateHelp( _nlsHelpFileName,
                  nHelpCommand,
                  dwpData );
}


/*******************************************************************

    NAME:       ADMIN_APP::OnUserMessage

    SYNOPSIS:   See if help is called on the common dialog, or while
                a menu is dropped.

    ENTRY:

    EXIT:

    HISTORY:
        Yi-HsinS     8-Sept-1992     Created.
        KeithMo      23-Oct-1992     Added support for WM_MENU_ITEM_HELP.

********************************************************************/

BOOL ADMIN_APP::OnUserMessage( const EVENT &event )
{
    if ( event.QueryMessage() == _msgHelpCommDlg )
    {
        GET_FNAME_BASE_DLG *pDlg = (GET_FNAME_BASE_DLG *)
                            ((LPOPENFILENAME) event.QueryLParam())->lCustData;
        pDlg->OnHelp( (HWND) event.QueryWParam() );
        return TRUE;
    }
    else
    if( event.QueryMessage() == WM_MENU_ITEM_HELP )
    {
        //
        //  The user pressed [F1] during a menu.
        //

        //
        //  Cancel the menu before we launch help.
        //

        _fInCancelMode = TRUE;
        Command( WM_CANCELMODE, 0, 0 );
        _fInCancelMode = FALSE;

        //
        //  Activate appropriate help.
        //

        if( _midSelected >= IDM_AAPPX_BASE )
        {
            //
            //  It's an extension.  Let the extension decide
            //  how to handle it.
            //

            ActivateExtension( QueryHwnd(), (DWORD)_midSelected + OMID_EXT_HELP );
        }
        else
        if( _midSelected != 0 )
        {
            //
            //  It's a "normal" menu item.  Let's see if we
            //  can map the menu ID to a help context value.
            //

            ULONG hc;

            if( Mid2HC( _midSelected, &hc ) )
            {
                //
                //  Got the help context.  Fire off WinHelp.
                //

                ActivateHelp( _nlsHelpFileName,
                              HELP_CONTEXT,
                              (DWORD_PTR)hc );
            }
            else
            {
                DBGEOL( "ADMIN_APP - Could not find help context for MID "
                        << (ULONG)_midSelected );
            }
        }
    }

    return FALSE;
}


/*******************************************************************

    NAME:       ADMIN_APP::Mid2HC

    SYNOPSIS:   Maps a given menu ID to a help context.

    ENTRY:      mid                     - The menu ID to map.

                phc                     - Will receive the help context
                                          if this method is successful.

    RETURNS:    BOOL                    - TRUE  if *phc is valid (mapped),
                                          FALSE if could not map.

    NOTES:      We should probably merge this functionality with that
                provided by MSGPOPUP_DIALOG::Msg2HC into a common
                "resource lookup table" thang.

    HISTORY:
        KeithMo     23-Oct-1992     Created.  OK, blatently stolen from
                                    MSGPOPUP_DIALOG::Msg2HC.

********************************************************************/
BOOL ADMIN_APP::Mid2HC( MID mid, ULONG * phc ) const
{
    UIASSERT( phc != NULL );

    //
    //  We'll assume that the lookup table is stored in the
    //  resource associated with the hInstance passed to the
    //  ADMIN_APP constructor.
    //
    //  Find that dang resource.
    //

    HRSRC hrsrcFind = ::FindResource( QueryInstance(),
                                      MAKEINTRESOURCE( IDHC_MENU_TO_HELP ),
                                      RT_RCDATA );
    if( hrsrcFind == NULL )
    {
        return FALSE;
    }

    //
    //  Load the resource into global memory.
    //

    HGLOBAL hglobalLoad = ::LoadResource( QueryInstance(), hrsrcFind );
    if( hglobalLoad == NULL )
    {
        return FALSE;
    }

    //
    //  Lock it down.
    //

    LPMENUHCTABLE lpMenuToHCTable = (LPMENUHCTABLE)::LockResource( hglobalLoad );
    if( lpMenuToHCTable == NULL )
    {
        return FALSE;
    }

    //
    //  Scan for a matching menu ID.  Since we cannot assume any
    //  particular ordering of IDs within the table, a linear
    //  search is required.
    //

    BOOL fResult = FALSE;       // until proven otherwise...
    LPMENUHCTABLE lpScan = lpMenuToHCTable;

    for( ; ; )
    {
        if( lpScan->mid == 0 )
        {
            //
            //  End of table.
            //

            break;
        }

        if( mid == (MID)lpScan->mid )
        {
            //
            //  Got a match.  Save the help context & set the
            //  "success" flag.
            //

            *phc = (ULONG)lpScan->hc;
            fResult = TRUE;
            break;
        }

        //
        //  Advance to the next entry.
        //

        lpScan++;
    }

#if !defined(WIN32)
    ::UnlockResource( hglobalLoad );
    ::FreeResource( hrsrcFind );
#endif

    return fResult;
}


/*******************************************************************

    NAME:       ADMIN_APP::SetAcceleratorTable

    SYNOPSIS:   Maps a given menu ID to a help context.

    ENTRY:      idAccel                 - The resource ID
                                          0 for no accelerators

    RETURNS:    APIERR

    HISTORY:
        JonN        02-Feb-1992     Created

********************************************************************/
APIERR ADMIN_APP::SetAcceleratorTable( UINT idAccel )
{
    ACCELTABLE * pTemp = NULL;
    APIERR err = NERR_Success;
    if (idAccel != 0)
    {
        pTemp = new ACCELTABLE( idAccel );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pTemp == NULL
            || (err = pTemp->QueryError()) != NERR_Success
           )
        {
            DBGEOL(   "ADMIN_APP::SetAcceleratorTable( " << idAccel
                   << " ) failed with error " << err );
            delete pTemp;
            pTemp = NULL;
        }
    }
    else
    {
        TRACEEOL( "ADMIN_APP::SetAcceleratorTable: no accelerator table" );
    }

    if (err == NERR_Success)
    {
        delete _paccel;
        _paccel = pTemp;
    }

    return err;
}


/*******************************************************************

    NAME:       ADMIN_APP::OnMenuSelect

    SYNOPSIS:   Invoked when a WM_MENUSELECT message is received.

    ENTRY:      event                   - The "packaged" event.

    RETURNS:    BOOL                    - TRUE  if we handled the message,
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     23-Oct-1992     Created.

********************************************************************/
BOOL ADMIN_APP::OnMenuSelect( const MENUITEM_EVENT & event )
{
#ifndef WIN32
#error  "We'll worry about this at a more appropriate time..."
#endif  // WIN32

    //
    //  If this message is a result of us sending a WM_CANCELMODE
    //  message to the window, then we can ignore it.  The keeps
    //  us from overwriting _midSelected and _flagsSelected when
    //  to force the menu closed before launching WinHelp.
    //

    if( !_fInCancelMode )
    {
        UINT flags = (UINT)HIWORD(event.QueryWParam());

        if( ( flags == -1 ) && ( event.QueryLParam() == 0 ) )
        {
            //
            //  The menu was closed.
            //

            _midSelected   = 0;
            _flagsSelected = 0;
        }
        else
        {
            MID mid = event.QueryMID();

            if( ( mid == 0 ) || ( flags & MF_SEPARATOR ) )
            {
                //
                //  The mid will be 0 if an "abnormal" item is
                //  selected.  Also, there's no point in invoking
                //  help for the separator bar...
                //

                _midSelected   = 0;
                _flagsSelected = 0;
            }
            else
            {
                _midSelected   = mid;
                _flagsSelected = flags;
            }
        }
    }

    //
    //  Yes, we "handled" the message, but we'll return FALSE
    //  anyway so anyone else in the "chain" will get a crack
    //  at these messages.
    //

    return FALSE;
}


/*******************************************************************

    NAME:       ADMIN_APP::ActivateHelp

    SYNOPSIS:   Invokes WinHelp with the specified help file/command/context.

    ENTRY:      pszHelpFile             - Name of the help file.

                nHelpCommand            - One of the HELP_* help commands.

                dwpData                 - Command specific data.

    HISTORY:
        KeithMo     21-Oct-1992     Created.

********************************************************************/
VOID ADMIN_APP::ActivateHelp( const TCHAR * pszHelpFile,
                              UINT          nHelpCommand,
                              DWORD_PTR     dwpData )
{
    DBGEOL( "ADMIN_APP - Calling WinHelp: pszHelpFile = " << pszHelpFile
            << ", nHelpCommand = " << nHelpCommand
            << ", dwpData = " << dwpData );

    if( !::WinHelp( QueryHwnd(),
                    (TCHAR *)pszHelpFile,
                    nHelpCommand,
                    dwpData ) )
    {
        ::MsgPopup( QueryHwnd(),
                    IDS_BLT_WinHelpError,
                    MPSEV_ERROR,
                    MP_OK );
    }
}


/*******************************************************************

    NAME:       ADMIN_APP::AddExtensionMenuItem

    SYNOPSIS:   Adds the given menu item to the main app window &
                the help menu.

    ENTRY:      pszMenuName             - The name of the menu item.

                hMenu                   - Popup menu handle.

                dwDelta                 - The delta for this menu.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      This code assumes that the Help menu is always the
                *last* (rightmost) popup.

    HISTORY:
        KeithMo      21-Oct-1992     Created.

********************************************************************/
APIERR ADMIN_APP::AddExtensionMenuItem( const TCHAR * pszMenuName,
                                        HMENU         hMenu,
                                        DWORD         dwDelta )
{
    UIASSERT( pszMenuName != NULL );
    UIASSERT( hMenu != NULL );
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgr != NULL );

    //
    //  Adjust the mnemonic.
    //

    NLS_STR nlsNewMenuName;

    APIERR err = nlsNewMenuName.QueryError();

    if( err == NERR_Success )
    {
        err = AdjustMenuMnemonic( pszMenuName,
                                  nlsNewMenuName );
    }

    //
    //  Update the toplevel menu.
    //

    if( err == NERR_Success )
    {
        err = _pmenuApp->Insert( nlsNewMenuName,
                                 _pmenuApp->QueryItemCount() - 1,
                                 hMenu,
                                 MF_BYPOSITION );
    }

    if( err == NERR_Success )
    {
        //
        //  Create a temporary POPUP_MENU representing the "Help" menu.
        //

        POPUP_MENU menuHelp( _pmenuApp->QuerySubMenu(
                                            _pmenuApp->QueryItemCount() - 1 ) );

        err = menuHelp.QueryError();

        if( ( err == NERR_Success ) && ( QueryExtensionCount() == 0 ) )
        {
            //
            //  This is the first extension.  Add a new separator
            //  to the help menu.  We use QueryItemCount() - 1 to
            //  insert the separator just before the last item.  The
            //  last item in the Help menu is always "About...".
            //

            err = menuHelp.InsertSeparator( menuHelp.QueryItemCount() - 1,
                                            MF_BYPOSITION );
        }

        if( err == NERR_Success )
        {
            //
            //  Insert the help item.  We use QueryItemCount() - 2 to
            //  insert the item just before the next-to-last item.
            //  The next-to-last item is always a separator, and the
            //  last item is always "About...".
            //

            err = menuHelp.Insert( nlsNewMenuName,
                                   menuHelp.QueryItemCount() - 2,
                                   (UINT)dwDelta + VIDM_HELP_ON_EXT,
                                   MF_BYPOSITION );
        }
    }

    //
    //  Redraw the app's menu bar.
    //

    DrawMenuBar();

    return err;

}   // ADMIN_APP::AddExtensionMenuItem


/*******************************************************************

    NAME:       ADMIN_APP::LoadExtensions

    SYNOPSIS:   Tries to load the application extensions.

    RETURNS:    UINT                    - The number of extensions
                                          successfully loaded.

    HISTORY:
        KeithMo      19-Oct-1992     Created.

********************************************************************/
UINT ADMIN_APP::LoadExtensions( VOID )
{
    UIASSERT( _nlsExtSection.QueryTextLength() > 0 );

    //
    //  Create the interface object.
    //

    _pExtMgrIf = new AAPP_EXT_MGR_IF( this );

    if( ( _pExtMgrIf == NULL ) || ( _pExtMgrIf->QueryError() != NERR_Success ) )
    {
        DBGEOL( "ADMIN_APP::LoadExtensions - failed to create interface" );
        return 0;
    }

    //
    //  Create the extension manager.
    //

    _pExtMgr = LoadMenuExtensionMgr();

    if( ( _pExtMgr == NULL ) || ( _pExtMgrIf->QueryError() != NERR_Success ) )
    {
        DBGEOL( "ADMIN_APP::LoadExtensions - failed to create ext manager" );
        delete _pExtMgrIf;
        _pExtMgrIf = NULL;
        return 0;
    }

    //
    //  Now we can load the extensions.
    //

    return _pExtMgr->LoadExtensions();

}   // ADMIN_APP::LoadExtensions


/*******************************************************************

    NAME:       ADMIN_APP::LoadMenuExtensionMgr

    SYNOPSIS:   Tries to load the menu extension manager

    RETURNS:    UI_MENU_EXT_MGR *  -  A pointer to the newly loaded
                                      extension manager.  The caller is
                                      expected to handle NULL returns or
                                      returns of objects in error state.
                                      The caller is also expected to free
                                      the object, the destructor is virtual.

    HISTORY:
        JonN         23-Nov-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR * ADMIN_APP::LoadMenuExtensionMgr( VOID )
{
    return new UI_MENU_EXT_MGR( _pExtMgrIf,
                                IDM_AAPPX_BASE,
                                IDM_AAPPX_DELTA );
}


/*******************************************************************

    NAME:       ADMIN_APP::GetMenuExtensionList

    SYNOPSIS:   Returns a list of DLL names potentially containing
                menu extensions.

    RETURNS:    STRLIST *               - The list of DLL names.

    HISTORY:
        KeithMo      19-Oct-1992     Created.

********************************************************************/
STRLIST * ADMIN_APP::GetMenuExtensionList( VOID )
{
    UIASSERT( _nlsExtSection.QueryTextLength() > 0 );

    //
    //  Unfortunately, ADMIN_INI fails us here.  We need to read
    //  *all* keys for a given section, enumerate the keys, then
    //  read the value of each key.
    //
    //  CODEWORK:  Make a generic wrapper for this functionality.
    //

    STRLIST * psl = new STRLIST;

    if( psl == NULL )
    {
        DBGEOL( "ADMIN_APP::GetMenuExtensionList - cannot create STRLIST" );
        return NULL;
    }

    const TCHAR * pszIniFile = SZ("NTNET.INI"); // BUGBUG! stolen from aini.cxx

    //
    //  There's no easy way to determine the appropriate buffer size
    //  for a GetPrivateProfileString call.  We'll allocate a 4K TCHAR
    //  buffer and hope for the best.
    //

    BUFFER bufKeys( MAX_KEY_LIST_BUFFER_SIZE * sizeof(TCHAR) );
    BUFFER bufValue( MAX_PATH * sizeof(TCHAR) );

    if( ( bufKeys.QueryError() == NERR_Success ) &&
        ( bufValue.QueryError() == NERR_Success ) )
    {
        //
        //  Read the key names.
        //

        const TCHAR * pszKey = (TCHAR *)bufKeys.QueryPtr();

        ::GetPrivateProfileString( _nlsExtSection.QueryPch(),
                                   NULL,                // all keys
                                   SZ(""),              // default
                                   (LPTSTR)pszKey,
                                   bufKeys.QuerySize() / sizeof(TCHAR),
                                   (LPCTSTR)pszIniFile );

        //
        //  Scan the keys.
        //

        while( *pszKey )
        {
            //
            //  Read the value.
            //

            const TCHAR * pszValue = (TCHAR *)bufValue.QueryPtr();

            ::GetPrivateProfileString( _nlsExtSection.QueryPch(),
                                       pszKey,
                                       SZ(""),
                                       (LPTSTR)pszValue,
                                       bufValue.QuerySize() / sizeof(TCHAR),
                                       (LPCTSTR)pszIniFile );

            if( *pszValue )
            {
                //
                //  Create a new buffer, add it to the list.
                //

                NLS_STR * pnls = new NLS_STR( pszValue );

                if( ( pnls == NULL ) ||
                    ( pnls->QueryError() != NERR_Success ) ||
                    ( psl->Append( pnls ) != NERR_Success ) )
                {
                    break;
                }
            }

            //
            //  Advance to the next key.
            //

            pszKey += ::strlenf( pszKey ) + 1;
        }
    }

    return psl;

}   // ADMIN_APP::GetMenuExtensionList


/*******************************************************************

    NAME:       ADMIN_APP::BuildMenuMnemonicList

    SYNOPSIS:   Fills _nlsMenuMnemonics with the mnemonics used in
                the current menu.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo      21-Oct-1992     Created.

********************************************************************/
APIERR ADMIN_APP::BuildMenuMnemonicList( VOID )
{
    //
    //  nlsText will hold the names of the menu items.
    //

    NLS_STR nlsText;

    APIERR err = nlsText.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Scan through all menu items.
        //

        UINT cItems = _pmenuApp->QueryItemCount();

        for( UINT pos = 0 ; pos < cItems ; pos++ )
        {
            //
            //  Get the menu text for the current item.
            //

            err = _pmenuApp->QueryItemText( &nlsText, pos, MF_BYPOSITION );

            if( err != NERR_Success )
            {
                break;
            }

            //
            //  Map the menu text to uppercase, so all mnemonics
            //  in the list will stay in uppercase.
            //

            nlsText._strupr();

            //
            //  Scan the text for a mnemonic.
            //

            ISTR istr( nlsText );

            if( FindMnemonic( nlsText, istr ) )
            {
                //
                //  Append the mnemonic to our list.
                //

                err = _nlsMenuMnemonics.AppendChar( nlsText.QueryChar( istr ) );
            }

            if( err != NERR_Success )
            {
                break;
            }
        }
    }

    return err;
}


/*******************************************************************

    NAME:       ADMIN_APP::AdjustMenuMnemonic

    SYNOPSIS:   Adjusts the mnemonic in the given menu name so that
                it won't conflict with any existing mnemonics.

                The basic algorithm is:

                    If the menu already has a mnemonic, and this
                    mnemonic does not conflict, leave it as-is.

                    Otherwise, scan from the beginning of the name
                    looking for a non-blank character that can be
                    used as a mnemonic.  If one can be found, use it.

                    Otherwise, if the menu originally had a mnemonic,
                    use it.

                    Otherwise, use the first non-blank character in
                    the name.

    ENTRY:      pszOrgMenuName          - The "original" menu name.

                nlsNewMenuName          - The newly mangled menu name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo      21-Oct-1992     Created.

********************************************************************/
APIERR ADMIN_APP::AdjustMenuMnemonic( const TCHAR * pszOrgMenuName,
                                      NLS_STR     & nlsNewMenuName )
{
    UIASSERT( pszOrgMenuName != NULL );
    UIASSERT( nlsNewMenuName.QueryError() == NERR_Success );

    //
    //  Make a copy of the string so we can mess with it.
    //

    APIERR err = nlsNewMenuName.CopyFrom( pszOrgMenuName );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Let's see if it already has a mnemonic.
    //

    ALIAS_STR nlsPrefix( SZ("&") );
    ISTR      istr( nlsNewMenuName );
    BOOL      fHasMnemonic  = FALSE;
    BOOL      fComplete     = FALSE;
    WCHAR     chNewMnemonic = L'\0';

    if( FindMnemonic( nlsNewMenuName, istr ) )
    {
        fHasMnemonic = TRUE;

        WCHAR wchTmp = TO_UPPER( nlsNewMenuName.QueryChar( istr ) );

        if( ::strchrf( _nlsMenuMnemonics, wchTmp ) )
        {
            //
            //  Conflict.  Remove the offending mnemonic.
            //

            RemoveMnemonic( nlsNewMenuName );
        }
        else
        {
            //
            //  No conflict, the existing mnemonic is cool.
            //  Remember the mnemonic so we can add it to the list.
            //

            chNewMnemonic = wchTmp;
            fComplete = TRUE;
        }
    }

    if( !fComplete && ( err == NERR_Success ) )
    {
        //
        //  We only make it to this point if there was
        //  a conflict in the default mnemonic or if the
        //  menu item had no mnemonic.  So now we get to
        //  scan for an available mnemonic.
        //
        //  Ack.
        //

        istr.Reset();

        WCHAR wchTmp;

        while( ( wchTmp = TO_UPPER( nlsNewMenuName.QueryChar( istr ) ) ) != L'\0' )
        {
            //
            //  There's no point in making a space a mnemonic...
            //

            if( wchTmp != L' ' )
            {
                if( !::strchrf( _nlsMenuMnemonics, wchTmp ) )
                {
                    //
                    //  Found one.
                    //

                    if( !nlsNewMenuName.InsertStr( nlsPrefix, istr ) )
                    {
                        err = nlsNewMenuName.QueryError();
                    }

                    //
                    //  Remember the mnemonic so we can add it to
                    //  the list.
                    //

                    chNewMnemonic = wchTmp;

                    fComplete = TRUE;
                    break;
                }
            }

            ++istr;
        }
    }

    if( !fComplete && ( err == NERR_Success ) )
    {
        //
        //  We only make it to this point if we have
        //  really bad karma.  Every non-blank character
        //  in the menu name is already in use as a menu
        //  mnemonic.
        //
        //  If the menu name originally had a mnemonic,
        //  we'll use it.  Otherwise, we'll use the first
        //  character.
        //
        //  Pfft.
        //

        if( fHasMnemonic )
        {
            //
            //  Copy the original unmolested menu name.
            //

            err = nlsNewMenuName.CopyFrom( pszOrgMenuName );

            //
            //  We *should* have already set the saved mnemonic.
            //

            UIASSERT( chNewMnemonic != L'\0' );
            fComplete = TRUE;
        }
        else
        {
            //
            //  Insert the mnemonic prefix before the first
            //  character.
            //

            istr.Reset();
            err = nlsNewMenuName.InsertStr( nlsPrefix, istr );

            //
            //  Remember the new mnemonic so we can add it
            //  to the list.
            //

            chNewMnemonic = nlsNewMenuName.QueryChar( istr );
            fComplete = TRUE;
        }
    }

    //
    //  Add the new mnemonic to the mnemonic list.
    //

    if( err == NERR_Success )
    {
        UIASSERT( chNewMnemonic != L'\0' );

        err = _nlsMenuMnemonics.AppendChar( chNewMnemonic );
    }

    return err;
}


/*******************************************************************

    NAME:       ADMIN_APP::FindMnemonic

    SYNOPSIS:   Scans the given string, looking for the first (only?)
                mnemonic.

    ENTRY:      nlsText                 - The text to scan.

                istr                    - The starting location.

    RETURNS:    BOOL                    - TRUE if a mnemonic was found.
                                          istr will point to the mnemonic.

                                          FALSE if no mnemonic found.

    HISTORY:
        KeithMo      21-Oct-1992     Created.

********************************************************************/
BOOL ADMIN_APP::FindMnemonic( NLS_STR & nlsText, ISTR & istr )
{
    WCHAR chThis  = L'\0';
    WCHAR chPrev  = L'\0';
    BOOL  fResult = FALSE;      // until proven otherwise...

    while( ( chThis = nlsText.QueryChar( istr ) ) != L'\0' )
    {
        if( chPrev == L'&' )
        {
            if( chThis == L'&' )
            {
                //
                //  Actually, we can set chThis to anything
                //  other than '&'.  This is to keep "&&K"
                //  from recording 'K' as a mnemonic.
                //

                chThis = L' ';
            }
            else
            {
                //
                //  Found it!
                //

                fResult = TRUE;
                break;
            }
        }

        chPrev = chThis;
        ++istr;
    }

    return fResult;
}


/*******************************************************************

    NAME:       ADMIN_APP::RemoveMnemonic

    SYNOPSIS:   Removes the first (only?) mnemonic in the string.

    ENTRY:      nlsText                 - The text to scan.

    HISTORY:
        KeithMo      21-Oct-1992     Created.

********************************************************************/
VOID ADMIN_APP::RemoveMnemonic( NLS_STR & nlsText )
{
    WCHAR chThis  = L'\0';
    WCHAR chPrev  = L'\0';
    ISTR  istr( nlsText );
    ISTR  istrPrev( nlsText );

    while( ( chThis = nlsText.QueryChar( istr ) ) != L'\0' )
    {
        if( chPrev == L'&' )
        {
            if( chThis == L'&' )
            {
                //
                //  Actually, we can set chThis to anything
                //  other than '&'.  This is to keep "&&K"
                //  from recording 'K' as a mnemonic.
                //

                chThis = L' ';
            }
            else
            {
                //
                //  Found it!
                //

                nlsText.DelSubStr( istrPrev, istr );
                break;
            }
        }

        chPrev   = chThis;
        istrPrev = istr;

        ++istr;
    }
}


/*******************************************************************

    NAME:       ADMIN_APP::FindExtensionByName

    SYNOPSIS:   Given an extension DLL's name, finds the corresponding
                AAPP_MENU_EXT object.

    ENTRY:      pszDllName              - Name of the extension to find.

    RETURNS:    AAPP_MENU_EXT *         - The object, NULL if not found.

    HISTORY:
        KeithMo      26-Oct-1992     Created.

********************************************************************/
AAPP_MENU_EXT * ADMIN_APP::FindExtensionByName( const TCHAR * pszDllName ) const
{
    AAPP_MENU_EXT * pExt = NULL;

    if( _pExtMgr )
    {
        pExt = (AAPP_MENU_EXT *)_pExtMgr->FindExtensionByName( pszDllName );
    }

    return pExt;
}


/*******************************************************************

    NAME:       ADMIN_APP::FindExtensionByDelta

    SYNOPSIS:   Given an extension DLL's delta, finds the corresponding
                AAPP_MENU_EXT object.

    ENTRY:      dwDelta                 - The search delta.

    RETURNS:    AAPP_MENU_EXT *         - The object, NULL if not found.

    HISTORY:
        KeithMo      26-Oct-1992     Created.

********************************************************************/
AAPP_MENU_EXT * ADMIN_APP::FindExtensionByDelta( DWORD dwDelta ) const
{
    AAPP_MENU_EXT * pExt = NULL;

    if( _pExtMgr )
    {
        pExt = (AAPP_MENU_EXT *)_pExtMgr->FindExtensionByDelta( dwDelta );
    }

    return pExt;
}



/*-----------------------------------------------------------------------
 *
 * Everything below here is meant to be replaced by the client of ADMIN_APP.
 *
 * We may want to consider removing these and making the functions pure
 * virtual (after most of the basic admin application development is finished).
 *
 *-----------------------------------------------------------------------*/

VOID ADMIN_APP::OnNewObjectMenuSel()
{
    DBGEOL( "ADMIN_APP::OnNewObjectMenuSel" );
}

VOID ADMIN_APP::OnPropertiesMenuSel()
{
    DBGEOL( "ADMIN_APP::OnPropertiesMenuSel" );
}

VOID ADMIN_APP::OnCopyMenuSel()
{
    DBGEOL( "ADMIN_APP::OnCopyMenuSel" );
}

VOID ADMIN_APP::OnDeleteMenuSel()
{
    DBGEOL( "ADMIN_APP::OnDeleteMenuSel" );
}

VOID ADMIN_APP::OnSlowModeMenuSel()
{
    DBGEOL( "ADMIN_APP::OnSlowModeMenuSel" );

    SetRasMode( !InRasMode() );

    (void) SLOW_MODE_CACHE::Write( _locFocus,
                                   ( InRasMode() ? SLOW_MODE_CACHE_SLOW
                                                 : SLOW_MODE_CACHE_FAST ));

}


/*******************************************************************

    NAME:       ADMIN_APP::OnFontPickMenuSel

    SYNOPSIS:   When the IDM_FONTPICK menu item is selected, present the
                Font Picker common dialog.  If the font is changed, update
                the listboxes and remember the change.

    HISTORY:
        JonN         23-Sep-1993     Created

********************************************************************/

VOID ADMIN_APP::OnFontPickMenuSel()
{
    ASSERT( _plogfontPicked != NULL );

    DBGEOL( "ADMIN_APP::OnFontPickMenuSel" );

    APIERR err = NERR_Success;

    do // false loop
    {
        CHOOSEFONT cf;

        WIN32_FONT_PICKER::InitCHOOSEFONT( &cf, _plogfontPicked, QueryHwnd() );

        cf.Flags |= CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;
        cf.nSizeMin = FONTPICK_SIZE_MIN;
        cf.nSizeMax = FONTPICK_SIZE_MAX;

        BOOL fCancelled = FALSE;
        err = WIN32_FONT_PICKER::Process( this,
                                          &fCancelled,
                                          _pfontPicked,
                                          _plogfontPicked,
                                          &cf );
        if (err != NERR_Success)
        {
            DBGEOL( "ADMIN_APP::OnFontPickMenuSel: Process() error " << err );
            break;
        }

        if (fCancelled)
        {
            TRACEEOL( "ADMIN_APP::OnFontPickMenuSel: user cancelled" );
            break;
        }

        if (_pfontPicked == NULL)
        {
            _pfontPicked = new FONT( *_plogfontPicked );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   _pfontPicked == NULL
                || (err = _pfontPicked->QueryError()) != NERR_Success
               )
            {
                DBGEOL( "ADMIN_APP::OnFontPickMenuSel: FONT::ctor error "
                                << err );
                delete _pfontPicked;
                _pfontPicked = NULL;
                break;
            }
        }
        else
        {
            if ( (err = _pfontPicked->SetFont( *_plogfontPicked )) != NERR_Success )
            {
                DBGEOL( "ADMIN_APP::OnFontPickMenuSel: SetFont error " << err );
                break;
            }
        }

        OnFontPickChange( *_pfontPicked );

    } while (FALSE); // false loop

    if (err != NERR_Success)
    {
        ::MsgPopup( this, err );
    }
}


/*******************************************************************

    NAME:       ADMIN_APP::OnFontPickChange

    SYNOPSIS:   Subclasses should redefine this virtual to update the display
                font in all appropriate listboxes.

    HISTORY:
        JonN         23-Sep-1993     Created

********************************************************************/

VOID ADMIN_APP::OnFontPickChange( FONT & font )
{
    UNREFERENCED( font );
    DBGEOL( "ADMIN_APP::OnFontPickChange" );
}


ULONG ADMIN_APP::QueryHelpContext( enum HELP_OPTIONS helpOptions )
{
    UNREFERENCED( helpOptions );
    DBGEOL( "ADMIN_APP::QueryHelpContext" );

    return (ULONG)HC_NO_HELP;
}

VOID ADMIN_APP::OnRefresh()
{
    DBGEOL( "ADMIN_APP::OnRefresh" );
}

APIERR ADMIN_APP::OnRefreshNow( BOOL fClearFirst )
{
    UNREFERENCED( fClearFirst );
    DBGEOL( "ADMIN_APP::OnRefreshNow" );
    return NERR_Success;
}

AAPP_MENU_EXT * ADMIN_APP::LoadMenuExtension( const TCHAR * pszExtensionDll,
                                              DWORD         dwDelta )
{
    UNREFERENCED( pszExtensionDll );
    UNREFERENCED( dwDelta );
    DBGEOL( "ADMIN_APP::LoadMenuExtension - " << pszExtensionDll );
    return NULL;
}

APIERR ADMIN_APP::HandleFocusError( APIERR errPrev, HWND hwnd )
{
    UNREFERENCED( hwnd );
    return errPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\adminlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    adminlb.cxx
    ADMIN_LISTBOX and ADMIN_LBI module


    FILE HISTORY:
        rustanl     01-Jul-1991     Created
        rustanl     08-Aug-1991     Added mult sel support
        kevinl      12-Aug-1991     Added Refresh
        kevinl      04-Sep-1991     Code Rev Changes: JonN, RustanL, KeithMo,
                                                      DavidHov, ChuckC
        rustanl     09-Sep-1991     Removed OnUserAction
        kevinl      17-Sep-1991     Use new TIMER class
        kevinl      25-Sep-1991     Added Stoprefresh and DeleteRefreshInstance
        jonn        29-Mar-1992     Fixed AddRefreshItem(NULL)
        jonn        13-Oct-1993     Add ADMIN_SAVE_SELECTION

*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <adminlb.hxx>

#include <dbgstr.hxx>


DEFINE_MI2_NEWBASE( ADMIN_LISTBOX, BLT_LISTBOX,
                                   TIMER_CALLOUT );

/*******************************************************************

    NAME:      ADMIN_LBI::ADMIN_LBI

    SYNOPSIS:  ADMIN_LBI constructor

    HISTORY:
       rustanl     02-Jul-1991     Created
       kevinl      12-Aug-1991     Added _fRefreshed
       kevinl      04-Sep-1991     Changed _fRefreshed to _fCurrent

********************************************************************/

ADMIN_LBI::ADMIN_LBI() :
    _fCurrent ( FALSE ),
    _dItemAge ( 0 )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:      ADMIN_LBI::~ADMIN_LBI

    SYNOPSIS:  ADMIN_LBI destructor

    HISTORY:
       rustanl     02-Jul-1991     Created

********************************************************************/

ADMIN_LBI::~ADMIN_LBI()
{
    // nothing else to do
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::ADMIN_LISTBOX

    SYNOPSIS:  ADMIN_LISTBOX constructor

    ENTRY:     fMultSel -      Indicates whether or not the listbox
                               should be a mult sel listbox (extended
                               selection, actually).  Default is FALSE,
                               which indicates single sel.

    HISTORY:
       rustanl     01-Jul-1991     Created
       rustanl     19-Jul-1991     Added _paappwin
       beng        31-Jul-1991     Control error handling changed
       rustanl     08-Aug-1991     Added fMultSel parameter to allow
                                   listtbox to be mult sel
       kevinl      12-Aug-1991     Added _fRefreshInProgress

********************************************************************/

ADMIN_LISTBOX::ADMIN_LISTBOX( ADMIN_APP * paappwin, CID cid,
                             XYPOINT xy, XYDIMENSION dxy,
                             BOOL fMultSel, INT dAge )
    :  BLT_LISTBOX( paappwin, cid, xy, dxy,
                    WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER |
                    LBS_OWNERDRAWFIXED | LBS_NOTIFY|LBS_SORT |
                    LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT |
                    ( fMultSel ? LBS_EXTENDEDSEL : 0 )),
        TIMER_CALLOUT(),
        _timerFastRefresh( this, 1000 ),
        _paappwin( paappwin ),
        _fRefreshInProgress ( FALSE ),
        _fInvalidatePending ( FALSE ),
        _dMaxItemAge ( dAge )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::~ADMIN_LISTBOX

    SYNOPSIS:  ADMIN_LISTBOX destructor

    HISTORY:
       rustanl     01-Jul-1991     Created
       kevinl      12-Aug-1991     Added Refresh shutdown

********************************************************************/

ADMIN_LISTBOX::~ADMIN_LISTBOX()
{
    /* TurnOffRefresh might fail since DeleteRefreshInstance
     *  is a pure virtual.  Subclasses should already have
     *  turned off refresh in their destructors.
     */

    ASSERT( !_fRefreshInProgress );
}


/*******************************************************************

    NAME:       ADMIN_LISTBOX::OnTimerNotification

    SYNOPSIS:   Called every time

    ENTRY:      tid -       ID of timer that matured

    HISTORY:
        kevinl    17-Sep-1991     Created

********************************************************************/

VOID ADMIN_LISTBOX::OnTimerNotification( TIMER_ID tid )
{
    if ( _timerFastRefresh.QueryID() == tid )
    {
       if ( _fRefreshInProgress )       // Do we have a timer refresh
            OnFastTimer();              // running?
        return;
    }

    // call parent class
    TIMER_CALLOUT::OnTimerNotification( tid );
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::TurnOffRefresh

    SYNOPSIS:  This method stops a timer driven refresh.  This is
                the method that ADMIN_APP::StopRefresh should call.
                If a refresh is currently running then the method
                turns off the refresh timer and then calls the virtual
                method DeleteRefreshInstance which informs the user
                that they should remove the refresh specific data.
                Once this method is called, no further RefreshNext
                calls will be made without a call to
                CreateNewRefreshInstance.  Otherwise, it simply returns.

    HISTORY:
       kevinl     19-Aug-1991     Created
       kevinl     25-Sep-1991     Added call to DeleteRefreshInstance

********************************************************************/

VOID ADMIN_LISTBOX::TurnOffRefresh()
{
     if (!_fRefreshInProgress)                  // Refresh running?
         return;                                // No, Return

     _timerFastRefresh.Enable( FALSE );
     _fRefreshInProgress = FALSE;               // No refresh in progress

     DeleteRefreshInstance();                   // Delete Refresh Data
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::OnFastTimer

    SYNOPSIS:  Called by the fast refresh timer.  It will then
                call RefreshNext so that the next portion of the
                listbox can be updated.  It will stop the refresh
                if either all of the data has been processed or
                an error is reported by RefreshNext.

    HISTORY:
       kevinl     19-Aug-1991     Created

********************************************************************/

VOID ADMIN_LISTBOX::OnFastTimer()
{
    APIERR err = RefreshNext(); // Process the next piece

    if ( _fInvalidatePending )
    {
        SetRedraw( TRUE );                      // Allow redraws
         Invalidate();
         _fInvalidatePending = FALSE;
    }

    switch ( err )
    {
    case NERR_Success:                  // All data processed
        TurnOffRefresh();               // Stop the refresh timer
        PurgeStaleItems();                      // Delete old items

        break;

    case ERROR_MORE_DATA:               // Wait for the next timer
        return;

    default:                            // Error, or unknown case
        StopRefresh();                  // Stop the refresh
        break;
    }

    //
    // Refresh the extensions.  Note that the caller of RefreshNow is
    // responsible for doing this himself, only periodic refresh
    // completion is handled here.
    //

    _paappwin->CompletePeriodicRefresh();

}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::MarkAllAsStale

    SYNOPSIS:  Simple loops through the listbox items and resets
                the refreshed flags to UnRefreshed.  So that we
                always maintain valid data in the listbox.

    HISTORY:
       kevinl     19-Aug-1991     Created

********************************************************************/

VOID ADMIN_LISTBOX::MarkAllAsStale()
{
    ADMIN_LBI * plbi;

    INT clbe = QueryCount();

    for (INT i = 0; i < clbe; i++)
    {
        plbi = (ADMIN_LBI *)QueryItem( i );
         UIASSERT( plbi != NULL );
         plbi->MarkAsStale();
    }
}


/*******************************************************************

    NAME:       ADMIN_LISTBOX::PurgeStaleItems

    SYNOPSIS:   Loops through the listbox and depending on the
                refreshed flag will either:
                    Flag value                  Action
                -------------------------------------------
                   Refreshed            MarkAsUnrefreshed
                                        So subsequent refreshes
                                        will update it properly
                   UnRefreshed          Remove the item from
                                        the listbox.

    NOTES:      The basic algorithm is outlined below:

                for all items in the listbox,
                    if the item is current,
                        set its age to 0
                        mark the item as stale
                    else
                        increment its age
                        if the age is > the threshold,
                            delete the item
                        endif
                    endif
                endfor


    HISTORY:
       kevinl     19-Aug-1991     Created
       kevinl     04-Sep-1991     Code review changes

********************************************************************/

VOID ADMIN_LISTBOX::PurgeStaleItems()
{
    ADMIN_LBI * plbi;
    BOOL fItemDeleted = FALSE;

    SetRedraw( FALSE );                 // No flicker

    INT clbe = QueryCount();                    // How many items?

    for (INT i = 0; i < clbe; i++)
    {
        plbi = (ADMIN_LBI *)QueryItem( i );     // Get the lbi

         UIASSERT( plbi != NULL );

         if ( plbi->IsCurrent() )               // Refreshed?
         {
             plbi->SetAge( 0 );                 // Reset the age
             plbi->MarkAsStale();               // Yes, Mark it.
         }
         else
         {
             plbi->SetAge( plbi->QueryAge() + 1 );      // Increment age
             if ( plbi->QueryAge() > _dMaxItemAge )
             {
                 DeleteItem( i );               // No, Delete it.
                 i--;                           // Adjust the count and
                 clbe--;                        // index.  Because delete
                                                // item will adjust the
                                                // listbox immediately.
                 fItemDeleted = TRUE;           // Go ahead and invalidate
                                                // the listbox
             }
         }
    }

    SetRedraw( TRUE );                          // Allow painting

    if ( fItemDeleted || _fInvalidatePending )
        Invalidate( TRUE );                           // Force the updates.
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::RefreshNow

    SYNOPSIS:  Will force a refresh to occur, and will not yield
                until all of the data has been processed.

    RETURNS:   An API error, which is NERR_Success on success

    HISTORY:
       kevinl     19-Aug-1991     Created

********************************************************************/

APIERR ADMIN_LISTBOX::RefreshNow()
{
    AUTO_CURSOR autocur;                // Hourglass.

    //
    // Stop the timer refresh if one is running.  NOTE:
    // that StopRefresh will do nothing if a timer is not running.
    //
    StopRefresh();                      // Stop the refresh

    // Let the listbox know we are going to refresh

    APIERR err;

    if ((err = CreateNewRefreshInstance()) != NERR_Success)
    {
        DeleteRefreshInstance();        // Delete Refresh Instance
        return err;
    }

    SetRedraw( FALSE );         // No Flicker

    _fInvalidatePending = FALSE;

    do
    {
        err = RefreshNext();            // Process the next piece
    }
    while ( err == ERROR_MORE_DATA );

    DeleteRefreshInstance();            // Delete Refresh Instance

    switch ( err )
    {
    case NERR_Success:          // All data has been successfully
                                // processed.
        PurgeStaleItems();      // Remove old items.
                                // Will SetRedraw( TRUE );
        return NERR_Success;

    default:
        MarkAllAsStale();       // Start over.
        SetRedraw( TRUE );
        return err;

    }
}


/*******************************************************************

    NAME:       ADMIN_LISTBOX::KickOffRefresh

    SYNOPSIS:   This method starts a timer driven refresh.

        This is the method that periodic refreshes should call.
        If a refresh is currently running then the method
        simply returns.  Otherwise, it tries to start the refresh.

    HISTORY:
       kevinl     19-Aug-1991     Created

********************************************************************/

APIERR ADMIN_LISTBOX::KickOffRefresh()
{

    if (_fRefreshInProgress)            // Is a timer refresh running?
        return NERR_Success;            // if so, just exit

    // Let the listbox know we plan to refresh.
    // If this call succeeds then try to start the timer.
    //
    // We can reuse err for both calls since we only get to the second
    // assignment if the call to CreateNewRefreshInstance succeeds.

    APIERR err;

    if ((err = CreateNewRefreshInstance()) == NERR_Success)
    {
        _timerFastRefresh.Enable( TRUE );
        _fRefreshInProgress = TRUE;     // Set refresh in progress
    }
    else
    {
        DeleteRefreshInstance();        // Delete refresh instance
        _fRefreshInProgress = FALSE;    // Set NO refresh in progress
    }

    _fInvalidatePending = FALSE;

    return err;
}


/*******************************************************************

    NAME:       ADMIN_LISTBOX::StopRefresh

    SYNOPSIS:   This method stops a timer driven refresh.

        This is the method that ADMIN_APP::StopRefresh should call.
        If a refresh is currently running then the method
        turns off the refresh timer and then calls MarkAllAsStale
        to reset the listbox entries.  Once this method is
        called, no further RefreshNext calls will be made
        without a call to CreateNewRefreshInstance.  Otherwise,
        it simply returns.

    HISTORY:
       kevinl     25-Sep-1991     Created

********************************************************************/

VOID ADMIN_LISTBOX::StopRefresh()
{
    if (!_fRefreshInProgress)
        return;

    TurnOffRefresh();                   // Turn off refresh if running

    MarkAllAsStale();                   // Reset listbox items
}


/*******************************************************************

    NAME:      ADMIN_LISTBOX::AddRefreshItem

    SYNOPSIS:

    HISTORY:
       kevinl     19-Aug-1991     Created
       jonn       29-Mar-1992     Fixed AddRefreshItem(NULL)

********************************************************************/

APIERR ADMIN_LISTBOX::AddRefreshItem ( ADMIN_LBI * plbi )
{
    INT iRet;
    APIERR err = NERR_Success;

    if ( plbi == NULL || (plbi->QueryError() != NERR_Success) )
        return AddItem( plbi );

    plbi->MarkAsCurrent();

    if ( (iRet = FindItem( *plbi )) < 0 )
    {                                   // Not Found
        SetRedraw( FALSE );
         _fInvalidatePending = TRUE;

        if ( AddItem( plbi ) < 0 )
        {
            //  Assume out of memory
            DBGEOL("ADMIN LISTBOX: AddItem failed in AddRefreshItem");
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else                                // Found - Now check information
    {
        ADMIN_LBI * plbiTemp = (ADMIN_LBI *)QueryItem( iRet );

        UIASSERT( plbiTemp != NULL );

        plbiTemp->MarkAsCurrent();

        if ( !(plbiTemp->CompareAll( plbi )) )
        {
            if ( (err = ReplaceItem( iRet, plbi)) == NERR_Success)
            {
                if ( !_fInvalidatePending )
                    InvalidateItem( iRet );
            }
        }
        else
           delete plbi;
    }

    return err;

}


/*******************************************************************

    NAME:       ADMIN_LISTBOX::CD_VKey

    SYNOPSIS:   Called whenever a listbox with the LBS_WANTKEYBOARDINPUT
                style receives a WM_KEYDOWN message.

    ENTRY:      nVKey - The virtual-key code of the key which the user
                    pressed.

                nLastPos - Index of the current caret position.

    RETURN:     -2  = the control did all processing of the key press.
                -1  = the listbox should perform default action.
                >=0 = the index of an item to act upon.

    HISTORY:
        KeithMo      12-May-1993     Created

********************************************************************/

INT ADMIN_LISTBOX::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    if( nVKey == VK_F1 )
    {
        //  F1 pressed, invoke app help.
        _paappwin->Command( WM_COMMAND, IDM_HELP_CONTENTS, 0 );
        return -2;      // take no further action
    }

    return BLT_LISTBOX::CD_VKey( nVKey, nLastPos );
}


/*******************************************************************

    NAME:      SAVE_SELECTION::SAVE_SELECTION

    SYNOPSIS:  SAVE_SELECTION constructor

    HISTORY:
        jonn        13-Oct-1993 Created

********************************************************************/

SAVE_SELECTION::SAVE_SELECTION( LISTBOX * plb )
    : BASE(),
      _plb( plb ),
      _nlsFocusItem(),
      _strlistSelectedItems()
{
    ASSERT( plb != NULL && plb->QueryError() == NERR_Success );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   (err = _nlsFocusItem.QueryError()) != NERR_Success
       )
    {
        DBGEOL( "SAVE_SELECTION::ctor: error " << err );
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:      SAVE_SELECTION::~SAVE_SELECTION

    SYNOPSIS:  SAVE_SELECTION destructor

    HISTORY:
        jonn        13-Oct-1993 Created

********************************************************************/

SAVE_SELECTION::~SAVE_SELECTION()
{
    // nothing else to do
}


/*******************************************************************

    NAME:      SAVE_SELECTION::Remember

    SYNOPSIS:  Remember selected items and focus item (multsel)

    HISTORY:
        jonn        13-Oct-1993 Created

********************************************************************/

APIERR SAVE_SELECTION::Remember()
{
    APIERR err = NERR_Success;

    do { // false loop

        if (QueryListbox()->IsMultSel())
        {
            INT iCaretIndex = QueryListbox()->QueryCaretIndex();
            DBGEOL( "SAVE_SELECTION::Remember: caret index " << iCaretIndex );
            err = _nlsFocusItem.CopyFrom( QueryItemIdent( iCaretIndex ) );
        }
        if (err != NERR_Success)
            break;

        _strlistSelectedItems.Clear();

        /* templated from SELECTION */

        INT clbiSelection = QueryListbox()->QuerySelCount();

        if ( clbiSelection <= 0 )
            break;

        BUFFER bufSelection( clbiSelection * sizeof(UINT) );
        err = bufSelection.QueryError();
        if (err != NERR_Success)
            break;

        INT * piSelection = (INT *)bufSelection.QueryPtr();
        ASSERT( piSelection != NULL );

        err = QueryListbox()->QuerySelItems( piSelection, clbiSelection );
        if ( err != NERR_Success )
            break;

        INT iSelection;
        for ( iSelection = 0; iSelection < clbiSelection; iSelection++ )
        {
            INT iItem = piSelection[ iSelection ];
            ASSERT( iItem >= 0 );
            const TCHAR * pchIdent = QueryItemIdent( iItem );
            NLS_STR * pnlsItem = new NLS_STR( pchIdent );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pnlsItem == NULL
                || (err = pnlsItem->QueryError()) != NERR_Success
                || (err = _strlistSelectedItems.Add( pnlsItem )) != NERR_Success
               )
            {
                delete pnlsItem;
                break;
            }
        }
        if (err != NERR_Success)
            break;
    } while (FALSE); // false loop

#ifdef DEBUG
    if (err != NERR_Success)
    {
        DBGEOL( "SAVE_SELECTION::Remember: error " << err );
    }
#endif // DEBUG

    return err;
}


/*******************************************************************

    NAME:      SAVE_SELECTION::Restore

    SYNOPSIS:  Remember selected items and focus item (multsel)

    HISTORY:
        jonn        13-Oct-1993 Created

********************************************************************/

APIERR SAVE_SELECTION::Restore()
{
    APIERR err = NERR_Success;

    QueryListbox()->RemoveSelection();

    do { // false loop

        ITER_STRLIST itersl( _strlistSelectedItems );
        NLS_STR * pnlsItemIdent = NULL;

        while ( (pnlsItemIdent = itersl.Next()) != NULL )
        {
            ASSERT( pnlsItemIdent->QueryError() == NERR_Success );

            INT iIndex = FindItemIdent( pnlsItemIdent->QueryPch() );
            if (iIndex < 0)
                continue;

            QueryListbox()->SelectItem( iIndex );
        }
        if (err != NERR_Success)
            break;

        if (QueryListbox()->IsMultSel())
        {
            INT iCaretIndex = FindItemIdent( _nlsFocusItem.QueryPch() );
            DBGEOL( "SAVE_SELECTION::Restore: caret index " << iCaretIndex );
            if (iCaretIndex >= 0)
            {
                QueryListbox()->SetCaretIndex( iCaretIndex );
            }
        }
    } while (FALSE); // false loop

#ifdef DEBUG
    if (err != NERR_Success)
    {
        DBGEOL( "SAVE_SELECTION::Restore: error " << err );
    }
#endif // DEBUG

    return err;
}


/*******************************************************************

    NAME:      ADMIN_SAVE_SELECTION::QueryItemIdent

    SYNOPSIS:  return name of item

    HISTORY:
        jonn        13-Oct-1993 Created

********************************************************************/

const TCHAR * ADMIN_SAVE_SELECTION::QueryItemIdent( INT i )
{
    const TCHAR * pchReturn = NULL;

    ADMIN_LBI * plbi = (ADMIN_LBI *)(QueryListbox()->QueryItem( i ));
    if ( plbi != NULL && plbi->QueryError() == NERR_Success )
    {
        pchReturn = plbi->QueryName();
    }

    return pchReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\aini.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    aini.cxx
    ADMIN_INI class implementation

    This class reads and writes application settings that are stored
    between invocations of the apps.


    BUGBUG.  This file needs to be modified to work with the registry.
    However, clients of this class shouldn't have to be modified.


    FILE HISTORY:
        rustanl     09-Sep-1991     Created
        beng        31-Mar-1992     Purged of evil wsprintfs
*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <uibuffer.hxx>
#include <string.hxx>
#include <strnumer.hxx>

#include <aini.hxx>

#define SZ_ADMININIFILE SZ("NTNET.INI")


/*******************************************************************

    NAME:       ADMIN_INI::ADMIN_INI

    SYNOPSIS:   ADMIN_INI constructor

    ENTRY:      pszApplication -        Pointer to name of application

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

ADMIN_INI::ADMIN_INI( const TCHAR * pszApplication )
    :   BASE(),
        _nlsApplication( pszApplication )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ( err = _nlsApplication.QueryError()) != NERR_Success ||
         ( err = _nlsFile.QueryError()) != NERR_Success       )
    {
        ReportError( err );
        return;
    }

    //  Build the file name.
    //  BUGBUG.  This uses the the Win root.  Is that the right place?
    _nlsFile = SZ_ADMININIFILE;
    err = _nlsFile.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       ADMIN_INI::~ADMIN_INI

    SYNOPSIS:   ADMIN_INI destructor

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

ADMIN_INI::~ADMIN_INI()
{
    // do nothing else
}


/*******************************************************************

    NAME:       ADMIN_INI::SetAppName

    SYNOPSIS:   Sets the application name

    ENTRY:      pszApplication -        Pointer to application name

    RETURNS:    An API return return, which is NERR_Success on success

    HISTORY:
        rustanl     12-Sep-1991 Created
        beng        23-Oct-1991 Use NLS_STR::CopyFrom

********************************************************************/

APIERR ADMIN_INI::SetAppName( const TCHAR * pszApplication )
{
    return _nlsApplication.CopyFrom( pszApplication );
}


/*******************************************************************

    NAME:       ADMIN_INI::W_Write

    SYNOPSIS:   Write worker function

    ENTRY:      pszKey -        Pointer to key name
                pszValue -      Pointer to value

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     10-Sep-1991     Created

********************************************************************/

APIERR ADMIN_INI::W_Write( const TCHAR * pszKey, const TCHAR * pszValue )
{
    UIASSERT( _nlsApplication.strlen() > 0 );

    if ( ::WritePrivateProfileString( (TCHAR *)_nlsApplication.QueryPch(),
                                      (TCHAR *)pszKey,
                                      (TCHAR *)pszValue,
                                      (TCHAR *)_nlsFile.QueryPch()))
    {
        return NERR_Success;
    }

    // make up an error
    return ERROR_GEN_FAILURE;
}


/*******************************************************************

    NAME:       ADMIN_INI::Write

    SYNOPSIS:   Writes a value to the ini file

    ENTRY:      pszKey -        Pointer to key name

                pszValue -      Specifies the value to be written (pointer
                    OR          to string, or integer)
                nValue -

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     10-Sep-1991 Created
        beng        23-Oct-1991 Win32 conversion
        beng        31-Mar-1992 Removed wsprintf

********************************************************************/

APIERR ADMIN_INI::Write( const TCHAR * pszKey, const TCHAR * pszValue )
{
    return W_Write( pszKey, pszValue );

}

APIERR ADMIN_INI::Write( const TCHAR * pszKey, INT nValue )
{
    DEC_STR nlsValue( nValue );
    if (!nlsValue)
        return nlsValue.QueryError();

    return W_Write( pszKey, nlsValue.QueryPch() );
}


/*******************************************************************

    NAME:       ADMIN_INI::W_Read

    SYNOPSIS:   Read worker function

    ENTRY:      pszKey -        Pointer to key name
                pnls -          Pointer to NLS_STR which will receive
                                the read value
                pszDefault -    Default value to be used if key not
                                found or if an error occurs while
                                reading the value from the file

    RETURNS:    An API return value, which is NERR_Success on success

    NOTES:      The method may fail to use the default value, so
                callers must check the return value of the method

    HISTORY:
        rustanl     10-Sep-1991     Created
        beng        30-Apr-1992     API changes
        jonn        01-Sep-1993     buffering strategy

********************************************************************/

#define ADMIN_INI_FIRST_READ_SIZE       (80)
#define ADMIN_INI_MAX_READ_SIZE         (10240)

APIERR ADMIN_INI::W_Read( const TCHAR * pszKey,
                          NLS_STR * pnls,
                          const TCHAR * pszDefault ) const
{
    UIASSERT( pnls != NULL );

    UIASSERT( _nlsApplication.strlen() > 0 );

    // optimization for short strings
    TCHAR szBuf[ ADMIN_INI_FIRST_READ_SIZE ];

    TCHAR * pchBuffer = szBuf;
    DWORD cchBuffer = sizeof(szBuf) / sizeof(TCHAR);
    BUFFER buf(0);
    APIERR err = buf.QueryError();
    while ( err == NERR_Success )
    {
        INT n = ::GetPrivateProfileString( (TCHAR *)_nlsApplication.QueryPch(),
                                           (TCHAR *)pszKey,
                                           (TCHAR *)pszDefault,
                                           pchBuffer,
                                           cchBuffer,
                                           (TCHAR *)_nlsFile.QueryPch());

        if ( n < (INT)cchBuffer-1 ) // got entire string
        {
            break;
        }

        if ( (cchBuffer = cchBuffer * 2) > ADMIN_INI_MAX_READ_SIZE )
        {
            DBGEOL( "ADMIN_INI::W_Read(): complete string is too long, truncating" );
            break;
        }

        err = buf.Resize( cchBuffer * sizeof(TCHAR) );
        if (err == NERR_Success)
        {
            pchBuffer = (TCHAR *)buf.QueryPtr();
        }
    }

    return (err != NERR_Success) ? err : pnls->CopyFrom( pchBuffer );

}


/*******************************************************************

    NAME:       ADMIN_INI::Read

    SYNOPSIS:   Reads a value from the ini file

    ENTRY:      pszKey -        Pointer to key name

                pnls -          Pointer to object receiving the read
                    OR          value (an NLS_STR or an integer)
                pnValue -

                pszDefault -    Default value to be used if value was not
                    OR          found or if an error occurred.
                nDefault -

    RETURNS:    An API return value, which is NERR_Success on success

    NOTES:      The method may fail to use the default value, so
                callers must check the return value of the method

    HISTORY:
        rustanl     10-Sep-1991 Created
        beng        23-Oct-1991 Win32 conversion
        beng        31-Mar-1992 Removed wsprintf

********************************************************************/

APIERR ADMIN_INI::Read( const TCHAR * pszKey,
                        NLS_STR *     pnls,
                        const TCHAR * pszDefault ) const
{
    return W_Read( pszKey, pnls, pszDefault );
}

APIERR ADMIN_INI::Read( const TCHAR * pszKey,
                        INT * pnValue,
                        INT nDefault ) const
{
    UIASSERT( pnValue != NULL );

    NLS_STR nlsValue;
    if (!nlsValue)
        return nlsValue.QueryError();

    DEC_STR nlsDefault(nDefault);
    if (!nlsDefault)
        return nlsDefault.QueryError();

    APIERR err = W_Read( pszKey, &nlsValue, nlsDefault.QueryPch() );
    if ( err != NERR_Success )
        return err;

    *pnValue = nlsValue.atoi();

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\piggylb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    piggylb.cxx
    PIGGYBACK_LISTBOX and PIGGYBACK_LBI implementation

    This listbox piggybacks onto an ADMIN_SELECTION, from which
    it gets its items.  The ADMIN_SELECTION object is thus
    assumed to stay around for the life of this listbox and all
    its listbox items.  Moreover, the ADMIN_SELECTION is assumed
    not to change during that time.


    FILE HISTORY:
        rustanl     16-Aug-1991     Created
        KeithMo     06-Oct-1991     Win32 Conversion.

*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#include <dbgstr.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_CC
#include <blt.hxx>

#include <piggylb.hxx>



/*******************************************************************

    NAME:       PIGGYBACK_LBI::PIGGYBACK_LBI

    SYNOPSIS:   PIGGYBACK_LBI constructor

    ENTRY:      asel -      ADMIN_SELECTION onto which to piggyback
                i -         Index into given ADMIN_SELECTION

    NOTES:      It is assumed that asel will exist throughout the
                life of this LBI, and that it will not change during
                this time.

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

PIGGYBACK_LBI::PIGGYBACK_LBI( const ADMIN_SELECTION & asel, INT i )
    :   LBI(),
	_pszName( asel.QueryItemName( i ) ),
        _pLBI( (const LBI *)asel.QueryItem( i ))
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pLBI != NULL );
}


/*******************************************************************

    NAME:       PIGGYBACK_LBI::~PIGGYBACK_LBI

    SYNOPSIS:   PIGGYBACK_LBI destructor

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

PIGGYBACK_LBI::~PIGGYBACK_LBI()
{
    //  do nothing
}


/*******************************************************************

    NAME:       PIGGYBACK_LBI::Paint

    SYNOPSIS:   Paints the LBI

    ENTRY:      plb -           Pointer to listbox where LBI is
                hdc -           Handle to device context to be used
                                for drawing
                prect -         Pointer to rectangle in which to draw
                pGUILTT -       Pointer to GUILTT information

    HISTORY:
        rustanl     16-Aug-1991 Created
        KeithMo     06-Oct-1991 Now takes a const RECT *.
        beng        08-Nov-1991 Unsigned widths
        beng        22-Apr-1992 Change in LBI::Paint protocol

********************************************************************/

VOID PIGGYBACK_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                           GUILTT_INFO * pGUILTT ) const
{
    DM_DTE * pdmdte = ((const PIGGYBACK_LISTBOX *)plb)->QueryDmDte();

    UINT adxColWidths[ 2 ];
    adxColWidths[ 0 ] = pdmdte->QueryDisplayWidth();
    adxColWidths[ 1 ] = COL_WIDTH_AWAP;

    STR_DTE strdte( _pszName );

    DISPLAY_TABLE dtab( 2, adxColWidths );
    dtab[ 0 ] = pdmdte;
    dtab[ 1 ] = &strdte;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       PIGGYBACK_LBI::Compare

    SYNOPSIS:   Compares two PIGGYBACK_LBI objects

    ENTRY:      plbi -      Pointer to the other PIGGYBACK_LBI object

    RETURNS:    Standard compare return value

    NOTES:      It is assumed that the given plbi is really a pointer
                to a PIGGYBACK_LBI

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

INT PIGGYBACK_LBI::Compare( const LBI * plbi ) const
{
    return QueryRealLBI()->Compare( ((const PIGGYBACK_LBI *)plbi)->QueryRealLBI() );
}


/*******************************************************************

    NAME:       PIGGYBACK_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the first character of the listbox item

    RETURNS:    Said character

    HISTORY:
        rustanl     16-Aug-1991 Created
        beng        23-Oct-1991 Use ALIAS_STR

********************************************************************/

WCHAR PIGGYBACK_LBI::QueryLeadingChar() const
{
    return QueryRealLBI()->QueryLeadingChar();
}


/*******************************************************************

    NAME:       PIGGYBACK_LISTBOX::PIGGYBACK_LISTBOX

    SYNOPSIS:   PIGGYBACK_LISTBOX constructor

    ENTRY:      powin -     Pointer to owner window for listbox
                cid -       Control ID of listbox
                asel -      ADMIN_SELECTION onto which to piggyback
                dmid -      Display map ID to be used for all items
                            in listbox
                fReadOnly - Specifies whether or not listbox should be
                            read-only

    NOTES:      It is assumed that asel will exist throughout the
                lives of this listbox and its items, and that it will
                not change during this time.

                asel is allowed to be passed in as an unproperly
                constructed ADMIN_SELECTION.  This is because some
                callers may not have the opportunity to check
                asel's construction before constructing this object.
                If asel was not constructed properly, this constructor
                will fail with the same error, but will not assert
                out.

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

PIGGYBACK_LISTBOX::PIGGYBACK_LISTBOX( OWNER_WINDOW * powin,
                                      CID cid,
                                      const ADMIN_SELECTION & asel,
                                      DMID dmid,
                                      BOOL fReadOnly )
    :   BLT_LISTBOX( powin, cid, fReadOnly ),
        _pdmiddte( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    // BUGBUG - This is left here only so we know that the asel has
    // been properly constructed before constructing the listbox.
    APIERR err = asel.QueryError();
    if ( err != NERR_Success )
    {
        //  Allow this (i.e., don't assert out).  However, don't
        //  construct the listbox either.
        ReportError( err );
        return;
    }

    if ( dmid != 0 ) // BUGBUG better way to do this
    {
	_pdmiddte = new DMID_DTE( dmid );
	if ( _pdmiddte == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = _pdmiddte->QueryError();

        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }

}


/*******************************************************************

    NAME:       PIGGYBACK_LISTBOX::~PIGGYBACK_LISTBOX

    SYNOPSIS:   PIGGYBACK_LISTBOX destructor

    HISTORY:
        rustanl     16-Aug-1991     Created
        o-SimoP     02-Dec-1991     added delete
********************************************************************/

PIGGYBACK_LISTBOX::~PIGGYBACK_LISTBOX()
{
    delete _pdmiddte;
    _pdmiddte = NULL;
}


/*******************************************************************

    NAME:       PIGGYBACK_LISTBOX::Fill

    SYNOPSIS:   Fills the PIGGYBACK_LISTBOX

    ENTRY:
                asel -      ADMIN_SELECTION onto which to piggyback

    NOTES:      It is assumed that asel will exist throughout the
                lives of this listbox and its items, and that it will
                not change during this time.

                asel is allowed to be passed in as an unproperly
                constructed ADMIN_SELECTION.  This is because some
                callers may not have the opportunity to check
                asel's construction before constructing this object.
                If asel was not constructed properly, this constructor
                will fail with the same error, but will not assert
                out.

    HISTORY:
        thomaspa     04-May-1992     Created

********************************************************************/

APIERR PIGGYBACK_LISTBOX::Fill( const ADMIN_SELECTION & asel )
{
    APIERR err = asel.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    INT c = asel.QueryCount();
    for ( INT i = 0; i < c; i++ )
    {
        //  No error checking is done on the following 'new' because
        //  AddItem is guaranteed to do this for us.

	PIGGYBACK_LBI * plbi = GetPiggyLBI( asel, i );

        if ( AddItem( plbi) < 0 )
        {
            //  Assume memory failure
            DBGEOL("PIGGYBACK_LISTBOX ct:  AddItem failed");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return NERR_Success;
}

/*******************************************************************

    NAME:       PIGGYBACK_LISTBOX::GetPiggyLBI

    SYNOPSIS:   constructs an LBI to be added to the PIGGYBACK_LISTBOX
		This can be replaced by subclasses.

    HISTORY:
        thomaspa    02-May-1992     Created
********************************************************************/

PIGGYBACK_LBI * PIGGYBACK_LISTBOX::GetPiggyLBI( const ADMIN_SELECTION & asel,
						INT i )
{
	// Default implementation just creates a PIGGYBACK_LBI
	return new PIGGYBACK_LBI( asel, i );
}


/*******************************************************************

    NAME:       PIGGYBACK_LISTBOX::QueryDmDte

    SYNOPSIS:   Returns pointer to display map DTE to be painted
                in each listbox item that this listbox contains.

    RETURNS:    Said pointer.

    NOTES:      Although this method could be called by anyone, it
                is provided to acommodate PIGGYBACK_LBI objects.

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

DM_DTE * PIGGYBACK_LISTBOX::QueryDmDte( INT i ) const
{
    // Default Implementation
    UNREFERENCED( i );
    return _pdmiddte;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\asel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    asel.cxx
    ADMIN_SELECTION implementation


    FILE HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support
        rustanl     12-Aug-1991     Make use of proper BLT mult sel support
        rustanl     16-Aug-1991     Added fAll parameter
        jonn        09-Mar-1992     Added ADMIN_SELECTION::QueryItem()

*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <dbgstr.hxx>

#include <adminlb.hxx>
#include <asel.hxx>


/*******************************************************************

    NAME:       ADMIN_SELECTION::ADMIN_SELECTION

    SYNOPSIS:   ADMIN_SELECTION constructor

    ENTRY:      alb -       Listbox which contains the items of
                            interest
                fAll -      Indicates whether or not all listbox items
                            in the given listbox are to be used in
                            the ADMIN_SELECTION, or if only those
                            items selected should.

                            TRUE means use all items.
                            FALSE means use only selected items.

                            Default value is FALSE.

    HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support
        rustanl     12-Aug-1991     Make use of proper BLT mult sel support
        rustanl     16-Aug-1991     Added fAll parameter

********************************************************************/

ADMIN_SELECTION::ADMIN_SELECTION( ADMIN_LISTBOX & alb,
                                  BOOL fAll )
    :   _alb( alb ),
        _clbiSelection( 0 ),
        _piSelection( NULL ),
        _fAll( fAll )
{
    // This _must_ be done before any return statement, since the dtor
    // will always UnlockRefresh().
    _alb.LockRefresh();

    if ( QueryError() != NERR_Success )
        return;

    if ( _fAll )
    {
        /* CODEWORK QueryCount() shold ideally return UINT */
        _clbiSelection = (UINT)alb.QueryCount();
    }
    else
    {
        /* CODEWORK QuerySelCount() shold ideally return UINT */
        _clbiSelection = (UINT)alb.QuerySelCount();

        if ( _clbiSelection > 0 )
        {
            _piSelection = new UINT[ _clbiSelection ];
            if ( _piSelection == NULL )
            {
                DBGEOL("ADMIN_SELECTION ct:  Out of memory");
                ReportError( ERROR_NOT_ENOUGH_MEMORY );
                return;
            }

            /* CODEWORK QuerySelItems should ideally work with UINT */
            APIERR err = _alb.QuerySelItems(
                (INT *)_piSelection,
                (INT)_clbiSelection
                );
            if ( err != NERR_Success )
            {
                ReportError( err );
                return;
            }
        }
    }
}


/*******************************************************************

    NAME:       ADMIN_SELECTION::~ADMIN_SELECTION

    SYNOPSIS:   ADMIN_SELECTION destructor

    HISTORY:
        rustanl     07-Aug-1991     Created

********************************************************************/

ADMIN_SELECTION::~ADMIN_SELECTION()
{
    // This _must_ be done before any return statement, since the ctor
    // will always LockRefresh().
    _alb.UnlockRefresh();

    delete _piSelection;
    _piSelection = NULL;
}


/*******************************************************************

    NAME:       ADMIN_SELECTION::QueryItem

    SYNOPSIS:   Returns a selected item

    ENTRY:      i -     A valid index into the pool of items in the selection

    RETURNS:    A pointer to the name of the specified item

    HISTORY:
        jonn        09-Mar-1992     Created

********************************************************************/

const ADMIN_LBI * ADMIN_SELECTION::QueryItem( UINT i ) const
{
    UIASSERT( i < QueryCount() );

    if ( ! _fAll )
        i = _piSelection[ i ];

    return (ADMIN_LBI *)_alb.QueryItem( i );
}


/*******************************************************************

    NAME:       ADMIN_SELECTION::QueryItemName

    SYNOPSIS:   Returns the name of a selected item

    ENTRY:      i -     A valid index into the pool of items in the selection

    RETURNS:    A pointer to the name of the specified item

    HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support
        rustanl     16-Aug-1991     Added support for _fAll parameter
        jonn        09-Mar-1992     Uses QueryItem

********************************************************************/

const TCHAR * ADMIN_SELECTION::QueryItemName( UINT i ) const
{
    return QueryItem( i )->QueryName();
}


/*******************************************************************

    NAME:       ADMIN_SELECTION::QueryCount

    SYNOPSIS:   Returns the number of items in the selection

    RETURNS:    The number of items in the selection

    HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support

********************************************************************/

UINT ADMIN_SELECTION::QueryCount() const
{
    return _clbiSelection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\startdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    startdlg.cxx
    Admin app startup dialog implementation


    FILE HISTORY:
        rustanl     05-Sep-1991     Created

*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uimisc.hxx>

#include <adminapp.hxx>
#include <startdlg.hxx>


/*  Minimum time to display the startup dialog in milliseconds.
 *  Use immediately.
 */
#define MIN_ADMINAPP_STARTUP_WAIT_TIME      (0)



DEFINE_MI2_NEWBASE( STARTUP_DIALOG, DIALOG_WINDOW, TIMER_CALLOUT );



/*******************************************************************

    NAME:       STARTUP_DIALOG::STARTUP_DIALOG

    SYNOPSIS:   STARTUP_DIALOG constructor

    ENTRY:      paapp -             Pointer to parent window
                pszResourceName -   Pointer to name of startup dialog
                                    resource name.  This dialog should
                                    contain no buttons.

    HISTORY:
        rustanl     05-Sep-1991 Created
        beng        21-Feb-1992 Remove BUGBUG

********************************************************************/

STARTUP_DIALOG::STARTUP_DIALOG( ADMIN_APP * paapp,
                                const TCHAR * pszResourceName )
    :   DIALOG_WINDOW(pszResourceName, paapp->QueryHwnd()),
        _ulStartTime( ::QueryCurrentTimeStamp()),
        _timer( this, MIN_ADMINAPP_STARTUP_WAIT_TIME )
{
    if ( QueryError() != NERR_Success )
        return;

    //  Center the startup dialog with respect to the application window.

    INT dxMain;
    INT dyMain;
    paapp->QuerySize( &dxMain, &dyMain );

    INT dx;
    INT dy;
    QuerySize( &dx, &dy );

    XYPOINT xy = paapp->QueryPos();

    xy.SetX( xy.QueryX() + ( dxMain - dx ) / 2 );
    xy.SetY( xy.QueryY() + ( dyMain - dy ) / 2 );

    SetPos( xy, FALSE );

    //  Although unconventional for a dialog, this dialog is displayed at
    //  this time.  The reason is that this dialog is never accepts any
    //  user input, and will be dismissed as soon as Process gets called.
    Show();

    // Force immediate painting
    RepaintNow();
}


/*******************************************************************

    NAME:       STARTUP_DIALOG::~STARTUP_DIALOG

    SYNOPSIS:   STARTUP_DIALOG destructor

    HISTORY:
        rustanl     05-Sep-1991     Created

********************************************************************/

STARTUP_DIALOG::~STARTUP_DIALOG()
{
    // nothing else to do
}


/*******************************************************************

    NAME:       STARTUP_DIALOG::OnOK

    SYNOPSIS:   Handles what happens if user hits Enter to close
                the dialog

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     05-Sep-1991     Created

********************************************************************/

BOOL STARTUP_DIALOG::OnOK()
{
    return TRUE;            // Message was handled:  it was ignored
}


/*******************************************************************

    NAME:       STARTUP_DIALOG::OnTimerNotification

    SYNOPSIS:   Receives a timer as soon as the message loop is started.
                Then, dismisses the dialog.  This has the effect of
                dismissing the dialog as soon as Process is called.

    ENTRY:      tid -       ID of timer that matured

    HISTORY:
        rustanl     10-Sep-1991     Created

********************************************************************/

VOID STARTUP_DIALOG::OnTimerNotification( TIMER_ID tid )
{
    if ( tid == _timer.QueryID())
    {
        Dismiss();
        return;
    }

    // call parent
    TIMER_CALLOUT::OnTimerNotification( tid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\propdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    propdlg.cxx

    FILE HISTORY:
        JonN        17-Jul-1991 Created
        rustanl     13-Aug-1991 Moved to $(UI)\admin\common\src\adminapp\adminapp
        JonN        15-Aug-1991 Split BASEPROP_DLG and PROP_DLG
                                Added LOCATION member
        JonN        26-Aug-1991 code review changes
        JonN        15-Nov-1991 Added CancelToCloseButton()
        JonN        18-Aug-1992 DisplayError fixes (1070)
        JonN        18-Aug-1992 DisplayError now calls new form of MsgPopup
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>
#include <dbgstr.hxx>

#define INCL_BLT_WINDOW
#define